import {
  Comment,
  createApp,
  defineComponent,
  h,
  toRaw,
  version
} from "./chunk-IYPBRSHA.js";
import {
  __export
} from "./chunk-IER6VNQZ.js";

// ../../../../../../node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// ../../../../../../node_modules/devextreme/esm/core/utils/type.js
var types = {
  "[object Array]": "array",
  "[object Date]": "date",
  "[object Object]": "object",
  "[object String]": "string"
};
var type = function(object) {
  if (null === object) {
    return "null";
  }
  const typeOfObject = Object.prototype.toString.call(object);
  return "object" === typeof object ? types[typeOfObject] || "object" : typeof object;
};
var isBoolean = function(object) {
  return "boolean" === typeof object;
};
var isExponential = function(value2) {
  return isNumeric(value2) && -1 !== value2.toString().indexOf("e");
};
var isDate = function(object) {
  return "date" === type(object);
};
var isDefined = function(object) {
  return null !== object && void 0 !== object;
};
var isFunction = function(object) {
  return "function" === typeof object;
};
var isString = function(object) {
  return "string" === typeof object;
};
var isNumeric = function(object) {
  return "number" === typeof object && isFinite(object) || !isNaN(object - parseFloat(object));
};
var isObject = function(object) {
  return "object" === type(object);
};
var isEmptyObject = function(object) {
  let property;
  for (property in object) {
    return false;
  }
  return true;
};
var isPlainObject = function(object) {
  if (!object || "object" !== type(object)) {
    return false;
  }
  const proto = Object.getPrototypeOf(object);
  if (!proto) {
    return true;
  }
  const ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return "function" === typeof ctor && Object.toString.call(ctor) === Object.toString.call(Object);
};
var isPrimitive = function(value2) {
  return -1 === ["object", "array", "function"].indexOf(type(value2));
};
var isWindow = function(object) {
  return null != object && object === object.window;
};
var isRenderer = function(object) {
  return !!object && !!(object.jquery || object.dxRenderer);
};
var isPromise = function(object) {
  return !!object && isFunction(object.then);
};
var isDeferred = function(object) {
  return !!object && isFunction(object.done) && isFunction(object.fail);
};
var isEvent = function(object) {
  return !!(object && object.preventDefault);
};

// ../../../../../../node_modules/devextreme/esm/core/utils/extend.js
var extendFromObject = function(target, source, overrideExistingValues) {
  target = target || {};
  for (const prop in source) {
    if (Object.prototype.hasOwnProperty.call(source, prop)) {
      const value2 = source[prop];
      if (!(prop in target) || overrideExistingValues) {
        target[prop] = value2;
      }
    }
  }
  return target;
};
var extend = function(target) {
  target = target || {};
  let i = 1;
  let deep = false;
  if ("boolean" === typeof target) {
    deep = target;
    target = arguments[1] || {};
    i++;
  }
  for (; i < arguments.length; i++) {
    const source = arguments[i];
    if (null == source) {
      continue;
    }
    for (const key in source) {
      const targetValue = target[key];
      const sourceValue = source[key];
      let sourceValueIsArray = false;
      let clone2;
      if ("__proto__" === key || "constructor" === key || target === sourceValue) {
        continue;
      }
      if (deep && sourceValue && (isPlainObject(sourceValue) || (sourceValueIsArray = Array.isArray(sourceValue)))) {
        if (sourceValueIsArray) {
          clone2 = targetValue && Array.isArray(targetValue) ? targetValue : [];
        } else {
          clone2 = targetValue && isPlainObject(targetValue) ? targetValue : {};
        }
        target[key] = extend(deep, clone2, sourceValue);
      } else if (void 0 !== sourceValue) {
        target[key] = sourceValue;
      }
    }
  }
  return target;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/iterator.js
var map = (values, callback) => {
  if (Array.isArray(values)) {
    return values.map(callback);
  }
  const result2 = [];
  for (const key in values) {
    result2.push(callback(values[key], key));
  }
  return result2;
};
var each = (values, callback) => {
  if (!values) {
    return;
  }
  if ("length" in values) {
    for (let i = 0; i < values.length; i++) {
      if (false === callback.call(values[i], i, values[i])) {
        break;
      }
    }
  } else {
    for (const key in values) {
      if (false === callback.call(values[key], key, values[key])) {
        break;
      }
    }
  }
  return values;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/console.js
var noop = function() {
};
var getConsoleMethod = function(method) {
  if ("undefined" === typeof console || !isFunction(console[method])) {
    return noop;
  }
  return console[method].bind(console);
};
var logger = {
  log: getConsoleMethod("log"),
  info: getConsoleMethod("info"),
  warn: getConsoleMethod("warn"),
  error: getConsoleMethod("error")
};
var debug = function() {
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  return {
    assert,
    assertParam: function(parameter, message) {
      assert(null !== parameter && void 0 !== parameter, message);
    }
  };
}();

// ../../../../../../node_modules/devextreme/esm/core/utils/string.js
var encodeHtml = function() {
  const encodeRegExp = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
  return function(str) {
    return String(str).replace(encodeRegExp[0], "&amp;").replace(encodeRegExp[1], "&quot;").replace(encodeRegExp[2], "&#39;").replace(encodeRegExp[3], "&lt;").replace(encodeRegExp[4], "&gt;");
  };
}();
var splitQuad = function(raw) {
  switch (typeof raw) {
    case "string":
      return raw.split(/\s+/, 4);
    case "object":
      return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
    case "number":
      return [raw];
    default:
      return raw;
  }
};
var quadToObject = function(raw) {
  const quad = splitQuad(raw);
  let left = parseInt(quad && quad[0], 10);
  let top = parseInt(quad && quad[1], 10);
  let right = parseInt(quad && quad[2], 10);
  let bottom = parseInt(quad && quad[3], 10);
  if (!isFinite(left)) {
    left = 0;
  }
  if (!isFinite(top)) {
    top = left;
  }
  if (!isFinite(right)) {
    right = left;
  }
  if (!isFinite(bottom)) {
    bottom = top;
  }
  return {
    top,
    right,
    bottom,
    left
  };
};
function format(template) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  if (isFunction(template)) {
    return template(...values);
  }
  values.forEach((value2, index2) => {
    if (isString(value2)) {
      value2 = value2.replace(/\$/g, "$$$$");
    }
    const placeholderReg = new RegExp("\\{" + index2 + "\\}", "gm");
    template = template.replace(placeholderReg, value2);
  });
  return template;
}
var isEmpty = function() {
  const SPACE_REGEXP = /\s/g;
  return function(text) {
    return !text || !text.replace(SPACE_REGEXP, "");
  };
}();

// ../../../../../../node_modules/devextreme/esm/core/version.js
var version2 = "24.1.6";
var fullVersion = "24.1.6";

// ../../../../../../node_modules/devextreme/esm/core/utils/error.js
var ERROR_URL = "https://js.devexpress.com/error/" + version2.split(".").slice(0, 2).join("_") + "/";
function error_default(baseErrors, errors2) {
  const exports = {
    ERROR_MESSAGES: extend(errors2, baseErrors),
    Error: function() {
      return function(args) {
        const id = args[0];
        args = args.slice(1);
        const details = formatDetails(id, args);
        const url = getErrorUrl(id);
        const message = formatMessage(id, details);
        return extend(new Error(message), {
          __id: id,
          __details: details,
          url
        });
      }([].slice.call(arguments));
    },
    log: function(id) {
      let method = "log";
      if (/^E\d+$/.test(id)) {
        method = "error";
      } else if (/^W\d+$/.test(id)) {
        method = "warn";
      }
      logger[method]("log" === method ? id : function(args) {
        const id2 = args[0];
        args = args.slice(1);
        return formatMessage(id2, formatDetails(id2, args));
      }([].slice.call(arguments)));
    }
  };
  function formatDetails(id, args) {
    args = [exports.ERROR_MESSAGES[id]].concat(args);
    return format.apply(this, args).replace(/\.*\s*?$/, "");
  }
  function formatMessage(id, details) {
    const kind = null !== id && void 0 !== id && id.startsWith("W") ? "warning" : "error";
    return format.apply(this, ["{0} - {1}.\n\nFor additional information on this {2} message, see: {3}", id, details, kind, getErrorUrl(id)]);
  }
  function getErrorUrl(id) {
    return ERROR_URL + id;
  }
  return exports;
}

// ../../../../../../node_modules/devextreme/esm/core/errors.js
var errors_default = error_default({
  E0001: "Method is not implemented",
  E0002: "Member name collision: {0}",
  E0003: "A class must be instantiated using the 'new' keyword",
  E0004: "The NAME property of the component is not specified",
  E0005: "Unknown device",
  E0006: "Unknown endpoint key is requested",
  E0007: "'Invalidate' method is called outside the update transaction",
  E0008: "Type of the option name is not appropriate to create an action",
  E0009: "Component '{0}' has not been initialized for an element",
  E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
  E0011: "Unknown animation type '{0}'",
  E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
  E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
  E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
  E0015: "Queued task returned an unexpected result",
  E0017: "Event namespace is not defined",
  E0018: "DevExpress.ui.DevExpressPopup widget is required",
  E0020: "Template engine '{0}' is not supported",
  E0021: "Unknown theme is set: {0}",
  E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
  E0023: "Template name is not specified",
  E0024: "DevExtreme bundle already included",
  E0025: "Unexpected argument type",
  E0100: "Unknown validation type is detected",
  E0101: "Misconfigured range validation rule is detected",
  E0102: "Misconfigured comparison validation rule is detected",
  E0103: "validationCallback of an asynchronous rule should return a jQuery or a native promise",
  E0110: "Unknown validation group is detected",
  E0120: "Adapter for a DevExpressValidator component cannot be configured",
  E0121: "The 'customItem' parameter of the 'onCustomItemCreating' function is empty or contains invalid data. Assign a custom object or a Promise that is resolved after the item is created.",
  W0000: "'{0}' is deprecated in {1}. {2}",
  W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
  W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
  W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
  W0004: "Timeout for theme loading is over: {0}",
  W0005: "'{0}' event is deprecated in {1}. {2}",
  W0006: "Invalid recurrence rule: '{0}'",
  W0007: "'{0}' Globalize culture is not defined",
  W0008: "Invalid view name: '{0}'",
  W0009: "Invalid time zone name: '{0}'",
  W0010: "{0} is deprecated in {1}. {2}",
  W0011: "Number parsing is invoked while the parser is not defined",
  W0012: "Date parsing is invoked while the parser is not defined",
  W0013: "'{0}' file is deprecated in {1}. {2}",
  W0014: "{0} - '{1}' type is deprecated in {2}. {3}",
  W0015: "Instead of returning a value from the '{0}' function, write it into the '{1}' field of the function's parameter.",
  W0016: 'The "{0}" option does not accept the "{1}" value since v{2}. {3}.',
  W0017: 'Setting the "{0}" property with a function is deprecated since v21.2',
  W0018: 'Setting the "position" property with a function is deprecated since v21.2',
  W0019: "DevExtreme: Unable to Locate a Valid License Key.\n\nIf you are using a 30-day trial version of DevExtreme, you must uninstall all copies of DevExtreme once your 30-day trial period expires. For terms and conditions that govern use of DevExtreme UI components/libraries, please refer to the DevExtreme End User License Agreement: https://js.devexpress.com/EULAs/DevExtremeComplete.\n\nTo use DevExtreme in a commercial project, you must purchase a license. For pricing/licensing options, please visit: https://js.devexpress.com/Buy.\n\nIf you have licensing-related questions or need help with a purchase, please email clientservices@devexpress.com.\n\n",
  W0020: "DevExtreme: License Key Has Expired.\n\nA mismatch exists between the license key used and the DevExtreme version referenced in this project.\n\nTo proceed, you can:\n• use a version of DevExtreme linked to your license key: https://www.devexpress.com/ClientCenter/DownloadManager\n• renew your DevExpress Subscription: https://www.devexpress.com/buy/renew (once you renew your subscription, you will be entitled to product updates and support service as defined in the DevExtreme End User License Agreement)\n\nIf you have licensing-related questions or need help with a renewal, please email clientservices@devexpress.com.\n\n",
  W0021: "DevExtreme: License Key Verification Has Failed.\n\nTo verify your DevExtreme license, make certain to specify a correct key in the GlobalConfig. If you continue to encounter this error, please visit https://www.devexpress.com/ClientCenter/DownloadManager to obtain a valid license key.\n\nIf you have a valid license and this problem persists, please submit a support ticket via the DevExpress Support Center. We will be happy to follow-up: https://supportcenter.devexpress.com/ticket/create.\n\n",
  W0022: "DevExtreme: Pre-release software. Not suitable for commercial use.\n\nPre-release software may contain deficiencies and as such, should not be considered for use or integrated in any mission critical application.\n\n",
  W0023: "DevExtreme: the following 'devextreme' package version does not match versions of other DevExpress products used in this application:\n\n{0}\n\nInteroperability between different versions of the products listed herein cannot be guaranteed.\n\n"
});

// ../../../../../../node_modules/devextreme/esm/core/class.js
var wrapOverridden = function(baseProto, methodName, method) {
  return function() {
    const prevCallBase = this.callBase;
    this.callBase = baseProto[methodName];
    try {
      return method.apply(this, arguments);
    } finally {
      this.callBase = prevCallBase;
    }
  };
};
var clonePrototype = function(obj) {
  const func = function() {
  };
  func.prototype = obj.prototype;
  return new func();
};
var redefine = function(members) {
  const that = this;
  let overridden;
  let memberName;
  let member;
  if (!members) {
    return that;
  }
  for (memberName in members) {
    member = members[memberName];
    overridden = "function" === typeof that.prototype[memberName] && "function" === typeof member;
    that.prototype[memberName] = overridden ? wrapOverridden(that.parent.prototype, memberName, member) : member;
  }
  return that;
};
var include = function() {
  const classObj = this;
  let argument;
  let name2;
  let i;
  const hasClassObjOwnProperty = Object.prototype.hasOwnProperty.bind(classObj);
  const isES6Class = !hasClassObjOwnProperty("_includedCtors") && !hasClassObjOwnProperty("_includedPostCtors");
  if (isES6Class) {
    classObj._includedCtors = classObj._includedCtors.slice(0);
    classObj._includedPostCtors = classObj._includedPostCtors.slice(0);
  }
  for (i = 0; i < arguments.length; i++) {
    argument = arguments[i];
    if (argument.ctor) {
      classObj._includedCtors.push(argument.ctor);
    }
    if (argument.postCtor) {
      classObj._includedPostCtors.push(argument.postCtor);
    }
    for (name2 in argument) {
      if ("ctor" === name2 || "postCtor" === name2 || "default" === name2) {
        continue;
      }
      classObj.prototype[name2] = argument[name2];
    }
  }
  return classObj;
};
var subclassOf = function(parentClass) {
  const hasParentProperty = Object.prototype.hasOwnProperty.bind(this)("parent");
  const isES6Class = !hasParentProperty && this.parent;
  if (isES6Class) {
    const baseClass = Object.getPrototypeOf(this);
    return baseClass === parentClass || baseClass.subclassOf(parentClass);
  } else {
    if (this.parent === parentClass) {
      return true;
    }
    if (!this.parent || !this.parent.subclassOf) {
      return false;
    }
    return this.parent.subclassOf(parentClass);
  }
};
var abstract = function() {
  throw errors_default.Error("E0001");
};
var copyStatic = function() {
  const hasOwn = Object.prototype.hasOwnProperty;
  return function(source, destination) {
    for (const key in source) {
      if (!hasOwn.call(source, key)) {
        return;
      }
      destination[key] = source[key];
    }
  };
}();
var classImpl = function() {
};
classImpl.inherit = function(members) {
  const inheritor = function() {
    if (!this || isWindow(this) || "function" !== typeof this.constructor) {
      throw errors_default.Error("E0003");
    }
    const instance = this;
    const ctor = instance.ctor;
    const includedCtors = instance.constructor._includedCtors;
    const includedPostCtors = instance.constructor._includedPostCtors;
    let i;
    for (i = 0; i < includedCtors.length; i++) {
      includedCtors[i].call(instance);
    }
    if (ctor) {
      ctor.apply(instance, arguments);
    }
    for (i = 0; i < includedPostCtors.length; i++) {
      includedPostCtors[i].call(instance);
    }
  };
  inheritor.prototype = clonePrototype(this);
  copyStatic(this, inheritor);
  inheritor.inherit = this.inherit;
  inheritor.abstract = abstract;
  inheritor.redefine = redefine;
  inheritor.include = include;
  inheritor.subclassOf = subclassOf;
  inheritor.parent = this;
  inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
  inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
  inheritor.prototype.constructor = inheritor;
  inheritor.redefine(members);
  return inheritor;
};
classImpl.abstract = abstract;
var class_default = classImpl;

// ../../../../../../node_modules/devextreme/esm/core/utils/dependency_injector.js
function dependency_injector_default(object) {
  const BaseClass = class_default.inherit(object);
  let InjectedClass = BaseClass;
  let instance = new InjectedClass(object);
  const initialFields = {};
  const injectFields = function(injectionObject, initial) {
    each(injectionObject, function(key) {
      if (isFunction(instance[key])) {
        if (initial || !object[key]) {
          object[key] = function() {
            return instance[key].apply(object, arguments);
          };
        }
      } else {
        if (initial) {
          initialFields[key] = object[key];
        }
        object[key] = instance[key];
      }
    });
  };
  injectFields(object, true);
  object.inject = function(injectionObject) {
    InjectedClass = InjectedClass.inherit(injectionObject);
    instance = new InjectedClass();
    injectFields(injectionObject);
  };
  object.resetInjection = function() {
    extend(object, initialFields);
    InjectedClass = BaseClass;
    instance = new BaseClass();
  };
  return object;
}

// ../../../../../../node_modules/devextreme/esm/core/config.js
var config = {
  rtlEnabled: false,
  defaultCurrency: "USD",
  defaultUseCurrencyAccountingStyle: true,
  oDataFilterToLower: true,
  serverDecimalSeparator: ".",
  decimalSeparator: ".",
  thousandsSeparator: ",",
  forceIsoDateParsing: true,
  wrapActionsBeforeExecute: true,
  useLegacyStoreResult: false,
  useJQuery: void 0,
  editorStylingMode: void 0,
  useLegacyVisibleIndex: false,
  floatingActionButtonConfig: {
    icon: "add",
    closeIcon: "close",
    label: "",
    position: {
      at: "right bottom",
      my: "right bottom",
      offset: {
        x: -16,
        y: -16
      }
    },
    maxSpeedDialActionCount: 5,
    shading: false,
    direction: "auto"
  },
  optionsParser: (optionsString) => {
    if ("{" !== optionsString.trim().charAt(0)) {
      optionsString = "{" + optionsString + "}";
    }
    try {
      return JSON.parse(optionsString);
    } catch (ex) {
      try {
        return JSON.parse(normalizeToJSONString(optionsString));
      } catch (exNormalize) {
        throw errors_default.Error("E3018", ex, optionsString);
      }
    }
  }
};
var normalizeToJSONString = (optionsString) => optionsString.replace(/'/g, '"').replace(/,\s*([\]}])/g, "$1").replace(/([{,])\s*([^":\s]+)\s*:/g, '$1"$2":');
var deprecatedFields = ["decimalSeparator", "thousandsSeparator"];
var configMethod = function() {
  if (!arguments.length) {
    return config;
  }
  const newConfig = arguments.length <= 0 ? void 0 : arguments[0];
  deprecatedFields.forEach((deprecatedField) => {
    if (newConfig[deprecatedField]) {
      const message = `Now, the ${deprecatedField} is selected based on the specified locale.`;
      errors_default.log("W0003", "config", deprecatedField, "19.2", message);
    }
  });
  extend(config, newConfig);
};
if ("undefined" !== typeof DevExpress && DevExpress.config) {
  configMethod(DevExpress.config);
}
var config_default = configMethod;

// ../../../../../../node_modules/devextreme/esm/core/guid.js
var Guid = class_default.inherit({
  ctor: function(value2) {
    if (value2) {
      value2 = String(value2);
    }
    this._value = this._normalize(value2 || this._generate());
  },
  _normalize: function(value2) {
    value2 = value2.replace(/[^a-f0-9]/gi, "").toLowerCase();
    while (value2.length < 32) {
      value2 += "0";
    }
    return [value2.substr(0, 8), value2.substr(8, 4), value2.substr(12, 4), value2.substr(16, 4), value2.substr(20, 12)].join("-");
  },
  _generate: function() {
    let value2 = "";
    for (let i = 0; i < 32; i++) {
      value2 += Math.round(15 * Math.random()).toString(16);
    }
    return value2;
  },
  toString: function() {
    return this._value;
  },
  valueOf: function() {
    return this._value;
  },
  toJSON: function() {
    return this._value;
  }
});
var guid_default = Guid;

// ../../../../../../node_modules/devextreme/esm/core/utils/callbacks.js
var Callback = function(options2) {
  this._options = options2 || {};
  this._list = [];
  this._queue = [];
  this._firing = false;
  this._fired = false;
  this._firingIndexes = [];
};
Callback.prototype._fireCore = function(context2, args) {
  const firingIndexes = this._firingIndexes;
  const list = this._list;
  const stopOnFalse = this._options.stopOnFalse;
  const step = firingIndexes.length;
  for (firingIndexes[step] = 0; firingIndexes[step] < list.length; firingIndexes[step]++) {
    const result2 = list[firingIndexes[step]].apply(context2, args);
    if (false === result2 && stopOnFalse) {
      break;
    }
  }
  firingIndexes.pop();
};
Callback.prototype.add = function(fn) {
  if ("function" === typeof fn && (!this._options.unique || !this.has(fn))) {
    this._list.push(fn);
  }
  return this;
};
Callback.prototype.remove = function(fn) {
  const list = this._list;
  const firingIndexes = this._firingIndexes;
  const index2 = list.indexOf(fn);
  if (index2 > -1) {
    list.splice(index2, 1);
    if (this._firing && firingIndexes.length) {
      for (let step = 0; step < firingIndexes.length; step++) {
        if (index2 <= firingIndexes[step]) {
          firingIndexes[step]--;
        }
      }
    }
  }
  return this;
};
Callback.prototype.has = function(fn) {
  const list = this._list;
  return fn ? list.indexOf(fn) > -1 : !!list.length;
};
Callback.prototype.empty = function(fn) {
  this._list = [];
  return this;
};
Callback.prototype.fireWith = function(context2, args) {
  const queue = this._queue;
  args = args || [];
  args = args.slice ? args.slice() : args;
  if (this._options.syncStrategy) {
    this._firing = true;
    this._fireCore(context2, args);
  } else {
    queue.push([context2, args]);
    if (this._firing) {
      return;
    }
    this._firing = true;
    while (queue.length) {
      const memory = queue.shift();
      this._fireCore(memory[0], memory[1]);
    }
  }
  this._firing = false;
  this._fired = true;
  return this;
};
Callback.prototype.fire = function() {
  this.fireWith(this, arguments);
};
Callback.prototype.fired = function() {
  return this._fired;
};
var Callbacks = function(options2) {
  return new Callback(options2);
};
var callbacks_default = Callbacks;

// ../../../../../../node_modules/devextreme/esm/core/utils/deferred.js
var deferredConfig = [{
  method: "resolve",
  handler: "done",
  state: "resolved"
}, {
  method: "reject",
  handler: "fail",
  state: "rejected"
}, {
  method: "notify",
  handler: "progress"
}];
var DeferredObj = function() {
  const that = this;
  this._state = "pending";
  this._promise = {};
  deferredConfig.forEach((function(config3) {
    const methodName = config3.method;
    this[methodName + "Callbacks"] = callbacks_default();
    this[methodName] = (function() {
      return this[methodName + "With"](this._promise, arguments);
    }).bind(this);
    this._promise[config3.handler] = function(handler) {
      if (!handler) {
        return this;
      }
      const callbacks2 = that[methodName + "Callbacks"];
      if (callbacks2.fired()) {
        handler.apply(that[methodName + "Context"], that[methodName + "Args"]);
      } else {
        callbacks2.add((function(context2, args) {
          handler.apply(context2, args);
        }).bind(this));
      }
      return this;
    };
  }).bind(this));
  this._promise.always = function(handler) {
    return this.done(handler).fail(handler);
  };
  this._promise.catch = function(handler) {
    return this.then(null, handler);
  };
  this._promise.then = function(resolve, reject) {
    const result2 = new DeferredObj();
    ["done", "fail"].forEach((function(method) {
      const callback = "done" === method ? resolve : reject;
      this[method](function() {
        if (!callback) {
          result2["done" === method ? "resolve" : "reject"].apply(this, arguments);
          return;
        }
        const callbackResult = callback && callback.apply(this, arguments);
        if (isDeferred(callbackResult)) {
          callbackResult.done(result2.resolve).fail(result2.reject);
        } else if (isPromise(callbackResult)) {
          callbackResult.then(result2.resolve, result2.reject);
        } else {
          result2.resolve.apply(this, isDefined(callbackResult) ? [callbackResult] : arguments);
        }
      });
    }).bind(this));
    return result2.promise();
  };
  this._promise.state = function() {
    return that._state;
  };
  this._promise.promise = function(args) {
    return args ? extend(args, that._promise) : that._promise;
  };
  this._promise.promise(this);
};
deferredConfig.forEach(function(config3) {
  const methodName = config3.method;
  const state = config3.state;
  DeferredObj.prototype[methodName + "With"] = function(context2, args) {
    const callbacks2 = this[methodName + "Callbacks"];
    if ("pending" === this.state()) {
      this[methodName + "Args"] = args;
      this[methodName + "Context"] = context2;
      if (state) {
        this._state = state;
      }
      callbacks2.fire(context2, args);
      if ("pending" !== state) {
        this.resolveCallbacks.empty();
        this.rejectCallbacks.empty();
      }
    }
    return this;
  };
});
function fromPromise(promise, context2) {
  if (isDeferred(promise)) {
    return promise;
  } else if (isPromise(promise)) {
    const d = new DeferredObj();
    promise.then(function() {
      d.resolveWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    }, function() {
      d.rejectWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    });
    return d;
  }
  return new DeferredObj().resolveWith(context2, [promise]);
}
var whenFunc = function() {
  if (1 === arguments.length) {
    return fromPromise(arguments[0]);
  }
  const values = [].slice.call(arguments);
  const contexts = [];
  let resolvedCount = 0;
  const deferred = new DeferredObj();
  const updateState = function(i) {
    return function(value2) {
      contexts[i] = this;
      values[i] = arguments.length > 1 ? [].slice.call(arguments) : value2;
      resolvedCount++;
      if (resolvedCount === values.length) {
        deferred.resolveWith(contexts, values);
      }
    };
  };
  for (let i = 0; i < values.length; i++) {
    if (isDeferred(values[i])) {
      values[i].promise().done(updateState(i)).fail(deferred.reject);
    } else {
      resolvedCount++;
    }
  }
  if (resolvedCount === values.length) {
    deferred.resolveWith(contexts, values);
  }
  return deferred.promise();
};
function Deferred() {
  return new DeferredObj();
}
function when() {
  return whenFunc.apply(this, arguments);
}

// ../../../../../../node_modules/devextreme/esm/core/utils/variable_wrapper.js
var variable_wrapper_default = dependency_injector_default({
  isWrapped: function() {
    return false;
  },
  isWritableWrapped: function() {
    return false;
  },
  wrap: function(value2) {
    return value2;
  },
  unwrap: function(value2) {
    return value2;
  },
  assign: function() {
    logger.error("Method 'assign' should not be used for not wrapped variables. Use 'isWrapped' method for ensuring.");
  }
});

// ../../../../../../node_modules/devextreme/esm/core/utils/object.js
var clone = function() {
  function Clone() {
  }
  return function(obj) {
    Clone.prototype = obj;
    return new Clone();
  };
}();
var orderEach = function(map2, func) {
  const keys = [];
  let key;
  let i;
  for (key in map2) {
    if (Object.prototype.hasOwnProperty.call(map2, key)) {
      keys.push(key);
    }
  }
  keys.sort(function(x, y) {
    const isNumberX = isNumeric(x);
    const isNumberY = isNumeric(y);
    if (isNumberX && isNumberY) {
      return x - y;
    }
    if (isNumberX && !isNumberY) {
      return -1;
    }
    if (!isNumberX && isNumberY) {
      return 1;
    }
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  });
  for (i = 0; i < keys.length; i++) {
    key = keys[i];
    func(key, map2[key]);
  }
};
var assignValueToProperty = function(target, property, value2, assignByReference) {
  if (!assignByReference && variable_wrapper_default.isWrapped(target[property])) {
    variable_wrapper_default.assign(target[property], value2);
  } else {
    target[property] = value2;
  }
};
var deepExtendArraySafe = function(target, changes, extendComplexObject, assignByReference) {
  let prevValue;
  let newValue;
  for (const name2 in changes) {
    prevValue = target[name2];
    newValue = changes[name2];
    if ("__proto__" === name2 || "constructor" === name2 || target === newValue) {
      continue;
    }
    if (isPlainObject(newValue)) {
      const goDeeper = extendComplexObject ? isObject(prevValue) : isPlainObject(prevValue);
      newValue = deepExtendArraySafe(goDeeper ? prevValue : {}, newValue, extendComplexObject, assignByReference);
    }
    if (void 0 !== newValue && prevValue !== newValue) {
      assignValueToProperty(target, name2, newValue, assignByReference);
    }
  }
  return target;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/data.js
var unwrapVariable = variable_wrapper_default.unwrap;
var isWrapped = variable_wrapper_default.isWrapped;
var assign = variable_wrapper_default.assign;
var bracketsToDots = function(expr) {
  return expr.replace(/\[/g, ".").replace(/\]/g, "");
};
var getPathParts = function(name2) {
  return bracketsToDots(name2).split(".");
};
var readPropValue = function(obj, propName, options2) {
  options2 = options2 || {};
  if ("this" === propName) {
    return unwrap(obj, options2);
  }
  return unwrap(obj[propName], options2);
};
var assignPropValue = function(obj, propName, value2, options2) {
  if ("this" === propName) {
    throw new errors_default.Error("E4016");
  }
  const propValue = obj[propName];
  if (options2.unwrapObservables && isWrapped(propValue)) {
    assign(propValue, value2);
  } else {
    obj[propName] = value2;
  }
};
var prepareOptions = function(options2) {
  options2 = options2 || {};
  options2.unwrapObservables = void 0 !== options2.unwrapObservables ? options2.unwrapObservables : true;
  return options2;
};
function unwrap(value2, options2) {
  return options2.unwrapObservables ? unwrapVariable(value2) : value2;
}
var compileGetter = function(expr) {
  if (arguments.length > 1) {
    expr = [].slice.call(arguments);
  }
  if (!expr || "this" === expr) {
    return function(obj) {
      return obj;
    };
  }
  if ("string" === typeof expr) {
    const path = getPathParts(expr);
    return function(obj, options2) {
      options2 = prepareOptions(options2);
      const functionAsIs = options2.functionsAsIs;
      const hasDefaultValue = "defaultValue" in options2;
      let current2 = unwrap(obj, options2);
      for (let i = 0; i < path.length; i++) {
        if (!current2) {
          if (null == current2 && hasDefaultValue) {
            return options2.defaultValue;
          }
          break;
        }
        const pathPart = path[i];
        if (hasDefaultValue && isObject(current2) && !(pathPart in current2)) {
          return options2.defaultValue;
        }
        let next = unwrap(current2[pathPart], options2);
        if (!functionAsIs && isFunction(next)) {
          next = next.call(current2);
        }
        current2 = next;
      }
      return current2;
    };
  }
  if (Array.isArray(expr)) {
    return combineGetters(expr);
  }
  if (isFunction(expr)) {
    return expr;
  }
};
function combineGetters(getters) {
  const compiledGetters = {};
  for (let i = 0, l = getters.length; i < l; i++) {
    const getter = getters[i];
    compiledGetters[getter] = compileGetter(getter);
  }
  return function(obj, options2) {
    let result2;
    each(compiledGetters, function(name2) {
      const value2 = this(obj, options2);
      if (void 0 === value2) {
        return;
      }
      let current2 = result2 || (result2 = {});
      const path = name2.split(".");
      const last = path.length - 1;
      for (let i = 0; i < last; i++) {
        const pathItem = path[i];
        if (!(pathItem in current2)) {
          current2[pathItem] = {};
        }
        current2 = current2[pathItem];
      }
      current2[path[last]] = value2;
    });
    return result2;
  };
}
function toLowerCase(value2, options2) {
  return null !== options2 && void 0 !== options2 && options2.locale ? value2.toLocaleLowerCase(options2.locale) : value2.toLowerCase();
}
function toUpperCase(value2, options2) {
  return null !== options2 && void 0 !== options2 && options2.locale ? value2.toLocaleUpperCase(options2.locale) : value2.toUpperCase();
}
var ensurePropValueDefined = function(obj, propName, value2, options2) {
  if (isDefined(value2)) {
    return value2;
  }
  const newValue = {};
  assignPropValue(obj, propName, newValue, options2);
  return newValue;
};
var compileSetter = function(expr) {
  expr = getPathParts(expr || "this");
  const lastLevelIndex = expr.length - 1;
  return function(obj, value2, options2) {
    options2 = prepareOptions(options2);
    let currentValue = unwrap(obj, options2);
    expr.forEach(function(propertyName, levelIndex) {
      let propertyValue = readPropValue(currentValue, propertyName, options2);
      const isPropertyFunc = !options2.functionsAsIs && isFunction(propertyValue) && !isWrapped(propertyValue);
      if (levelIndex === lastLevelIndex) {
        if (options2.merge && isPlainObject(value2) && (!isDefined(propertyValue) || isPlainObject(propertyValue))) {
          propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options2);
          deepExtendArraySafe(propertyValue, value2, false, true);
        } else if (isPropertyFunc) {
          currentValue[propertyName](value2);
        } else {
          assignPropValue(currentValue, propertyName, value2, options2);
        }
      } else {
        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options2);
        if (isPropertyFunc) {
          propertyValue = propertyValue.call(currentValue);
        }
        currentValue = propertyValue;
      }
    });
  };
};
var toComparable = function(value2, caseSensitive) {
  var _options$collatorOpti;
  let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
  if (value2 instanceof Date) {
    return value2.getTime();
  }
  if (value2 && value2 instanceof class_default && value2.valueOf) {
    return value2.valueOf();
  }
  const isCaseSensitive = "case" === (null === options2 || void 0 === options2 || null === (_options$collatorOpti = options2.collatorOptions) || void 0 === _options$collatorOpti ? void 0 : _options$collatorOpti.sensitivity) || caseSensitive;
  if (!isCaseSensitive && "string" === typeof value2) {
    var _options$collatorOpti2, _options$locale;
    if ("base" === (null === options2 || void 0 === options2 || null === (_options$collatorOpti2 = options2.collatorOptions) || void 0 === _options$collatorOpti2 ? void 0 : _options$collatorOpti2.sensitivity)) {
      const REMOVE_DIACRITICAL_MARKS_REGEXP = /[\u0300-\u036f]/g;
      value2 = value2.normalize("NFD").replace(REMOVE_DIACRITICAL_MARKS_REGEXP, "");
    }
    const locale = null === options2 || void 0 === options2 || null === (_options$locale = options2.locale) || void 0 === _options$locale ? void 0 : _options$locale.toLowerCase();
    const useUpperCase = locale && !!["hy", "el"].find((code) => locale === code || locale.startsWith(`${code}-`));
    return (useUpperCase ? toUpperCase : toLowerCase)(value2, options2);
  }
  return value2;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/common.js
var ensureDefined = function(value2, defaultValue) {
  return isDefined(value2) ? value2 : defaultValue;
};
var executeAsync = function(action, context2) {
  const deferred = new Deferred();
  const normalizedContext = context2 || this;
  const task = {
    promise: deferred.promise(),
    abort: function() {
      clearTimeout(timerId);
      deferred.rejectWith(normalizedContext);
    }
  };
  const timerId = (arguments[2] || setTimeout)(function() {
    const result2 = action.call(normalizedContext);
    if (result2 && result2.done && isFunction(result2.done)) {
      result2.done(function() {
        deferred.resolveWith(normalizedContext);
      });
    } else {
      deferred.resolveWith(normalizedContext);
    }
  }, "number" === typeof context2 ? context2 : 0);
  return task;
};
var delayedFuncs = [];
var delayedNames = [];
var delayedDeferreds = [];
var executingName;
var deferExecute = function(name2, func, deferred) {
  if (executingName && executingName !== name2) {
    delayedFuncs.push(func);
    delayedNames.push(name2);
    deferred = deferred || new Deferred();
    delayedDeferreds.push(deferred);
    return deferred;
  } else {
    const oldExecutingName = executingName;
    const currentDelayedCount = delayedDeferreds.length;
    executingName = name2;
    let result2 = func();
    if (!result2) {
      if (delayedDeferreds.length > currentDelayedCount) {
        result2 = when.apply(this, delayedDeferreds.slice(currentDelayedCount));
      } else if (deferred) {
        deferred.resolve();
      }
    }
    executingName = oldExecutingName;
    if (deferred && result2 && result2.done) {
      result2.done(deferred.resolve).fail(deferred.reject);
    }
    if (!executingName && delayedFuncs.length) {
      ("render" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());
    }
    return result2 || when();
  }
};
var deferRender = function(func, deferred) {
  return deferExecute("render", func, deferred);
};
var deferUpdate = function(func, deferred) {
  return deferExecute("update", func, deferred);
};
var deferRenderer = function(func) {
  return function() {
    const that = this;
    return deferExecute("render", function() {
      return func.call(that);
    });
  };
};
var deferUpdater = function(func) {
  return function() {
    const that = this;
    return deferExecute("update", function() {
      return func.call(that);
    });
  };
};
var findBestMatches = function(targetFilter, items, mapFn) {
  const bestMatches = [];
  let maxMatchCount = 0;
  each(items, (index2, itemSrc) => {
    let matchCount = 0;
    const item = mapFn ? mapFn(itemSrc) : itemSrc;
    each(targetFilter, (paramName, targetValue) => {
      const value2 = item[paramName];
      if (void 0 === value2) {
        return;
      }
      if (match(value2, targetValue)) {
        matchCount++;
        return;
      }
      matchCount = -1;
      return false;
    });
    if (matchCount < maxMatchCount) {
      return;
    }
    if (matchCount > maxMatchCount) {
      bestMatches.length = 0;
      maxMatchCount = matchCount;
    }
    bestMatches.push(itemSrc);
  });
  return bestMatches;
};
var match = function(value2, targetValue) {
  if (Array.isArray(value2) && Array.isArray(targetValue)) {
    let mismatch = false;
    each(value2, (index2, valueItem) => {
      if (valueItem !== targetValue[index2]) {
        mismatch = true;
        return false;
      }
    });
    if (mismatch) {
      return false;
    }
    return true;
  }
  if (value2 === targetValue) {
    return true;
  }
  return false;
};
var splitPair = function(raw) {
  switch (type(raw)) {
    case "string":
      return raw.split(/\s+/, 2);
    case "object":
      return [raw.x ?? raw.h, raw.y ?? raw.v];
    case "number":
      return [raw];
    case "array":
      return raw;
    default:
      return null;
  }
};
var normalizeKey = function(id) {
  let key = isString(id) ? id : id.toString();
  const arr = key.match(/[^a-zA-Z0-9_]/g);
  arr && each(arr, (_, sign2) => {
    key = key.replace(sign2, "__" + sign2.charCodeAt() + "__");
  });
  return key;
};
var pairToObject = function(raw, preventRound) {
  const pair = splitPair(raw);
  let h2 = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);
  let v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);
  if (!isFinite(h2)) {
    h2 = 0;
  }
  if (!isFinite(v)) {
    v = h2;
  }
  return {
    h: h2,
    v
  };
};
var getKeyHash = function(key) {
  if (key instanceof guid_default) {
    return key.toString();
  } else if (isObject(key) || Array.isArray(key)) {
    try {
      const keyHash = JSON.stringify(key);
      return "{}" === keyHash ? key : keyHash;
    } catch (e) {
      return key;
    }
  }
  return key;
};
var escapeRegExp = function(string) {
  return string.replace(/[[\]{}\-()*+?.\\^$|\s]/g, "\\$&");
};
var applyServerDecimalSeparator = function(value2) {
  const separator = config_default().serverDecimalSeparator;
  if (isDefined(value2)) {
    value2 = value2.toString().replace(".", separator);
  }
  return value2;
};
var noop2 = function() {
};
var grep = function(elements, checkFunction, invert) {
  const result2 = [];
  let check;
  const expectedCheck = !invert;
  for (let i = 0; i < elements.length; i++) {
    check = !!checkFunction(elements[i], i);
    if (check === expectedCheck) {
      result2.push(elements[i]);
    }
  }
  return result2;
};
var compareArrays = (array1, array2, depth, options2) => {
  if (array1.length !== array2.length) {
    return false;
  }
  return !array1.some((item, idx) => !compareByValue(item, array2[idx], depth + 1, _extends({}, options2, {
    strict: true
  })));
};
var compareObjects = (object1, object2, depth, options2) => {
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  const keys2Set = new Set(keys2);
  return !keys1.some((key) => !keys2Set.has(key) || !compareByValue(object1[key], object2[key], depth + 1, options2));
};
var DEFAULT_EQUAL_BY_VALUE_OPTS = {
  maxDepth: 3,
  strict: true
};
var compareByValue = (value1, value2, depth, options2) => {
  const {
    strict,
    maxDepth
  } = options2;
  const comparable1 = toComparable(value1, true);
  const comparable2 = toComparable(value2, true);
  const comparisonResult = strict ? comparable1 === comparable2 : comparable1 == comparable2;
  switch (true) {
    case comparisonResult:
    case depth >= maxDepth:
      return true;
    case (isObject(comparable1) && isObject(comparable2)):
      return compareObjects(comparable1, comparable2, depth, options2);
    case (Array.isArray(comparable1) && Array.isArray(comparable2)):
      return compareArrays(comparable1, comparable2, depth, options2);
    default:
      return false;
  }
};
var equalByValue = function(value1, value2) {
  let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : DEFAULT_EQUAL_BY_VALUE_OPTS;
  const compareOptions = _extends({}, DEFAULT_EQUAL_BY_VALUE_OPTS, options2);
  return compareByValue(value1, value2, 0, compareOptions);
};

// ../../../../../../node_modules/devextreme/esm/core/utils/shadow_dom.js
var DX_RULE_PREFIX = "dx-";
var ownerDocumentStyleSheet = null;
function createConstructedStyleSheet(rootNode) {
  try {
    return new CSSStyleSheet();
  } catch (err) {
    const styleElement = rootNode.ownerDocument.createElement("style");
    rootNode.appendChild(styleElement);
    return styleElement.sheet;
  }
}
function processRules(targetStyleSheet, styleSheets, needApplyAllStyles) {
  for (let i = 0; i < styleSheets.length; i++) {
    const sheet = styleSheets[i];
    try {
      for (let j = 0; j < sheet.cssRules.length; j++) {
        insertRule(targetStyleSheet, sheet.cssRules[j], needApplyAllStyles);
      }
    } catch (err) {
    }
  }
}
function insertRule(targetStyleSheet, rule, needApplyAllStyles) {
  var _rule$selectorText, _rule$cssRules, _rule$name, _rule$style;
  const isDxRule = needApplyAllStyles || (null === (_rule$selectorText = rule.selectorText) || void 0 === _rule$selectorText ? void 0 : _rule$selectorText.includes(DX_RULE_PREFIX)) || (null === (_rule$cssRules = rule.cssRules) || void 0 === _rule$cssRules || null === (_rule$cssRules = _rule$cssRules[0]) || void 0 === _rule$cssRules || null === (_rule$cssRules = _rule$cssRules.selectorText) || void 0 === _rule$cssRules ? void 0 : _rule$cssRules.includes(DX_RULE_PREFIX)) || (null === (_rule$name = rule.name) || void 0 === _rule$name ? void 0 : _rule$name.startsWith(DX_RULE_PREFIX)) || "DXIcons" === (null === (_rule$style = rule.style) || void 0 === _rule$style ? void 0 : _rule$style.fontFamily);
  if (isDxRule) {
    targetStyleSheet.insertRule(rule.cssText, targetStyleSheet.cssRules.length);
  }
}
function addShadowDomStyles($element) {
  var _el$getRootNode;
  const el = $element.get(0);
  const root = null === (_el$getRootNode = el.getRootNode) || void 0 === _el$getRootNode ? void 0 : _el$getRootNode.call(el);
  if (!(null !== root && void 0 !== root && root.host)) {
    return;
  }
  if (!ownerDocumentStyleSheet) {
    ownerDocumentStyleSheet = createConstructedStyleSheet(root);
    processRules(ownerDocumentStyleSheet, el.ownerDocument.styleSheets, false);
  }
  const currentShadowDomStyleSheet = createConstructedStyleSheet(root);
  processRules(currentShadowDomStyleSheet, root.styleSheets, true);
  root.adoptedStyleSheets = [ownerDocumentStyleSheet, currentShadowDomStyleSheet];
}
function isPositionInElementRectangle(element, x, y) {
  const rect = element.getBoundingClientRect();
  return rect && x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom;
}
function createQueue() {
  let shiftIndex = 0;
  const items = [];
  return {
    push(item) {
      items.push(item);
      return this;
    },
    shift() {
      shiftIndex++;
      return items[shiftIndex - 1];
    },
    get length() {
      return items.length - shiftIndex;
    },
    get items() {
      return items;
    }
  };
}
function getShadowElementsFromPoint(x, y, root) {
  const elementQueue = createQueue().push(root);
  while (elementQueue.length) {
    const el = elementQueue.shift();
    for (let i = 0; i < el.childNodes.length; i++) {
      const childNode = el.childNodes[i];
      if (childNode.nodeType === Node.ELEMENT_NODE && isPositionInElementRectangle(childNode, x, y) && "none" !== getComputedStyle(childNode).pointerEvents) {
        elementQueue.push(childNode);
      }
    }
  }
  const result2 = elementQueue.items.reverse();
  result2.pop();
  return result2;
}

// ../../../../../../node_modules/devextreme/esm/core/dom_adapter.js
var nativeDOMAdapterStrategy = {
  querySelectorAll: (element, selector) => element.querySelectorAll(selector),
  elementMatches(element, selector) {
    const matches = element.matches || element.matchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector || ((selector2) => {
      const doc = element.document || element.ownerDocument;
      if (!doc) {
        return false;
      }
      const items = this.querySelectorAll(doc, selector2);
      for (let i = 0; i < items.length; i++) {
        if (items[i] === element) {
          return true;
        }
      }
    });
    return matches.call(element, selector);
  },
  createElement(tagName, context2) {
    context2 = context2 || this._document;
    return context2.createElement(tagName);
  },
  createElementNS(ns, tagName, context2) {
    context2 = context2 || this._document;
    return context2.createElementNS(ns, tagName);
  },
  createTextNode(text, context2) {
    context2 = context2 || this._document;
    return context2.createTextNode(text);
  },
  createAttribute(text, context2) {
    context2 = context2 || this._document;
    return context2.createAttribute(text);
  },
  isNode: (element) => element && "object" === typeof element && "nodeType" in element && "nodeName" in element,
  isElementNode: (element) => element && 1 === element.nodeType,
  isTextNode: (element) => element && 3 === element.nodeType,
  isDocument: (element) => element && 9 === element.nodeType,
  isDocumentFragment: (element) => element && 11 === element.nodeType,
  removeElement(element) {
    const parentNode = element && element.parentNode;
    if (parentNode) {
      parentNode.removeChild(element);
    }
  },
  insertElement(parentElement, newElement, nextSiblingElement) {
    if (parentElement && newElement && parentElement !== newElement) {
      if (nextSiblingElement) {
        parentElement.insertBefore(newElement, nextSiblingElement);
      } else {
        parentElement.appendChild(newElement);
      }
    }
  },
  getAttribute: (element, name2) => element.getAttribute(name2),
  setAttribute(element, name2, value2) {
    if ("style" === name2) {
      element.style.cssText = value2;
    } else {
      element.setAttribute(name2, value2);
    }
  },
  removeAttribute(element, name2) {
    element.removeAttribute(name2);
  },
  setProperty(element, name2, value2) {
    element[name2] = value2;
  },
  setText(element, text) {
    if (element) {
      element.textContent = text;
    }
  },
  setClass(element, className, isAdd) {
    if (1 === element.nodeType && className) {
      isAdd ? element.classList.add(className) : element.classList.remove(className);
    }
  },
  setStyle(element, name2, value2) {
    element.style[name2] = value2 || "";
  },
  _document: "undefined" === typeof document ? void 0 : document,
  getDocument() {
    return this._document;
  },
  getActiveElement(element) {
    const activeElementHolder = this.getRootNode(element);
    return activeElementHolder.activeElement;
  },
  getRootNode(element) {
    var _element$getRootNode;
    return (null === element || void 0 === element || null === (_element$getRootNode = element.getRootNode) || void 0 === _element$getRootNode ? void 0 : _element$getRootNode.call(element)) ?? this._document;
  },
  getBody() {
    return this._document.body;
  },
  createDocumentFragment() {
    return this._document.createDocumentFragment();
  },
  getDocumentElement() {
    return this._document.documentElement;
  },
  getLocation() {
    return this._document.location;
  },
  getSelection() {
    return this._document.selection;
  },
  getReadyState() {
    return this._document.readyState;
  },
  getHead() {
    return this._document.head;
  },
  hasDocumentProperty(property) {
    return property in this._document;
  },
  listen(element, event, callback, options2) {
    if (!element || !("addEventListener" in element)) {
      return noop2;
    }
    element.addEventListener(event, callback, options2);
    return () => {
      element.removeEventListener(event, callback);
    };
  },
  elementsFromPoint(x, y, element) {
    const activeElementHolder = this.getRootNode(element);
    if (activeElementHolder.host) {
      return getShadowElementsFromPoint(x, y, activeElementHolder);
    }
    return activeElementHolder.elementsFromPoint(x, y);
  }
};
var dom_adapter_default = dependency_injector_default(nativeDOMAdapterStrategy);

// ../../../../../../node_modules/devextreme/esm/core/memorized_callbacks.js
var MemorizedCallbacks = class {
  constructor() {
    this.memory = [];
    this.callbacks = callbacks_default();
  }
  add(fn) {
    each(this.memory, (_, item) => fn.apply(fn, item));
    this.callbacks.add(fn);
  }
  remove(fn) {
    this.callbacks.remove(fn);
  }
  fire() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.memory.push(args);
    this.callbacks.fire.apply(this.callbacks, args);
  }
};

// ../../../../../../node_modules/devextreme/esm/events/core/event_registrator_callbacks.js
var event_registrator_callbacks_default = new MemorizedCallbacks();

// ../../../../../../node_modules/devextreme/esm/events/utils/event_target.js
var getEventTarget = (event) => {
  var _originalEvent$target, _originalEvent$compos;
  const originalEvent = event.originalEvent;
  if (!originalEvent) {
    return event.target;
  }
  const isShadowDOMUsed = Boolean(null === (_originalEvent$target = originalEvent.target) || void 0 === _originalEvent$target ? void 0 : _originalEvent$target.shadowRoot);
  if (!isShadowDOMUsed) {
    return originalEvent.target;
  }
  const path = originalEvent.path ?? (null === (_originalEvent$compos = originalEvent.composedPath) || void 0 === _originalEvent$compos ? void 0 : _originalEvent$compos.call(originalEvent));
  const target = (null === path || void 0 === path ? void 0 : path[0]) ?? event.target;
  return target;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/window.js
var hasWindowValue = "undefined" !== typeof window;
var hasWindow = () => hasWindowValue;
var windowObject = hasWindow() ? window : void 0;
if (!windowObject) {
  windowObject = {};
  windowObject.window = windowObject;
}
var getWindow = () => windowObject;
var hasProperty = (prop) => hasWindow() && prop in windowObject;
var defaultScreenFactorFunc = (width) => {
  if (width < 768) {
    return "xs";
  } else if (width < 992) {
    return "sm";
  } else if (width < 1200) {
    return "md";
  } else {
    return "lg";
  }
};
var getCurrentScreenFactor = (screenFactorCallback) => {
  const screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;
  const windowWidth = dom_adapter_default.getDocumentElement().clientWidth;
  return screenFactorFunc(windowWidth);
};
var getNavigator = () => hasWindow() ? windowObject.navigator : {
  userAgent: ""
};

// ../../../../../../node_modules/devextreme/esm/events/core/hook_touch_props.js
var touchPropsToHook = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"];
var touchPropHook = function(name2, event) {
  if (event[name2] && !event.touches || !event.touches) {
    return event[name2];
  }
  const touches = event.touches.length ? event.touches : event.changedTouches;
  if (!touches.length) {
    return;
  }
  return touches[0][name2];
};
function hook_touch_props_default(callback) {
  touchPropsToHook.forEach(function(name2) {
    callback(name2, function(event) {
      return touchPropHook(name2, event);
    });
  }, this);
}

// ../../../../../../node_modules/devextreme/esm/core/utils/call_once.js
var callOnce = function(handler) {
  let result2;
  let wrappedHandler = function() {
    result2 = handler.apply(this, arguments);
    wrappedHandler = function() {
      return result2;
    };
    return result2;
  };
  return function() {
    return wrappedHandler.apply(this, arguments);
  };
};
var call_once_default = callOnce;

// ../../../../../../node_modules/devextreme/esm/events/core/events_engine.js
var window2 = getWindow();
var EMPTY_EVENT_NAME = "dxEmptyEventType";
var NATIVE_EVENTS_TO_SUBSCRIBE = {
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  pointerenter: "pointerover",
  pointerleave: "pointerout"
};
var NATIVE_EVENTS_TO_TRIGGER = {
  focusin: "focus",
  focusout: "blur"
};
var NO_BUBBLE_EVENTS = ["blur", "focus", "load"];
var forcePassiveFalseEventNames = ["touchmove", "wheel", "mousewheel", "touchstart"];
var EVENT_PROPERTIES = ["target", "relatedTarget", "delegateTarget", "altKey", "bubbles", "cancelable", "changedTouches", "ctrlKey", "detail", "eventPhase", "metaKey", "shiftKey", "view", "char", "code", "charCode", "key", "keyCode", "button", "buttons", "offsetX", "offsetY", "pointerId", "pointerType", "targetTouches", "toElement", "touches"];
function matchesSafe(target, selector) {
  return !isWindow(target) && "#document" !== target.nodeName && dom_adapter_default.elementMatches(target, selector);
}
var elementDataMap = /* @__PURE__ */ new WeakMap();
var guid = 0;
var skipEvent;
var special = function() {
  const specialData = {};
  event_registrator_callbacks_default.add(function(eventName, eventObject) {
    specialData[eventName] = eventObject;
  });
  return {
    getField: function(eventName, field) {
      return specialData[eventName] && specialData[eventName][field];
    },
    callMethod: function(eventName, methodName, context2, args) {
      return specialData[eventName] && specialData[eventName][methodName] && specialData[eventName][methodName].apply(context2, args);
    }
  };
}();
var eventsEngine = dependency_injector_default({
  on: getHandler(normalizeOnArguments(iterate(function(element, eventName, selector, data2, handler) {
    const handlersController = getHandlersController(element, eventName);
    handlersController.addHandler(handler, selector, data2);
  }))),
  one: getHandler(normalizeOnArguments(function(element, eventName, selector, data2, handler) {
    const oneTimeHandler = function() {
      eventsEngine.off(element, eventName, selector, oneTimeHandler);
      handler.apply(this, arguments);
    };
    eventsEngine.on(element, eventName, selector, data2, oneTimeHandler);
  })),
  off: getHandler(normalizeOffArguments(iterate(function(element, eventName, selector, handler) {
    const handlersController = getHandlersController(element, eventName);
    handlersController.removeHandler(handler, selector);
  }))),
  trigger: getHandler(normalizeTriggerArguments(function(element, event, extraParameters) {
    const eventName = event.type;
    const handlersController = getHandlersController(element, event.type);
    special.callMethod(eventName, "trigger", element, [event, extraParameters]);
    handlersController.callHandlers(event, extraParameters);
    const noBubble = special.getField(eventName, "noBubble") || event.isPropagationStopped() || -1 !== NO_BUBBLE_EVENTS.indexOf(eventName);
    if (!noBubble) {
      const parents = [];
      const getParents = function(element2) {
        const parent = element2.parentNode ?? (isObject(element2.host) ? element2.host : null);
        if (parent) {
          parents.push(parent);
          getParents(parent);
        }
      };
      getParents(element);
      parents.push(window2);
      let i = 0;
      while (parents[i] && !event.isPropagationStopped()) {
        const parentDataByEvent = getHandlersController(parents[i], event.type);
        parentDataByEvent.callHandlers(extend(event, {
          currentTarget: parents[i]
        }), extraParameters);
        i++;
      }
    }
    if (element.nodeType || isWindow(element)) {
      special.callMethod(eventName, "_default", element, [event, extraParameters]);
      callNativeMethod(eventName, element);
    }
  })),
  triggerHandler: getHandler(normalizeTriggerArguments(function(element, event, extraParameters) {
    const handlersController = getHandlersController(element, event.type);
    handlersController.callHandlers(event, extraParameters);
  }))
});
function applyForEach(args, method) {
  const element = args[0];
  if (!element) {
    return;
  }
  if (dom_adapter_default.isNode(element) || isWindow(element)) {
    method.apply(eventsEngine, args);
  } else if (!isString(element) && "length" in element) {
    const itemArgs = Array.prototype.slice.call(args, 0);
    Array.prototype.forEach.call(element, function(itemElement) {
      itemArgs[0] = itemElement;
      applyForEach(itemArgs, method);
    });
  } else {
    throw errors_default.Error("E0025");
  }
}
function getHandler(method) {
  return function() {
    applyForEach(arguments, method);
  };
}
function detectPassiveEventHandlersSupport() {
  let isSupported = false;
  try {
    const options2 = Object.defineProperty({}, "passive", {
      get: function() {
        isSupported = true;
        return true;
      }
    });
    window2.addEventListener("test", null, options2);
  } catch (e) {
  }
  return isSupported;
}
var passiveEventHandlersSupported = call_once_default(detectPassiveEventHandlersSupport);
var contains = (container, element) => {
  if (isWindow(container)) {
    return contains(container.document, element);
  }
  return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
};
function getHandlersController(element, eventName) {
  let elementData = elementDataMap.get(element);
  eventName = eventName || "";
  const eventNameParts = eventName.split(".");
  const namespaces2 = eventNameParts.slice(1);
  const eventNameIsDefined = !!eventNameParts[0];
  eventName = eventNameParts[0] || EMPTY_EVENT_NAME;
  if (!elementData) {
    elementData = {};
    elementDataMap.set(element, elementData);
  }
  if (!elementData[eventName]) {
    elementData[eventName] = {
      handleObjects: [],
      nativeHandler: null
    };
  }
  const eventData2 = elementData[eventName];
  return {
    addHandler: function(handler, selector, data2) {
      const callHandler = function(e, extraParameters) {
        const handlerArgs = [e];
        const target = e.currentTarget;
        const relatedTarget = e.relatedTarget;
        let secondaryTargetIsInside;
        let result2;
        if (eventName in NATIVE_EVENTS_TO_SUBSCRIBE) {
          secondaryTargetIsInside = relatedTarget && target && (relatedTarget === target || contains(target, relatedTarget));
        }
        if (void 0 !== extraParameters) {
          handlerArgs.push(extraParameters);
        }
        special.callMethod(eventName, "handle", element, [e, data2]);
        if (!secondaryTargetIsInside) {
          result2 = handler.apply(target, handlerArgs);
        }
        if (false === result2) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      const handleObject = {
        handler,
        wrappedHandler: function(e, extraParameters) {
          if (skipEvent && e.type === skipEvent) {
            return;
          }
          e.data = data2;
          e.delegateTarget = element;
          if (selector) {
            let currentTarget = e.target;
            while (currentTarget && currentTarget !== element) {
              if (matchesSafe(currentTarget, selector)) {
                e.currentTarget = currentTarget;
                callHandler(e, extraParameters);
              }
              currentTarget = currentTarget.parentNode;
            }
          } else {
            var _e$target;
            e.currentTarget = e.delegateTarget || e.target;
            const isTargetInShadowDOM = Boolean(null === (_e$target = e.target) || void 0 === _e$target ? void 0 : _e$target.shadowRoot);
            if (isTargetInShadowDOM) {
              const target = getEventTarget(e);
              e.target = target;
            }
            callHandler(e, extraParameters);
          }
        },
        selector,
        type: eventName,
        data: data2,
        namespace: namespaces2.join("."),
        namespaces: namespaces2,
        guid: ++guid
      };
      eventData2.handleObjects.push(handleObject);
      const firstHandlerForTheType = 1 === eventData2.handleObjects.length;
      let shouldAddNativeListener = firstHandlerForTheType && eventNameIsDefined;
      let nativeListenerOptions;
      if (shouldAddNativeListener) {
        shouldAddNativeListener = !special.callMethod(eventName, "setup", element, [data2, namespaces2, handler]);
      }
      if (shouldAddNativeListener) {
        eventData2.nativeHandler = getNativeHandler(eventName);
        if (passiveEventHandlersSupported() && forcePassiveFalseEventNames.indexOf(eventName) > -1) {
          nativeListenerOptions = {
            passive: false
          };
        }
        eventData2.removeListener = dom_adapter_default.listen(element, NATIVE_EVENTS_TO_SUBSCRIBE[eventName] || eventName, eventData2.nativeHandler, nativeListenerOptions);
      }
      special.callMethod(eventName, "add", element, [handleObject]);
    },
    removeHandler: function(handler, selector) {
      const removeByEventName = function(eventName2) {
        const eventData3 = elementData[eventName2];
        if (!eventData3.handleObjects.length) {
          delete elementData[eventName2];
          return;
        }
        let removedHandler;
        eventData3.handleObjects = eventData3.handleObjects.filter(function(handleObject) {
          const skip = namespaces2.length && !isSubset(handleObject.namespaces, namespaces2) || handler && handleObject.handler !== handler || selector && handleObject.selector !== selector;
          if (!skip) {
            removedHandler = handleObject.handler;
            special.callMethod(eventName2, "remove", element, [handleObject]);
          }
          return skip;
        });
        const lastHandlerForTheType = !eventData3.handleObjects.length;
        const shouldRemoveNativeListener = lastHandlerForTheType && eventName2 !== EMPTY_EVENT_NAME;
        if (shouldRemoveNativeListener) {
          special.callMethod(eventName2, "teardown", element, [namespaces2, removedHandler]);
          if (eventData3.nativeHandler) {
            eventData3.removeListener();
          }
          delete elementData[eventName2];
        }
      };
      if (eventNameIsDefined) {
        removeByEventName(eventName);
      } else {
        for (const name2 in elementData) {
          removeByEventName(name2);
        }
      }
      const elementDataIsEmpty = 0 === Object.keys(elementData).length;
      if (elementDataIsEmpty) {
        elementDataMap.delete(element);
      }
    },
    callHandlers: function(event, extraParameters) {
      let forceStop = false;
      const handleCallback = function(handleObject) {
        if (forceStop) {
          return;
        }
        if (!namespaces2.length || isSubset(handleObject.namespaces, namespaces2)) {
          handleObject.wrappedHandler(event, extraParameters);
          forceStop = event.isImmediatePropagationStopped();
        }
      };
      eventData2.handleObjects.forEach(handleCallback);
      if (namespaces2.length && elementData[EMPTY_EVENT_NAME]) {
        elementData[EMPTY_EVENT_NAME].handleObjects.forEach(handleCallback);
      }
    }
  };
}
function getNativeHandler(subscribeName) {
  return function(event, extraParameters) {
    const handlersController = getHandlersController(this, subscribeName);
    event = eventsEngine.Event(event);
    handlersController.callHandlers(event, extraParameters);
  };
}
function isSubset(original, checked) {
  for (let i = 0; i < checked.length; i++) {
    if (original.indexOf(checked[i]) < 0) {
      return false;
    }
  }
  return true;
}
function normalizeOnArguments(callback) {
  return function(element, eventName, selector, data2, handler) {
    if (!handler) {
      handler = data2;
      data2 = void 0;
    }
    if ("string" !== typeof selector) {
      data2 = selector;
      selector = void 0;
    }
    if (!handler && "string" === typeof eventName) {
      handler = data2 || selector;
      selector = void 0;
      data2 = void 0;
    }
    callback(element, eventName, selector, data2, handler);
  };
}
function normalizeOffArguments(callback) {
  return function(element, eventName, selector, handler) {
    if ("function" === typeof selector) {
      handler = selector;
      selector = void 0;
    }
    callback(element, eventName, selector, handler);
  };
}
function normalizeTriggerArguments(callback) {
  return function(element, src, extraParameters) {
    if ("string" === typeof src) {
      src = {
        type: src
      };
    }
    if (!src.target) {
      src.target = element;
    }
    src.currentTarget = element;
    if (!src.delegateTarget) {
      src.delegateTarget = element;
    }
    if (!src.type && src.originalEvent) {
      src.type = src.originalEvent.type;
    }
    callback(element, src instanceof eventsEngine.Event ? src : eventsEngine.Event(src), extraParameters);
  };
}
function normalizeEventArguments(callback) {
  eventsEngine.Event = function(src, config3) {
    if (!(this instanceof eventsEngine.Event)) {
      return new eventsEngine.Event(src, config3);
    }
    if (!src) {
      src = {};
    }
    if ("string" === typeof src) {
      src = {
        type: src
      };
    }
    if (!config3) {
      config3 = {};
    }
    callback.call(this, src, config3);
  };
  Object.assign(eventsEngine.Event.prototype, {
    _propagationStopped: false,
    _immediatePropagationStopped: false,
    _defaultPrevented: false,
    isPropagationStopped: function() {
      return !!(this._propagationStopped || this.originalEvent && this.originalEvent.propagationStopped);
    },
    stopPropagation: function() {
      this._propagationStopped = true;
      this.originalEvent && this.originalEvent.stopPropagation();
    },
    isImmediatePropagationStopped: function() {
      return this._immediatePropagationStopped;
    },
    stopImmediatePropagation: function() {
      this.stopPropagation();
      this._immediatePropagationStopped = true;
      this.originalEvent && this.originalEvent.stopImmediatePropagation();
    },
    isDefaultPrevented: function() {
      return !!(this._defaultPrevented || this.originalEvent && this.originalEvent.defaultPrevented);
    },
    preventDefault: function() {
      this._defaultPrevented = true;
      this.originalEvent && this.originalEvent.preventDefault();
    }
  });
  return eventsEngine.Event;
}
function iterate(callback) {
  const iterateEventNames = function(element, eventName) {
    if (eventName && eventName.indexOf(" ") > -1) {
      const args = Array.prototype.slice.call(arguments, 0);
      eventName.split(" ").forEach(function(eventName2) {
        args[1] = eventName2;
        callback.apply(this, args);
      });
    } else {
      callback.apply(this, arguments);
    }
  };
  return function(element, eventName) {
    if ("object" === typeof eventName) {
      const args = Array.prototype.slice.call(arguments, 0);
      for (const name2 in eventName) {
        args[1] = name2;
        args[args.length - 1] = eventName[name2];
        iterateEventNames.apply(this, args);
      }
    } else {
      iterateEventNames.apply(this, arguments);
    }
  };
}
function callNativeMethod(eventName, element) {
  const nativeMethodName = NATIVE_EVENTS_TO_TRIGGER[eventName] || eventName;
  if (function(eventName2, element2) {
    return "click" === eventName2 && "a" === element2.localName;
  }(eventName, element)) {
    return;
  }
  if (isFunction(element[nativeMethodName])) {
    skipEvent = eventName;
    element[nativeMethodName]();
    skipEvent = void 0;
  }
}
function calculateWhich(event) {
  if (function(event2) {
    return null == event2.which && 0 === event2.type.indexOf("key");
  }(event)) {
    return null != event.charCode ? event.charCode : event.keyCode;
  }
  if (function(event2) {
    return !event2.which && void 0 !== event2.button && /^(?:mouse|pointer|contextmenu|drag|drop)|click/.test(event2.type);
  }(event)) {
    const whichByButton = {
      1: 1,
      2: 3,
      3: 1,
      4: 2
    };
    return whichByButton[event.button];
  }
  return event.which;
}
function initEvent(EventClass) {
  if (EventClass) {
    eventsEngine.Event = EventClass;
    eventsEngine.Event.prototype = EventClass.prototype;
  }
}
initEvent(normalizeEventArguments(function(src, config3) {
  var _src$view;
  const srcIsEvent = src instanceof eventsEngine.Event || hasWindow() && src instanceof window2.Event || (null === (_src$view = src.view) || void 0 === _src$view ? void 0 : _src$view.Event) && src instanceof src.view.Event;
  if (srcIsEvent) {
    this.originalEvent = src;
    this.type = src.type;
    this.currentTarget = void 0;
    if (Object.prototype.hasOwnProperty.call(src, "isTrusted")) {
      this.isTrusted = src.isTrusted;
    }
    this.timeStamp = src.timeStamp || Date.now();
  } else {
    Object.assign(this, src);
  }
  addProperty("which", calculateWhich, this);
  if (0 === src.type.indexOf("touch")) {
    delete config3.pageX;
    delete config3.pageY;
  }
  Object.assign(this, config3);
  this.guid = ++guid;
}));
function addProperty(propName, hook, eventInstance) {
  Object.defineProperty(eventInstance || eventsEngine.Event.prototype, propName, {
    enumerable: true,
    configurable: true,
    get: function() {
      return this.originalEvent && hook(this.originalEvent);
    },
    set: function(value2) {
      Object.defineProperty(this, propName, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value2
      });
    }
  });
}
EVENT_PROPERTIES.forEach((prop) => addProperty(prop, (event) => event[prop]));
hook_touch_props_default(addProperty);
var beforeSetStrategy = callbacks_default();
var afterSetStrategy = callbacks_default();
eventsEngine.set = function(engine) {
  beforeSetStrategy.fire();
  eventsEngine.inject(engine);
  initEvent(engine.Event);
  afterSetStrategy.fire();
};
eventsEngine.subscribeGlobal = function() {
  applyForEach(arguments, normalizeOnArguments(function() {
    const args = arguments;
    eventsEngine.on.apply(this, args);
    beforeSetStrategy.add(function() {
      const offArgs = Array.prototype.slice.call(args, 0);
      offArgs.splice(3, 1);
      eventsEngine.off.apply(this, offArgs);
    });
    afterSetStrategy.add(function() {
      eventsEngine.on.apply(this, args);
    });
  }));
};
eventsEngine.forcePassiveFalseEventNames = forcePassiveFalseEventNames;
eventsEngine.passiveEventHandlersSupported = passiveEventHandlersSupported;
var events_engine_default = eventsEngine;

// ../../../../../../node_modules/devextreme/esm/core/element_data.js
var dataMap = /* @__PURE__ */ new WeakMap();
var strategy;
var strategyChanging = new MemorizedCallbacks();
var beforeCleanDataFunc = function() {
};
var afterCleanDataFunc = function() {
};
var setDataStrategy = function(value2) {
  strategyChanging.fire(value2);
  strategy = value2;
  const cleanData = strategy.cleanData;
  strategy.cleanData = function(nodes) {
    beforeCleanDataFunc(nodes);
    const result2 = cleanData.call(this, nodes);
    afterCleanDataFunc(nodes);
    return result2;
  };
};
setDataStrategy({
  data: function() {
    const element = arguments[0];
    const key = arguments[1];
    const value2 = arguments[2];
    if (!element) {
      return;
    }
    let elementData = dataMap.get(element);
    if (!elementData) {
      elementData = {};
      dataMap.set(element, elementData);
    }
    if (void 0 === key) {
      return elementData;
    }
    if (2 === arguments.length) {
      return elementData[key];
    }
    elementData[key] = value2;
    return value2;
  },
  removeData: function(element, key) {
    if (!element) {
      return;
    }
    if (void 0 === key) {
      dataMap.delete(element);
    } else {
      const elementData = dataMap.get(element);
      if (elementData) {
        delete elementData[key];
      }
    }
  },
  cleanData: function(elements) {
    for (let i = 0; i < elements.length; i++) {
      events_engine_default.off(elements[i]);
      dataMap.delete(elements[i]);
    }
  }
});
function data() {
  return strategy.data.apply(this, arguments);
}
function beforeCleanData(callback) {
  beforeCleanDataFunc = callback;
}
function removeData(element, key) {
  return strategy.removeData.call(this, element, key);
}
function cleanDataRecursive(element, cleanSelf) {
  if (!dom_adapter_default.isElementNode(element)) {
    return;
  }
  const childElements = element.getElementsByTagName("*");
  strategy.cleanData(childElements);
  if (cleanSelf) {
    strategy.cleanData([element]);
  }
}

// ../../../../../../node_modules/devextreme/esm/core/utils/inflector.js
var _normalize = function(text) {
  if (void 0 === text || null === text) {
    return "";
  }
  return String(text);
};
var _upperCaseFirst = function(text) {
  return _normalize(text).charAt(0).toUpperCase() + text.substr(1);
};
var _chop = function(text) {
  return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/);
};
var dasherize = function(text) {
  return map(_chop(text), function(p2) {
    return p2.toLowerCase();
  }).join("-");
};
var camelize = function(text, upperFirst) {
  return map(_chop(text), function(p2, i) {
    p2 = p2.toLowerCase();
    if (upperFirst || i > 0) {
      p2 = _upperCaseFirst(p2);
    }
    return p2;
  }).join("");
};
var humanize = function(text) {
  return _upperCaseFirst(dasherize(text).replace(/-/g, " "));
};
var titleize = function(text) {
  return map(_chop(text), function(p2) {
    return _upperCaseFirst(p2.toLowerCase());
  }).join(" ");
};
var DIGIT_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
var captionize = function(name2) {
  const captionList = [];
  let i;
  let char;
  let isPrevCharNewWord = false;
  let isNewWord = false;
  for (i = 0; i < name2.length; i++) {
    char = name2.charAt(i);
    isNewWord = char === char.toUpperCase() && "-" !== char && ")" !== char && "/" !== char || char in DIGIT_CHARS;
    if ("_" === char || "." === char) {
      char = " ";
      isNewWord = true;
    } else if (0 === i) {
      char = char.toUpperCase();
      isNewWord = true;
    } else if (!isPrevCharNewWord && isNewWord) {
      if (captionList.length > 0) {
        captionList.push(" ");
      }
    }
    captionList.push(char);
    isPrevCharNewWord = isNewWord;
  }
  return captionList.join("");
};

// ../../../../../../node_modules/devextreme/esm/core/utils/style.js
var jsPrefixes = ["", "Webkit", "Moz", "O", "Ms"];
var cssPrefixes = {
  "": "",
  Webkit: "-webkit-",
  Moz: "-moz-",
  O: "-o-",
  ms: "-ms-"
};
var getStyles = call_once_default(function() {
  return dom_adapter_default.createElement("dx").style;
});
var forEachPrefixes = function(prop, callBack) {
  prop = camelize(prop, true);
  let result2;
  for (let i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
    const jsPrefix = jsPrefixes[i];
    const prefixedProp = jsPrefix + prop;
    const lowerPrefixedProp = camelize(prefixedProp);
    result2 = callBack(lowerPrefixedProp, jsPrefix);
    if (void 0 === result2) {
      result2 = callBack(prefixedProp, jsPrefix);
    }
    if (void 0 !== result2) {
      break;
    }
  }
  return result2 || "";
};
var styleProp = function(name2) {
  if (name2 in getStyles()) {
    return name2;
  }
  const originalName = name2;
  name2 = name2.charAt(0).toUpperCase() + name2.substr(1);
  for (let i = 1; i < jsPrefixes.length; i++) {
    const prefixedProp = jsPrefixes[i].toLowerCase() + name2;
    if (prefixedProp in getStyles()) {
      return prefixedProp;
    }
  }
  return originalName;
};
var stylePropPrefix = function(prop) {
  return forEachPrefixes(prop, function(specific, jsPrefix) {
    if (specific in getStyles()) {
      return cssPrefixes[jsPrefix];
    }
  });
};
var pxExceptions = ["fillOpacity", "columnCount", "flexGrow", "flexShrink", "fontWeight", "lineHeight", "opacity", "zIndex", "zoom"];
var normalizeStyleProp = function(prop, value2) {
  if (isNumeric(value2) && -1 === pxExceptions.indexOf(prop)) {
    value2 += "px";
  }
  return value2;
};
var setStyle = function(element, styleString) {
  let resetStyle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;
  if (resetStyle) {
    const styleList = [].slice.call(element.style);
    styleList.forEach((propertyName) => {
      element.style.removeProperty(propertyName);
    });
  }
  styleString.split(";").forEach((style) => {
    const parts = style.split(":").map((stylePart) => stylePart.trim());
    if (2 === parts.length) {
      const [property, value2] = parts;
      element.style[property] = value2;
    }
  });
};

// ../../../../../../node_modules/devextreme/esm/core/utils/size.js
var window3 = getWindow();
var SPECIAL_HEIGHT_VALUES = ["auto", "none", "inherit", "initial"];
var getSizeByStyles = function(elementStyles, styles) {
  let result2 = 0;
  styles.forEach(function(style) {
    result2 += parseFloat(elementStyles[style]) || 0;
  });
  return result2;
};
var getElementBoxParams = function(name2, elementStyles) {
  const beforeName = "width" === name2 ? "Left" : "Top";
  const afterName = "width" === name2 ? "Right" : "Bottom";
  return {
    padding: getSizeByStyles(elementStyles, ["padding" + beforeName, "padding" + afterName]),
    border: getSizeByStyles(elementStyles, ["border" + beforeName + "Width", "border" + afterName + "Width"]),
    margin: getSizeByStyles(elementStyles, ["margin" + beforeName, "margin" + afterName])
  };
};
var getElementComputedStyle = function(element) {
  var _element$ownerDocumen;
  const view = (null === element || void 0 === element || null === (_element$ownerDocumen = element.ownerDocument) || void 0 === _element$ownerDocumen ? void 0 : _element$ownerDocumen.defaultView) || window3;
  return view.getComputedStyle && view.getComputedStyle(element);
};
var getCSSProperty = function(element, styles, name2, defaultValue) {
  var _element$style;
  return (null === styles || void 0 === styles ? void 0 : styles[name2]) || (null === (_element$style = element.style) || void 0 === _element$style ? void 0 : _element$style[name2]) || defaultValue;
};
var boxIndices = {
  content: 0,
  padding: 1,
  border: 2,
  margin: 3,
  "content-box": 0,
  "border-box": 2
};
var dimensionComponents = {
  width: ["left", "right"],
  height: ["top", "bottom"]
};
function getComponentThickness(elem, dimension, component, styles) {
  const get = (elem2, styles2, field) => parseFloat(getCSSProperty(elem2, styles2, field, "0")) || 0;
  const suffix = "border" === component ? "-width" : "";
  return get(elem, styles, `${component}-${dimensionComponents[dimension][0]}${suffix}`) + get(elem, styles, `${component}-${dimensionComponents[dimension][1]}${suffix}`);
}
var getSize = function(element, dimension, box) {
  const offsetFieldName = "width" === dimension ? "offsetWidth" : "offsetHeight";
  const styles = getElementComputedStyle(element);
  let result2 = getCSSProperty(element, styles, dimension);
  if ("" === result2 || "auto" === result2) {
    result2 = element[offsetFieldName];
  }
  result2 = parseFloat(result2) || 0;
  const currentBox = getCSSProperty(element, styles, "boxSizing", "content-box");
  const targetBox = box || currentBox;
  let targetBoxIndex = boxIndices[targetBox];
  let currentBoxIndex = boxIndices[currentBox];
  if (void 0 === targetBoxIndex || void 0 === currentBoxIndex) {
    throw new Error();
  }
  if (currentBoxIndex === targetBoxIndex) {
    return result2;
  }
  const coeff = Math.sign(targetBoxIndex - currentBoxIndex);
  let padding = false;
  let border = false;
  let margin = false;
  let scrollThickness = false;
  if (1 === coeff) {
    targetBoxIndex += 1;
    currentBoxIndex += 1;
  }
  for (let boxPart = currentBoxIndex; boxPart !== targetBoxIndex; boxPart += coeff) {
    switch (boxPart) {
      case boxIndices.content:
        break;
      case boxIndices.padding:
        padding = coeff * getComponentThickness(element, dimension, "padding", styles);
        break;
      case boxIndices.border:
        border = coeff * getComponentThickness(element, dimension, "border", styles);
        break;
      case boxIndices.margin:
        margin = coeff * getComponentThickness(element, dimension, "margin", styles);
    }
  }
  if (padding || border) {
    const paddingAndBorder = (false === padding ? coeff * getComponentThickness(element, dimension, "padding", styles) : padding) + (false === border ? coeff * getComponentThickness(element, dimension, "border", styles) : border);
    scrollThickness = coeff * Math.max(0, Math.floor(element[offsetFieldName] - result2 - coeff * paddingAndBorder)) || 0;
  }
  return result2 + margin + padding + border + scrollThickness;
};
var getContainerHeight = function(container) {
  return isWindow(container) ? container.innerHeight : container.offsetHeight;
};
var parseHeight = function(value2, container, element) {
  if (value2.indexOf("px") > 0) {
    value2 = parseInt(value2.replace("px", ""));
  } else if (value2.indexOf("%") > 0) {
    value2 = parseInt(value2.replace("%", "")) * getContainerHeight(container) / 100;
  } else if (!isNaN(value2)) {
    value2 = parseInt(value2);
  } else if (value2.indexOf("vh") > 0) {
    value2 = window3.innerHeight / 100 * parseInt(value2.replace("vh", ""));
  } else if (element && value2.indexOf("em") > 0) {
    value2 = parseFloat(value2.replace("em", "")) * parseFloat(window3.getComputedStyle(element).fontSize);
  }
  return value2;
};
var getHeightWithOffset = function(value2, offset2, container) {
  if (!value2) {
    return null;
  }
  if (SPECIAL_HEIGHT_VALUES.indexOf(value2) > -1) {
    return offset2 ? null : value2;
  }
  if (isString(value2)) {
    value2 = parseHeight(value2, container);
  }
  if (isNumeric(value2)) {
    return Math.max(0, value2 + offset2);
  }
  const operationString = offset2 < 0 ? " - " : " ";
  return "calc(" + value2 + operationString + Math.abs(offset2) + "px)";
};
var addOffsetToMaxHeight = function(value2, offset2, container) {
  const maxHeight = getHeightWithOffset(value2, offset2, container);
  return null !== maxHeight ? maxHeight : "none";
};
var addOffsetToMinHeight = function(value2, offset2, container) {
  const minHeight = getHeightWithOffset(value2, offset2, container);
  return null !== minHeight ? minHeight : 0;
};
var getVerticalOffsets = function(element, withMargins) {
  if (!element) {
    return 0;
  }
  const boxParams = getElementBoxParams("height", window3.getComputedStyle(element));
  return boxParams.padding + boxParams.border + (withMargins ? boxParams.margin : 0);
};
var getVisibleHeight = function(element) {
  if (element) {
    const boundingClientRect = element.getBoundingClientRect();
    if (boundingClientRect.height) {
      return boundingClientRect.height;
    }
  }
  return 0;
};
var implementationsMap = {
  getWidth: function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return elementSizeHelper("width", ...args);
  },
  setWidth: function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return elementSizeHelper("width", ...args);
  },
  getHeight: function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return elementSizeHelper("height", ...args);
  },
  setHeight: function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return elementSizeHelper("height", ...args);
  },
  getOuterWidth: function() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return elementSizeHelper("outerWidth", ...args);
  },
  setOuterWidth: function() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return elementSizeHelper("outerWidth", ...args);
  },
  getOuterHeight: function() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return elementSizeHelper("outerHeight", ...args);
  },
  setOuterHeight: function() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    return elementSizeHelper("outerHeight", ...args);
  },
  getInnerWidth: function() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    return elementSizeHelper("innerWidth", ...args);
  },
  setInnerWidth: function() {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }
    return elementSizeHelper("innerWidth", ...args);
  },
  getInnerHeight: function() {
    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      args[_key11] = arguments[_key11];
    }
    return elementSizeHelper("innerHeight", ...args);
  },
  setInnerHeight: function() {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }
    return elementSizeHelper("innerHeight", ...args);
  }
};
function elementSizeHelper(sizeProperty, el, value2) {
  return 2 === arguments.length ? elementSize(el, sizeProperty) : elementSize(el, sizeProperty, value2);
}
var getWidth = (el) => implementationsMap.getWidth(el);
var setWidth = (el, value2) => implementationsMap.setWidth(el, value2);
var getHeight = (el) => implementationsMap.getHeight(el);
var setHeight = (el, value2) => implementationsMap.setHeight(el, value2);
var getOuterWidth = (el, includeMargin) => implementationsMap.getOuterWidth(el, includeMargin || false);
var setOuterWidth = (el, value2) => implementationsMap.setOuterWidth(el, value2);
var getOuterHeight = (el, includeMargin) => implementationsMap.getOuterHeight(el, includeMargin || false);
var setOuterHeight = (el, value2) => implementationsMap.setOuterHeight(el, value2);
var getInnerWidth = (el) => implementationsMap.getInnerWidth(el);
var getInnerHeight = (el) => implementationsMap.getInnerHeight(el);
var elementSize = function(el, sizeProperty, value2) {
  const partialName = sizeProperty.toLowerCase().indexOf("width") >= 0 ? "Width" : "Height";
  const propName = partialName.toLowerCase();
  const isOuter = 0 === sizeProperty.indexOf("outer");
  const isInner = 0 === sizeProperty.indexOf("inner");
  const isGetter = 2 === arguments.length || "boolean" === typeof value2;
  if (isRenderer(el)) {
    if (el.length > 1 && !isGetter) {
      for (let i = 0; i < el.length; i++) {
        elementSize(el[i], sizeProperty, value2);
      }
      return;
    }
    el = el[0];
  }
  if (!el) {
    return;
  }
  if (isWindow(el)) {
    return isOuter ? el["inner" + partialName] : dom_adapter_default.getDocumentElement()["client" + partialName];
  }
  if (dom_adapter_default.isDocument(el)) {
    const documentElement = dom_adapter_default.getDocumentElement();
    const body = dom_adapter_default.getBody();
    return Math.max(body["scroll" + partialName], body["offset" + partialName], documentElement["scroll" + partialName], documentElement["offset" + partialName], documentElement["client" + partialName]);
  }
  if (isGetter) {
    let box = "content";
    if (isOuter) {
      box = value2 ? "margin" : "border";
    }
    if (isInner) {
      box = "padding";
    }
    return getSize(el, propName, box);
  }
  if (isNumeric(value2)) {
    const elementStyles = getElementComputedStyle(el);
    const sizeAdjustment = getElementBoxParams(propName, elementStyles);
    const isBorderBox = "border-box" === elementStyles.boxSizing;
    value2 = Number(value2);
    if (isOuter) {
      value2 -= isBorderBox ? 0 : sizeAdjustment.border + sizeAdjustment.padding;
    } else if (isInner) {
      value2 += isBorderBox ? sizeAdjustment.border : -sizeAdjustment.padding;
    } else if (isBorderBox) {
      value2 += sizeAdjustment.border + sizeAdjustment.padding;
    }
  }
  value2 += isNumeric(value2) ? "px" : "";
  dom_adapter_default.setStyle(el, propName, value2);
  return null;
};
var getWindowByElement = (el) => isWindow(el) ? el : el.defaultView;
var getOffset = (el) => {
  if (!el.getClientRects().length) {
    return {
      top: 0,
      left: 0
    };
  }
  const rect = el.getBoundingClientRect();
  const win = getWindowByElement(el.ownerDocument);
  const docElem = el.ownerDocument.documentElement;
  return {
    top: rect.top + win.pageYOffset - docElem.clientTop,
    left: rect.left + win.pageXOffset - docElem.clientLeft
  };
};

// ../../../../../../node_modules/devextreme/esm/core/utils/html_parser.js
var isTagName = /<([a-z][^/\0>\x20\t\r\n\f]+)/i;
var tagWrappers = {
  default: {
    tagsCount: 0,
    startTags: "",
    endTags: ""
  },
  thead: {
    tagsCount: 1,
    startTags: "<table>",
    endTags: "</table>"
  },
  td: {
    tagsCount: 3,
    startTags: "<table><tbody><tr>",
    endTags: "</tr></tbody></table>"
  },
  col: {
    tagsCount: 2,
    startTags: "<table><colgroup>",
    endTags: "</colgroup></table>"
  },
  tr: {
    tagsCount: 2,
    startTags: "<table><tbody>",
    endTags: "</tbody></table>"
  }
};
tagWrappers.tbody = tagWrappers.colgroup = tagWrappers.caption = tagWrappers.tfoot = tagWrappers.thead;
tagWrappers.th = tagWrappers.td;
var parseHTML = function(html) {
  if ("string" !== typeof html) {
    return null;
  }
  const fragment = dom_adapter_default.createDocumentFragment();
  let container = fragment.appendChild(dom_adapter_default.createElement("div"));
  const tags = isTagName.exec(html);
  const firstRootTag = tags && tags[1].toLowerCase();
  const tagWrapper = tagWrappers[firstRootTag] || tagWrappers.default;
  container.innerHTML = tagWrapper.startTags + html + tagWrapper.endTags;
  for (let i = 0; i < tagWrapper.tagsCount; i++) {
    container = container.lastChild;
  }
  return [...container.childNodes];
};
var isTablePart = function(html) {
  const tags = isTagName.exec(html);
  return tags && tags[1] in tagWrappers;
};

// ../../../../../../node_modules/devextreme/esm/core/renderer_base.js
var window4 = getWindow();
var renderer;
var initRender = function(selector, context2) {
  if (!selector) {
    this.length = 0;
    return this;
  }
  if ("string" === typeof selector) {
    if ("body" === selector) {
      this[0] = context2 ? context2.body : dom_adapter_default.getBody();
      this.length = 1;
      return this;
    }
    context2 = context2 || dom_adapter_default.getDocument();
    if ("<" === selector[0]) {
      this[0] = dom_adapter_default.createElement(selector.slice(1, -1), context2);
      this.length = 1;
      return this;
    }
    [].push.apply(this, dom_adapter_default.querySelectorAll(context2, selector));
    return this;
  } else if (dom_adapter_default.isNode(selector) || isWindow(selector)) {
    this[0] = selector;
    this.length = 1;
    return this;
  } else if (Array.isArray(selector)) {
    [].push.apply(this, selector);
    return this;
  }
  return renderer(selector.toArray ? selector.toArray() : [selector]);
};
renderer = function(selector, context2) {
  return new initRender(selector, context2);
};
renderer.fn = {
  dxRenderer: true
};
initRender.prototype = renderer.fn;
var repeatMethod = function(methodName, args) {
  for (let i = 0; i < this.length; i++) {
    const item = renderer(this[i]);
    item[methodName].apply(item, args);
  }
  return this;
};
var setAttributeValue = function(element, attrName, value2) {
  if (void 0 !== value2 && null !== value2 && false !== value2) {
    dom_adapter_default.setAttribute(element, attrName, value2);
  } else {
    dom_adapter_default.removeAttribute(element, attrName);
  }
};
initRender.prototype.show = function() {
  return this.toggle(true);
};
initRender.prototype.hide = function() {
  return this.toggle(false);
};
initRender.prototype.toggle = function(value2) {
  if (this[0]) {
    this.toggleClass("dx-state-invisible", !value2);
  }
  return this;
};
initRender.prototype.attr = function(attrName, value2) {
  if (this.length > 1 && arguments.length > 1) {
    return repeatMethod.call(this, "attr", arguments);
  }
  if (!this[0]) {
    if (isObject(attrName) || void 0 !== value2) {
      return this;
    } else {
      return;
    }
  }
  if (!this[0].getAttribute) {
    return this.prop(attrName, value2);
  }
  if ("string" === typeof attrName && 1 === arguments.length) {
    const result2 = this[0].getAttribute(attrName);
    return null == result2 ? void 0 : result2;
  } else if (isPlainObject(attrName)) {
    for (const key in attrName) {
      this.attr(key, attrName[key]);
    }
  } else {
    setAttributeValue(this[0], attrName, value2);
  }
  return this;
};
initRender.prototype.removeAttr = function(attrName) {
  this[0] && dom_adapter_default.removeAttribute(this[0], attrName);
  return this;
};
initRender.prototype.prop = function(propName, value2) {
  if (!this[0]) {
    return this;
  }
  if ("string" === typeof propName && 1 === arguments.length) {
    return this[0][propName];
  } else if (isPlainObject(propName)) {
    for (const key in propName) {
      this.prop(key, propName[key]);
    }
  } else {
    dom_adapter_default.setProperty(this[0], propName, value2);
  }
  return this;
};
initRender.prototype.addClass = function(className) {
  return this.toggleClass(className, true);
};
initRender.prototype.removeClass = function(className) {
  return this.toggleClass(className, false);
};
initRender.prototype.hasClass = function(className) {
  if (!this[0] || void 0 === this[0].className) {
    return false;
  }
  const classNames = className.split(" ");
  for (let i = 0; i < classNames.length; i++) {
    if (this[0].classList) {
      if (this[0].classList.contains(classNames[i])) {
        return true;
      }
    } else {
      const className2 = isString(this[0].className) ? this[0].className : dom_adapter_default.getAttribute(this[0], "class");
      if ((className2 || "").split(" ").indexOf(classNames[i]) >= 0) {
        return true;
      }
    }
  }
  return false;
};
initRender.prototype.toggleClass = function(className, value2) {
  if (this.length > 1) {
    return repeatMethod.call(this, "toggleClass", arguments);
  }
  if (!this[0] || !className) {
    return this;
  }
  value2 = void 0 === value2 ? !this.hasClass(className) : value2;
  const classNames = className.split(" ");
  for (let i = 0; i < classNames.length; i++) {
    dom_adapter_default.setClass(this[0], classNames[i], value2);
  }
  return this;
};
initRender.prototype.html = function(value2) {
  if (!arguments.length) {
    return this[0].innerHTML;
  }
  this.empty();
  if ("string" === typeof value2 && !isTablePart(value2) || "number" === typeof value2) {
    this[0].innerHTML = value2;
    return this;
  }
  return this.append(parseHTML(value2));
};
var appendElements = function(element, nextSibling) {
  if (!this[0] || !element) {
    return;
  }
  if ("string" === typeof element) {
    element = parseHTML(element);
  } else if (element.nodeType) {
    element = [element];
  } else if (isNumeric(element)) {
    element = [dom_adapter_default.createTextNode(element)];
  }
  for (let i = 0; i < element.length; i++) {
    const item = element[i];
    let container = this[0];
    const wrapTR = "TABLE" === container.tagName && "TR" === item.tagName;
    if (wrapTR && container.tBodies && container.tBodies.length) {
      container = container.tBodies[0];
    }
    dom_adapter_default.insertElement(container, item.nodeType ? item : item[0], nextSibling);
  }
};
var setCss = function(name2, value2) {
  if (!this[0] || !this[0].style) {
    return;
  }
  if (null === value2 || "number" === typeof value2 && isNaN(value2)) {
    return;
  }
  name2 = styleProp(name2);
  for (let i = 0; i < this.length; i++) {
    this[i].style[name2] = normalizeStyleProp(name2, value2);
  }
};
initRender.prototype.css = function(name2, value2) {
  if (isString(name2)) {
    if (2 === arguments.length) {
      setCss.call(this, name2, value2);
    } else {
      if (!this[0]) {
        return;
      }
      name2 = styleProp(name2);
      const result2 = window4.getComputedStyle(this[0])[name2] || this[0].style[name2];
      return isNumeric(result2) ? result2.toString() : result2;
    }
  } else if (isPlainObject(name2)) {
    for (const key in name2) {
      setCss.call(this, key, name2[key]);
    }
  }
  return this;
};
initRender.prototype.prepend = function(element) {
  if (arguments.length > 1) {
    for (let i = 0; i < arguments.length; i++) {
      this.prepend(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element, this[0].firstChild]);
  return this;
};
initRender.prototype.append = function(element) {
  if (arguments.length > 1) {
    for (let i = 0; i < arguments.length; i++) {
      this.append(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element]);
  return this;
};
initRender.prototype.prependTo = function(element) {
  if (this.length > 1) {
    for (let i = this.length - 1; i >= 0; i--) {
      renderer(this[i]).prependTo(element);
    }
    return this;
  }
  element = renderer(element);
  if (element[0]) {
    dom_adapter_default.insertElement(element[0], this[0], element[0].firstChild);
  }
  return this;
};
initRender.prototype.appendTo = function(element) {
  if (this.length > 1) {
    return repeatMethod.call(this, "appendTo", arguments);
  }
  dom_adapter_default.insertElement(renderer(element)[0], this[0]);
  return this;
};
initRender.prototype.insertBefore = function(element) {
  if (element && element[0]) {
    dom_adapter_default.insertElement(element[0].parentNode, this[0], element[0]);
  }
  return this;
};
initRender.prototype.insertAfter = function(element) {
  if (element && element[0]) {
    dom_adapter_default.insertElement(element[0].parentNode, this[0], element[0].nextSibling);
  }
  return this;
};
initRender.prototype.before = function(element) {
  if (this[0]) {
    dom_adapter_default.insertElement(this[0].parentNode, element[0], this[0]);
  }
  return this;
};
initRender.prototype.after = function(element) {
  if (this[0]) {
    dom_adapter_default.insertElement(this[0].parentNode, element[0], this[0].nextSibling);
  }
  return this;
};
initRender.prototype.wrap = function(wrapper) {
  if (this[0]) {
    const wrap = renderer(wrapper);
    wrap.insertBefore(this);
    wrap.append(this);
  }
  return this;
};
initRender.prototype.wrapInner = function(wrapper) {
  const contents = this.contents();
  if (contents.length) {
    contents.wrap(wrapper);
  } else {
    this.append(wrapper);
  }
  return this;
};
initRender.prototype.replaceWith = function(element) {
  if (!(element && element[0])) {
    return;
  }
  if (element.is(this)) {
    return this;
  }
  element.insertBefore(this);
  this.remove();
  return element;
};
initRender.prototype.remove = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "remove", arguments);
  }
  cleanDataRecursive(this[0], true);
  dom_adapter_default.removeElement(this[0]);
  return this;
};
initRender.prototype.detach = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "detach", arguments);
  }
  dom_adapter_default.removeElement(this[0]);
  return this;
};
initRender.prototype.empty = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "empty", arguments);
  }
  cleanDataRecursive(this[0]);
  dom_adapter_default.setText(this[0], "");
  return this;
};
initRender.prototype.clone = function() {
  const result2 = [];
  for (let i = 0; i < this.length; i++) {
    result2.push(this[i].cloneNode(true));
  }
  return renderer(result2);
};
initRender.prototype.text = function(value2) {
  if (!arguments.length) {
    let result2 = "";
    for (let i = 0; i < this.length; i++) {
      result2 += this[i] && this[i].textContent || "";
    }
    return result2;
  }
  const text = isFunction(value2) ? value2() : value2;
  cleanDataRecursive(this[0], false);
  dom_adapter_default.setText(this[0], isDefined(text) ? text : "");
  return this;
};
initRender.prototype.val = function(value2) {
  if (1 === arguments.length) {
    return this.prop("value", isDefined(value2) ? value2 : "");
  }
  return this.prop("value");
};
initRender.prototype.contents = function() {
  if (!this[0]) {
    return renderer();
  }
  const result2 = [];
  result2.push.apply(result2, this[0].childNodes);
  return renderer(result2);
};
initRender.prototype.find = function(selector) {
  const result2 = renderer();
  if (!selector) {
    return result2;
  }
  const nodes = [];
  let i;
  if ("string" === typeof selector) {
    selector = selector.trim();
    for (i = 0; i < this.length; i++) {
      const element = this[i];
      if (dom_adapter_default.isElementNode(element)) {
        const elementId = element.getAttribute("id");
        let queryId = elementId || "dx-query-children";
        if (!elementId) {
          setAttributeValue(element, "id", queryId);
        }
        queryId = "[id='" + queryId + "'] ";
        const querySelector = queryId + selector.replace(/([^\\])(,)/g, "$1, " + queryId);
        nodes.push.apply(nodes, dom_adapter_default.querySelectorAll(element, querySelector));
        setAttributeValue(element, "id", elementId);
      } else if (dom_adapter_default.isDocument(element) || dom_adapter_default.isDocumentFragment(element)) {
        nodes.push.apply(nodes, dom_adapter_default.querySelectorAll(element, selector));
      }
    }
  } else {
    for (i = 0; i < this.length; i++) {
      selector = dom_adapter_default.isNode(selector) ? selector : selector[0];
      if (this[i] !== selector && this[i].contains(selector)) {
        nodes.push(selector);
      }
    }
  }
  return result2.add(nodes);
};
var isVisible = function(_, element) {
  element = element.host ?? element;
  if (!element.nodeType) {
    return true;
  }
  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
};
initRender.prototype.filter = function(selector) {
  if (!selector) {
    return renderer();
  }
  if (":visible" === selector) {
    return this.filter(isVisible);
  } else if (":hidden" === selector) {
    return this.filter(function(_, element) {
      return !isVisible(0, element);
    });
  }
  const result2 = [];
  for (let i = 0; i < this.length; i++) {
    const item = this[i];
    if (dom_adapter_default.isElementNode(item) && "string" === type(selector)) {
      dom_adapter_default.elementMatches(item, selector) && result2.push(item);
    } else if (dom_adapter_default.isNode(selector) || isWindow(selector)) {
      selector === item && result2.push(item);
    } else if (isFunction(selector)) {
      selector.call(item, i, item) && result2.push(item);
    } else {
      for (let j = 0; j < selector.length; j++) {
        selector[j] === item && result2.push(item);
      }
    }
  }
  return renderer(result2);
};
initRender.prototype.not = function(selector) {
  const result2 = [];
  const nodes = this.filter(selector).toArray();
  for (let i = 0; i < this.length; i++) {
    if (-1 === nodes.indexOf(this[i])) {
      result2.push(this[i]);
    }
  }
  return renderer(result2);
};
initRender.prototype.is = function(selector) {
  return !!this.filter(selector).length;
};
initRender.prototype.children = function(selector) {
  let result2 = [];
  for (let i = 0; i < this.length; i++) {
    const nodes = this[i] ? this[i].childNodes : [];
    for (let j = 0; j < nodes.length; j++) {
      if (dom_adapter_default.isElementNode(nodes[j])) {
        result2.push(nodes[j]);
      }
    }
  }
  result2 = renderer(result2);
  return selector ? result2.filter(selector) : result2;
};
initRender.prototype.siblings = function() {
  const element = this[0];
  if (!element || !element.parentNode) {
    return renderer();
  }
  const result2 = [];
  const parentChildNodes = element.parentNode.childNodes || [];
  for (let i = 0; i < parentChildNodes.length; i++) {
    const node = parentChildNodes[i];
    if (dom_adapter_default.isElementNode(node) && node !== element) {
      result2.push(node);
    }
  }
  return renderer(result2);
};
initRender.prototype.each = function(callback) {
  for (let i = 0; i < this.length; i++) {
    if (false === callback.call(this[i], i, this[i])) {
      break;
    }
  }
};
initRender.prototype.index = function(element) {
  if (!element) {
    return this.parent().children().index(this);
  }
  element = renderer(element);
  return this.toArray().indexOf(element[0]);
};
initRender.prototype.get = function(index2) {
  return this[index2 < 0 ? this.length + index2 : index2];
};
initRender.prototype.eq = function(index2) {
  index2 = index2 < 0 ? this.length + index2 : index2;
  return renderer(this[index2]);
};
initRender.prototype.first = function() {
  return this.eq(0);
};
initRender.prototype.last = function() {
  return this.eq(-1);
};
initRender.prototype.select = function() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].select && this[i].select();
  }
  return this;
};
initRender.prototype.parent = function(selector) {
  if (!this[0]) {
    return renderer();
  }
  const result2 = renderer(this[0].parentNode);
  return !selector || result2.is(selector) ? result2 : renderer();
};
initRender.prototype.parents = function(selector) {
  const result2 = [];
  let parent = this.parent();
  while (parent && parent[0] && !dom_adapter_default.isDocument(parent[0])) {
    if (dom_adapter_default.isElementNode(parent[0])) {
      if (!selector || parent.is(selector)) {
        result2.push(parent.get(0));
      }
    }
    parent = parent.parent();
  }
  return renderer(result2);
};
initRender.prototype.closest = function(selector) {
  if (this.is(selector)) {
    return this;
  }
  let parent = this.parent();
  while (parent && parent.length) {
    if (parent.is(selector)) {
      return parent;
    }
    parent = parent.parent();
  }
  return renderer();
};
initRender.prototype.next = function(selector) {
  if (!this[0]) {
    return renderer();
  }
  let next = renderer(this[0].nextSibling);
  if (!arguments.length) {
    return next;
  }
  while (next && next.length) {
    if (next.is(selector)) {
      return next;
    }
    next = next.next();
  }
  return renderer();
};
initRender.prototype.prev = function() {
  if (!this[0]) {
    return renderer();
  }
  return renderer(this[0].previousSibling);
};
initRender.prototype.add = function(selector) {
  const targets = renderer(selector);
  const result2 = this.toArray();
  for (let i = 0; i < targets.length; i++) {
    const target = targets[i];
    if (-1 === result2.indexOf(target)) {
      result2.push(target);
    }
  }
  return renderer(result2);
};
var emptyArray = [];
initRender.prototype.splice = function() {
  return renderer(emptyArray.splice.apply(this, arguments));
};
initRender.prototype.slice = function() {
  return renderer(emptyArray.slice.apply(this, arguments));
};
initRender.prototype.toArray = function() {
  return emptyArray.slice.call(this);
};
initRender.prototype.offset = function() {
  if (!this[0]) {
    return;
  }
  return getOffset(this[0]);
};
initRender.prototype.offsetParent = function() {
  if (!this[0]) {
    return renderer();
  }
  let offsetParent = renderer(this[0].offsetParent);
  while (offsetParent[0] && "static" === offsetParent.css("position")) {
    offsetParent = renderer(offsetParent[0].offsetParent);
  }
  offsetParent = offsetParent[0] ? offsetParent : renderer(dom_adapter_default.getDocumentElement());
  return offsetParent;
};
initRender.prototype.position = function() {
  if (!this[0]) {
    return;
  }
  let offset2;
  const marginTop = parseFloat(this.css("marginTop"));
  const marginLeft = parseFloat(this.css("marginLeft"));
  if ("fixed" === this.css("position")) {
    offset2 = this[0].getBoundingClientRect();
    return {
      top: offset2.top - marginTop,
      left: offset2.left - marginLeft
    };
  }
  offset2 = this.offset();
  const offsetParent = this.offsetParent();
  let parentOffset = {
    top: 0,
    left: 0
  };
  if ("HTML" !== offsetParent[0].nodeName) {
    parentOffset = offsetParent.offset();
  }
  parentOffset = {
    top: parentOffset.top + parseFloat(offsetParent.css("borderTopWidth")),
    left: parentOffset.left + parseFloat(offsetParent.css("borderLeftWidth"))
  };
  return {
    top: offset2.top - parentOffset.top - marginTop,
    left: offset2.left - parentOffset.left - marginLeft
  };
};
[{
  name: "scrollLeft",
  offsetProp: "pageXOffset",
  scrollWindow: function(win, value2) {
    win.scrollTo(value2, win.pageYOffset);
  }
}, {
  name: "scrollTop",
  offsetProp: "pageYOffset",
  scrollWindow: function(win, value2) {
    win.scrollTo(win.pageXOffset, value2);
  }
}].forEach(function(directionStrategy) {
  const propName = directionStrategy.name;
  initRender.prototype[propName] = function(value2) {
    if (!this[0]) {
      return;
    }
    const window26 = getWindowByElement(this[0]);
    if (void 0 === value2) {
      return window26 ? window26[directionStrategy.offsetProp] : this[0][propName];
    }
    if (window26) {
      directionStrategy.scrollWindow(window26, value2);
    } else {
      this[0][propName] = value2;
    }
    return this;
  };
});
initRender.prototype.data = function(key, value2) {
  if (!this[0]) {
    return;
  }
  if (arguments.length < 2) {
    return data.call(renderer, this[0], key);
  }
  data.call(renderer, this[0], key, value2);
  return this;
};
initRender.prototype.removeData = function(key) {
  this[0] && removeData(this[0], key);
  return this;
};
var rendererWrapper = function() {
  return renderer.apply(this, arguments);
};
Object.defineProperty(rendererWrapper, "fn", {
  enumerable: true,
  configurable: true,
  get: function() {
    return renderer.fn;
  },
  set: function(value2) {
    renderer.fn = value2;
  }
});
var renderer_base_default = {
  set: function(strategy4) {
    renderer = strategy4;
  },
  get: function() {
    return rendererWrapper;
  }
};

// ../../../../../../node_modules/devextreme/esm/core/renderer.js
var renderer_default = renderer_base_default.get();

// ../../../../../../node_modules/devextreme/esm/core/component_registrator_callbacks.js
var component_registrator_callbacks_default = new MemorizedCallbacks();

// ../../../../../../node_modules/devextreme/esm/events/core/event_registrator.js
var registerEvent = function(name2, eventObject) {
  const strategy4 = {};
  if ("noBubble" in eventObject) {
    strategy4.noBubble = eventObject.noBubble;
  }
  if ("bindType" in eventObject) {
    strategy4.bindType = eventObject.bindType;
  }
  if ("delegateType" in eventObject) {
    strategy4.delegateType = eventObject.delegateType;
  }
  each(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], function(_, methodName) {
    if (!eventObject[methodName]) {
      return;
    }
    strategy4[methodName] = function() {
      const args = [].slice.call(arguments);
      args.unshift(this);
      return eventObject[methodName].apply(eventObject, args);
    };
  });
  event_registrator_callbacks_default.fire(name2, strategy4);
};
registerEvent.callbacks = event_registrator_callbacks_default;
var event_registrator_default = registerEvent;

// ../../../../../../node_modules/devextreme/esm/events/remove.js
var removeEvent = "dxremove";
var eventPropName = "dxRemoveEvent";
beforeCleanData(function(elements) {
  elements = [].slice.call(elements);
  for (let i = 0; i < elements.length; i++) {
    const $element = renderer_default(elements[i]);
    if ($element.prop(eventPropName)) {
      $element[0][eventPropName] = null;
      events_engine_default.triggerHandler($element, "dxremove");
    }
  }
});
event_registrator_default("dxremove", {
  noBubble: true,
  setup: function(element) {
    renderer_default(element).prop(eventPropName, true);
  }
});

// ../../../../../../node_modules/devextreme/esm/core/utils/public_component.js
var componentNames = /* @__PURE__ */ new WeakMap();
var nextAnonymousComponent = 0;
var getName = function(componentClass, newName) {
  if (isDefined(newName)) {
    componentNames.set(componentClass, newName);
    return;
  }
  if (!componentNames.has(componentClass)) {
    const generatedName = "dxPrivateComponent" + nextAnonymousComponent++;
    componentNames.set(componentClass, generatedName);
    return generatedName;
  }
  return componentNames.get(componentClass);
};
function attachInstanceToElement($element, componentInstance, disposeFn) {
  const data2 = data($element.get(0));
  const name2 = getName(componentInstance.constructor);
  data2[name2] = componentInstance;
  if (disposeFn) {
    events_engine_default.one($element, removeEvent, function() {
      disposeFn.call(componentInstance);
    });
  }
  if (!data2.dxComponents) {
    data2.dxComponents = [];
  }
  data2.dxComponents.push(name2);
}
function getInstanceByElement($element, componentClass) {
  const name2 = getName(componentClass);
  return data($element.get(0), name2);
}

// ../../../../../../node_modules/devextreme/esm/core/component_registrator.js
var registerComponent = function(name2, namespace, componentClass) {
  if (!componentClass) {
    componentClass = namespace;
  } else {
    namespace[name2] = componentClass;
  }
  getName(componentClass, name2);
  component_registrator_callbacks_default.fire(name2, componentClass);
};
var registerRendererComponent = function(name2, componentClass) {
  renderer_default.fn[name2] = function(options2) {
    const isMemberInvoke = "string" === typeof options2;
    let result2;
    if (isMemberInvoke) {
      const memberName = options2;
      const memberArgs = [].slice.call(arguments).slice(1);
      this.each(function() {
        const instance = componentClass.getInstance(this);
        if (!instance) {
          throw errors_default.Error("E0009", name2);
        }
        const member = instance[memberName];
        const memberValue = member.apply(instance, memberArgs);
        if (void 0 === result2) {
          result2 = memberValue;
        }
      });
    } else {
      this.each(function() {
        const instance = componentClass.getInstance(this);
        if (instance) {
          instance.option(options2);
        } else {
          new componentClass(this, options2);
        }
      });
      result2 = this;
    }
    return result2;
  };
};
component_registrator_callbacks_default.add(registerRendererComponent);
var component_registrator_default = registerComponent;

// ../../../../../../node_modules/devextreme/esm/events/utils/add_namespace.js
var addNamespace = (eventNames, namespace) => {
  if (!namespace) {
    throw errors_default.Error("E0017");
  }
  if (Array.isArray(eventNames)) {
    return eventNames.map((eventName) => addNamespace(eventName, namespace)).join(" ");
  }
  if (-1 !== eventNames.indexOf(" ")) {
    return addNamespace(eventNames.split(/\s+/g), namespace);
  }
  return `${eventNames}.${namespace}`;
};
var add_namespace_default = addNamespace;

// ../../../../../../node_modules/devextreme/esm/ui/widget/selectors.js
var focusableFn = function(element, tabIndex) {
  if (!visible(element)) {
    return false;
  }
  const nodeName = element.nodeName.toLowerCase();
  const isTabIndexNotNaN = !isNaN(tabIndex);
  const isDisabled = element.disabled;
  const isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName);
  const isHyperlink = "a" === nodeName;
  let isFocusable;
  const isContentEditable = element.isContentEditable;
  if (isDefaultFocus || isContentEditable) {
    isFocusable = !isDisabled;
  } else if (isHyperlink) {
    isFocusable = element.href || isTabIndexNotNaN;
  } else {
    isFocusable = isTabIndexNotNaN;
  }
  return isFocusable;
};
function visible(element) {
  const $element = renderer_default(element);
  return $element.is(":visible") && "hidden" !== $element.css("visibility") && "hidden" !== $element.parents().css("visibility");
}
var focusable = function(index2, element) {
  return focusableFn(element, renderer_default(element).attr("tabIndex"));
};
var tabbable = function(index2, element) {
  const tabIndex = renderer_default(element).attr("tabIndex");
  return (isNaN(tabIndex) || tabIndex >= 0) && focusableFn(element, tabIndex);
};
var focused = function($element) {
  const element = renderer_default($element).get(0);
  return dom_adapter_default.getActiveElement(element) === element;
};

// ../../../../../../node_modules/devextreme/esm/events/utils/index.js
var KEY_MAP = {
  backspace: "backspace",
  tab: "tab",
  enter: "enter",
  escape: "escape",
  pageup: "pageUp",
  pagedown: "pageDown",
  end: "end",
  home: "home",
  arrowleft: "leftArrow",
  arrowup: "upArrow",
  arrowright: "rightArrow",
  arrowdown: "downArrow",
  delete: "del",
  " ": "space",
  f: "F",
  a: "A",
  "*": "asterisk",
  "-": "minus",
  alt: "alt",
  control: "control",
  shift: "shift"
};
var LEGACY_KEY_CODES = {
  8: "backspace",
  9: "tab",
  13: "enter",
  27: "escape",
  33: "pageUp",
  34: "pageDown",
  35: "end",
  36: "home",
  37: "leftArrow",
  38: "upArrow",
  39: "rightArrow",
  40: "downArrow",
  46: "del",
  32: "space",
  70: "F",
  65: "A",
  106: "asterisk",
  109: "minus",
  189: "minus",
  173: "minus",
  16: "shift",
  17: "control",
  18: "alt"
};
var EVENT_SOURCES_REGEX = {
  dx: /^dx/i,
  mouse: /(mouse|wheel)/i,
  touch: /^touch/i,
  keyboard: /^key/i,
  pointer: /^(ms)?pointer/i
};
var fixMethod = (e) => e;
var copyEvent = (originalEvent) => fixMethod(events_engine_default.Event(originalEvent, originalEvent), originalEvent);
var isDxEvent = (e) => "dx" === eventSource(e);
var isNativeMouseEvent = (e) => "mouse" === eventSource(e);
var isNativeTouchEvent = (e) => "touch" === eventSource(e);
var eventSource = (_ref) => {
  let {
    type: type2
  } = _ref;
  let result2 = "other";
  each(EVENT_SOURCES_REGEX, function(key) {
    if (this.test(type2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
};
var isPointerEvent = (e) => "pointer" === eventSource(e);
var isMouseEvent = (e) => isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "mouse" === e.pointerType;
var isDxMouseWheelEvent = (e) => e && "dxmousewheel" === e.type;
var isTouchEvent = (e) => isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "touch" === e.pointerType;
var isFakeClickEvent = (_ref2) => {
  let {
    screenX,
    offsetX,
    pageX
  } = _ref2;
  return 0 === screenX && !offsetX && 0 === pageX;
};
var eventData = (_ref3) => {
  let {
    pageX,
    pageY,
    timeStamp
  } = _ref3;
  return {
    x: pageX,
    y: pageY,
    time: timeStamp
  };
};
var eventDelta = (from, to) => ({
  x: to.x - from.x,
  y: to.y - from.y,
  time: to.time - from.time || 1
});
var hasTouches = (e) => {
  const {
    originalEvent,
    pointers
  } = e;
  if (isNativeTouchEvent(e)) {
    return (originalEvent.touches || []).length;
  }
  if (isDxEvent(e)) {
    return (pointers || []).length;
  }
  return 0;
};
var skipEvents = false;
var needSkipEvent = (e) => {
  if (skipEvents) {
    return true;
  }
  const {
    target
  } = e;
  const $target = renderer_default(target);
  const isContentEditable = (null === target || void 0 === target ? void 0 : target.isContentEditable) || (null === target || void 0 === target ? void 0 : target.hasAttribute("contenteditable"));
  const touchInEditable = $target.is("input, textarea, select") || isContentEditable;
  if (isDxMouseWheelEvent(e)) {
    const isTextArea = $target.is("textarea") && $target.hasClass("dx-texteditor-input");
    if (isTextArea || isContentEditable) {
      return false;
    }
    const isInputFocused = $target.is("input[type='number'], textarea, select") && $target.is(":focus");
    return isInputFocused;
  }
  if (isMouseEvent(e)) {
    return touchInEditable || e.which > 1;
  }
  if (isTouchEvent(e)) {
    return touchInEditable && focused($target);
  }
};
var createEvent = (originalEvent, args) => {
  const event = copyEvent(originalEvent);
  args && extend(event, args);
  return event;
};
var fireEvent = (props) => {
  const {
    originalEvent,
    delegateTarget
  } = props;
  const event = createEvent(originalEvent, props);
  events_engine_default.trigger(delegateTarget || event.target, event);
  return event;
};
var normalizeKeyName = (_ref4) => {
  let {
    key,
    which
  } = _ref4;
  const normalizedKey = KEY_MAP[null === key || void 0 === key ? void 0 : key.toLowerCase()] || key;
  const normalizedKeyFromWhich = LEGACY_KEY_CODES[which];
  if (normalizedKeyFromWhich && normalizedKey === key) {
    return normalizedKeyFromWhich;
  } else if (!normalizedKey && which) {
    return String.fromCharCode(which);
  }
  return normalizedKey;
};
var getChar = (_ref5) => {
  let {
    key,
    which
  } = _ref5;
  return key || String.fromCharCode(which);
};
var addNamespace2 = add_namespace_default;
var isCommandKeyPressed = (_ref6) => {
  let {
    ctrlKey,
    metaKey
  } = _ref6;
  return ctrlKey || metaKey;
};

// ../../../../../../node_modules/devextreme/esm/events/core/wheel.js
var EVENT_NAME = "dxmousewheel";
var wheel = {
  setup: function(element) {
    const $element = renderer_default(element);
    events_engine_default.on($element, addNamespace2("wheel", "dxWheel"), wheel._wheelHandler.bind(wheel));
  },
  teardown: function(element) {
    events_engine_default.off(element, ".dxWheel");
  },
  _wheelHandler: function(e) {
    const {
      deltaMode,
      deltaY,
      deltaX,
      deltaZ
    } = e.originalEvent;
    fireEvent({
      type: EVENT_NAME,
      originalEvent: e,
      delta: this._normalizeDelta(deltaY, deltaMode),
      deltaX,
      deltaY,
      deltaZ,
      deltaMode,
      pointerType: "mouse"
    });
    e.stopPropagation();
  },
  _normalizeDelta(delta) {
    let deltaMode = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (0 === deltaMode) {
      return -delta;
    } else {
      return -30 * delta;
    }
  }
};
event_registrator_default(EVENT_NAME, wheel);

// ../../../../../../node_modules/devextreme/esm/localization/cldr-data/parent_locales.js
var parent_locales_default = {
  "en-150": "en-001",
  "en-AG": "en-001",
  "en-AI": "en-001",
  "en-AU": "en-001",
  "en-BB": "en-001",
  "en-BM": "en-001",
  "en-BS": "en-001",
  "en-BW": "en-001",
  "en-BZ": "en-001",
  "en-CC": "en-001",
  "en-CK": "en-001",
  "en-CM": "en-001",
  "en-CX": "en-001",
  "en-CY": "en-001",
  "en-DG": "en-001",
  "en-DM": "en-001",
  "en-ER": "en-001",
  "en-FJ": "en-001",
  "en-FK": "en-001",
  "en-FM": "en-001",
  "en-GB": "en-001",
  "en-GD": "en-001",
  "en-GG": "en-001",
  "en-GH": "en-001",
  "en-GI": "en-001",
  "en-GM": "en-001",
  "en-GY": "en-001",
  "en-HK": "en-001",
  "en-IE": "en-001",
  "en-IL": "en-001",
  "en-IM": "en-001",
  "en-IN": "en-001",
  "en-IO": "en-001",
  "en-JE": "en-001",
  "en-JM": "en-001",
  "en-KE": "en-001",
  "en-KI": "en-001",
  "en-KN": "en-001",
  "en-KY": "en-001",
  "en-LC": "en-001",
  "en-LR": "en-001",
  "en-LS": "en-001",
  "en-MG": "en-001",
  "en-MO": "en-001",
  "en-MS": "en-001",
  "en-MT": "en-001",
  "en-MU": "en-001",
  "en-MV": "en-001",
  "en-MW": "en-001",
  "en-MY": "en-001",
  "en-NA": "en-001",
  "en-NF": "en-001",
  "en-NG": "en-001",
  "en-NR": "en-001",
  "en-NU": "en-001",
  "en-NZ": "en-001",
  "en-PG": "en-001",
  "en-PK": "en-001",
  "en-PN": "en-001",
  "en-PW": "en-001",
  "en-RW": "en-001",
  "en-SB": "en-001",
  "en-SC": "en-001",
  "en-SD": "en-001",
  "en-SG": "en-001",
  "en-SH": "en-001",
  "en-SL": "en-001",
  "en-SS": "en-001",
  "en-SX": "en-001",
  "en-SZ": "en-001",
  "en-TC": "en-001",
  "en-TK": "en-001",
  "en-TO": "en-001",
  "en-TT": "en-001",
  "en-TV": "en-001",
  "en-TZ": "en-001",
  "en-UG": "en-001",
  "en-VC": "en-001",
  "en-VG": "en-001",
  "en-VU": "en-001",
  "en-WS": "en-001",
  "en-ZA": "en-001",
  "en-ZM": "en-001",
  "en-ZW": "en-001",
  "en-AT": "en-150",
  "en-BE": "en-150",
  "en-CH": "en-150",
  "en-DE": "en-150",
  "en-DK": "en-150",
  "en-FI": "en-150",
  "en-NL": "en-150",
  "en-SE": "en-150",
  "en-SI": "en-150",
  "hi-Latn": "en-IN",
  "es-AR": "es-419",
  "es-BO": "es-419",
  "es-BR": "es-419",
  "es-BZ": "es-419",
  "es-CL": "es-419",
  "es-CO": "es-419",
  "es-CR": "es-419",
  "es-CU": "es-419",
  "es-DO": "es-419",
  "es-EC": "es-419",
  "es-GT": "es-419",
  "es-HN": "es-419",
  "es-MX": "es-419",
  "es-NI": "es-419",
  "es-PA": "es-419",
  "es-PE": "es-419",
  "es-PR": "es-419",
  "es-PY": "es-419",
  "es-SV": "es-419",
  "es-US": "es-419",
  "es-UY": "es-419",
  "es-VE": "es-419",
  nb: "no",
  nn: "no",
  "pt-AO": "pt-PT",
  "pt-CH": "pt-PT",
  "pt-CV": "pt-PT",
  "pt-FR": "pt-PT",
  "pt-GQ": "pt-PT",
  "pt-GW": "pt-PT",
  "pt-LU": "pt-PT",
  "pt-MO": "pt-PT",
  "pt-MZ": "pt-PT",
  "pt-ST": "pt-PT",
  "pt-TL": "pt-PT",
  "az-Arab": "und",
  "az-Cyrl": "und",
  "bal-Latn": "und",
  "blt-Latn": "und",
  "bm-Nkoo": "und",
  "bs-Cyrl": "und",
  "byn-Latn": "und",
  "cu-Glag": "und",
  "dje-Arab": "und",
  "dyo-Arab": "und",
  "en-Dsrt": "und",
  "en-Shaw": "und",
  "ff-Adlm": "und",
  "ff-Arab": "und",
  "ha-Arab": "und",
  "iu-Latn": "und",
  "kk-Arab": "und",
  "ks-Deva": "und",
  "ku-Arab": "und",
  "ky-Arab": "und",
  "ky-Latn": "und",
  "ml-Arab": "und",
  "mn-Mong": "und",
  "mni-Mtei": "und",
  "ms-Arab": "und",
  "pa-Arab": "und",
  "sat-Deva": "und",
  "sd-Deva": "und",
  "sd-Khoj": "und",
  "sd-Sind": "und",
  "shi-Latn": "und",
  "so-Arab": "und",
  "sr-Latn": "und",
  "sw-Arab": "und",
  "tg-Arab": "und",
  "ug-Cyrl": "und",
  "uz-Arab": "und",
  "uz-Cyrl": "und",
  "vai-Latn": "und",
  "wo-Arab": "und",
  "yo-Arab": "und",
  "yue-Hans": "und",
  "zh-Hant": "und",
  "zh-Hant-MO": "zh-Hant-HK"
};

// ../../../../../../node_modules/devextreme/esm/localization/parentLocale.js
var parentLocale_default = (parentLocales, locale) => {
  const parentLocale = parentLocales[locale];
  if (parentLocale) {
    return "root" !== parentLocale && parentLocale;
  }
  return locale.substr(0, locale.lastIndexOf("-"));
};

// ../../../../../../node_modules/devextreme/esm/localization/core.js
var core_default = dependency_injector_default({
  locale: (() => {
    let currentLocale = "en";
    return (locale) => {
      if (!locale) {
        return currentLocale;
      }
      currentLocale = locale;
    };
  })(),
  getValueByClosestLocale: function(getter) {
    let locale = this.locale();
    let value2 = getter(locale);
    let isRootLocale;
    while (!value2 && !isRootLocale) {
      locale = parentLocale_default(parent_locales_default, locale);
      if (locale) {
        value2 = getter(locale);
      } else {
        isRootLocale = true;
      }
    }
    if (void 0 === value2 && "en" !== locale) {
      return getter("en");
    }
    return value2;
  }
});

// ../../../../../../node_modules/devextreme/esm/localization/default_messages.js
var defaultMessages = {
  en: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    Close: "Close",
    Clear: "Clear",
    Done: "Done",
    Loading: "Loading...",
    Select: "Select...",
    Search: "Search",
    Back: "Back",
    OK: "OK",
    "dxCollectionWidget-noDataText": "No data to display",
    "dxDropDownEditor-selectLabel": "Select",
    "validation-required": "Required",
    "validation-required-formatted": "{0} is required",
    "validation-numeric": "Value must be a number",
    "validation-numeric-formatted": "{0} must be a number",
    "validation-range": "Value is out of range",
    "validation-range-formatted": "{0} is out of range",
    "validation-stringLength": "The length of the value is not correct",
    "validation-stringLength-formatted": "The length of {0} is not correct",
    "validation-custom": "Value is invalid",
    "validation-custom-formatted": "{0} is invalid",
    "validation-async": "Value is invalid",
    "validation-async-formatted": "{0} is invalid",
    "validation-compare": "Values do not match",
    "validation-compare-formatted": "{0} does not match",
    "validation-pattern": "Value does not match pattern",
    "validation-pattern-formatted": "{0} does not match pattern",
    "validation-email": "Email is invalid",
    "validation-email-formatted": "{0} is invalid",
    "validation-mask": "Value is invalid",
    "dxLookup-searchPlaceholder": "Minimum character number: {0}",
    "dxList-pullingDownText": "Pull down to refresh...",
    "dxList-pulledDownText": "Release to refresh...",
    "dxList-refreshingText": "Refreshing...",
    "dxList-pageLoadingText": "Loading...",
    "dxList-nextButtonText": "More",
    "dxList-selectAll": "Select All",
    "dxList-listAriaLabel": "Items",
    "dxList-listAriaLabel-deletable": "Deletable items",
    "dxListEditDecorator-delete": "Delete",
    "dxListEditDecorator-more": "More",
    "dxScrollView-pullingDownText": "Pull down to refresh...",
    "dxScrollView-pulledDownText": "Release to refresh...",
    "dxScrollView-refreshingText": "Refreshing...",
    "dxScrollView-reachBottomText": "Loading...",
    "dxDateBox-simulatedDataPickerTitleTime": "Select time",
    "dxDateBox-simulatedDataPickerTitleDate": "Select date",
    "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
    "dxDateBox-validation-datetime": "Value must be a date or time",
    "dxDateRangeBox-invalidStartDateMessage": "Start value must be a date",
    "dxDateRangeBox-invalidEndDateMessage": "End value must be a date",
    "dxDateRangeBox-startDateOutOfRangeMessage": "Start date is out of range",
    "dxDateRangeBox-endDateOutOfRangeMessage": "End date is out of range",
    "dxDateRangeBox-startDateLabel": "Start Date",
    "dxDateRangeBox-endDateLabel": "End Date",
    "dxFileUploader-selectFile": "Select a file",
    "dxFileUploader-dropFile": "or Drop a file here",
    "dxFileUploader-bytes": "bytes",
    "dxFileUploader-kb": "KB",
    "dxFileUploader-Mb": "MB",
    "dxFileUploader-Gb": "GB",
    "dxFileUploader-upload": "Upload",
    "dxFileUploader-uploaded": "Uploaded",
    "dxFileUploader-readyToUpload": "Ready to upload",
    "dxFileUploader-uploadAbortedMessage": "Upload cancelled",
    "dxFileUploader-uploadFailedMessage": "Upload failed",
    "dxFileUploader-invalidFileExtension": "File type is not allowed",
    "dxFileUploader-invalidMaxFileSize": "File is too large",
    "dxFileUploader-invalidMinFileSize": "File is too small",
    "dxRangeSlider-ariaFrom": "From",
    "dxRangeSlider-ariaTill": "Till",
    "dxSwitch-switchedOnText": "ON",
    "dxSwitch-switchedOffText": "OFF",
    "dxForm-optionalMark": "optional",
    "dxForm-requiredMessage": "{0} is required",
    "dxNumberBox-invalidValueMessage": "Value must be a number",
    "dxNumberBox-noDataText": "No data",
    "dxDataGrid-emptyHeaderWithColumnChooserText": "Use {0} to display columns",
    "dxDataGrid-emptyHeaderWithGroupPanelText": "Drag a column from the group panel here",
    "dxDataGrid-emptyHeaderWithColumnChooserAndGroupPanelText": "Use {0} or drag a column from the group panel",
    "dxDataGrid-emptyHeaderColumnChooserText": "column chooser",
    "dxDataGrid-columnChooserTitle": "Column Chooser",
    "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
    "dxDataGrid-groupContinuesMessage": "Continues on the next page",
    "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
    "dxDataGrid-groupHeaderText": "Group by This Column",
    "dxDataGrid-ungroupHeaderText": "Ungroup",
    "dxDataGrid-ungroupAllText": "Ungroup All",
    "dxDataGrid-editingEditRow": "Edit",
    "dxDataGrid-editingSaveRowChanges": "Save",
    "dxDataGrid-editingCancelRowChanges": "Cancel",
    "dxDataGrid-editingDeleteRow": "Delete",
    "dxDataGrid-editingUndeleteRow": "Undelete",
    "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
    "dxDataGrid-validationCancelChanges": "Cancel changes",
    "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
    "dxDataGrid-noDataText": "No data",
    "dxDataGrid-searchPanelPlaceholder": "Search...",
    "dxDataGrid-filterRowShowAllText": "(All)",
    "dxDataGrid-filterRowResetOperationText": "Reset",
    "dxDataGrid-filterRowOperationEquals": "Equals",
    "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
    "dxDataGrid-filterRowOperationLess": "Less than",
    "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
    "dxDataGrid-filterRowOperationGreater": "Greater than",
    "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
    "dxDataGrid-filterRowOperationStartsWith": "Starts with",
    "dxDataGrid-filterRowOperationContains": "Contains",
    "dxDataGrid-filterRowOperationNotContains": "Does not contain",
    "dxDataGrid-filterRowOperationEndsWith": "Ends with",
    "dxDataGrid-filterRowOperationBetween": "Between",
    "dxDataGrid-filterRowOperationBetweenStartText": "Start",
    "dxDataGrid-filterRowOperationBetweenEndText": "End",
    "dxDataGrid-ariaSearchBox": "Search box",
    "dxDataGrid-applyFilterText": "Apply filter",
    "dxDataGrid-trueText": "true",
    "dxDataGrid-falseText": "false",
    "dxDataGrid-sortingAscendingText": "Sort Ascending",
    "dxDataGrid-sortingDescendingText": "Sort Descending",
    "dxDataGrid-sortingClearText": "Clear Sorting",
    "dxDataGrid-ariaNotSortedColumn": "Not sorted column",
    "dxDataGrid-ariaSortedAscendingColumn": "Column sorted in ascending order",
    "dxDataGrid-ariaSortedDescendingColumn": "Column sorted in descending order",
    "dxDataGrid-ariaSortIndex": "Sort index {0}",
    "dxDataGrid-editingSaveAllChanges": "Save changes",
    "dxDataGrid-editingCancelAllChanges": "Discard changes",
    "dxDataGrid-editingAddRow": "Add a row",
    "dxDataGrid-summaryMin": "Min: {0}",
    "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
    "dxDataGrid-summaryMax": "Max: {0}",
    "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
    "dxDataGrid-summaryAvg": "Avg: {0}",
    "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
    "dxDataGrid-summarySum": "Sum: {0}",
    "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
    "dxDataGrid-summaryCount": "Count: {0}",
    "dxDataGrid-columnFixingFix": "Fix",
    "dxDataGrid-columnFixingUnfix": "Unfix",
    "dxDataGrid-columnFixingLeftPosition": "To the left",
    "dxDataGrid-columnFixingRightPosition": "To the right",
    "dxDataGrid-exportTo": "Export",
    "dxDataGrid-exportToExcel": "Export to Excel file",
    "dxDataGrid-exporting": "Exporting...",
    "dxDataGrid-excelFormat": "Excel file",
    "dxDataGrid-selectedRows": "Selected rows",
    "dxDataGrid-exportSelectedRows": "Export selected rows to {0}",
    "dxDataGrid-exportAll": "Export all data to {0}",
    "dxDataGrid-headerFilterLabel": "Filter options",
    "dxDataGrid-headerFilterIndicatorLabel": "Show filter options for column '{0}'",
    "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
    "dxDataGrid-headerFilterOK": "OK",
    "dxDataGrid-headerFilterCancel": "Cancel",
    "dxDataGrid-ariaAdaptiveCollapse": "Hide additional data",
    "dxDataGrid-ariaAdaptiveExpand": "Display additional data",
    "dxDataGrid-ariaColumn": "Column",
    "dxDataGrid-ariaColumnHeader": "Column header",
    "dxDataGrid-ariaValue": "Value",
    "dxDataGrid-ariaError": "Error",
    "dxDataGrid-ariaRevertButton": "Press Escape to discard the changes",
    "dxDataGrid-ariaFilterCell": "Filter cell",
    "dxDataGrid-ariaCollapse": "Collapse",
    "dxDataGrid-ariaModifiedCell": "Modified",
    "dxDataGrid-ariaDeletedCell": "Deleted",
    "dxDataGrid-ariaEditableCell": "Editable",
    "dxDataGrid-ariaExpand": "Expand",
    "dxDataGrid-ariaCollapsedRow": "Collapsed row",
    "dxDataGrid-ariaExpandedRow": "Expanded row",
    "dxDataGrid-ariaDataGrid": "Data grid with {0} rows and {1} columns",
    "dxDataGrid-ariaSearchInGrid": "Search in the data grid",
    "dxDataGrid-ariaSelectAll": "Select all",
    "dxDataGrid-ariaSelectRow": "Select row",
    "dxDataGrid-ariaToolbar": "Data grid toolbar",
    "dxDataGrid-ariaEditForm": "Edit form",
    "dxDataGrid-filterBuilderPopupTitle": "Filter Builder",
    "dxDataGrid-filterPanelCreateFilter": "Create Filter",
    "dxDataGrid-filterPanelClearFilter": "Clear",
    "dxDataGrid-filterPanelFilterEnabledHint": "Enable the filter",
    "dxDataGrid-masterDetail": "Cell with details",
    "dxTreeList-ariaTreeList": "Tree list with {0} rows and {1} columns",
    "dxTreeList-ariaSearchInGrid": "Search in the tree list",
    "dxTreeList-ariaToolbar": "Tree list toolbar",
    "dxTreeList-editingAddRowToNode": "Add",
    "dxPager-infoText": "Page {0} of {1} ({2} items)",
    "dxPager-pagesCountText": "of",
    "dxPager-pageSize": "Items per page: {0}",
    "dxPager-pageSizesAllText": "All",
    "dxPager-page": "Page {0}",
    "dxPager-prevPage": "Previous Page",
    "dxPager-nextPage": "Next Page",
    "dxPager-ariaLabel": "Page Navigation",
    "dxPager-ariaPageSize": "Page size",
    "dxPager-ariaPageNumber": "Page number",
    "dxPivotGrid-grandTotal": "Grand Total",
    "dxPivotGrid-total": "{0} Total",
    "dxPivotGrid-fieldChooserTitle": "Field Chooser",
    "dxPivotGrid-showFieldChooser": "Show Field Chooser",
    "dxPivotGrid-expandAll": "Expand All",
    "dxPivotGrid-collapseAll": "Collapse All",
    "dxPivotGrid-sortColumnBySummary": 'Sort "{0}" by This Column',
    "dxPivotGrid-sortRowBySummary": 'Sort "{0}" by This Row',
    "dxPivotGrid-removeAllSorting": "Remove All Sorting",
    "dxPivotGrid-dataNotAvailable": "N/A",
    "dxPivotGrid-rowFields": "Row Fields",
    "dxPivotGrid-columnFields": "Column Fields",
    "dxPivotGrid-dataFields": "Data Fields",
    "dxPivotGrid-filterFields": "Filter Fields",
    "dxPivotGrid-allFields": "All Fields",
    "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
    "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
    "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
    "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
    "dxScheduler-editorLabelTitle": "Subject",
    "dxScheduler-editorLabelStartDate": "Start Date",
    "dxScheduler-editorLabelEndDate": "End Date",
    "dxScheduler-editorLabelDescription": "Description",
    "dxScheduler-editorLabelRecurrence": "Repeat",
    "dxScheduler-openAppointment": "Open appointment",
    "dxScheduler-recurrenceNever": "Never",
    "dxScheduler-recurrenceMinutely": "Every minute",
    "dxScheduler-recurrenceHourly": "Hourly",
    "dxScheduler-recurrenceDaily": "Daily",
    "dxScheduler-recurrenceWeekly": "Weekly",
    "dxScheduler-recurrenceMonthly": "Monthly",
    "dxScheduler-recurrenceYearly": "Yearly",
    "dxScheduler-recurrenceRepeatEvery": "Repeat Every",
    "dxScheduler-recurrenceRepeatOn": "Repeat On",
    "dxScheduler-recurrenceEnd": "End repeat",
    "dxScheduler-recurrenceAfter": "After",
    "dxScheduler-recurrenceOn": "On",
    "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
    "dxScheduler-recurrenceRepeatHourly": "hour(s)",
    "dxScheduler-recurrenceRepeatDaily": "day(s)",
    "dxScheduler-recurrenceRepeatWeekly": "week(s)",
    "dxScheduler-recurrenceRepeatMonthly": "month(s)",
    "dxScheduler-recurrenceRepeatYearly": "year(s)",
    "dxScheduler-switcherDay": "Day",
    "dxScheduler-switcherWeek": "Week",
    "dxScheduler-switcherWorkWeek": "Work Week",
    "dxScheduler-switcherMonth": "Month",
    "dxScheduler-switcherAgenda": "Agenda",
    "dxScheduler-switcherTimelineDay": "Timeline Day",
    "dxScheduler-switcherTimelineWeek": "Timeline Week",
    "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
    "dxScheduler-switcherTimelineMonth": "Timeline Month",
    "dxScheduler-recurrenceRepeatOnDate": "on date",
    "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
    "dxScheduler-allDay": "All day",
    "dxScheduler-confirmRecurrenceEditTitle": "Edit Recurring Appointment",
    "dxScheduler-confirmRecurrenceDeleteTitle": "Delete Recurring Appointment",
    "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
    "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
    "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
    "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
    "dxScheduler-noTimezoneTitle": "No timezone",
    "dxScheduler-moreAppointments": "{0} more",
    "dxCalendar-currentDay": "Today",
    "dxCalendar-currentMonth": "Current month",
    "dxCalendar-currentYear": "Current year",
    "dxCalendar-currentYearRange": "Current year range",
    "dxCalendar-todayButtonText": "Today",
    "dxCalendar-ariaWidgetName": "Calendar",
    "dxCalendar-previousMonthButtonLabel": "Previous month",
    "dxCalendar-previousYearButtonLabel": "Previous year",
    "dxCalendar-previousDecadeButtonLabel": "Previous decade",
    "dxCalendar-previousCenturyButtonLabel": "Previous century",
    "dxCalendar-nextMonthButtonLabel": "Next month",
    "dxCalendar-nextYearButtonLabel": "Next year",
    "dxCalendar-nextDecadeButtonLabel": "Next decade",
    "dxCalendar-nextCenturyButtonLabel": "Next century",
    "dxCalendar-captionMonthLabel": "Month selection",
    "dxCalendar-captionYearLabel": "Year selection",
    "dxCalendar-captionDecadeLabel": "Decade selection",
    "dxCalendar-captionCenturyLabel": "Century selection",
    "dxCalendar-selectedDate": "The selected date is {0}",
    "dxCalendar-selectedDateRange": "The selected date range is from {0} to {1}",
    "dxColorView-ariaRed": "Red",
    "dxColorView-ariaGreen": "Green",
    "dxColorView-ariaBlue": "Blue",
    "dxColorView-ariaAlpha": "Transparency",
    "dxColorView-ariaHex": "Color code",
    "dxTagBox-selected": "{0} selected",
    "dxTagBox-allSelected": "All selected ({0})",
    "dxTagBox-moreSelected": "{0} more",
    "dxTagBox-tagRoleDescription": "Tag. Press the delete button to remove this tag",
    "vizExport-printingButtonText": "Print",
    "vizExport-titleMenuText": "Exporting/Printing",
    "vizExport-exportButtonText": "{0} file",
    "dxFilterBuilder-and": "And",
    "dxFilterBuilder-or": "Or",
    "dxFilterBuilder-notAnd": "Not And",
    "dxFilterBuilder-notOr": "Not Or",
    "dxFilterBuilder-addCondition": "Add Condition",
    "dxFilterBuilder-addGroup": "Add Group",
    "dxFilterBuilder-enterValueText": "<enter a value>",
    "dxFilterBuilder-filterOperationEquals": "Equals",
    "dxFilterBuilder-filterOperationNotEquals": "Does not equal",
    "dxFilterBuilder-filterOperationLess": "Is less than",
    "dxFilterBuilder-filterOperationLessOrEquals": "Is less than or equal to",
    "dxFilterBuilder-filterOperationGreater": "Is greater than",
    "dxFilterBuilder-filterOperationGreaterOrEquals": "Is greater than or equal to",
    "dxFilterBuilder-filterOperationStartsWith": "Starts with",
    "dxFilterBuilder-filterOperationContains": "Contains",
    "dxFilterBuilder-filterOperationNotContains": "Does not contain",
    "dxFilterBuilder-filterOperationEndsWith": "Ends with",
    "dxFilterBuilder-filterOperationIsBlank": "Is blank",
    "dxFilterBuilder-filterOperationIsNotBlank": "Is not blank",
    "dxFilterBuilder-filterOperationBetween": "Is between",
    "dxFilterBuilder-filterOperationAnyOf": "Is any of",
    "dxFilterBuilder-filterOperationNoneOf": "Is none of",
    "dxHtmlEditor-dialogColorCaption": "Change Font Color",
    "dxHtmlEditor-dialogBackgroundCaption": "Change Background Color",
    "dxHtmlEditor-dialogLinkCaption": "Add Link",
    "dxHtmlEditor-dialogLinkUrlField": "URL",
    "dxHtmlEditor-dialogLinkTextField": "Text",
    "dxHtmlEditor-dialogLinkTargetField": "Open link in new window",
    "dxHtmlEditor-dialogImageCaption": "Add Image",
    "dxHtmlEditor-dialogImageUrlField": "URL",
    "dxHtmlEditor-dialogImageAltField": "Alternate text",
    "dxHtmlEditor-dialogImageWidthField": "Width (px)",
    "dxHtmlEditor-dialogImageHeightField": "Height (px)",
    "dxHtmlEditor-dialogInsertTableRowsField": "Rows",
    "dxHtmlEditor-dialogInsertTableColumnsField": "Columns",
    "dxHtmlEditor-dialogInsertTableCaption": "Insert Table",
    "dxHtmlEditor-dialogUpdateImageCaption": "Update Image",
    "dxHtmlEditor-dialogImageUpdateButton": "Update",
    "dxHtmlEditor-dialogImageAddButton": "Add",
    "dxHtmlEditor-dialogImageSpecifyUrl": "From the Web",
    "dxHtmlEditor-dialogImageSelectFile": "From This Device",
    "dxHtmlEditor-dialogImageKeepAspectRatio": "Keep Aspect Ratio",
    "dxHtmlEditor-dialogImageEncodeToBase64": "Encode to Base64",
    "dxHtmlEditor-heading": "Heading",
    "dxHtmlEditor-normalText": "Normal text",
    "dxHtmlEditor-background": "Background Color",
    "dxHtmlEditor-bold": "Bold",
    "dxHtmlEditor-color": "Font Color",
    "dxHtmlEditor-font": "Font",
    "dxHtmlEditor-italic": "Italic",
    "dxHtmlEditor-link": "Add Link",
    "dxHtmlEditor-image": "Add Image",
    "dxHtmlEditor-size": "Size",
    "dxHtmlEditor-strike": "Strikethrough",
    "dxHtmlEditor-subscript": "Subscript",
    "dxHtmlEditor-superscript": "Superscript",
    "dxHtmlEditor-underline": "Underline",
    "dxHtmlEditor-blockquote": "Blockquote",
    "dxHtmlEditor-header": "Header",
    "dxHtmlEditor-increaseIndent": "Increase Indent",
    "dxHtmlEditor-decreaseIndent": "Decrease Indent",
    "dxHtmlEditor-orderedList": "Ordered List",
    "dxHtmlEditor-bulletList": "Bullet List",
    "dxHtmlEditor-alignLeft": "Align Left",
    "dxHtmlEditor-alignCenter": "Align Center",
    "dxHtmlEditor-alignRight": "Align Right",
    "dxHtmlEditor-alignJustify": "Align Justify",
    "dxHtmlEditor-codeBlock": "Code Block",
    "dxHtmlEditor-variable": "Add Variable",
    "dxHtmlEditor-undo": "Undo",
    "dxHtmlEditor-redo": "Redo",
    "dxHtmlEditor-clear": "Clear Formatting",
    "dxHtmlEditor-insertTable": "Insert Table",
    "dxHtmlEditor-insertHeaderRow": "Insert Header Row",
    "dxHtmlEditor-insertRowAbove": "Insert Row Above",
    "dxHtmlEditor-insertRowBelow": "Insert Row Below",
    "dxHtmlEditor-insertColumnLeft": "Insert Column Left",
    "dxHtmlEditor-insertColumnRight": "Insert Column Right",
    "dxHtmlEditor-deleteColumn": "Delete Column",
    "dxHtmlEditor-deleteRow": "Delete Row",
    "dxHtmlEditor-deleteTable": "Delete Table",
    "dxHtmlEditor-cellProperties": "Cell Properties",
    "dxHtmlEditor-tableProperties": "Table Properties",
    "dxHtmlEditor-insert": "Insert",
    "dxHtmlEditor-delete": "Delete",
    "dxHtmlEditor-border": "Border",
    "dxHtmlEditor-style": "Style",
    "dxHtmlEditor-width": "Width",
    "dxHtmlEditor-height": "Height",
    "dxHtmlEditor-borderColor": "Color",
    "dxHtmlEditor-borderWidth": "Border Width",
    "dxHtmlEditor-tableBackground": "Background",
    "dxHtmlEditor-dimensions": "Dimensions",
    "dxHtmlEditor-alignment": "Alignment",
    "dxHtmlEditor-horizontal": "Horizontal",
    "dxHtmlEditor-vertical": "Vertical",
    "dxHtmlEditor-paddingVertical": "Vertical Padding",
    "dxHtmlEditor-paddingHorizontal": "Horizontal Padding",
    "dxHtmlEditor-pixels": "Pixels",
    "dxHtmlEditor-list": "List",
    "dxHtmlEditor-ordered": "Ordered",
    "dxHtmlEditor-bullet": "Bullet",
    "dxHtmlEditor-align": "Align",
    "dxHtmlEditor-center": "Center",
    "dxHtmlEditor-left": "Left",
    "dxHtmlEditor-right": "Right",
    "dxHtmlEditor-indent": "Indent",
    "dxHtmlEditor-justify": "Justify",
    "dxHtmlEditor-borderStyleNone": "none",
    "dxHtmlEditor-borderStyleHidden": "hidden",
    "dxHtmlEditor-borderStyleDotted": "dotted",
    "dxHtmlEditor-borderStyleDashed": "dashed",
    "dxHtmlEditor-borderStyleSolid": "solid",
    "dxHtmlEditor-borderStyleDouble": "double",
    "dxHtmlEditor-borderStyleGroove": "groove",
    "dxHtmlEditor-borderStyleRidge": "ridge",
    "dxHtmlEditor-borderStyleInset": "inset",
    "dxHtmlEditor-borderStyleOutset": "outset",
    "dxFileManager-newDirectoryName": "Untitled directory",
    "dxFileManager-rootDirectoryName": "Files",
    "dxFileManager-errorNoAccess": "Access Denied. Operation could not be completed.",
    "dxFileManager-errorDirectoryExistsFormat": "Directory '{0}' already exists.",
    "dxFileManager-errorFileExistsFormat": "File '{0}' already exists.",
    "dxFileManager-errorFileNotFoundFormat": "File '{0}' not found.",
    "dxFileManager-errorDirectoryNotFoundFormat": "Directory '{0}' not found.",
    "dxFileManager-errorWrongFileExtension": "File extension is not allowed.",
    "dxFileManager-errorMaxFileSizeExceeded": "File size exceeds the maximum allowed size.",
    "dxFileManager-errorInvalidSymbols": "This name contains invalid characters.",
    "dxFileManager-errorDefault": "Unspecified error.",
    "dxFileManager-errorDirectoryOpenFailed": "The directory cannot be opened",
    "dxFileManager-commandCreate": "New directory",
    "dxFileManager-commandRename": "Rename",
    "dxFileManager-commandMove": "Move to",
    "dxFileManager-commandCopy": "Copy to",
    "dxFileManager-commandDelete": "Delete",
    "dxFileManager-commandDownload": "Download",
    "dxFileManager-commandUpload": "Upload files",
    "dxFileManager-commandRefresh": "Refresh",
    "dxFileManager-commandThumbnails": "Thumbnails View",
    "dxFileManager-commandDetails": "Details View",
    "dxFileManager-commandClearSelection": "Clear selection",
    "dxFileManager-commandShowNavPane": "Toggle navigation pane",
    "dxFileManager-dialogDirectoryChooserMoveTitle": "Move to",
    "dxFileManager-dialogDirectoryChooserMoveButtonText": "Move",
    "dxFileManager-dialogDirectoryChooserCopyTitle": "Copy to",
    "dxFileManager-dialogDirectoryChooserCopyButtonText": "Copy",
    "dxFileManager-dialogRenameItemTitle": "Rename",
    "dxFileManager-dialogRenameItemButtonText": "Save",
    "dxFileManager-dialogCreateDirectoryTitle": "New directory",
    "dxFileManager-dialogCreateDirectoryButtonText": "Create",
    "dxFileManager-dialogDeleteItemTitle": "Delete",
    "dxFileManager-dialogDeleteItemButtonText": "Delete",
    "dxFileManager-dialogDeleteItemSingleItemConfirmation": "Are you sure you want to delete {0}?",
    "dxFileManager-dialogDeleteItemMultipleItemsConfirmation": "Are you sure you want to delete {0} items?",
    "dxFileManager-dialogButtonCancel": "Cancel",
    "dxFileManager-editingCreateSingleItemProcessingMessage": "Creating a directory inside {0}",
    "dxFileManager-editingCreateSingleItemSuccessMessage": "Created a directory inside {0}",
    "dxFileManager-editingCreateSingleItemErrorMessage": "Directory was not created",
    "dxFileManager-editingCreateCommonErrorMessage": "Directory was not created",
    "dxFileManager-editingRenameSingleItemProcessingMessage": "Renaming an item inside {0}",
    "dxFileManager-editingRenameSingleItemSuccessMessage": "Renamed an item inside {0}",
    "dxFileManager-editingRenameSingleItemErrorMessage": "Item was not renamed",
    "dxFileManager-editingRenameCommonErrorMessage": "Item was not renamed",
    "dxFileManager-editingDeleteSingleItemProcessingMessage": "Deleting an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsProcessingMessage": "Deleting {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemSuccessMessage": "Deleted an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsSuccessMessage": "Deleted {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemErrorMessage": "Item was not deleted",
    "dxFileManager-editingDeleteMultipleItemsErrorMessage": "{0} items were not deleted",
    "dxFileManager-editingDeleteCommonErrorMessage": "Some items were not deleted",
    "dxFileManager-editingMoveSingleItemProcessingMessage": "Moving an item to {0}",
    "dxFileManager-editingMoveMultipleItemsProcessingMessage": "Moving {0} items to {1}",
    "dxFileManager-editingMoveSingleItemSuccessMessage": "Moved an item to {0}",
    "dxFileManager-editingMoveMultipleItemsSuccessMessage": "Moved {0} items to {1}",
    "dxFileManager-editingMoveSingleItemErrorMessage": "Item was not moved",
    "dxFileManager-editingMoveMultipleItemsErrorMessage": "{0} items were not moved",
    "dxFileManager-editingMoveCommonErrorMessage": "Some items were not moved",
    "dxFileManager-editingCopySingleItemProcessingMessage": "Copying an item to {0}",
    "dxFileManager-editingCopyMultipleItemsProcessingMessage": "Copying {0} items to {1}",
    "dxFileManager-editingCopySingleItemSuccessMessage": "Copied an item to {0}",
    "dxFileManager-editingCopyMultipleItemsSuccessMessage": "Copied {0} items to {1}",
    "dxFileManager-editingCopySingleItemErrorMessage": "Item was not copied",
    "dxFileManager-editingCopyMultipleItemsErrorMessage": "{0} items were not copied",
    "dxFileManager-editingCopyCommonErrorMessage": "Some items were not copied",
    "dxFileManager-editingUploadSingleItemProcessingMessage": "Uploading an item to {0}",
    "dxFileManager-editingUploadMultipleItemsProcessingMessage": "Uploading {0} items to {1}",
    "dxFileManager-editingUploadSingleItemSuccessMessage": "Uploaded an item to {0}",
    "dxFileManager-editingUploadMultipleItemsSuccessMessage": "Uploaded {0} items to {1}",
    "dxFileManager-editingUploadSingleItemErrorMessage": "Item was not uploaded",
    "dxFileManager-editingUploadMultipleItemsErrorMessage": "{0} items were not uploaded",
    "dxFileManager-editingUploadCanceledMessage": "Canceled",
    "dxFileManager-editingDownloadSingleItemErrorMessage": "Item was not downloaded",
    "dxFileManager-editingDownloadMultipleItemsErrorMessage": "{0} items were not downloaded",
    "dxFileManager-listDetailsColumnCaptionName": "Name",
    "dxFileManager-listDetailsColumnCaptionDateModified": "Date Modified",
    "dxFileManager-listDetailsColumnCaptionFileSize": "File Size",
    "dxFileManager-listThumbnailsTooltipTextSize": "Size",
    "dxFileManager-listThumbnailsTooltipTextDateModified": "Date Modified",
    "dxFileManager-notificationProgressPanelTitle": "Progress",
    "dxFileManager-notificationProgressPanelEmptyListText": "No operations",
    "dxFileManager-notificationProgressPanelOperationCanceled": "Canceled",
    "dxDiagram-categoryGeneral": "General",
    "dxDiagram-categoryFlowchart": "Flowchart",
    "dxDiagram-categoryOrgChart": "Org Chart",
    "dxDiagram-categoryContainers": "Containers",
    "dxDiagram-categoryCustom": "Custom",
    "dxDiagram-commandExportToSvg": "Export to SVG",
    "dxDiagram-commandExportToPng": "Export to PNG",
    "dxDiagram-commandExportToJpg": "Export to JPEG",
    "dxDiagram-commandUndo": "Undo",
    "dxDiagram-commandRedo": "Redo",
    "dxDiagram-commandFontName": "Font Name",
    "dxDiagram-commandFontSize": "Font Size",
    "dxDiagram-commandBold": "Bold",
    "dxDiagram-commandItalic": "Italic",
    "dxDiagram-commandUnderline": "Underline",
    "dxDiagram-commandTextColor": "Font Color",
    "dxDiagram-commandLineColor": "Line Color",
    "dxDiagram-commandLineWidth": "Line Width",
    "dxDiagram-commandLineStyle": "Line Style",
    "dxDiagram-commandLineStyleSolid": "Solid",
    "dxDiagram-commandLineStyleDotted": "Dotted",
    "dxDiagram-commandLineStyleDashed": "Dashed",
    "dxDiagram-commandFillColor": "Fill Color",
    "dxDiagram-commandAlignLeft": "Align Left",
    "dxDiagram-commandAlignCenter": "Align Center",
    "dxDiagram-commandAlignRight": "Align Right",
    "dxDiagram-commandConnectorLineType": "Connector Line Type",
    "dxDiagram-commandConnectorLineStraight": "Straight",
    "dxDiagram-commandConnectorLineOrthogonal": "Orthogonal",
    "dxDiagram-commandConnectorLineStart": "Connector Line Start",
    "dxDiagram-commandConnectorLineEnd": "Connector Line End",
    "dxDiagram-commandConnectorLineNone": "None",
    "dxDiagram-commandConnectorLineArrow": "Arrow",
    "dxDiagram-commandFullscreen": "Full Screen",
    "dxDiagram-commandUnits": "Units",
    "dxDiagram-commandPageSize": "Page Size",
    "dxDiagram-commandPageOrientation": "Page Orientation",
    "dxDiagram-commandPageOrientationLandscape": "Landscape",
    "dxDiagram-commandPageOrientationPortrait": "Portrait",
    "dxDiagram-commandPageColor": "Page Color",
    "dxDiagram-commandShowGrid": "Show Grid",
    "dxDiagram-commandSnapToGrid": "Snap to Grid",
    "dxDiagram-commandGridSize": "Grid Size",
    "dxDiagram-commandZoomLevel": "Zoom Level",
    "dxDiagram-commandAutoZoom": "Auto Zoom",
    "dxDiagram-commandFitToContent": "Fit to Content",
    "dxDiagram-commandFitToWidth": "Fit to Width",
    "dxDiagram-commandAutoZoomByContent": "Auto Zoom by Content",
    "dxDiagram-commandAutoZoomByWidth": "Auto Zoom by Width",
    "dxDiagram-commandSimpleView": "Simple View",
    "dxDiagram-commandCut": "Cut",
    "dxDiagram-commandCopy": "Copy",
    "dxDiagram-commandPaste": "Paste",
    "dxDiagram-commandSelectAll": "Select All",
    "dxDiagram-commandDelete": "Delete",
    "dxDiagram-commandBringToFront": "Bring to Front",
    "dxDiagram-commandSendToBack": "Send to Back",
    "dxDiagram-commandLock": "Lock",
    "dxDiagram-commandUnlock": "Unlock",
    "dxDiagram-commandInsertShapeImage": "Insert Image...",
    "dxDiagram-commandEditShapeImage": "Change Image...",
    "dxDiagram-commandDeleteShapeImage": "Delete Image",
    "dxDiagram-commandLayoutLeftToRight": "Left-to-right",
    "dxDiagram-commandLayoutRightToLeft": "Right-to-left",
    "dxDiagram-commandLayoutTopToBottom": "Top-to-bottom",
    "dxDiagram-commandLayoutBottomToTop": "Bottom-to-top",
    "dxDiagram-unitIn": "in",
    "dxDiagram-unitCm": "cm",
    "dxDiagram-unitPx": "px",
    "dxDiagram-dialogButtonOK": "OK",
    "dxDiagram-dialogButtonCancel": "Cancel",
    "dxDiagram-dialogInsertShapeImageTitle": "Insert Image",
    "dxDiagram-dialogEditShapeImageTitle": "Change Image",
    "dxDiagram-dialogEditShapeImageSelectButton": "Select image",
    "dxDiagram-dialogEditShapeImageLabelText": "or drop a file here",
    "dxDiagram-uiExport": "Export",
    "dxDiagram-uiProperties": "Properties",
    "dxDiagram-uiSettings": "Settings",
    "dxDiagram-uiShowToolbox": "Show Toolbox",
    "dxDiagram-uiSearch": "Search",
    "dxDiagram-uiStyle": "Style",
    "dxDiagram-uiLayout": "Layout",
    "dxDiagram-uiLayoutTree": "Tree",
    "dxDiagram-uiLayoutLayered": "Layered",
    "dxDiagram-uiDiagram": "Diagram",
    "dxDiagram-uiText": "Text",
    "dxDiagram-uiObject": "Object",
    "dxDiagram-uiConnector": "Connector",
    "dxDiagram-uiPage": "Page",
    "dxDiagram-shapeText": "Text",
    "dxDiagram-shapeRectangle": "Rectangle",
    "dxDiagram-shapeEllipse": "Ellipse",
    "dxDiagram-shapeCross": "Cross",
    "dxDiagram-shapeTriangle": "Triangle",
    "dxDiagram-shapeDiamond": "Diamond",
    "dxDiagram-shapeHeart": "Heart",
    "dxDiagram-shapePentagon": "Pentagon",
    "dxDiagram-shapeHexagon": "Hexagon",
    "dxDiagram-shapeOctagon": "Octagon",
    "dxDiagram-shapeStar": "Star",
    "dxDiagram-shapeArrowLeft": "Left Arrow",
    "dxDiagram-shapeArrowUp": "Up Arrow",
    "dxDiagram-shapeArrowRight": "Right Arrow",
    "dxDiagram-shapeArrowDown": "Down Arrow",
    "dxDiagram-shapeArrowUpDown": "Up Down Arrow",
    "dxDiagram-shapeArrowLeftRight": "Left Right Arrow",
    "dxDiagram-shapeProcess": "Process",
    "dxDiagram-shapeDecision": "Decision",
    "dxDiagram-shapeTerminator": "Terminator",
    "dxDiagram-shapePredefinedProcess": "Predefined Process",
    "dxDiagram-shapeDocument": "Document",
    "dxDiagram-shapeMultipleDocuments": "Multiple Documents",
    "dxDiagram-shapeManualInput": "Manual Input",
    "dxDiagram-shapePreparation": "Preparation",
    "dxDiagram-shapeData": "Data",
    "dxDiagram-shapeDatabase": "Database",
    "dxDiagram-shapeHardDisk": "Hard Disk",
    "dxDiagram-shapeInternalStorage": "Internal Storage",
    "dxDiagram-shapePaperTape": "Paper Tape",
    "dxDiagram-shapeManualOperation": "Manual Operation",
    "dxDiagram-shapeDelay": "Delay",
    "dxDiagram-shapeStoredData": "Stored Data",
    "dxDiagram-shapeDisplay": "Display",
    "dxDiagram-shapeMerge": "Merge",
    "dxDiagram-shapeConnector": "Connector",
    "dxDiagram-shapeOr": "Or",
    "dxDiagram-shapeSummingJunction": "Summing Junction",
    "dxDiagram-shapeContainerDefaultText": "Container",
    "dxDiagram-shapeVerticalContainer": "Vertical Container",
    "dxDiagram-shapeHorizontalContainer": "Horizontal Container",
    "dxDiagram-shapeCardDefaultText": "Person's Name",
    "dxDiagram-shapeCardWithImageOnLeft": "Card with Image on the Left",
    "dxDiagram-shapeCardWithImageOnTop": "Card with Image on the Top",
    "dxDiagram-shapeCardWithImageOnRight": "Card with Image on the Right",
    "dxGantt-dialogTitle": "Title",
    "dxGantt-dialogStartTitle": "Start",
    "dxGantt-dialogEndTitle": "End",
    "dxGantt-dialogProgressTitle": "Progress",
    "dxGantt-dialogResourcesTitle": "Resources",
    "dxGantt-dialogResourceManagerTitle": "Resource Manager",
    "dxGantt-dialogTaskDetailsTitle": "Task Details",
    "dxGantt-dialogEditResourceListHint": "Edit Resource List",
    "dxGantt-dialogEditNoResources": "No resources",
    "dxGantt-dialogButtonAdd": "Add",
    "dxGantt-contextMenuNewTask": "New Task",
    "dxGantt-contextMenuNewSubtask": "New Subtask",
    "dxGantt-contextMenuDeleteTask": "Delete Task",
    "dxGantt-contextMenuDeleteDependency": "Delete Dependency",
    "dxGantt-dialogTaskDeleteConfirmation": "Deleting a task also deletes all its dependencies and subtasks. Are you sure you want to delete this task?",
    "dxGantt-dialogDependencyDeleteConfirmation": "Are you sure you want to delete the dependency from the task?",
    "dxGantt-dialogResourcesDeleteConfirmation": "Deleting a resource also deletes it from tasks to which this resource is assigned. Are you sure you want to delete these resources? Resources: {0}",
    "dxGantt-dialogConstraintCriticalViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. How would you like to proceed?",
    "dxGantt-dialogCancelOperationMessage": "Cancel the operation",
    "dxGantt-dialogDeleteDependencyMessage": "Delete the dependency",
    "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "Move the task and keep the dependency",
    "dxGantt-dialogConstraintCriticalViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. How would you like to proceed?",
    "dxGantt-dialogDeleteDependenciesMessage": "Delete the dependency relations",
    "dxGantt-dialogMoveTaskAndKeepDependenciesMessage": "Move the task and keep the dependencies",
    "dxGantt-undo": "Undo",
    "dxGantt-redo": "Redo",
    "dxGantt-expandAll": "Expand All",
    "dxGantt-collapseAll": "Collapse All",
    "dxGantt-addNewTask": "Add New Task",
    "dxGantt-deleteSelectedTask": "Delete Selected Task",
    "dxGantt-zoomIn": "Zoom In",
    "dxGantt-zoomOut": "Zoom Out",
    "dxGantt-fullScreen": "Full Screen",
    "dxGantt-quarter": "Q{0}",
    "dxGantt-sortingAscendingText": "Sort Ascending",
    "dxGantt-sortingDescendingText": "Sort Descending",
    "dxGantt-sortingClearText": "Clear Sorting",
    "dxGantt-showResources": "Show Resources",
    "dxGantt-showDependencies": "Show Dependencies",
    "dxGantt-dialogStartDateValidation": "Start date must be after {0}",
    "dxGantt-dialogEndDateValidation": "End date must be after {0}",
    "dxGallery-itemName": "Gallery item",
    "dxMultiView-elementAriaRoleDescription": "MultiView",
    "dxMultiView-elementAriaLabel": "Use the arrow keys or swipe to navigate between views",
    "dxMultiView-itemAriaRoleDescription": "View",
    "dxMultiView-itemAriaLabel": "{0} of {1}",
    "dxSplitter-resizeHandleAriaLabel": "Split bar"
  }
};

// ../../../../../../node_modules/devextreme/esm/localization/message.js
var baseDictionary = extend(true, {}, defaultMessages);
var getDataByLocale = (localeData, locale) => {
  var _Object$entries$find;
  return localeData[locale] || (null === locale || void 0 === locale ? void 0 : locale.toLowerCase) && (null === (_Object$entries$find = Object.entries(localeData).find((_ref) => {
    let [key] = _ref;
    return key.toLowerCase() === locale.toLowerCase();
  })) || void 0 === _Object$entries$find ? void 0 : _Object$entries$find[1]) || {};
};
var newMessages = {};
var messageLocalization = dependency_injector_default({
  engine: function() {
    return "base";
  },
  _dictionary: baseDictionary,
  load: function(messages) {
    extend(true, this._dictionary, messages);
  },
  _localizablePrefix: "@",
  setup: function(localizablePrefix) {
    this._localizablePrefix = localizablePrefix;
  },
  localizeString: function(text) {
    const that = this;
    const regex = new RegExp("(^|[^a-zA-Z_0-9" + that._localizablePrefix + "-]+)(" + that._localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g");
    const escapeString = that._localizablePrefix + that._localizablePrefix;
    return text.replace(regex, (str, prefix, escape, localizationKey) => {
      const defaultResult = that._localizablePrefix + localizationKey;
      let result2;
      if (escape !== escapeString) {
        result2 = that.format(localizationKey);
      }
      if (!result2) {
        newMessages[localizationKey] = humanize(localizationKey);
      }
      return prefix + (result2 || defaultResult);
    });
  },
  getMessagesByLocales: function() {
    return this._dictionary;
  },
  getDictionary: function(onlyNew) {
    if (onlyNew) {
      return newMessages;
    }
    return extend({}, newMessages, this.getMessagesByLocales()[core_default.locale()]);
  },
  getFormatter: function(key) {
    return this._getFormatterBase(key) || this._getFormatterBase(key, "en");
  },
  _getFormatterBase: function(key, locale) {
    const message = core_default.getValueByClosestLocale((locale2) => getDataByLocale(this._dictionary, locale2)[key]);
    if (message) {
      return function() {
        const args = 1 === arguments.length && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
        args.unshift(message);
        return format.apply(this, args);
      };
    }
  },
  format: function(key) {
    const formatter = this.getFormatter(key);
    const values = Array.prototype.slice.call(arguments, 1);
    return formatter && formatter.apply(this, values) || "";
  }
});
var message_default = messageLocalization;

// ../../../../../../node_modules/devextreme/esm/core/utils/ready_callbacks.js
var callbacks = [];
var subscribeReady = call_once_default(() => {
  const removeListener = dom_adapter_default.listen(dom_adapter_default.getDocument(), "DOMContentLoaded", () => {
    readyCallbacks.fire();
    removeListener();
  });
});
var readyCallbacks = {
  add: (callback) => {
    const windowExists = hasWindow();
    if (windowExists && "loading" !== dom_adapter_default.getReadyState()) {
      callback();
    } else {
      callbacks.push(callback);
      windowExists && subscribeReady();
    }
  },
  fire: () => {
    callbacks.forEach((callback) => callback());
    callbacks = [];
  }
};
var ready_callbacks_default = dependency_injector_default(readyCallbacks);

// ../../../../../../node_modules/devextreme/esm/core/utils/resize_callbacks.js
var resizeCallbacks = function() {
  let prevSize;
  const callbacks2 = callbacks_default();
  const originalCallbacksAdd = callbacks2.add;
  const originalCallbacksRemove = callbacks2.remove;
  if (!hasWindow()) {
    return callbacks2;
  }
  const formatSize = function() {
    const window26 = getWindow();
    return {
      width: window26.innerWidth,
      height: window26.innerHeight
    };
  };
  const handleResize = function() {
    const now = formatSize();
    if (now.width === prevSize.width && now.height === prevSize.height) {
      return;
    }
    let changedDimension;
    if (now.width === prevSize.width) {
      changedDimension = "height";
    }
    if (now.height === prevSize.height) {
      changedDimension = "width";
    }
    prevSize = now;
    callbacks2.fire(changedDimension);
  };
  const setPrevSize = call_once_default(function() {
    prevSize = formatSize();
  });
  let removeListener;
  callbacks2.add = function() {
    const result2 = originalCallbacksAdd.apply(callbacks2, arguments);
    setPrevSize();
    ready_callbacks_default.add(function() {
      if (!removeListener && callbacks2.has()) {
        removeListener = dom_adapter_default.listen(getWindow(), "resize", handleResize);
      }
    });
    return result2;
  };
  callbacks2.remove = function() {
    const result2 = originalCallbacksRemove.apply(callbacks2, arguments);
    if (!callbacks2.has() && removeListener) {
      removeListener();
      removeListener = void 0;
    }
    return result2;
  };
  return callbacks2;
}();
var resize_callbacks_default = resizeCallbacks;

// ../../../../../../node_modules/devextreme/esm/core/events_strategy.js
var EventsStrategy = class _EventsStrategy {
  constructor(owner) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    this._events = {};
    this._owner = owner;
    this._options = options2;
  }
  static create(owner, strategy4) {
    if (strategy4) {
      return isFunction(strategy4) ? strategy4(owner) : strategy4;
    } else {
      return new _EventsStrategy(owner);
    }
  }
  hasEvent(eventName) {
    const callbacks2 = this._events[eventName];
    return callbacks2 ? callbacks2.has() : false;
  }
  fireEvent(eventName, eventArgs) {
    const callbacks2 = this._events[eventName];
    if (callbacks2) {
      callbacks2.fireWith(this._owner, eventArgs);
    }
    return this._owner;
  }
  on(eventName, eventHandler) {
    if (isPlainObject(eventName)) {
      each(eventName, (e, h2) => {
        this.on(e, h2);
      });
    } else {
      let callbacks2 = this._events[eventName];
      if (!callbacks2) {
        callbacks2 = callbacks_default({
          syncStrategy: this._options.syncStrategy
        });
        this._events[eventName] = callbacks2;
      }
      const addFn = callbacks2.originalAdd || callbacks2.add;
      addFn.call(callbacks2, eventHandler);
    }
  }
  off(eventName, eventHandler) {
    const callbacks2 = this._events[eventName];
    if (callbacks2) {
      if (isFunction(eventHandler)) {
        callbacks2.remove(eventHandler);
      } else {
        callbacks2.empty();
      }
    }
  }
  dispose() {
    each(this._events, (eventName, event) => {
      event.empty();
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/core/utils/storage.js
var window5 = getWindow();
var getSessionStorage = function() {
  let sessionStorage;
  try {
    sessionStorage = window5.sessionStorage;
  } catch (e) {
  }
  return sessionStorage;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/view_port.js
var ready = ready_callbacks_default.add;
var changeCallback = callbacks_default();
var $originalViewPort = renderer_default();
var value = function() {
  let $current;
  return function(element) {
    if (!arguments.length) {
      return $current;
    }
    const $element = renderer_default(element);
    $originalViewPort = $element;
    const isNewViewportFound = !!$element.length;
    const prevViewPort = value();
    $current = isNewViewportFound ? $element : renderer_default("body");
    changeCallback.fire(isNewViewportFound ? value() : renderer_default(), prevViewPort);
  };
}();
ready(function() {
  value(".dx-viewport");
});
function originalViewPort() {
  return $originalViewPort;
}

// ../../../../../../node_modules/devextreme/esm/core/devices.js
var window6 = getWindow();
var KNOWN_UA_TABLE = {
  iPhone: "iPhone",
  iPhone5: "iPhone",
  iPhone6: "iPhone",
  iPhone6plus: "iPhone",
  iPad: "iPad",
  iPadMini: "iPad Mini",
  androidPhone: "Android Mobile",
  androidTablet: "Android",
  msSurface: "Windows ARM Tablet PC",
  desktop: "desktop"
};
var DEFAULT_DEVICE = {
  deviceType: "desktop",
  platform: "generic",
  version: [],
  phone: false,
  tablet: false,
  android: false,
  ios: false,
  generic: true,
  grade: "A",
  mac: false
};
var UA_PARSERS = {
  generic(userAgent) {
    const isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/);
    const isTablet = !isPhone && /Windows(.*)arm(.*)Tablet PC/i.test(userAgent);
    const isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
    const isMac = /((intel|ppc) mac os x)/.test(userAgent.toLowerCase());
    if (!(isPhone || isTablet || isDesktop || isMac)) {
      return null;
    }
    return {
      deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
      platform: "generic",
      version: [],
      grade: "A",
      mac: isMac
    };
  },
  appleTouchDevice(userAgent) {
    const navigator3 = getNavigator();
    const isIpadOs = /Macintosh/i.test(userAgent) && (null === navigator3 || void 0 === navigator3 ? void 0 : navigator3.maxTouchPoints) > 2;
    const isAppleDevice = /ip(hone|od|ad)/i.test(userAgent);
    if (!isAppleDevice && !isIpadOs) {
      return null;
    }
    const isPhone = /ip(hone|od)/i.test(userAgent);
    const matches = userAgent.match(/os\s{0,}X? (\d+)_(\d+)_?(\d+)?/i);
    const version3 = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
    const isIPhone4 = 480 === window6.screen.height;
    const grade = isIPhone4 ? "B" : "A";
    return {
      deviceType: isPhone ? "phone" : "tablet",
      platform: "ios",
      version: version3,
      grade
    };
  },
  android(userAgent) {
    const isAndroid = /android|htc_|silk/i.test(userAgent);
    const isWinPhone = /windows phone/i.test(userAgent);
    if (!isAndroid || isWinPhone) {
      return null;
    }
    const isPhone = /mobile/i.test(userAgent);
    const matches = userAgent.match(/android (\d+)\.?(\d+)?\.?(\d+)?/i);
    const version3 = matches ? [parseInt(matches[1], 10), parseInt(matches[2] || 0, 10), parseInt(matches[3] || 0, 10)] : [];
    const worseThan4_4 = version3.length > 1 && (version3[0] < 4 || 4 === version3[0] && version3[1] < 4);
    const grade = worseThan4_4 ? "B" : "A";
    return {
      deviceType: isPhone ? "phone" : "tablet",
      platform: "android",
      version: version3,
      grade
    };
  }
};
var UA_PARSERS_ARRAY = [UA_PARSERS.appleTouchDevice, UA_PARSERS.android, UA_PARSERS.generic];
var Devices = class {
  constructor(options2) {
    this._window = (null === options2 || void 0 === options2 ? void 0 : options2.window) || window6;
    this._realDevice = this._getDevice();
    this._currentDevice = void 0;
    this._currentOrientation = void 0;
    this._eventsStrategy = new EventsStrategy(this);
    this.changed = callbacks_default();
    if (hasWindow()) {
      ready_callbacks_default.add(this._recalculateOrientation.bind(this));
      resize_callbacks_default.add(this._recalculateOrientation.bind(this));
    }
  }
  current(deviceOrName) {
    if (deviceOrName) {
      this._currentDevice = this._getDevice(deviceOrName);
      this._forced = true;
      this.changed.fire();
      return;
    }
    if (!this._currentDevice) {
      deviceOrName = void 0;
      try {
        deviceOrName = this._getDeviceOrNameFromWindowScope();
      } catch (e) {
        deviceOrName = this._getDeviceNameFromSessionStorage();
      } finally {
        if (!deviceOrName) {
          deviceOrName = this._getDeviceNameFromSessionStorage();
        }
        if (deviceOrName) {
          this._forced = true;
        }
      }
      this._currentDevice = this._getDevice(deviceOrName);
    }
    return this._currentDevice;
  }
  real(forceDevice) {
    return extend({}, this._realDevice);
  }
  orientation() {
    return this._currentOrientation;
  }
  isForced() {
    return this._forced;
  }
  isRippleEmulator() {
    return !!this._window.tinyHippos;
  }
  _getCssClasses(device) {
    const result2 = [];
    const realDevice2 = this._realDevice;
    device = device || this.current();
    if (device.deviceType) {
      result2.push(`dx-device-${device.deviceType}`);
      if ("desktop" !== device.deviceType) {
        result2.push("dx-device-mobile");
      }
    }
    result2.push(`dx-device-${realDevice2.platform}`);
    if (realDevice2.version && realDevice2.version.length) {
      result2.push(`dx-device-${realDevice2.platform}-${realDevice2.version[0]}`);
    }
    if (this.isSimulator()) {
      result2.push("dx-simulator");
    }
    if (config_default().rtlEnabled) {
      result2.push("dx-rtl");
    }
    return result2;
  }
  attachCssClasses(element, device) {
    this._deviceClasses = this._getCssClasses(device).join(" ");
    renderer_default(element).addClass(this._deviceClasses);
  }
  detachCssClasses(element) {
    renderer_default(element).removeClass(this._deviceClasses);
  }
  isSimulator() {
    try {
      return this._isSimulator || hasWindow() && this._window.top !== this._window.self && this._window.top["dx-force-device"] || this.isRippleEmulator();
    } catch (e) {
      return false;
    }
  }
  forceSimulator() {
    this._isSimulator = true;
  }
  _getDevice(deviceName) {
    if ("genericPhone" === deviceName) {
      deviceName = {
        deviceType: "phone",
        platform: "generic",
        generic: true
      };
    }
    if (isPlainObject(deviceName)) {
      return this._fromConfig(deviceName);
    } else {
      let ua;
      if (deviceName) {
        ua = KNOWN_UA_TABLE[deviceName];
        if (!ua) {
          throw errors_default.Error("E0005");
        }
      } else {
        const navigator3 = getNavigator();
        ua = navigator3.userAgent;
      }
      return this._fromUA(ua);
    }
  }
  _getDeviceOrNameFromWindowScope() {
    let result2;
    if (hasWindow() && (this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"])) {
      result2 = this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"];
    }
    return result2;
  }
  _getDeviceNameFromSessionStorage() {
    const sessionStorage = getSessionStorage();
    if (!sessionStorage) {
      return;
    }
    const deviceOrName = sessionStorage.getItem("dx-force-device");
    try {
      return JSON.parse(deviceOrName);
    } catch (ex) {
      return deviceOrName;
    }
  }
  _fromConfig(config3) {
    const result2 = extend({}, DEFAULT_DEVICE, this._currentDevice, config3);
    const shortcuts = {
      phone: "phone" === result2.deviceType,
      tablet: "tablet" === result2.deviceType,
      android: "android" === result2.platform,
      ios: "ios" === result2.platform,
      generic: "generic" === result2.platform
    };
    return extend(result2, shortcuts);
  }
  _fromUA(ua) {
    for (let idx = 0; idx < UA_PARSERS_ARRAY.length; idx += 1) {
      const parser = UA_PARSERS_ARRAY[idx];
      const config3 = parser(ua);
      if (config3) {
        return this._fromConfig(config3);
      }
    }
    return DEFAULT_DEVICE;
  }
  _changeOrientation() {
    const $window = renderer_default(this._window);
    const orientation = getHeight($window) > getWidth($window) ? "portrait" : "landscape";
    if (this._currentOrientation === orientation) {
      return;
    }
    this._currentOrientation = orientation;
    this._eventsStrategy.fireEvent("orientationChanged", [{
      orientation
    }]);
  }
  _recalculateOrientation() {
    const windowWidth = getWidth(this._window);
    if (this._currentWidth === windowWidth) {
      return;
    }
    this._currentWidth = windowWidth;
    this._changeOrientation();
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
};
var devices = new Devices();
var viewPortElement = value();
if (viewPortElement) {
  devices.attachCssClasses(viewPortElement);
}
changeCallback.add((viewPort2, prevViewport) => {
  devices.detachCssClasses(prevViewport);
  devices.attachCssClasses(viewPort2);
});
var devices_default = devices;

// ../../../../../../node_modules/devextreme/esm/core/resize_observer.js
var window7 = getWindow();
var ResizeObserverMock = {
  observe: noop2,
  unobserve: noop2,
  disconnect: noop2
};
var ResizeObserverSingleton = class {
  constructor() {
    if (!hasWindow() || !window7.ResizeObserver) {
      return ResizeObserverMock;
    }
    this._callbacksMap = /* @__PURE__ */ new Map();
    this._observer = new window7.ResizeObserver((entries) => {
      entries.forEach((entry) => {
        var _this$_callbacksMap$g;
        null === (_this$_callbacksMap$g = this._callbacksMap.get(entry.target)) || void 0 === _this$_callbacksMap$g || _this$_callbacksMap$g(entry);
      });
    });
  }
  observe(element, callback) {
    this._callbacksMap.set(element, callback);
    this._observer.observe(element);
  }
  unobserve(element) {
    this._callbacksMap.delete(element);
    this._observer.unobserve(element);
  }
  disconnect() {
    this._callbacksMap.clear();
    this._observer.disconnect();
  }
};
var resizeObserverSingleton = new ResizeObserverSingleton();
var resize_observer_default = resizeObserverSingleton;

// ../../../../../../node_modules/devextreme/esm/core/utils/support.js
var support_exports = {};
__export(support_exports, {
  animation: () => animation,
  inputType: () => inputType,
  nativeScrolling: () => nativeScrolling,
  pointerEvents: () => pointerEvents,
  styleProp: () => styleProp,
  stylePropPrefix: () => stylePropPrefix,
  supportProp: () => supportProp,
  touch: () => touch,
  touchEvents: () => touchEvents,
  transition: () => transition,
  transitionEndEventName: () => transitionEndEventName
});
var {
  maxTouchPoints
} = getNavigator();
var transitionEndEventNames = {
  webkitTransition: "webkitTransitionEnd",
  MozTransition: "transitionend",
  OTransition: "oTransitionEnd",
  transition: "transitionend"
};
var supportProp = function(prop) {
  return !!styleProp(prop);
};
var isNativeScrollingSupported = function() {
  const {
    platform,
    mac: isMac
  } = devices_default.real();
  const isNativeScrollDevice = "ios" === platform || "android" === platform || isMac;
  return isNativeScrollDevice;
};
var inputType = function(type2) {
  if ("text" === type2) {
    return true;
  }
  const input = dom_adapter_default.createElement("input");
  try {
    input.setAttribute("type", type2);
    input.value = "wrongValue";
    return !input.value;
  } catch (e) {
    return false;
  }
};
var detectTouchEvents = function(hasWindowProperty, maxTouchPoints2) {
  return (hasWindowProperty("ontouchstart") || !!maxTouchPoints2) && !hasWindowProperty("callPhantom");
};
var detectPointerEvent = function(hasWindowProperty) {
  return hasWindowProperty("PointerEvent");
};
var touchEvents = detectTouchEvents(hasProperty, maxTouchPoints);
var pointerEvents = detectPointerEvent(hasProperty);
var touchPointersPresent = !!maxTouchPoints;
var touch = touchEvents || pointerEvents && touchPointersPresent;
var transition = call_once_default(function() {
  return supportProp("transition");
});
var transitionEndEventName = call_once_default(function() {
  return transitionEndEventNames[styleProp("transition")];
});
var animation = call_once_default(function() {
  return supportProp("animation");
});
var nativeScrolling = isNativeScrollingSupported();

// ../../../../../../node_modules/devextreme/esm/core/utils/browser.js
var navigator = getNavigator();
var webkitRegExp = /(webkit)[ /]([\w.]+)/;
var mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
var browserFromUA = (ua) => {
  ua = ua.toLowerCase();
  const result2 = {};
  const matches = webkitRegExp.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || [];
  let browserName = matches[1];
  let browserVersion = matches[2];
  if ("webkit" === browserName) {
    result2.webkit = true;
    if (ua.indexOf("chrome") >= 0 || ua.indexOf("crios") >= 0) {
      browserName = "chrome";
      browserVersion = /(?:chrome|crios)\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf("fxios") >= 0) {
      browserName = "mozilla";
      browserVersion = /fxios\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf("safari") >= 0 && /version|phantomjs/.test(ua)) {
      browserName = "safari";
      browserVersion = /(?:version|phantomjs)\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else {
      browserName = "unknown";
      browserVersion = /applewebkit\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    }
  }
  if (browserName) {
    result2[browserName] = true;
    result2.version = browserVersion;
  }
  return result2;
};
var browser_default = extend({
  _fromUA: browserFromUA
}, browserFromUA(navigator.userAgent));

// ../../../../../../node_modules/devextreme/esm/events/pointer/base.js
var BaseStrategy = class_default.inherit({
  ctor: function(eventName, originalEvents) {
    this._eventName = eventName;
    this._originalEvents = addNamespace2(originalEvents, "dxPointerEvents");
    this._handlerCount = 0;
    this.noBubble = this._isNoBubble();
  },
  _isNoBubble: function() {
    const eventName = this._eventName;
    return "dxpointerenter" === eventName || "dxpointerleave" === eventName;
  },
  _handler: function(e) {
    const delegateTarget = this._getDelegateTarget(e);
    const event = {
      type: this._eventName,
      pointerType: e.pointerType || eventSource(e),
      originalEvent: e,
      delegateTarget,
      timeStamp: browser_default.mozilla ? (/* @__PURE__ */ new Date()).getTime() : e.timeStamp
    };
    const target = getEventTarget(e);
    event.target = target;
    return this._fireEvent(event);
  },
  _getDelegateTarget: function(e) {
    let delegateTarget;
    if (this.noBubble) {
      delegateTarget = e.delegateTarget;
    }
    return delegateTarget;
  },
  _fireEvent: function(args) {
    return fireEvent(args);
  },
  _setSelector: function(handleObj) {
    this._selector = this.noBubble && handleObj ? handleObj.selector : null;
  },
  _getSelector: function() {
    return this._selector;
  },
  setup: function() {
    return true;
  },
  add: function(element, handleObj) {
    if (this._handlerCount <= 0 || this.noBubble) {
      element = this.noBubble ? element : dom_adapter_default.getDocument();
      this._setSelector(handleObj);
      const that = this;
      events_engine_default.on(element, this._originalEvents, this._getSelector(), function(e) {
        that._handler(e);
      });
    }
    if (!this.noBubble) {
      this._handlerCount++;
    }
  },
  remove: function(handleObj) {
    this._setSelector(handleObj);
    if (!this.noBubble) {
      this._handlerCount--;
    }
  },
  teardown: function(element) {
    if (this._handlerCount && !this.noBubble) {
      return;
    }
    element = this.noBubble ? element : dom_adapter_default.getDocument();
    if (".dxPointerEvents" !== this._originalEvents) {
      events_engine_default.off(element, this._originalEvents, this._getSelector());
    }
  },
  dispose: function(element) {
    element = this.noBubble ? element : dom_adapter_default.getDocument();
    events_engine_default.off(element, this._originalEvents);
  }
});
var base_default = BaseStrategy;

// ../../../../../../node_modules/devextreme/esm/events/pointer/touch.js
var eventMap = {
  dxpointerdown: "touchstart",
  dxpointermove: "touchmove",
  dxpointerup: "touchend",
  dxpointercancel: "touchcancel",
  dxpointerover: "",
  dxpointerout: "",
  dxpointerenter: "",
  dxpointerleave: ""
};
var normalizeTouchEvent = function(e) {
  const pointers = [];
  each(e.touches, function(_, touch2) {
    pointers.push(extend({
      pointerId: touch2.identifier
    }, touch2));
  });
  return {
    pointers,
    pointerId: e.changedTouches[0].identifier
  };
};
var skipTouchWithSameIdentifier = function(pointerEvent) {
  return "ios" === devices_default.real().platform && ("dxpointerdown" === pointerEvent || "dxpointerup" === pointerEvent);
};
var TouchStrategy = base_default.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    this._pointerId = 0;
  },
  _handler: function(e) {
    if (skipTouchWithSameIdentifier(this._eventName)) {
      const touch2 = e.changedTouches[0];
      if (this._pointerId === touch2.identifier && 0 !== this._pointerId) {
        return;
      }
      this._pointerId = touch2.identifier;
    }
    return this.callBase.apply(this, arguments);
  },
  _fireEvent: function(args) {
    return this.callBase(extend(normalizeTouchEvent(args.originalEvent), args));
  }
});
TouchStrategy.map = eventMap;
TouchStrategy.normalize = normalizeTouchEvent;
var touch_default = TouchStrategy;

// ../../../../../../node_modules/devextreme/esm/events/pointer/observer.js
var addEventsListener = function(events, handler) {
  ready_callbacks_default.add(function() {
    events.split(" ").forEach(function(event) {
      dom_adapter_default.listen(dom_adapter_default.getDocument(), event, handler, true);
    });
  });
};
var Observer = function(eventMap4, pointerEquals, onPointerAdding) {
  onPointerAdding = onPointerAdding || function() {
  };
  let pointers = [];
  const getPointerIndex = function(e) {
    let index2 = -1;
    each(pointers, function(i, pointer2) {
      if (!pointerEquals(e, pointer2)) {
        return true;
      }
      index2 = i;
      return false;
    });
    return index2;
  };
  const removePointer = function(e) {
    const index2 = getPointerIndex(e);
    if (index2 > -1) {
      pointers.splice(index2, 1);
    }
  };
  addEventsListener(eventMap4.dxpointerdown, function(e) {
    if (-1 === getPointerIndex(e)) {
      onPointerAdding(e);
      pointers.push(e);
    }
  });
  addEventsListener(eventMap4.dxpointermove, function(e) {
    pointers[getPointerIndex(e)] = e;
  });
  addEventsListener(eventMap4.dxpointerup, removePointer);
  addEventsListener(eventMap4.dxpointercancel, removePointer);
  this.pointers = function() {
    return pointers;
  };
  this.reset = function() {
    pointers = [];
  };
};
var observer_default = Observer;

// ../../../../../../node_modules/devextreme/esm/events/pointer/mouse.js
var eventMap2 = {
  dxpointerdown: "mousedown",
  dxpointermove: "mousemove",
  dxpointerup: "mouseup",
  dxpointercancel: "",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
var normalizeMouseEvent = function(e) {
  e.pointerId = 1;
  return {
    pointers: observer.pointers(),
    pointerId: 1
  };
};
var observer;
var activated = false;
var activateStrategy = function() {
  if (activated) {
    return;
  }
  observer = new observer_default(eventMap2, function() {
    return true;
  });
  activated = true;
};
var MouseStrategy = base_default.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _fireEvent: function(args) {
    return this.callBase(extend(normalizeMouseEvent(args.originalEvent), args));
  }
});
MouseStrategy.map = eventMap2;
MouseStrategy.normalize = normalizeMouseEvent;
MouseStrategy.activate = activateStrategy;
MouseStrategy.resetObserver = function() {
  observer.reset();
};
var mouse_default = MouseStrategy;

// ../../../../../../node_modules/devextreme/esm/events/pointer/mouse_and_touch.js
var eventMap3 = {
  dxpointerdown: "touchstart mousedown",
  dxpointermove: "touchmove mousemove",
  dxpointerup: "touchend mouseup",
  dxpointercancel: "touchcancel",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
var activated2 = false;
var activateStrategy2 = function() {
  if (activated2) {
    return;
  }
  mouse_default.activate();
  activated2 = true;
};
var MouseAndTouchStrategy = base_default.inherit({
  EVENT_LOCK_TIMEOUT: 100,
  ctor: function() {
    this.callBase.apply(this, arguments);
    activateStrategy2();
  },
  _handler: function(e) {
    const isMouse = isMouseEvent(e);
    if (!isMouse) {
      this._skipNextEvents = true;
    }
    if (isMouse && this._mouseLocked) {
      return;
    }
    if (isMouse && this._skipNextEvents) {
      this._skipNextEvents = false;
      this._mouseLocked = true;
      clearTimeout(this._unlockMouseTimer);
      const that = this;
      this._unlockMouseTimer = setTimeout(function() {
        that._mouseLocked = false;
      }, this.EVENT_LOCK_TIMEOUT);
      return;
    }
    return this.callBase(e);
  },
  _fireEvent: function(args) {
    const normalizer = isMouseEvent(args.originalEvent) ? mouse_default.normalize : touch_default.normalize;
    return this.callBase(extend(normalizer(args.originalEvent), args));
  },
  dispose: function() {
    this.callBase();
    this._skipNextEvents = false;
    this._mouseLocked = false;
    clearTimeout(this._unlockMouseTimer);
  }
});
MouseAndTouchStrategy.map = eventMap3;
MouseAndTouchStrategy.resetObserver = mouse_default.resetObserver;
var mouse_and_touch_default = MouseAndTouchStrategy;

// ../../../../../../node_modules/devextreme/esm/events/pointer.js
var getStrategy = (support, _ref) => {
  let {
    tablet,
    phone
  } = _ref;
  const pointerEventStrategy = getStrategyFromGlobalConfig();
  if (pointerEventStrategy) {
    return pointerEventStrategy;
  }
  if (support.touch && !(tablet || phone)) {
    return mouse_and_touch_default;
  }
  if (support.touch) {
    return touch_default;
  }
  return mouse_default;
};
var EventStrategy = getStrategy(support_exports, devices_default.real());
each(EventStrategy.map, (pointerEvent, originalEvents) => {
  event_registrator_default(pointerEvent, new EventStrategy(pointerEvent, originalEvents));
});
var pointer = {
  down: "dxpointerdown",
  up: "dxpointerup",
  move: "dxpointermove",
  cancel: "dxpointercancel",
  enter: "dxpointerenter",
  leave: "dxpointerleave",
  over: "dxpointerover",
  out: "dxpointerout"
};
function getStrategyFromGlobalConfig() {
  const eventStrategyName = config_default().pointerEventStrategy;
  return {
    "mouse-and-touch": mouse_and_touch_default,
    touch: touch_default,
    mouse: mouse_default
  }[eventStrategyName];
}
var pointer_default = pointer;

// ../../../../../../node_modules/devextreme/esm/core/utils/dom.js
var window8 = getWindow();
var getRootNodeHost = (element) => {
  if (!element.getRootNode) {
    return;
  }
  const host = element.getRootNode().host;
  if (isString(host)) {
    return;
  }
  return host;
};
var resetActiveElement = () => {
  const activeElement = dom_adapter_default.getActiveElement();
  if (activeElement && activeElement !== dom_adapter_default.getBody()) {
    var _activeElement$blur;
    null === (_activeElement$blur = activeElement.blur) || void 0 === _activeElement$blur || _activeElement$blur.call(activeElement);
  }
};
var clearSelection = () => {
  const selection = window8.getSelection();
  if (!selection) {
    return;
  }
  if ("Caret" === selection.type) {
    return;
  }
  if (selection.empty) {
    selection.empty();
  } else if (selection.removeAllRanges) {
    try {
      selection.removeAllRanges();
    } catch (e) {
    }
  }
};
var closestCommonParent = (startTarget, endTarget) => {
  const $startTarget = renderer_default(startTarget);
  const $endTarget = renderer_default(endTarget);
  if ($startTarget[0] === $endTarget[0]) {
    return $startTarget[0];
  }
  const $startParents = $startTarget.parents();
  const $endParents = $endTarget.parents();
  const startingParent = Math.min($startParents.length, $endParents.length);
  for (let i = -startingParent; i < 0; i++) {
    if ($startParents.get(i) === $endParents.get(i)) {
      return $startParents.get(i);
    }
  }
};
var normalizeTemplateElement = (element) => {
  let $element = isDefined(element) && (element.nodeType || isRenderer(element)) ? renderer_default(element) : renderer_default("<div>").html(element).contents();
  if (1 === $element.length) {
    if ($element.is("script")) {
      $element = normalizeTemplateElement($element.html().trim());
    } else if ($element.is("table")) {
      $element = $element.children("tbody").contents();
    }
  }
  return $element;
};
var clipboardText = (event, text) => {
  const clipboard = event.originalEvent && event.originalEvent.clipboardData || window8.clipboardData;
  if (!text) {
    return clipboard && clipboard.getData("Text");
  }
  clipboard && clipboard.setData("Text", text);
};
var contains2 = (container, element) => {
  if (!element) {
    return false;
  }
  if (isWindow(container)) {
    return contains2(container.document, element);
  }
  return container.contains(element) || contains2(container, getRootNodeHost(element));
};
var createTextElementHiddenCopy = (element, text, options2) => {
  const elementStyles = window8.getComputedStyle(renderer_default(element).get(0));
  const includePaddings = options2 && options2.includePaddings;
  return renderer_default("<div>").text(text).css({
    fontStyle: elementStyles.fontStyle,
    fontVariant: elementStyles.fontVariant,
    fontWeight: elementStyles.fontWeight,
    fontSize: elementStyles.fontSize,
    fontFamily: elementStyles.fontFamily,
    letterSpacing: elementStyles.letterSpacing,
    border: elementStyles.border,
    paddingTop: includePaddings ? elementStyles.paddingTop : "",
    paddingRight: includePaddings ? elementStyles.paddingRight : "",
    paddingBottom: includePaddings ? elementStyles.paddingBottom : "",
    paddingLeft: includePaddings ? elementStyles.paddingLeft : "",
    visibility: "hidden",
    whiteSpace: "pre",
    position: "absolute",
    float: "left"
  });
};
var insertBefore = (element, newElement) => {
  if (newElement) {
    dom_adapter_default.insertElement(element.parentNode, newElement, element);
  }
  return element;
};
var replaceWith = (element, newElement) => {
  if (!(newElement && newElement[0])) {
    return;
  }
  if (newElement.is(element)) {
    return element;
  }
  each(newElement, (_, currentElement) => {
    insertBefore(element[0], currentElement);
  });
  element.remove();
  return newElement;
};
var isElementInDom = ($element) => {
  const element = null === $element || void 0 === $element ? void 0 : $element.get(0);
  const shadowHost = null === element || void 0 === element ? void 0 : element.getRootNode().host;
  return !!renderer_default(shadowHost || element).closest(getWindow().document).length;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/math.js
var sign = function(value2) {
  if (0 === value2) {
    return 0;
  }
  return value2 / Math.abs(value2);
};
var fitIntoRange = function(value2, minValue, maxValue) {
  const isMinValueUndefined = !minValue && 0 !== minValue;
  const isMaxValueUndefined = !maxValue && 0 !== maxValue;
  isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value2, maxValue) : value2);
  isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value2, minValue) : value2);
  return Math.min(Math.max(value2, minValue), maxValue);
};
var inRange = function(value2, minValue, maxValue) {
  return value2 >= minValue && value2 <= maxValue;
};
function getExponent(value2) {
  return Math.abs(parseInt(value2.toExponential().split("e")[1]));
}
function getExponentialNotation(value2) {
  const parts = value2.toExponential().split("e");
  const mantissa = parseFloat(parts[0]);
  const exponent = parseInt(parts[1]);
  return {
    exponent,
    mantissa
  };
}
function multiplyInExponentialForm(value2, exponentShift) {
  const exponentialNotation = getExponentialNotation(value2);
  return parseFloat(`${exponentialNotation.mantissa}e${exponentialNotation.exponent + exponentShift}`);
}
function _isEdgeBug() {
  return "0.000300" !== 3e-4.toPrecision(3);
}
function adjust(value2, interval) {
  let precision = getPrecision(interval || 0) + 2;
  const separatedValue = value2.toString().split(".");
  const sourceValue = value2;
  const absValue = Math.abs(value2);
  let separatedAdjustedValue;
  const isExponentValue = isExponential(value2);
  const integerPart = absValue > 1 ? 10 : 0;
  if (1 === separatedValue.length) {
    return value2;
  }
  if (!isExponentValue) {
    if (isExponential(interval)) {
      precision = separatedValue[0].length + getExponent(interval);
    }
    value2 = absValue;
    value2 = value2 - Math.floor(value2) + integerPart;
  }
  precision = _isEdgeBug() && getExponent(value2) > 6 || precision > 7 ? 15 : 7;
  if (!isExponentValue) {
    separatedAdjustedValue = parseFloat(value2.toPrecision(precision)).toString().split(".");
    if (separatedAdjustedValue[0] === integerPart.toString()) {
      return parseFloat(separatedValue[0] + "." + separatedAdjustedValue[1]);
    }
  }
  return parseFloat(sourceValue.toPrecision(precision));
}
function getPrecision(value2) {
  const str = value2.toString();
  if (str.indexOf(".") < 0) {
    return 0;
  }
  const mantissa = str.split(".");
  const positionOfDelimiter = mantissa[1].indexOf("e");
  return positionOfDelimiter >= 0 ? positionOfDelimiter : mantissa[1].length;
}
function roundFloatPart(value2) {
  let digitsCount = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
  return parseFloat(value2.toFixed(digitsCount));
}

// ../../../../../../node_modules/devextreme/esm/localization/utils.js
var DECIMAL_BASE = 10;
function roundByAbs(value2) {
  const valueSign = sign(value2);
  return valueSign * Math.round(Math.abs(value2));
}
function adjustValue(value2, precision) {
  const precisionMultiplier = Math.pow(DECIMAL_BASE, precision);
  const intermediateValue = multiplyInExponentialForm(value2, precision);
  return roundByAbs(intermediateValue) / precisionMultiplier;
}
function toFixed(value2, precision) {
  const valuePrecision = precision || 0;
  const adjustedValue = valuePrecision > 0 ? adjustValue(...arguments) : value2;
  return adjustedValue.toFixed(valuePrecision);
}

// ../../../../../../node_modules/devextreme/esm/localization/ldml/number.js
var DEFAULT_CONFIG = {
  thousandsSeparator: ",",
  decimalSeparator: "."
};
var ESCAPING_CHAR = "'";
function getGroupSizes(formatString) {
  return formatString.split(",").slice(1).map(function(str) {
    let singleQuotesLeft = 0;
    return str.split("").filter(function(char, index2) {
      singleQuotesLeft += "'" === char;
      const isDigit = "#" === char || "0" === char;
      const isInStub = singleQuotesLeft % 2;
      return isDigit && !isInStub;
    }).length;
  });
}
function getSignParts(format2) {
  const signParts = format2.split(";");
  if (1 === signParts.length) {
    signParts.push("-" + signParts[0]);
  }
  return signParts;
}
function reverseString(str) {
  return str.toString().split("").reverse().join("");
}
function isPercentFormat(format2) {
  return -1 !== format2.indexOf("%") && !format2.match(/'[^']*%[^']*'/g);
}
function removeStubs(str) {
  return str.replace(/'.+'/g, "");
}
function getNonRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  const format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[#]/g, "").length;
}
function getRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  const format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[0]/g, "").length;
}
function normalizeValueString(valuePart, minDigitCount, maxDigitCount) {
  if (!valuePart) {
    return "";
  }
  if (valuePart.length > maxDigitCount) {
    valuePart = valuePart.substr(0, maxDigitCount);
  }
  while (valuePart.length > minDigitCount && "0" === valuePart.slice(-1)) {
    valuePart = valuePart.substr(0, valuePart.length - 1);
  }
  while (valuePart.length < minDigitCount) {
    valuePart += "0";
  }
  return valuePart;
}
function applyGroups(valueString, groupSizes, thousandsSeparator) {
  if (!groupSizes.length) {
    return valueString;
  }
  const groups = [];
  let index2 = 0;
  while (valueString) {
    const groupSize = groupSizes[index2];
    if (!groupSize) {
      break;
    }
    groups.push(valueString.slice(0, groupSize));
    valueString = valueString.slice(groupSize);
    if (index2 < groupSizes.length - 1) {
      index2++;
    }
  }
  return groups.join(thousandsSeparator);
}
function formatNumberPart(format2, valueString) {
  return format2.split(ESCAPING_CHAR).map(function(formatPart, escapeIndex) {
    const isEscape = escapeIndex % 2;
    if (!formatPart && isEscape) {
      return ESCAPING_CHAR;
    }
    return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString);
  }).join("");
}
function getFloatPointIndex(format2) {
  let isEscape = false;
  for (let index2 = 0; index2 < format2.length; index2++) {
    if ("'" === format2[index2]) {
      isEscape = !isEscape;
    }
    if ("." === format2[index2] && !isEscape) {
      return index2;
    }
  }
  return format2.length;
}
function getFormatter(format2, config3) {
  config3 = config3 || DEFAULT_CONFIG;
  return function(value2) {
    if ("number" !== typeof value2 || isNaN(value2)) {
      return "";
    }
    const signFormatParts = getSignParts(format2);
    const isPositiveZero = 1 / value2 === 1 / 0;
    const isPositive = value2 > 0 || isPositiveZero;
    const numberFormat = signFormatParts[isPositive ? 0 : 1];
    const floatPointIndex = getFloatPointIndex(numberFormat);
    const floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];
    const minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);
    const maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);
    if (isPercentFormat(numberFormat)) {
      value2 = multiplyInExponentialForm(value2, 2);
    }
    if (!isPositive) {
      value2 = -value2;
    }
    const minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);
    const maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config3.unlimitedIntegerDigits ? void 0 : minIntegerPrecision;
    const integerLength = Math.floor(value2).toString().length;
    const floatPrecision = fitIntoRange(maxFloatPrecision, 0, 15 - integerLength);
    const groupSizes = getGroupSizes(floatFormatParts[0]).reverse();
    const valueParts = toFixed(value2, floatPrecision < 0 ? 0 : floatPrecision).split(".");
    let valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);
    const valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);
    valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config3.thousandsSeparator);
    const integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));
    const floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : "";
    const result2 = integerString + (floatString.match(/\d/) ? config3.decimalSeparator : "") + floatString;
    return result2;
  };
}
function parseValue(text, isPercent, isNegative) {
  const value2 = (isPercent ? 0.01 : 1) * parseFloat(text) || 0;
  return isNegative ? -value2 : value2;
}
function prepareValueText(valueText, formatter, isPercent, isIntegerPart) {
  let nextValueText = valueText;
  let char;
  let text;
  let nextText;
  do {
    if (nextText) {
      char = text.length === nextText.length ? "0" : "1";
      valueText = isIntegerPart ? char + valueText : valueText + char;
    }
    text = nextText || formatter(parseValue(nextValueText, isPercent));
    nextValueText = isIntegerPart ? "1" + nextValueText : nextValueText + "1";
    nextText = formatter(parseValue(nextValueText, isPercent));
  } while (text !== nextText && (isIntegerPart ? text.length === nextText.length : text.length <= nextText.length));
  if (isIntegerPart && nextText.length > text.length) {
    const hasGroups = -1 === formatter(12345).indexOf("12345");
    do {
      valueText = "1" + valueText;
    } while (hasGroups && parseValue(valueText, isPercent) < 1e5);
  }
  return valueText;
}
function getFormatByValueText(valueText, formatter, isPercent, isNegative) {
  let format2 = formatter(parseValue(valueText, isPercent, isNegative));
  const valueTextParts = valueText.split(".");
  const valueTextWithModifiedFloat = valueTextParts[0] + ".3" + valueTextParts[1].slice(1);
  const valueWithModifiedFloat = parseValue(valueTextWithModifiedFloat, isPercent, isNegative);
  const decimalSeparatorIndex = formatter(valueWithModifiedFloat).indexOf("3") - 1;
  format2 = format2.replace(/(\d)\D(\d)/g, "$1,$2");
  if (decimalSeparatorIndex >= 0) {
    format2 = format2.slice(0, decimalSeparatorIndex) + "." + format2.slice(decimalSeparatorIndex + 1);
  }
  format2 = format2.replace(/1+/, "1").replace(/1/g, "#");
  if (!isPercent) {
    format2 = format2.replace(/%/g, "'%'");
  }
  return format2;
}
function getFormat(formatter) {
  let valueText = ".";
  const isPercent = formatter(1).indexOf("100") >= 0;
  valueText = prepareValueText(valueText, formatter, isPercent, true);
  valueText = prepareValueText(valueText, formatter, isPercent, false);
  const positiveFormat = getFormatByValueText(valueText, formatter, isPercent, false);
  const negativeFormat = getFormatByValueText(valueText, formatter, isPercent, true);
  return negativeFormat === "-" + positiveFormat ? positiveFormat : positiveFormat + ";" + negativeFormat;
}

// ../../../../../../node_modules/devextreme/esm/localization/currency.js
var currency_default = {
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("currency" === format2) {
      formatConfig.precision = formatConfig.precision || 0;
      let result2 = this.format(value2, extend({}, formatConfig, {
        type: "fixedpoint"
      }));
      const currencyPart = this.getCurrencySymbol().symbol.replace(/\$/g, "$$$$");
      result2 = result2.replace(/^(\D*)(\d.*)/, "$1" + currencyPart + "$2");
      return result2;
    }
    return this.callBase.apply(this, arguments);
  },
  getCurrencySymbol: function() {
    return {
      symbol: "$"
    };
  },
  getOpenXmlCurrencyFormat: function() {
    return "$#,##0{0}_);\\($#,##0{0}\\)";
  }
};

// ../../../../../../node_modules/devextreme/esm/localization/open_xml_currency_format.js
var open_xml_currency_format_default = (currencySymbol, accountingFormat) => {
  if (!accountingFormat) {
    return;
  }
  let encodedCurrencySymbol = currencySymbol;
  if ("string" === typeof currencySymbol) {
    encodedCurrencySymbol = "";
    for (let i = 0; i < currencySymbol.length; i++) {
      if ("$" !== currencySymbol[i]) {
        encodedCurrencySymbol += "\\";
      }
      encodedCurrencySymbol += currencySymbol[i];
    }
  }
  const encodeSymbols = {
    ".00": "{0}",
    "'": "\\'",
    "\\(": "\\(",
    "\\)": "\\)",
    " ": "\\ ",
    '"': "&quot;",
    "\\¤": encodedCurrencySymbol
  };
  const result2 = accountingFormat.split(";");
  for (let i = 0; i < result2.length; i++) {
    for (const symbol in encodeSymbols) {
      if (Object.prototype.hasOwnProperty.call(encodeSymbols, symbol)) {
        result2[i] = result2[i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol]);
      }
    }
  }
  return 2 === result2.length ? result2[0] + "_);" + result2[1] : result2[0];
};

// ../../../../../../node_modules/devextreme/esm/localization/cldr-data/accounting_formats.js
var accounting_formats_default = {
  af: "¤#,##0.00;(¤#,##0.00)",
  "af-NA": "¤#,##0.00;(¤#,##0.00)",
  agq: "#,##0.00¤",
  ak: "¤#,##0.00",
  am: "¤#,##0.00;(¤#,##0.00)",
  ar: "¤#,##0.00;(¤#,##0.00)",
  "ar-AE": "¤#,##0.00;(¤#,##0.00)",
  "ar-BH": "¤#,##0.00;(¤#,##0.00)",
  "ar-DJ": "¤#,##0.00;(¤#,##0.00)",
  "ar-DZ": "¤#,##0.00;(¤#,##0.00)",
  "ar-EG": "¤#,##0.00;(¤#,##0.00)",
  "ar-EH": "¤#,##0.00;(¤#,##0.00)",
  "ar-ER": "¤#,##0.00;(¤#,##0.00)",
  "ar-IL": "¤#,##0.00;(¤#,##0.00)",
  "ar-IQ": "¤#,##0.00;(¤#,##0.00)",
  "ar-JO": "¤#,##0.00;(¤#,##0.00)",
  "ar-KM": "¤#,##0.00;(¤#,##0.00)",
  "ar-KW": "¤#,##0.00;(¤#,##0.00)",
  "ar-LB": "¤#,##0.00;(¤#,##0.00)",
  "ar-LY": "¤#,##0.00;(¤#,##0.00)",
  "ar-MA": "¤#,##0.00;(¤#,##0.00)",
  "ar-MR": "¤#,##0.00;(¤#,##0.00)",
  "ar-OM": "¤#,##0.00;(¤#,##0.00)",
  "ar-PS": "¤#,##0.00;(¤#,##0.00)",
  "ar-QA": "¤#,##0.00;(¤#,##0.00)",
  "ar-SA": "¤#,##0.00;(¤#,##0.00)",
  "ar-SD": "¤#,##0.00;(¤#,##0.00)",
  "ar-SO": "¤#,##0.00;(¤#,##0.00)",
  "ar-SS": "¤#,##0.00;(¤#,##0.00)",
  "ar-SY": "¤#,##0.00;(¤#,##0.00)",
  "ar-TD": "¤#,##0.00;(¤#,##0.00)",
  "ar-TN": "¤#,##0.00;(¤#,##0.00)",
  "ar-YE": "¤#,##0.00;(¤#,##0.00)",
  as: "¤ #,##,##0.00",
  asa: "#,##0.00 ¤",
  ast: "#,##0.00 ¤",
  az: "#,##0.00 ¤",
  "az-Cyrl": "#,##0.00 ¤",
  "az-Latn": "#,##0.00 ¤",
  bas: "#,##0.00 ¤",
  be: "#,##0.00 ¤",
  "be-tarask": "#,##0.00 ¤",
  bem: "¤#,##0.00;(¤#,##0.00)",
  bez: "#,##0.00¤",
  bg: "0.00 ¤;(0.00 ¤)",
  bm: "¤#,##0.00;(¤#,##0.00)",
  bn: "#,##,##0.00¤;(#,##,##0.00¤)",
  "bn-IN": "#,##,##0.00¤;(#,##,##0.00¤)",
  bo: "¤ #,##0.00",
  "bo-IN": "¤ #,##0.00",
  br: "#,##0.00 ¤",
  brx: "¤ #,##,##0.00",
  bs: "#,##0.00 ¤",
  "bs-Cyrl": "#,##0.00 ¤",
  "bs-Latn": "#,##0.00 ¤",
  ca: "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-AD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-ES-valencia": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-FR": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-IT": "#,##0.00 ¤;(#,##0.00 ¤)",
  ccp: "#,##,##0.00¤;(#,##,##0.00¤)",
  "ccp-IN": "#,##,##0.00¤;(#,##,##0.00¤)",
  ce: "#,##0.00 ¤",
  ceb: "¤#,##0.00;(¤#,##0.00)",
  cgg: "¤#,##0.00",
  chr: "¤#,##0.00;(¤#,##0.00)",
  ckb: "¤ #,##0.00",
  "ckb-IR": "¤ #,##0.00",
  cs: "#,##0.00 ¤",
  cy: "¤#,##0.00;(¤#,##0.00)",
  da: "#,##0.00 ¤",
  "da-GL": "#,##0.00 ¤",
  dav: "¤#,##0.00;(¤#,##0.00)",
  de: "#,##0.00 ¤",
  "de-AT": "#,##0.00 ¤",
  "de-BE": "#,##0.00 ¤",
  "de-CH": "#,##0.00 ¤",
  "de-IT": "#,##0.00 ¤",
  "de-LI": "#,##0.00 ¤",
  "de-LU": "#,##0.00 ¤",
  dje: "#,##0.00¤",
  doi: "¤#,##0.00",
  dsb: "#,##0.00 ¤",
  dua: "#,##0.00 ¤",
  dyo: "#,##0.00 ¤",
  dz: "¤#,##,##0.00",
  ebu: "¤#,##0.00;(¤#,##0.00)",
  ee: "¤#,##0.00;(¤#,##0.00)",
  "ee-TG": "¤#,##0.00;(¤#,##0.00)",
  el: "#,##0.00 ¤",
  "el-CY": "#,##0.00 ¤",
  en: "¤#,##0.00;(¤#,##0.00)",
  "en-001": "¤#,##0.00;(¤#,##0.00)",
  "en-150": "#,##0.00 ¤",
  "en-AE": "¤#,##0.00;(¤#,##0.00)",
  "en-AG": "¤#,##0.00;(¤#,##0.00)",
  "en-AI": "¤#,##0.00;(¤#,##0.00)",
  "en-AS": "¤#,##0.00;(¤#,##0.00)",
  "en-AT": "¤ #,##0.00",
  "en-AU": "¤#,##0.00;(¤#,##0.00)",
  "en-BB": "¤#,##0.00;(¤#,##0.00)",
  "en-BE": "#,##0.00 ¤",
  "en-BI": "¤#,##0.00;(¤#,##0.00)",
  "en-BM": "¤#,##0.00;(¤#,##0.00)",
  "en-BS": "¤#,##0.00;(¤#,##0.00)",
  "en-BW": "¤#,##0.00;(¤#,##0.00)",
  "en-BZ": "¤#,##0.00;(¤#,##0.00)",
  "en-CA": "¤#,##0.00;(¤#,##0.00)",
  "en-CC": "¤#,##0.00;(¤#,##0.00)",
  "en-CH": "¤ #,##0.00;¤-#,##0.00",
  "en-CK": "¤#,##0.00;(¤#,##0.00)",
  "en-CM": "¤#,##0.00;(¤#,##0.00)",
  "en-CX": "¤#,##0.00;(¤#,##0.00)",
  "en-CY": "¤#,##0.00;(¤#,##0.00)",
  "en-DE": "#,##0.00 ¤",
  "en-DG": "¤#,##0.00;(¤#,##0.00)",
  "en-DK": "#,##0.00 ¤",
  "en-DM": "¤#,##0.00;(¤#,##0.00)",
  "en-ER": "¤#,##0.00;(¤#,##0.00)",
  "en-FI": "#,##0.00 ¤",
  "en-FJ": "¤#,##0.00;(¤#,##0.00)",
  "en-FK": "¤#,##0.00;(¤#,##0.00)",
  "en-FM": "¤#,##0.00;(¤#,##0.00)",
  "en-GB": "¤#,##0.00;(¤#,##0.00)",
  "en-GD": "¤#,##0.00;(¤#,##0.00)",
  "en-GG": "¤#,##0.00;(¤#,##0.00)",
  "en-GH": "¤#,##0.00;(¤#,##0.00)",
  "en-GI": "¤#,##0.00;(¤#,##0.00)",
  "en-GM": "¤#,##0.00;(¤#,##0.00)",
  "en-GU": "¤#,##0.00;(¤#,##0.00)",
  "en-GY": "¤#,##0.00;(¤#,##0.00)",
  "en-HK": "¤#,##0.00;(¤#,##0.00)",
  "en-IE": "¤#,##0.00;(¤#,##0.00)",
  "en-IL": "¤#,##0.00;(¤#,##0.00)",
  "en-IM": "¤#,##0.00;(¤#,##0.00)",
  "en-IN": "¤#,##0.00;(¤#,##0.00)",
  "en-IO": "¤#,##0.00;(¤#,##0.00)",
  "en-JE": "¤#,##0.00;(¤#,##0.00)",
  "en-JM": "¤#,##0.00;(¤#,##0.00)",
  "en-KE": "¤#,##0.00;(¤#,##0.00)",
  "en-KI": "¤#,##0.00;(¤#,##0.00)",
  "en-KN": "¤#,##0.00;(¤#,##0.00)",
  "en-KY": "¤#,##0.00;(¤#,##0.00)",
  "en-LC": "¤#,##0.00;(¤#,##0.00)",
  "en-LR": "¤#,##0.00;(¤#,##0.00)",
  "en-LS": "¤#,##0.00;(¤#,##0.00)",
  "en-MG": "¤#,##0.00;(¤#,##0.00)",
  "en-MH": "¤#,##0.00;(¤#,##0.00)",
  "en-MO": "¤#,##0.00;(¤#,##0.00)",
  "en-MP": "¤#,##0.00;(¤#,##0.00)",
  "en-MS": "¤#,##0.00;(¤#,##0.00)",
  "en-MT": "¤#,##0.00;(¤#,##0.00)",
  "en-MU": "¤#,##0.00;(¤#,##0.00)",
  "en-MV": "¤ #,##0.00",
  "en-MW": "¤#,##0.00;(¤#,##0.00)",
  "en-MY": "¤#,##0.00;(¤#,##0.00)",
  "en-NA": "¤#,##0.00;(¤#,##0.00)",
  "en-NF": "¤#,##0.00;(¤#,##0.00)",
  "en-NG": "¤#,##0.00;(¤#,##0.00)",
  "en-NL": "¤ #,##0.00;(¤ #,##0.00)",
  "en-NR": "¤#,##0.00;(¤#,##0.00)",
  "en-NU": "¤#,##0.00;(¤#,##0.00)",
  "en-NZ": "¤#,##0.00;(¤#,##0.00)",
  "en-PG": "¤#,##0.00;(¤#,##0.00)",
  "en-PH": "¤#,##0.00;(¤#,##0.00)",
  "en-PK": "¤#,##0.00;(¤#,##0.00)",
  "en-PN": "¤#,##0.00;(¤#,##0.00)",
  "en-PR": "¤#,##0.00;(¤#,##0.00)",
  "en-PW": "¤#,##0.00;(¤#,##0.00)",
  "en-RW": "¤#,##0.00;(¤#,##0.00)",
  "en-SB": "¤#,##0.00;(¤#,##0.00)",
  "en-SC": "¤#,##0.00;(¤#,##0.00)",
  "en-SD": "¤#,##0.00;(¤#,##0.00)",
  "en-SE": "#,##0.00 ¤",
  "en-SG": "¤#,##0.00;(¤#,##0.00)",
  "en-SH": "¤#,##0.00;(¤#,##0.00)",
  "en-SI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "en-SL": "¤#,##0.00;(¤#,##0.00)",
  "en-SS": "¤#,##0.00;(¤#,##0.00)",
  "en-SX": "¤#,##0.00;(¤#,##0.00)",
  "en-SZ": "¤#,##0.00;(¤#,##0.00)",
  "en-TC": "¤#,##0.00;(¤#,##0.00)",
  "en-TK": "¤#,##0.00;(¤#,##0.00)",
  "en-TO": "¤#,##0.00;(¤#,##0.00)",
  "en-TT": "¤#,##0.00;(¤#,##0.00)",
  "en-TV": "¤#,##0.00;(¤#,##0.00)",
  "en-TZ": "¤#,##0.00;(¤#,##0.00)",
  "en-UG": "¤#,##0.00;(¤#,##0.00)",
  "en-UM": "¤#,##0.00;(¤#,##0.00)",
  "en-VC": "¤#,##0.00;(¤#,##0.00)",
  "en-VG": "¤#,##0.00;(¤#,##0.00)",
  "en-VI": "¤#,##0.00;(¤#,##0.00)",
  "en-VU": "¤#,##0.00;(¤#,##0.00)",
  "en-WS": "¤#,##0.00;(¤#,##0.00)",
  "en-ZA": "¤#,##0.00;(¤#,##0.00)",
  "en-ZM": "¤#,##0.00;(¤#,##0.00)",
  "en-ZW": "¤#,##0.00;(¤#,##0.00)",
  eo: "¤ #,##0.00",
  es: "#,##0.00 ¤",
  "es-419": "¤#,##0.00",
  "es-AR": "¤ #,##0.00;(¤ #,##0.00)",
  "es-BO": "¤#,##0.00",
  "es-BR": "¤#,##0.00",
  "es-BZ": "¤#,##0.00",
  "es-CL": "¤#,##0.00",
  "es-CO": "¤#,##0.00",
  "es-CR": "¤#,##0.00",
  "es-CU": "¤#,##0.00",
  "es-DO": "¤#,##0.00;(¤#,##0.00)",
  "es-EA": "#,##0.00 ¤",
  "es-EC": "¤#,##0.00",
  "es-GQ": "#,##0.00 ¤",
  "es-GT": "¤#,##0.00",
  "es-HN": "¤#,##0.00",
  "es-IC": "#,##0.00 ¤",
  "es-MX": "¤#,##0.00",
  "es-NI": "¤#,##0.00",
  "es-PA": "¤#,##0.00",
  "es-PE": "¤#,##0.00",
  "es-PH": "#,##0.00 ¤",
  "es-PR": "¤#,##0.00",
  "es-PY": "¤#,##0.00",
  "es-SV": "¤#,##0.00",
  "es-US": "¤#,##0.00",
  "es-UY": "¤ #,##0.00;(¤ #,##0.00)",
  "es-VE": "¤#,##0.00",
  et: "#,##0.00 ¤;(#,##0.00 ¤)",
  eu: "#,##0.00 ¤;(#,##0.00 ¤)",
  ewo: "#,##0.00 ¤",
  fa: "‎¤ #,##0.00;‎(¤ #,##0.00)",
  "fa-AF": "¤ #,##0.00;‎(¤ #,##0.00)",
  ff: "#,##0.00 ¤",
  "ff-Adlm": "¤ #,##0.00",
  "ff-Adlm-BF": "¤ #,##0.00",
  "ff-Adlm-CM": "¤ #,##0.00",
  "ff-Adlm-GH": "¤ #,##0.00",
  "ff-Adlm-GM": "¤ #,##0.00",
  "ff-Adlm-GW": "¤ #,##0.00",
  "ff-Adlm-LR": "¤ #,##0.00",
  "ff-Adlm-MR": "¤ #,##0.00",
  "ff-Adlm-NE": "¤ #,##0.00",
  "ff-Adlm-NG": "¤ #,##0.00",
  "ff-Adlm-SL": "¤ #,##0.00",
  "ff-Adlm-SN": "¤ #,##0.00",
  "ff-Latn": "#,##0.00 ¤",
  "ff-Latn-BF": "#,##0.00 ¤",
  "ff-Latn-CM": "#,##0.00 ¤",
  "ff-Latn-GH": "#,##0.00 ¤",
  "ff-Latn-GM": "#,##0.00 ¤",
  "ff-Latn-GN": "#,##0.00 ¤",
  "ff-Latn-GW": "#,##0.00 ¤",
  "ff-Latn-LR": "#,##0.00 ¤",
  "ff-Latn-MR": "#,##0.00 ¤",
  "ff-Latn-NE": "#,##0.00 ¤",
  "ff-Latn-NG": "#,##0.00 ¤",
  "ff-Latn-SL": "#,##0.00 ¤",
  fi: "#,##0.00 ¤",
  fil: "¤#,##0.00;(¤#,##0.00)",
  fo: "#,##0.00 ¤;(#,##0.00 ¤)",
  "fo-DK": "#,##0.00 ¤;(#,##0.00 ¤)",
  fr: "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BJ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BL": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CH": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-DJ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-DZ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GP": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-HT": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-KM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-LU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-ML": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MR": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-NC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-NE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-PF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-PM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-RE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-RW": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SY": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-VU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-WF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-YT": "#,##0.00 ¤;(#,##0.00 ¤)",
  fur: "¤ #,##0.00",
  fy: "¤ #,##0.00;(¤ #,##0.00)",
  ga: "¤#,##0.00;(¤#,##0.00)",
  "ga-GB": "¤#,##0.00;(¤#,##0.00)",
  gd: "¤#,##0.00;(¤#,##0.00)",
  gl: "#,##0.00 ¤",
  gsw: "#,##0.00 ¤",
  "gsw-FR": "#,##0.00 ¤",
  "gsw-LI": "#,##0.00 ¤",
  gu: "¤#,##,##0.00;(¤#,##,##0.00)",
  guz: "¤#,##0.00;(¤#,##0.00)",
  gv: "¤#,##0.00",
  ha: "¤ #,##0.00",
  "ha-GH": "¤ #,##0.00",
  "ha-NE": "¤ #,##0.00",
  haw: "¤#,##0.00;(¤#,##0.00)",
  he: "#,##0.00 ¤",
  hi: "¤#,##,##0.00",
  "hi-Latn": "¤#,##,##0.00",
  hr: "#,##0.00 ¤",
  "hr-BA": "#,##0.00 ¤",
  hsb: "#,##0.00 ¤",
  hu: "#,##0.00 ¤",
  hy: "#,##0.00 ¤",
  ia: "¤ #,##0.00;(¤ #,##0.00)",
  id: "¤#,##0.00",
  ig: "¤#,##0.00;(¤#,##0.00)",
  ii: "¤ #,##0.00",
  is: "#,##0.00 ¤",
  it: "#,##0.00 ¤",
  "it-CH": "#,##0.00 ¤",
  "it-SM": "#,##0.00 ¤",
  "it-VA": "#,##0.00 ¤",
  ja: "¤#,##0.00;(¤#,##0.00)",
  jgo: "¤ #,##0.00",
  jmc: "¤#,##0.00",
  jv: "¤ #,##0.00",
  ka: "#,##0.00 ¤",
  kab: "#,##0.00¤",
  kam: "¤#,##0.00;(¤#,##0.00)",
  kde: "¤#,##0.00;(¤#,##0.00)",
  kea: "#,##0.00 ¤;(#,##0.00 ¤)",
  kgp: "¤ #,##0.00",
  khq: "#,##0.00¤",
  ki: "¤#,##0.00;(¤#,##0.00)",
  kk: "#,##0.00 ¤",
  kkj: "¤ #,##0.00",
  kl: "¤#,##0.00;¤-#,##0.00",
  kln: "¤#,##0.00;(¤#,##0.00)",
  km: "#,##0.00¤;(#,##0.00¤)",
  kn: "¤#,##0.00;(¤#,##0.00)",
  ko: "¤#,##0.00;(¤#,##0.00)",
  "ko-KP": "¤#,##0.00;(¤#,##0.00)",
  kok: "¤#,##0.00;(¤#,##0.00)",
  ks: "¤#,##0.00",
  "ks-Arab": "¤#,##0.00",
  "ks-Deva": "¤ #,##0.00",
  ksb: "#,##0.00¤",
  ksf: "#,##0.00 ¤",
  ksh: "#,##0.00 ¤",
  ku: "#,##0.00 ¤;(#,##0.00 ¤)",
  kw: "¤#,##0.00",
  ky: "#,##0.00 ¤",
  lag: "¤ #,##0.00",
  lb: "#,##0.00 ¤",
  lg: "#,##0.00¤",
  lkt: "¤ #,##0.00",
  ln: "#,##0.00 ¤",
  "ln-AO": "#,##0.00 ¤",
  "ln-CF": "#,##0.00 ¤",
  "ln-CG": "#,##0.00 ¤",
  lo: "¤#,##0.00;¤-#,##0.00",
  lrc: "¤ #,##0.00",
  "lrc-IQ": "¤ #,##0.00",
  lt: "#,##0.00 ¤",
  lu: "#,##0.00¤",
  luo: "#,##0.00¤",
  luy: "¤#,##0.00;¤- #,##0.00",
  lv: "#,##0.00 ¤",
  mai: "¤ #,##0.00",
  mas: "¤#,##0.00;(¤#,##0.00)",
  "mas-TZ": "¤#,##0.00;(¤#,##0.00)",
  mer: "¤#,##0.00;(¤#,##0.00)",
  mfe: "¤ #,##0.00",
  mg: "¤#,##0.00",
  mgh: "¤ #,##0.00",
  mgo: "¤ #,##0.00",
  mi: "¤ #,##0.00",
  mk: "#,##0.00 ¤",
  ml: "¤#,##0.00;(¤#,##0.00)",
  mn: "¤ #,##0.00",
  mni: "¤ #,##0.00",
  "mni-Beng": "¤ #,##0.00",
  mr: "¤#,##0.00;(¤#,##0.00)",
  ms: "¤#,##0.00;(¤#,##0.00)",
  "ms-BN": "¤#,##0.00;(¤#,##0.00)",
  "ms-ID": "¤#,##0.00",
  "ms-SG": "¤#,##0.00;(¤#,##0.00)",
  mt: "¤#,##0.00",
  mua: "¤#,##0.00;(¤#,##0.00)",
  my: "¤ #,##0.00",
  mzn: "¤ #,##0.00",
  naq: "¤#,##0.00",
  nb: "¤ #,##0.00;(¤ #,##0.00)",
  "nb-SJ": "¤ #,##0.00;(¤ #,##0.00)",
  nd: "¤#,##0.00;(¤#,##0.00)",
  nds: "¤ #,##0.00",
  "nds-NL": "¤ #,##0.00",
  ne: "¤ #,##,##0.00",
  "ne-IN": "¤ #,##,##0.00",
  nl: "¤ #,##0.00;(¤ #,##0.00)",
  "nl-AW": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-BE": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-BQ": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-CW": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-SR": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-SX": "¤ #,##0.00;(¤ #,##0.00)",
  nmg: "#,##0.00 ¤",
  nn: "#,##0.00 ¤",
  nnh: "¤ #,##0.00",
  no: "¤ #,##0.00;(¤ #,##0.00)",
  nus: "¤#,##0.00;(¤#,##0.00)",
  nyn: "¤#,##0.00",
  om: "¤#,##0.00",
  "om-KE": "¤#,##0.00",
  or: "¤#,##0.00;(¤#,##0.00)",
  os: "¤ #,##0.00",
  "os-RU": "¤ #,##0.00",
  pa: "¤ #,##0.00",
  "pa-Arab": "¤ #,##0.00",
  "pa-Guru": "¤ #,##0.00",
  pcm: "¤#,##0.00",
  pl: "#,##0.00 ¤;(#,##0.00 ¤)",
  ps: "¤#,##0.00;(¤#,##0.00)",
  "ps-PK": "¤#,##0.00;(¤#,##0.00)",
  pt: "¤ #,##0.00",
  "pt-AO": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-CH": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-CV": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-GQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-GW": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-LU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-MO": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-MZ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-PT": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-ST": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-TL": "#,##0.00 ¤;(#,##0.00 ¤)",
  qu: "¤ #,##0.00",
  "qu-BO": "¤ #,##0.00",
  "qu-EC": "¤ #,##0.00",
  rm: "#,##0.00 ¤",
  rn: "#,##0.00¤",
  ro: "#,##0.00 ¤;(#,##0.00 ¤)",
  "ro-MD": "#,##0.00 ¤;(#,##0.00 ¤)",
  rof: "¤#,##0.00",
  ru: "#,##0.00 ¤",
  "ru-BY": "#,##0.00 ¤",
  "ru-KG": "#,##0.00 ¤",
  "ru-KZ": "#,##0.00 ¤",
  "ru-MD": "#,##0.00 ¤",
  "ru-UA": "#,##0.00 ¤",
  rw: "¤ #,##0.00",
  rwk: "#,##0.00¤",
  sa: "¤ #,##0.00",
  sah: "#,##0.00 ¤",
  saq: "¤#,##0.00;(¤#,##0.00)",
  sat: "¤ #,##0.00",
  "sat-Olck": "¤ #,##0.00",
  sbp: "#,##0.00¤",
  sc: "#,##0.00 ¤",
  sd: "¤ #,##0.00",
  "sd-Arab": "¤ #,##0.00",
  "sd-Deva": "¤ #,##0.00",
  se: "#,##0.00 ¤",
  "se-FI": "#,##0.00 ¤",
  "se-SE": "#,##0.00 ¤",
  seh: "#,##0.00¤",
  ses: "#,##0.00¤",
  sg: "¤#,##0.00;¤-#,##0.00",
  shi: "#,##0.00¤",
  "shi-Latn": "#,##0.00¤",
  "shi-Tfng": "#,##0.00¤",
  si: "¤#,##0.00;(¤#,##0.00)",
  sk: "#,##0.00 ¤;(#,##0.00 ¤)",
  sl: "#,##0.00 ¤;(#,##0.00 ¤)",
  smn: "#,##0.00 ¤",
  sn: "¤#,##0.00;(¤#,##0.00)",
  so: "¤#,##0.00;(¤#,##0.00)",
  "so-DJ": "¤#,##0.00;(¤#,##0.00)",
  "so-ET": "¤#,##0.00;(¤#,##0.00)",
  "so-KE": "¤#,##0.00;(¤#,##0.00)",
  sq: "#,##0.00 ¤;(#,##0.00 ¤)",
  "sq-MK": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sq-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  sr: "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-BA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-ME": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-BA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-ME": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  su: "¤#,##0.00",
  "su-Latn": "¤#,##0.00",
  sv: "#,##0.00 ¤",
  "sv-AX": "#,##0.00 ¤",
  "sv-FI": "#,##0.00 ¤",
  sw: "¤ #,##0.00",
  "sw-CD": "¤ #,##0.00",
  "sw-KE": "¤ #,##0.00",
  "sw-UG": "¤ #,##0.00",
  ta: "¤#,##0.00;(¤#,##0.00)",
  "ta-LK": "¤#,##0.00;(¤#,##0.00)",
  "ta-MY": "¤#,##0.00;(¤#,##0.00)",
  "ta-SG": "¤#,##0.00;(¤#,##0.00)",
  te: "¤#,##0.00;(¤#,##0.00)",
  teo: "¤#,##0.00;(¤#,##0.00)",
  "teo-KE": "¤#,##0.00;(¤#,##0.00)",
  tg: "#,##0.00 ¤",
  th: "¤#,##0.00;(¤#,##0.00)",
  ti: "¤#,##0.00",
  "ti-ER": "¤#,##0.00",
  tk: "#,##0.00 ¤",
  to: "¤ #,##0.00",
  tr: "¤#,##0.00;(¤#,##0.00)",
  "tr-CY": "¤#,##0.00;(¤#,##0.00)",
  tt: "#,##0.00 ¤",
  twq: "#,##0.00¤",
  tzm: "#,##0.00 ¤",
  ug: "¤#,##0.00;(¤#,##0.00)",
  uk: "#,##0.00 ¤",
  und: "¤ #,##0.00",
  ur: "¤#,##0.00;(¤#,##0.00)",
  "ur-IN": "¤#,##0.00;(¤#,##0.00)",
  uz: "#,##0.00 ¤",
  "uz-Arab": "¤ #,##0.00",
  "uz-Cyrl": "#,##0.00 ¤",
  "uz-Latn": "#,##0.00 ¤",
  vai: "¤#,##0.00;(¤#,##0.00)",
  "vai-Latn": "¤#,##0.00;(¤#,##0.00)",
  "vai-Vaii": "¤#,##0.00;(¤#,##0.00)",
  vi: "#,##0.00 ¤",
  vun: "¤#,##0.00",
  wae: "¤ #,##0.00",
  wo: "¤ #,##0.00",
  xh: "¤#,##0.00",
  xog: "#,##0.00 ¤",
  yav: "#,##0.00 ¤;(#,##0.00 ¤)",
  yi: "¤ #,##0.00",
  yo: "¤#,##0.00;(¤#,##0.00)",
  "yo-BJ": "¤#,##0.00;(¤#,##0.00)",
  yrl: "¤ #,##0.00",
  "yrl-CO": "¤ #,##0.00",
  "yrl-VE": "¤ #,##0.00",
  yue: "¤#,##0.00;(¤#,##0.00)",
  "yue-Hans": "¤#,##0.00;(¤#,##0.00)",
  "yue-Hant": "¤#,##0.00;(¤#,##0.00)",
  zgh: "#,##0.00¤",
  zh: "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-HK": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-MO": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-SG": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant-HK": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant-MO": "¤#,##0.00;(¤#,##0.00)",
  zu: "¤#,##0.00;(¤#,##0.00)"
};

// ../../../../../../node_modules/devextreme/esm/localization/intl/number.js
var CURRENCY_STYLES = ["standard", "accounting"];
var detectCurrencySymbolRegex = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/;
var formattersCache = {};
var getFormatter2 = (format2) => {
  const key = core_default.locale() + "/" + JSON.stringify(format2);
  if (!formattersCache[key]) {
    formattersCache[key] = new Intl.NumberFormat(core_default.locale(), format2).format;
  }
  return formattersCache[key];
};
var getCurrencyFormatter = (currency) => new Intl.NumberFormat(core_default.locale(), {
  style: "currency",
  currency
});
var number_default = {
  engine: function() {
    return "intl";
  },
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("exponential" === format2) {
      return this.callBase.apply(this, arguments);
    }
    return getFormatter2(this._normalizeFormatConfig(format2, formatConfig, value2))(value2);
  },
  _normalizeFormatConfig: function(format2, formatConfig, value2) {
    let config3;
    if ("decimal" === format2) {
      const fractionDigits = String(value2).split(".")[1];
      config3 = {
        minimumIntegerDigits: formatConfig.precision || void 0,
        useGrouping: false,
        maximumFractionDigits: fractionDigits && fractionDigits.length,
        round: value2 < 0 ? "ceil" : "floor"
      };
    } else {
      config3 = this._getPrecisionConfig(formatConfig.precision);
    }
    if ("percent" === format2) {
      config3.style = "percent";
    } else if ("currency" === format2) {
      const useAccountingStyle = formatConfig.useCurrencyAccountingStyle ?? config_default().defaultUseCurrencyAccountingStyle;
      config3.style = "currency";
      config3.currency = formatConfig.currency || config_default().defaultCurrency;
      config3.currencySign = CURRENCY_STYLES[+useAccountingStyle];
    }
    return config3;
  },
  _getPrecisionConfig: function(precision) {
    let config3;
    if (null === precision) {
      config3 = {
        minimumFractionDigits: 0,
        maximumFractionDigits: 20
      };
    } else {
      config3 = {
        minimumFractionDigits: precision || 0,
        maximumFractionDigits: precision || 0
      };
    }
    return config3;
  },
  format: function(value2, format2) {
    if ("number" !== typeof value2) {
      return value2;
    }
    format2 = this._normalizeFormat(format2);
    if ("default" === format2.currency) {
      format2.currency = config_default().defaultCurrency;
    }
    if (!format2 || "function" !== typeof format2 && !format2.type && !format2.formatter) {
      return getFormatter2(format2)(value2);
    }
    return this.callBase.apply(this, arguments);
  },
  _getCurrencySymbolInfo: function(currency) {
    const formatter = getCurrencyFormatter(currency);
    return this._extractCurrencySymbolInfo(formatter.format(0));
  },
  _extractCurrencySymbolInfo: function(currencyValueString) {
    const match2 = detectCurrencySymbolRegex.exec(currencyValueString) || [];
    const position3 = match2[1] ? "before" : "after";
    const symbol = match2[1] || match2[4] || "";
    const delimiter = match2[2] || match2[3] || "";
    return {
      position: position3,
      symbol,
      delimiter
    };
  },
  getCurrencySymbol: function(currency) {
    if (!currency) {
      currency = config_default().defaultCurrency;
    }
    const symbolInfo = this._getCurrencySymbolInfo(currency);
    return {
      symbol: symbolInfo.symbol
    };
  },
  getOpenXmlCurrencyFormat: function(currency) {
    const targetCurrency = currency || config_default().defaultCurrency;
    const currencySymbol = this._getCurrencySymbolInfo(targetCurrency).symbol;
    const closestAccountingFormat = core_default.getValueByClosestLocale((locale) => accounting_formats_default[locale]);
    return open_xml_currency_format_default(currencySymbol, closestAccountingFormat);
  }
};

// ../../../../../../node_modules/devextreme/esm/localization/number.js
var hasIntl = "undefined" !== typeof Intl;
var NUMERIC_FORMATS = ["currency", "fixedpoint", "exponential", "percent", "decimal"];
var LargeNumberFormatPostfixes = {
  1: "K",
  2: "M",
  3: "B",
  4: "T"
};
var LargeNumberFormatPowers = {
  largenumber: "auto",
  thousands: 1,
  millions: 2,
  billions: 3,
  trillions: 4
};
var numberLocalization = dependency_injector_default({
  engine: function() {
    return "base";
  },
  numericFormats: NUMERIC_FORMATS,
  defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
  _parseNumberFormatString: function(formatType) {
    const formatObject = {};
    if (!formatType || "string" !== typeof formatType) {
      return;
    }
    const formatList = formatType.toLowerCase().split(" ");
    each(formatList, (index2, value2) => {
      if (NUMERIC_FORMATS.includes(value2)) {
        formatObject.formatType = value2;
      } else if (value2 in LargeNumberFormatPowers) {
        formatObject.power = LargeNumberFormatPowers[value2];
      }
    });
    if (formatObject.power && !formatObject.formatType) {
      formatObject.formatType = "fixedpoint";
    }
    if (formatObject.formatType) {
      return formatObject;
    }
  },
  _calculateNumberPower: function(value2, base2, minPower, maxPower) {
    let number = Math.abs(value2);
    let power = 0;
    if (number > 1) {
      while (number && number >= base2 && (void 0 === maxPower || power < maxPower)) {
        power++;
        number /= base2;
      }
    } else if (number > 0 && number < 1) {
      while (number < 1 && (void 0 === minPower || power > minPower)) {
        power--;
        number *= base2;
      }
    }
    return power;
  },
  _getNumberByPower: function(number, power, base2) {
    let result2 = number;
    while (power > 0) {
      result2 /= base2;
      power--;
    }
    while (power < 0) {
      result2 *= base2;
      power++;
    }
    return result2;
  },
  _formatNumber: function(value2, formatObject, formatConfig) {
    if ("auto" === formatObject.power) {
      formatObject.power = this._calculateNumberPower(value2, 1e3, 0, 4);
    }
    if (formatObject.power) {
      value2 = this._getNumberByPower(value2, formatObject.power, 1e3);
    }
    const powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || "";
    let result2 = this._formatNumberCore(value2, formatObject.formatType, formatConfig);
    result2 = result2.replace(/(\d|.$)(\D*)$/, "$1" + powerPostfix + "$2");
    return result2;
  },
  _formatNumberExponential: function(value2, formatConfig) {
    let power = this._calculateNumberPower(value2, 10);
    let number = this._getNumberByPower(value2, power, 10);
    if (void 0 === formatConfig.precision) {
      formatConfig.precision = 1;
    }
    if (number.toFixed(formatConfig.precision || 0) >= 10) {
      power++;
      number /= 10;
    }
    const powString = (power >= 0 ? "+" : "") + power.toString();
    return this._formatNumberCore(number, "fixedpoint", formatConfig) + "E" + powString;
  },
  _addZeroes: function(value2, precision) {
    const multiplier = Math.pow(10, precision);
    const sign2 = value2 < 0 ? "-" : "";
    value2 = (Math.abs(value2) * multiplier >>> 0) / multiplier;
    let result2 = value2.toString();
    while (result2.length < precision) {
      result2 = "0" + result2;
    }
    return sign2 + result2;
  },
  _addGroupSeparators: function(value2) {
    const parts = value2.toString().split(".");
    return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, config_default().thousandsSeparator) + (parts[1] ? config_default().decimalSeparator + parts[1] : "");
  },
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("exponential" === format2) {
      return this._formatNumberExponential(value2, formatConfig);
    }
    if ("decimal" !== format2 && null !== formatConfig.precision) {
      formatConfig.precision = formatConfig.precision || 0;
    }
    if ("percent" === format2) {
      value2 *= 100;
    }
    if (void 0 !== formatConfig.precision) {
      if ("decimal" === format2) {
        value2 = this._addZeroes(value2, formatConfig.precision);
      } else {
        value2 = null === formatConfig.precision ? value2.toPrecision() : toFixed(value2, formatConfig.precision);
      }
    }
    if ("decimal" !== format2) {
      value2 = this._addGroupSeparators(value2);
    } else {
      value2 = value2.toString().replace(".", config_default().decimalSeparator);
    }
    if ("percent" === format2) {
      value2 += "%";
    }
    return value2;
  },
  _normalizeFormat: function(format2) {
    if (!format2) {
      return {};
    }
    if ("function" === typeof format2) {
      return format2;
    }
    if (!isPlainObject(format2)) {
      format2 = {
        type: format2
      };
    }
    return format2;
  },
  _getSeparators: function() {
    return {
      decimalSeparator: this.getDecimalSeparator(),
      thousandsSeparator: this.getThousandsSeparator()
    };
  },
  getThousandsSeparator: function() {
    return this.format(1e4, "fixedPoint")[2];
  },
  getDecimalSeparator: function() {
    return this.format(1.2, {
      type: "fixedPoint",
      precision: 1
    })[1];
  },
  convertDigits: function(value2, toStandard) {
    const digits = this.format(90, "decimal");
    if ("string" !== typeof value2 || "0" === digits[1]) {
      return value2;
    }
    const fromFirstDigit = toStandard ? digits[1] : "0";
    const toFirstDigit = toStandard ? "0" : digits[1];
    const fromLastDigit = toStandard ? digits[0] : "9";
    const regExp = new RegExp("[" + fromFirstDigit + "-" + fromLastDigit + "]", "g");
    return value2.replace(regExp, (char) => String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0))));
  },
  getNegativeEtalonRegExp: function(format2) {
    const separators = this._getSeparators();
    const digitalRegExp = new RegExp("[0-9" + escapeRegExp(separators.decimalSeparator + separators.thousandsSeparator) + "]+", "g");
    let negativeEtalon = this.format(-1, format2).replace(digitalRegExp, "1");
    ["\\", "(", ")", "[", "]", "*", "+", "$", "^", "?", "|", "{", "}"].forEach((char) => {
      negativeEtalon = negativeEtalon.replace(new RegExp(`\\${char}`, "g"), `\\${char}`);
    });
    negativeEtalon = negativeEtalon.replace(/ /g, "\\s");
    negativeEtalon = negativeEtalon.replace(/1/g, ".*");
    return new RegExp(negativeEtalon, "g");
  },
  getSign: function(text, format2) {
    if (!format2) {
      if ("-" === text.replace(/[^0-9-]/g, "").charAt(0)) {
        return -1;
      }
      return 1;
    }
    const negativeEtalon = this.getNegativeEtalonRegExp(format2);
    return text.match(negativeEtalon) ? -1 : 1;
  },
  format: function(value2, format2) {
    if ("number" !== typeof value2) {
      return value2;
    }
    if ("number" === typeof format2) {
      return value2;
    }
    format2 = format2 && format2.formatter || format2;
    if ("function" === typeof format2) {
      return format2(value2);
    }
    format2 = this._normalizeFormat(format2);
    if (!format2.type) {
      format2.type = "decimal";
    }
    const numberConfig = this._parseNumberFormatString(format2.type);
    if (!numberConfig) {
      const formatterConfig = this._getSeparators();
      formatterConfig.unlimitedIntegerDigits = format2.unlimitedIntegerDigits;
      return this.convertDigits(getFormatter(format2.type, formatterConfig)(value2));
    }
    return this._formatNumber(value2, numberConfig, format2);
  },
  parse: function(text, format2) {
    if (!text) {
      return;
    }
    if (format2 && format2.parser) {
      return format2.parser(text);
    }
    text = this.convertDigits(text, true);
    if (format2 && "string" !== typeof format2) {
      errors_default.log("W0011");
    }
    const decimalSeparator = this.getDecimalSeparator();
    const regExp = new RegExp("[^0-9" + escapeRegExp(decimalSeparator) + "]", "g");
    const cleanedText = text.replace(regExp, "").replace(decimalSeparator, ".").replace(/\.$/g, "");
    if ("." === cleanedText || "" === cleanedText) {
      return null;
    }
    if (this._calcSignificantDigits(cleanedText) > 15) {
      return NaN;
    }
    let parsed = +cleanedText * this.getSign(text, format2);
    format2 = this._normalizeFormat(format2);
    const formatConfig = this._parseNumberFormatString(format2.type);
    let power = null === formatConfig || void 0 === formatConfig ? void 0 : formatConfig.power;
    if (power) {
      if ("auto" === power) {
        const match2 = text.match(/\d(K|M|B|T)/);
        if (match2) {
          power = Object.keys(LargeNumberFormatPostfixes).find((power2) => LargeNumberFormatPostfixes[power2] === match2[1]);
        }
      }
      parsed *= Math.pow(10, 3 * power);
    }
    if ("percent" === (null === formatConfig || void 0 === formatConfig ? void 0 : formatConfig.formatType)) {
      parsed /= 100;
    }
    return parsed;
  },
  _calcSignificantDigits: function(text) {
    const [integer, fractional] = text.split(".");
    const calcDigitsAfterLeadingZeros = (digits) => {
      let index2 = -1;
      for (let i = 0; i < digits.length; i++) {
        if ("0" !== digits[i]) {
          index2 = i;
          break;
        }
      }
      return index2 > -1 ? digits.length - index2 : 0;
    };
    let result2 = 0;
    if (integer) {
      result2 += calcDigitsAfterLeadingZeros(integer.split(""));
    }
    if (fractional) {
      result2 += calcDigitsAfterLeadingZeros(fractional.split("").reverse());
    }
    return result2;
  }
});
numberLocalization.inject(currency_default);
if (hasIntl) {
  numberLocalization.inject(number_default);
}
var number_default2 = numberLocalization;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_validation_engine.js
var EMAIL_VALIDATION_REGEX = /^[\d\w.+_-]+@[\d\w._-]+\.[\w]+$/i;
var STATUS = {
  valid: "valid",
  invalid: "invalid",
  pending: "pending"
};
var BaseRuleValidator = class {
  constructor() {
    this.NAME = "base";
  }
  defaultMessage(value2) {
    return message_default.getFormatter(`validation-${this.NAME}`)(value2);
  }
  defaultFormattedMessage(value2) {
    return message_default.getFormatter(`validation-${this.NAME}-formatted`)(value2);
  }
  _isValueEmpty(value2) {
    return !rulesValidators.required.validate(value2, {});
  }
  validate(value2, rule) {
    const valueArray = Array.isArray(value2) ? value2 : [value2];
    let result2 = true;
    if (valueArray.length) {
      valueArray.every((itemValue) => {
        result2 = this._validate(itemValue, rule);
        return result2;
      });
    } else {
      result2 = this._validate(null, rule);
    }
    return result2;
  }
};
var RequiredRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "required";
  }
  _validate(value2, rule) {
    if (!isDefined(value2)) {
      return false;
    }
    if (false === value2) {
      return false;
    }
    value2 = String(value2);
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    return "" !== value2;
  }
};
var NumericRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "numeric";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    if (rule.useCultureSettings && isString(value2)) {
      return !isNaN(number_default2.parse(value2));
    }
    return isNumeric(value2);
  }
};
var RangeRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "range";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const validNumber = rulesValidators.numeric.validate(value2, rule);
    const validValue = isDefined(value2) && "" !== value2;
    const number = validNumber ? parseFloat(value2) : validValue && value2.valueOf();
    const {
      min
    } = rule;
    const {
      max
    } = rule;
    if (!(validNumber || isDate(value2)) && !validValue) {
      return false;
    }
    if (isDefined(min)) {
      if (isDefined(max)) {
        return number >= min && number <= max;
      }
      return number >= min;
    }
    if (isDefined(max)) {
      return number <= max;
    }
    throw errors_default.Error("E0101");
  }
};
var StringLengthRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "stringLength";
  }
  _validate(value2, rule) {
    value2 = String(value2 ?? "");
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.range.validate(value2.length, extend({}, rule));
  }
};
var CustomRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "custom";
  }
  validate(value2, rule) {
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
    const extraParams = isFunction(dataGetter) && dataGetter();
    const params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    return rule.validationCallback(params);
  }
};
var AsyncRuleValidator = class extends CustomRuleValidator {
  constructor() {
    super();
    this.NAME = "async";
  }
  validate(value2, rule) {
    if (!isDefined(rule.reevaluate)) {
      extend(rule, {
        reevaluate: true
      });
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
    const extraParams = isFunction(dataGetter) && dataGetter();
    const params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    const callbackResult = rule.validationCallback(params);
    if (!isPromise(callbackResult)) {
      throw errors_default.Error("E0103");
    }
    return this._getWrappedPromise(fromPromise(callbackResult).promise());
  }
  _getWrappedPromise(promise) {
    const deferred = Deferred();
    promise.then((res) => {
      deferred.resolve(res);
    }, (err) => {
      const res = {
        isValid: false
      };
      if (isDefined(err)) {
        if (isString(err)) {
          res.message = err;
        } else if (isObject(err) && isDefined(err.message) && isString(err.message)) {
          res.message = err.message;
        }
      }
      deferred.resolve(res);
    });
    return deferred.promise();
  }
};
var CompareRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "compare";
  }
  _validate(value2, rule) {
    if (!rule.comparisonTarget) {
      throw errors_default.Error("E0102");
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    extend(rule, {
      reevaluate: true
    });
    const otherValue = rule.comparisonTarget();
    const type2 = rule.comparisonType || "==";
    switch (type2) {
      case "==":
        return value2 == otherValue;
      case "!=":
        return value2 != otherValue;
      case "===":
        return value2 === otherValue;
      case "!==":
        return value2 !== otherValue;
      case ">":
        return value2 > otherValue;
      case ">=":
        return value2 >= otherValue;
      case "<":
        return value2 < otherValue;
      case "<=":
        return value2 <= otherValue;
    }
  }
};
var PatternRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "pattern";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    let {
      pattern
    } = rule;
    if (isString(pattern)) {
      pattern = new RegExp(pattern);
    }
    return pattern.test(value2);
  }
};
var EmailRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "email";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.pattern.validate(value2, extend({}, rule, {
      pattern: EMAIL_VALIDATION_REGEX
    }));
  }
};
var rulesValidators = {
  required: new RequiredRuleValidator(),
  numeric: new NumericRuleValidator(),
  range: new RangeRuleValidator(),
  stringLength: new StringLengthRuleValidator(),
  custom: new CustomRuleValidator(),
  async: new AsyncRuleValidator(),
  compare: new CompareRuleValidator(),
  pattern: new PatternRuleValidator(),
  email: new EmailRuleValidator()
};
var GroupConfig = class_default.inherit({
  ctor(group, isRemovable) {
    this.group = group;
    this.validators = [];
    this._isRemovable = isRemovable;
    this._pendingValidators = [];
    this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);
    this._resetValidationInfo();
    this._eventsStrategy = new EventsStrategy(this);
  },
  validate() {
    const result2 = {
      isValid: true,
      brokenRules: [],
      validators: [],
      status: STATUS.valid,
      complete: null
    };
    this._unsubscribeFromAllChangeEvents();
    this._pendingValidators = [];
    this._resetValidationInfo();
    each(this.validators, (_, validator) => {
      const validatorResult = validator.validate();
      result2.isValid = result2.isValid && validatorResult.isValid;
      if (validatorResult.brokenRules) {
        result2.brokenRules = result2.brokenRules.concat(validatorResult.brokenRules);
      }
      result2.validators.push(validator);
      if (validatorResult.status === STATUS.pending) {
        this._addPendingValidator(validator);
      }
      this._subscribeToChangeEvents(validator);
    });
    if (this._pendingValidators.length) {
      result2.status = STATUS.pending;
    } else {
      result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
      this._unsubscribeFromAllChangeEvents();
      this._raiseValidatedEvent(result2);
    }
    this._updateValidationInfo(result2);
    return extend({}, this._validationInfo.result);
  },
  _subscribeToChangeEvents(validator) {
    validator.on("validating", this._onValidatorStatusChanged);
    validator.on("validated", this._onValidatorStatusChanged);
  },
  _unsubscribeFromChangeEvents(validator) {
    validator.off("validating", this._onValidatorStatusChanged);
    validator.off("validated", this._onValidatorStatusChanged);
  },
  _unsubscribeFromAllChangeEvents() {
    each(this.validators, (_, validator) => {
      this._unsubscribeFromChangeEvents(validator);
    });
  },
  _updateValidationInfo(result2) {
    this._validationInfo.result = result2;
    if (result2.status !== STATUS.pending) {
      return;
    }
    if (!this._validationInfo.deferred) {
      this._validationInfo.deferred = Deferred();
      this._validationInfo.result.complete = this._validationInfo.deferred.promise();
    }
  },
  _addPendingValidator(validator) {
    const foundValidator = grep(this._pendingValidators, (val) => val === validator)[0];
    if (!foundValidator) {
      this._pendingValidators.push(validator);
    }
  },
  _removePendingValidator(validator) {
    const index2 = this._pendingValidators.indexOf(validator);
    if (index2 >= 0) {
      this._pendingValidators.splice(index2, 1);
    }
  },
  _orderBrokenRules(brokenRules) {
    let orderedRules = [];
    each(this.validators, (_, validator) => {
      const foundRules = grep(brokenRules, (rule) => rule.validator === validator);
      if (foundRules.length) {
        orderedRules = orderedRules.concat(foundRules);
      }
    });
    return orderedRules;
  },
  _updateBrokenRules(result2) {
    if (!this._validationInfo.result) {
      return;
    }
    let {
      brokenRules
    } = this._validationInfo.result;
    const rules = grep(brokenRules, (rule) => rule.validator !== result2.validator);
    if (result2.brokenRules) {
      brokenRules = rules.concat(result2.brokenRules);
    }
    this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);
  },
  _onValidatorStatusChanged(result2) {
    if (result2.status === STATUS.pending) {
      this._addPendingValidator(result2.validator);
      return;
    }
    this._resolveIfComplete(result2);
  },
  _resolveIfComplete(result2) {
    this._removePendingValidator(result2.validator);
    this._updateBrokenRules(result2);
    if (!this._pendingValidators.length) {
      this._unsubscribeFromAllChangeEvents();
      if (!this._validationInfo.result) {
        return;
      }
      this._validationInfo.result.status = 0 === this._validationInfo.result.brokenRules.length ? STATUS.valid : STATUS.invalid;
      this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;
      const res = extend({}, this._validationInfo.result, {
        complete: null
      });
      const {
        deferred
      } = this._validationInfo;
      this._validationInfo.deferred = null;
      this._raiseValidatedEvent(res);
      deferred && setTimeout(() => {
        deferred.resolve(res);
      });
    }
  },
  _raiseValidatedEvent(result2) {
    this._eventsStrategy.fireEvent("validated", [result2]);
  },
  _resetValidationInfo() {
    this._validationInfo = {
      result: null,
      deferred: null
    };
  },
  _synchronizeValidationInfo() {
    if (this._validationInfo.result) {
      this._validationInfo.result.validators = this.validators;
    }
  },
  removeRegisteredValidator(validator) {
    const index2 = this.validators.indexOf(validator);
    if (index2 > -1) {
      this.validators.splice(index2, 1);
      this._synchronizeValidationInfo();
      this._resolveIfComplete({
        validator
      });
    }
  },
  registerValidator(validator) {
    if (!this.validators.includes(validator)) {
      this.validators.push(validator);
      this._synchronizeValidationInfo();
    }
  },
  reset() {
    each(this.validators, (_, validator) => {
      validator.reset();
    });
    this._pendingValidators = [];
    this._resetValidationInfo();
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
var ValidationEngine = {
  groups: [],
  getGroupConfig(group) {
    const result2 = grep(this.groups, (config3) => config3.group === group);
    if (result2.length) {
      return result2[0];
    }
  },
  findGroup($element, model) {
    var _$element$data;
    const hasValidationGroup = null === (_$element$data = $element.data()) || void 0 === _$element$data || null === (_$element$data = _$element$data.dxComponents) || void 0 === _$element$data ? void 0 : _$element$data.includes("dxValidationGroup");
    const validationGroup = hasValidationGroup && $element.dxValidationGroup("instance");
    if (validationGroup) {
      return validationGroup;
    }
    const $dxGroup = $element.parents(".dx-validationgroup").first();
    if ($dxGroup.length) {
      return $dxGroup.dxValidationGroup("instance");
    }
    return model;
  },
  initGroups() {
    this.groups = [];
    this.addGroup(void 0, false);
  },
  addGroup(group) {
    let isRemovable = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
    let config3 = this.getGroupConfig(group);
    if (!config3) {
      config3 = new GroupConfig(group, isRemovable);
      this.groups.push(config3);
    }
    return config3;
  },
  removeGroup(group) {
    const config3 = this.getGroupConfig(group);
    const index2 = this.groups.indexOf(config3);
    if (index2 > -1) {
      this.groups.splice(index2, 1);
    }
    return config3;
  },
  _setDefaultMessage(info) {
    const {
      rule,
      validator,
      name: name2
    } = info;
    if (!isDefined(rule.message)) {
      if (validator.defaultFormattedMessage && isDefined(name2)) {
        rule.message = validator.defaultFormattedMessage(name2);
      } else {
        rule.message = validator.defaultMessage();
      }
    }
  },
  _addBrokenRule(info) {
    const {
      result: result2,
      rule
    } = info;
    if (!result2.brokenRule) {
      result2.brokenRule = rule;
    }
    if (!result2.brokenRules) {
      result2.brokenRules = [];
    }
    result2.brokenRules.push(rule);
  },
  validate(value2, rules, name2) {
    var _rules$;
    let result2 = {
      name: name2,
      value: value2,
      brokenRule: null,
      brokenRules: null,
      isValid: true,
      validationRules: rules,
      pendingRules: null,
      status: STATUS.valid,
      complete: null
    };
    const validator = null === rules || void 0 === rules || null === (_rules$ = rules[0]) || void 0 === _rules$ ? void 0 : _rules$.validator;
    const asyncRuleItems = [];
    each(rules || [], (_, rule) => {
      const ruleValidator = rulesValidators[rule.type];
      let ruleValidationResult;
      if (ruleValidator) {
        if (isDefined(rule.isValid) && rule.value === value2 && !rule.reevaluate) {
          if (!rule.isValid) {
            result2.isValid = false;
            this._addBrokenRule({
              result: result2,
              rule
            });
            return false;
          }
          return true;
        }
        rule.value = value2;
        if ("async" === rule.type) {
          asyncRuleItems.push({
            rule,
            ruleValidator
          });
          return true;
        }
        ruleValidationResult = ruleValidator.validate(value2, rule);
        rule.isValid = ruleValidationResult;
        if (!ruleValidationResult) {
          result2.isValid = false;
          this._setDefaultMessage({
            rule,
            validator: ruleValidator,
            name: name2
          });
          this._addBrokenRule({
            result: result2,
            rule
          });
        }
        if (!rule.isValid) {
          return false;
        }
      } else {
        throw errors_default.Error("E0100");
      }
    });
    if (result2.isValid && !result2.brokenRules && asyncRuleItems.length) {
      result2 = this._validateAsyncRules({
        value: value2,
        items: asyncRuleItems,
        result: result2,
        name: name2
      });
    }
    this._synchronizeGroupValidationInfo(validator, result2);
    result2.status = result2.pendingRules ? STATUS.pending : result2.isValid ? STATUS.valid : STATUS.invalid;
    return result2;
  },
  _synchronizeGroupValidationInfo(validator, result2) {
    if (!validator) {
      return;
    }
    const groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);
    groupConfig._updateBrokenRules.call(groupConfig, {
      validator,
      brokenRules: result2.brokenRules ?? []
    });
  },
  _validateAsyncRules(_ref) {
    let {
      result: result2,
      value: value2,
      items,
      name: name2
    } = _ref;
    const asyncResults = [];
    each(items, (_, item) => {
      const validateResult = item.ruleValidator.validate(value2, item.rule);
      if (!isPromise(validateResult)) {
        this._updateRuleConfig({
          rule: item.rule,
          ruleResult: this._getPatchedRuleResult(validateResult),
          validator: item.ruleValidator,
          name: name2
        });
      } else {
        if (!result2.pendingRules) {
          result2.pendingRules = [];
        }
        result2.pendingRules.push(item.rule);
        const asyncResult = validateResult.then((res) => {
          const ruleResult = this._getPatchedRuleResult(res);
          this._updateRuleConfig({
            rule: item.rule,
            ruleResult,
            validator: item.ruleValidator,
            name: name2
          });
          return ruleResult;
        });
        asyncResults.push(asyncResult);
      }
    });
    if (asyncResults.length) {
      result2.complete = Promise.all(asyncResults).then((values) => this._getAsyncRulesResult({
        result: result2,
        values
      }));
    }
    return result2;
  },
  _updateRuleConfig(_ref2) {
    let {
      rule,
      ruleResult,
      validator,
      name: name2
    } = _ref2;
    rule.isValid = ruleResult.isValid;
    if (!ruleResult.isValid) {
      if (isDefined(ruleResult.message) && isString(ruleResult.message) && ruleResult.message.length) {
        rule.message = ruleResult.message;
      } else {
        this._setDefaultMessage({
          rule,
          validator,
          name: name2
        });
      }
    }
  },
  _getPatchedRuleResult(ruleResult) {
    let result2;
    if (isObject(ruleResult)) {
      result2 = extend({}, ruleResult);
      if (!isDefined(result2.isValid)) {
        result2.isValid = true;
      }
    } else {
      result2 = {
        isValid: isBoolean(ruleResult) ? ruleResult : true
      };
    }
    return result2;
  },
  _getAsyncRulesResult(_ref3) {
    let {
      values,
      result: result2
    } = _ref3;
    each(values, (index2, val) => {
      if (false === val.isValid) {
        result2.isValid = val.isValid;
        const rule = result2.pendingRules[index2];
        this._addBrokenRule({
          result: result2,
          rule
        });
      }
    });
    result2.pendingRules = null;
    result2.complete = null;
    result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
    return result2;
  },
  registerValidatorInGroup(group, validator) {
    const groupConfig = ValidationEngine.addGroup(group);
    groupConfig.registerValidator.call(groupConfig, validator);
  },
  removeRegisteredValidator(group, validator) {
    const config3 = ValidationEngine.getGroupConfig(group);
    if (config3) {
      config3.removeRegisteredValidator.call(config3, validator);
      const validatorsInGroup = config3.validators;
      const isRemovable = config3._isRemovable;
      const shouldRemoveGroup = 0 === validatorsInGroup.length && isRemovable;
      if (shouldRemoveGroup) {
        this.removeGroup(group);
      }
    }
  },
  initValidationOptions(options2) {
    const initedOptions = {};
    if (options2) {
      const syncOptions = ["isValid", "validationStatus", "validationError", "validationErrors"];
      syncOptions.forEach((prop) => {
        if (prop in options2) {
          extend(initedOptions, this.synchronizeValidationOptions({
            name: prop,
            value: options2[prop]
          }, options2));
        }
      });
    }
    return initedOptions;
  },
  synchronizeValidationOptions(_ref4, options2) {
    let {
      name: name2,
      value: value2
    } = _ref4;
    switch (name2) {
      case "validationStatus": {
        const isValid = value2 === STATUS.valid || value2 === STATUS.pending;
        return options2.isValid !== isValid ? {
          isValid
        } : {};
      }
      case "isValid": {
        const {
          validationStatus
        } = options2;
        let newStatus = validationStatus;
        if (value2 && validationStatus === STATUS.invalid) {
          newStatus = STATUS.valid;
        } else if (!value2 && validationStatus !== STATUS.invalid) {
          newStatus = STATUS.invalid;
        }
        return newStatus !== validationStatus ? {
          validationStatus: newStatus
        } : {};
      }
      case "validationErrors": {
        const validationError = !value2 || !value2.length ? null : value2[0];
        return options2.validationError !== validationError ? {
          validationError
        } : {};
      }
      case "validationError": {
        const {
          validationErrors
        } = options2;
        if (!value2 && validationErrors) {
          return {
            validationErrors: null
          };
        }
        if (value2 && !validationErrors) {
          return {
            validationErrors: [value2]
          };
        }
        if (value2 && validationErrors && value2 !== validationErrors[0]) {
          validationErrors[0] = value2;
          return {
            validationErrors: validationErrors.slice()
          };
        }
      }
    }
    return {};
  },
  validateGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors_default.Error("E0110");
    }
    return groupConfig.validate();
  },
  resetGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors_default.Error("E0110");
    }
    return groupConfig.reset();
  }
};
ValidationEngine.initGroups();
var m_validation_engine_default = ValidationEngine;

// ../../../../../../node_modules/devextreme/esm/ui/validation_engine.js
var validation_engine_default = m_validation_engine_default;

// ../../../../../../node_modules/devextreme/esm/core/utils/position.js
var getDefaultAlignment = (isRtlEnabled) => {
  const rtlEnabled = isRtlEnabled ?? config_default().rtlEnabled;
  return rtlEnabled ? "right" : "left";
};
var getBoundingRect = (element) => {
  if (isWindow(element)) {
    return {
      width: element.outerWidth,
      height: element.outerHeight
    };
  }
  return element.getBoundingClientRect();
};

// ../../../../../../node_modules/devextreme/esm/core/element.js
function getPublicElementNonJquery(element) {
  if (element && element.get) {
    return element.get(0);
  }
  return element;
}
var strategy2 = getPublicElementNonJquery;
function getPublicElement(element) {
  return strategy2(element);
}

// ../../../../../../node_modules/devextreme/esm/animation/translator.js
var TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/;
var TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
var locate = function($element) {
  $element = renderer_default($element);
  const translate = getTranslate($element);
  return {
    left: translate.x,
    top: translate.y
  };
};
function isPercentValue(value2) {
  return "string" === type(value2) && "%" === value2[value2.length - 1];
}
function cacheTranslate($element, translate) {
  if ($element.length) {
    data($element.get(0), "dxTranslator", translate);
  }
}
var clearCache = function($element) {
  if ($element.length) {
    removeData($element.get(0), "dxTranslator");
  }
};
var getTranslateCss = function(translate) {
  translate.x = translate.x || 0;
  translate.y = translate.y || 0;
  const xValueString = isPercentValue(translate.x) ? translate.x : translate.x + "px";
  const yValueString = isPercentValue(translate.y) ? translate.y : translate.y + "px";
  return "translate(" + xValueString + ", " + yValueString + ")";
};
var getTranslate = function($element) {
  let result2 = $element.length ? data($element.get(0), "dxTranslator") : null;
  if (!result2) {
    const transformValue = $element.css("transform") || getTranslateCss({
      x: 0,
      y: 0
    });
    let matrix = transformValue.match(TRANSFORM_MATRIX_REGEX);
    const is3D = matrix && matrix[1];
    if (matrix) {
      matrix = matrix[2].split(",");
      if ("3d" === is3D) {
        matrix = matrix.slice(12, 15);
      } else {
        matrix.push(0);
        matrix = matrix.slice(4, 7);
      }
    } else {
      matrix = [0, 0, 0];
    }
    result2 = {
      x: parseFloat(matrix[0]),
      y: parseFloat(matrix[1]),
      z: parseFloat(matrix[2])
    };
    cacheTranslate($element, result2);
  }
  return result2;
};
var move = function($element, position3) {
  $element = renderer_default($element);
  const left = position3.left;
  const top = position3.top;
  let translate;
  if (void 0 === left) {
    translate = getTranslate($element);
    translate.y = top || 0;
  } else if (void 0 === top) {
    translate = getTranslate($element);
    translate.x = left || 0;
  } else {
    translate = {
      x: left || 0,
      y: top || 0,
      z: 0
    };
    cacheTranslate($element, translate);
  }
  $element.css({
    transform: getTranslateCss(translate)
  });
  if (isPercentValue(left) || isPercentValue(top)) {
    clearCache($element);
  }
};
var resetPosition = function($element, finishTransition) {
  $element = renderer_default($element);
  let originalTransition;
  const stylesConfig = {
    left: 0,
    top: 0,
    transform: "none"
  };
  if (finishTransition) {
    originalTransition = $element.css("transition");
    stylesConfig.transition = "none";
  }
  $element.css(stylesConfig);
  clearCache($element);
  if (finishTransition) {
    $element.get(0).offsetHeight;
    $element.css("transition", originalTransition);
  }
};
var parseTranslate = function(translateString) {
  let result2 = translateString.match(TRANSLATE_REGEX);
  if (!result2 || !result2[1]) {
    return;
  }
  result2 = result2[1].split(",");
  result2 = {
    x: parseFloat(result2[0]),
    y: parseFloat(result2[1]),
    z: parseFloat(result2[2])
  };
  return result2;
};

// ../../../../../../node_modules/devextreme/esm/animation/easing.js
var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/;
var TransitionTimingFuncMap = {
  linear: "cubic-bezier(0, 0, 1, 1)",
  swing: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
  ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
  "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
  "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
};
var polynomBezier = function(x1, y1, x2, y2) {
  const Cx = 3 * x1;
  const Bx = 3 * (x2 - x1) - Cx;
  const Ax = 1 - Cx - Bx;
  const Cy = 3 * y1;
  const By = 3 * (y2 - y1) - Cy;
  const Ay = 1 - Cy - By;
  const bezierX = function(t) {
    return t * (Cx + t * (Bx + t * Ax));
  };
  const derivativeX = function(t) {
    return Cx + t * (2 * Bx + 3 * t * Ax);
  };
  return function(t) {
    return function(t2) {
      return t2 * (Cy + t2 * (By + t2 * Ay));
    }(function(t2) {
      let x = t2;
      let i = 0;
      let z;
      while (i < 14) {
        z = bezierX(x) - t2;
        if (Math.abs(z) < 1e-3) {
          break;
        }
        x -= z / derivativeX(x);
        i++;
      }
      return x;
    }(t));
  };
};
var easing = {};
var convertTransitionTimingFuncToEasing = function(cssTransitionEasing) {
  cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
  let coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
  let forceName;
  if (!coeffs) {
    forceName = "linear";
    coeffs = TransitionTimingFuncMap[forceName].match(CSS_TRANSITION_EASING_REGEX);
  }
  coeffs = coeffs.slice(1, 5);
  for (let i = 0; i < coeffs.length; i++) {
    coeffs[i] = parseFloat(coeffs[i]);
  }
  const easingName = forceName || "cubicbezier_" + coeffs.join("_").replace(/\./g, "p");
  if (!isFunction(easing[easingName])) {
    easing[easingName] = function(x, t, b, c, d) {
      return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b;
    };
  }
  return easingName;
};
function getEasing(name2) {
  return easing[name2];
}

// ../../../../../../node_modules/devextreme/esm/animation/frame.js
var window9 = hasWindow() ? getWindow() : {};
var FRAME_ANIMATION_STEP_TIME = 1e3 / 60;
var request = function(callback) {
  return setTimeout(callback, 16.666666666666668);
};
var cancel = function(requestID) {
  clearTimeout(requestID);
};
var setAnimationFrameMethods = call_once_default(function() {
  const nativeRequest = window9.requestAnimationFrame || window9.webkitRequestAnimationFrame || window9.mozRequestAnimationFrame || window9.oRequestAnimationFrame || window9.msRequestAnimationFrame;
  const nativeCancel = window9.cancelAnimationFrame || window9.webkitCancelAnimationFrame || window9.mozCancelAnimationFrame || window9.oCancelAnimationFrame || window9.msCancelAnimationFrame;
  if (nativeRequest && nativeCancel) {
    request = nativeRequest;
    cancel = nativeCancel;
  }
});
function requestAnimationFrame() {
  setAnimationFrameMethods();
  return request.apply(window9, arguments);
}
function cancelAnimationFrame() {
  setAnimationFrameMethods();
  cancel.apply(window9, arguments);
}

// ../../../../../../node_modules/devextreme/esm/animation/position.js
var window10 = getWindow();
var horzRe = /left|right/;
var vertRe = /top|bottom/;
var collisionRe = /fit|flip|none/;
var scaleRe = /scale\(.+?\)/;
var IS_SAFARI = browser_default.safari;
var normalizeAlign = function(raw) {
  const result2 = {
    h: "center",
    v: "center"
  };
  const pair = splitPair(raw);
  if (pair) {
    each(pair, function() {
      const w = String(this).toLowerCase();
      if (horzRe.test(w)) {
        result2.h = w;
      } else if (vertRe.test(w)) {
        result2.v = w;
      }
    });
  }
  return result2;
};
var normalizeOffset = function(raw, preventRound) {
  return pairToObject(raw, preventRound);
};
var normalizeCollision = function(raw) {
  const pair = splitPair(raw);
  let h2 = String(pair && pair[0]).toLowerCase();
  let v = String(pair && pair[1]).toLowerCase();
  if (!collisionRe.test(h2)) {
    h2 = "none";
  }
  if (!collisionRe.test(v)) {
    v = h2;
  }
  return {
    h: h2,
    v
  };
};
var getAlignFactor = function(align) {
  switch (align) {
    case "center":
      return 0.5;
    case "right":
    case "bottom":
      return 1;
    default:
      return 0;
  }
};
var inverseAlign = function(align) {
  switch (align) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    default:
      return align;
  }
};
var calculateOversize = function(data2, bounds) {
  let oversize = 0;
  if (data2.myLocation < bounds.min) {
    oversize += bounds.min - data2.myLocation;
  }
  if (data2.myLocation > bounds.max) {
    oversize += data2.myLocation - bounds.max;
  }
  return oversize;
};
var collisionSide = function(direction, data2, bounds) {
  if (data2.myLocation < bounds.min) {
    return "h" === direction ? "left" : "top";
  }
  if (data2.myLocation > bounds.max) {
    return "h" === direction ? "right" : "bottom";
  }
  return "none";
};
var initMyLocation = function(data2) {
  data2.myLocation = data2.atLocation + getAlignFactor(data2.atAlign) * data2.atSize - getAlignFactor(data2.myAlign) * data2.mySize + data2.offset;
};
var collisionResolvers = {
  fit: function(data2, bounds) {
    let result2 = false;
    if (data2.myLocation > bounds.max) {
      data2.myLocation = bounds.max;
      result2 = true;
    }
    if (data2.myLocation < bounds.min) {
      data2.myLocation = bounds.min;
      result2 = true;
    }
    data2.fit = result2;
  },
  flip: function(data2, bounds) {
    data2.flip = false;
    if ("center" === data2.myAlign && "center" === data2.atAlign) {
      return;
    }
    if (data2.myLocation < bounds.min || data2.myLocation > bounds.max) {
      const inverseData = extend({}, data2, {
        myAlign: inverseAlign(data2.myAlign),
        atAlign: inverseAlign(data2.atAlign),
        offset: -data2.offset
      });
      initMyLocation(inverseData);
      inverseData.oversize = calculateOversize(inverseData, bounds);
      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data2.oversize > inverseData.oversize) {
        data2.myLocation = inverseData.myLocation;
        data2.oversize = inverseData.oversize;
        data2.flip = true;
      }
    }
  },
  flipfit: function(data2, bounds) {
    this.flip(data2, bounds);
    this.fit(data2, bounds);
  },
  none: function(data2) {
    data2.oversize = 0;
  }
};
var scrollbarWidth;
var calculateScrollbarWidth = function() {
  const $scrollDiv = renderer_default("<div>").css({
    width: 100,
    height: 100,
    overflow: "scroll",
    position: "absolute",
    top: -9999
  }).appendTo(renderer_default("body"));
  const result2 = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
  $scrollDiv.remove();
  scrollbarWidth = result2;
};
var defaultPositionResult = {
  h: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  },
  v: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  }
};
var calculatePosition = function(what, options2) {
  const $what = renderer_default(what);
  const currentOffset = $what.offset();
  const result2 = extend(true, {}, defaultPositionResult, {
    h: {
      location: currentOffset.left
    },
    v: {
      location: currentOffset.top
    }
  });
  if (!options2) {
    return result2;
  }
  const my = normalizeAlign(options2.my);
  const at = normalizeAlign(options2.at);
  let of = renderer_default(options2.of).length && options2.of || window10;
  const offset2 = normalizeOffset(options2.offset, options2.precise);
  const collision = normalizeCollision(options2.collision);
  const boundary = options2.boundary;
  const boundaryOffset = normalizeOffset(options2.boundaryOffset, options2.precise);
  const h2 = {
    mySize: getOuterWidth($what),
    myAlign: my.h,
    atAlign: at.h,
    offset: offset2.h,
    collision: collision.h,
    boundaryOffset: boundaryOffset.h
  };
  const v = {
    mySize: getOuterHeight($what),
    myAlign: my.v,
    atAlign: at.v,
    offset: offset2.v,
    collision: collision.v,
    boundaryOffset: boundaryOffset.v
  };
  if (of.preventDefault) {
    h2.atLocation = of.pageX;
    v.atLocation = of.pageY;
    h2.atSize = 0;
    v.atSize = 0;
  } else {
    of = renderer_default(of);
    if (isWindow(of[0])) {
      h2.atLocation = of.scrollLeft();
      v.atLocation = of.scrollTop();
      if ("phone" === devices_default.real().deviceType && of[0].visualViewport) {
        h2.atLocation = Math.max(h2.atLocation, of[0].visualViewport.offsetLeft);
        v.atLocation = Math.max(v.atLocation, of[0].visualViewport.offsetTop);
        h2.atSize = of[0].visualViewport.width;
        v.atSize = of[0].visualViewport.height;
      } else {
        h2.atSize = of[0].innerWidth > of[0].outerWidth ? of[0].innerWidth : getWidth(of);
        v.atSize = of[0].innerHeight > of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : getHeight(of);
      }
    } else if (9 === of[0].nodeType) {
      h2.atLocation = 0;
      v.atLocation = 0;
      h2.atSize = getWidth(of);
      v.atSize = getHeight(of);
    } else {
      const ofRect = getBoundingRect(of.get(0));
      const o = getOffsetWithoutScale(of);
      h2.atLocation = o.left;
      v.atLocation = o.top;
      h2.atSize = Math.max(ofRect.width, getOuterWidth(of));
      v.atSize = Math.max(ofRect.height, getOuterHeight(of));
    }
  }
  initMyLocation(h2);
  initMyLocation(v);
  const bounds = function() {
    const win = renderer_default(window10);
    const windowWidth = getWidth(win);
    const windowHeight = getHeight(win);
    let left = win.scrollLeft();
    let top = win.scrollTop();
    const documentElement = dom_adapter_default.getDocumentElement();
    const hZoomLevel = touch ? documentElement.clientWidth / windowWidth : 1;
    const vZoomLevel = touch ? documentElement.clientHeight / windowHeight : 1;
    if (void 0 === scrollbarWidth) {
      calculateScrollbarWidth();
    }
    let boundaryWidth = windowWidth;
    let boundaryHeight = windowHeight;
    if (boundary && !isWindow(boundary)) {
      const $boundary = renderer_default(boundary);
      const boundaryPosition = $boundary.offset();
      left = boundaryPosition.left;
      top = boundaryPosition.top;
      boundaryWidth = getWidth($boundary);
      boundaryHeight = getHeight($boundary);
    }
    return {
      h: {
        min: left + h2.boundaryOffset,
        max: left + boundaryWidth / hZoomLevel - h2.mySize - h2.boundaryOffset
      },
      v: {
        min: top + v.boundaryOffset,
        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
      }
    };
  }();
  h2.oversize = calculateOversize(h2, bounds.h);
  v.oversize = calculateOversize(v, bounds.v);
  h2.collisionSide = collisionSide("h", h2, bounds.h);
  v.collisionSide = collisionSide("v", v, bounds.v);
  if (collisionResolvers[h2.collision]) {
    collisionResolvers[h2.collision](h2, bounds.h);
  }
  if (collisionResolvers[v.collision]) {
    collisionResolvers[v.collision](v, bounds.v);
  }
  const preciser = function(number) {
    return options2.precise ? number : Math.round(number);
  };
  extend(true, result2, {
    h: {
      location: preciser(h2.myLocation),
      oversize: preciser(h2.oversize),
      fit: h2.fit,
      flip: h2.flip,
      collisionSide: h2.collisionSide
    },
    v: {
      location: preciser(v.myLocation),
      oversize: preciser(v.oversize),
      fit: v.fit,
      flip: v.flip,
      collisionSide: v.collisionSide
    },
    precise: options2.precise
  });
  return result2;
};
var setScaleProperty = function(element, scale, styleAttr, isEmpty2) {
  const stylePropIsValid = isDefined(element.style) && !dom_adapter_default.isNode(element.style);
  const newStyleValue = isEmpty2 ? styleAttr.replace(scale, "") : styleAttr;
  if (stylePropIsValid) {
    setStyle(element, newStyleValue, false);
  } else {
    const styleAttributeNode = dom_adapter_default.createAttribute("style");
    styleAttributeNode.value = newStyleValue;
    element.setAttributeNode(styleAttributeNode);
  }
};
var getOffsetWithoutScale = function($startElement) {
  var _currentElement$getAt, _style$match;
  let $currentElement = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : $startElement;
  const currentElement = $currentElement.get(0);
  if (!currentElement) {
    return $startElement.offset();
  }
  const style = (null === (_currentElement$getAt = currentElement.getAttribute) || void 0 === _currentElement$getAt ? void 0 : _currentElement$getAt.call(currentElement, "style")) || "";
  const scale = null === (_style$match = style.match(scaleRe)) || void 0 === _style$match ? void 0 : _style$match[0];
  let offset2;
  if (scale) {
    setScaleProperty(currentElement, scale, style, true);
    offset2 = getOffsetWithoutScale($startElement, $currentElement.parent());
    setScaleProperty(currentElement, scale, style, false);
  } else {
    offset2 = getOffsetWithoutScale($startElement, $currentElement.parent());
  }
  return offset2;
};
var position = function(what, options2) {
  const $what = renderer_default(what);
  if (!options2) {
    return $what.offset();
  }
  resetPosition($what, true);
  const offset2 = getOffsetWithoutScale($what);
  const targetPosition = options2.h && options2.v ? options2 : calculatePosition($what, options2);
  const preciser = function(number) {
    return options2.precise ? number : Math.round(number);
  };
  move($what, {
    left: targetPosition.h.location - preciser(offset2.left),
    top: targetPosition.v.location - preciser(offset2.top)
  });
  return targetPosition;
};
var offset = function(element) {
  element = renderer_default(element).get(0);
  if (isWindow(element)) {
    return null;
  } else if (element && "pageY" in element && "pageX" in element) {
    return {
      top: element.pageY,
      left: element.pageX
    };
  }
  return renderer_default(element).offset();
};
if (!position.inverseAlign) {
  position.inverseAlign = inverseAlign;
}
if (!position.normalizeAlign) {
  position.normalizeAlign = normalizeAlign;
}
var position_default = {
  calculateScrollbarWidth,
  calculate: calculatePosition,
  setup: position,
  offset
};

// ../../../../../../node_modules/devextreme/esm/animation/fx.js
var window11 = getWindow();
var removeEventName = addNamespace2(removeEvent, "dxFX");
var RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;
var ANIM_DATA_KEY = "dxAnimData";
var ANIM_QUEUE_KEY = "dxAnimQueue";
var TransitionAnimationStrategy = {
  initAnimation: function($element, config3) {
    $element.css({
      transitionProperty: "none"
    });
    if ("string" === typeof config3.from) {
      $element.addClass(config3.from);
    } else {
      setProps($element, config3.from);
    }
    const that = this;
    const deferred = new Deferred();
    const cleanupWhen = config3.cleanupWhen;
    config3.transitionAnimation = {
      deferred,
      finish: function() {
        that._finishTransition($element);
        if (cleanupWhen) {
          when(deferred, cleanupWhen).always(function() {
            that._cleanup($element, config3);
          });
        } else {
          that._cleanup($element, config3);
        }
        deferred.resolveWith($element, [config3, $element]);
      }
    };
    this._completeAnimationCallback($element, config3).done(function() {
      config3.transitionAnimation.finish();
    }).fail(function() {
      deferred.rejectWith($element, [config3, $element]);
    });
    if (!config3.duration) {
      config3.transitionAnimation.finish();
    }
    $element.css("transform");
  },
  animate: function($element, config3) {
    this._startAnimation($element, config3);
    return config3.transitionAnimation.deferred.promise();
  },
  _completeAnimationCallback: function($element, config3) {
    const that = this;
    const startTime = Date.now() + config3.delay;
    const deferred = new Deferred();
    const transitionEndFired = new Deferred();
    const simulatedTransitionEndFired = new Deferred();
    let simulatedEndEventTimer;
    const transitionEndEventFullName = transitionEndEventName() + ".dxFX";
    config3.transitionAnimation.cleanup = function() {
      clearTimeout(simulatedEndEventTimer);
      clearTimeout(waitForJSCompleteTimer);
      events_engine_default.off($element, transitionEndEventFullName);
      events_engine_default.off($element, removeEventName);
    };
    events_engine_default.one($element, transitionEndEventFullName, function() {
      if (Date.now() - startTime >= config3.duration) {
        transitionEndFired.reject();
      }
    });
    events_engine_default.off($element, removeEventName);
    events_engine_default.on($element, removeEventName, function() {
      that.stop($element, config3);
      deferred.reject();
    });
    const waitForJSCompleteTimer = setTimeout(function() {
      simulatedEndEventTimer = setTimeout(function() {
        simulatedTransitionEndFired.reject();
      }, config3.duration + config3.delay + fx._simulatedTransitionEndDelay);
      when(transitionEndFired, simulatedTransitionEndFired).fail((function() {
        deferred.resolve();
      }).bind(this));
    });
    return deferred.promise();
  },
  _startAnimation: function($element, config3) {
    $element.css({
      transitionProperty: "all",
      transitionDelay: config3.delay + "ms",
      transitionDuration: config3.duration + "ms",
      transitionTimingFunction: config3.easing
    });
    if ("string" === typeof config3.to) {
      $element[0].className += " " + config3.to;
    } else if (config3.to) {
      setProps($element, config3.to);
    }
  },
  _finishTransition: function($element) {
    $element.css("transition", "none");
  },
  _cleanup: function($element, config3) {
    config3.transitionAnimation.cleanup();
    if ("string" === typeof config3.from) {
      $element.removeClass(config3.from);
      $element.removeClass(config3.to);
    }
  },
  stop: function($element, config3, jumpToEnd) {
    if (!config3) {
      return;
    }
    if (jumpToEnd) {
      config3.transitionAnimation.finish();
    } else {
      if (isPlainObject(config3.to)) {
        each(config3.to, function(key) {
          $element.css(key, $element.css(key));
        });
      }
      this._finishTransition($element);
      this._cleanup($element, config3);
    }
  }
};
var FrameAnimationStrategy = {
  initAnimation: function($element, config3) {
    setProps($element, config3.from);
  },
  animate: function($element, config3) {
    const deferred = new Deferred();
    const that = this;
    if (!config3) {
      return deferred.reject().promise();
    }
    each(config3.to, function(prop) {
      if (void 0 === config3.from[prop]) {
        config3.from[prop] = that._normalizeValue($element.css(prop));
      }
    });
    if (config3.to.transform) {
      config3.from.transform = that._parseTransform(config3.from.transform);
      config3.to.transform = that._parseTransform(config3.to.transform);
    }
    config3.frameAnimation = {
      to: config3.to,
      from: config3.from,
      currentValue: config3.from,
      easing: convertTransitionTimingFuncToEasing(config3.easing),
      duration: config3.duration,
      startTime: (/* @__PURE__ */ new Date()).valueOf(),
      finish: function() {
        this.currentValue = this.to;
        this.draw();
        cancelAnimationFrame(config3.frameAnimation.animationFrameId);
        deferred.resolve();
      },
      draw: function() {
        if (config3.draw) {
          config3.draw(this.currentValue);
          return;
        }
        const currentValue = extend({}, this.currentValue);
        if (currentValue.transform) {
          currentValue.transform = map(currentValue.transform, function(value2, prop) {
            if ("translate" === prop) {
              return getTranslateCss(value2);
            } else if ("scale" === prop) {
              return "scale(" + value2 + ")";
            } else if ("rotate" === prop.substr(0, prop.length - 1)) {
              return prop + "(" + value2 + "deg)";
            }
          }).join(" ");
        }
        $element.css(currentValue);
      }
    };
    if (config3.delay) {
      config3.frameAnimation.startTime += config3.delay;
      config3.frameAnimation.delayTimeout = setTimeout(function() {
        that._startAnimation($element, config3);
      }, config3.delay);
    } else {
      that._startAnimation($element, config3);
    }
    return deferred.promise();
  },
  _startAnimation: function($element, config3) {
    events_engine_default.off($element, removeEventName);
    events_engine_default.on($element, removeEventName, function() {
      if (config3.frameAnimation) {
        cancelAnimationFrame(config3.frameAnimation.animationFrameId);
      }
    });
    this._animationStep($element, config3);
  },
  _parseTransform: function(transformString) {
    const result2 = {};
    each(transformString.match(/\w+\d*\w*\([^)]*\)\s*/g), function(i, part) {
      const translateData = parseTranslate(part);
      const scaleData = part.match(/scale\((.+?)\)/);
      const rotateData = part.match(/(rotate.)\((.+)deg\)/);
      if (translateData) {
        result2.translate = translateData;
      }
      if (scaleData && scaleData[1]) {
        result2.scale = parseFloat(scaleData[1]);
      }
      if (rotateData && rotateData[1]) {
        result2[rotateData[1]] = parseFloat(rotateData[2]);
      }
    });
    return result2;
  },
  stop: function($element, config3, jumpToEnd) {
    const frameAnimation = config3 && config3.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    cancelAnimationFrame(frameAnimation.animationFrameId);
    clearTimeout(frameAnimation.delayTimeout);
    if (jumpToEnd) {
      frameAnimation.finish();
    }
    delete config3.frameAnimation;
  },
  _animationStep: function($element, config3) {
    const frameAnimation = config3 && config3.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    const now = (/* @__PURE__ */ new Date()).valueOf();
    if (now >= frameAnimation.startTime + frameAnimation.duration) {
      frameAnimation.finish();
      return;
    }
    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
    frameAnimation.draw();
    const that = this;
    frameAnimation.animationFrameId = requestAnimationFrame(function() {
      that._animationStep($element, config3);
    });
  },
  _calcStepValue: function(frameAnimation, currentDuration) {
    const calcValueRecursively = function(from, to) {
      const result2 = Array.isArray(to) ? [] : {};
      each(to, function(propName, endPropValue) {
        if ("string" === typeof endPropValue && false === parseFloat(endPropValue)) {
          return true;
        }
        result2[propName] = "object" === typeof endPropValue ? calcValueRecursively(from[propName], endPropValue) : function(propName2) {
          const x = currentDuration / frameAnimation.duration;
          const t = currentDuration;
          const b = 1 * from[propName2];
          const c = to[propName2] - from[propName2];
          const d = frameAnimation.duration;
          return getEasing(frameAnimation.easing)(x, t, b, c, d);
        }(propName);
      });
      return result2;
    };
    return calcValueRecursively(frameAnimation.from, frameAnimation.to);
  },
  _normalizeValue: function(value2) {
    const numericValue = parseFloat(value2);
    if (false === numericValue) {
      return value2;
    }
    return numericValue;
  }
};
var FallbackToNoAnimationStrategy = {
  initAnimation: function() {
  },
  animate: function() {
    return new Deferred().resolve().promise();
  },
  stop: noop2,
  isSynchronous: true
};
var getAnimationStrategy = function(config3) {
  config3 = config3 || {};
  const animationStrategies = {
    transition: transition() ? TransitionAnimationStrategy : FrameAnimationStrategy,
    frame: FrameAnimationStrategy,
    noAnimation: FallbackToNoAnimationStrategy
  };
  let strategy4 = config3.strategy || "transition";
  if ("css" === config3.type && !transition()) {
    strategy4 = "noAnimation";
  }
  return animationStrategies[strategy4];
};
var baseConfigValidator = function(config3, animationType, validate, typeMessage) {
  each(["from", "to"], function() {
    if (!validate(config3[this])) {
      throw errors_default.Error("E0010", animationType, this, typeMessage);
    }
  });
};
var isObjectConfigValidator = function(config3, animationType) {
  return baseConfigValidator(config3, animationType, function(target) {
    return isPlainObject(target);
  }, "a plain object");
};
var isStringConfigValidator = function(config3, animationType) {
  return baseConfigValidator(config3, animationType, function(target) {
    return "string" === typeof target;
  }, "a string");
};
var CustomAnimationConfigurator = {
  setup: function() {
  }
};
var CssAnimationConfigurator = {
  validateConfig: function(config3) {
    isStringConfigValidator(config3, "css");
  },
  setup: function() {
  }
};
var positionAliases = {
  top: {
    my: "bottom center",
    at: "top center"
  },
  bottom: {
    my: "top center",
    at: "bottom center"
  },
  right: {
    my: "left center",
    at: "right center"
  },
  left: {
    my: "right center",
    at: "left center"
  }
};
var SlideAnimationConfigurator = {
  validateConfig: function(config3) {
    isObjectConfigValidator(config3, "slide");
  },
  setup: function($element, config3) {
    const location = locate($element);
    if ("slide" !== config3.type) {
      const positioningConfig = "slideIn" === config3.type ? config3.from : config3.to;
      positioningConfig.position = extend({
        of: window11
      }, positionAliases[config3.direction]);
      setupPosition($element, positioningConfig);
    }
    this._setUpConfig(location, config3.from);
    this._setUpConfig(location, config3.to);
    clearCache($element);
  },
  _setUpConfig: function(location, config3) {
    config3.left = "left" in config3 ? config3.left : "+=0";
    config3.top = "top" in config3 ? config3.top : "+=0";
    this._initNewPosition(location, config3);
  },
  _initNewPosition: function(location, config3) {
    const position3 = {
      left: config3.left,
      top: config3.top
    };
    delete config3.left;
    delete config3.top;
    let relativeValue = this._getRelativeValue(position3.left);
    if (void 0 !== relativeValue) {
      position3.left = relativeValue + location.left;
    } else {
      config3.left = 0;
    }
    relativeValue = this._getRelativeValue(position3.top);
    if (void 0 !== relativeValue) {
      position3.top = relativeValue + location.top;
    } else {
      config3.top = 0;
    }
    config3.transform = getTranslateCss({
      x: position3.left,
      y: position3.top
    });
  },
  _getRelativeValue: function(value2) {
    let relativeValue;
    if ("string" === typeof value2 && (relativeValue = RELATIVE_VALUE_REGEX.exec(value2))) {
      return parseInt(relativeValue[1] + "1") * relativeValue[2];
    }
  }
};
var FadeAnimationConfigurator = {
  setup: function($element, config3) {
    const from = config3.from;
    const to = config3.to;
    const defaultFromOpacity = "fadeOut" === config3.type ? 1 : 0;
    const defaultToOpacity = "fadeOut" === config3.type ? 0 : 1;
    let fromOpacity = isPlainObject(from) ? String(from.opacity ?? defaultFromOpacity) : String(from);
    let toOpacity = isPlainObject(to) ? String(to.opacity ?? defaultToOpacity) : String(to);
    if (!config3.skipElementInitialStyles) {
      fromOpacity = $element.css("opacity");
    }
    switch (config3.type) {
      case "fadeIn":
        toOpacity = 1;
        break;
      case "fadeOut":
        toOpacity = 0;
    }
    config3.from = {
      visibility: "visible",
      opacity: fromOpacity
    };
    config3.to = {
      opacity: toOpacity
    };
  }
};
var PopAnimationConfigurator = {
  validateConfig: function(config3) {
    isObjectConfigValidator(config3, "pop");
  },
  setup: function($element, config3) {
    const from = config3.from;
    const to = config3.to;
    const fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity");
    const toOpacity = "opacity" in to ? to.opacity : 1;
    const fromScale = "scale" in from ? from.scale : 0;
    const toScale = "scale" in to ? to.scale : 1;
    config3.from = {
      opacity: fromOpacity
    };
    const translate = getTranslate($element);
    config3.from.transform = this._getCssTransform(translate, fromScale);
    config3.to = {
      opacity: toOpacity
    };
    config3.to.transform = this._getCssTransform(translate, toScale);
  },
  _getCssTransform: function(translate, scale) {
    return getTranslateCss(translate) + "scale(" + scale + ")";
  }
};
var animationConfigurators = {
  custom: CustomAnimationConfigurator,
  slide: SlideAnimationConfigurator,
  slideIn: SlideAnimationConfigurator,
  slideOut: SlideAnimationConfigurator,
  fade: FadeAnimationConfigurator,
  fadeIn: FadeAnimationConfigurator,
  fadeOut: FadeAnimationConfigurator,
  pop: PopAnimationConfigurator,
  css: CssAnimationConfigurator
};
var getAnimationConfigurator = function(config3) {
  const result2 = animationConfigurators[config3.type];
  if (!result2) {
    throw errors_default.Error("E0011", config3.type);
  }
  return result2;
};
var defaultJSConfig = {
  type: "custom",
  from: {},
  to: {},
  duration: 400,
  start: noop2,
  complete: noop2,
  easing: "ease",
  delay: 0
};
var defaultCssConfig = {
  duration: 400,
  easing: "ease",
  delay: 0
};
function setupAnimationOnElement() {
  const $element = this.element;
  const config3 = this.config;
  setupPosition($element, config3.from);
  setupPosition($element, config3.to);
  this.configurator.setup($element, config3);
  $element.data(ANIM_DATA_KEY, this);
  if (fx.off) {
    config3.duration = 0;
    config3.delay = 0;
  }
  this.strategy.initAnimation($element, config3);
  if (config3.start) {
    const element = getPublicElement($element);
    config3.start.apply(this, [element, config3]);
  }
}
var onElementAnimationComplete = function(animation3) {
  const $element = animation3.element;
  const config3 = animation3.config;
  $element.removeData(ANIM_DATA_KEY);
  if (config3.complete) {
    const element = getPublicElement($element);
    config3.complete.apply(this, [element, config3]);
  }
  animation3.deferred.resolveWith(this, [$element, config3]);
};
var startAnimationOnElement = function() {
  const animation3 = this;
  const $element = animation3.element;
  const config3 = animation3.config;
  animation3.isStarted = true;
  return animation3.strategy.animate($element, config3).done(function() {
    onElementAnimationComplete(animation3);
  }).fail(function() {
    animation3.deferred.rejectWith(this, [$element, config3]);
  });
};
var stopAnimationOnElement = function(jumpToEnd) {
  const animation3 = this;
  const $element = animation3.element;
  const config3 = animation3.config;
  clearTimeout(animation3.startTimeout);
  if (!animation3.isStarted) {
    animation3.start();
  }
  animation3.strategy.stop($element, config3, jumpToEnd);
};
var scopedRemoveEvent = addNamespace2(removeEvent, "dxFXStartAnimation");
var subscribeToRemoveEvent = function(animation3) {
  events_engine_default.off(animation3.element, scopedRemoveEvent);
  events_engine_default.on(animation3.element, scopedRemoveEvent, function() {
    fx.stop(animation3.element);
  });
  animation3.deferred.always(function() {
    events_engine_default.off(animation3.element, scopedRemoveEvent);
  });
};
var createAnimation = function(element, initialConfig) {
  const defaultConfig = "css" === initialConfig.type ? defaultCssConfig : defaultJSConfig;
  const config3 = extend(true, {}, defaultConfig, initialConfig);
  const configurator = getAnimationConfigurator(config3);
  const strategy4 = getAnimationStrategy(config3);
  const animation3 = {
    element: renderer_default(element),
    config: config3,
    configurator,
    strategy: strategy4,
    isSynchronous: strategy4.isSynchronous,
    setup: setupAnimationOnElement,
    start: startAnimationOnElement,
    stop: stopAnimationOnElement,
    deferred: new Deferred()
  };
  if (isFunction(configurator.validateConfig)) {
    configurator.validateConfig(config3);
  }
  subscribeToRemoveEvent(animation3);
  return animation3;
};
var animate = function(element, config3) {
  const $element = renderer_default(element);
  if (!$element.length) {
    return new Deferred().resolve().promise();
  }
  const animation3 = createAnimation($element, config3);
  pushInAnimationQueue($element, animation3);
  return animation3.deferred.promise();
};
function pushInAnimationQueue($element, animation3) {
  const queueData = getAnimQueueData($element);
  writeAnimQueueData($element, queueData);
  queueData.push(animation3);
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
}
function getAnimQueueData($element) {
  return $element.data(ANIM_QUEUE_KEY) || [];
}
function writeAnimQueueData($element, queueData) {
  $element.data(ANIM_QUEUE_KEY, queueData);
}
var destroyAnimQueueData = function($element) {
  $element.removeData(ANIM_QUEUE_KEY);
};
function isAnimating($element) {
  return !!$element.data(ANIM_DATA_KEY);
}
function shiftFromAnimationQueue($element, queueData) {
  queueData = getAnimQueueData($element);
  if (!queueData.length) {
    return;
  }
  const animation3 = queueData.shift();
  if (0 === queueData.length) {
    destroyAnimQueueData($element);
  }
  executeAnimation(animation3).done(function() {
    if (!isAnimating($element)) {
      shiftFromAnimationQueue($element);
    }
  });
}
function executeAnimation(animation3) {
  animation3.setup();
  if (fx.off || animation3.isSynchronous) {
    animation3.start();
  } else {
    animation3.startTimeout = setTimeout(function() {
      animation3.start();
    });
  }
  return animation3.deferred.promise();
}
function setupPosition($element, config3) {
  if (!config3 || !config3.position) {
    return;
  }
  const win = renderer_default(window11);
  let left = 0;
  let top = 0;
  const position3 = position_default.calculate($element, config3.position);
  const offset2 = $element.offset();
  const currentPosition = $element.position();
  if (currentPosition.top > offset2.top) {
    top = win.scrollTop();
  }
  if (currentPosition.left > offset2.left) {
    left = win.scrollLeft();
  }
  extend(config3, {
    left: position3.h.location - offset2.left + currentPosition.left - left,
    top: position3.v.location - offset2.top + currentPosition.top - top
  });
  delete config3.position;
}
function setProps($element, props) {
  each(props, function(key, value2) {
    try {
      $element.css(key, isFunction(value2) ? value2() : value2);
    } catch (e) {
    }
  });
}
var stop = function(element, jumpToEnd) {
  const $element = renderer_default(element);
  const queueData = getAnimQueueData($element);
  each(queueData, function(_, animation4) {
    animation4.config.delay = 0;
    animation4.config.duration = 0;
    animation4.isSynchronous = true;
  });
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
  const animation3 = $element.data(ANIM_DATA_KEY);
  if (animation3) {
    animation3.stop(jumpToEnd);
  }
  $element.removeData(ANIM_DATA_KEY);
  destroyAnimQueueData($element);
};
var fx = {
  off: false,
  animationTypes: animationConfigurators,
  animate,
  createAnimation,
  isAnimating,
  stop,
  _simulatedTransitionEndDelay: 100
};
var fx_default = fx;

// ../../../../../../node_modules/devextreme/esm/events/visibility_change.js
var triggerVisibilityChangeEvent = function(eventName) {
  return function(element) {
    const $element = renderer_default(element || "body");
    const changeHandlers = $element.filter(".dx-visibility-change-handler").add($element.find(".dx-visibility-change-handler"));
    for (let i = 0; i < changeHandlers.length; i++) {
      events_engine_default.triggerHandler(changeHandlers[i], eventName);
    }
  };
};
var triggerShownEvent = triggerVisibilityChangeEvent("dxshown");
var triggerHidingEvent = triggerVisibilityChangeEvent("dxhiding");
var triggerResizeEvent = triggerVisibilityChangeEvent("dxresize");

// ../../../../../../node_modules/devextreme/esm/core/templates/template_base.js
var renderedCallbacks = callbacks_default({
  syncStrategy: true
});
var TemplateBase = class {
  render(options2) {
    options2 = options2 || {};
    const onRendered = options2.onRendered;
    delete options2.onRendered;
    let $result;
    if (options2.renovated && options2.transclude && this._element) {
      $result = renderer_default("<div>").append(this._element).contents();
    } else {
      $result = this._renderCore(options2);
    }
    this._ensureResultInContainer($result, options2.container);
    renderedCallbacks.fire($result, options2.container);
    onRendered && onRendered();
    return $result;
  }
  _ensureResultInContainer($result, container) {
    if (!container) {
      return;
    }
    const $container = renderer_default(container);
    const resultInContainer = contains2($container.get(0), $result.get(0));
    $container.append($result);
    if (resultInContainer) {
      return;
    }
    const resultInBody = contains2(dom_adapter_default.getBody(), $container.get(0));
    if (!resultInBody) {
      return;
    }
    triggerShownEvent($result);
  }
  _renderCore() {
    throw errors_default.Error("E0001");
  }
};

// ../../../../../../node_modules/devextreme/esm/core/templates/empty_template.js
var EmptyTemplate = class extends TemplateBase {
  _renderCore() {
    return renderer_default();
  }
};

// ../../../../../../node_modules/devextreme/esm/core/utils/array.js
function createOccurrenceMap(array) {
  return array.reduce((map2, value2) => {
    const count = (map2.get(value2) ?? 0) + 1;
    map2.set(value2, count);
    return map2;
  }, /* @__PURE__ */ new Map());
}
var wrapToArray = function(item) {
  return Array.isArray(item) ? item : [item];
};
var getUniqueValues = function(values) {
  return [...new Set(values)];
};
var getIntersection = function(firstArray, secondArray) {
  const toRemoveMap = createOccurrenceMap(secondArray);
  return firstArray.filter((value2) => {
    const occurrencesCount = toRemoveMap.get(value2);
    occurrencesCount && toRemoveMap.set(value2, occurrencesCount - 1);
    return occurrencesCount;
  });
};
var removeDuplicates = function() {
  let from = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  let toRemove = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
  const toRemoveMap = createOccurrenceMap(toRemove);
  return from.filter((value2) => {
    const occurrencesCount = toRemoveMap.get(value2);
    occurrencesCount && toRemoveMap.set(value2, occurrencesCount - 1);
    return !occurrencesCount;
  });
};
var normalizeIndexes = function(items, indexPropName, currentItem, needIndexCallback) {
  const indexedItems = {};
  const {
    useLegacyVisibleIndex
  } = config_default();
  let currentIndex = 0;
  const shouldUpdateIndex = (item) => !isDefined(item[indexPropName]) && (!needIndexCallback || needIndexCallback(item));
  items.forEach((item) => {
    const index2 = item[indexPropName];
    if (index2 >= 0) {
      indexedItems[index2] = indexedItems[index2] || [];
      if (item === currentItem) {
        indexedItems[index2].unshift(item);
      } else {
        indexedItems[index2].push(item);
      }
    } else {
      item[indexPropName] = void 0;
    }
  });
  if (!useLegacyVisibleIndex) {
    items.forEach((item) => {
      if (shouldUpdateIndex(item)) {
        while (indexedItems[currentIndex]) {
          currentIndex++;
        }
        indexedItems[currentIndex] = [item];
        currentIndex++;
      }
    });
  }
  currentIndex = 0;
  orderEach(indexedItems, function(index2, items2) {
    items2.forEach((item) => {
      if (index2 >= 0) {
        item[indexPropName] = currentIndex++;
      }
    });
  });
  if (useLegacyVisibleIndex) {
    items.forEach((item) => {
      if (shouldUpdateIndex(item)) {
        item[indexPropName] = currentIndex++;
      }
    });
  }
};
var groupBy = (array, getGroupName) => array.reduce((groupedResult, item) => {
  const groupName = getGroupName(item);
  groupedResult[groupName] = groupedResult[groupName] ?? [];
  groupedResult[groupName].push(item);
  return groupedResult;
}, {});

// ../../../../../../node_modules/devextreme/esm/events/core/emitter.js
var Emitter = class_default.inherit({
  ctor: function(element) {
    this._$element = renderer_default(element);
    this._cancelCallback = callbacks_default();
    this._acceptCallback = callbacks_default();
  },
  getElement: function() {
    return this._$element;
  },
  validate: function(e) {
    return !isDxMouseWheelEvent(e);
  },
  validatePointers: function(e) {
    return 1 === hasTouches(e);
  },
  allowInterruptionByMouseWheel: function() {
    return true;
  },
  configure: function(data2) {
    extend(this, data2);
  },
  addCancelCallback: function(callback) {
    this._cancelCallback.add(callback);
  },
  removeCancelCallback: function() {
    this._cancelCallback.empty();
  },
  _cancel: function(e) {
    this._cancelCallback.fire(this, e);
  },
  addAcceptCallback: function(callback) {
    this._acceptCallback.add(callback);
  },
  removeAcceptCallback: function() {
    this._acceptCallback.empty();
  },
  _accept: function(e) {
    this._acceptCallback.fire(this, e);
  },
  _requestAccept: function(e) {
    this._acceptRequestEvent = e;
  },
  _forgetAccept: function() {
    this._accept(this._acceptRequestEvent);
    this._acceptRequestEvent = null;
  },
  start: noop2,
  move: noop2,
  end: noop2,
  cancel: noop2,
  reset: function() {
    if (this._acceptRequestEvent) {
      this._accept(this._acceptRequestEvent);
    }
  },
  _fireEvent: function(eventName, e, params) {
    const eventData2 = extend({
      type: eventName,
      originalEvent: e,
      target: this._getEmitterTarget(e),
      delegateTarget: this.getElement().get(0)
    }, params);
    e = fireEvent(eventData2);
    if (e.cancel) {
      this._cancel(e);
    }
    return e;
  },
  _getEmitterTarget: function(e) {
    return (this.delegateSelector ? renderer_default(e.target).closest(this.delegateSelector) : this.getElement()).get(0);
  },
  dispose: noop2
});
var emitter_default = Emitter;

// ../../../../../../node_modules/devextreme/esm/events/gesture/emitter.gesture.js
var ready2 = ready_callbacks_default.add;
var abs = Math.abs;
var TOUCH_BOUNDARY = 10;
var supportPointerEvents = function() {
  return styleProp("pointer-events");
};
var setGestureCover = call_once_default(function() {
  const isDesktop = "desktop" === devices_default.real().deviceType;
  if (!supportPointerEvents() || !isDesktop) {
    return noop2;
  }
  const $cover = renderer_default("<div>").addClass("dx-gesture-cover").css("pointerEvents", "none");
  events_engine_default.subscribeGlobal($cover, "dxmousewheel", function(e) {
    e.preventDefault();
  });
  ready2(function() {
    $cover.appendTo("body");
  });
  return function(toggle, cursor) {
    $cover.css("pointerEvents", toggle ? "all" : "none");
    toggle && $cover.css("cursor", cursor);
  };
});
var gestureCover = function(toggle, cursor) {
  const gestureCoverStrategy = setGestureCover();
  gestureCoverStrategy(toggle, cursor);
};
var GestureEmitter = emitter_default.inherit({
  gesture: true,
  configure: function(data2) {
    this.getElement().css("msTouchAction", data2.immediate ? "pinch-zoom" : "");
    this.callBase(data2);
  },
  allowInterruptionByMouseWheel: function() {
    return 2 !== this._stage;
  },
  getDirection: function() {
    return this.direction;
  },
  _cancel: function() {
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
    this._stage = 0;
  },
  start: function(e) {
    if (e._needSkipEvent || needSkipEvent(e)) {
      this._cancel(e);
      return;
    }
    this._startEvent = createEvent(e);
    this._startEventData = eventData(e);
    this._stage = 1;
    this._init(e);
    this._setupImmediateTimer();
  },
  _setupImmediateTimer: function() {
    clearTimeout(this._immediateTimer);
    this._immediateAccepted = false;
    if (!this.immediate) {
      return;
    }
    if (0 === this.immediateTimeout) {
      this._immediateAccepted = true;
      return;
    }
    this._immediateTimer = setTimeout((function() {
      this._immediateAccepted = true;
    }).bind(this), this.immediateTimeout ?? 180);
  },
  move: function(e) {
    if (1 === this._stage && this._directionConfirmed(e)) {
      this._stage = 2;
      this._resetActiveElement();
      this._toggleGestureCover(true);
      this._clearSelection(e);
      this._adjustStartEvent(e);
      this._start(this._startEvent);
      if (0 === this._stage) {
        return;
      }
      this._requestAccept(e);
      this._move(e);
      this._forgetAccept();
    } else if (2 === this._stage) {
      this._clearSelection(e);
      this._move(e);
    }
  },
  _directionConfirmed: function(e) {
    const touchBoundary = this._getTouchBoundary(e);
    const delta = eventDelta(this._startEventData, eventData(e));
    const deltaX = abs(delta.x);
    const deltaY = abs(delta.y);
    const horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);
    const verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
    const direction = this.getDirection(e);
    const bothAccepted = "both" === direction && (horizontalMove || verticalMove);
    const horizontalAccepted = "horizontal" === direction && horizontalMove;
    const verticalAccepted = "vertical" === direction && verticalMove;
    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;
  },
  _validateMove: function(touchBoundary, mainAxis, crossAxis) {
    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);
  },
  _getTouchBoundary: function(e) {
    return this.immediate || isDxMouseWheelEvent(e) ? 0 : TOUCH_BOUNDARY;
  },
  _adjustStartEvent: function(e) {
    const touchBoundary = this._getTouchBoundary(e);
    const delta = eventDelta(this._startEventData, eventData(e));
    this._startEvent.pageX += sign(delta.x) * touchBoundary;
    this._startEvent.pageY += sign(delta.y) * touchBoundary;
  },
  _resetActiveElement: function() {
    if ("ios" === devices_default.real().platform && this.getElement().find(":focus").length) {
      resetActiveElement();
    }
  },
  _toggleGestureCover: function(toggle) {
    this._toggleGestureCoverImpl(toggle);
  },
  _toggleGestureCoverImpl: function(toggle) {
    const isStarted = 2 === this._stage;
    if (isStarted) {
      gestureCover(toggle, this.getElement().css("cursor"));
    }
  },
  _clearSelection: function(e) {
    if (isDxMouseWheelEvent(e) || isTouchEvent(e)) {
      return;
    }
    clearSelection();
  },
  end: function(e) {
    this._toggleGestureCover(false);
    if (2 === this._stage) {
      this._end(e);
    } else if (1 === this._stage) {
      this._stop(e);
    }
    this._stage = 0;
  },
  dispose: function() {
    clearTimeout(this._immediateTimer);
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
  },
  _init: noop2,
  _start: noop2,
  _move: noop2,
  _stop: noop2,
  _end: noop2
});
GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
GestureEmitter.touchBoundary = function(newBoundary) {
  if (isDefined(newBoundary)) {
    TOUCH_BOUNDARY = newBoundary;
    return;
  }
  return TOUCH_BOUNDARY;
};
var emitter_gesture_default = GestureEmitter;

// ../../../../../../node_modules/devextreme/esm/events/core/emitter_registrator.js
var MANAGER_EVENT = "dxEventManager";
var EventManager = class_default.inherit({
  ctor: function() {
    this._attachHandlers();
    this.reset();
    this._proxiedCancelHandler = this._cancelHandler.bind(this);
    this._proxiedAcceptHandler = this._acceptHandler.bind(this);
  },
  _attachHandlers: function() {
    ready_callbacks_default.add((function() {
      const document2 = dom_adapter_default.getDocument();
      events_engine_default.subscribeGlobal(document2, addNamespace2(pointer_default.down, MANAGER_EVENT), this._pointerDownHandler.bind(this));
      events_engine_default.subscribeGlobal(document2, addNamespace2(pointer_default.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this));
      events_engine_default.subscribeGlobal(document2, addNamespace2([pointer_default.up, pointer_default.cancel].join(" "), MANAGER_EVENT), this._pointerUpHandler.bind(this));
      events_engine_default.subscribeGlobal(document2, addNamespace2(EVENT_NAME, MANAGER_EVENT), this._mouseWheelHandler.bind(this));
    }).bind(this));
  },
  _eachEmitter: function(callback) {
    const activeEmitters = this._activeEmitters || [];
    let i = 0;
    while (activeEmitters.length > i) {
      const emitter = activeEmitters[i];
      if (false === callback(emitter)) {
        break;
      }
      if (activeEmitters[i] === emitter) {
        i++;
      }
    }
  },
  _applyToEmitters: function(method, arg) {
    this._eachEmitter(function(emitter) {
      emitter[method].call(emitter, arg);
    });
  },
  reset: function() {
    this._eachEmitter(this._proxiedCancelHandler);
    this._activeEmitters = [];
  },
  resetEmitter: function(emitter) {
    this._proxiedCancelHandler(emitter);
  },
  _pointerDownHandler: function(e) {
    if (isMouseEvent(e) && e.which > 1) {
      return;
    }
    this._updateEmitters(e);
  },
  _updateEmitters: function(e) {
    if (!this._isSetChanged(e)) {
      return;
    }
    this._cleanEmitters(e);
    this._fetchEmitters(e);
  },
  _isSetChanged: function(e) {
    const currentSet = this._closestEmitter(e);
    const previousSet = this._emittersSet || [];
    let setChanged = currentSet.length !== previousSet.length;
    each(currentSet, function(index2, emitter) {
      setChanged = setChanged || previousSet[index2] !== emitter;
      return !setChanged;
    });
    this._emittersSet = currentSet;
    return setChanged;
  },
  _closestEmitter: function(e) {
    const that = this;
    const result2 = [];
    let $element = renderer_default(e.target);
    function handleEmitter(_, emitter) {
      if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
        emitter.addCancelCallback(that._proxiedCancelHandler);
        emitter.addAcceptCallback(that._proxiedAcceptHandler);
        result2.push(emitter);
      }
    }
    while ($element.length) {
      const emitters = data($element.get(0), "dxEmitter") || [];
      each(emitters, handleEmitter);
      $element = $element.parent();
    }
    return result2;
  },
  _acceptHandler: function(acceptedEmitter, e) {
    const that = this;
    this._eachEmitter(function(emitter) {
      if (emitter !== acceptedEmitter) {
        that._cancelEmitter(emitter, e);
      }
    });
  },
  _cancelHandler: function(canceledEmitter, e) {
    this._cancelEmitter(canceledEmitter, e);
  },
  _cancelEmitter: function(emitter, e) {
    const activeEmitters = this._activeEmitters;
    if (e) {
      emitter.cancel(e);
    } else {
      emitter.reset();
    }
    emitter.removeCancelCallback();
    emitter.removeAcceptCallback();
    const emitterIndex = activeEmitters.indexOf(emitter);
    if (emitterIndex > -1) {
      activeEmitters.splice(emitterIndex, 1);
    }
  },
  _cleanEmitters: function(e) {
    this._applyToEmitters("end", e);
    this.reset(e);
  },
  _fetchEmitters: function(e) {
    this._activeEmitters = this._emittersSet.slice();
    this._applyToEmitters("start", e);
  },
  _pointerMoveHandler: function(e) {
    this._applyToEmitters("move", e);
  },
  _pointerUpHandler: function(e) {
    this._updateEmitters(e);
  },
  _mouseWheelHandler: function(e) {
    if (!this._allowInterruptionByMouseWheel()) {
      return;
    }
    e.pointers = [null];
    this._pointerDownHandler(e);
    this._adjustWheelEvent(e);
    this._pointerMoveHandler(e);
    e.pointers = [];
    this._pointerUpHandler(e);
  },
  _allowInterruptionByMouseWheel: function() {
    let allowInterruption = true;
    this._eachEmitter(function(emitter) {
      allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
      return allowInterruption;
    });
    return allowInterruption;
  },
  _adjustWheelEvent: function(e) {
    let closestGestureEmitter = null;
    this._eachEmitter(function(emitter) {
      if (!emitter.gesture) {
        return;
      }
      const direction2 = emitter.getDirection(e);
      if ("horizontal" !== direction2 && !e.shiftKey || "vertical" !== direction2 && e.shiftKey) {
        closestGestureEmitter = emitter;
        return false;
      }
    });
    if (!closestGestureEmitter) {
      return;
    }
    const direction = closestGestureEmitter.getDirection(e);
    const verticalGestureDirection = "both" === direction && !e.shiftKey || "vertical" === direction;
    const prop = verticalGestureDirection ? "pageY" : "pageX";
    e[prop] += e.delta;
  },
  isActive: function(element) {
    let result2 = false;
    this._eachEmitter(function(emitter) {
      result2 = result2 || emitter.getElement().is(element);
    });
    return result2;
  }
});
var eventManager = new EventManager();
var registerEmitter = function(emitterConfig) {
  const emitterClass = emitterConfig.emitter;
  const emitterName = emitterConfig.events[0];
  const emitterEvents = emitterConfig.events;
  each(emitterEvents, function(_, eventName) {
    event_registrator_default(eventName, {
      noBubble: !emitterConfig.bubble,
      setup: function(element) {
        const subscriptions = data(element, "dxEmitterSubscription") || {};
        const emitters = data(element, "dxEmitter") || {};
        const emitter = emitters[emitterName] || new emitterClass(element);
        subscriptions[eventName] = true;
        emitters[emitterName] = emitter;
        data(element, "dxEmitter", emitters);
        data(element, "dxEmitterSubscription", subscriptions);
      },
      add: function(element, handleObj) {
        const emitters = data(element, "dxEmitter");
        const emitter = emitters[emitterName];
        emitter.configure(extend({
          delegateSelector: handleObj.selector
        }, handleObj.data), handleObj.type);
      },
      teardown: function(element) {
        const subscriptions = data(element, "dxEmitterSubscription");
        const emitters = data(element, "dxEmitter");
        const emitter = emitters[emitterName];
        delete subscriptions[eventName];
        let disposeEmitter = true;
        each(emitterEvents, function(_2, eventName2) {
          disposeEmitter = disposeEmitter && !subscriptions[eventName2];
          return disposeEmitter;
        });
        if (disposeEmitter) {
          if (eventManager.isActive(element)) {
            eventManager.resetEmitter(emitter);
          }
          emitter && emitter.dispose();
          delete emitters[emitterName];
        }
      }
    });
  });
};
var emitter_registrator_default = registerEmitter;

// ../../../../../../node_modules/devextreme/esm/events/drag.js
var DRAG_START_EVENT = "dxdragstart";
var DRAG_EVENT = "dxdrag";
var DRAG_END_EVENT = "dxdragend";
var DRAG_ENTER_EVENT = "dxdragenter";
var DRAG_LEAVE_EVENT = "dxdragleave";
var DROP_EVENT = "dxdrop";
var knownDropTargets = [];
var knownDropTargetSelectors = [];
var knownDropTargetConfigs = [];
var dropTargetRegistration = {
  setup: function(element, data2) {
    const knownDropTarget = knownDropTargets.includes(element);
    if (!knownDropTarget) {
      knownDropTargets.push(element);
      knownDropTargetSelectors.push([]);
      knownDropTargetConfigs.push(data2 || {});
    }
  },
  add: function(element, handleObj) {
    const index2 = knownDropTargets.indexOf(element);
    this.updateEventsCounter(element, handleObj.type, 1);
    const selector = handleObj.selector;
    if (!knownDropTargetSelectors[index2].includes(selector)) {
      knownDropTargetSelectors[index2].push(selector);
    }
  },
  updateEventsCounter: function(element, event, value2) {
    if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].indexOf(event) > -1) {
      const eventsCount = data(element, "dxDragEventsCount") || 0;
      data(element, "dxDragEventsCount", Math.max(0, eventsCount + value2));
    }
  },
  remove: function(element, handleObj) {
    this.updateEventsCounter(element, handleObj.type, -1);
  },
  teardown: function(element) {
    const handlersCount = data(element, "dxDragEventsCount");
    if (!handlersCount) {
      const index2 = knownDropTargets.indexOf(element);
      knownDropTargets.splice(index2, 1);
      knownDropTargetSelectors.splice(index2, 1);
      knownDropTargetConfigs.splice(index2, 1);
      removeData(element, "dxDragEventsCount");
    }
  }
};
event_registrator_default(DRAG_ENTER_EVENT, dropTargetRegistration);
event_registrator_default(DRAG_LEAVE_EVENT, dropTargetRegistration);
event_registrator_default(DROP_EVENT, dropTargetRegistration);
var getItemDelegatedTargets = function($element) {
  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  const dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter((selector) => selector);
  let $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
  if (knownDropTargetSelectors[dropTargetIndex].includes(void 0)) {
    $delegatedTargets = $delegatedTargets.add($element);
  }
  return $delegatedTargets;
};
var getItemConfig = function($element) {
  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  return knownDropTargetConfigs[dropTargetIndex];
};
var getItemPosition = function(dropTargetConfig, $element) {
  if (dropTargetConfig.itemPositionFunc) {
    return dropTargetConfig.itemPositionFunc($element);
  } else {
    return $element.offset();
  }
};
var getItemSize = function(dropTargetConfig, $element) {
  if (dropTargetConfig.itemSizeFunc) {
    return dropTargetConfig.itemSizeFunc($element);
  }
  return {
    width: $element.get(0).getBoundingClientRect().width,
    height: $element.get(0).getBoundingClientRect().height
  };
};
var DragEmitter = emitter_gesture_default.inherit({
  ctor: function(element) {
    this.callBase(element);
    this.direction = "both";
  },
  _init: function(e) {
    this._initEvent = e;
  },
  _start: function(e) {
    e = this._fireEvent("dxdragstart", this._initEvent);
    this._maxLeftOffset = e.maxLeftOffset;
    this._maxRightOffset = e.maxRightOffset;
    this._maxTopOffset = e.maxTopOffset;
    this._maxBottomOffset = e.maxBottomOffset;
    if (e.targetElements || null === e.targetElements) {
      const dropTargets = wrapToArray(e.targetElements || []);
      this._dropTargets = map(dropTargets, function(element) {
        return renderer_default(element).get(0);
      });
    } else {
      this._dropTargets = knownDropTargets;
    }
  },
  _move: function(e) {
    const eventData2 = eventData(e);
    const dragOffset = this._calculateOffset(eventData2);
    e = this._fireEvent("dxdrag", e, {
      offset: dragOffset
    });
    this._processDropTargets(e);
    if (!e._cancelPreventDefault) {
      e.preventDefault();
    }
  },
  _calculateOffset: function(eventData2) {
    return {
      x: this._calculateXOffset(eventData2),
      y: this._calculateYOffset(eventData2)
    };
  },
  _calculateXOffset: function(eventData2) {
    if ("vertical" !== this.direction) {
      const offset2 = eventData2.x - this._startEventData.x;
      return this._fitOffset(offset2, this._maxLeftOffset, this._maxRightOffset);
    }
    return 0;
  },
  _calculateYOffset: function(eventData2) {
    if ("horizontal" !== this.direction) {
      const offset2 = eventData2.y - this._startEventData.y;
      return this._fitOffset(offset2, this._maxTopOffset, this._maxBottomOffset);
    }
    return 0;
  },
  _fitOffset: function(offset2, minOffset, maxOffset) {
    if (null != minOffset) {
      offset2 = Math.max(offset2, -minOffset);
    }
    if (null != maxOffset) {
      offset2 = Math.min(offset2, maxOffset);
    }
    return offset2;
  },
  _processDropTargets: function(e) {
    const target = this._findDropTarget(e);
    const sameTarget = target === this._currentDropTarget;
    if (!sameTarget) {
      this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
      this._currentDropTarget = target;
      this._fireDropTargetEvent(e, DRAG_ENTER_EVENT);
    }
  },
  _fireDropTargetEvent: function(event, eventName) {
    if (!this._currentDropTarget) {
      return;
    }
    const eventData2 = {
      type: eventName,
      originalEvent: event,
      draggingElement: this._$element.get(0),
      target: this._currentDropTarget
    };
    fireEvent(eventData2);
  },
  _findDropTarget: function(e) {
    const that = this;
    let result2;
    each(knownDropTargets, function(_, target) {
      if (!that._checkDropTargetActive(target)) {
        return;
      }
      const $target = renderer_default(target);
      each(getItemDelegatedTargets($target), function(_2, delegatedTarget) {
        const $delegatedTarget = renderer_default(delegatedTarget);
        if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, renderer_default(result2), e)) {
          result2 = delegatedTarget;
        }
      });
    });
    return result2;
  },
  _checkDropTargetActive: function(target) {
    let active2 = false;
    each(this._dropTargets, function(_, activeTarget) {
      active2 = active2 || activeTarget === target || contains2(activeTarget, target);
      return !active2;
    });
    return active2;
  },
  _checkDropTarget: function(config3, $target, $prevTarget, e) {
    const isDraggingElement = $target.get(0) === renderer_default(e.target).get(0);
    if (isDraggingElement) {
      return false;
    }
    const targetPosition = getItemPosition(config3, $target);
    if (e.pageX < targetPosition.left) {
      return false;
    }
    if (e.pageY < targetPosition.top) {
      return false;
    }
    const targetSize = getItemSize(config3, $target);
    if (e.pageX > targetPosition.left + targetSize.width) {
      return false;
    }
    if (e.pageY > targetPosition.top + targetSize.height) {
      return false;
    }
    if ($prevTarget.length && $prevTarget.closest($target).length) {
      return false;
    }
    if (config3.checkDropTarget && !config3.checkDropTarget($target, e)) {
      return false;
    }
    return $target;
  },
  _end: function(e) {
    const eventData2 = eventData(e);
    this._fireEvent("dxdragend", e, {
      offset: this._calculateOffset(eventData2)
    });
    this._fireDropTargetEvent(e, DROP_EVENT);
    delete this._currentDropTarget;
  }
});
emitter_registrator_default({
  emitter: DragEmitter,
  events: ["dxdragstart", "dxdrag", "dxdragend"]
});

// ../../../../../../node_modules/devextreme/esm/events/core/keyboard_processor.js
var NAMESPACE = "KeyboardProcessor";
var createKeyDownOptions = (e) => ({
  keyName: normalizeKeyName(e),
  key: e.key,
  code: e.code,
  ctrl: e.ctrlKey,
  location: e.location,
  metaKey: e.metaKey,
  shift: e.shiftKey,
  alt: e.altKey,
  which: e.which,
  originalEvent: e
});
var KeyboardProcessor = class_default.inherit({
  _keydown: addNamespace2("keydown", NAMESPACE),
  _compositionStart: addNamespace2("compositionstart", NAMESPACE),
  _compositionEnd: addNamespace2("compositionend", NAMESPACE),
  ctor: function(options2) {
    options2 = options2 || {};
    if (options2.element) {
      this._element = renderer_default(options2.element);
    }
    if (options2.focusTarget) {
      this._focusTarget = options2.focusTarget;
    }
    this._handler = options2.handler;
    if (this._element) {
      this._processFunction = (e) => {
        const focusTargets = renderer_default(this._focusTarget).toArray();
        const isNotFocusTarget = this._focusTarget && this._focusTarget !== e.target && !focusTargets.includes(e.target);
        const shouldSkipProcessing = this._isComposingJustFinished && 229 === e.which || this._isComposing || isNotFocusTarget;
        this._isComposingJustFinished = false;
        if (!shouldSkipProcessing) {
          this.process(e);
        }
      };
      this._toggleProcessingWithContext = this.toggleProcessing.bind(this);
      events_engine_default.on(this._element, this._keydown, this._processFunction);
      events_engine_default.on(this._element, this._compositionStart, this._toggleProcessingWithContext);
      events_engine_default.on(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
  },
  dispose: function() {
    if (this._element) {
      events_engine_default.off(this._element, this._keydown, this._processFunction);
      events_engine_default.off(this._element, this._compositionStart, this._toggleProcessingWithContext);
      events_engine_default.off(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
    this._element = void 0;
    this._handler = void 0;
  },
  process: function(e) {
    this._handler(createKeyDownOptions(e));
  },
  toggleProcessing: function(_ref) {
    let {
      type: type2
    } = _ref;
    this._isComposing = "compositionstart" === type2;
    this._isComposingJustFinished = !this._isComposing;
  }
});
KeyboardProcessor.createKeyDownOptions = createKeyDownOptions;
var keyboard_processor_default = KeyboardProcessor;

// ../../../../../../node_modules/devextreme/esm/events/short.js
function addNamespace3(event, namespace) {
  return namespace ? addNamespace2(event, namespace) : event;
}
function executeAction(action, args) {
  return "function" === typeof action ? action(args) : action.execute(args);
}
var active = {
  on: ($el, active2, inactive, opts) => {
    const {
      selector,
      showTimeout,
      hideTimeout,
      namespace
    } = opts;
    events_engine_default.on($el, addNamespace3("dxactive", namespace), selector, {
      timeout: showTimeout
    }, (event) => executeAction(active2, {
      event,
      element: event.currentTarget
    }));
    events_engine_default.on($el, addNamespace3("dxinactive", namespace), selector, {
      timeout: hideTimeout
    }, (event) => executeAction(inactive, {
      event,
      element: event.currentTarget
    }));
  },
  off: ($el, _ref) => {
    let {
      namespace,
      selector
    } = _ref;
    events_engine_default.off($el, addNamespace3("dxactive", namespace), selector);
    events_engine_default.off($el, addNamespace3("dxinactive", namespace), selector);
  }
};
var resize = {
  on: function($el, resize2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    events_engine_default.on($el, addNamespace3("dxresize", namespace), resize2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    events_engine_default.off($el, addNamespace3("dxresize", namespace));
  }
};
var hover = {
  on: ($el, start, end, _ref2) => {
    let {
      selector,
      namespace
    } = _ref2;
    events_engine_default.on($el, addNamespace3("dxhoverend", namespace), selector, (event) => end(event));
    events_engine_default.on($el, addNamespace3("dxhoverstart", namespace), selector, (event) => executeAction(start, {
      element: event.target,
      event
    }));
  },
  off: ($el, _ref3) => {
    let {
      selector,
      namespace
    } = _ref3;
    events_engine_default.off($el, addNamespace3("dxhoverstart", namespace), selector);
    events_engine_default.off($el, addNamespace3("dxhoverend", namespace), selector);
  }
};
var visibility = {
  on: ($el, shown, hiding, _ref4) => {
    let {
      namespace
    } = _ref4;
    events_engine_default.on($el, addNamespace3("dxhiding", namespace), hiding);
    events_engine_default.on($el, addNamespace3("dxshown", namespace), shown);
  },
  off: ($el, _ref5) => {
    let {
      namespace
    } = _ref5;
    events_engine_default.off($el, addNamespace3("dxhiding", namespace));
    events_engine_default.off($el, addNamespace3("dxshown", namespace));
  }
};
var focus = {
  on: ($el, focusIn, focusOut, _ref6) => {
    let {
      namespace
    } = _ref6;
    events_engine_default.on($el, addNamespace3("focusin", namespace), focusIn);
    events_engine_default.on($el, addNamespace3("focusout", namespace), focusOut);
  },
  off: ($el, _ref7) => {
    let {
      namespace
    } = _ref7;
    events_engine_default.off($el, addNamespace3("focusin", namespace));
    events_engine_default.off($el, addNamespace3("focusout", namespace));
  },
  trigger: ($el) => events_engine_default.trigger($el, "focus")
};
var dxClick = {
  on: function($el, click2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    events_engine_default.on($el, addNamespace3("dxclick", namespace), click2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    events_engine_default.off($el, addNamespace3("dxclick", namespace));
  }
};
var click = {
  on: function($el, click2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    events_engine_default.on($el, addNamespace3("click", namespace), click2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    events_engine_default.off($el, addNamespace3("click", namespace));
  }
};
var index = 0;
var keyboardProcessors = {};
var generateListenerId = () => "keyboardProcessorId" + index++;
var keyboard = {
  on: (element, focusTarget, handler) => {
    const listenerId = generateListenerId();
    keyboardProcessors[listenerId] = new keyboard_processor_default({
      element,
      focusTarget,
      handler
    });
    return listenerId;
  },
  off: (listenerId) => {
    if (listenerId && keyboardProcessors[listenerId]) {
      keyboardProcessors[listenerId].dispose();
      delete keyboardProcessors[listenerId];
    }
  },
  _getProcessor: (listenerId) => keyboardProcessors[listenerId]
};

// ../../../../../../node_modules/devextreme/esm/mobile/hide_callback.js
var hideCallback = function() {
  let callbacks2 = [];
  return {
    add: function(callback) {
      if (!callbacks2.includes(callback)) {
        callbacks2.push(callback);
      }
    },
    remove: function(callback) {
      const indexOfCallback = callbacks2.indexOf(callback);
      if (-1 !== indexOfCallback) {
        callbacks2.splice(indexOfCallback, 1);
      }
    },
    fire: function() {
      const callback = callbacks2.pop();
      const result2 = !!callback;
      if (result2) {
        callback();
      }
      return result2;
    },
    hasCallback: function() {
      return callbacks2.length > 0;
    }
  };
}();

// ../../../../../../node_modules/devextreme/esm/ui/widget/ui.errors.js
var ui_errors_default = error_default(errors_default.ERROR_MESSAGES, {
  E1001: "Module '{0}'. Controller '{1}' is already registered",
  E1002: "Module '{0}'. Controller '{1}' does not inherit from DevExpress.ui.dxDataGrid.Controller",
  E1003: "Module '{0}'. View '{1}' is already registered",
  E1004: "Module '{0}'. View '{1}' does not inherit from DevExpress.ui.dxDataGrid.View",
  E1005: "Public method '{0}' is already registered",
  E1006: "Public method '{0}.{1}' does not exist",
  E1007: "State storing cannot be provided due to the restrictions of the browser",
  E1010: "The template does not contain the TextBox widget",
  E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',
  E1012: "Editing type '{0}' with the name '{1}' is unsupported",
  E1016: "Unexpected type of data source is provided for a lookup column",
  E1018: "The 'collapseAll' method cannot be called if you use a remote data source",
  E1019: "Search mode '{0}' is unavailable",
  E1020: "The type cannot be changed after initialization",
  E1021: "{0} '{1}' you are trying to remove does not exist",
  E1022: 'The "markers" option is given an invalid value. Assign an array instead',
  E1023: 'The "routes" option is given an invalid value. Assign an array instead',
  E1025: "This layout is too complex to render",
  E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',
  E1031: "Unknown subscription in the Scheduler widget: '{0}'",
  E1032: "Unknown start date in an appointment: '{0}'",
  E1033: "Unknown step in the date navigator: '{0}'",
  E1034: "The browser does not implement an API for saving files",
  E1035: "The editor cannot be created: {0}",
  E1037: "Invalid structure of grouped data",
  E1038: "The browser does not support local storages for local web pages",
  E1039: "A cell's position cannot be calculated",
  E1040: "The '{0}' key value is not unique within the data array",
  E1041: "The '{0}' script is referenced after the DevExtreme scripts or not referenced at all",
  E1042: "{0} requires the key field to be specified",
  E1043: "Changes cannot be processed due to the incorrectly set key",
  E1044: "The key field specified by the keyExpr option does not match the key field specified in the data store",
  E1045: "Editing requires the key field to be specified in the data store",
  E1046: "The '{0}' key field is not found in data objects",
  E1047: 'The "{0}" field is not found in the fields array',
  E1048: 'The "{0}" operation is not found in the filterOperations array',
  E1049: "Column '{0}': filtering is allowed but the 'dataField' or 'name' option is not specified",
  E1050: "The validationRules option does not apply to third-party editors defined in the editCellTemplate",
  E1051: `HtmlEditor's valueType is "{0}", but the {0} converter was not imported.`,
  E1052: '{0} should have the "dataSource" option specified',
  E1053: 'The "buttons" option accepts an array that contains only objects or string values',
  E1054: "All text editor buttons must have names",
  E1055: 'One or several text editor buttons have invalid or non-unique "name" values',
  E1056: 'The {0} widget does not support buttons of the "{1}" type',
  E1058: 'The "startDayHour" and "endDayHour" options must be integers in the [0, 24] range, with "endDayHour" being greater than "startDayHour".',
  E1059: "The following column names are not unique: {0}",
  E1060: "All editable columns must have names",
  E1061: 'The "offset" option must be an integer in the [-1440, 1440] range, divisible by 5 without a remainder.',
  E1062: 'The "cellDuration" must be a positive integer, evenly dividing the ("endDayHour" - "startDayHour") interval into minutes.',
  W1001: 'The "key" option cannot be modified after initialization',
  W1002: "An item with the key '{0}' does not exist",
  W1003: "A group with the key '{0}' in which you are trying to select items does not exist",
  W1004: "The item '{0}' you are trying to select in the group '{1}' does not exist",
  W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.",
  W1006: "The map service returned the following error: '{0}'",
  W1007: "No item with key {0} was found in the data source, but this key was used as the parent key for item {1}",
  W1008: "Cannot scroll to the '{0}' date because it does not exist on the current view",
  W1009: "Searching works only if data is specified using the dataSource option",
  W1010: "The capability to select all items works with source data of plain structure only",
  W1011: 'The "keyExpr" option is not applied when dataSource is not an array',
  W1012: "The '{0}' key field is not found in data objects",
  W1013: 'The "message" field in the dialog component was renamed to "messageHtml". Change your code correspondingly. In addition, if you used HTML code in the message, make sure that it is secure',
  W1014: "The Floating Action Button exceeds the recommended speed dial action count. If you need to display more speed dial actions, increase the maxSpeedDialActionCount option value in the global config.",
  W1016: "The '{0}' field in the HTML Editor toolbar item configuration was renamed to '{1}'. Please make a corresponding change in your code.",
  W1017: "The 'key' property is not specified for a lookup data source. Please specify it to prevent requests for the entire dataset when users filter data.",
  W1018: "Infinite scrolling may not work properly with multiple selection. To use these features together, set 'selection.deferred' to true or set 'selection.selectAllMode' to 'page'.",
  W1019: "Filter query string exceeds maximum length limit of {0} characters.",
  W1020: "hideEvent is ignored when the shading property is true",
  W1021: `The '{0}' is not rendered because none of the DOM elements match the value of the "container" property.`,
  W1022: "{0} JSON parsing error: '{1}'",
  W1023: "Appointments require unique keys. Otherwise, the agenda view may not work correctly.",
  W1024: "The client-side export is enabled. Implement the 'onExporting' function.",
  W1025: "'scrolling.mode' is set to 'virtual' or 'infinite'. Specify the height of the component."
});

// ../../../../../../node_modules/devextreme/esm/core/action.js
var Action = class _Action {
  constructor(action, config3) {
    config3 = config3 || {};
    this._action = action;
    this._context = config3.context || getWindow();
    this._beforeExecute = config3.beforeExecute;
    this._afterExecute = config3.afterExecute;
    this._component = config3.component;
    this._validatingTargetName = config3.validatingTargetName;
    const excludeValidators = this._excludeValidators = {};
    if (config3.excludeValidators) {
      for (let i = 0; i < config3.excludeValidators.length; i++) {
        excludeValidators[config3.excludeValidators[i]] = true;
      }
    }
  }
  execute() {
    const e = {
      action: this._action,
      args: Array.prototype.slice.call(arguments),
      context: this._context,
      component: this._component,
      validatingTargetName: this._validatingTargetName,
      cancel: false,
      handled: false
    };
    const beforeExecute = this._beforeExecute;
    const afterExecute = this._afterExecute;
    const argsBag = e.args[0] || {};
    if (!this._validateAction(e)) {
      return;
    }
    null === beforeExecute || void 0 === beforeExecute || beforeExecute.call(this._context, e);
    if (e.cancel) {
      return;
    }
    const result2 = this._executeAction(e);
    if (argsBag.cancel) {
      return;
    }
    null === afterExecute || void 0 === afterExecute || afterExecute.call(this._context, e);
    return result2;
  }
  _validateAction(e) {
    const excludeValidators = this._excludeValidators;
    const {
      executors
    } = _Action;
    for (const name2 in executors) {
      if (!excludeValidators[name2]) {
        var _executor$validate;
        const executor = executors[name2];
        null === (_executor$validate = executor.validate) || void 0 === _executor$validate || _executor$validate.call(executor, e);
        if (e.cancel) {
          return false;
        }
      }
    }
    return true;
  }
  _executeAction(e) {
    let result2;
    const {
      executors
    } = _Action;
    for (const name2 in executors) {
      var _executor$execute;
      const executor = executors[name2];
      null === (_executor$execute = executor.execute) || void 0 === _executor$execute || _executor$execute.call(executor, e);
      if (e.handled) {
        result2 = e.result;
        break;
      }
    }
    return result2;
  }
  static registerExecutor(name2, executor) {
    if (isPlainObject(name2)) {
      each(name2, _Action.registerExecutor);
      return;
    }
    _Action.executors[name2] = executor;
  }
  static unregisterExecutor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    each(args, function() {
      delete _Action.executors[this];
    });
  }
};
Action.executors = {};
var createValidatorByTargetElement = (condition) => (e) => {
  if (!e.args.length) {
    return;
  }
  const args = e.args[0];
  const element = args[e.validatingTargetName] || args.element;
  if (element && condition(renderer_default(element))) {
    e.cancel = true;
  }
};
Action.registerExecutor({
  disabled: {
    validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-disabled, .dx-state-disabled *"))
  },
  readOnly: {
    validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-readonly, .dx-state-readonly *:not(.dx-state-independent)"))
  },
  undefined: {
    execute: (e) => {
      if (!e.action) {
        e.result = void 0;
        e.handled = true;
      }
    }
  },
  func: {
    execute: (e) => {
      if (isFunction(e.action)) {
        e.result = e.action.call(e.context, e.args[0]);
        e.handled = true;
      }
    }
  }
});

// ../../../../../../node_modules/devextreme/esm/core/utils/comparator.js
var hasNegation = function(oldValue, newValue) {
  return 1 / oldValue === 1 / newValue;
};
var equals = function(oldValue, newValue) {
  oldValue = toComparable(oldValue, true);
  newValue = toComparable(newValue, true);
  if (oldValue && newValue && isRenderer(oldValue) && isRenderer(newValue)) {
    return newValue.is(oldValue);
  }
  const oldValueIsNaN = oldValue !== oldValue;
  const newValueIsNaN = newValue !== newValue;
  if (oldValueIsNaN && newValueIsNaN) {
    return true;
  }
  if (0 === oldValue && 0 === newValue) {
    return hasNegation(oldValue, newValue);
  }
  if (null === oldValue || "object" !== typeof oldValue || dom_adapter_default.isElementNode(oldValue)) {
    return oldValue === newValue;
  }
  return false;
};

// ../../../../../../node_modules/devextreme/esm/core/options/utils.js
var cachedGetters = {};
var convertRulesToOptions = (rules) => {
  const currentDevice = devices_default.current();
  return rules.reduce((options2, _ref) => {
    let {
      device,
      options: ruleOptions
    } = _ref;
    const deviceFilter = device || {};
    const match2 = isFunction(deviceFilter) ? deviceFilter(currentDevice) : deviceMatch(currentDevice, deviceFilter);
    if (match2) {
      extend(true, options2, ruleOptions);
    }
    return options2;
  }, {});
};
var normalizeOptions = (options2, value2) => "string" !== typeof options2 ? options2 : {
  [options2]: value2
};
var deviceMatch = (device, filter) => isEmptyObject(filter) || findBestMatches(device, [filter]).length > 0;
var getFieldName = (fullName) => fullName.substr(fullName.lastIndexOf(".") + 1);
var getParentName = (fullName) => fullName.substr(0, fullName.lastIndexOf("."));
var getNestedOptionValue = function(optionsObject, name2) {
  cachedGetters[name2] = cachedGetters[name2] || compileGetter(name2);
  return cachedGetters[name2](optionsObject, {
    functionsAsIs: true
  });
};
var createDefaultOptionRules = function() {
  let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  return options2;
};

// ../../../../../../node_modules/devextreme/esm/core/options/option_manager.js
var cachedGetters2 = {};
var cachedSetters = {};
var OptionManager = class {
  constructor(options2, optionsByReference) {
    this._options = options2;
    this._optionsByReference = optionsByReference;
    this._changingCallback;
    this._changedCallback;
    this._namePreparedCallbacks;
  }
  _setByReference(options2, rulesOptions) {
    extend(true, options2, rulesOptions);
    for (const fieldName in this._optionsByReference) {
      if (Object.prototype.hasOwnProperty.call(rulesOptions, fieldName)) {
        options2[fieldName] = rulesOptions[fieldName];
      }
    }
  }
  _setPreparedValue(name2, value2, merge, silent) {
    const previousValue = this.get(this._options, name2, false);
    if (!equals(previousValue, value2)) {
      const path = getPathParts(name2);
      !silent && this._changingCallback(name2, previousValue, value2);
      cachedSetters[name2] = cachedSetters[name2] || compileSetter(name2);
      cachedSetters[name2](this._options, value2, {
        functionsAsIs: true,
        merge: isDefined(merge) ? merge : !this._optionsByReference[name2],
        unwrapObservables: path.length > 1 && !!this._optionsByReference[path[0]]
      });
      !silent && this._changedCallback(name2, value2, previousValue);
    }
  }
  _prepareRelevantNames(options2, name2, value2, silent) {
    if (isPlainObject(value2)) {
      for (const valueName in value2) {
        this._prepareRelevantNames(options2, `${name2}.${valueName}`, value2[valueName]);
      }
    }
    this._namePreparedCallbacks(options2, name2, value2, silent);
  }
  get() {
    let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._options;
    let name2 = arguments.length > 1 ? arguments[1] : void 0;
    let unwrapObservables = arguments.length > 2 ? arguments[2] : void 0;
    cachedGetters2[name2] = cachedGetters2[name2] || compileGetter(name2);
    return cachedGetters2[name2](options2, {
      functionsAsIs: true,
      unwrapObservables
    });
  }
  set(options2, value2, merge, silent) {
    options2 = normalizeOptions(options2, value2);
    for (const name2 in options2) {
      this._prepareRelevantNames(options2, name2, options2[name2], silent);
    }
    for (const name2 in options2) {
      this._setPreparedValue(name2, options2[name2], merge, silent);
    }
  }
  onRelevantNamesPrepared(callBack) {
    this._namePreparedCallbacks = callBack;
  }
  onChanging(callBack) {
    this._changingCallback = callBack;
  }
  onChanged(callBack) {
    this._changedCallback = callBack;
  }
  dispose() {
    this._changingCallback = noop2;
    this._changedCallback = noop2;
  }
};

// ../../../../../../node_modules/devextreme/esm/core/options/index.js
var Options = class {
  constructor(options2, defaultOptions3, optionsByReference, deprecatedOptions) {
    this._deprecatedCallback;
    this._startChangeCallback;
    this._endChangeCallback;
    this._default = defaultOptions3;
    this._deprecated = deprecatedOptions;
    this._deprecatedNames = [];
    this._initDeprecatedNames();
    this._optionManager = new OptionManager(options2, optionsByReference);
    this._optionManager.onRelevantNamesPrepared((options3, name2, value2, silent) => this._setRelevantNames(options3, name2, value2, silent));
    this._cachedOptions = {};
    this._rules = [];
  }
  set _initial(value2) {
    this._initialOptions = value2;
  }
  get _initial() {
    if (!this._initialOptions) {
      const rulesOptions = this._getByRules(this.silent("defaultOptionsRules"));
      this._initialOptions = this._default;
      this._optionManager._setByReference(this._initialOptions, rulesOptions);
    }
    return this._initialOptions;
  }
  _initDeprecatedNames() {
    for (const optionName in this._deprecated) {
      this._deprecatedNames.push(optionName);
    }
  }
  _getByRules(rules) {
    rules = Array.isArray(rules) ? this._rules.concat(rules) : this._rules;
    return convertRulesToOptions(rules);
  }
  _notifyDeprecated(option) {
    const info = this._deprecated[option];
    if (info) {
      this._deprecatedCallback(option, info);
    }
  }
  _setRelevantNames(options2, name2, value2, silent) {
    if (name2) {
      const normalizedName = this._normalizeName(name2, silent);
      if (normalizedName && normalizedName !== name2) {
        this._setField(options2, normalizedName, value2);
        this._clearField(options2, name2);
      }
    }
  }
  _setField(options2, fullName, value2) {
    let fieldName = "";
    let fieldObject = null;
    do {
      fieldName = fieldName ? `.${fieldName}` : "";
      fieldName = getFieldName(fullName) + fieldName;
      fullName = getParentName(fullName);
      fieldObject = fullName ? this._optionManager.get(options2, fullName, false) : options2;
    } while (!fieldObject);
    fieldObject[fieldName] = value2;
  }
  _clearField(options2, name2) {
    delete options2[name2];
    const previousFieldName = getParentName(name2);
    const fieldObject = previousFieldName ? this._optionManager.get(options2, previousFieldName, false) : options2;
    if (fieldObject) {
      delete fieldObject[getFieldName(name2)];
    }
  }
  _normalizeName(name2, silent) {
    if (this._deprecatedNames.length && name2) {
      for (let i = 0; i < this._deprecatedNames.length; i++) {
        if (this._deprecatedNames[i] === name2) {
          const deprecate = this._deprecated[name2];
          if (deprecate) {
            !silent && this._notifyDeprecated(name2);
            return deprecate.alias || name2;
          }
        }
      }
    }
    return name2;
  }
  addRules(rules) {
    this._rules = rules.concat(this._rules);
  }
  applyRules(rules) {
    const options2 = this._getByRules(rules);
    this.silent(options2);
  }
  dispose() {
    this._deprecatedCallback = noop2;
    this._startChangeCallback = noop2;
    this._endChangeCallback = noop2;
    this._optionManager.dispose();
  }
  onChanging(callBack) {
    this._optionManager.onChanging(callBack);
  }
  onChanged(callBack) {
    this._optionManager.onChanged(callBack);
  }
  onDeprecated(callBack) {
    this._deprecatedCallback = callBack;
  }
  onStartChange(callBack) {
    this._startChangeCallback = callBack;
  }
  onEndChange(callBack) {
    this._endChangeCallback = callBack;
  }
  isInitial(name2) {
    const value2 = this.silent(name2);
    const initialValue = this.initial(name2);
    const areFunctions = isFunction(value2) && isFunction(initialValue);
    return areFunctions ? value2.toString() === initialValue.toString() : equalByValue(value2, initialValue);
  }
  initial(name2) {
    return getNestedOptionValue(this._initial, name2);
  }
  option(options2, value2) {
    const isGetter = arguments.length < 2 && "object" !== type(options2);
    if (isGetter) {
      return this._optionManager.get(void 0, this._normalizeName(options2));
    } else {
      this._startChangeCallback();
      try {
        this._optionManager.set(options2, value2);
      } finally {
        this._endChangeCallback();
      }
    }
  }
  silent(options2, value2) {
    const isGetter = arguments.length < 2 && "object" !== type(options2);
    if (isGetter) {
      return this._optionManager.get(void 0, options2, void 0, true);
    } else {
      this._optionManager.set(options2, value2, void 0, true);
    }
  }
  reset(name2) {
    if (name2) {
      const fullPath = getPathParts(name2);
      const value2 = fullPath.reduce((value3, field) => value3 ? value3[field] : this.initial(field), null);
      const defaultValue = isObject(value2) ? _extends({}, value2) : value2;
      this._optionManager.set(name2, defaultValue, false);
    }
  }
  getAliasesByName(name2) {
    return Object.keys(this._deprecated).filter((aliasName) => name2 === this._deprecated[aliasName].alias);
  }
  isDeprecated(name2) {
    return Object.prototype.hasOwnProperty.call(this._deprecated, name2);
  }
  cache(name2, options2) {
    const isGetter = arguments.length < 2;
    if (isGetter) {
      return this._cachedOptions[name2];
    } else {
      this._cachedOptions[name2] = extend(this._cachedOptions[name2], options2);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/core/postponed_operations.js
var PostponedOperations = class {
  constructor() {
    this._postponedOperations = {};
  }
  add(key, fn, postponedPromise) {
    if (key in this._postponedOperations) {
      postponedPromise && this._postponedOperations[key].promises.push(postponedPromise);
    } else {
      const completePromise = new Deferred();
      this._postponedOperations[key] = {
        fn,
        completePromise,
        promises: postponedPromise ? [postponedPromise] : []
      };
    }
    return this._postponedOperations[key].completePromise.promise();
  }
  callPostponedOperations() {
    for (const key in this._postponedOperations) {
      const operation = this._postponedOperations[key];
      if (isDefined(operation)) {
        if (operation.promises && operation.promises.length) {
          when(...operation.promises).done(operation.fn).then(operation.completePromise.resolve);
        } else {
          operation.fn().done(operation.completePromise.resolve);
        }
      }
    }
    this._postponedOperations = {};
  }
};

// ../../../../../../node_modules/devextreme/esm/core/component.js
var getEventName = (actionName) => actionName.charAt(2).toLowerCase() + actionName.substr(3);
var isInnerOption = (optionName) => 0 === optionName.indexOf("_", 0);
var Component = class_default.inherit({
  _setDeprecatedOptions() {
    this._deprecatedOptions = {};
  },
  _getDeprecatedOptions() {
    return this._deprecatedOptions;
  },
  _getDefaultOptions: () => ({
    onInitialized: null,
    onOptionChanged: null,
    onDisposing: null,
    defaultOptionsRules: null
  }),
  _defaultOptionsRules: () => [],
  _setOptionsByDevice(rules) {
    this._options.applyRules(rules);
  },
  _convertRulesToOptions: (rules) => convertRulesToOptions(rules),
  _isInitialOptionValue(name2) {
    return this._options.isInitial(name2);
  },
  _setOptionsByReference() {
    this._optionsByReference = {};
  },
  _getOptionsByReference() {
    return this._optionsByReference;
  },
  ctor() {
    let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const {
      _optionChangedCallbacks,
      _disposingCallbacks
    } = options2;
    this.NAME = getName(this.constructor);
    this._eventsStrategy = EventsStrategy.create(this, options2.eventsStrategy);
    this._updateLockCount = 0;
    this._optionChangedCallbacks = _optionChangedCallbacks || callbacks_default();
    this._disposingCallbacks = _disposingCallbacks || callbacks_default();
    this.postponedOperations = new PostponedOperations();
    this._createOptions(options2);
  },
  _createOptions(options2) {
    this.beginUpdate();
    try {
      this._setOptionsByReference();
      this._setDeprecatedOptions();
      this._options = new Options(this._getDefaultOptions(), this._getDefaultOptions(), this._getOptionsByReference(), this._getDeprecatedOptions());
      this._options.onChanging((name2, previousValue, value2) => this._initialized && this._optionChanging(name2, previousValue, value2));
      this._options.onDeprecated((option, info) => this._logDeprecatedOptionWarning(option, info));
      this._options.onChanged((name2, value2, previousValue) => this._notifyOptionChanged(name2, value2, previousValue));
      this._options.onStartChange(() => this.beginUpdate());
      this._options.onEndChange(() => this.endUpdate());
      this._options.addRules(this._defaultOptionsRules());
      if (options2 && options2.onInitializing) {
        options2.onInitializing.apply(this, [options2]);
      }
      this._setOptionsByDevice(options2.defaultOptionsRules);
      this._initOptions(options2);
    } finally {
      this.endUpdate();
    }
  },
  _initOptions(options2) {
    this.option(options2);
  },
  _init() {
    this._createOptionChangedAction();
    this.on("disposing", (args) => {
      this._disposingCallbacks.fireWith(this, [args]);
    });
  },
  _logDeprecatedOptionWarning(option, info) {
    const message = info.message || `Use the '${info.alias}' option instead`;
    errors_default.log("W0001", this.NAME, option, info.since, message);
  },
  _logDeprecatedComponentWarning(since, alias) {
    errors_default.log("W0000", this.NAME, since, `Use the '${alias}' widget instead`);
  },
  _createOptionChangedAction() {
    this._optionChangedAction = this._createActionByOption("onOptionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _createDisposingAction() {
    this._disposingAction = this._createActionByOption("onDisposing", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _optionChanged(args) {
    switch (args.name) {
      case "onDisposing":
      case "onInitialized":
      case "defaultOptionsRules":
        break;
      case "onOptionChanged":
        this._createOptionChangedAction();
    }
  },
  _dispose() {
    this._optionChangedCallbacks.empty();
    this._createDisposingAction();
    this._disposingAction();
    this._eventsStrategy.dispose();
    this._options.dispose();
    this._disposed = true;
  },
  _lockUpdate() {
    this._updateLockCount++;
  },
  _unlockUpdate() {
    this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
  },
  _isUpdateAllowed() {
    return 0 === this._updateLockCount;
  },
  _isInitializingRequired() {
    return !this._initializing && !this._initialized;
  },
  isInitialized() {
    return this._initialized;
  },
  _commitUpdate() {
    this.postponedOperations.callPostponedOperations();
    this._isInitializingRequired() && this._initializeComponent();
  },
  _initializeComponent() {
    this._initializing = true;
    try {
      this._init();
    } finally {
      this._initializing = false;
      this._lockUpdate();
      this._createActionByOption("onInitialized", {
        excludeValidators: ["disabled", "readOnly"]
      })();
      this._unlockUpdate();
      this._initialized = true;
    }
  },
  instance() {
    return this;
  },
  beginUpdate: function() {
    this._lockUpdate();
  },
  endUpdate: function() {
    this._unlockUpdate();
    this._isUpdateAllowed() && this._commitUpdate();
  },
  _optionChanging: noop2,
  _notifyOptionChanged(option, value2, previousValue) {
    if (this._initialized) {
      const optionNames = [option].concat(this._options.getAliasesByName(option));
      for (let i = 0; i < optionNames.length; i++) {
        const name2 = optionNames[i];
        const args = {
          name: getPathParts(name2)[0],
          fullName: name2,
          value: value2,
          previousValue
        };
        if (!isInnerOption(name2)) {
          this._optionChangedCallbacks.fireWith(this, [extend(this._defaultActionArgs(), args)]);
          this._optionChangedAction(extend({}, args));
        }
        if (!this._disposed && this._cancelOptionChange !== name2) {
          this._optionChanged(args);
        }
      }
    }
  },
  initialOption(name2) {
    return this._options.initial(name2);
  },
  _defaultActionConfig() {
    return {
      context: this,
      component: this
    };
  },
  _defaultActionArgs() {
    return {
      component: this
    };
  },
  _createAction(actionSource, config3) {
    let action;
    return (e) => {
      if (!isDefined(e)) {
        e = {};
      }
      if (!isPlainObject(e)) {
        e = {
          actionValue: e
        };
      }
      action = action || new Action(actionSource, extend({}, config3, this._defaultActionConfig()));
      return action.execute.call(action, extend(e, this._defaultActionArgs()));
    };
  },
  _createActionByOption(optionName, config3) {
    var _this = this;
    let action;
    let eventName;
    let actionFunc;
    config3 = extend({}, config3);
    const result2 = function() {
      if (!eventName) {
        config3 = config3 || {};
        if ("string" !== typeof optionName) {
          throw errors_default.Error("E0008");
        }
        if (0 === optionName.indexOf("on")) {
          eventName = getEventName(optionName);
        }
        actionFunc = _this.option(optionName);
      }
      if (!action && !actionFunc && !config3.beforeExecute && !config3.afterExecute && !_this._eventsStrategy.hasEvent(eventName)) {
        return;
      }
      if (!action) {
        const beforeExecute = config3.beforeExecute;
        config3.beforeExecute = function() {
          for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            props[_key2] = arguments[_key2];
          }
          beforeExecute && beforeExecute.apply(_this, props);
          _this._eventsStrategy.fireEvent(eventName, props[0].args);
        };
        action = _this._createAction(actionFunc, config3);
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (config_default().wrapActionsBeforeExecute) {
        const beforeActionExecute = _this.option("beforeActionExecute") || noop2;
        const wrappedAction = beforeActionExecute(_this, action, config3) || action;
        return wrappedAction.apply(_this, args);
      }
      return action.apply(_this, args);
    };
    if (config_default().wrapActionsBeforeExecute) {
      return result2;
    }
    const onActionCreated = this.option("onActionCreated") || noop2;
    return onActionCreated(this, result2, config3) || result2;
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  },
  hasActionSubscription: function(actionName) {
    return !!this._options.silent(actionName) || this._eventsStrategy.hasEvent(getEventName(actionName));
  },
  isOptionDeprecated(name2) {
    return this._options.isDeprecated(name2);
  },
  _setOptionWithoutOptionChange(name2, value2) {
    this._cancelOptionChange = name2;
    this.option(name2, value2);
    this._cancelOptionChange = false;
  },
  _getOptionValue(name2, context2) {
    const value2 = this.option(name2);
    if (isFunction(value2)) {
      return value2.bind(context2)();
    }
    return value2;
  },
  option() {
    return this._options.option(...arguments);
  },
  resetOption(name2) {
    this.beginUpdate();
    this._options.reset(name2);
    this.endUpdate();
  }
});

// ../../../../../../node_modules/devextreme/esm/core/templates/function_template.js
var FunctionTemplate = class extends TemplateBase {
  constructor(render4) {
    super();
    this._render = render4;
  }
  _renderCore(options2) {
    return normalizeTemplateElement(this._render(options2));
  }
};

// ../../../../../../node_modules/devextreme/esm/core/templates/child_default_template.js
var ChildDefaultTemplate = class extends TemplateBase {
  constructor(name2) {
    super();
    this.name = name2;
  }
};

// ../../../../../../node_modules/devextreme/esm/core/templates/template_engine_registry.js
var templateEngines = {};
var currentTemplateEngine;
function registerTemplateEngine(name2, templateEngine) {
  templateEngines[name2] = templateEngine;
}
function setTemplateEngine(templateEngine) {
  if (isString(templateEngine)) {
    currentTemplateEngine = templateEngines[templateEngine];
    if (!currentTemplateEngine) {
      throw errors_default.Error("E0020", templateEngine);
    }
  } else {
    currentTemplateEngine = templateEngine;
  }
}
function getCurrentTemplateEngine() {
  return currentTemplateEngine;
}

// ../../../../../../node_modules/devextreme/esm/core/templates/template.js
registerTemplateEngine("default", {
  compile: (element) => normalizeTemplateElement(element),
  render: (template, model, index2) => template.clone()
});
setTemplateEngine("default");
var Template = class extends TemplateBase {
  constructor(element) {
    super();
    this._element = element;
  }
  _renderCore(options2) {
    const transclude = options2.transclude;
    if (!transclude && !this._compiledTemplate) {
      this._compiledTemplate = getCurrentTemplateEngine().compile(this._element);
    }
    return renderer_default("<div>").append(transclude ? this._element : getCurrentTemplateEngine().render(this._compiledTemplate, options2.model, options2.index)).contents();
  }
  source() {
    return renderer_default(this._element).clone();
  }
};

// ../../../../../../node_modules/devextreme/esm/core/utils/template_manager.js
var findTemplates = (element, name2) => {
  const templates = renderer_default(element).contents().filter(`[data-options*="${name2}"]`);
  return [].slice.call(templates).map((element2) => {
    const optionsString = renderer_default(element2).attr("data-options") || "";
    return {
      element: element2,
      options: config_default().optionsParser(optionsString)[name2]
    };
  }).filter((template) => !!template.options);
};
var suitableTemplatesByName = (rawTemplates) => {
  const templatesMap = groupBy(rawTemplates, (template) => template.options.name);
  if (templatesMap[void 0]) {
    throw errors_default.Error("E0023");
  }
  const result2 = {};
  Object.keys(templatesMap).forEach((name2) => {
    var _findBestMatches$;
    const suitableTemplate = null === (_findBestMatches$ = findBestMatches(devices_default.current(), templatesMap[name2], (template) => template.options)[0]) || void 0 === _findBestMatches$ ? void 0 : _findBestMatches$.element;
    if (suitableTemplate) {
      result2[name2] = suitableTemplate;
    }
  });
  return result2;
};
var addOneRenderedCall = (template) => {
  const render4 = template.render.bind(template);
  return extend({}, template, {
    render(options2) {
      const templateResult = render4(options2);
      options2 && options2.onRendered && options2.onRendered();
      return templateResult;
    }
  });
};
var addPublicElementNormalization = (template) => {
  const render4 = template.render.bind(template);
  return extend({}, template, {
    render(options2) {
      const $container = renderer_default(options2.container);
      return render4(_extends({}, options2, {
        container: getPublicElement($container)
      }));
    }
  });
};
var getNormalizedTemplateArgs = (options2) => {
  const args = [];
  if ("model" in options2) {
    args.push(options2.model);
  }
  if ("index" in options2) {
    args.push(options2.index);
  }
  args.push(options2.container);
  return args;
};
var validateTemplateSource = (templateSource) => "string" === typeof templateSource ? normalizeTemplateElement(templateSource) : templateSource;
var templateKey = (templateSource) => isRenderer(templateSource) && templateSource[0] || templateSource;
var defaultCreateElement = (element) => new Template(element);
var acquireIntegrationTemplate = (templateSource, templates, isAsyncTemplate, skipTemplates) => {
  let integrationTemplate = null;
  if (!skipTemplates || -1 === skipTemplates.indexOf(templateSource)) {
    integrationTemplate = templates[templateSource];
    if (integrationTemplate && !(integrationTemplate instanceof TemplateBase)) {
      if (isFunction(integrationTemplate.render)) {
        integrationTemplate = addPublicElementNormalization(integrationTemplate);
      }
      if (!isAsyncTemplate) {
        integrationTemplate = addOneRenderedCall(integrationTemplate);
      }
    }
  }
  return integrationTemplate;
};
var acquireTemplate = (templateSource, createTemplate, templates, isAsyncTemplate, skipTemplates, defaultTemplates) => {
  if (null == templateSource) {
    return new EmptyTemplate();
  }
  if (templateSource instanceof ChildDefaultTemplate) {
    return defaultTemplates[templateSource.name];
  }
  if (templateSource instanceof TemplateBase) {
    return templateSource;
  }
  if (isFunction(templateSource.render) && !isRenderer(templateSource)) {
    return isAsyncTemplate ? templateSource : addOneRenderedCall(templateSource);
  }
  if (templateSource.nodeType || isRenderer(templateSource)) {
    return createTemplate(renderer_default(templateSource));
  }
  return acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) || defaultTemplates[templateSource] || createTemplate(templateSource);
};

// ../../../../../../node_modules/devextreme/esm/core/template_manager.js
var DX_POLYMORPH_WIDGET_TEMPLATE = new FunctionTemplate((_ref) => {
  let {
    model,
    parent
  } = _ref;
  const widgetName = model.widget;
  if (!widgetName) {
    return renderer_default();
  }
  const widgetElement = renderer_default("<div>");
  const widgetOptions = model.options || {};
  if (parent) {
    parent._createComponent(widgetElement, widgetName, widgetOptions);
  } else {
    widgetElement[widgetName](widgetOptions);
  }
  return widgetElement;
});
var TemplateManager = class {
  constructor(createElement2, anonymousTemplateName) {
    this._tempTemplates = [];
    this._defaultTemplates = {};
    this._anonymousTemplateName = anonymousTemplateName || "template";
    this._createElement = createElement2 || defaultCreateElement;
    this._createTemplateIfNeeded = this._createTemplateIfNeeded.bind(this);
  }
  static createDefaultOptions() {
    return {
      integrationOptions: {
        watchMethod: function(fn, callback) {
          let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          if (!options2.skipImmediate) {
            callback(fn());
          }
          return noop2;
        },
        templates: {
          "dx-polymorph-widget": DX_POLYMORPH_WIDGET_TEMPLATE
        },
        useDeferUpdateForTemplates: true
      }
    };
  }
  get anonymousTemplateName() {
    return this._anonymousTemplateName;
  }
  addDefaultTemplates(templates) {
    this._defaultTemplates = extend({}, this._defaultTemplates, templates);
  }
  dispose() {
    this._tempTemplates.forEach((tempTemplate) => {
      tempTemplate.template.dispose && tempTemplate.template.dispose();
    });
    this._tempTemplates = [];
  }
  extractTemplates($el) {
    const templates = this._extractTemplates($el);
    const anonymousTemplateMeta = this._extractAnonymousTemplate($el);
    return {
      templates,
      anonymousTemplateMeta
    };
  }
  _extractTemplates($el) {
    const templates = findTemplates($el, "dxTemplate");
    const suitableTemplates = suitableTemplatesByName(templates);
    templates.forEach((_ref2) => {
      let {
        element,
        options: {
          name: name2
        }
      } = _ref2;
      if (element === suitableTemplates[name2]) {
        renderer_default(element).addClass("dx-template-wrapper").detach();
      } else {
        renderer_default(element).remove();
      }
    });
    return Object.keys(suitableTemplates).map((name2) => ({
      name: name2,
      template: this._createTemplate(suitableTemplates[name2])
    }));
  }
  _extractAnonymousTemplate($el) {
    const $anonymousTemplate = $el.contents().detach();
    const $notJunkTemplateContent = $anonymousTemplate.filter((_, element) => {
      const isTextNode = 3 === element.nodeType;
      const isEmptyText = renderer_default(element).text().trim().length < 1;
      return !(isTextNode && isEmptyText);
    });
    return $notJunkTemplateContent.length > 0 ? {
      template: this._createTemplate($anonymousTemplate),
      name: this._anonymousTemplateName
    } : {};
  }
  _createTemplateIfNeeded(templateSource) {
    const cachedTemplate = this._tempTemplates.filter((tempTemplate) => tempTemplate.source === templateKey(templateSource))[0];
    if (cachedTemplate) {
      return cachedTemplate.template;
    }
    const template = this._createTemplate(templateSource);
    this._tempTemplates.push({
      template,
      source: templateKey(templateSource)
    });
    return template;
  }
  _createTemplate(templateSource) {
    return this._createElement(validateTemplateSource(templateSource));
  }
  getTemplate(templateSource, templates, _ref3, context2) {
    let {
      isAsyncTemplate,
      skipTemplates
    } = _ref3;
    if (!isFunction(templateSource)) {
      return acquireTemplate(templateSource, this._createTemplateIfNeeded, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
    }
    return new FunctionTemplate((options2) => {
      const templateSourceResult = templateSource.apply(context2, getNormalizedTemplateArgs(options2));
      if (!isDefined(templateSourceResult)) {
        return new EmptyTemplate();
      }
      let dispose = false;
      const template = acquireTemplate(templateSourceResult, (templateSource2) => {
        if (templateSource2.nodeType || isRenderer(templateSource2) && !renderer_default(templateSource2).is("script")) {
          return new FunctionTemplate(() => templateSource2);
        }
        dispose = true;
        return this._createTemplate(templateSource2);
      }, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
      const result2 = template.render(options2);
      dispose && template.dispose && template.dispose();
      return result2;
    });
  }
};

// ../../../../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r)
    return {};
  var t = {};
  for (var n in r)
    if ({}.hasOwnProperty.call(r, n)) {
      if (e.includes(n))
        continue;
      t[n] = r[n];
    }
  return t;
}

// ../../../../../../node_modules/devextreme/esm/__internal/utils/version.js
var assertedVersions = [];
var VERSION_SPLITTER = ".";
function stringifyVersion(version3) {
  const {
    major,
    minor,
    patch: patch2
  } = version3;
  return [major, minor, patch2].join(VERSION_SPLITTER);
}
function parseVersion(version3) {
  const [major, minor, patch2] = version3.split(".").map(Number);
  return {
    major,
    minor,
    patch: patch2
  };
}
function stringifyVersionList(assertedVersionList) {
  return assertedVersionList.map((assertedVersion) => `${assertedVersion.packageName}: ${assertedVersion.version}`).join("\n");
}
function versionsEqual(versionA, versionB) {
  return versionA.major === versionB.major && versionA.minor === versionB.minor && versionA.patch === versionB.patch;
}
function getPreviousMajorVersion(_ref) {
  let {
    major,
    minor,
    patch: patch2
  } = _ref;
  const previousMajorVersion = 1 === minor ? {
    major: major - 1,
    minor: 2,
    patch: patch2
  } : {
    major,
    minor: minor - 1,
    patch: patch2
  };
  return previousMajorVersion;
}
function assertedVersionsCompatible(currentVersion) {
  const mismatchingVersions = assertedVersions.filter((assertedVersion) => !versionsEqual(parseVersion(assertedVersion.version), currentVersion));
  if (mismatchingVersions.length) {
    errors_default.log("W0023", stringifyVersionList([{
      packageName: "devextreme",
      version: stringifyVersion(currentVersion)
    }, ...mismatchingVersions]));
    return false;
  }
  return true;
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/byte_utils.js
function base64ToBytes(base64) {
  return new Uint8Array(atob(base64).split("").map((s) => s.charCodeAt(0)));
}
function hexToBytes(string) {
  var _string$match;
  return new Uint8Array((null === (_string$match = string.match(/.{1,2}/g)) || void 0 === _string$match ? void 0 : _string$match.map((byte) => parseInt(byte, 16))) ?? []);
}
function stringToBytes(string) {
  const bytes = new Uint8Array(string.length);
  for (let k = 0; k < string.length; k += 1) {
    bytes[k] = 255 & string.charCodeAt(k);
  }
  return bytes;
}
function wordsToBytes(words) {
  const bytes = new Uint8Array(4 * words.length);
  for (let k = 0; k < bytes.length; k += 1) {
    bytes[k] = words[k >> 2] >>> 8 * (3 - k % 4);
  }
  return bytes;
}
function bytesToWords(bytes) {
  const words = new Uint32Array(1 + (bytes.length - 1 >> 2));
  for (let k = 0; k < bytes.length; k += 1) {
    words[k >> 2] |= bytes[k] << 8 * (3 - k % 4);
  }
  return words;
}
function leftRotate(x, n) {
  return (x << n | x >>> 32 - n) >>> 0;
}
function concatBytes(a, b) {
  const result2 = new Uint8Array(a.length + b.length);
  result2.set(a, 0);
  result2.set(b, a.length);
  return result2;
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/key.js
var PUBLIC_KEY = {
  e: 65537,
  n: new Uint8Array([200, 219, 153, 203, 140, 7, 228, 253, 193, 243, 62, 137, 139, 60, 68, 242, 48, 142, 113, 88, 185, 235, 253, 105, 80, 74, 32, 170, 96, 74, 111, 250, 7, 205, 154, 3, 146, 115, 153, 53, 45, 132, 123, 56, 61, 208, 184, 201, 63, 24, 109, 223, 0, 179, 169, 102, 139, 224, 73, 233, 45, 173, 138, 66, 98, 88, 69, 76, 177, 111, 113, 218, 192, 33, 101, 152, 25, 134, 34, 173, 32, 82, 230, 44, 247, 200, 253, 170, 192, 246, 30, 12, 96, 205, 100, 249, 181, 93, 0, 231])
};
var INTERNAL_USAGE_ID = "ppJtlS56r0az1kqUjWJs-g";

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/pkcs1.js
var ASN1_SHA1 = "3021300906052b0e03021a05000414";
function pad(hash) {
  const dataLength = (8 * PUBLIC_KEY.n.length + 6) / 8;
  const data2 = concatBytes(hexToBytes(ASN1_SHA1), hash);
  if (data2.length + 10 > dataLength) {
    throw Error("Key is too short for SHA1 signing algorithm");
  }
  const padding = new Uint8Array(dataLength - data2.length);
  padding.fill(255, 0, padding.length - 1);
  padding[0] = 0;
  padding[1] = 1;
  padding[padding.length - 1] = 0;
  return concatBytes(padding, data2);
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/rsa_bigint.js
function compareSignatures(args) {
  try {
    const zero = BigInt(0);
    const one2 = BigInt(1);
    const eight = BigInt(8);
    const modExp = (base2, exponent2, modulus2) => {
      let result2 = one2;
      let b = base2;
      let e = exponent2;
      while (e) {
        if (e & one2) {
          result2 = result2 * b % modulus2;
        }
        b = b * b % modulus2;
        e >>= one2;
      }
      return result2;
    };
    const bigIntFromBytes = (bytes) => bytes.reduce((acc, cur) => (acc << eight) + BigInt(cur), zero);
    const actual = bigIntFromBytes(args.actual);
    const signature = bigIntFromBytes(args.signature);
    const exponent = BigInt(args.key.e);
    const modulus = bigIntFromBytes(args.key.n);
    const expected = modExp(signature, exponent, modulus);
    return expected === actual;
  } catch {
    return true;
  }
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/sha1.js
function preprocess(text) {
  const bytes = new Uint8Array(text.length + 1);
  bytes.set(stringToBytes(text));
  bytes[bytes.length - 1] = 128;
  const words = bytesToWords(new Uint8Array(bytes));
  const result2 = new Uint32Array(16 * Math.ceil((words.length + 2) / 16));
  result2.set(words, 0);
  result2[result2.length - 1] = 8 * (bytes.length - 1);
  return result2;
}
function sha1(text) {
  const message = preprocess(text);
  const h2 = new Uint32Array([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
  for (let i = 0; i < message.length; i += 16) {
    const w = new Uint32Array(80);
    for (let j = 0; j < 16; j += 1) {
      w[j] = message[i + j];
    }
    for (let j = 16; j < 80; j += 1) {
      const n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
      w[j] = n << 1 | n >>> 31;
    }
    let a = h2[0];
    let b = h2[1];
    let c = h2[2];
    let d = h2[3];
    let e = h2[4];
    for (let j = 0; j < 80; j += 1) {
      const [f, k] = j < 20 ? [b & c | ~b & d, 1518500249] : j < 40 ? [b ^ c ^ d, 1859775393] : j < 60 ? [b & c | b & d | c & d, 2400959708] : [b ^ c ^ d, 3395469782];
      const temp = leftRotate(a, 5) + f + e + k + w[j];
      e = d;
      d = c;
      c = leftRotate(b, 30);
      b = a;
      a = temp;
    }
    h2[0] += a;
    h2[1] += b;
    h2[2] += c;
    h2[3] += d;
    h2[4] += e;
  }
  return wordsToBytes(h2);
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/trial_panel.client.js
var isClient = () => "undefined" !== typeof HTMLElement;
var SafeHTMLElement = isClient() ? HTMLElement : class {
};
var componentNames2 = {
  trigger: "dx-license-trigger",
  panel: "dx-license"
};
var attributeNames = {
  buyNow: "buy-now",
  version: "version"
};
var commonStyles = {
  opacity: "1",
  visibility: "visible",
  "clip-path": "none",
  filter: "none"
};
var contentStyles = _extends({}, commonStyles, {
  width: "100%",
  height: "auto",
  "line-height": "normal",
  display: "block",
  "z-index": "1500",
  position: "static",
  transform: "translate(0px, 0px)",
  "background-color": "#FF7200",
  border: "none",
  margin: "auto",
  "box-sizing": "border-box",
  "text-align": "center"
});
var containerStyles = _extends({}, contentStyles, {
  display: "flex",
  "align-items": "center",
  "flex-direction": "row",
  position: "relative",
  top: "0px",
  left: "0px",
  padding: "0.5rem"
});
var buttonStyles = {
  width: "1rem",
  cursor: "pointer",
  height: "1rem"
};
var textStyles = _extends({}, commonStyles, {
  display: "inline",
  position: "static",
  padding: "0px",
  margin: "0px",
  color: "white",
  "font-family": "'Segoe UI','Open Sans Condensed',-apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,Cantarell,Ubuntu,roboto,noto,arial,sans-serif",
  "font-size": "0.875rem",
  "font-wight": "600"
});
function createImportantStyles(defaultStyles, customStyles) {
  const styles = customStyles ? _extends({}, defaultStyles, customStyles) : defaultStyles;
  return Object.keys(styles).reduce((cssString, currentKey) => `${cssString}${[currentKey, `${styles[currentKey]} !important;`].join(": ")}`, "");
}
var DxLicense = class _DxLicense extends SafeHTMLElement {
  constructor() {
    var _DxLicense$customStyl, _DxLicense$customStyl2, _DxLicense$customStyl3, _DxLicense$customStyl4, _DxLicense$customStyl5;
    super();
    this._observer = null;
    this._inReassign = false;
    this._hidden = false;
    this._spanStyles = createImportantStyles(textStyles, null === (_DxLicense$customStyl = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl ? void 0 : _DxLicense$customStyl.textStyles);
    this._linkStyles = createImportantStyles(textStyles, null === (_DxLicense$customStyl2 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl2 ? void 0 : _DxLicense$customStyl2.linkStyles);
    this._containerStyles = createImportantStyles(containerStyles, null === (_DxLicense$customStyl3 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl3 ? void 0 : _DxLicense$customStyl3.containerStyles);
    this._contentStyles = createImportantStyles(contentStyles, null === (_DxLicense$customStyl4 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl4 ? void 0 : _DxLicense$customStyl4.contentStyles);
    this._buttonStyles = createImportantStyles(buttonStyles, null === (_DxLicense$customStyl5 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl5 ? void 0 : _DxLicense$customStyl5.contentStyles);
  }
  _createSpan(text) {
    const span = document.createElement("span");
    span.innerText = text;
    span.style.cssText = this._spanStyles;
    return span;
  }
  _createLink(text, href) {
    const link = document.createElement("a");
    link.innerText = text;
    link.style.cssText = this._linkStyles;
    link.href = href;
    link.target = "_blank";
    return link;
  }
  _createButton() {
    const button = document.createElement("div");
    button.style.cssText = this._buttonStyles;
    const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    polygon.setAttribute("points", "13.4 12.7 8.7 8 13.4 3.4 12.6 2.6 8 7.3 3.4 2.6 2.6 3.4 7.3 8 2.6 12.6 3.4 13.4 8 8.7 12.7 13.4 13.4 12.7");
    polygon.style.cssText = createImportantStyles({
      fill: "#fff",
      opacity: ".5",
      "stroke-width": "0px"
    });
    svg.setAttribute("id", "Layer_1");
    svg.setAttribute("data-name", "Layer 1");
    svg.setAttribute("version", "1.1");
    svg.setAttribute("viewBox", "0 0 16 16");
    svg.style.cssText = createImportantStyles({
      "vertical-align": "baseline"
    });
    svg.appendChild(polygon);
    button.appendChild(svg);
    button.onclick = () => {
      this._hidden = true;
      this.style.cssText = createImportantStyles({
        display: "none"
      });
    };
    return button;
  }
  _createContentContainer() {
    const contentContainer = document.createElement("div");
    contentContainer.style.cssText = this._contentStyles;
    contentContainer.append(this._createSpan("For evaluation purposes only. Redistribution not authorized. Please "), this._createLink("purchase a license", this.getAttribute(attributeNames.buyNow)), this._createSpan(` to continue use of DevExpress product libraries (v${this.getAttribute(attributeNames.version)}).`));
    return contentContainer;
  }
  _reassignComponent() {
    this.innerHTML = "";
    this.style.cssText = this._containerStyles;
    this.append(this._createContentContainer(), this._createButton());
  }
  connectedCallback() {
    this._reassignComponent();
    if (!this._observer) {
      this._observer = new MutationObserver(() => {
        if (this._hidden) {
          var _this$_observer;
          null === (_this$_observer = this._observer) || void 0 === _this$_observer || _this$_observer.disconnect();
          return;
        }
        if (this._inReassign) {
          this._inReassign = false;
        } else {
          this._inReassign = true;
          this._reassignComponent();
        }
      });
      this._observer.observe(this, {
        childList: true,
        attributes: true,
        subtree: true
      });
    }
  }
  disconnectedCallback() {
    setTimeout(() => {
      const licensePanel = document.getElementsByTagName(componentNames2.panel);
      if (!licensePanel.length) {
        document.body.prepend(this);
      }
    }, 100);
  }
};
DxLicense.customStyles = void 0;
var DxLicenseTrigger = class extends SafeHTMLElement {
  connectedCallback() {
    this.style.cssText = createImportantStyles({
      display: "none"
    });
    const licensePanel = document.getElementsByTagName(componentNames2.panel);
    if (!licensePanel.length) {
      const license = document.createElement(componentNames2.panel);
      license.setAttribute(attributeNames.version, this.getAttribute(attributeNames.version));
      license.setAttribute(attributeNames.buyNow, this.getAttribute(attributeNames.buyNow));
      license.setAttribute("data-permanent", "true");
      document.body.prepend(license);
    }
  }
};
function registerCustomComponents(customStyles) {
  if (!customElements.get(componentNames2.trigger)) {
    DxLicense.customStyles = customStyles;
    customElements.define(componentNames2.trigger, DxLicenseTrigger);
    customElements.define(componentNames2.panel, DxLicense);
  }
}
function renderTrialPanel(buyNowUrl, version3, customStyles) {
  registerCustomComponents(customStyles);
  const trialPanelTrigger = document.createElement(componentNames2.trigger);
  trialPanelTrigger.setAttribute(attributeNames.buyNow, buyNowUrl);
  trialPanelTrigger.setAttribute(attributeNames.version, version3);
  document.body.appendChild(trialPanelTrigger);
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/trial_panel.js
function showTrialPanel(buyNowUrl, version3, customStyles) {
  if (isClient()) {
    renderTrialPanel(buyNowUrl, version3, customStyles);
  }
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/types.js
var TokenKind;
!function(TokenKind2) {
  TokenKind2.corrupted = "corrupted";
  TokenKind2.verified = "verified";
  TokenKind2.internal = "internal";
}(TokenKind || (TokenKind = {}));

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/license_validation.js
var _excluded = ["customerId", "maxVersionAllowed", "format", "internalUsageId"];
var FORMAT = 1;
var RTM_MIN_PATCH_VERSION = 3;
var KEY_SPLITTER = ".";
var BUY_NOW_LINK = "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeJQuery.aspx";
var GENERAL_ERROR = {
  kind: TokenKind.corrupted,
  error: "general"
};
var VERIFICATION_ERROR = {
  kind: TokenKind.corrupted,
  error: "verification"
};
var DECODING_ERROR = {
  kind: TokenKind.corrupted,
  error: "decoding"
};
var DESERIALIZATION_ERROR = {
  kind: TokenKind.corrupted,
  error: "deserialization"
};
var PAYLOAD_ERROR = {
  kind: TokenKind.corrupted,
  error: "payload"
};
var VERSION_ERROR = {
  kind: TokenKind.corrupted,
  error: "version"
};
var validationPerformed = false;
function verifySignature(_ref) {
  let {
    text,
    signature: encodedSignature
  } = _ref;
  return compareSignatures({
    key: PUBLIC_KEY,
    signature: base64ToBytes(encodedSignature),
    actual: pad(sha1(text))
  });
}
function parseLicenseKey(encodedKey) {
  if (void 0 === encodedKey) {
    return GENERAL_ERROR;
  }
  const parts = encodedKey.split(KEY_SPLITTER);
  if (2 !== parts.length || 0 === parts[0].length || 0 === parts[1].length) {
    return GENERAL_ERROR;
  }
  if (!verifySignature({
    text: parts[0],
    signature: parts[1]
  })) {
    return VERIFICATION_ERROR;
  }
  let decodedPayload = "";
  try {
    decodedPayload = atob(parts[0]);
  } catch {
    return DECODING_ERROR;
  }
  let payload = {};
  try {
    payload = JSON.parse(decodedPayload);
  } catch {
    return DESERIALIZATION_ERROR;
  }
  const {
    customerId,
    maxVersionAllowed,
    format: format2,
    internalUsageId
  } = payload, rest = _objectWithoutPropertiesLoose(payload, _excluded);
  if (void 0 !== internalUsageId) {
    return {
      kind: TokenKind.internal,
      internalUsageId
    };
  }
  if (void 0 === customerId || void 0 === maxVersionAllowed || void 0 === format2) {
    return PAYLOAD_ERROR;
  }
  if (format2 !== FORMAT) {
    return VERSION_ERROR;
  }
  return {
    kind: TokenKind.verified,
    payload: _extends({
      customerId,
      maxVersionAllowed
    }, rest)
  };
}
function isPreview(patch2) {
  return isNaN(patch2) || patch2 < RTM_MIN_PATCH_VERSION;
}
function getLicenseCheckParams(_ref2) {
  let {
    licenseKey,
    version: version3
  } = _ref2;
  let preview = false;
  try {
    preview = isPreview(version3.patch);
    const {
      major,
      minor
    } = preview ? getPreviousMajorVersion(version3) : version3;
    if (!licenseKey) {
      return {
        preview,
        error: "W0019"
      };
    }
    const license = parseLicenseKey(licenseKey);
    if (license.kind === TokenKind.corrupted) {
      return {
        preview,
        error: "W0021"
      };
    }
    if (license.kind === TokenKind.internal) {
      return {
        preview,
        internal: true,
        error: license.internalUsageId === INTERNAL_USAGE_ID ? void 0 : "W0020"
      };
    }
    if (!(major && minor)) {
      return {
        preview,
        error: "W0021"
      };
    }
    if (10 * major + minor > license.payload.maxVersionAllowed) {
      return {
        preview,
        error: "W0020"
      };
    }
    return {
      preview,
      error: void 0
    };
  } catch {
    return {
      preview,
      error: "W0021"
    };
  }
}
function validateLicense(licenseKey) {
  let versionStr = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : fullVersion;
  if (validationPerformed) {
    return;
  }
  validationPerformed = true;
  const version3 = parseVersion(versionStr);
  const versionsCompatible = assertedVersionsCompatible(version3);
  const {
    internal,
    error
  } = getLicenseCheckParams({
    licenseKey,
    version: version3
  });
  if (!versionsCompatible && internal) {
    return;
  }
  if (error && !internal) {
    showTrialPanel(config_default().buyNowLink ?? BUY_NOW_LINK, fullVersion);
  }
  const preview = isPreview(version3.patch);
  if (error) {
    errors_default.log(preview ? "W0022" : error);
    return;
  }
  if (preview && !internal) {
    errors_default.log("W0022");
  }
}
function peekValidationPerformed() {
  return validationPerformed;
}
var license_validation_default = {
  validateLicense
};

// ../../../../../../node_modules/devextreme/esm/core/dom_component.js
var {
  abstract: abstract2
} = Component;
var DOMComponent = Component.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      width: void 0,
      height: void 0,
      rtlEnabled: config_default().rtlEnabled,
      elementAttr: {},
      disabled: false,
      integrationOptions: {}
    }, this._useTemplates() ? TemplateManager.createDefaultOptions() : {});
  },
  ctor(element, options2) {
    this._customClass = null;
    this._createElement(element);
    attachInstanceToElement(this._$element, this, this._dispose);
    this.callBase(options2);
    const validationAlreadyPerformed = peekValidationPerformed();
    license_validation_default.validateLicense(config_default().licenseKey);
    if (!validationAlreadyPerformed && peekValidationPerformed()) {
      config_default({
        licenseKey: ""
      });
    }
  },
  _createElement(element) {
    this._$element = renderer_default(element);
  },
  _getSynchronizableOptionsForCreateComponent: () => ["rtlEnabled", "disabled", "templatesRenderAsynchronously"],
  _checkFunctionValueDeprecation: function(optionNames) {
    if (!this.option("_ignoreFunctionValueDeprecation")) {
      optionNames.forEach((optionName) => {
        if (isFunction(this.option(optionName))) {
          errors_default.log("W0017", optionName);
        }
      });
    }
  },
  _visibilityChanged: abstract2,
  _dimensionChanged: abstract2,
  _init() {
    this.callBase();
    this._checkFunctionValueDeprecation(["width", "height", "maxHeight", "maxWidth", "minHeight", "minWidth", "popupHeight", "popupWidth"]);
    this._attachWindowResizeCallback();
    this._initTemplateManager();
  },
  _setOptionsByDevice(instanceCustomRules) {
    this.callBase([].concat(this.constructor._classCustomRules || [], instanceCustomRules || []));
  },
  _isInitialOptionValue(name2) {
    const isCustomOption = this.constructor._classCustomRules && Object.prototype.hasOwnProperty.call(this._convertRulesToOptions(this.constructor._classCustomRules), name2);
    return !isCustomOption && this.callBase(name2);
  },
  _attachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      const windowResizeCallBack = this._windowResizeCallBack = this._dimensionChanged.bind(this);
      resize_callbacks_default.add(windowResizeCallBack);
    }
  },
  _isDimensionChangeSupported() {
    return this._dimensionChanged !== abstract2;
  },
  _renderComponent() {
    addShadowDomStyles(this.$element());
    this._initMarkup();
    hasWindow() && this._render();
  },
  _initMarkup() {
    const {
      rtlEnabled
    } = this.option() || {};
    this._renderElementAttributes();
    this._toggleRTLDirection(rtlEnabled);
    this._renderVisibilityChange();
    this._renderDimensions();
  },
  _render() {
    this._attachVisibilityChangeHandlers();
  },
  _renderElementAttributes() {
    const {
      elementAttr
    } = this.option() || {};
    const attributes = extend({}, elementAttr);
    const classNames = attributes.class;
    delete attributes.class;
    this.$element().attr(attributes).removeClass(this._customClass).addClass(classNames);
    this._customClass = classNames;
  },
  _renderVisibilityChange() {
    if (this._isDimensionChangeSupported()) {
      this._attachDimensionChangeHandlers();
    }
    if (this._isVisibilityChangeSupported()) {
      const $element = this.$element();
      $element.addClass("dx-visibility-change-handler");
    }
  },
  _renderDimensions() {
    const $element = this.$element();
    const element = $element.get(0);
    const width = this._getOptionValue("width", element);
    const height = this._getOptionValue("height", element);
    if (this._isCssUpdateRequired(element, height, width)) {
      $element.css({
        width: null === width ? "" : width,
        height: null === height ? "" : height
      });
    }
  },
  _isCssUpdateRequired: (element, height, width) => !!(isDefined(width) || isDefined(height) || element.style.width || element.style.height),
  _attachDimensionChangeHandlers() {
    const $el = this.$element();
    const namespace = `${this.NAME}VisibilityChange`;
    resize.off($el, {
      namespace
    });
    resize.on($el, () => this._dimensionChanged(), {
      namespace
    });
  },
  _attachVisibilityChangeHandlers() {
    if (this._isVisibilityChangeSupported()) {
      const $el = this.$element();
      const namespace = `${this.NAME}VisibilityChange`;
      this._isHidden = !this._isVisible();
      visibility.off($el, {
        namespace
      });
      visibility.on($el, () => this._checkVisibilityChanged("shown"), () => this._checkVisibilityChanged("hiding"), {
        namespace
      });
    }
  },
  _isVisible() {
    const $element = this.$element();
    return $element.is(":visible");
  },
  _checkVisibilityChanged(action) {
    const isVisible2 = this._isVisible();
    if (isVisible2) {
      if ("hiding" === action && !this._isHidden) {
        this._visibilityChanged(false);
        this._isHidden = true;
      } else if ("shown" === action && this._isHidden) {
        this._isHidden = false;
        this._visibilityChanged(true);
      }
    }
  },
  _isVisibilityChangeSupported() {
    return this._visibilityChanged !== abstract2 && hasWindow();
  },
  _clean: noop2,
  _modelByElement() {
    const {
      modelByElement
    } = this.option();
    const $element = this.$element();
    return modelByElement ? modelByElement($element) : void 0;
  },
  _invalidate() {
    if (this._isUpdateAllowed()) {
      throw errors_default.Error("E0007");
    }
    this._requireRefresh = true;
  },
  _refresh() {
    this._clean();
    this._renderComponent();
  },
  _dispose() {
    this._templateManager && this._templateManager.dispose();
    this.callBase();
    this._clean();
    this._detachWindowResizeCallback();
  },
  _detachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      resize_callbacks_default.remove(this._windowResizeCallBack);
    }
  },
  _toggleRTLDirection(rtl) {
    const $element = this.$element();
    $element.toggleClass("dx-rtl", rtl);
  },
  _createComponent(element, component) {
    let config3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    const synchronizableOptions = grep(this._getSynchronizableOptionsForCreateComponent(), (value2) => !(value2 in config3));
    const {
      integrationOptions
    } = this.option();
    let {
      nestedComponentOptions
    } = this.option();
    nestedComponentOptions = nestedComponentOptions || noop2;
    const nestedComponentConfig = extend({
      integrationOptions
    }, nestedComponentOptions(this));
    synchronizableOptions.forEach((optionName) => nestedComponentConfig[optionName] = this.option(optionName));
    this._extendConfig(config3, nestedComponentConfig);
    let instance;
    if (isString(component)) {
      const $element = renderer_default(element)[component](config3);
      instance = $element[component]("instance");
    } else if (element) {
      instance = component.getInstance(element);
      if (instance) {
        instance.option(config3);
      } else {
        instance = new component(element, config3);
      }
    }
    if (instance) {
      const optionChangedHandler = (_ref) => {
        let {
          name: name2,
          value: value2
        } = _ref;
        if (synchronizableOptions.includes(name2)) {
          instance.option(name2, value2);
        }
      };
      this.on("optionChanged", optionChangedHandler);
      instance.on("disposing", () => this.off("optionChanged", optionChangedHandler));
    }
    return instance;
  },
  _extendConfig(config3, extendConfig) {
    each(extendConfig, (key, value2) => {
      !Object.prototype.hasOwnProperty.call(config3, key) && (config3[key] = value2);
    });
  },
  _defaultActionConfig() {
    const $element = this.$element();
    const context2 = this._modelByElement($element);
    return extend(this.callBase(), {
      context: context2
    });
  },
  _defaultActionArgs() {
    const $element = this.$element();
    const model = this._modelByElement($element);
    const element = this.element();
    return extend(this.callBase(), {
      element,
      model
    });
  },
  _optionChanged(args) {
    switch (args.name) {
      case "width":
      case "height":
        this._renderDimensions();
        break;
      case "rtlEnabled":
        this._invalidate();
        break;
      case "elementAttr":
        this._renderElementAttributes();
        break;
      case "disabled":
      case "integrationOptions":
        break;
      default:
        this.callBase(args);
    }
  },
  _removeAttributes(element) {
    const attrs = element.attributes;
    for (let i = attrs.length - 1; i >= 0; i--) {
      const attr = attrs[i];
      if (attr) {
        const {
          name: name2
        } = attr;
        if (!name2.indexOf("aria-") || -1 !== name2.indexOf("dx-") || "role" === name2 || "style" === name2 || "tabindex" === name2) {
          element.removeAttribute(name2);
        }
      }
    }
  },
  _removeClasses(element) {
    element.className = element.className.split(" ").filter((cssClass) => 0 !== cssClass.lastIndexOf("dx-", 0)).join(" ");
  },
  _updateDOMComponent(renderRequired) {
    if (renderRequired) {
      this._renderComponent();
    } else if (this._requireRefresh) {
      this._requireRefresh = false;
      this._refresh();
    }
  },
  endUpdate() {
    const renderRequired = this._isInitializingRequired();
    this.callBase();
    this._isUpdateAllowed() && this._updateDOMComponent(renderRequired);
  },
  $element() {
    return this._$element;
  },
  element() {
    const $element = this.$element();
    return getPublicElement($element);
  },
  dispose() {
    const element = this.$element().get(0);
    cleanDataRecursive(element, true);
    element.textContent = "";
    this._removeAttributes(element);
    this._removeClasses(element);
  },
  resetOption(optionName) {
    this.callBase(optionName);
    if ("width" === optionName || "height" === optionName) {
      const initialOption = this.initialOption(optionName);
      !isDefined(initialOption) && this.$element().css(optionName, "");
    }
  },
  _getAnonymousTemplateName() {
    return;
  },
  _initTemplateManager() {
    if (this._templateManager || !this._useTemplates()) {
      return;
    }
    const {
      integrationOptions = {}
    } = this.option();
    const {
      createTemplate
    } = integrationOptions;
    this._templateManager = new TemplateManager(createTemplate, this._getAnonymousTemplateName());
    this._initTemplates();
  },
  _initTemplates() {
    const {
      templates,
      anonymousTemplateMeta
    } = this._templateManager.extractTemplates(this.$element());
    const anonymousTemplate = this.option(`integrationOptions.templates.${anonymousTemplateMeta.name}`);
    templates.forEach((_ref2) => {
      let {
        name: name2,
        template
      } = _ref2;
      this._options.silent(`integrationOptions.templates.${name2}`, template);
    });
    if (anonymousTemplateMeta.name && !anonymousTemplate) {
      this._options.silent(`integrationOptions.templates.${anonymousTemplateMeta.name}`, anonymousTemplateMeta.template);
      this._options.silent("_hasAnonymousTemplateContent", true);
    }
  },
  _getTemplateByOption(optionName) {
    return this._getTemplate(this.option(optionName));
  },
  _getTemplate(templateSource) {
    const templates = this.option("integrationOptions.templates");
    const isAsyncTemplate = this.option("templatesRenderAsynchronously");
    const skipTemplates = this.option("integrationOptions.skipTemplates");
    return this._templateManager.getTemplate(templateSource, templates, {
      isAsyncTemplate,
      skipTemplates
    }, this);
  },
  _saveTemplate(name2, template) {
    this._setOptionWithoutOptionChange("integrationOptions.templates." + name2, this._templateManager._createTemplate(template));
  },
  _useTemplates: () => true
});
DOMComponent.getInstance = function(element) {
  return getInstanceByElement(renderer_default(element), this);
};
DOMComponent.defaultOptions = function(rule) {
  this._classCustomRules = this._classCustomRules || [];
  this._classCustomRules.push(rule);
};
var dom_component_default = DOMComponent;

// ../../../../../../node_modules/devextreme/esm/core/utils/version.js
function compare(x, y, maxLevel) {
  function normalizeArg(value2) {
    if ("string" === typeof value2) {
      return value2.split(".");
    }
    if ("number" === typeof value2) {
      return [value2];
    }
    return value2;
  }
  x = normalizeArg(x);
  y = normalizeArg(y);
  let length = Math.max(x.length, y.length);
  if (isFinite(maxLevel)) {
    length = Math.min(length, maxLevel);
  }
  for (let i = 0; i < length; i++) {
    const xItem = parseInt(x[i] || 0, 10);
    const yItem = parseInt(y[i] || 0, 10);
    if (xItem < yItem) {
      return -1;
    }
    if (xItem > yItem) {
      return 1;
    }
  }
  return 0;
}

// ../../../../../../node_modules/devextreme/esm/events/utils/event_nodes_disposing.js
function nodesByEvent(event) {
  return event && [event.target, event.delegateTarget, event.relatedTarget, event.currentTarget].filter((node) => !!node);
}
var subscribeNodesDisposing = (event, callback) => {
  events_engine_default.one(nodesByEvent(event), removeEvent, callback);
};
var unsubscribeNodesDisposing = (event, callback) => {
  events_engine_default.off(nodesByEvent(event), removeEvent, callback);
};

// ../../../../../../node_modules/devextreme/esm/events/click.js
var CLICK_EVENT_NAME = "dxclick";
var prevented = null;
var lastFiredEvent = null;
var onNodeRemove = () => {
  lastFiredEvent = null;
};
var clickHandler = function(e) {
  const originalEvent = e.originalEvent;
  const eventAlreadyFired = lastFiredEvent === originalEvent || originalEvent && originalEvent.DXCLICK_FIRED;
  const leftButton = !e.which || 1 === e.which;
  if (leftButton && !prevented && !eventAlreadyFired) {
    if (originalEvent) {
      originalEvent.DXCLICK_FIRED = true;
    }
    unsubscribeNodesDisposing(lastFiredEvent, onNodeRemove);
    lastFiredEvent = originalEvent;
    subscribeNodesDisposing(lastFiredEvent, onNodeRemove);
    fireEvent({
      type: "dxclick",
      originalEvent: e
    });
  }
};
var ClickEmitter = emitter_default.inherit({
  ctor: function(element) {
    this.callBase(element);
    events_engine_default.on(this.getElement(), "click", clickHandler);
  },
  start: function(e) {
    prevented = null;
  },
  cancel: function() {
    prevented = true;
  },
  dispose: function() {
    events_engine_default.off(this.getElement(), "click", clickHandler);
  }
});
!function() {
  const desktopDevice = devices_default.real().generic;
  if (!desktopDevice) {
    let startTarget = null;
    let blurPrevented = false;
    const isInput = function(element) {
      return renderer_default(element).is("input, textarea, select, button ,:focus, :focus *");
    };
    const pointerDownHandler = function(e) {
      startTarget = e.target;
      blurPrevented = e.isDefaultPrevented();
    };
    const getTarget = function(e) {
      const target = getEventTarget(e);
      return renderer_default(target);
    };
    const clickHandler2 = function(e) {
      const $target = getTarget(e);
      if (!blurPrevented && startTarget && !$target.is(startTarget) && !renderer_default(startTarget).is("label") && isInput($target)) {
        resetActiveElement();
      }
      startTarget = null;
      blurPrevented = false;
    };
    const NATIVE_CLICK_FIXER_NAMESPACE = "NATIVE_CLICK_FIXER";
    const document2 = dom_adapter_default.getDocument();
    events_engine_default.subscribeGlobal(document2, addNamespace2(pointer_default.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler);
    events_engine_default.subscribeGlobal(document2, addNamespace2("click", NATIVE_CLICK_FIXER_NAMESPACE), clickHandler2);
  }
}();
emitter_registrator_default({
  emitter: ClickEmitter,
  bubble: true,
  events: ["dxclick"]
});

// ../../../../../../node_modules/devextreme/esm/events/core/emitter.feedback.js
var ACTIVE_EVENT_NAME = "dxactive";
var FeedbackEvent = class_default.inherit({
  ctor: function(timeout, fire) {
    this._timeout = timeout;
    this._fire = fire;
  },
  start: function() {
    const that = this;
    this._schedule(function() {
      that.force();
    });
  },
  _schedule: function(fn) {
    this.stop();
    this._timer = setTimeout(fn, this._timeout);
  },
  stop: function() {
    clearTimeout(this._timer);
  },
  force: function() {
    if (this._fired) {
      return;
    }
    this.stop();
    this._fire();
    this._fired = true;
  },
  fired: function() {
    return this._fired;
  }
});
var activeFeedback;
var FeedbackEmitter = emitter_default.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    this._active = new FeedbackEvent(0, noop2);
    this._inactive = new FeedbackEvent(0, noop2);
  },
  configure: function(data2, eventName) {
    switch (eventName) {
      case "dxactive":
        data2.activeTimeout = data2.timeout;
        break;
      case "dxinactive":
        data2.inactiveTimeout = data2.timeout;
    }
    this.callBase(data2);
  },
  start: function(e) {
    if (activeFeedback) {
      const activeChildExists = contains2(this.getElement().get(0), activeFeedback.getElement().get(0));
      const childJustActivated = !activeFeedback._active.fired();
      if (activeChildExists && childJustActivated) {
        this._cancel();
        return;
      }
      activeFeedback._inactive.force();
    }
    activeFeedback = this;
    this._initEvents(e);
    this._active.start();
  },
  _initEvents: function(e) {
    const that = this;
    const eventTarget = this._getEmitterTarget(e);
    const mouseEvent = isMouseEvent(e);
    const isSimulator = devices_default.isSimulator();
    const deferFeedback = isSimulator || !mouseEvent;
    const activeTimeout = ensureDefined(this.activeTimeout, 30);
    const inactiveTimeout = ensureDefined(this.inactiveTimeout, 400);
    this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, function() {
      that._fireEvent("dxactive", e, {
        target: eventTarget
      });
    });
    this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, function() {
      that._fireEvent("dxinactive", e, {
        target: eventTarget
      });
      activeFeedback = null;
    });
  },
  cancel: function(e) {
    this.end(e);
  },
  end: function(e) {
    const skipTimers = e.type !== pointer_default.up;
    if (skipTimers) {
      this._active.stop();
    } else {
      this._active.force();
    }
    this._inactive.start();
    if (skipTimers) {
      this._inactive.force();
    }
  },
  dispose: function() {
    this._active.stop();
    this._inactive.stop();
    if (activeFeedback === this) {
      activeFeedback = null;
    }
    this.callBase();
  },
  lockInactive: function() {
    this._active.force();
    this._inactive.stop();
    activeFeedback = null;
    this._cancel();
    return this._inactive.force.bind(this._inactive);
  }
});
FeedbackEmitter.lock = function(deferred) {
  const lockInactive = activeFeedback ? activeFeedback.lockInactive() : noop2;
  deferred.done(lockInactive);
};
emitter_registrator_default({
  emitter: FeedbackEmitter,
  events: ["dxactive", "dxinactive"]
});
var lock = FeedbackEmitter.lock;

// ../../../../../../node_modules/devextreme/esm/events/hover.js
var HOVERSTART = "dxhoverstart";
var POINTERENTER_NAMESPACED_EVENT_NAME = addNamespace2(pointer_default.enter, "dxHoverStart");
var HOVEREND = "dxhoverend";
var POINTERLEAVE_NAMESPACED_EVENT_NAME = addNamespace2(pointer_default.leave, "dxHoverEnd");
var Hover = class_default.inherit({
  noBubble: true,
  ctor: function() {
    this._handlerArrayKeyPath = this._eventNamespace + "_HandlerStore";
  },
  setup: function(element) {
    data(element, this._handlerArrayKeyPath, {});
  },
  add: function(element, handleObj) {
    const that = this;
    const handler = function(e) {
      that._handler(e);
    };
    events_engine_default.on(element, this._originalEventName, handleObj.selector, handler);
    data(element, this._handlerArrayKeyPath)[handleObj.guid] = handler;
  },
  _handler: function(e) {
    if (isTouchEvent(e) || devices_default.isSimulator()) {
      return;
    }
    fireEvent({
      type: this._eventName,
      originalEvent: e,
      delegateTarget: e.delegateTarget
    });
  },
  remove: function(element, handleObj) {
    const handler = data(element, this._handlerArrayKeyPath)[handleObj.guid];
    events_engine_default.off(element, this._originalEventName, handleObj.selector, handler);
  },
  teardown: function(element) {
    removeData(element, this._handlerArrayKeyPath);
  }
});
var HoverStart = Hover.inherit({
  ctor: function() {
    this._eventNamespace = "dxHoverStart";
    this._eventName = HOVERSTART;
    this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
    this.callBase();
  },
  _handler: function(e) {
    const pointers = e.pointers || [];
    if (!pointers.length) {
      this.callBase(e);
    }
  }
});
var HoverEnd = Hover.inherit({
  ctor: function() {
    this._eventNamespace = "dxHoverEnd";
    this._eventName = HOVEREND;
    this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
    this.callBase();
  }
});
event_registrator_default(HOVERSTART, new HoverStart());
event_registrator_default(HOVEREND, new HoverEnd());

// ../../../../../../node_modules/devextreme/esm/ui/widget/ui.widget.js
function setAttribute(name2, value2, target) {
  name2 = "role" === name2 || "id" === name2 ? name2 : `aria-${name2}`;
  value2 = isDefined(value2) ? value2.toString() : null;
  target.attr(name2, value2);
}
var Widget = dom_component_default.inherit({
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  _supportedKeys: () => ({}),
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoveredElement: null,
      isActive: false,
      disabled: false,
      visible: true,
      hint: void 0,
      activeStateEnabled: false,
      onContentReady: null,
      hoverStateEnabled: false,
      focusStateEnabled: false,
      tabIndex: 0,
      accessKey: void 0,
      onFocusIn: null,
      onFocusOut: null,
      onKeyboardHandled: null,
      ignoreParentReadOnly: false,
      useResizeObserver: true
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: function() {
        const device = devices_default.real();
        const platform = device.platform;
        const version3 = device.version;
        return "ios" === platform && compare(version3, "13.3") <= 0;
      },
      options: {
        useResizeObserver: false
      }
    }]);
  },
  _init() {
    this.callBase();
    this._initContentReadyAction();
  },
  _innerWidgetOptionChanged: function(innerWidget, args) {
    const options2 = Widget.getOptionsFromContainer(args);
    innerWidget && innerWidget.option(options2);
    this._options.cache(args.name, options2);
  },
  _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    const syncOptions = () => this._options.silent(optionsContainer, extend({}, innerWidget.option()));
    syncOptions();
    innerWidget.on("optionChanged", syncOptions);
  },
  _getAriaTarget() {
    return this._focusTarget();
  },
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption("onContentReady", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _initMarkup() {
    const {
      disabled,
      visible: visible2
    } = this.option();
    this.$element().addClass("dx-widget");
    this._toggleDisabledState(disabled);
    this._toggleVisibility(visible2);
    this._renderHint();
    this._isFocusable() && this._renderFocusTarget();
    this.callBase();
  },
  _render() {
    this.callBase();
    this._renderContent();
    this._renderFocusState();
    this._attachFeedbackEvents();
    this._attachHoverEvents();
    this._toggleIndependentState();
  },
  _renderHint() {
    const {
      hint
    } = this.option();
    this.$element().attr("title", hint || null);
  },
  _renderContent() {
    deferRender(() => !this._disposed ? this._renderContentImpl() : void 0).done(() => !this._disposed ? this._fireContentReadyAction() : void 0);
  },
  _renderContentImpl: noop2,
  _fireContentReadyAction: deferRenderer(function() {
    return this._contentReadyAction();
  }),
  _dispose() {
    this._contentReadyAction = null;
    this._detachKeyboardEvents();
    this.callBase();
  },
  _resetActiveState() {
    this._toggleActiveState(this._eventBindingTarget(), false);
  },
  _clean() {
    this._cleanFocusState();
    this._resetActiveState();
    this.callBase();
    this.$element().empty();
  },
  _toggleVisibility(visible2) {
    this.$element().toggleClass("dx-state-invisible", !visible2);
  },
  _renderFocusState() {
    this._attachKeyboardEvents();
    if (this._isFocusable()) {
      this._renderFocusTarget();
      this._attachFocusEvents();
      this._renderAccessKey();
    }
  },
  _renderAccessKey() {
    const $el = this._focusTarget();
    const {
      accessKey
    } = this.option();
    $el.attr("accesskey", accessKey);
  },
  _isFocusable() {
    const {
      focusStateEnabled,
      disabled
    } = this.option();
    return focusStateEnabled && !disabled;
  },
  _eventBindingTarget() {
    return this.$element();
  },
  _focusTarget() {
    return this._getActiveElement();
  },
  _isFocusTarget: function(element) {
    const focusTargets = renderer_default(this._focusTarget()).toArray();
    return focusTargets.includes(element);
  },
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit).not(".dx-state-disabled");
  },
  _getActiveElement() {
    const activeElement = this._eventBindingTarget();
    if (this._activeStateUnit) {
      return this._findActiveTarget(activeElement);
    }
    return activeElement;
  },
  _renderFocusTarget() {
    const {
      tabIndex
    } = this.option();
    this._focusTarget().attr("tabIndex", tabIndex);
  },
  _keyboardEventBindingTarget() {
    return this._eventBindingTarget();
  },
  _refreshFocusEvent() {
    this._detachFocusEvents();
    this._attachFocusEvents();
  },
  _focusEventTarget() {
    return this._focusTarget();
  },
  _focusInHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption("onFocusIn", {
        beforeExecute: () => this._updateFocusState(event, true),
        excludeValidators: ["readOnly"]
      })({
        event
      });
    }
  },
  _focusOutHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption("onFocusOut", {
        beforeExecute: () => this._updateFocusState(event, false),
        excludeValidators: ["readOnly", "disabled"]
      })({
        event
      });
    }
  },
  _updateFocusState(_ref, isFocused) {
    let {
      target
    } = _ref;
    if (this._isFocusTarget(target)) {
      this._toggleFocusClass(isFocused, renderer_default(target));
    }
  },
  _toggleFocusClass(isFocused, $element) {
    const $focusTarget = $element && $element.length ? $element : this._focusTarget();
    $focusTarget.toggleClass("dx-state-focused", isFocused);
  },
  _hasFocusClass(element) {
    const $focusTarget = renderer_default(element || this._focusTarget());
    return $focusTarget.hasClass("dx-state-focused");
  },
  _isFocused() {
    return this._hasFocusClass();
  },
  _getKeyboardListeners: () => [],
  _attachKeyboardEvents() {
    this._detachKeyboardEvents();
    const {
      focusStateEnabled,
      onKeyboardHandled
    } = this.option();
    const hasChildListeners = this._getKeyboardListeners().length;
    const hasKeyboardEventHandler = !!onKeyboardHandled;
    const shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;
    if (shouldAttach) {
      this._keyboardListenerId = keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), (opts) => this._keyboardHandler(opts));
    }
  },
  _keyboardHandler(options2, onlyChildProcessing) {
    if (!onlyChildProcessing) {
      const {
        originalEvent,
        keyName,
        which
      } = options2;
      const keys = this._supportedKeys(originalEvent);
      const func = keys[keyName] || keys[which];
      if (void 0 !== func) {
        const handler = func.bind(this);
        const result2 = handler(originalEvent, options2);
        if (!result2) {
          return false;
        }
      }
    }
    const keyboardListeners = this._getKeyboardListeners();
    const {
      onKeyboardHandled
    } = this.option();
    keyboardListeners.forEach((listener) => listener && listener._keyboardHandler(options2));
    onKeyboardHandled && onKeyboardHandled(options2);
    return true;
  },
  _refreshFocusState() {
    this._cleanFocusState();
    this._renderFocusState();
  },
  _cleanFocusState() {
    const $element = this._focusTarget();
    $element.removeAttr("tabIndex");
    this._toggleFocusClass(false);
    this._detachFocusEvents();
    this._detachKeyboardEvents();
  },
  _detachKeyboardEvents() {
    keyboard.off(this._keyboardListenerId);
    this._keyboardListenerId = null;
  },
  _attachHoverEvents() {
    const {
      hoverStateEnabled
    } = this.option();
    const selector = this._activeStateUnit;
    const $el = this._eventBindingTarget();
    hover.off($el, {
      selector,
      namespace: "UIFeedback"
    });
    if (hoverStateEnabled) {
      hover.on($el, new Action((_ref2) => {
        let {
          event,
          element
        } = _ref2;
        this._hoverStartHandler(event);
        this.option("hoveredElement", renderer_default(element));
      }, {
        excludeValidators: ["readOnly"]
      }), (event) => {
        this.option("hoveredElement", null);
        this._hoverEndHandler(event);
      }, {
        selector,
        namespace: "UIFeedback"
      });
    }
  },
  _attachFeedbackEvents() {
    const {
      activeStateEnabled
    } = this.option();
    const selector = this._activeStateUnit;
    const $el = this._eventBindingTarget();
    active.off($el, {
      namespace: "UIFeedback",
      selector
    });
    if (activeStateEnabled) {
      active.on($el, new Action((_ref3) => {
        let {
          event,
          element
        } = _ref3;
        return this._toggleActiveState(renderer_default(element), true, event);
      }), new Action((_ref4) => {
        let {
          event,
          element
        } = _ref4;
        return this._toggleActiveState(renderer_default(element), false, event);
      }, {
        excludeValidators: ["disabled", "readOnly"]
      }), {
        showTimeout: this._feedbackShowTimeout,
        hideTimeout: this._feedbackHideTimeout,
        selector,
        namespace: "UIFeedback"
      });
    }
  },
  _detachFocusEvents() {
    const $el = this._focusEventTarget();
    focus.off($el, {
      namespace: `${this.NAME}Focus`
    });
  },
  _attachFocusEvents() {
    const $el = this._focusEventTarget();
    focus.on($el, (e) => this._focusInHandler(e), (e) => this._focusOutHandler(e), {
      namespace: `${this.NAME}Focus`,
      isFocusable: (index2, el) => renderer_default(el).is(focusable)
    });
  },
  _hoverStartHandler: noop2,
  _hoverEndHandler: noop2,
  _toggleActiveState($element, value2) {
    this.option("isActive", value2);
    $element.toggleClass("dx-state-active", value2);
  },
  _updatedHover() {
    const hoveredElement = this._options.silent("hoveredElement");
    this._hover(hoveredElement, hoveredElement);
  },
  _findHoverTarget($el) {
    return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget());
  },
  _hover($el, $previous) {
    const {
      hoverStateEnabled,
      disabled,
      isActive
    } = this.option();
    $previous = this._findHoverTarget($previous);
    $previous && $previous.toggleClass("dx-state-hover", false);
    if ($el && hoverStateEnabled && !disabled && !isActive) {
      const newHoveredElement = this._findHoverTarget($el);
      newHoveredElement && newHoveredElement.toggleClass("dx-state-hover", true);
    }
  },
  _toggleDisabledState(value2) {
    this.$element().toggleClass("dx-state-disabled", Boolean(value2));
    this.setAria("disabled", value2 || void 0);
  },
  _toggleIndependentState() {
    this.$element().toggleClass("dx-state-independent", this.option("ignoreParentReadOnly"));
  },
  _setWidgetOption(widgetName, args) {
    if (!this[widgetName]) {
      return;
    }
    if (isPlainObject(args[0])) {
      each(args[0], (option, value3) => this._setWidgetOption(widgetName, [option, value3]));
      return;
    }
    const optionName = args[0];
    let value2 = args[1];
    if (1 === args.length) {
      value2 = this.option(optionName);
    }
    const widgetOptionMap = this[`${widgetName}OptionMap`];
    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value2);
  },
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "disabled":
        this._toggleDisabledState(value2);
        this._updatedHover();
        this._refreshFocusState();
        break;
      case "hint":
        this._renderHint();
        break;
      case "ignoreParentReadOnly":
        this._toggleIndependentState();
        break;
      case "activeStateEnabled":
        this._attachFeedbackEvents();
        break;
      case "hoverStateEnabled":
        this._attachHoverEvents();
        this._updatedHover();
        break;
      case "tabIndex":
      case "focusStateEnabled":
        this._refreshFocusState();
        break;
      case "onFocusIn":
      case "onFocusOut":
      case "useResizeObserver":
        break;
      case "accessKey":
        this._renderAccessKey();
        break;
      case "hoveredElement":
        this._hover(value2, previousValue);
        break;
      case "isActive":
        this._updatedHover();
        break;
      case "visible":
        this._toggleVisibility(value2);
        if (this._isVisibilityChangeSupported()) {
          this._checkVisibilityChanged(value2 ? "shown" : "hiding");
        }
        break;
      case "onKeyboardHandled":
        this._attachKeyboardEvents();
        break;
      case "onContentReady":
        this._initContentReadyAction();
        break;
      default:
        this.callBase(args);
    }
  },
  _isVisible() {
    const {
      visible: visible2
    } = this.option();
    return this.callBase() && visible2;
  },
  beginUpdate() {
    this._ready(false);
    this.callBase();
  },
  endUpdate() {
    this.callBase();
    if (this._initialized) {
      this._ready(true);
    }
  },
  _ready(value2) {
    if (0 === arguments.length) {
      return this._isReady;
    }
    this._isReady = value2;
  },
  setAria() {
    if (!isPlainObject(arguments.length <= 0 ? void 0 : arguments[0])) {
      setAttribute(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], (arguments.length <= 2 ? void 0 : arguments[2]) || this._getAriaTarget());
    } else {
      const target = (arguments.length <= 1 ? void 0 : arguments[1]) || this._getAriaTarget();
      each(arguments.length <= 0 ? void 0 : arguments[0], (name2, value2) => setAttribute(name2, value2, target));
    }
  },
  isReady() {
    return this._ready();
  },
  repaint() {
    this._refresh();
  },
  focus() {
    focus.trigger(this._focusTarget());
  },
  registerKeyHandler(key, handler) {
    const currentKeys = this._supportedKeys();
    this._supportedKeys = () => extend(currentKeys, {
      [key]: handler
    });
  }
});
Widget.getOptionsFromContainer = (_ref5) => {
  let {
    name: name2,
    fullName,
    value: value2
  } = _ref5;
  let options2 = {};
  if (name2 === fullName) {
    options2 = value2;
  } else {
    const option = fullName.split(".").pop();
    options2[option] = value2;
  }
  return options2;
};
var ui_widget_default = Widget;

// ../../../../../../node_modules/devextreme/esm/ui/widget/swatch_container.js
var getSwatchContainer = (element) => {
  const $element = renderer_default(element);
  const swatchContainer = $element.closest('[class^="dx-swatch-"], [class*=" dx-swatch-"]');
  const viewport = value();
  if (!swatchContainer.length) {
    return viewport;
  }
  const swatchClassRegex = new RegExp("(\\s|^)(dx-swatch-.*?)(\\s|$)");
  const swatchClass = swatchContainer[0].className.match(swatchClassRegex)[2];
  let viewportSwatchContainer = viewport.children("." + swatchClass);
  if (!viewportSwatchContainer.length) {
    viewportSwatchContainer = renderer_default("<div>").addClass(swatchClass).appendTo(viewport);
  }
  return viewportSwatchContainer;
};
var swatch_container_default = {
  getSwatchContainer
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/overlay/m_overlay_position_controller.js
var window12 = getWindow();
var OVERLAY_POSITION_ALIASES = {
  top: {
    my: "top center",
    at: "top center"
  },
  bottom: {
    my: "bottom center",
    at: "bottom center"
  },
  right: {
    my: "right center",
    at: "right center"
  },
  left: {
    my: "left center",
    at: "left center"
  },
  center: {
    my: "center",
    at: "center"
  },
  "right bottom": {
    my: "right bottom",
    at: "right bottom"
  },
  "right top": {
    my: "right top",
    at: "right top"
  },
  "left bottom": {
    my: "left bottom",
    at: "left bottom"
  },
  "left top": {
    my: "left top",
    at: "left top"
  }
};
var OVERLAY_DEFAULT_BOUNDARY_OFFSET = {
  h: 0,
  v: 0
};
var OverlayPositionController = class {
  constructor(_ref) {
    let {
      position: position3,
      container,
      visualContainer,
      $root,
      $content,
      $wrapper,
      onPositioned,
      onVisualPositionChanged,
      restorePosition,
      _fixWrapperPosition,
      _skipContentPositioning
    } = _ref;
    this._props = {
      position: position3,
      container,
      visualContainer,
      restorePosition,
      onPositioned,
      onVisualPositionChanged,
      _fixWrapperPosition,
      _skipContentPositioning
    };
    this._$root = $root;
    this._$content = $content;
    this._$wrapper = $wrapper;
    this._$markupContainer = void 0;
    this._$visualContainer = void 0;
    this._shouldRenderContentInitialPosition = true;
    this._visualPosition = void 0;
    this._initialPosition = void 0;
    this._previousVisualPosition = void 0;
    this.updateContainer(container);
    this.updatePosition(position3);
    this.updateVisualContainer(visualContainer);
  }
  get $container() {
    this.updateContainer();
    return this._$markupContainer;
  }
  get $visualContainer() {
    return this._$visualContainer;
  }
  get position() {
    return this._position;
  }
  set fixWrapperPosition(fixWrapperPosition) {
    this._props._fixWrapperPosition = fixWrapperPosition;
    this.styleWrapperPosition();
  }
  set restorePosition(restorePosition) {
    this._props.restorePosition = restorePosition;
  }
  restorePositionOnNextRender(value2) {
    this._shouldRenderContentInitialPosition = value2 || !this._visualPosition;
  }
  openingHandled() {
    const shouldRestorePosition = this._props.restorePosition;
    this.restorePositionOnNextRender(shouldRestorePosition);
  }
  updatePosition(positionProp) {
    this._props.position = positionProp;
    this._position = this._normalizePosition(positionProp);
    this.updateVisualContainer();
  }
  updateContainer() {
    let containerProp = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._props.container;
    this._props.container = containerProp;
    this._$markupContainer = containerProp ? renderer_default(containerProp) : swatch_container_default.getSwatchContainer(this._$root);
    this.updateVisualContainer(this._props.visualContainer);
  }
  updateVisualContainer() {
    let visualContainer = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._props.visualContainer;
    this._props.visualContainer = visualContainer;
    this._$visualContainer = this._getVisualContainer();
  }
  detectVisualPositionChange(event) {
    this._updateVisualPositionValue();
    this._raisePositionedEvents(event);
  }
  positionContent() {
    if (this._shouldRenderContentInitialPosition) {
      this._renderContentInitialPosition();
    } else {
      move(this._$content, this._visualPosition);
      this.detectVisualPositionChange();
    }
  }
  positionWrapper() {
    if (this._$visualContainer) {
      position_default.setup(this._$wrapper, {
        my: "top left",
        at: "top left",
        of: this._$visualContainer
      });
    }
  }
  styleWrapperPosition() {
    const useFixed = isWindow(this.$visualContainer.get(0)) || this._props._fixWrapperPosition;
    const positionStyle = useFixed ? "fixed" : "absolute";
    this._$wrapper.css("position", positionStyle);
  }
  _updateVisualPositionValue() {
    this._previousVisualPosition = this._visualPosition;
    this._visualPosition = locate(this._$content);
  }
  _renderContentInitialPosition() {
    this._renderBoundaryOffset();
    resetPosition(this._$content);
    const wrapperOverflow = this._$wrapper.css("overflow");
    this._$wrapper.css("overflow", "hidden");
    if (!this._props._skipContentPositioning) {
      const resultPosition = position_default.setup(this._$content, this._position);
      this._initialPosition = resultPosition;
    }
    this._$wrapper.css("overflow", wrapperOverflow);
    this.detectVisualPositionChange();
  }
  _raisePositionedEvents(event) {
    const previousPosition = this._previousVisualPosition;
    const newPosition = this._visualPosition;
    const isVisualPositionChanged = (null === previousPosition || void 0 === previousPosition ? void 0 : previousPosition.top) !== newPosition.top || (null === previousPosition || void 0 === previousPosition ? void 0 : previousPosition.left) !== newPosition.left;
    if (isVisualPositionChanged) {
      this._props.onVisualPositionChanged({
        previousPosition,
        position: newPosition,
        event
      });
    }
    this._props.onPositioned({
      position: this._initialPosition
    });
  }
  _renderBoundaryOffset() {
    const boundaryOffset = this._position ?? {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    this._$content.css("margin", `${boundaryOffset.v}px ${boundaryOffset.h}px`);
  }
  _getVisualContainer() {
    var _this$_props$position, _this$_props$position2;
    const containerProp = this._props.container;
    const visualContainerProp = this._props.visualContainer;
    const positionOf = isEvent(null === (_this$_props$position = this._props.position) || void 0 === _this$_props$position ? void 0 : _this$_props$position.of) ? this._props.position.of.target : null === (_this$_props$position2 = this._props.position) || void 0 === _this$_props$position2 ? void 0 : _this$_props$position2.of;
    if (visualContainerProp) {
      return renderer_default(visualContainerProp);
    }
    if (containerProp) {
      return renderer_default(containerProp);
    }
    if (positionOf) {
      return renderer_default(positionOf);
    }
    return renderer_default(window12);
  }
  _normalizePosition(positionProp) {
    const defaultPositionConfig = {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    if (isDefined(positionProp)) {
      return extend(true, {}, defaultPositionConfig, this._positionToObject(positionProp));
    }
    return defaultPositionConfig;
  }
  _positionToObject(position3) {
    if (isString(position3)) {
      return extend({}, OVERLAY_POSITION_ALIASES[position3]);
    }
    return position3;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/overlay/m_z_index.js
var baseZIndex = 1500;
var zIndexStack = [];
var base = (ZIndex) => {
  baseZIndex = ensureDefined(ZIndex, baseZIndex);
  return baseZIndex;
};
var create = function() {
  let baseIndex = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : baseZIndex;
  const {
    length
  } = zIndexStack;
  const index2 = (length ? zIndexStack[length - 1] : baseIndex) + 1;
  zIndexStack.push(index2);
  return index2;
};
var remove = (zIndex) => {
  const position3 = zIndexStack.indexOf(zIndex);
  if (position3 >= 0) {
    zIndexStack.splice(position3, 1);
  }
};
var isLastZIndexInStack = (zIndex) => zIndexStack.length && zIndexStack[zIndexStack.length - 1] === zIndex;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/overlay/m_overlay.js
var ready3 = ready_callbacks_default.add;
var window13 = getWindow();
var viewPortChanged = changeCallback;
var OVERLAY_STACK = [];
ready3(() => {
  events_engine_default.subscribeGlobal(dom_adapter_default.getDocument(), pointer_default.down, (e) => {
    for (let i = OVERLAY_STACK.length - 1; i >= 0; i--) {
      if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
        return;
      }
    }
  });
});
var Overlay = ui_widget_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), {
      escape() {
        this.hide();
      }
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      activeStateEnabled: false,
      visible: false,
      deferRendering: true,
      shading: true,
      shadingColor: "",
      wrapperAttr: {},
      position: extend({}, OVERLAY_POSITION_ALIASES.center),
      width: "80vw",
      minWidth: null,
      maxWidth: null,
      height: "80vh",
      minHeight: null,
      maxHeight: null,
      animation: {
        show: {
          type: "pop",
          duration: 300,
          from: {
            scale: 0.55
          }
        },
        hide: {
          type: "pop",
          duration: 300,
          from: {
            opacity: 1,
            scale: 1
          },
          to: {
            opacity: 0,
            scale: 0.55
          }
        }
      },
      closeOnOutsideClick: false,
      hideOnOutsideClick: false,
      _ignorePreventScrollEventsDeprecation: false,
      onShowing: null,
      onShown: null,
      onHiding: null,
      onHidden: null,
      contentTemplate: "content",
      innerOverlay: false,
      restorePosition: true,
      container: void 0,
      visualContainer: void 0,
      hideTopOverlayHandler: () => {
        this.hide();
      },
      hideOnParentScroll: false,
      preventScrollEvents: true,
      onPositioned: null,
      propagateOutsideClick: false,
      ignoreChildEvents: true,
      _checkParentVisibility: true,
      _hideOnParentScrollTarget: void 0,
      _fixWrapperPosition: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => !hasWindow(),
      options: {
        width: null,
        height: null,
        animation: null,
        _checkParentVisibility: false
      }
    }]);
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      animation: true
    });
  },
  $wrapper() {
    return this._$wrapper;
  },
  _eventBindingTarget() {
    return this._$content;
  },
  _setDeprecatedOptions() {
    this.callBase();
    extend(this._deprecatedOptions, {
      closeOnOutsideClick: {
        since: "22.1",
        alias: "hideOnOutsideClick"
      }
    });
  },
  ctor(element, options2) {
    this.callBase(element, options2);
    if (options2) {
      if ("preventScrollEvents" in options2 && !options2._ignorePreventScrollEventsDeprecation) {
        this._logDeprecatedPreventScrollEventsInfo();
      }
    }
  },
  _logDeprecatedPreventScrollEventsInfo() {
    this._logDeprecatedOptionWarning("preventScrollEvents", {
      since: "23.1",
      message: "If you enable this option, end-users may experience scrolling issues."
    });
  },
  _init() {
    this.callBase();
    this._initActions();
    this._initHideOnOutsideClickHandler();
    this._initTabTerminatorHandler();
    this._customWrapperClass = null;
    this._$wrapper = renderer_default("<div>").addClass("dx-overlay-wrapper");
    this._$content = renderer_default("<div>").addClass("dx-overlay-content");
    this._initInnerOverlayClass();
    const $element = this.$element();
    $element.addClass("dx-overlay");
    this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
    this._toggleViewPortSubscription(true);
    this._initHideTopOverlayHandler(this.option("hideTopOverlayHandler"));
    this._parentsScrollSubscriptionInfo = {
      handler: (e) => {
        this._hideOnParentsScrollHandler(e);
      }
    };
    this.warnPositionAsFunction();
  },
  warnPositionAsFunction() {
    if (isFunction(this.option("position"))) {
      errors_default.log("W0018");
    }
  },
  _initInnerOverlayClass() {
    this._$content.toggleClass("dx-inner-overlay", this.option("innerOverlay"));
  },
  _initHideTopOverlayHandler(handler) {
    this._hideTopOverlayHandler = handler;
  },
  _getActionsList: () => ["onShowing", "onShown", "onHiding", "onHidden", "onPositioned", "onVisualPositionChanged"],
  _initActions() {
    this._actions = {};
    const actions = this._getActionsList();
    each(actions, (_, action) => {
      this._actions[action] = this._createActionByOption(action, {
        excludeValidators: ["disabled", "readOnly"]
      }) || noop2;
    });
  },
  _initHideOnOutsideClickHandler() {
    var _this = this;
    this._proxiedDocumentDownHandler = function() {
      return _this._documentDownHandler(...arguments);
    };
  },
  _initMarkup() {
    this.callBase();
    this._renderWrapperAttributes();
    this._initPositionController();
  },
  _documentDownHandler(e) {
    if (this._showAnimationProcessing) {
      this._stopAnimation();
    }
    const isAttachedTarget = renderer_default(window13.document).is(e.target) || contains2(window13.document, e.target);
    const isInnerOverlay = renderer_default(e.target).closest(".dx-inner-overlay").length;
    const outsideClick = isAttachedTarget && !isInnerOverlay && !(this._$content.is(e.target) || contains2(this._$content.get(0), e.target));
    if (outsideClick && this._shouldHideOnOutsideClick(e)) {
      this._outsideClickHandler(e);
    }
    return this.option("propagateOutsideClick");
  },
  _shouldHideOnOutsideClick(e) {
    const {
      hideOnOutsideClick
    } = this.option();
    if (isFunction(hideOnOutsideClick)) {
      return hideOnOutsideClick(e);
    }
    return hideOnOutsideClick;
  },
  _outsideClickHandler(e) {
    if (this.option("shading")) {
      e.preventDefault();
    }
    this.hide();
  },
  _getAnonymousTemplateName: () => "content",
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new EmptyTemplate()
    });
    this.callBase();
  },
  _isTopOverlay() {
    const overlayStack = this._overlayStack();
    for (let i = overlayStack.length - 1; i >= 0; i--) {
      const tabbableElements = overlayStack[i]._findTabbableBounds();
      if (tabbableElements.first || tabbableElements.last) {
        return overlayStack[i] === this;
      }
    }
    return false;
  },
  _overlayStack: () => OVERLAY_STACK,
  _zIndexInitValue: () => Overlay.baseZIndex(),
  _toggleViewPortSubscription(toggle) {
    var _this2 = this;
    viewPortChanged.remove(this._viewPortChangeHandle);
    if (toggle) {
      this._viewPortChangeHandle = function() {
        _this2._viewPortChangeHandler(...arguments);
      };
      viewPortChanged.add(this._viewPortChangeHandle);
    }
  },
  _viewPortChangeHandler() {
    this._positionController.updateContainer(this.option("container"));
    this._refresh();
  },
  _renderWrapperAttributes() {
    const {
      wrapperAttr
    } = this.option();
    const attributes = extend({}, wrapperAttr);
    const classNames = attributes.class;
    delete attributes.class;
    this.$wrapper().attr(attributes).removeClass(this._customWrapperClass).addClass(classNames);
    this._customWrapperClass = classNames;
  },
  _renderVisibilityAnimate(visible2) {
    this._stopAnimation();
    return visible2 ? this._show() : this._hide();
  },
  _getAnimationConfig() {
    return this._getOptionValue("animation", this);
  },
  _toggleBodyScroll: noop2,
  _animateShowing() {
    var _this3 = this;
    const animation3 = this._getAnimationConfig() ?? {};
    const showAnimation = this._normalizeAnimation(animation3.show, "to");
    const startShowAnimation = (null === showAnimation || void 0 === showAnimation ? void 0 : showAnimation.start) ?? noop2;
    const completeShowAnimation = (null === showAnimation || void 0 === showAnimation ? void 0 : showAnimation.complete) ?? noop2;
    this._animate(showAnimation, function() {
      if (_this3._isAnimationPaused) {
        return;
      }
      if (_this3.option("focusStateEnabled")) {
        events_engine_default.trigger(_this3._focusTarget(), "focus");
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      completeShowAnimation.call(_this3, ...args);
      _this3._showAnimationProcessing = false;
      _this3._isHidden = false;
      _this3._actions.onShown();
      _this3._toggleSafariScrolling();
      _this3._showingDeferred.resolve();
    }, function() {
      if (_this3._isAnimationPaused) {
        return;
      }
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      startShowAnimation.call(_this3, ...args);
      _this3._showAnimationProcessing = true;
    });
  },
  _processShowingHidingCancel(cancelArg, applyFunction, cancelFunction) {
    if (isPromise(cancelArg)) {
      cancelArg.then((shouldCancel) => {
        if (shouldCancel) {
          cancelFunction();
        } else {
          applyFunction();
        }
      }).catch(() => applyFunction());
    } else {
      cancelArg ? cancelFunction() : applyFunction();
    }
  },
  _show() {
    this._showingDeferred = Deferred();
    this._parentHidden = this._isParentHidden();
    this._showingDeferred.done(() => {
      delete this._parentHidden;
    });
    if (this._parentHidden) {
      this._isHidden = true;
      return this._showingDeferred.resolve();
    }
    if (this._currentVisible) {
      return Deferred().resolve().promise();
    }
    this._currentVisible = true;
    if (this._isHidingActionCanceled) {
      delete this._isHidingActionCanceled;
      this._showingDeferred.reject();
    } else {
      const show = () => {
        this._stopAnimation();
        this._toggleBodyScroll(this.option("enableBodyScroll"));
        this._toggleVisibility(true);
        this._$content.css("visibility", "hidden");
        this._$content.toggleClass("dx-state-invisible", false);
        this._updateZIndexStackPosition(true);
        this._positionController.openingHandled();
        this._renderContent();
        const showingArgs = {
          cancel: false
        };
        this._actions.onShowing(showingArgs);
        this._processShowingHidingCancel(showingArgs.cancel, () => {
          this._$content.css("visibility", "");
          this._renderVisibility(true);
          this._animateShowing();
        }, () => {
          this._toggleVisibility(false);
          this._$content.css("visibility", "");
          this._$content.toggleClass("dx-state-invisible", true);
          this._isShowingActionCanceled = true;
          this._moveFromContainer();
          this._toggleBodyScroll(true);
          this.option("visible", false);
          this._showingDeferred.resolve();
        });
      };
      if (this.option("templatesRenderAsynchronously")) {
        this._stopShowTimer();
        this._asyncShowTimeout = setTimeout(show);
      } else {
        show();
      }
    }
    return this._showingDeferred.promise();
  },
  _normalizeAnimation(showHideConfig, direction) {
    if (showHideConfig) {
      showHideConfig = extend({
        type: "slide",
        skipElementInitialStyles: true
      }, showHideConfig);
      if (isObject(showHideConfig[direction])) {
        extend(showHideConfig[direction], {
          position: this._positionController.position
        });
      }
    }
    return showHideConfig;
  },
  _animateHiding() {
    var _this4 = this;
    const animation3 = this._getAnimationConfig() ?? {};
    const hideAnimation = this._normalizeAnimation(animation3.hide, "from");
    const startHideAnimation = (null === hideAnimation || void 0 === hideAnimation ? void 0 : hideAnimation.start) ?? noop2;
    const completeHideAnimation = (null === hideAnimation || void 0 === hideAnimation ? void 0 : hideAnimation.complete) ?? noop2;
    this._animate(hideAnimation, function() {
      var _this4$_actions;
      _this4._$content.css("pointerEvents", "");
      _this4._renderVisibility(false);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      completeHideAnimation.call(_this4, ...args);
      _this4._hideAnimationProcessing = false;
      null === (_this4$_actions = _this4._actions) || void 0 === _this4$_actions || _this4$_actions.onHidden();
      _this4._hidingDeferred.resolve();
    }, function() {
      _this4._$content.css("pointerEvents", "none");
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      startHideAnimation.call(_this4, ...args);
      _this4._hideAnimationProcessing = true;
    });
  },
  _hide() {
    if (!this._currentVisible) {
      return Deferred().resolve().promise();
    }
    this._currentVisible = false;
    this._hidingDeferred = Deferred();
    const hidingArgs = {
      cancel: false
    };
    if (this._isShowingActionCanceled) {
      delete this._isShowingActionCanceled;
      this._hidingDeferred.reject();
    } else {
      this._actions.onHiding(hidingArgs);
      this._toggleSafariScrolling();
      this._toggleBodyScroll(true);
      const cancelHide = () => {
        this._isHidingActionCanceled = true;
        this._toggleBodyScroll(this.option("enableBodyScroll"));
        this.option("visible", true);
        this._hidingDeferred.resolve();
      };
      const applyHide = () => {
        this._forceFocusLost();
        this._toggleShading(false);
        this._toggleSubscriptions(false);
        this._stopShowTimer();
        this._animateHiding();
      };
      this._processShowingHidingCancel(hidingArgs.cancel, applyHide, cancelHide);
    }
    return this._hidingDeferred.promise();
  },
  _forceFocusLost() {
    const activeElement = dom_adapter_default.getActiveElement();
    const shouldResetActiveElement = !!this._$content.find(activeElement).length;
    if (shouldResetActiveElement) {
      resetActiveElement();
    }
  },
  _animate(animation3, completeCallback, startCallback) {
    if (animation3) {
      startCallback = startCallback || animation3.start || noop2;
      fx_default.animate(this._$content, extend({}, animation3, {
        start: startCallback,
        complete: completeCallback
      }));
    } else {
      completeCallback();
    }
  },
  _stopAnimation() {
    fx_default.stop(this._$content, true);
  },
  _renderVisibility(visible2) {
    if (visible2 && this._isParentHidden()) {
      return;
    }
    this._currentVisible = visible2;
    this._stopAnimation();
    if (!visible2) {
      triggerHidingEvent(this._$content);
    }
    if (visible2) {
      this._checkContainerExists();
      this._moveToContainer();
      this._renderGeometry();
      triggerShownEvent(this._$content);
      triggerResizeEvent(this._$content);
    } else {
      this._toggleVisibility(visible2);
      this._$content.toggleClass("dx-state-invisible", !visible2);
      this._updateZIndexStackPosition(visible2);
      this._moveFromContainer();
    }
    this._toggleShading(visible2);
    this._toggleSubscriptions(visible2);
  },
  _updateZIndexStackPosition(pushToStack) {
    const overlayStack = this._overlayStack();
    const index2 = overlayStack.indexOf(this);
    if (pushToStack) {
      if (-1 === index2) {
        this._zIndex = create(this._zIndexInitValue());
        overlayStack.push(this);
      }
      this._$wrapper.css("zIndex", this._zIndex);
      this._$content.css("zIndex", this._zIndex);
    } else if (-1 !== index2) {
      overlayStack.splice(index2, 1);
      remove(this._zIndex);
    }
  },
  _toggleShading(visible2) {
    this._$wrapper.toggleClass("dx-overlay-shader", visible2 && this.option("shading"));
    this._$wrapper.css("backgroundColor", this.option("shading") ? this.option("shadingColor") : "");
    this._toggleTabTerminator(visible2 && this.option("shading"));
  },
  _initTabTerminatorHandler() {
    var _this5 = this;
    this._proxiedTabTerminatorHandler = function() {
      _this5._tabKeyHandler(...arguments);
    };
  },
  _toggleTabTerminator(enabled) {
    const eventName = addNamespace2("keydown", this.NAME);
    if (enabled) {
      events_engine_default.on(dom_adapter_default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    } else {
      events_engine_default.off(dom_adapter_default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    }
  },
  _findTabbableBounds() {
    const $elements = this._$wrapper.find("*");
    const elementsCount = $elements.length - 1;
    const result2 = {
      first: null,
      last: null
    };
    for (let i = 0; i <= elementsCount; i++) {
      if (!result2.first && $elements.eq(i).is(tabbable)) {
        result2.first = $elements.eq(i);
      }
      if (!result2.last && $elements.eq(elementsCount - i).is(tabbable)) {
        result2.last = $elements.eq(elementsCount - i);
      }
      if (result2.first && result2.last) {
        break;
      }
    }
    return result2;
  },
  _tabKeyHandler(e) {
    if ("tab" !== normalizeKeyName(e) || !this._isTopOverlay()) {
      return;
    }
    const tabbableElements = this._findTabbableBounds();
    const $firstTabbable = tabbableElements.first;
    const $lastTabbable = tabbableElements.last;
    const isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0);
    const isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0);
    const isEmptyTabList = 0 === tabbableElements.length;
    const isOutsideTarget = !contains2(this._$wrapper.get(0), e.target);
    if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
      e.preventDefault();
      const $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;
      events_engine_default.trigger($focusElement, "focusin");
      events_engine_default.trigger($focusElement, "focus");
    }
  },
  _toggleSubscriptions(enabled) {
    if (hasWindow()) {
      this._toggleHideTopOverlayCallback(enabled);
      this._toggleHideOnParentsScrollSubscription(enabled);
    }
  },
  _toggleHideTopOverlayCallback(subscribe) {
    if (!this._hideTopOverlayHandler) {
      return;
    }
    if (subscribe) {
      hideCallback.add(this._hideTopOverlayHandler);
    } else {
      hideCallback.remove(this._hideTopOverlayHandler);
    }
  },
  _toggleHideOnParentsScrollSubscription(needSubscribe) {
    const scrollEvent = addNamespace2("scroll", this.NAME);
    const {
      prevTargets,
      handler
    } = this._parentsScrollSubscriptionInfo ?? {};
    events_engine_default.off(prevTargets, scrollEvent, handler);
    const hideOnScroll = this.option("hideOnParentScroll");
    if (needSubscribe && hideOnScroll) {
      let $parents = this._getHideOnParentScrollTarget().parents();
      if ("desktop" === devices_default.real().deviceType) {
        $parents = $parents.add(window13);
      }
      events_engine_default.on($parents, scrollEvent, handler);
      this._parentsScrollSubscriptionInfo.prevTargets = $parents;
    }
  },
  _hideOnParentsScrollHandler(e) {
    let hideHandled = false;
    const hideOnScroll = this.option("hideOnParentScroll");
    if (isFunction(hideOnScroll)) {
      hideHandled = hideOnScroll(e);
    }
    if (!hideHandled && !this._showAnimationProcessing) {
      this.hide();
    }
  },
  _getHideOnParentScrollTarget() {
    const $hideOnParentScrollTarget = renderer_default(this.option("_hideOnParentScrollTarget"));
    if ($hideOnParentScrollTarget.length) {
      return $hideOnParentScrollTarget;
    }
    return this._$wrapper;
  },
  _render() {
    this.callBase();
    this._appendContentToElement();
    this._renderVisibilityAnimate(this.option("visible"));
  },
  _appendContentToElement() {
    if (!this._$content.parent().is(this.$element())) {
      this._$content.appendTo(this.$element());
    }
  },
  _renderContent() {
    const shouldDeferRendering = !this._currentVisible && this.option("deferRendering");
    const isParentHidden = this.option("visible") && this._isParentHidden();
    if (isParentHidden) {
      this._isHidden = true;
      return;
    }
    if (this._contentAlreadyRendered || shouldDeferRendering) {
      return;
    }
    this._contentAlreadyRendered = true;
    this._appendContentToElement();
    this.callBase();
  },
  _isParentHidden() {
    if (!this.option("_checkParentVisibility")) {
      return false;
    }
    if (void 0 !== this._parentHidden) {
      return this._parentHidden;
    }
    const $parent = this.$element().parent();
    if ($parent.is(":visible")) {
      return false;
    }
    let isHidden = false;
    $parent.add($parent.parents()).each((index2, element) => {
      const $element = renderer_default(element);
      if ("none" === $element.css("display")) {
        isHidden = true;
        return false;
      }
    });
    return isHidden || !dom_adapter_default.getBody().contains($parent.get(0));
  },
  _renderContentImpl() {
    const whenContentRendered = Deferred();
    const contentTemplateOption = this.option("contentTemplate");
    const contentTemplate = this._getTemplate(contentTemplateOption);
    const transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;
    contentTemplate && contentTemplate.render({
      container: getPublicElement(this.$content()),
      noModel: true,
      transclude,
      onRendered: () => {
        whenContentRendered.resolve();
        if (this.option("templatesRenderAsynchronously")) {
          this._dimensionChanged();
        }
      }
    });
    this._toggleWrapperScrollEventsSubscription(this.option("preventScrollEvents"));
    whenContentRendered.done(() => {
      if (this.option("visible")) {
        this._moveToContainer();
      }
    });
    return whenContentRendered.promise();
  },
  _getPositionControllerConfig() {
    const {
      container,
      visualContainer,
      _fixWrapperPosition,
      restorePosition,
      _skipContentPositioning
    } = this.option();
    return {
      container,
      visualContainer,
      $root: this.$element(),
      $content: this._$content,
      $wrapper: this._$wrapper,
      onPositioned: this._actions.onPositioned,
      onVisualPositionChanged: this._actions.onVisualPositionChanged,
      restorePosition,
      _fixWrapperPosition,
      _skipContentPositioning
    };
  },
  _initPositionController() {
    this._positionController = new OverlayPositionController(this._getPositionControllerConfig());
  },
  _toggleWrapperScrollEventsSubscription(enabled) {
    const eventName = addNamespace2(DRAG_EVENT, this.NAME);
    events_engine_default.off(this._$wrapper, eventName);
    if (enabled) {
      events_engine_default.on(this._$wrapper, eventName, {
        validate: () => true,
        getDirection: () => "both",
        _toggleGestureCover(toggle) {
          if (!toggle) {
            this._toggleGestureCoverImpl(toggle);
          }
        },
        _clearSelection: noop2,
        isNative: true
      }, (e) => {
        const {
          originalEvent
        } = e.originalEvent;
        const {
          type: type2
        } = originalEvent || {};
        const isWheel = "wheel" === type2;
        const isMouseMove = "mousemove" === type2;
        const isScrollByWheel = isWheel && !isCommandKeyPressed(e);
        e._cancelPreventDefault = true;
        if (originalEvent && false !== e.cancelable && (!isMouseMove && !isWheel || isScrollByWheel)) {
          e.preventDefault();
        }
      });
    }
  },
  _moveFromContainer() {
    this._$content.appendTo(this.$element());
    this._$wrapper.detach();
  },
  _checkContainerExists() {
    const $wrapperContainer = this._positionController.$container;
    if (void 0 === $wrapperContainer) {
      return;
    }
    const containerExists = $wrapperContainer.length > 0;
    if (!containerExists) {
      ui_errors_default.log("W1021", this.NAME);
    }
  },
  _moveToContainer() {
    const $wrapperContainer = this._positionController.$container;
    this._$wrapper.appendTo($wrapperContainer);
    this._$content.appendTo(this._$wrapper);
  },
  _renderGeometry(options2) {
    const {
      visible: visible2
    } = this.option();
    if (visible2 && hasWindow()) {
      this._stopAnimation();
      this._renderGeometryImpl();
    }
  },
  _renderGeometryImpl() {
    this._positionController.updatePosition(this._getOptionValue("position"));
    this._renderWrapper();
    this._renderDimensions();
    this._renderPosition();
  },
  _renderPosition() {
    this._positionController.positionContent();
  },
  _isAllWindowCovered() {
    return isWindow(this._positionController.$visualContainer.get(0)) && this.option("shading");
  },
  _toggleSafariScrolling() {
    const visible2 = this.option("visible");
    const $body = renderer_default(dom_adapter_default.getBody());
    const isIosSafari = "ios" === devices_default.real().platform && browser_default.safari;
    const isAllWindowCovered = this._isAllWindowCovered();
    const isScrollingPrevented = $body.hasClass("dx-prevent-safari-scrolling");
    const shouldPreventScrolling = !isScrollingPrevented && visible2 && isAllWindowCovered;
    const shouldEnableScrolling = isScrollingPrevented && (!visible2 || !isAllWindowCovered || this._disposed);
    if (isIosSafari) {
      if (shouldEnableScrolling) {
        $body.removeClass("dx-prevent-safari-scrolling");
        window13.scrollTo(0, this._cachedBodyScrollTop);
        this._cachedBodyScrollTop = void 0;
      } else if (shouldPreventScrolling) {
        this._cachedBodyScrollTop = window13.pageYOffset;
        $body.addClass("dx-prevent-safari-scrolling");
      }
    }
  },
  _renderWrapper() {
    this._positionController.styleWrapperPosition();
    this._renderWrapperDimensions();
    this._positionController.positionWrapper();
  },
  _renderWrapperDimensions() {
    const {
      $visualContainer
    } = this._positionController;
    const documentElement = dom_adapter_default.getDocumentElement();
    const isVisualContainerWindow = isWindow($visualContainer.get(0));
    const wrapperWidth = isVisualContainerWindow ? documentElement.clientWidth : getOuterWidth($visualContainer);
    const wrapperHeight = isVisualContainerWindow ? window13.innerHeight : getOuterHeight($visualContainer);
    this._$wrapper.css({
      width: wrapperWidth,
      height: wrapperHeight
    });
  },
  _renderDimensions() {
    const content = this._$content.get(0);
    this._$content.css({
      minWidth: this._getOptionValue("minWidth", content),
      maxWidth: this._getOptionValue("maxWidth", content),
      minHeight: this._getOptionValue("minHeight", content),
      maxHeight: this._getOptionValue("maxHeight", content),
      width: this._getOptionValue("width", content),
      height: this._getOptionValue("height", content)
    });
  },
  _focusTarget() {
    return this._$content;
  },
  _attachKeyboardEvents() {
    this._keyboardListenerId = keyboard.on(this._$content, null, (opts) => this._keyboardHandler(opts));
  },
  _keyboardHandler(options2) {
    const e = options2.originalEvent;
    const $target = renderer_default(e.target);
    if ($target.is(this._$content) || !this.option("ignoreChildEvents")) {
      this.callBase(...arguments);
    }
  },
  _isVisible() {
    return this.option("visible");
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      if (this.option("visible")) {
        this._renderVisibilityAnimate(visible2);
      }
    } else {
      this._renderVisibilityAnimate(visible2);
    }
  },
  _dimensionChanged() {
    this._renderGeometry();
  },
  _clean() {
    const options2 = this.option();
    if (!this._contentAlreadyRendered && !options2.isRenovated) {
      this.$content().empty();
    }
    this._renderVisibility(false);
    this._stopShowTimer();
    this._cleanFocusState();
  },
  _stopShowTimer() {
    if (this._asyncShowTimeout) {
      clearTimeout(this._asyncShowTimeout);
    }
    this._asyncShowTimeout = null;
  },
  _dispose() {
    fx_default.stop(this._$content, false);
    clearTimeout(this._deferShowTimer);
    this._toggleViewPortSubscription(false);
    this._toggleSubscriptions(false);
    this._updateZIndexStackPosition(false);
    this._toggleTabTerminator(false);
    this._actions = null;
    this._parentsScrollSubscriptionInfo = null;
    this.callBase();
    this._toggleSafariScrolling();
    this.option("visible") && remove(this._zIndex);
    this._$wrapper.remove();
    this._$content.remove();
  },
  _toggleRTLDirection(rtl) {
    this._$content.toggleClass("dx-rtl", rtl);
  },
  _optionChanged(args) {
    const {
      value: value2,
      name: name2
    } = args;
    if (this._getActionsList().includes(name2)) {
      this._initActions();
      return;
    }
    switch (name2) {
      case "animation":
      case "closeOnOutsideClick":
      case "hideOnOutsideClick":
      case "propagateOutsideClick":
        break;
      case "shading":
        this._toggleShading(this.option("visible"));
        this._toggleSafariScrolling();
        break;
      case "shadingColor":
        this._toggleShading(this.option("visible"));
        break;
      case "width":
      case "height":
      case "minWidth":
      case "maxWidth":
      case "minHeight":
      case "maxHeight":
        this._renderGeometry();
        break;
      case "position":
        this._positionController.updatePosition(this.option("position"));
        this._positionController.restorePositionOnNextRender(true);
        this._renderGeometry();
        this._toggleSafariScrolling();
        break;
      case "visible":
        this._renderVisibilityAnimate(value2).done(() => {
          var _this$_animateDeferre;
          return null === (_this$_animateDeferre = this._animateDeferred) || void 0 === _this$_animateDeferre ? void 0 : _this$_animateDeferre.resolveWith(this);
        }).fail(() => {
          var _this$_animateDeferre2;
          return null === (_this$_animateDeferre2 = this._animateDeferred) || void 0 === _this$_animateDeferre2 ? void 0 : _this$_animateDeferre2.reject();
        });
        break;
      case "container":
        this._positionController.updateContainer(value2);
        this._invalidate();
        this._toggleSafariScrolling();
        break;
      case "visualContainer":
        this._positionController.updateVisualContainer(value2);
        this._renderWrapper();
        this._toggleSafariScrolling();
        break;
      case "innerOverlay":
        this._initInnerOverlayClass();
        break;
      case "deferRendering":
      case "contentTemplate":
        this._contentAlreadyRendered = false;
        this._clean();
        this._invalidate();
        break;
      case "hideTopOverlayHandler":
        this._toggleHideTopOverlayCallback(false);
        this._initHideTopOverlayHandler(value2);
        this._toggleHideTopOverlayCallback(this.option("visible"));
        break;
      case "hideOnParentScroll":
      case "_hideOnParentScrollTarget":
        this._toggleHideOnParentsScrollSubscription(this.option("visible"));
        break;
      case "rtlEnabled":
        this._contentAlreadyRendered = false;
        this.callBase(args);
        break;
      case "_fixWrapperPosition":
        this._positionController.fixWrapperPosition = value2;
        break;
      case "wrapperAttr":
        this._renderWrapperAttributes();
        break;
      case "restorePosition":
        this._positionController.restorePosition = value2;
        break;
      case "preventScrollEvents":
        this._logDeprecatedPreventScrollEventsInfo();
        this._toggleWrapperScrollEventsSubscription(value2);
        break;
      default:
        this.callBase(args);
    }
  },
  toggle(showing) {
    showing = void 0 === showing ? !this.option("visible") : showing;
    const result2 = Deferred();
    if (showing === this.option("visible")) {
      return result2.resolveWith(this, [showing]).promise();
    }
    const animateDeferred = Deferred();
    this._animateDeferred = animateDeferred;
    this.option("visible", showing);
    animateDeferred.promise().done(() => {
      delete this._animateDeferred;
      result2.resolveWith(this, [this.option("visible")]);
    }).fail(() => {
      delete this._animateDeferred;
      result2.reject();
    });
    return result2.promise();
  },
  $content() {
    return this._$content;
  },
  show() {
    return this.toggle(true);
  },
  hide() {
    return this.toggle(false);
  },
  content() {
    return getPublicElement(this._$content);
  },
  repaint() {
    if (this._contentAlreadyRendered) {
      this._positionController.restorePositionOnNextRender(true);
      this._renderGeometry({
        forceStopAnimation: true
      });
      triggerResizeEvent(this._$content);
    } else {
      this.callBase();
    }
  }
});
Overlay.baseZIndex = (zIndex) => base(zIndex);
component_registrator_default("dxOverlay", Overlay);
var m_overlay_default = Overlay;

// ../../../../../../node_modules/devextreme/esm/ui/overlay/ui.overlay.js
var ui_overlay_default = m_overlay_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_validation_message.js
var INVALID_MESSAGE = "dx-invalid-message";
var INVALID_MESSAGE_AUTO = "dx-invalid-message-auto";
var INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always";
var INVALID_MESSAGE_CONTENT = "dx-invalid-message-content";
var ValidationMessage = ui_overlay_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      integrationOptions: {},
      templatesRenderAsynchronously: false,
      shading: false,
      width: "auto",
      height: "auto",
      hideOnOutsideClick: false,
      animation: null,
      visible: true,
      propagateOutsideClick: true,
      _checkParentVisibility: false,
      rtlEnabled: false,
      contentTemplate: this._renderInnerHtml,
      maxWidth: "100%",
      container: this.$element(),
      target: void 0,
      mode: "auto",
      validationErrors: void 0,
      preventScrollEvents: false,
      positionSide: "top",
      boundary: void 0,
      offset: {
        h: 0,
        v: 0
      },
      contentId: void 0
    });
  },
  _init() {
    this.callBase();
    this.updateMaxWidth();
    this._updatePosition();
  },
  _initMarkup() {
    this.callBase();
    this._ensureMessageNotEmpty();
    this._updatePositionByTarget();
    this._toggleModeClass();
    this._updateContentId();
  },
  _updatePositionByTarget() {
    const {
      target
    } = this.option();
    this.option("position.of", target);
  },
  _ensureMessageNotEmpty() {
    this._textMarkup = this._getTextMarkup();
    const shouldShowMessage = this.option("visible") && this._textMarkup;
    this._toggleVisibilityClasses(shouldShowMessage);
  },
  _toggleVisibilityClasses(visible2) {
    if (visible2) {
      this.$element().addClass(INVALID_MESSAGE);
      this.$wrapper().addClass(INVALID_MESSAGE);
    } else {
      this.$element().removeClass(INVALID_MESSAGE);
      this.$wrapper().removeClass(INVALID_MESSAGE);
    }
  },
  _updateContentId() {
    const {
      container,
      contentId
    } = this.option();
    const id = contentId ?? renderer_default(container).attr("aria-describedby");
    this.$content().addClass(INVALID_MESSAGE_CONTENT).attr("id", id);
  },
  _renderInnerHtml(element) {
    const $element = element && renderer_default(element);
    null === $element || void 0 === $element || $element.html(this._textMarkup);
  },
  _getTextMarkup() {
    const validationErrors = this.option("validationErrors") ?? [];
    let validationErrorMessage = "";
    validationErrors.forEach((err) => {
      const separator = validationErrorMessage ? "<br />" : "";
      validationErrorMessage += separator + encodeHtml((null === err || void 0 === err ? void 0 : err.message) ?? "");
    });
    return validationErrorMessage;
  },
  _toggleModeClass() {
    const mode = this.option("mode");
    this.$wrapper().toggleClass(INVALID_MESSAGE_AUTO, "auto" === mode).toggleClass(INVALID_MESSAGE_ALWAYS, "always" === mode);
  },
  updateMaxWidth() {
    const target = this.option("target");
    const targetWidth = getOuterWidth(target);
    let maxWidth = "100%";
    if (targetWidth) {
      maxWidth = Math.max(targetWidth, 100);
    }
    this.option({
      maxWidth
    });
  },
  _getPositionsArray(positionSide, rtlSide) {
    switch (positionSide) {
      case "top":
        return [`${rtlSide} bottom`, `${rtlSide} top`];
      case "left":
        return ["right", "left"];
      case "right":
        return ["left", "right"];
      default:
        return [`${rtlSide} top`, `${rtlSide} bottom`];
    }
  },
  _updatePosition() {
    const {
      positionSide,
      rtlEnabled,
      offset: componentOffset,
      boundary
    } = this.option();
    const rtlSide = getDefaultAlignment(rtlEnabled);
    const positions = this._getPositionsArray(positionSide, rtlSide);
    const offset2 = _extends({}, componentOffset);
    this.$element().addClass(`dx-invalid-message-${positionSide}`);
    if (rtlEnabled && "left" !== positionSide && "right" !== positionSide) {
      offset2.h = -offset2.h;
    }
    if ("top" === positionSide) {
      offset2.v = -offset2.v;
    }
    if ("left" === positionSide) {
      offset2.h = -offset2.h;
    }
    this.option("position", {
      offset: offset2,
      boundary,
      my: positions[0],
      at: positions[1],
      collision: "none flip"
    });
  },
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "target":
        this._updatePositionByTarget();
        this.updateMaxWidth();
        this.callBase(args);
        break;
      case "boundary":
        this.option("position.boundary", value2);
        break;
      case "mode":
        this._toggleModeClass(value2);
        break;
      case "rtlEnabled":
      case "offset":
      case "positionSide":
        this.$element().removeClass(`dx-invalid-message-${previousValue}`);
        this._updatePosition();
        break;
      case "container":
        this._updateContentId();
        this.callBase(args);
        break;
      case "contentId":
        this._updateContentId();
        break;
      case "validationErrors":
        this._ensureMessageNotEmpty();
        this._renderInnerHtml(this.$content());
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxValidationMessage", ValidationMessage);
var m_validation_message_default = ValidationMessage;

// ../../../../../../node_modules/devextreme/esm/ui/validation_message.js
var validation_message_default = m_validation_message_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/editor/m_editor.js
var INVALID_MESSAGE_AUTO2 = "dx-invalid-message-auto";
var DX_INVALID_BADGE_CLASS = "dx-show-invalid-badge";
var VALIDATION_TARGET = "dx-validation-target";
var ALLOWED_STYLING_MODES = ["outlined", "filled", "underlined"];
var VALIDATION_MESSAGE_KEYS_MAP = {
  validationMessageMode: "mode",
  validationMessagePosition: "positionSide",
  validationMessageOffset: "offset",
  validationBoundary: "boundary"
};
var Editor = ui_widget_default.inherit({
  ctor() {
    this.showValidationMessageTimeout = null;
    this.validationRequest = callbacks_default();
    this.callBase.apply(this, arguments);
  },
  _createElement(element) {
    this.callBase(element);
    const $element = this.$element();
    if ($element) {
      data($element[0], VALIDATION_TARGET, this);
    }
  },
  _initOptions(options2) {
    this.callBase.apply(this, arguments);
    this.option(validation_engine_default.initValidationOptions(options2));
  },
  _init() {
    this._initialValue = this.option("value");
    this.callBase();
    this._options.cache("validationTooltipOptions", this.option("validationTooltipOptions"));
    const $element = this.$element();
    $element.addClass(DX_INVALID_BADGE_CLASS);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: null,
      name: "",
      onValueChanged: null,
      readOnly: false,
      isValid: true,
      validationError: null,
      validationErrors: null,
      validationStatus: "valid",
      validationMessageMode: "auto",
      validationMessagePosition: "bottom",
      validationBoundary: void 0,
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {},
      _showValidationMessage: true,
      isDirty: false
    });
  },
  _attachKeyboardEvents() {
    if (!this.option("readOnly")) {
      this.callBase();
    }
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      validationError: true
    });
  },
  _createValueChangeAction() {
    this._valueChangeAction = this._createActionByOption("onValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _suppressValueChangeAction() {
    this._valueChangeActionSuppressed = true;
  },
  _resumeValueChangeAction() {
    this._valueChangeActionSuppressed = false;
  },
  _initMarkup() {
    var _this$option;
    this._toggleReadOnlyState();
    this._setSubmitElementName(this.option("name"));
    this.callBase();
    this._renderValidationState();
    null === (_this$option = this.option("_onMarkupRendered")) || void 0 === _this$option || _this$option();
  },
  _raiseValueChangeAction(value2, previousValue) {
    if (!this._valueChangeAction) {
      this._createValueChangeAction();
    }
    this._valueChangeAction(this._valueChangeArgs(value2, previousValue));
  },
  _valueChangeArgs(value2, previousValue) {
    return {
      value: value2,
      previousValue,
      event: this._valueChangeEventInstance
    };
  },
  _saveValueChangeEvent(e) {
    this._valueChangeEventInstance = e;
  },
  _focusInHandler(e) {
    const isValidationMessageShownOnFocus = "auto" === this.option("validationMessageMode");
    if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
      var _this$_validationMess;
      const $validationMessageWrapper = null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess ? void 0 : _this$_validationMess.$wrapper();
      null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO2);
      clearTimeout(this.showValidationMessageTimeout);
      this.showValidationMessageTimeout = setTimeout(() => null === $validationMessageWrapper || void 0 === $validationMessageWrapper ? void 0 : $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO2), 150);
    }
    return this.callBase(e);
  },
  _canValueBeChangedByClick: () => false,
  _getStylingModePrefix: () => "dx-editor-",
  _renderStylingMode() {
    const optionValue = this.option("stylingMode");
    const prefix = this._getStylingModePrefix();
    const allowedStylingClasses = ALLOWED_STYLING_MODES.map((mode) => prefix + mode);
    allowedStylingClasses.forEach((className) => this.$element().removeClass(className));
    let stylingModeClass = prefix + optionValue;
    if (!allowedStylingClasses.includes(stylingModeClass)) {
      const defaultOptionValue = this._getDefaultOptions().stylingMode;
      const platformOptionValue = this._convertRulesToOptions(this._defaultOptionsRules()).stylingMode;
      stylingModeClass = prefix + (platformOptionValue || defaultOptionValue);
    }
    this.$element().addClass(stylingModeClass);
  },
  _getValidationErrors() {
    let validationErrors = this.option("validationErrors");
    if (!validationErrors && this.option("validationError")) {
      validationErrors = [this.option("validationError")];
    }
    return validationErrors;
  },
  _disposeValidationMessage() {
    if (this._$validationMessage) {
      this._$validationMessage.remove();
      this.setAria("describedby", null);
      this._$validationMessage = void 0;
      this._validationMessage = void 0;
    }
  },
  _toggleValidationClasses(isInvalid3) {
    this.$element().toggleClass("dx-invalid", isInvalid3);
    this.setAria("invalid", isInvalid3 || void 0);
  },
  _renderValidationState() {
    const isValid = this.option("isValid") && "invalid" !== this.option("validationStatus");
    const validationErrors = this._getValidationErrors();
    const $element = this.$element();
    this._toggleValidationClasses(!isValid);
    if (!hasWindow() || false === this.option("_showValidationMessage")) {
      return;
    }
    this._disposeValidationMessage();
    if (!isValid && validationErrors) {
      const {
        validationMessageMode,
        validationMessageOffset,
        validationBoundary,
        rtlEnabled
      } = this.option();
      this._$validationMessage = renderer_default("<div>").appendTo($element);
      const validationMessageContentId = `dx-${new guid_default()}`;
      this.setAria("describedby", validationMessageContentId);
      this._validationMessage = new validation_message_default(this._$validationMessage, extend({
        validationErrors,
        rtlEnabled,
        target: this._getValidationMessageTarget(),
        visualContainer: $element,
        mode: validationMessageMode,
        positionSide: this._getValidationMessagePosition(),
        offset: validationMessageOffset,
        boundary: validationBoundary,
        contentId: validationMessageContentId
      }, this._options.cache("validationTooltipOptions")));
      this._bindInnerWidgetOptions(this._validationMessage, "validationTooltipOptions");
    }
  },
  _getValidationMessagePosition() {
    return this.option("validationMessagePosition");
  },
  _getValidationMessageTarget() {
    return this.$element();
  },
  _toggleReadOnlyState() {
    const readOnly = this.option("readOnly");
    this._toggleBackspaceHandler(readOnly);
    this.$element().toggleClass("dx-state-readonly", !!readOnly);
    this._setAriaReadonly(readOnly);
  },
  _setAriaReadonly(readOnly) {
    this.setAria("readonly", readOnly || void 0);
  },
  _toggleBackspaceHandler(isReadOnly) {
    const $eventTarget = this._keyboardEventBindingTarget();
    const eventName = addNamespace2("keydown", "editorReadOnly");
    events_engine_default.off($eventTarget, eventName);
    if (isReadOnly) {
      events_engine_default.on($eventTarget, eventName, (e) => {
        if ("backspace" === normalizeKeyName(e)) {
          e.preventDefault();
        }
      });
    }
  },
  _dispose() {
    const element = this.$element()[0];
    data(element, VALIDATION_TARGET, null);
    clearTimeout(this.showValidationMessageTimeout);
    this._disposeValidationMessage();
    this.callBase();
  },
  _setSubmitElementName(name2) {
    const $submitElement = this._getSubmitElement();
    if (!$submitElement) {
      return;
    }
    if (name2.length > 0) {
      $submitElement.attr("name", name2);
    } else {
      $submitElement.removeAttr("name");
    }
  },
  _getSubmitElement: () => null,
  _setValidationMessageOption(_ref) {
    var _this$_validationMess2;
    let {
      name: name2,
      value: value2
    } = _ref;
    const optionKey = VALIDATION_MESSAGE_KEYS_MAP[name2] ? VALIDATION_MESSAGE_KEYS_MAP[name2] : name2;
    null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 || _this$_validationMess2.option(optionKey, value2);
  },
  _hasActiveElement: noop2,
  _optionChanged(args) {
    var _this$_validationMess3;
    switch (args.name) {
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "readOnly":
        this._toggleReadOnlyState();
        this._refreshFocusState();
        break;
      case "value":
        if (args.value != args.previousValue) {
          this.option("isDirty", this._initialValue !== args.value);
          this.validationRequest.fire({
            value: args.value,
            editor: this
          });
        }
        if (!this._valueChangeActionSuppressed) {
          this._raiseValueChangeAction(args.value, args.previousValue);
          this._saveValueChangeEvent(void 0);
        }
        break;
      case "width":
        this.callBase(args);
        null === (_this$_validationMess3 = this._validationMessage) || void 0 === _this$_validationMess3 || _this$_validationMess3.updateMaxWidth();
        break;
      case "name":
        this._setSubmitElementName(args.value);
        break;
      case "isValid":
      case "validationError":
      case "validationErrors":
      case "validationStatus":
        this.option(validation_engine_default.synchronizeValidationOptions(args, this.option()));
        this._renderValidationState();
        break;
      case "validationBoundary":
      case "validationMessageMode":
      case "validationMessagePosition":
      case "validationMessageOffset":
        this._setValidationMessageOption(args);
        break;
      case "rtlEnabled":
        this._setValidationMessageOption(args);
        this.callBase(args);
        break;
      case "validationTooltipOptions":
        this._innerWidgetOptionChanged(this._validationMessage, args);
        break;
      case "_showValidationMessage":
      case "isDirty":
        break;
      default:
        this.callBase(args);
    }
  },
  _resetToInitialValue() {
    this.option("value", this._initialValue);
  },
  blur() {
    if (this._hasActiveElement()) {
      resetActiveElement();
    }
  },
  clear() {
    const defaultOptions3 = this._getDefaultOptions();
    this.option("value", defaultOptions3.value);
  },
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      this._initialValue = value2;
    }
    this._resetToInitialValue();
    this.option("isDirty", false);
    this.option("isValid", true);
  }
});
Editor.isEditor = (instance) => instance instanceof Editor;
var m_editor_default = Editor;

// ../../../../../../node_modules/devextreme/esm/ui/editor/editor.js
var editor_default = m_editor_default;

// ../../../../../../node_modules/devextreme/esm/ui/themes_callback.js
var themeReadyCallback = callbacks_default();

// ../../../../../../node_modules/devextreme/esm/ui/themes.js
var window14 = getWindow();
var ready4 = ready_callbacks_default.add;
var viewPort = value;
var viewPortChanged2 = changeCallback;
var initDeferred = new Deferred();
var DX_LINK_SELECTOR = "link[rel=dx-theme]";
var THEME_ATTR = "data-theme";
var ACTIVE_ATTR = "data-active";
var DX_HAIRLINES_CLASS = "dx-hairlines";
var ANY_THEME = "any";
var context;
var $activeThemeLink;
var knownThemes;
var currentThemeName;
var pendingThemeName;
var defaultTimeout = 15e3;
var THEME_MARKER_PREFIX = "dx.";
function readThemeMarker() {
  if (!hasWindow()) {
    return null;
  }
  const element = renderer_default("<div>", context).addClass("dx-theme-marker").appendTo(context.documentElement);
  let result2;
  try {
    result2 = window14.getComputedStyle(element.get(0)).fontFamily;
    if (!result2) {
      return null;
    }
    result2 = result2.replace(/["']/g, "");
    if (result2.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {
      return null;
    }
    return result2.substr(THEME_MARKER_PREFIX.length);
  } finally {
    element.remove();
  }
}
function waitForThemeLoad(themeName) {
  let waitStartTime;
  let timerId;
  let intervalCleared = true;
  pendingThemeName = themeName;
  function handleLoaded() {
    pendingThemeName = null;
    clearInterval(timerId);
    intervalCleared = true;
    themeReadyCallback.fire();
    themeReadyCallback.empty();
    initDeferred.resolve();
  }
  if (isPendingThemeLoaded() || !defaultTimeout) {
    handleLoaded();
  } else {
    if (!intervalCleared) {
      if (pendingThemeName) {
        pendingThemeName = themeName;
      }
      return;
    }
    waitStartTime = Date.now();
    intervalCleared = false;
    timerId = setInterval(function() {
      const isLoaded = isPendingThemeLoaded();
      const isTimeout = !isLoaded && Date.now() - waitStartTime > defaultTimeout;
      if (isTimeout) {
        ui_errors_default.log("W0004", pendingThemeName);
      }
      if (isLoaded || isTimeout) {
        handleLoaded();
      }
    }, 10);
  }
}
function isPendingThemeLoaded() {
  if (!pendingThemeName) {
    return true;
  }
  const anyThemePending = pendingThemeName === ANY_THEME;
  if ("resolved" === initDeferred.state() && anyThemePending) {
    return true;
  }
  const themeMarker = readThemeMarker();
  if (themeMarker && anyThemePending) {
    return true;
  }
  return themeMarker === pendingThemeName;
}
function processMarkup() {
  const $allThemeLinks = renderer_default(DX_LINK_SELECTOR, context);
  if (!$allThemeLinks.length) {
    return;
  }
  knownThemes = {};
  $activeThemeLink = renderer_default(parseHTML("<link rel=stylesheet>"), context);
  $allThemeLinks.each(function() {
    const link = renderer_default(this, context);
    const fullThemeName = link.attr(THEME_ATTR);
    const url = link.attr("href");
    const isActive = "true" === link.attr(ACTIVE_ATTR);
    knownThemes[fullThemeName] = {
      url,
      isActive
    };
  });
  $allThemeLinks.last().after($activeThemeLink);
  $allThemeLinks.remove();
}
function resolveFullThemeName(desiredThemeName) {
  const desiredThemeParts = desiredThemeName ? desiredThemeName.split(".") : [];
  let result2 = null;
  if (knownThemes) {
    if (desiredThemeName in knownThemes) {
      return desiredThemeName;
    }
    each(knownThemes, function(knownThemeName, themeData) {
      const knownThemeParts = knownThemeName.split(".");
      if (desiredThemeParts[0] && knownThemeParts[0] !== desiredThemeParts[0]) {
        return;
      }
      if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
        return;
      }
      if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
        return;
      }
      if (!result2 || themeData.isActive) {
        result2 = knownThemeName;
      }
      if (themeData.isActive) {
        return false;
      }
    });
  }
  return result2;
}
function initContext(newContext) {
  try {
    if (newContext !== context) {
      knownThemes = null;
    }
  } catch (x) {
    knownThemes = null;
  }
  context = newContext;
}
function init(options2) {
  options2 = options2 || {};
  initContext(options2.context || dom_adapter_default.getDocument());
  if (!context) {
    return;
  }
  processMarkup();
  currentThemeName = void 0;
  current(options2);
}
function current(options2) {
  if (!arguments.length) {
    currentThemeName = currentThemeName || readThemeMarker();
    return currentThemeName;
  }
  detachCssClasses(viewPort());
  options2 = options2 || {};
  if ("string" === typeof options2) {
    options2 = {
      theme: options2
    };
  }
  const isAutoInit = options2._autoInit;
  const loadCallback = options2.loadCallback;
  let currentThemeData;
  currentThemeName = resolveFullThemeName(options2.theme || currentThemeName);
  if (currentThemeName) {
    currentThemeData = knownThemes[currentThemeName];
  }
  if (loadCallback) {
    themeReadyCallback.add(loadCallback);
  }
  if (currentThemeData) {
    $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
    if (themeReadyCallback.has() || "resolved" !== initDeferred.state() || options2._forceTimeout) {
      waitForThemeLoad(currentThemeName);
    }
  } else if (isAutoInit) {
    if (hasWindow()) {
      waitForThemeLoad(ANY_THEME);
    }
    themeReadyCallback.fire();
    themeReadyCallback.empty();
  } else {
    throw ui_errors_default.Error("E0021", currentThemeName);
  }
  initDeferred.done(() => attachCssClasses(originalViewPort(), currentThemeName));
}
function getCssClasses(themeName) {
  themeName = themeName || current();
  const result2 = [];
  const themeNameParts = themeName && themeName.split(".");
  if (themeNameParts) {
    result2.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
    if (themeNameParts.length > 1) {
      result2.push("dx-color-scheme-" + themeNameParts[1] + (isMaterialBased(themeName) ? "-" + themeNameParts[2] : ""));
    }
  }
  return result2;
}
var themeClasses;
function attachCssClasses(element, themeName) {
  themeClasses = getCssClasses(themeName).join(" ");
  renderer_default(element).addClass(themeClasses);
  !function() {
    const pixelRatio = hasWindow() && window14.devicePixelRatio;
    if (!pixelRatio || pixelRatio < 2) {
      return;
    }
    const $tester = renderer_default("<div>");
    $tester.css("border", ".5px solid transparent");
    renderer_default("body").append($tester);
    if (1 === getOuterHeight($tester)) {
      renderer_default(element).addClass(DX_HAIRLINES_CLASS);
      themeClasses += " " + DX_HAIRLINES_CLASS;
    }
    $tester.remove();
  }();
}
function detachCssClasses(element) {
  renderer_default(element).removeClass(themeClasses);
}
function isTheme(themeRegExp, themeName) {
  if (!themeName) {
    themeName = currentThemeName || readThemeMarker();
  }
  return new RegExp(themeRegExp).test(themeName);
}
function isMaterialBased(themeName) {
  return isMaterial(themeName) || isFluent(themeName);
}
function isMaterial(themeName) {
  return isTheme("material", themeName);
}
function isFluent(themeName) {
  return isTheme("fluent", themeName);
}
function isGeneric(themeName) {
  return isTheme("generic", themeName);
}
function isCompact(themeName) {
  return isTheme("compact", themeName);
}
function isWebFontLoaded(text, fontWeight) {
  const document2 = dom_adapter_default.getDocument();
  const testElement = document2.createElement("span");
  testElement.style.position = "absolute";
  testElement.style.top = "-9999px";
  testElement.style.left = "-9999px";
  testElement.style.visibility = "hidden";
  testElement.style.fontFamily = "Arial";
  testElement.style.fontSize = "250px";
  testElement.style.fontWeight = fontWeight;
  testElement.innerHTML = text;
  document2.body.appendChild(testElement);
  const etalonFontWidth = testElement.offsetWidth;
  testElement.style.fontFamily = "Roboto, RobotoFallback, Arial";
  const testedFontWidth = testElement.offsetWidth;
  testElement.parentNode.removeChild(testElement);
  return etalonFontWidth !== testedFontWidth;
}
function waitWebFont(text, fontWeight) {
  return new Promise((resolve) => {
    const clear = () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
      resolve();
    };
    const intervalId = setInterval(() => {
      if (isWebFontLoaded(text, fontWeight)) {
        clear();
      }
    }, 15);
    const timeoutId = setTimeout(clear, 2e3);
  });
}
function autoInit() {
  init({
    _autoInit: true,
    _forceTimeout: true
  });
  if (renderer_default(DX_LINK_SELECTOR, context).length) {
    throw ui_errors_default.Error("E0022");
  }
}
if (hasWindow()) {
  autoInit();
} else {
  ready4(autoInit);
}
viewPortChanged2.add(function(viewPort2, prevViewPort) {
  initDeferred.done(function() {
    detachCssClasses(prevViewPort);
    attachCssClasses(viewPort2);
  });
});
devices_default.changed.add(function() {
  init({
    _autoInit: true
  });
});

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_load_indicator.js
var navigator2 = getNavigator();
var LoadIndicator = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      indicatorSrc: "",
      activeStateEnabled: false,
      hoverStateEnabled: false,
      _animatingSegmentCount: 1,
      _animatingSegmentInner: false
    });
  },
  _defaultOptionsRules() {
    const themeName = current();
    return this.callBase().concat([{
      device() {
        const realDevice2 = devices_default.real();
        const obsoleteAndroid = "android" === realDevice2.platform && !/chrome/i.test(navigator2.userAgent);
        return obsoleteAndroid;
      },
      options: {
        viaImage: true
      }
    }, {
      device: () => isMaterialBased(themeName),
      options: {
        _animatingSegmentCount: 2,
        _animatingSegmentInner: true
      }
    }, {
      device: () => isGeneric(themeName),
      options: {
        _animatingSegmentCount: 7
      }
    }]);
  },
  _useTemplates: () => false,
  _init() {
    this.callBase();
    this.$element().addClass("dx-loadindicator");
    const label = message_default.format("Loading");
    const aria = {
      role: "alert",
      label
    };
    this.setAria(aria);
  },
  _initMarkup() {
    this.callBase();
    this._renderWrapper();
    this._renderIndicatorContent();
    this._renderMarkup();
  },
  _renderWrapper() {
    this._$wrapper = renderer_default("<div>").addClass("dx-loadindicator-wrapper");
    this.$element().append(this._$wrapper);
  },
  _renderIndicatorContent() {
    this._$content = renderer_default("<div>").addClass("dx-loadindicator-content");
    this._$wrapper.append(this._$content);
  },
  _renderMarkup() {
    const {
      viaImage,
      indicatorSrc
    } = this.option();
    if (animation() && !viaImage && !indicatorSrc) {
      this._renderMarkupForAnimation();
    } else {
      this._renderMarkupForImage();
    }
  },
  _renderMarkupForAnimation() {
    const animatingSegmentInner = this.option("_animatingSegmentInner");
    this._$indicator = renderer_default("<div>").addClass("dx-loadindicator-icon");
    this._$content.append(this._$indicator);
    for (let i = this.option("_animatingSegmentCount"); i >= 0; --i) {
      const $segment = renderer_default("<div>").addClass("dx-loadindicator-segment").addClass("dx-loadindicator-segment" + i);
      if (animatingSegmentInner) {
        $segment.append(renderer_default("<div>").addClass("dx-loadindicator-segment-inner"));
      }
      this._$indicator.append($segment);
    }
  },
  _renderMarkupForImage() {
    const {
      indicatorSrc
    } = this.option();
    if (indicatorSrc) {
      this._$wrapper.addClass("dx-loadindicator-image");
      this._$wrapper.css("backgroundImage", `url(${indicatorSrc})`);
    } else if (animation()) {
      this._renderMarkupForAnimation();
    }
  },
  _renderDimensions() {
    this.callBase();
    this._updateContentSizeForAnimation();
  },
  _updateContentSizeForAnimation() {
    if (!this._$indicator) {
      return;
    }
    let width = this.option("width");
    let height = this.option("height");
    if (width || height) {
      width = getWidth(this.$element());
      height = getHeight(this.$element());
      const minDimension = Math.min(height, width);
      this._$wrapper.css({
        height: minDimension,
        width: minDimension,
        fontSize: minDimension
      });
    }
  },
  _clean() {
    this.callBase();
    this._removeMarkupForAnimation();
    this._removeMarkupForImage();
  },
  _removeMarkupForAnimation() {
    if (!this._$indicator) {
      return;
    }
    this._$indicator.remove();
    delete this._$indicator;
  },
  _removeMarkupForImage() {
    this._$wrapper.css("backgroundImage", "none");
  },
  _optionChanged(args) {
    switch (args.name) {
      case "_animatingSegmentCount":
      case "_animatingSegmentInner":
      case "indicatorSrc":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxLoadIndicator", LoadIndicator);
var m_load_indicator_default = LoadIndicator;

// ../../../../../../node_modules/devextreme/esm/ui/load_indicator.js
var load_indicator_default = m_load_indicator_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_button.js
var TextEditorButton = class {
  constructor(name2, editor, options2) {
    this.instance = null;
    this.$container = null;
    this.$placeMarker = null;
    this.editor = editor;
    this.name = name2;
    this.options = options2 || {};
  }
  _addPlaceMarker($container) {
    this.$placeMarker = renderer_default("<div>").appendTo($container);
  }
  _addToContainer($element) {
    const {
      $placeMarker,
      $container
    } = this;
    $placeMarker ? $placeMarker.replaceWith($element) : $element.appendTo($container);
  }
  _attachEvents(instance, $element) {
    throw "Not implemented";
  }
  _create() {
    throw "Not implemented";
  }
  _isRendered() {
    return !!this.instance;
  }
  _isVisible() {
    const {
      editor,
      options: options2
    } = this;
    return options2.visible || !editor.option("readOnly");
  }
  _isDisabled() {
    throw "Not implemented";
  }
  _shouldRender() {
    return this._isVisible() && !this._isRendered();
  }
  dispose() {
    const {
      instance,
      $placeMarker
    } = this;
    if (instance) {
      instance.dispose ? instance.dispose() : instance.remove();
      this.instance = null;
    }
    $placeMarker && $placeMarker.remove();
  }
  render() {
    let $container = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.$container;
    this.$container = $container;
    if (this._isVisible()) {
      const {
        instance,
        $element
      } = this._create();
      this.instance = instance;
      this._attachEvents(instance, $element);
    } else {
      this._addPlaceMarker($container);
    }
  }
  update() {
    if (this._shouldRender()) {
      this.render();
    }
    return !!this.instance;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.clear.js
var pointerDown = pointer_default.down;
var ClearButton = class extends TextEditorButton {
  _create() {
    const $element = renderer_default("<span>").addClass("dx-clear-button-area").append(renderer_default("<span>").addClass("dx-icon").addClass("dx-icon-clear"));
    this._addToContainer($element);
    this.update(true);
    return {
      instance: $element,
      $element
    };
  }
  _isVisible() {
    const {
      editor
    } = this;
    return editor._isClearButtonVisible();
  }
  _attachEvents(instance, $button) {
    const {
      editor
    } = this;
    const editorName = editor.NAME;
    events_engine_default.on($button, addNamespace2(pointerDown, editorName), (e) => {
      e.preventDefault();
      if ("mouse" !== e.pointerType) {
        editor._clearValueHandler(e);
      }
    });
    events_engine_default.on($button, addNamespace2(CLICK_EVENT_NAME, editorName), (e) => editor._clearValueHandler(e));
  }
  _legacyRender($editor, isVisible2) {
    $editor.toggleClass("dx-show-clear-button", isVisible2);
  }
  update() {
    let rendered = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    !rendered && super.update();
    const {
      editor,
      instance
    } = this;
    const $editor = editor.$element();
    const isVisible2 = this._isVisible();
    instance && instance.toggleClass("dx-state-invisible", !isVisible2);
    this._legacyRender($editor, isVisible2);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.label.js
var TextEditorLabel = class {
  constructor(props) {
    this.NAME = "dxLabel";
    this._props = props;
    this._id = `dx-texteditor-label-${new guid_default()}`;
    this._render();
    this._toggleMarkupVisibility();
  }
  _isVisible() {
    return !!this._props.text && "hidden" !== this._props.mode;
  }
  _render() {
    this._$before = renderer_default("<div>").addClass("dx-label-before");
    this._$labelSpan = renderer_default("<span>");
    this._$label = renderer_default("<div>").addClass("dx-label").append(this._$labelSpan);
    this._$after = renderer_default("<div>").addClass("dx-label-after");
    this._$root = renderer_default("<div>").addClass("dx-texteditor-label").attr("id", this._id).append(this._$before).append(this._$label).append(this._$after);
    this._updateMark();
    this._updateText();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  _toggleMarkupVisibility() {
    const visible2 = this._isVisible();
    this._updateEditorBeforeButtonsClass(visible2);
    this._updateEditorLabelClass(visible2);
    visible2 ? this._$root.appendTo(this._props.$editor) : this._$root.detach();
    this._attachEvents();
  }
  _attachEvents() {
    const clickEventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const hoverStartEventName = addNamespace2(HOVERSTART, this.NAME);
    const activeEventName = addNamespace2(ACTIVE_EVENT_NAME, this.NAME);
    events_engine_default.off(this._$labelSpan, clickEventName);
    events_engine_default.off(this._$labelSpan, hoverStartEventName);
    events_engine_default.off(this._$labelSpan, activeEventName);
    if (this._isVisible() && this._isOutsideMode()) {
      events_engine_default.on(this._$labelSpan, clickEventName, (e) => {
        const selectedText = getWindow().getSelection().toString();
        if ("" === selectedText) {
          this._props.onClickHandler();
          e.preventDefault();
        }
      });
      events_engine_default.on(this._$labelSpan, hoverStartEventName, (e) => {
        this._props.onHoverHandler(e);
      });
      events_engine_default.on(this._$labelSpan, activeEventName, (e) => {
        this._props.onActiveHandler(e);
      });
    }
  }
  _updateEditorLabelClass(visible2) {
    this._props.$editor.removeClass("dx-texteditor-with-floating-label").removeClass("dx-texteditor-label-outside").removeClass("dx-texteditor-with-label");
    if (visible2) {
      const labelClass = "floating" === this._props.mode ? "dx-texteditor-with-floating-label" : "dx-texteditor-with-label";
      this._props.$editor.addClass(labelClass);
      if (this._isOutsideMode()) {
        this._props.$editor.addClass("dx-texteditor-label-outside");
      }
    }
  }
  _isOutsideMode() {
    return "outside" === this._props.mode;
  }
  _updateEditorBeforeButtonsClass() {
    let visible2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._isVisible();
    this._props.$editor.removeClass("dx-texteditor-with-before-buttons");
    if (visible2) {
      const beforeButtonsClass = this._props.containsButtonsBefore ? "dx-texteditor-with-before-buttons" : "";
      this._props.$editor.addClass(beforeButtonsClass);
    }
  }
  _updateMark() {
    this._$labelSpan.attr("data-mark", this._props.mark);
  }
  _updateText() {
    this._$labelSpan.text(this._props.text);
  }
  _updateBeforeWidth() {
    if (this._isVisible()) {
      const width = this._props.beforeWidth ?? this._props.getBeforeWidth();
      this._$before.css({
        width
      });
      this._updateLabelTransform();
    }
  }
  _updateLabelTransform() {
    let offset2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    this._$labelSpan.css("transform", "");
    if (this._isVisible() && this._isOutsideMode()) {
      const sign2 = this._props.rtlEnabled ? 1 : -1;
      const labelTranslateX = sign2 * (getWidth(this._$before) + offset2);
      this._$labelSpan.css("transform", `translateX(${labelTranslateX}px)`);
    }
  }
  _updateMaxWidth() {
    if (this._isVisible() && !this._isOutsideMode()) {
      const maxWidth = this._props.containerWidth ?? this._props.getContainerWidth();
      this._$label.css({
        maxWidth
      });
    }
  }
  $element() {
    return this._$root;
  }
  isVisible() {
    return this._isVisible();
  }
  getId() {
    if (this._isVisible()) {
      return this._id;
    }
  }
  updateMode(mode) {
    this._props.mode = mode;
    this._toggleMarkupVisibility();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  updateText(text) {
    this._props.text = text;
    this._updateText();
    this._toggleMarkupVisibility();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  updateMark(mark) {
    this._props.mark = mark;
    this._updateMark();
  }
  updateContainsButtonsBefore(containsButtonsBefore) {
    this._props.containsButtonsBefore = containsButtonsBefore;
    this._updateEditorBeforeButtonsClass();
  }
  updateBeforeWidth(beforeWidth) {
    this._props.beforeWidth = beforeWidth;
    this._updateBeforeWidth();
  }
  updateMaxWidth(containerWidth) {
    this._props.containerWidth = containerWidth;
    this._updateMaxWidth();
  }
};

// ../../../../../../node_modules/inferno/dist/index.esm.js
var isArray = Array.isArray;
function isStringOrNumber(o) {
  var type2 = typeof o;
  return type2 === "string" || type2 === "number";
}
function isNullOrUndef(o) {
  return o === void 0 || o === null;
}
function isInvalid(o) {
  return o === null || o === false || o === true || o === void 0;
}
function isFunction2(o) {
  return typeof o === "function";
}
function isString2(o) {
  return typeof o === "string";
}
function isNumber(o) {
  return typeof o === "number";
}
function isNull(o) {
  return o === null;
}
function isUndefined(o) {
  return o === void 0;
}
function combineFrom(first, second) {
  var out = {};
  if (first) {
    for (var key in first) {
      out[key] = first[key];
    }
  }
  if (second) {
    for (var key$1 in second) {
      out[key$1] = second[key$1];
    }
  }
  return out;
}
function isLinkEventObject(o) {
  return !isNull(o) && typeof o === "object";
}
var EMPTY_OBJ = {};
var Fragment = "$F";
function normalizeEventName(name2) {
  return name2.substr(2).toLowerCase();
}
function appendChild(parentDOM, dom) {
  parentDOM.appendChild(dom);
}
function insertOrAppend(parentDOM, newNode, nextNode) {
  if (isNull(nextNode)) {
    appendChild(parentDOM, newNode);
  } else {
    parentDOM.insertBefore(newNode, nextNode);
  }
}
function documentCreateElement(tag, isSVG) {
  if (isSVG) {
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
  }
  return document.createElement(tag);
}
function replaceChild(parentDOM, newDom, lastDom) {
  parentDOM.replaceChild(newDom, lastDom);
}
function removeChild(parentDOM, childNode) {
  parentDOM.removeChild(childNode);
}
function callAll(arrayFn) {
  for (var i = 0; i < arrayFn.length; i++) {
    arrayFn[i]();
  }
}
function findChildVNode(vNode, startEdge, flags) {
  var children = vNode.children;
  if (flags & 4) {
    return children.$LI;
  }
  if (flags & 8192) {
    return vNode.childFlags === 2 ? children : children[startEdge ? 0 : children.length - 1];
  }
  return children;
}
function findDOMfromVNode(vNode, startEdge) {
  var flags;
  while (vNode) {
    flags = vNode.flags;
    if (flags & 2033) {
      return vNode.dom;
    }
    vNode = findChildVNode(vNode, startEdge, flags);
  }
  return null;
}
function removeVNodeDOM(vNode, parentDOM) {
  do {
    var flags = vNode.flags;
    if (flags & 2033) {
      removeChild(parentDOM, vNode.dom);
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      vNode = children.$LI;
    }
    if (flags & 8) {
      vNode = children;
    }
    if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          removeVNodeDOM(children[i], parentDOM);
        }
        return;
      }
    }
  } while (vNode);
}
function moveVNodeDOM(vNode, parentDOM, nextNode) {
  do {
    var flags = vNode.flags;
    if (flags & 2033) {
      insertOrAppend(parentDOM, vNode.dom, nextNode);
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      vNode = children.$LI;
    }
    if (flags & 8) {
      vNode = children;
    }
    if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          moveVNodeDOM(children[i], parentDOM, nextNode);
        }
        return;
      }
    }
  } while (vNode);
}
function createDerivedState(instance, nextProps, state) {
  if (instance.constructor.getDerivedStateFromProps) {
    return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));
  }
  return state;
}
var renderCheck = {
  v: false
};
var options = {
  componentComparator: null,
  createVNode: null,
  renderComplete: null
};
function setTextContent(dom, children) {
  dom.textContent = children;
}
function isLastValueSameLinkEvent(lastValue, nextValue) {
  return isLinkEventObject(lastValue) && lastValue.event === nextValue.event && lastValue.data === nextValue.data;
}
function mergeUnsetProperties(to, from) {
  for (var propName in from) {
    if (isUndefined(to[propName])) {
      to[propName] = from[propName];
    }
  }
  return to;
}
function safeCall1(method, arg1) {
  return !!isFunction2(method) && (method(arg1), true);
}
var keyPrefix = "$";
function V(childFlags, children, className, flags, key, props, ref, type2) {
  this.childFlags = childFlags;
  this.children = children;
  this.className = className;
  this.dom = null;
  this.flags = flags;
  this.key = key === void 0 ? null : key;
  this.props = props === void 0 ? null : props;
  this.ref = ref === void 0 ? null : ref;
  this.type = type2;
}
function createVNode(flags, type2, className, children, childFlags, props, key, ref) {
  var childFlag = childFlags === void 0 ? 1 : childFlags;
  var vNode = new V(childFlag, children, className, flags, key, props, ref, type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  if (childFlag === 0) {
    normalizeChildren(vNode, vNode.children);
  }
  return vNode;
}
function mergeDefaultHooks(flags, type2, ref) {
  if (flags & 4) {
    return ref;
  }
  var defaultHooks = (flags & 32768 ? type2.render : type2).defaultHooks;
  if (isNullOrUndef(defaultHooks)) {
    return ref;
  }
  if (isNullOrUndef(ref)) {
    return defaultHooks;
  }
  return mergeUnsetProperties(ref, defaultHooks);
}
function mergeDefaultProps(flags, type2, props) {
  var defaultProps = (flags & 32768 ? type2.render : type2).defaultProps;
  if (isNullOrUndef(defaultProps)) {
    return props;
  }
  if (isNullOrUndef(props)) {
    return combineFrom(defaultProps, null);
  }
  return mergeUnsetProperties(props, defaultProps);
}
function resolveComponentFlags(flags, type2) {
  if (flags & 12) {
    return flags;
  }
  if (type2.prototype && type2.prototype.render) {
    return 4;
  }
  if (type2.render) {
    return 32776;
  }
  return 8;
}
function createComponentVNode(flags, type2, props, key, ref) {
  flags = resolveComponentFlags(flags, type2);
  var vNode = new V(1, null, null, flags, key, mergeDefaultProps(flags, type2, props), mergeDefaultHooks(flags, type2, ref), type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  return vNode;
}
function createTextVNode(text, key) {
  return new V(1, isNullOrUndef(text) || text === true || text === false ? "" : text, null, 16, key, null, null, null);
}
function createFragment(children, childFlags, key) {
  var fragment = createVNode(8192, 8192, null, children, childFlags, null, key, null);
  switch (fragment.childFlags) {
    case 1:
      fragment.children = createVoidVNode();
      fragment.childFlags = 2;
      break;
    case 16:
      fragment.children = [createTextVNode(children)];
      fragment.childFlags = 4;
      break;
  }
  return fragment;
}
function normalizeProps(vNode) {
  var props = vNode.props;
  if (props) {
    var flags = vNode.flags;
    if (flags & 481) {
      if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
        normalizeChildren(vNode, props.children);
      }
      if (props.className !== void 0) {
        if (isNullOrUndef(vNode.className)) {
          vNode.className = props.className || null;
        }
        props.className = void 0;
      }
    }
    if (props.key !== void 0) {
      vNode.key = props.key;
      props.key = void 0;
    }
    if (props.ref !== void 0) {
      if (flags & 8) {
        vNode.ref = combineFrom(vNode.ref, props.ref);
      } else {
        vNode.ref = props.ref;
      }
      props.ref = void 0;
    }
  }
  return vNode;
}
function cloneFragment(vNodeToClone) {
  var oldChildren = vNodeToClone.children;
  var childFlags = vNodeToClone.childFlags;
  return createFragment(childFlags === 2 ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);
}
function directClone(vNodeToClone) {
  var flags = vNodeToClone.flags & -16385;
  var props = vNodeToClone.props;
  if (flags & 14) {
    if (!isNull(props)) {
      var propsToClone = props;
      props = {};
      for (var key in propsToClone) {
        props[key] = propsToClone[key];
      }
    }
  }
  if ((flags & 8192) === 0) {
    return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
  }
  return cloneFragment(vNodeToClone);
}
function createVoidVNode() {
  return createTextVNode("", null);
}
function _normalizeVNodes(nodes, result2, index2, currentKey) {
  for (var len = nodes.length; index2 < len; index2++) {
    var n = nodes[index2];
    if (!isInvalid(n)) {
      var newKey = currentKey + keyPrefix + index2;
      if (isArray(n)) {
        _normalizeVNodes(n, result2, 0, newKey);
      } else {
        if (isStringOrNumber(n)) {
          n = createTextVNode(n, newKey);
        } else {
          var oldKey = n.key;
          var isPrefixedKey = isString2(oldKey) && oldKey[0] === keyPrefix;
          if (n.flags & 81920 || isPrefixedKey) {
            n = directClone(n);
          }
          n.flags |= 65536;
          if (!isPrefixedKey) {
            if (isNull(oldKey)) {
              n.key = newKey;
            } else {
              n.key = currentKey + oldKey;
            }
          } else if (oldKey.substring(0, currentKey.length) !== currentKey) {
            n.key = currentKey + oldKey;
          }
        }
        result2.push(n);
      }
    }
  }
}
function getFlagsForElementVnode(type2) {
  switch (type2) {
    case "svg":
      return 32;
    case "input":
      return 64;
    case "select":
      return 256;
    case "textarea":
      return 128;
    case Fragment:
      return 8192;
    default:
      return 1;
  }
}
function normalizeChildren(vNode, children) {
  var newChildren;
  var newChildFlags = 1;
  if (isInvalid(children)) {
    newChildren = children;
  } else if (isStringOrNumber(children)) {
    newChildFlags = 16;
    newChildren = children;
  } else if (isArray(children)) {
    var len = children.length;
    for (var i = 0; i < len; ++i) {
      var n = children[i];
      if (isInvalid(n) || isArray(n)) {
        newChildren = newChildren || children.slice(0, i);
        _normalizeVNodes(children, newChildren, i, "");
        break;
      } else if (isStringOrNumber(n)) {
        newChildren = newChildren || children.slice(0, i);
        newChildren.push(createTextVNode(n, keyPrefix + i));
      } else {
        var key = n.key;
        var needsCloning = (n.flags & 81920) > 0;
        var isNullKey = isNull(key);
        var isPrefixed = isString2(key) && key[0] === keyPrefix;
        if (needsCloning || isNullKey || isPrefixed) {
          newChildren = newChildren || children.slice(0, i);
          if (needsCloning || isPrefixed) {
            n = directClone(n);
          }
          if (isNullKey || isPrefixed) {
            n.key = keyPrefix + i;
          }
          newChildren.push(n);
        } else if (newChildren) {
          newChildren.push(n);
        }
        n.flags |= 65536;
      }
    }
    newChildren = newChildren || children;
    if (newChildren.length === 0) {
      newChildFlags = 1;
    } else {
      newChildFlags = 8;
    }
  } else {
    newChildren = children;
    newChildren.flags |= 65536;
    if (children.flags & 81920) {
      newChildren = directClone(children);
    }
    newChildFlags = 2;
  }
  vNode.children = newChildren;
  vNode.childFlags = newChildFlags;
  return vNode;
}
function normalizeRoot(input) {
  if (isInvalid(input) || isStringOrNumber(input)) {
    return createTextVNode(input, null);
  }
  if (isArray(input)) {
    return createFragment(input, 0, null);
  }
  return input.flags & 16384 ? directClone(input) : input;
}
var xlinkNS = "http://www.w3.org/1999/xlink";
var xmlNS = "http://www.w3.org/XML/1998/namespace";
var namespaces = {
  "xlink:actuate": xlinkNS,
  "xlink:arcrole": xlinkNS,
  "xlink:href": xlinkNS,
  "xlink:role": xlinkNS,
  "xlink:show": xlinkNS,
  "xlink:title": xlinkNS,
  "xlink:type": xlinkNS,
  "xml:base": xmlNS,
  "xml:lang": xmlNS,
  "xml:space": xmlNS
};
function getDelegatedEventObject(v) {
  return {
    onClick: v,
    onDblClick: v,
    onFocusIn: v,
    onFocusOut: v,
    onKeyDown: v,
    onKeyPress: v,
    onKeyUp: v,
    onMouseDown: v,
    onMouseMove: v,
    onMouseUp: v,
    onTouchEnd: v,
    onTouchMove: v,
    onTouchStart: v
  };
}
var attachedEventCounts = getDelegatedEventObject(0);
var attachedEvents = getDelegatedEventObject(null);
var syntheticEvents = getDelegatedEventObject(true);
function updateOrAddSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (!eventsObject) {
    eventsObject = dom.$EV = getDelegatedEventObject(null);
  }
  if (!eventsObject[name2]) {
    if (++attachedEventCounts[name2] === 1) {
      attachedEvents[name2] = attachEventToDocument(name2);
    }
  }
  return eventsObject;
}
function unmountSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (eventsObject && eventsObject[name2]) {
    if (--attachedEventCounts[name2] === 0) {
      document.removeEventListener(normalizeEventName(name2), attachedEvents[name2]);
      attachedEvents[name2] = null;
    }
    eventsObject[name2] = null;
  }
}
function handleSyntheticEvent(name2, lastEvent, nextEvent, dom) {
  if (isFunction2(nextEvent)) {
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else if (isLinkEventObject(nextEvent)) {
    if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {
      return;
    }
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else {
    unmountSyntheticEvent(name2, dom);
  }
}
function getTargetNode(event) {
  return isFunction2(event.composedPath) ? event.composedPath()[0] : event.target;
}
function dispatchEvents(event, isClick, name2, eventData2) {
  var dom = getTargetNode(event);
  do {
    if (isClick && dom.disabled) {
      return;
    }
    var eventsObject = dom.$EV;
    if (eventsObject) {
      var currentEvent = eventsObject[name2];
      if (currentEvent) {
        eventData2.dom = dom;
        currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);
        if (event.cancelBubble) {
          return;
        }
      }
    }
    dom = dom.parentNode;
  } while (!isNull(dom));
}
function stopPropagation() {
  this.cancelBubble = true;
  if (!this.immediatePropagationStopped) {
    this.stopImmediatePropagation();
  }
}
function isDefaultPrevented() {
  return this.defaultPrevented;
}
function isPropagationStopped() {
  return this.cancelBubble;
}
function extendEventProperties(event) {
  var eventData2 = {
    dom: document
  };
  event.isDefaultPrevented = isDefaultPrevented;
  event.isPropagationStopped = isPropagationStopped;
  event.stopPropagation = stopPropagation;
  Object.defineProperty(event, "currentTarget", {
    configurable: true,
    get: function get() {
      return eventData2.dom;
    }
  });
  return eventData2;
}
function rootClickEvent(name2) {
  return function(event) {
    if (event.button !== 0) {
      event.stopPropagation();
      return;
    }
    dispatchEvents(event, true, name2, extendEventProperties(event));
  };
}
function rootEvent(name2) {
  return function(event) {
    dispatchEvents(event, false, name2, extendEventProperties(event));
  };
}
function attachEventToDocument(name2) {
  var attachedEvent = name2 === "onClick" || name2 === "onDblClick" ? rootClickEvent(name2) : rootEvent(name2);
  document.addEventListener(normalizeEventName(name2), attachedEvent);
  return attachedEvent;
}
function isSameInnerHTML(dom, innerHTML) {
  var tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function triggerEventListener(props, methodName, e) {
  if (props[methodName]) {
    var listener = props[methodName];
    if (listener.event) {
      listener.event(listener.data, e);
    } else {
      listener(e);
    }
  } else {
    var nativeListenerName = methodName.toLowerCase();
    if (props[nativeListenerName]) {
      props[nativeListenerName](e);
    }
  }
}
function createWrappedFunction(methodName, applyValue) {
  var fnMethod = function(e) {
    var vNode = this.$V;
    if (!vNode) {
      return;
    }
    var props = vNode.props || EMPTY_OBJ;
    var dom = vNode.dom;
    if (isString2(methodName)) {
      triggerEventListener(props, methodName, e);
    } else {
      for (var i = 0; i < methodName.length; ++i) {
        triggerEventListener(props, methodName[i], e);
      }
    }
    if (isFunction2(applyValue)) {
      var newVNode = this.$V;
      var newProps = newVNode.props || EMPTY_OBJ;
      applyValue(newProps, dom, false, newVNode);
    }
  };
  Object.defineProperty(fnMethod, "wrapped", {
    configurable: false,
    enumerable: false,
    value: true,
    writable: false
  });
  return fnMethod;
}
function attachEvent(dom, eventName, handler) {
  var previousKey = "$" + eventName;
  var previousArgs = dom[previousKey];
  if (previousArgs) {
    if (previousArgs[1].wrapped) {
      return;
    }
    dom.removeEventListener(previousArgs[0], previousArgs[1]);
    dom[previousKey] = null;
  }
  if (isFunction2(handler)) {
    dom.addEventListener(eventName, handler);
    dom[previousKey] = [eventName, handler];
  }
}
function isCheckedType(type2) {
  return type2 === "checkbox" || type2 === "radio";
}
var onTextInputChange = createWrappedFunction("onInput", applyValueInput);
var wrappedOnChange = createWrappedFunction(["onClick", "onChange"], applyValueInput);
function emptywrapper(event) {
  event.stopPropagation();
}
emptywrapper.wrapped = true;
function inputEvents(dom, nextPropsOrEmpty) {
  if (isCheckedType(nextPropsOrEmpty.type)) {
    attachEvent(dom, "change", wrappedOnChange);
    attachEvent(dom, "click", emptywrapper);
  } else {
    attachEvent(dom, "input", onTextInputChange);
  }
}
function applyValueInput(nextPropsOrEmpty, dom) {
  var type2 = nextPropsOrEmpty.type;
  var value2 = nextPropsOrEmpty.value;
  var checked = nextPropsOrEmpty.checked;
  var multiple = nextPropsOrEmpty.multiple;
  var defaultValue = nextPropsOrEmpty.defaultValue;
  var hasValue = !isNullOrUndef(value2);
  if (type2 && type2 !== dom.type) {
    dom.setAttribute("type", type2);
  }
  if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
    dom.multiple = multiple;
  }
  if (!isNullOrUndef(defaultValue) && !hasValue) {
    dom.defaultValue = defaultValue + "";
  }
  if (isCheckedType(type2)) {
    if (hasValue) {
      dom.value = value2;
    }
    if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  } else {
    if (hasValue && dom.value !== value2) {
      dom.defaultValue = value2;
      dom.value = value2;
    } else if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  }
}
function updateChildOptions(vNode, value2) {
  if (vNode.type === "option") {
    updateChildOption(vNode, value2);
  } else {
    var children = vNode.children;
    var flags = vNode.flags;
    if (flags & 4) {
      updateChildOptions(children.$LI, value2);
    } else if (flags & 8) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags === 2) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags & 12) {
      for (var i = 0, len = children.length; i < len; ++i) {
        updateChildOptions(children[i], value2);
      }
    }
  }
}
function updateChildOption(vNode, value2) {
  var props = vNode.props || EMPTY_OBJ;
  var dom = vNode.dom;
  dom.value = props.value;
  if (props.value === value2 || isArray(value2) && value2.indexOf(props.value) !== -1) {
    dom.selected = true;
  } else if (!isNullOrUndef(value2) || !isNullOrUndef(props.selected)) {
    dom.selected = props.selected || false;
  }
}
var onSelectChange = createWrappedFunction("onChange", applyValueSelect);
function selectEvents(dom) {
  attachEvent(dom, "change", onSelectChange);
}
function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
  var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
  if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
    dom.multiple = multiplePropInBoolean;
  }
  var index2 = nextPropsOrEmpty.selectedIndex;
  if (index2 === -1) {
    dom.selectedIndex = -1;
  }
  var childFlags = vNode.childFlags;
  if (childFlags !== 1) {
    var value2 = nextPropsOrEmpty.value;
    if (isNumber(index2) && index2 > -1 && dom.options[index2]) {
      value2 = dom.options[index2].value;
    }
    if (mounting && isNullOrUndef(value2)) {
      value2 = nextPropsOrEmpty.defaultValue;
    }
    updateChildOptions(vNode, value2);
  }
}
var onTextareaInputChange = createWrappedFunction("onInput", applyValueTextArea);
var wrappedOnChange$1 = createWrappedFunction("onChange");
function textAreaEvents(dom, nextPropsOrEmpty) {
  attachEvent(dom, "input", onTextareaInputChange);
  if (nextPropsOrEmpty.onChange) {
    attachEvent(dom, "change", wrappedOnChange$1);
  }
}
function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
  var value2 = nextPropsOrEmpty.value;
  var domValue = dom.value;
  if (isNullOrUndef(value2)) {
    if (mounting) {
      var defaultValue = nextPropsOrEmpty.defaultValue;
      if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
        dom.defaultValue = defaultValue;
        dom.value = defaultValue;
      }
    }
  } else if (domValue !== value2) {
    dom.defaultValue = value2;
    dom.value = value2;
  }
}
function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
  if (flags & 64) {
    applyValueInput(nextPropsOrEmpty, dom);
  } else if (flags & 256) {
    applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
  } else if (flags & 128) {
    applyValueTextArea(nextPropsOrEmpty, dom, mounting);
  }
  if (isControlled) {
    dom.$V = vNode;
  }
}
function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
  if (flags & 64) {
    inputEvents(dom, nextPropsOrEmpty);
  } else if (flags & 256) {
    selectEvents(dom);
  } else if (flags & 128) {
    textAreaEvents(dom, nextPropsOrEmpty);
  }
}
function isControlledFormElement(nextPropsOrEmpty) {
  return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
}
function createRef() {
  return {
    current: null
  };
}
function unmountRef(ref) {
  if (ref) {
    if (!safeCall1(ref, null) && ref.current) {
      ref.current = null;
    }
  }
}
function mountRef(ref, value2, lifecycle) {
  if (ref && (isFunction2(ref) || ref.current !== void 0)) {
    lifecycle.push(function() {
      if (!safeCall1(ref, value2) && ref.current !== void 0) {
        ref.current = value2;
      }
    });
  }
}
function remove2(vNode, parentDOM) {
  unmount(vNode);
  removeVNodeDOM(vNode, parentDOM);
}
function unmount(vNode) {
  var flags = vNode.flags;
  var children = vNode.children;
  var ref;
  if (flags & 481) {
    ref = vNode.ref;
    var props = vNode.props;
    unmountRef(ref);
    var childFlags = vNode.childFlags;
    if (!isNull(props)) {
      var keys = Object.keys(props);
      for (var i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        if (syntheticEvents[key]) {
          unmountSyntheticEvent(key, vNode.dom);
        }
      }
    }
    if (childFlags & 12) {
      unmountAllChildren(children);
    } else if (childFlags === 2) {
      unmount(children);
    }
  } else if (children) {
    if (flags & 4) {
      if (isFunction2(children.componentWillUnmount)) {
        children.componentWillUnmount();
      }
      unmountRef(vNode.ref);
      children.$UN = true;
      unmount(children.$LI);
    } else if (flags & 8) {
      ref = vNode.ref;
      if (!isNullOrUndef(ref) && isFunction2(ref.onComponentWillUnmount)) {
        ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
      }
      unmount(children);
    } else if (flags & 1024) {
      remove2(children, vNode.ref);
    } else if (flags & 8192) {
      if (vNode.childFlags & 12) {
        unmountAllChildren(children);
      }
    }
  }
}
function unmountAllChildren(children) {
  for (var i = 0, len = children.length; i < len; ++i) {
    unmount(children[i]);
  }
}
function clearDOM(dom) {
  dom.textContent = "";
}
function removeAllChildren(dom, vNode, children) {
  unmountAllChildren(children);
  if (vNode.flags & 8192) {
    removeVNodeDOM(vNode, dom);
  } else {
    clearDOM(dom);
  }
}
function wrapLinkEvent(nextValue) {
  var ev = nextValue.event;
  return function(e) {
    ev(nextValue.data, e);
  };
}
function patchEvent(name2, lastValue, nextValue, dom) {
  if (isLinkEventObject(nextValue)) {
    if (isLastValueSameLinkEvent(lastValue, nextValue)) {
      return;
    }
    nextValue = wrapLinkEvent(nextValue);
  }
  attachEvent(dom, normalizeEventName(name2), nextValue);
}
function patchStyle(lastAttrValue, nextAttrValue, dom) {
  if (isNullOrUndef(nextAttrValue)) {
    dom.removeAttribute("style");
    return;
  }
  var domStyle = dom.style;
  var style;
  var value2;
  if (isString2(nextAttrValue)) {
    domStyle.cssText = nextAttrValue;
    return;
  }
  if (!isNullOrUndef(lastAttrValue) && !isString2(lastAttrValue)) {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      if (value2 !== lastAttrValue[style]) {
        domStyle.setProperty(style, value2);
      }
    }
    for (style in lastAttrValue) {
      if (isNullOrUndef(nextAttrValue[style])) {
        domStyle.removeProperty(style);
      }
    }
  } else {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      domStyle.setProperty(style, value2);
    }
  }
}
function patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {
  var lastHtml = lastValue && lastValue.__html || "";
  var nextHtml = nextValue && nextValue.__html || "";
  if (lastHtml !== nextHtml) {
    if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
      if (!isNull(lastVNode)) {
        if (lastVNode.childFlags & 12) {
          unmountAllChildren(lastVNode.children);
        } else if (lastVNode.childFlags === 2) {
          unmount(lastVNode.children);
        }
        lastVNode.children = null;
        lastVNode.childFlags = 1;
      }
      dom.innerHTML = nextHtml;
    }
  }
}
function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {
  switch (prop) {
    case "children":
    case "childrenType":
    case "className":
    case "defaultValue":
    case "key":
    case "multiple":
    case "ref":
    case "selectedIndex":
      break;
    case "autoFocus":
      dom.autofocus = !!nextValue;
      break;
    case "allowfullscreen":
    case "autoplay":
    case "capture":
    case "checked":
    case "controls":
    case "default":
    case "disabled":
    case "hidden":
    case "indeterminate":
    case "loop":
    case "muted":
    case "novalidate":
    case "open":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "selected":
      dom[prop] = !!nextValue;
      break;
    case "defaultChecked":
    case "value":
    case "volume":
      if (hasControlledValue && prop === "value") {
        break;
      }
      var value2 = isNullOrUndef(nextValue) ? "" : nextValue;
      if (dom[prop] !== value2) {
        dom[prop] = value2;
      }
      break;
    case "style":
      patchStyle(lastValue, nextValue, dom);
      break;
    case "dangerouslySetInnerHTML":
      patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);
      break;
    default:
      if (syntheticEvents[prop]) {
        handleSyntheticEvent(prop, lastValue, nextValue, dom);
      } else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {
        patchEvent(prop, lastValue, nextValue, dom);
      } else if (isNullOrUndef(nextValue)) {
        dom.removeAttribute(prop);
      } else if (isSVG && namespaces[prop]) {
        dom.setAttributeNS(namespaces[prop], prop, nextValue);
      } else {
        dom.setAttribute(prop, nextValue);
      }
      break;
  }
}
function mountProps(vNode, flags, props, dom, isSVG) {
  var hasControlledValue = false;
  var isFormElement = (flags & 448) > 0;
  if (isFormElement) {
    hasControlledValue = isControlledFormElement(props);
    if (hasControlledValue) {
      addFormElementEventHandlers(flags, dom, props);
    }
  }
  for (var prop in props) {
    patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);
  }
  if (isFormElement) {
    processElement(flags, vNode, dom, props, true, hasControlledValue);
  }
}
function renderNewInput(instance, props, context2) {
  var nextInput = normalizeRoot(instance.render(props, instance.state, context2));
  var childContext = context2;
  if (isFunction2(instance.getChildContext)) {
    childContext = combineFrom(context2, instance.getChildContext());
  }
  instance.$CX = childContext;
  return nextInput;
}
function createClassComponentInstance(vNode, Component4, props, context2, isSVG, lifecycle) {
  var instance = new Component4(props, context2);
  var usesNewAPI = instance.$N = Boolean(Component4.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate);
  instance.$SVG = isSVG;
  instance.$L = lifecycle;
  vNode.children = instance;
  instance.$BS = false;
  instance.context = context2;
  if (instance.props === EMPTY_OBJ) {
    instance.props = props;
  }
  if (!usesNewAPI) {
    if (isFunction2(instance.componentWillMount)) {
      instance.$BR = true;
      instance.componentWillMount();
      var pending = instance.$PS;
      if (!isNull(pending)) {
        var state = instance.state;
        if (isNull(state)) {
          instance.state = pending;
        } else {
          for (var key in pending) {
            state[key] = pending[key];
          }
        }
        instance.$PS = null;
      }
      instance.$BR = false;
    }
  } else {
    instance.state = createDerivedState(instance, props, instance.state);
  }
  instance.$LI = renderNewInput(instance, props, context2);
  return instance;
}
function renderFunctionalComponent(vNode, context2) {
  var props = vNode.props || EMPTY_OBJ;
  return vNode.flags & 32768 ? vNode.type.render(props, vNode.ref, context2) : vNode.type(props, context2);
}
function mount(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var flags = vNode.flags |= 16384;
  if (flags & 481) {
    mountElement(vNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (flags & 4) {
    mountClassComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (flags & 8) {
    mountFunctionalComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle);
    mountFunctionalComponentCallbacks(vNode, lifecycle);
  } else if (flags & 512 || flags & 16) {
    mountText(vNode, parentDOM, nextNode);
  } else if (flags & 8192) {
    mountFragment(vNode, context2, parentDOM, isSVG, nextNode, lifecycle);
  } else if (flags & 1024) {
    mountPortal(vNode, context2, parentDOM, nextNode, lifecycle);
  } else
    ;
}
function mountPortal(vNode, context2, parentDOM, nextNode, lifecycle) {
  mount(vNode.children, vNode.ref, context2, false, null, lifecycle);
  var placeHolderVNode = createVoidVNode();
  mountText(placeHolderVNode, parentDOM, nextNode);
  vNode.dom = placeHolderVNode.dom;
}
function mountFragment(vNode, context2, parentDOM, isSVG, nextNode, lifecycle) {
  var children = vNode.children;
  var childFlags = vNode.childFlags;
  if (childFlags & 12 && children.length === 0) {
    childFlags = vNode.childFlags = 2;
    children = vNode.children = createVoidVNode();
  }
  if (childFlags === 2) {
    mount(children, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else {
    mountArrayChildren(children, parentDOM, context2, isSVG, nextNode, lifecycle);
  }
}
function mountText(vNode, parentDOM, nextNode) {
  var dom = vNode.dom = document.createTextNode(vNode.children);
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
}
function mountElement(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var flags = vNode.flags;
  var props = vNode.props;
  var className = vNode.className;
  var childFlags = vNode.childFlags;
  var dom = vNode.dom = documentCreateElement(vNode.type, isSVG = isSVG || (flags & 32) > 0);
  var children = vNode.children;
  if (!isNullOrUndef(className) && className !== "") {
    if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
  }
  if (childFlags === 16) {
    setTextContent(dom, children);
  } else if (childFlags !== 1) {
    var childrenIsSVG = isSVG && vNode.type !== "foreignObject";
    if (childFlags === 2) {
      if (children.flags & 16384) {
        vNode.children = children = directClone(children);
      }
      mount(children, dom, context2, childrenIsSVG, null, lifecycle);
    } else if (childFlags === 8 || childFlags === 4) {
      mountArrayChildren(children, dom, context2, childrenIsSVG, null, lifecycle);
    }
  }
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
  if (!isNull(props)) {
    mountProps(vNode, flags, props, dom, isSVG);
  }
  mountRef(vNode.ref, dom, lifecycle);
}
function mountArrayChildren(children, dom, context2, isSVG, nextNode, lifecycle) {
  for (var i = 0; i < children.length; ++i) {
    var child = children[i];
    if (child.flags & 16384) {
      children[i] = child = directClone(child);
    }
    mount(child, dom, context2, isSVG, nextNode, lifecycle);
  }
}
function mountClassComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context2, isSVG, lifecycle);
  mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
  mountClassComponentCallbacks(vNode.ref, instance, lifecycle);
}
function mountFunctionalComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  mount(vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context2)), parentDOM, context2, isSVG, nextNode, lifecycle);
}
function createClassMountCallback(instance) {
  return function() {
    instance.componentDidMount();
  };
}
function mountClassComponentCallbacks(ref, instance, lifecycle) {
  mountRef(ref, instance, lifecycle);
  if (isFunction2(instance.componentDidMount)) {
    lifecycle.push(createClassMountCallback(instance));
  }
}
function createOnMountCallback(ref, vNode) {
  return function() {
    ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
  };
}
function mountFunctionalComponentCallbacks(vNode, lifecycle) {
  var ref = vNode.ref;
  if (!isNullOrUndef(ref)) {
    safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);
    if (isFunction2(ref.onComponentDidMount)) {
      lifecycle.push(createOnMountCallback(ref, vNode));
    }
  }
}
function replaceWithNewNode(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle) {
  unmount(lastVNode);
  if ((nextVNode.flags & lastVNode.flags & 2033) !== 0) {
    mount(nextVNode, null, context2, isSVG, null, lifecycle);
    replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);
  } else {
    mount(nextVNode, parentDOM, context2, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);
    removeVNodeDOM(lastVNode, parentDOM);
  }
}
function patch(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var nextFlags = nextVNode.flags |= 16384;
  if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048) {
    if (lastVNode.flags & 16384) {
      replaceWithNewNode(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle);
    } else {
      mount(nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle);
    }
  } else if (nextFlags & 481) {
    patchElement(lastVNode, nextVNode, context2, isSVG, nextFlags, lifecycle);
  } else if (nextFlags & 4) {
    patchClassComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (nextFlags & 8) {
    patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (nextFlags & 16) {
    patchText(lastVNode, nextVNode);
  } else if (nextFlags & 512) {
    nextVNode.dom = lastVNode.dom;
  } else if (nextFlags & 8192) {
    patchFragment(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle);
  } else {
    patchPortal(lastVNode, nextVNode, context2, lifecycle);
  }
}
function patchSingleTextChild(lastChildren, nextChildren, parentDOM) {
  if (lastChildren !== nextChildren) {
    if (lastChildren !== "") {
      parentDOM.firstChild.nodeValue = nextChildren;
    } else {
      setTextContent(parentDOM, nextChildren);
    }
  }
}
function patchContentEditableChildren(dom, nextChildren) {
  if (dom.textContent !== nextChildren) {
    dom.textContent = nextChildren;
  }
}
function patchFragment(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle) {
  var lastChildren = lastVNode.children;
  var nextChildren = nextVNode.children;
  var lastChildFlags = lastVNode.childFlags;
  var nextChildFlags = nextVNode.childFlags;
  var nextNode = null;
  if (nextChildFlags & 12 && nextChildren.length === 0) {
    nextChildFlags = nextVNode.childFlags = 2;
    nextChildren = nextVNode.children = createVoidVNode();
  }
  var nextIsSingle = (nextChildFlags & 2) !== 0;
  if (lastChildFlags & 12) {
    var lastLen = lastChildren.length;
    if (
      // It uses keyed algorithm
      lastChildFlags & 8 && nextChildFlags & 8 || // It transforms from many to single
      nextIsSingle || // It will append more nodes
      !nextIsSingle && nextChildren.length > lastLen
    ) {
      nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;
    }
  }
  patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, lastVNode, lifecycle);
}
function patchPortal(lastVNode, nextVNode, context2, lifecycle) {
  var lastContainer = lastVNode.ref;
  var nextContainer = nextVNode.ref;
  var nextChildren = nextVNode.children;
  patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context2, false, null, lastVNode, lifecycle);
  nextVNode.dom = lastVNode.dom;
  if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
    var node = nextChildren.dom;
    removeChild(lastContainer, node);
    appendChild(nextContainer, node);
  }
}
function patchElement(lastVNode, nextVNode, context2, isSVG, nextFlags, lifecycle) {
  var dom = nextVNode.dom = lastVNode.dom;
  var lastProps = lastVNode.props;
  var nextProps = nextVNode.props;
  var isFormElement = false;
  var hasControlledValue = false;
  var nextPropsOrEmpty;
  isSVG = isSVG || (nextFlags & 32) > 0;
  if (lastProps !== nextProps) {
    var lastPropsOrEmpty = lastProps || EMPTY_OBJ;
    nextPropsOrEmpty = nextProps || EMPTY_OBJ;
    if (nextPropsOrEmpty !== EMPTY_OBJ) {
      isFormElement = (nextFlags & 448) > 0;
      if (isFormElement) {
        hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
      }
      for (var prop in nextPropsOrEmpty) {
        var lastValue = lastPropsOrEmpty[prop];
        var nextValue = nextPropsOrEmpty[prop];
        if (lastValue !== nextValue) {
          patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);
        }
      }
    }
    if (lastPropsOrEmpty !== EMPTY_OBJ) {
      for (var prop$1 in lastPropsOrEmpty) {
        if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {
          patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);
        }
      }
    }
  }
  var nextChildren = nextVNode.children;
  var nextClassName = nextVNode.className;
  if (lastVNode.className !== nextClassName) {
    if (isNullOrUndef(nextClassName)) {
      dom.removeAttribute("class");
    } else if (isSVG) {
      dom.setAttribute("class", nextClassName);
    } else {
      dom.className = nextClassName;
    }
  }
  if (nextFlags & 4096) {
    patchContentEditableChildren(dom, nextChildren);
  } else {
    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context2, isSVG && nextVNode.type !== "foreignObject", null, lastVNode, lifecycle);
  }
  if (isFormElement) {
    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
  }
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, dom, lifecycle);
  }
}
function replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context2, isSVG, lifecycle) {
  unmount(lastChildren);
  mountArrayChildren(nextChildren, parentDOM, context2, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);
  removeVNodeDOM(lastChildren, parentDOM);
}
function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, parentVNode, lifecycle) {
  switch (lastChildFlags) {
    case 2:
      switch (nextChildFlags) {
        case 2:
          patch(lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          remove2(lastChildren, parentDOM);
          break;
        case 16:
          unmount(lastChildren);
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context2, isSVG, lifecycle);
          break;
      }
      break;
    case 1:
      switch (nextChildFlags) {
        case 2:
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          break;
        case 16:
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
      }
      break;
    case 16:
      switch (nextChildFlags) {
        case 16:
          patchSingleTextChild(lastChildren, nextChildren, parentDOM);
          break;
        case 2:
          clearDOM(parentDOM);
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          clearDOM(parentDOM);
          break;
        default:
          clearDOM(parentDOM);
          mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
      }
      break;
    default:
      switch (nextChildFlags) {
        case 16:
          unmountAllChildren(lastChildren);
          setTextContent(parentDOM, nextChildren);
          break;
        case 2:
          removeAllChildren(parentDOM, parentVNode, lastChildren);
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          removeAllChildren(parentDOM, parentVNode, lastChildren);
          break;
        default:
          var lastLength = lastChildren.length | 0;
          var nextLength = nextChildren.length | 0;
          if (lastLength === 0) {
            if (nextLength > 0) {
              mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
            }
          } else if (nextLength === 0) {
            removeAllChildren(parentDOM, parentVNode, lastChildren);
          } else if (nextChildFlags === 8 && lastChildFlags === 8) {
            patchKeyedChildren(lastChildren, nextChildren, parentDOM, context2, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);
          } else {
            patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context2, isSVG, lastLength, nextLength, nextNode, lifecycle);
          }
          break;
      }
      break;
  }
}
function createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {
  lifecycle.push(function() {
    instance.componentDidUpdate(lastProps, lastState, snapshot);
  });
}
function updateClassComponent(instance, nextState, nextProps, parentDOM, context2, isSVG, force, nextNode, lifecycle) {
  var lastState = instance.state;
  var lastProps = instance.props;
  var usesNewAPI = Boolean(instance.$N);
  var hasSCU = isFunction2(instance.shouldComponentUpdate);
  if (usesNewAPI) {
    nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);
  }
  if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context2)) {
    if (!usesNewAPI && isFunction2(instance.componentWillUpdate)) {
      instance.componentWillUpdate(nextProps, nextState, context2);
    }
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context2;
    var snapshot = null;
    var nextInput = renderNewInput(instance, nextProps, context2);
    if (usesNewAPI && isFunction2(instance.getSnapshotBeforeUpdate)) {
      snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);
    }
    patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
    instance.$LI = nextInput;
    if (isFunction2(instance.componentDidUpdate)) {
      createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);
    }
  } else {
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context2;
  }
}
function patchClassComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var instance = nextVNode.children = lastVNode.children;
  if (isNull(instance)) {
    return;
  }
  instance.$L = lifecycle;
  var nextProps = nextVNode.props || EMPTY_OBJ;
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  var nextState = instance.state;
  if (!instance.$N) {
    if (isFunction2(instance.componentWillReceiveProps)) {
      instance.$BR = true;
      instance.componentWillReceiveProps(nextProps, context2);
      if (instance.$UN) {
        return;
      }
      instance.$BR = false;
    }
    if (!isNull(instance.$PS)) {
      nextState = combineFrom(nextState, instance.$PS);
      instance.$PS = null;
    }
  }
  updateClassComponent(instance, nextState, nextProps, parentDOM, context2, isSVG, false, nextNode, lifecycle);
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, instance, lifecycle);
  }
}
function patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var shouldUpdate = true;
  var nextProps = nextVNode.props || EMPTY_OBJ;
  var nextRef = nextVNode.ref;
  var lastProps = lastVNode.props;
  var nextHooksDefined = !isNullOrUndef(nextRef);
  var lastInput = lastVNode.children;
  if (nextHooksDefined && isFunction2(nextRef.onComponentShouldUpdate)) {
    shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);
  }
  if (shouldUpdate !== false) {
    if (nextHooksDefined && isFunction2(nextRef.onComponentWillUpdate)) {
      nextRef.onComponentWillUpdate(lastProps, nextProps);
    }
    var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context2));
    patch(lastInput, nextInput, parentDOM, context2, isSVG, nextNode, lifecycle);
    nextVNode.children = nextInput;
    if (nextHooksDefined && isFunction2(nextRef.onComponentDidUpdate)) {
      nextRef.onComponentDidUpdate(lastProps, nextProps);
    }
  } else {
    nextVNode.children = lastInput;
  }
}
function patchText(lastVNode, nextVNode) {
  var nextText = nextVNode.children;
  var dom = nextVNode.dom = lastVNode.dom;
  if (nextText !== lastVNode.children) {
    dom.nodeValue = nextText;
  }
}
function patchNonKeyedChildren(lastChildren, nextChildren, dom, context2, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {
  var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
  var i = 0;
  var nextChild;
  var lastChild;
  for (; i < commonLength; ++i) {
    nextChild = nextChildren[i];
    lastChild = lastChildren[i];
    if (nextChild.flags & 16384) {
      nextChild = nextChildren[i] = directClone(nextChild);
    }
    patch(lastChild, nextChild, dom, context2, isSVG, nextNode, lifecycle);
    lastChildren[i] = nextChild;
  }
  if (lastChildrenLength < nextChildrenLength) {
    for (i = commonLength; i < nextChildrenLength; ++i) {
      nextChild = nextChildren[i];
      if (nextChild.flags & 16384) {
        nextChild = nextChildren[i] = directClone(nextChild);
      }
      mount(nextChild, dom, context2, isSVG, nextNode, lifecycle);
    }
  } else if (lastChildrenLength > nextChildrenLength) {
    for (i = commonLength; i < lastChildrenLength; ++i) {
      remove2(lastChildren[i], dom);
    }
  }
}
function patchKeyedChildren(a, b, dom, context2, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {
  var aEnd = aLength - 1;
  var bEnd = bLength - 1;
  var j = 0;
  var aNode = a[j];
  var bNode = b[j];
  var nextPos;
  var nextNode;
  outer: {
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[j] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
      a[j] = bNode;
      ++j;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[j];
      bNode = b[j];
    }
    aNode = a[aEnd];
    bNode = b[bEnd];
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[bEnd] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
      a[aEnd] = bNode;
      aEnd--;
      bEnd--;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[aEnd];
      bNode = b[bEnd];
    }
  }
  if (j > aEnd) {
    if (j <= bEnd) {
      nextPos = bEnd + 1;
      nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;
      while (j <= bEnd) {
        bNode = b[j];
        if (bNode.flags & 16384) {
          b[j] = bNode = directClone(bNode);
        }
        ++j;
        mount(bNode, dom, context2, isSVG, nextNode, lifecycle);
      }
    }
  } else if (j > bEnd) {
    while (j <= aEnd) {
      remove2(a[j++], dom);
    }
  } else {
    patchKeyedChildrenComplex(a, b, context2, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);
  }
}
function patchKeyedChildrenComplex(a, b, context2, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {
  var aNode;
  var bNode;
  var nextPos;
  var i = 0;
  var aStart = j;
  var bStart = j;
  var aLeft = aEnd - j + 1;
  var bLeft = bEnd - j + 1;
  var sources = new Int32Array(bLeft + 1);
  var canRemoveWholeContent = aLeft === aLength;
  var moved = false;
  var pos = 0;
  var patched = 0;
  if (bLength < 4 || (aLeft | bLeft) < 32) {
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        for (j = bStart; j <= bEnd; j++) {
          bNode = b[j];
          if (aNode.key === bNode.key) {
            sources[j - bStart] = i + 1;
            if (canRemoveWholeContent) {
              canRemoveWholeContent = false;
              while (aStart < i) {
                remove2(a[aStart++], dom);
              }
            }
            if (pos > j) {
              moved = true;
            } else {
              pos = j;
            }
            if (bNode.flags & 16384) {
              b[j] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
            ++patched;
            break;
          }
        }
        if (!canRemoveWholeContent && j > bEnd) {
          remove2(aNode, dom);
        }
      } else if (!canRemoveWholeContent) {
        remove2(aNode, dom);
      }
    }
  } else {
    var keyIndex = {};
    for (i = bStart; i <= bEnd; ++i) {
      keyIndex[b[i].key] = i;
    }
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        j = keyIndex[aNode.key];
        if (j !== void 0) {
          if (canRemoveWholeContent) {
            canRemoveWholeContent = false;
            while (i > aStart) {
              remove2(a[aStart++], dom);
            }
          }
          sources[j - bStart] = i + 1;
          if (pos > j) {
            moved = true;
          } else {
            pos = j;
          }
          bNode = b[j];
          if (bNode.flags & 16384) {
            b[j] = bNode = directClone(bNode);
          }
          patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
          ++patched;
        } else if (!canRemoveWholeContent) {
          remove2(aNode, dom);
        }
      } else if (!canRemoveWholeContent) {
        remove2(aNode, dom);
      }
    }
  }
  if (canRemoveWholeContent) {
    removeAllChildren(dom, parentVNode, a);
    mountArrayChildren(b, dom, context2, isSVG, outerEdge, lifecycle);
  } else if (moved) {
    var seq = lis_algorithm(sources);
    j = seq.length - 1;
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount(bNode, dom, context2, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
      } else if (j < 0 || i !== seq[j]) {
        pos = i + bStart;
        bNode = b[pos];
        nextPos = pos + 1;
        moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);
      } else {
        j--;
      }
    }
  } else if (patched !== bLeft) {
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount(bNode, dom, context2, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
      }
    }
  }
}
var result;
var p;
var maxLen = 0;
function lis_algorithm(arr) {
  var arrI = 0;
  var i = 0;
  var j = 0;
  var k = 0;
  var u = 0;
  var v = 0;
  var c = 0;
  var len = arr.length;
  if (len > maxLen) {
    maxLen = len;
    result = new Int32Array(len);
    p = new Int32Array(len);
  }
  for (; i < len; ++i) {
    arrI = arr[i];
    if (arrI !== 0) {
      j = result[k];
      if (arr[j] < arrI) {
        p[i] = j;
        result[++k] = i;
        continue;
      }
      u = 0;
      v = k;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = k + 1;
  var seq = new Int32Array(u);
  v = result[u - 1];
  while (u-- > 0) {
    seq[u] = v;
    v = p[v];
    result[u] = 0;
  }
  return seq;
}
var hasDocumentAvailable = typeof document !== "undefined";
if (hasDocumentAvailable) {
  if (window.Node) {
    Node.prototype.$EV = null;
    Node.prototype.$V = null;
  }
}
function __render(input, parentDOM, callback, context2) {
  var lifecycle = [];
  var rootInput = parentDOM.$V;
  renderCheck.v = true;
  if (isNullOrUndef(rootInput)) {
    if (!isNullOrUndef(input)) {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      mount(input, parentDOM, context2, false, null, lifecycle);
      parentDOM.$V = input;
      rootInput = input;
    }
  } else {
    if (isNullOrUndef(input)) {
      remove2(rootInput, parentDOM);
      parentDOM.$V = null;
    } else {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      patch(rootInput, input, parentDOM, context2, false, null, lifecycle);
      rootInput = parentDOM.$V = input;
    }
  }
  callAll(lifecycle);
  renderCheck.v = false;
  if (isFunction2(callback)) {
    callback();
  }
  if (isFunction2(options.renderComplete)) {
    options.renderComplete(rootInput, parentDOM);
  }
}
function render(input, parentDOM, callback, context2) {
  if (callback === void 0)
    callback = null;
  if (context2 === void 0)
    context2 = EMPTY_OBJ;
  __render(input, parentDOM, callback, context2);
}
var QUEUE = [];
var nextTick = typeof Promise !== "undefined" ? Promise.resolve().then.bind(Promise.resolve()) : function(a) {
  window.setTimeout(a, 0);
};
var microTaskPending = false;
function queueStateChanges(component, newState, callback, force) {
  var pending = component.$PS;
  if (isFunction2(newState)) {
    newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);
  }
  if (isNullOrUndef(pending)) {
    component.$PS = newState;
  } else {
    for (var stateKey in newState) {
      pending[stateKey] = newState[stateKey];
    }
  }
  if (!component.$BR) {
    if (!renderCheck.v) {
      if (QUEUE.length === 0) {
        applyState(component, force);
        if (isFunction2(callback)) {
          callback.call(component);
        }
        return;
      }
    }
    if (QUEUE.indexOf(component) === -1) {
      QUEUE.push(component);
    }
    if (force) {
      component.$F = true;
    }
    if (!microTaskPending) {
      microTaskPending = true;
      nextTick(rerender);
    }
    if (isFunction2(callback)) {
      var QU = component.$QU;
      if (!QU) {
        QU = component.$QU = [];
      }
      QU.push(callback);
    }
  } else if (isFunction2(callback)) {
    component.$L.push(callback.bind(component));
  }
}
function callSetStateCallbacks(component) {
  var queue = component.$QU;
  for (var i = 0; i < queue.length; ++i) {
    queue[i].call(component);
  }
  component.$QU = null;
}
function rerender() {
  var component;
  microTaskPending = false;
  while (component = QUEUE.shift()) {
    if (!component.$UN) {
      var force = component.$F;
      component.$F = false;
      applyState(component, force);
      if (component.$QU) {
        callSetStateCallbacks(component);
      }
    }
  }
}
function applyState(component, force) {
  if (force || !component.$BR) {
    var pendingState = component.$PS;
    component.$PS = null;
    var lifecycle = [];
    renderCheck.v = true;
    updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);
    callAll(lifecycle);
    renderCheck.v = false;
  } else {
    component.state = component.$PS;
    component.$PS = null;
  }
}
var Component2 = function Component3(props, context2) {
  this.state = null;
  this.$BR = false;
  this.$BS = true;
  this.$PS = null;
  this.$LI = null;
  this.$UN = false;
  this.$CX = null;
  this.$QU = null;
  this.$N = false;
  this.$L = null;
  this.$SVG = false;
  this.$F = false;
  this.props = props || EMPTY_OBJ;
  this.context = context2 || EMPTY_OBJ;
};
Component2.prototype.forceUpdate = function forceUpdate(callback) {
  if (this.$UN) {
    return;
  }
  queueStateChanges(this, {}, callback, true);
};
Component2.prototype.setState = function setState(newState, callback) {
  if (this.$UN) {
    return;
  }
  if (!this.$BS) {
    queueStateChanges(this, newState, callback, false);
  }
};
Component2.prototype.render = function render2(_nextProps, _nextState, _nextContext) {
  return null;
};

// ../../../../../../node_modules/inferno/index.esm.js
if (true) {
  console.warn("You are running production build of Inferno in development mode. Use dev:module entry point.");
}

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/effect_host.js
var InfernoEffectHost = {
  lockCount: 0,
  lock() {
    this.lockCount++;
  },
  callbacks: [],
  callEffects() {
    this.lockCount--;
    if (this.lockCount < 0) {
      throw new Error("Unexpected Effect Call");
    }
    if (this.lockCount === 0) {
      const effects = this.callbacks;
      this.callbacks = [];
      effects.forEach((callback) => callback());
    }
  }
};

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/base_component.js
var areObjectsEqual = (firstObject, secondObject) => {
  const bothAreObjects = firstObject instanceof Object && secondObject instanceof Object;
  if (!bothAreObjects) {
    return firstObject === secondObject;
  }
  const firstObjectKeys = Object.keys(firstObject);
  const secondObjectKeys = Object.keys(secondObject);
  if (firstObjectKeys.length !== secondObjectKeys.length) {
    return false;
  }
  const hasDifferentElement = firstObjectKeys.some((key) => firstObject[key] !== secondObject[key]);
  return !hasDifferentElement;
};
var BaseInfernoComponent = class extends Component2 {
  constructor() {
    super(...arguments);
    this._pendingContext = this.context;
  }
  componentWillReceiveProps(_, context2) {
    this._pendingContext = context2 !== null && context2 !== void 0 ? context2 : {};
  }
  shouldComponentUpdate(nextProps, nextState) {
    return !areObjectsEqual(this.props, nextProps) || !areObjectsEqual(this.state, nextState) || !areObjectsEqual(this.context, this._pendingContext);
  }
};
var InfernoComponent = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this._effects = [];
  }
  createEffects() {
    return [];
  }
  updateEffects() {
  }
  componentWillMount() {
    InfernoEffectHost.lock();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  componentWillUpdate(_nextProps, _nextState, _context) {
    InfernoEffectHost.lock();
  }
  componentDidMount() {
    InfernoEffectHost.callbacks.push(() => {
      this._effects = this.createEffects();
    });
    InfernoEffectHost.callEffects();
  }
  componentDidUpdate() {
    InfernoEffectHost.callbacks.push(() => this.updateEffects());
    InfernoEffectHost.callEffects();
  }
  destroyEffects() {
    this._effects.forEach((e) => e.dispose());
  }
  componentWillUnmount() {
    this.destroyEffects();
  }
};
var InfernoWrapperComponent = class extends InfernoComponent {
  constructor() {
    super(...arguments);
    this.vDomElement = null;
  }
  vDomUpdateClasses() {
    const el = this.vDomElement;
    const currentClasses = el.className.length ? el.className.split(" ") : [];
    const addedClasses = currentClasses.filter((className) => el.dxClasses.previous.indexOf(className) < 0);
    const removedClasses = el.dxClasses.previous.filter((className) => currentClasses.indexOf(className) < 0);
    addedClasses.forEach((value2) => {
      const indexInRemoved = el.dxClasses.removed.indexOf(value2);
      if (indexInRemoved > -1) {
        el.dxClasses.removed.splice(indexInRemoved, 1);
      } else if (!el.dxClasses.added.includes(value2)) {
        el.dxClasses.added.push(value2);
      }
    });
    removedClasses.forEach((value2) => {
      const indexInAdded = el.dxClasses.added.indexOf(value2);
      if (indexInAdded > -1) {
        el.dxClasses.added.splice(indexInAdded, 1);
      } else if (!el.dxClasses.removed.includes(value2)) {
        el.dxClasses.removed.push(value2);
      }
    });
  }
  componentDidMount() {
    const el = findDOMfromVNode(this.$LI, true);
    this.vDomElement = el;
    super.componentDidMount();
    el.dxClasses = el.dxClasses || {
      removed: [],
      added: [],
      previous: []
    };
    el.dxClasses.previous = (el === null || el === void 0 ? void 0 : el.className.length) ? el.className.split(" ") : [];
  }
  componentDidUpdate() {
    super.componentDidUpdate();
    const el = this.vDomElement;
    if (el !== null) {
      el.dxClasses.added.forEach((className) => el.classList.add(className));
      el.dxClasses.removed.forEach((className) => el.classList.remove(className));
      el.dxClasses.previous = el.className.length ? el.className.split(" ") : [];
    }
  }
  shouldComponentUpdate(nextProps, nextState) {
    const shouldUpdate = super.shouldComponentUpdate(nextProps, nextState);
    if (shouldUpdate) {
      this.vDomUpdateClasses();
    }
    return shouldUpdate;
  }
};

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/create_context.js
var contextId = 0;
var createContext = function(defaultValue) {
  const id = contextId++;
  return {
    id,
    defaultValue,
    Provider: class extends Component2 {
      getChildContext() {
        return Object.assign(Object.assign({}, this.context), { [id]: this.props.value || defaultValue });
      }
      render() {
        return this.props.children;
      }
    }
  };
};

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/effect.js
var InfernoEffect = class {
  constructor(effect, dependency) {
    this.dependency = dependency;
    this.effect = effect;
    this.destroy = effect();
  }
  update(dependency) {
    const currentDependency = this.dependency;
    if (dependency) {
      this.dependency = dependency;
    }
    if (!dependency || dependency.some((d, i) => currentDependency[i] !== d)) {
      this.dispose();
      this.destroy = this.effect();
    }
  }
  dispose() {
    if (this.destroy) {
      this.destroy();
    }
  }
};

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/re_render_effect.js
var createReRenderEffect = () => new InfernoEffect(() => {
  rerender();
}, []);

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/mocked/shared.js
var ERROR_MSG = "a runtime error occured! Use Inferno in development environment to find the error.";
function isNullOrUndef2(o) {
  return o === void 0 || o === null;
}
function isInvalid2(o) {
  return o === null || o === false || o === true || o === void 0;
}
function isFunction3(o) {
  return typeof o === "function";
}
function isNull2(o) {
  return o === null;
}
function throwError(message) {
  if (!message) {
    message = ERROR_MSG;
  }
  throw new Error(`Inferno Error: ${message}`);
}

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/mocked/hydrate.js
function isSameInnerHTML2(dom, innerHTML) {
  const tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function findLastDOMFromVNode(vNode) {
  let flags;
  let children;
  while (vNode) {
    flags = vNode.flags;
    if (flags & 2033) {
      return vNode.dom;
    }
    children = vNode.children;
    if (flags & 8192) {
      vNode = vNode.childFlags === 2 ? children : children[children.length - 1];
    } else if (flags & 4) {
      vNode = children.$LI;
    } else {
      vNode = children;
    }
  }
  return null;
}
function isSamePropsInnerHTML(dom, props) {
  return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML2(dom, props.dangerouslySetInnerHTML.__html));
}
function hydrateComponent(vNode, parentDOM, dom, context2, isSVG, isClass, lifecycle) {
  const type2 = vNode.type;
  const ref = vNode.ref;
  const props = vNode.props || EMPTY_OBJ;
  let currentNode;
  if (isClass) {
    const instance = createClassComponentInstance(vNode, type2, props, context2, isSVG, lifecycle);
    const input = instance.$LI;
    currentNode = hydrateVNode(input, parentDOM, dom, instance.$CX, isSVG, lifecycle);
    mountClassComponentCallbacks(ref, instance, lifecycle);
  } else {
    const input = normalizeRoot(renderFunctionalComponent(vNode, context2));
    currentNode = hydrateVNode(input, parentDOM, dom, context2, isSVG, lifecycle);
    vNode.children = input;
    mountFunctionalComponentCallbacks(vNode, lifecycle);
  }
  return currentNode;
}
function hydrateChildren(parentVNode, parentNode, currentNode, context2, isSVG, lifecycle) {
  const childFlags = parentVNode.childFlags;
  const children = parentVNode.children;
  const props = parentVNode.props;
  const flags = parentVNode.flags;
  if (childFlags !== 1) {
    if (childFlags === 2) {
      if (isNull2(currentNode)) {
        mount(children, parentNode, context2, isSVG, null, lifecycle);
      } else {
        currentNode = hydrateVNode(children, parentNode, currentNode, context2, isSVG, lifecycle);
        currentNode = currentNode ? currentNode.nextSibling : null;
      }
    } else if (childFlags === 16) {
      if (isNull2(currentNode)) {
        parentNode.appendChild(document.createTextNode(children));
      } else if (parentNode.childNodes.length !== 1 || currentNode.nodeType !== 3) {
        parentNode.textContent = children;
      } else if (currentNode.nodeValue !== children) {
        currentNode.nodeValue = children;
      }
      currentNode = null;
    } else if (childFlags & 12) {
      let prevVNodeIsTextNode = false;
      for (let i = 0, len = children.length; i < len; ++i) {
        const child = children[i];
        if (isNull2(currentNode) || prevVNodeIsTextNode && (child.flags & 16) > 0) {
          mount(child, parentNode, context2, isSVG, currentNode, lifecycle);
        } else {
          currentNode = hydrateVNode(child, parentNode, currentNode, context2, isSVG, lifecycle);
          currentNode = currentNode ? currentNode.nextSibling : null;
        }
        prevVNodeIsTextNode = (child.flags & 16) > 0;
      }
    }
    if ((flags & 8192) === 0) {
      let nextSibling = null;
      while (currentNode) {
        nextSibling = currentNode.nextSibling;
        parentNode.removeChild(currentNode);
        currentNode = nextSibling;
      }
    }
  } else if (!isNull2(parentNode.firstChild) && !isSamePropsInnerHTML(parentNode, props)) {
    parentNode.textContent = "";
    if (flags & 448) {
      parentNode.defaultValue = "";
    }
  }
}
function hydrateElement(vNode, parentDOM, dom, context2, isSVG, lifecycle) {
  const props = vNode.props;
  const className = vNode.className;
  const flags = vNode.flags;
  const ref = vNode.ref;
  isSVG = isSVG || (flags & 32) > 0;
  if (dom.nodeType !== 1) {
    mountElement(vNode, null, context2, isSVG, null, lifecycle);
    parentDOM.replaceChild(vNode.dom, dom);
  } else {
    vNode.dom = dom;
    hydrateChildren(vNode, dom, dom.firstChild, context2, isSVG, lifecycle);
    if (!isNull2(props)) {
      mountProps(vNode, flags, props, dom, isSVG);
    }
    if (isNullOrUndef2(className)) {
      if (dom.className !== "") {
        dom.removeAttribute("class");
      }
    } else if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
    mountRef(ref, dom, lifecycle);
  }
  return vNode.dom;
}
function hydrateText(vNode, parentDOM, dom) {
  if (dom.nodeType !== 3) {
    parentDOM.replaceChild(vNode.dom = document.createTextNode(vNode.children), dom);
  } else {
    const text = vNode.children;
    if (dom.nodeValue !== text) {
      dom.nodeValue = text;
    }
    vNode.dom = dom;
  }
  return vNode.dom;
}
function hydrateFragment(vNode, parentDOM, dom, context2, isSVG, lifecycle) {
  const children = vNode.children;
  if (vNode.childFlags === 2) {
    hydrateText(children, parentDOM, dom);
    return children.dom;
  }
  hydrateChildren(vNode, parentDOM, dom, context2, isSVG, lifecycle);
  return findLastDOMFromVNode(children[children.length - 1]);
}
function hydrateVNode(vNode, parentDOM, currentDom, context2, isSVG, lifecycle) {
  const flags = vNode.flags |= 16384;
  if (flags & 14) {
    return hydrateComponent(vNode, parentDOM, currentDom, context2, isSVG, (flags & 4) > 0, lifecycle);
  }
  if (flags & 481) {
    return hydrateElement(vNode, parentDOM, currentDom, context2, isSVG, lifecycle);
  }
  if (flags & 16) {
    return hydrateText(vNode, parentDOM, currentDom);
  }
  if (flags & 512) {
    return vNode.dom = currentDom;
  }
  if (flags & 8192) {
    return hydrateFragment(vNode, parentDOM, currentDom, context2, isSVG, lifecycle);
  }
  throwError();
  return null;
}
function hydrate(input, parentDOM, callback) {
  let dom = parentDOM.firstChild;
  if (isNull2(dom)) {
    render(input, parentDOM, callback);
  } else {
    const lifecycle = [];
    if (!isInvalid2(input)) {
      dom = hydrateVNode(input, parentDOM, dom, {}, false, lifecycle);
    }
    while (dom && (dom = dom.nextSibling)) {
      parentDOM.removeChild(dom);
    }
    if (lifecycle.length > 0) {
      let listener;
      while ((listener = lifecycle.shift()) !== void 0) {
        listener();
      }
    }
  }
  parentDOM.$V = input;
  if (isFunction3(callback)) {
    callback();
  }
}

// ../../../../../../node_modules/inferno-create-element/dist/index.esm.js
function isNullOrUndef3(o) {
  return o === void 0 || o === null;
}
function isString3(o) {
  return typeof o === "string";
}
function isUndefined2(o) {
  return o === void 0;
}
var componentHooks = {
  onComponentDidMount: 1,
  onComponentDidUpdate: 1,
  onComponentShouldUpdate: 1,
  onComponentWillMount: 1,
  onComponentWillUnmount: 1,
  onComponentWillUpdate: 1
};
function createElement(type2, props, _children) {
  var arguments$1 = arguments;
  var children;
  var ref = null;
  var key = null;
  var className = null;
  var flags = 0;
  var newProps;
  var childLen = arguments.length - 2;
  if (childLen === 1) {
    children = _children;
  } else if (childLen > 1) {
    children = [];
    while (childLen-- > 0) {
      children[childLen] = arguments$1[childLen + 2];
    }
  }
  if (isString3(type2)) {
    flags = getFlagsForElementVnode(type2);
    if (!isNullOrUndef3(props)) {
      newProps = {};
      for (var prop in props) {
        if (prop === "className" || prop === "class") {
          className = props[prop];
        } else if (prop === "key") {
          key = props.key;
        } else if (prop === "children" && isUndefined2(children)) {
          children = props.children;
        } else if (prop === "ref") {
          ref = props.ref;
        } else {
          if (prop === "contenteditable") {
            flags |= 4096;
          }
          newProps[prop] = props[prop];
        }
      }
    }
  } else {
    flags = 2;
    if (!isUndefined2(children)) {
      if (!props) {
        props = {};
      }
      props.children = children;
    }
    if (!isNullOrUndef3(props)) {
      newProps = {};
      for (var prop$1 in props) {
        if (prop$1 === "key") {
          key = props.key;
        } else if (prop$1 === "ref") {
          ref = props.ref;
        } else if (componentHooks[prop$1] === 1) {
          if (!ref) {
            ref = {};
          }
          ref[prop$1] = props[prop$1];
        } else {
          newProps[prop$1] = props[prop$1];
        }
      }
    }
    return createComponentVNode(flags, type2, newProps, key, ref);
  }
  if (flags & 8192) {
    return createFragment(childLen === 1 ? [children] : children, 0, key);
  }
  return createVNode(flags, type2, className, children, 0, newProps, key, ref);
}

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/render_template.js
var getContainer = (props) => {
  var _a, _b;
  return ((_a = props.container) === null || _a === void 0 ? void 0 : _a.get(0)) || ((_b = props.item) === null || _b === void 0 ? void 0 : _b.get(0));
};
function renderTemplate(template, props, _component) {
  setTimeout(() => {
    render(createElement(template, props), getContainer(props));
  }, 0);
}
var hasTemplate = (name2, properties, _component) => {
  const value2 = properties[name2];
  return !!value2 && typeof value2 !== "string";
};

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/normalize_styles.js
var NUMBER_STYLES = /* @__PURE__ */ new Set([
  "animationIterationCount",
  "borderImageOutset",
  "borderImageSlice",
  "border-imageWidth",
  "boxFlex",
  "boxFlexGroup",
  "boxOrdinalGroup",
  "columnCount",
  "fillOpacity",
  "flex",
  "flexGrow",
  "flexNegative",
  "flexOrder",
  "flexPositive",
  "flexShrink",
  "floodOpacity",
  "fontWeight",
  "gridColumn",
  "gridRow",
  "lineClamp",
  "lineHeight",
  "opacity",
  "order",
  "orphans",
  "stopOpacity",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "tabSize",
  "widows",
  "zIndex",
  "zoom"
]);
var isNumeric2 = (value2) => {
  if (typeof value2 === "number")
    return true;
  return !Number.isNaN(Number(value2));
};
var getNumberStyleValue = (style, value2) => NUMBER_STYLES.has(style) ? value2 : `${value2}px`;
var uppercasePattern = /[A-Z]/g;
var kebabCase = (str) => str.replace(uppercasePattern, "-$&").toLowerCase();
function normalizeStyles(styles) {
  if (!(styles instanceof Object)) {
    return void 0;
  }
  return Object.entries(styles).reduce((acc, [key, value2]) => {
    acc[kebabCase(key)] = isNumeric2(value2) ? getNumberStyleValue(key, value2) : value2;
    return acc;
  }, {});
}

// ../../../../../../node_modules/devextreme/esm/core/inferno_renderer.js
var remove3 = (element) => {
  const {
    parentNode
  } = element;
  if (parentNode) {
    const nextSibling = element.nextSibling;
    cleanDataRecursive(element);
    parentNode.$V = element.$V;
    render(null, parentNode);
    parentNode.insertBefore(element, nextSibling);
    element.innerHTML = "";
    delete parentNode.$V;
  }
  delete element.$V;
};
var inferno_renderer_default = dependency_injector_default({
  createElement: (component, props) => createElement(component, props),
  remove: remove3,
  onAfterRender: () => {
    InfernoEffectHost.callEffects();
  },
  onPreRender: () => {
    InfernoEffectHost.lock();
  },
  render: (component, props, container, replace) => {
    if (!replace) {
      const {
        parentNode
      } = container;
      const nextNode = null === container || void 0 === container ? void 0 : container.nextSibling;
      const rootNode = dom_adapter_default.createElement("div");
      rootNode.appendChild(container);
      const mountNode = dom_adapter_default.createDocumentFragment().appendChild(rootNode);
      const vNodeAlreadyExists = !!container.$V;
      vNodeAlreadyExists && remove3(container);
      hydrate(createElement(component, props), mountNode);
      container.$V = mountNode.$V;
      if (parentNode) {
        parentNode.insertBefore(container, nextNode);
      }
    } else {
      render(createElement(component, props), container);
    }
  }
});

// ../../../../../../node_modules/devextreme/esm/renovation/utils/shallow_equals.js
var shallowEquals = (firstObject, secondObject) => {
  if (Object.keys(firstObject).length !== Object.keys(secondObject).length) {
    return false;
  }
  return Object.keys(firstObject).every((key) => firstObject[key] === secondObject[key]);
};

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/common/template_wrapper.js
var _excluded2 = ["isEqual"];
function isDxElementWrapper(element) {
  return !!element.toArray;
}
function buildTemplateArgs(model, template) {
  const args = {
    template,
    model: _extends({}, model)
  };
  const _ref = model.data ?? {}, {
    isEqual: isEqual2
  } = _ref, data2 = _objectWithoutPropertiesLoose(_ref, _excluded2);
  if (isEqual2) {
    args.model.data = data2;
    args.isEqual = isEqual2;
  }
  return args;
}
function renderTemplateContent(props, container) {
  const {
    data: data2,
    index: index2
  } = props.model ?? {
    data: {}
  };
  if (data2) {
    Object.keys(data2).forEach((name2) => {
      if (data2[name2] && dom_adapter_default.isNode(data2[name2])) {
        data2[name2] = getPublicElement(renderer_default(data2[name2]));
      }
    });
  }
  const rendered = props.template.render(_extends({
    container,
    transclude: props.transclude
  }, {
    renovated: props.renovated
  }, !props.transclude ? {
    model: data2
  } : {}, !props.transclude && Number.isFinite(index2) ? {
    index: index2
  } : {}));
  if (void 0 === rendered) {
    return [];
  }
  return isDxElementWrapper(rendered) ? rendered.toArray() : [renderer_default(rendered).get(0)];
}
function removeDifferentElements(oldChildren, newChildren) {
  newChildren.forEach((newElement) => {
    const hasOldChild = !!oldChildren.find((oldElement) => newElement === oldElement);
    if (!hasOldChild && newElement.parentNode) {
      renderer_default(newElement).remove();
    }
  });
}
var TemplateWrapper = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.renderTemplate = this.renderTemplate.bind(this);
  }
  renderTemplate() {
    const node = findDOMfromVNode(this.$LI, true);
    if (!(null !== node && void 0 !== node && node.parentNode)) {
      return () => {
      };
    }
    const container = node.parentNode;
    const $container = renderer_default(container);
    const $oldContainerContent = $container.contents().toArray();
    const content = renderTemplateContent(this.props, getPublicElement($container));
    replaceWith(renderer_default(node), renderer_default(content));
    return () => {
      const $actualContainerContent = renderer_default(container).contents().toArray();
      removeDifferentElements($oldContainerContent, $actualContainerContent);
      container.appendChild(node);
    };
  }
  shouldComponentUpdate(nextProps) {
    const {
      model,
      template
    } = this.props;
    const {
      isEqual: isEqual2,
      model: nextModel,
      template: nextTemplate
    } = nextProps;
    const equalityComparer = isEqual2 ?? shallowEquals;
    if (template !== nextTemplate) {
      return true;
    }
    if (!isDefined(model) || !isDefined(nextModel)) {
      return model !== nextModel;
    }
    const {
      data: data2,
      index: index2
    } = model;
    const {
      data: nextData,
      index: nextIndex
    } = nextModel;
    if (index2 !== nextIndex) {
      return true;
    }
    return !equalityComparer(data2, nextData);
  }
  createEffects() {
    return [new InfernoEffect(this.renderTemplate, [this.props.template, this.props.model])];
  }
  updateEffects() {
    this._effects[0].update([this.props.template, this.props.model]);
  }
  componentWillUnmount() {
  }
  render() {
    return null;
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/utils/update_props_immutable.js
function cloneObjectValue(value2) {
  return Array.isArray(value2) ? [...value2] : _extends({}, value2);
}
function cloneObjectProp(value2, prevValue, fullNameParts) {
  const result2 = fullNameParts.length > 0 && prevValue && value2 !== prevValue ? cloneObjectValue(prevValue) : cloneObjectValue(value2);
  const name2 = fullNameParts[0];
  if (fullNameParts.length > 1) {
    result2[name2] = cloneObjectProp(value2[name2], null === prevValue || void 0 === prevValue ? void 0 : prevValue[name2], fullNameParts.slice(1));
  } else if (name2) {
    if (isPlainObject(value2[name2])) {
      result2[name2] = cloneObjectValue(value2[name2]);
    } else {
      result2[name2] = value2[name2];
    }
  }
  return result2;
}
function updatePropsImmutable(props, option, name2, fullName) {
  const currentPropsValue = option[name2];
  const prevPropsValue = props[name2];
  const result2 = props;
  if (isPlainObject(currentPropsValue) || name2 !== fullName && Array.isArray(currentPropsValue)) {
    result2[name2] = cloneObjectProp(currentPropsValue, prevPropsValue, getPathParts(fullName).slice(1));
  } else {
    result2[name2] = currentPropsValue;
  }
}

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/common/component.js
var setDefaultOptionValue = (options2, defaultValueGetter) => (name2) => {
  if (Object.prototype.hasOwnProperty.call(options2, name2) && void 0 === options2[name2]) {
    options2[name2] = defaultValueGetter(name2);
  }
};
var ComponentWrapper = class extends dom_component_default {
  get _propsInfo() {
    return {
      allowNull: [],
      twoWay: [],
      elements: [],
      templates: [],
      props: []
    };
  }
  constructor(element, options2) {
    super(element, options2);
    this._shouldRaiseContentReady = false;
    this.validateKeyDownHandler();
  }
  validateKeyDownHandler() {
    const supportedKeyNames = this.getSupportedKeyNames();
    const hasComponentDefaultKeyHandlers = supportedKeyNames.length > 0;
    const hasComponentKeyDownMethod = "function" === typeof this._viewComponent.prototype.keyDown;
    if (hasComponentDefaultKeyHandlers && !hasComponentKeyDownMethod) {
      throw Error("Component's declaration must have 'keyDown' method.");
    }
  }
  get viewRef() {
    var _this$_viewRef;
    return null === (_this$_viewRef = this._viewRef) || void 0 === _this$_viewRef ? void 0 : _this$_viewRef.current;
  }
  _checkContentReadyOption(fullName) {
    const contentReadyOptions = this._getContentReadyOptions().reduce((options2, name2) => {
      options2[name2] = true;
      return options2;
    }, {});
    this._checkContentReadyOption = (optionName) => !!contentReadyOptions[optionName];
    return this._checkContentReadyOption(fullName);
  }
  _getContentReadyOptions() {
    return ["rtlEnabled"];
  }
  _fireContentReady() {
    this._actionsMap.onContentReady({});
  }
  _getDefaultOptions() {
    const viewDefaultProps = this._getViewComponentDefaultProps();
    return extend(true, super._getDefaultOptions(), viewDefaultProps, this._propsInfo.twoWay.reduce((options2, _ref) => {
      let [name2, defaultName, eventName] = _ref;
      return _extends({}, options2, {
        [name2]: viewDefaultProps[defaultName],
        [eventName]: (value2) => this.option(name2, value2)
      });
    }, {}), this._propsInfo.templates.reduce((options2, name2) => _extends({}, options2, {
      [name2]: null
    }), {}));
  }
  _getUnwrappedOption() {
    const unwrappedProps = {};
    Object.keys(this.option()).forEach((key) => {
      unwrappedProps[key] = this.option(key);
    });
    return unwrappedProps;
  }
  _initializeComponent() {
    var _this$_templateManage;
    super._initializeComponent();
    null === (_this$_templateManage = this._templateManager) || void 0 === _this$_templateManage || _this$_templateManage.addDefaultTemplates(this.getDefaultTemplates());
    const optionProxy = this._getUnwrappedOption();
    this._props = this._optionsWithDefaultTemplates(optionProxy);
    this._propsInfo.templates.forEach((template) => {
      this._componentTemplates[template] = this._createTemplateComponent(this._props[template]);
    });
    Object.keys(this._getActionConfigsFull()).forEach((name2) => this._addAction(name2));
    this._viewRef = createRef();
    this.defaultKeyHandlers = this._createDefaultKeyHandlers();
  }
  _initMarkup() {
    const props = this.getProps();
    this._renderWrapper(props);
  }
  _renderWrapper(props) {
    const containerNode = this.$element()[0];
    if (!this._isNodeReplaced) {
      inferno_renderer_default.onPreRender();
    }
    inferno_renderer_default.render(this._viewComponent, props, containerNode, this._isNodeReplaced);
    if (!this._isNodeReplaced) {
      this._isNodeReplaced = true;
      inferno_renderer_default.onAfterRender();
      this._shouldRaiseContentReady = true;
    }
    if (this._shouldRaiseContentReady) {
      this._fireContentReady();
      this._shouldRaiseContentReady = false;
    }
  }
  _silent(name2, value2) {
    this._options.silent(name2, value2);
  }
  _render() {
  }
  _removeWidget() {
    inferno_renderer_default.remove(this.$element()[0]);
  }
  _dispose() {
    this._removeWidget();
    super._dispose();
  }
  get elementAttr() {
    const element = this.$element()[0];
    if (!this._elementAttr) {
      const {
        attributes
      } = element;
      const attrs = Array.from(attributes).filter((attr) => {
        var _attributes$attr$name;
        return !this._propsInfo.templates.includes(attr.name) && (null === (_attributes$attr$name = attributes[attr.name]) || void 0 === _attributes$attr$name ? void 0 : _attributes$attr$name.specified);
      }).reduce((result2, _ref2) => {
        let {
          name: name2,
          value: value2
        } = _ref2;
        const updatedAttributes = result2;
        const isDomAttr = name2 in element;
        updatedAttributes[name2] = "" === value2 && isDomAttr ? element[name2] : value2;
        return updatedAttributes;
      }, {});
      this._elementAttr = attrs;
      this._storedClasses = element.getAttribute("class") || "";
    }
    const elemStyle = element.style;
    const style = {};
    for (let i = 0; i < elemStyle.length; i += 1) {
      style[elemStyle[i]] = elemStyle.getPropertyValue(elemStyle[i]);
    }
    this._elementAttr.style = style;
    this._elementAttr.class = this._storedClasses;
    return this._elementAttr;
  }
  _getAdditionalActionConfigs() {
    return {
      onContentReady: {
        excludeValidators: ["disabled", "readOnly"]
      }
    };
  }
  _getAdditionalProps() {
    return [];
  }
  _patchOptionValues(options2) {
    const {
      allowNull,
      elements,
      props,
      twoWay
    } = this._propsInfo;
    const viewDefaultProps = this._getViewComponentDefaultProps();
    const defaultWidgetPropsKeys = Object.keys(viewDefaultProps);
    const defaultOptions3 = this._getDefaultOptions();
    const {
      children,
      onKeyboardHandled,
      ref
    } = options2;
    const onKeyDown = onKeyboardHandled ? (_, event_options) => {
      onKeyboardHandled(event_options);
    } : void 0;
    const widgetProps = {
      ref,
      children,
      onKeyDown
    };
    [...props, ...this._getAdditionalProps()].forEach((propName) => {
      if (Object.prototype.hasOwnProperty.call(options2, propName)) {
        widgetProps[propName] = options2[propName];
      }
    });
    allowNull.forEach(setDefaultOptionValue(widgetProps, () => null));
    defaultWidgetPropsKeys.forEach(setDefaultOptionValue(widgetProps, (name2) => defaultOptions3[name2]));
    twoWay.forEach((_ref3) => {
      let [name2, defaultName] = _ref3;
      setDefaultOptionValue(widgetProps, () => defaultOptions3[defaultName])(name2);
    });
    elements.forEach((name2) => {
      if (name2 in widgetProps) {
        const value2 = widgetProps[name2];
        if (isRenderer(value2)) {
          widgetProps[name2] = this._patchElementParam(value2);
        }
      }
    });
    return widgetProps;
  }
  getSupportedKeyNames() {
    return [];
  }
  prepareStyleProp(props) {
    if ("string" === typeof props.style) {
      return _extends({}, props, {
        style: {},
        cssText: props.style
      });
    }
    return props;
  }
  getProps() {
    const {
      elementAttr
    } = this.option();
    const options2 = this._patchOptionValues(_extends({}, this._props, {
      ref: this._viewRef,
      children: this._extractDefaultSlot(),
      aria: this._aria
    }));
    this._propsInfo.templates.forEach((template) => {
      options2[template] = this._componentTemplates[template];
    });
    return this.prepareStyleProp(_extends({}, options2, this.elementAttr, elementAttr, {
      className: [...(this.elementAttr.class ?? "").split(" "), ...((null === elementAttr || void 0 === elementAttr ? void 0 : elementAttr.class) ?? "").split(" ")].filter((c, i, a) => c && a.indexOf(c) === i).join(" ").trim(),
      class: ""
    }, this._actionsMap));
  }
  _getActionConfigs() {
    return {};
  }
  _getActionConfigsFull() {
    return _extends({}, this._getActionConfigs(), this._getAdditionalActionConfigs());
  }
  getDefaultTemplates() {
    const defaultTemplates = Object.values(this._templatesInfo);
    const result2 = {};
    defaultTemplates.forEach((template) => {
      result2[template] = "dx-renovation-template-mock";
    });
    return result2;
  }
  get _templatesInfo() {
    return {};
  }
  _optionsWithDefaultTemplates(options2) {
    const templateOptions = Object.entries(this._templatesInfo).reduce((result2, _ref4) => {
      let [templateName, templateValue] = _ref4;
      return _extends({}, result2, {
        [templateName]: options2[templateName] ?? templateValue
      });
    }, {});
    return _extends({}, options2, templateOptions);
  }
  _init() {
    super._init();
    this.customKeyHandlers = {};
    this._actionsMap = {};
    this._aria = {};
    this._componentTemplates = {};
  }
  _createDefaultKeyHandlers() {
    const result2 = {};
    const keys = this.getSupportedKeyNames();
    keys.forEach((key) => {
      result2[key] = (e) => this.viewRef.keyDown(keyboard_processor_default.createKeyDownOptions(e));
    });
    return result2;
  }
  _addAction(event, actionToAdd) {
    let action = actionToAdd;
    if (!action) {
      const actionByOption = this._createActionByOption(event, this._getActionConfigsFull()[event]);
      action = (actArgs) => {
        Object.keys(actArgs).forEach((name2) => {
          if (isDefined(actArgs[name2]) && dom_adapter_default.isNode(actArgs[name2])) {
            actArgs[name2] = getPublicElement(renderer_default(actArgs[name2]));
          }
        });
        return actionByOption(actArgs);
      };
    }
    this._actionsMap[event] = action;
  }
  _optionChanged(option) {
    const {
      fullName,
      name: name2,
      previousValue,
      value: value2
    } = option;
    updatePropsImmutable(this._props, this.option(), name2, fullName);
    if (this._propsInfo.templates.includes(name2) && value2 !== previousValue) {
      this._componentTemplates[name2] = this._createTemplateComponent(value2);
    }
    if (name2 && this._getActionConfigsFull()[name2]) {
      this._addAction(name2);
    }
    this._shouldRaiseContentReady = this._shouldRaiseContentReady || this._checkContentReadyOption(fullName);
    super._optionChanged(option);
    this._invalidate();
  }
  _extractDefaultSlot() {
    if (this.option("_hasAnonymousTemplateContent")) {
      return inferno_renderer_default.createElement(TemplateWrapper, {
        template: this._getTemplate(this._templateManager.anonymousTemplateName),
        transclude: true,
        renovated: true
      });
    }
    return null;
  }
  _createTemplateComponent(templateOption) {
    if (!templateOption) {
      return;
    }
    const template = this._getTemplate(templateOption);
    if (isString(template) && "dx-renovation-template-mock" === template) {
      return;
    }
    return (model) => inferno_renderer_default.createElement(TemplateWrapper, buildTemplateArgs(model, template));
  }
  _wrapKeyDownHandler(initialHandler) {
    return (options2) => {
      const {
        keyName,
        originalEvent,
        which
      } = options2;
      const keys = this.customKeyHandlers;
      const func = keys[keyName] || keys[which];
      if (void 0 !== func) {
        const handler = func.bind(this);
        const result2 = handler(originalEvent, options2);
        if (!result2) {
          originalEvent.cancel = true;
          return originalEvent;
        }
      }
      return null === initialHandler || void 0 === initialHandler ? void 0 : initialHandler(originalEvent, options2);
    };
  }
  _toPublicElement(element) {
    return getPublicElement(renderer_default(element));
  }
  _patchElementParam(value2) {
    try {
      const result2 = renderer_default(value2);
      const element = null === result2 || void 0 === result2 ? void 0 : result2.get(0);
      return null !== element && void 0 !== element && element.nodeType ? element : value2;
    } catch (error) {
      return value2;
    }
  }
  repaint() {
    this._isNodeReplaced = false;
    this._shouldRaiseContentReady = true;
    this._removeWidget();
    this._refresh();
  }
  _supportedKeys() {
    return _extends({}, this.defaultKeyHandlers, this.customKeyHandlers);
  }
  registerKeyHandler(key, handler) {
    this.customKeyHandlers[key] = handler;
  }
  setAria(name2, value2) {
    this._aria[name2] = value2;
    this._initMarkup();
  }
  _getViewComponentDefaultProps() {
    return this._viewComponent.defaultProps || {};
  }
};
ComponentWrapper.IS_RENOVATED_WIDGET = false;
var component_default = ComponentWrapper;
ComponentWrapper.IS_RENOVATED_WIDGET = true;

// ../../../../../../node_modules/devextreme/esm/core/utils/icon.js
var getImageSourceType = (source) => {
  if (!source || "string" !== typeof source) {
    return false;
  }
  if (/^\s*<svg[^>]*>(.|\r?\n)*?<\/svg>\s*$/i.test(source)) {
    return "svg";
  }
  if (/data:.*base64|\.|[^<\s]\/{1,1}/.test(source)) {
    return "image";
  }
  if (/^[\w-_]+$/.test(source)) {
    return "dxIcon";
  }
  if (/^\s?([\w-_:]\s?)+$/.test(source)) {
    return "fontIcon";
  }
  return false;
};
var getImageContainer = (source) => {
  switch (getImageSourceType(source)) {
    case "image":
      return renderer_default("<img>").attr("src", source).addClass("dx-icon");
    case "fontIcon":
      return renderer_default("<i>").addClass(`dx-icon ${source}`);
    case "dxIcon":
      return renderer_default("<i>").addClass(`dx-icon dx-icon-${source}`);
    case "svg":
      return renderer_default("<i>").addClass("dx-icon dx-svg-icon").append(source);
    default:
      return null;
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/button.js
var ButtonWrapper = class extends component_default {
  get _validationGroupConfig() {
    return validation_engine_default.getGroupConfig(this._findGroup());
  }
  getDefaultTemplateNames() {
    return ["content"];
  }
  getSupportedKeyNames() {
    return ["space", "enter"];
  }
  getProps() {
    const props = super.getProps();
    props.onClick = (_ref) => {
      let {
        event
      } = _ref;
      this._clickAction({
        event,
        validationGroup: this._validationGroupConfig
      });
    };
    const iconType = getImageSourceType(props.icon);
    if ("svg" === iconType) {
      props.iconTemplate = this._createTemplateComponent(() => props.icon);
    }
    return props;
  }
  get _templatesInfo() {
    return {
      template: "content"
    };
  }
  _toggleActiveState(_, value2) {
    const button = this.viewRef;
    value2 ? button.activate() : button.deactivate();
  }
  _getSubmitAction() {
    let needValidate = true;
    let validationStatus = "valid";
    return this._createAction((_ref2) => {
      let {
        event,
        submitInput
      } = _ref2;
      if (needValidate) {
        const validationGroup = this._validationGroupConfig;
        if (void 0 !== validationGroup && "" !== validationGroup) {
          const validationResult = validationGroup.validate();
          validationStatus = validationResult.status;
          if ("pending" === validationResult.status) {
            needValidate = false;
            this.option("disabled", true);
            validationResult.complete.then((_ref3) => {
              let {
                status
              } = _ref3;
              this.option("disabled", false);
              validationStatus = status;
              "valid" === validationStatus && submitInput.click();
              needValidate = true;
            });
          }
        }
      }
      "valid" !== validationStatus && event.preventDefault();
      event.stopPropagation();
    });
  }
  _initializeComponent() {
    super._initializeComponent();
    this._addAction("onSubmit", this._getSubmitAction());
    this._clickAction = this._createClickAction();
  }
  _initMarkup() {
    super._initMarkup();
    const $content = this.$element().find(".dx-button-content").first();
    const $template = $content.children().filter(".dx-template-wrapper");
    const $input = $content.children().filter(".dx-button-submit-input");
    if ($template.length) {
      $template.addClass("dx-button-content");
      $template.append($input);
      $content.replaceWith($template);
    }
  }
  _patchOptionValues(options2) {
    return super._patchOptionValues(_extends({}, options2, {
      templateData: options2._templateData
    }));
  }
  _findGroup() {
    const $element = this.$element();
    const validationGroup = this.option("validationGroup");
    return void 0 !== validationGroup && "" !== validationGroup ? validationGroup : validation_engine_default.findGroup($element, this._modelByElement($element));
  }
  _createClickAction() {
    return this._createActionByOption("onClick", {
      excludeValidators: ["readOnly"]
    });
  }
  _optionChanged(option) {
    if ("onClick" === option.name) {
      this._clickAction = this._createClickAction();
    }
    super._optionChanged(option);
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/utils/combine_classes.js
function combineClasses(classesMap) {
  return Object.keys(classesMap).filter((p2) => classesMap[p2]).join(" ");
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/icon.js
var _excluded3 = ["iconTemplate", "position", "source"];
var viewFunction = (_ref) => {
  let {
    iconClassName,
    props: {
      iconTemplate: IconTemplate,
      source
    },
    sourceType
  } = _ref;
  return createFragment(["dxIcon" === sourceType && createVNode(1, "i", iconClassName), "fontIcon" === sourceType && createVNode(1, "i", iconClassName), "image" === sourceType && createVNode(1, "img", iconClassName, null, 1, {
    alt: "",
    src: source
  }), IconTemplate && createVNode(1, "i", iconClassName, IconTemplate({}), 0)], 0);
};
var IconProps = {
  position: "left",
  source: ""
};
var getTemplate = (TemplateProp) => TemplateProp && (TemplateProp.defaultProps ? (props) => normalizeProps(createComponentVNode(2, TemplateProp, _extends({}, props))) : TemplateProp);
var Icon = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }
  get sourceType() {
    return getImageSourceType(this.props.source);
  }
  get cssClass() {
    return "left" !== this.props.position ? "dx-icon-right" : "";
  }
  get iconClassName() {
    const generalClasses = {
      "dx-icon": true,
      [this.cssClass]: !!this.cssClass
    };
    const {
      source
    } = this.props;
    if ("dxIcon" === this.sourceType) {
      return combineClasses(_extends({}, generalClasses, {
        [`dx-icon-${source}`]: true
      }));
    }
    if ("fontIcon" === this.sourceType) {
      return combineClasses(_extends({}, generalClasses, {
        [String(source)]: !!source
      }));
    }
    if ("image" === this.sourceType) {
      return combineClasses(generalClasses);
    }
    if ("svg" === this.sourceType) {
      return combineClasses(_extends({}, generalClasses, {
        "dx-svg-icon": true
      }));
    }
    return "";
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded3);
    return restProps;
  }
  render() {
    const props = this.props;
    return viewFunction({
      props: _extends({}, props, {
        iconTemplate: getTemplate(props.iconTemplate)
      }),
      sourceType: this.sourceType,
      cssClass: this.cssClass,
      iconClassName: this.iconClassName,
      restAttributes: this.restAttributes
    });
  }
};
Icon.defaultProps = IconProps;

// ../../../../../../node_modules/devextreme/esm/ui/widget/utils.ink_ripple.js
var INKRIPPLE_SHOWING_CLASS = "dx-inkripple-showing";
var INKRIPPLE_HIDING_CLASS = "dx-inkripple-hiding";
var initConfig = function() {
  let config3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  const {
    useHoldAnimation,
    waveSizeCoefficient,
    isCentered,
    wavesNumber
  } = config3;
  return {
    waveSizeCoefficient: waveSizeCoefficient || 2,
    isCentered: isCentered || false,
    wavesNumber: wavesNumber || 1,
    durations: getDurations(useHoldAnimation ?? true)
  };
};
var render3 = function(args) {
  const config3 = initConfig(args);
  return {
    showWave: showWave.bind(this, config3),
    hideWave: hideWave.bind(this, config3)
  };
};
var getInkRipple = function(element) {
  let result2 = element.children(".dx-inkripple");
  if (0 === result2.length) {
    result2 = renderer_default("<div>").addClass("dx-inkripple").appendTo(element);
  }
  return result2;
};
var getWaves = function(element, wavesNumber) {
  const inkRipple = getInkRipple(renderer_default(element));
  const result2 = inkRipple.children(".dx-inkripple-wave").toArray();
  for (let i = result2.length; i < wavesNumber; i++) {
    const $currentWave = renderer_default("<div>").appendTo(inkRipple).addClass("dx-inkripple-wave");
    result2.push($currentWave[0]);
  }
  return renderer_default(result2);
};
var getWaveStyleConfig = function(args, config3) {
  const element = renderer_default(config3.element);
  const elementWidth = getOuterWidth(element);
  const elementHeight = getOuterHeight(element);
  const elementDiagonal = parseInt(Math.sqrt(elementWidth * elementWidth + elementHeight * elementHeight));
  const waveSize = Math.min(4e3, parseInt(elementDiagonal * args.waveSizeCoefficient));
  let left;
  let top;
  if (args.isCentered) {
    left = (elementWidth - waveSize) / 2;
    top = (elementHeight - waveSize) / 2;
  } else {
    const event = config3.event;
    const position3 = element.offset();
    const x = event.pageX - position3.left;
    const y = event.pageY - position3.top;
    left = x - waveSize / 2;
    top = y - waveSize / 2;
  }
  return {
    left,
    top,
    height: waveSize,
    width: waveSize
  };
};
function showWave(args, config3) {
  const $wave = getWaves(config3.element, args.wavesNumber).eq(config3.wave || 0);
  args.hidingTimeout && clearTimeout(args.hidingTimeout);
  hideSelectedWave($wave);
  $wave.css(getWaveStyleConfig(args, config3));
  args.showingTimeout = setTimeout(showingWaveHandler.bind(this, args, $wave), 0);
}
function showingWaveHandler(args, $wave) {
  const durationCss = args.durations.showingScale + "ms";
  $wave.addClass(INKRIPPLE_SHOWING_CLASS).css("transitionDuration", durationCss);
}
function getDurations(useHoldAnimation) {
  return {
    showingScale: useHoldAnimation ? 1e3 : 300,
    hidingScale: 300,
    hidingOpacity: 300
  };
}
function hideSelectedWave($wave) {
  $wave.removeClass(INKRIPPLE_HIDING_CLASS).css("transitionDuration", "");
}
function hideWave(args, config3) {
  args.showingTimeout && clearTimeout(args.showingTimeout);
  const $wave = getWaves(config3.element, config3.wavesNumber).eq(config3.wave || 0);
  const durations = args.durations;
  const durationCss = durations.hidingScale + "ms, " + durations.hidingOpacity + "ms";
  $wave.addClass(INKRIPPLE_HIDING_CLASS).removeClass(INKRIPPLE_SHOWING_CLASS).css("transitionDuration", durationCss);
  const animationDuration = Math.max(durations.hidingScale, durations.hidingOpacity);
  args.hidingTimeout = setTimeout(hideSelectedWave.bind(this, $wave), animationDuration);
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/ink_ripple.js
var _excluded4 = ["config"];
var viewFunction2 = (model) => normalizeProps(createVNode(1, "div", "dx-inkripple", null, 1, _extends({}, model.restAttributes)));
var InkRippleProps = {
  config: Object.freeze({})
};
var InkRipple = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.__getterCache = {};
    this.hideWave = this.hideWave.bind(this);
    this.showWave = this.showWave.bind(this);
  }
  get getConfig() {
    if (void 0 !== this.__getterCache.getConfig) {
      return this.__getterCache.getConfig;
    }
    return this.__getterCache.getConfig = (() => {
      const {
        config: config3
      } = this.props;
      return initConfig(config3);
    })();
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded4);
    return restProps;
  }
  hideWave(opts) {
    hideWave(this.getConfig, opts);
  }
  showWave(opts) {
    showWave(this.getConfig, opts);
  }
  componentWillUpdate(nextProps, nextState, context2) {
    if (this.props.config !== nextProps.config) {
      this.__getterCache.getConfig = void 0;
    }
  }
  render() {
    const props = this.props;
    return viewFunction2({
      props: _extends({}, props),
      getConfig: this.getConfig,
      restAttributes: this.restAttributes
    });
  }
};
InkRipple.defaultProps = InkRippleProps;

// ../../../../../../node_modules/devextreme/esm/events/gesture/emitter.gesture.scroll.js
var abstract3 = class_default.abstract;
var realDevice = devices_default.real();
var Locker = class_default.inherit(function() {
  const NAMESPACED_SCROLL_EVENT = addNamespace2("scroll", "dxScrollEmitter");
  return {
    ctor: function(element) {
      this._element = element;
      this._locked = false;
      this._proxiedScroll = (e) => {
        if (!this._disposed) {
          this._scroll(e);
        }
      };
      events_engine_default.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    },
    _scroll: abstract3,
    check: function(e, callback) {
      if (this._locked) {
        callback();
      }
    },
    dispose: function() {
      this._disposed = true;
      events_engine_default.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    }
  };
}());
var TimeoutLocker = Locker.inherit({
  ctor: function(element, timeout) {
    this.callBase(element);
    this._timeout = timeout;
  },
  _scroll: function() {
    this._prepare();
    this._forget();
  },
  _prepare: function() {
    if (this._timer) {
      this._clearTimer();
    }
    this._locked = true;
  },
  _clearTimer: function() {
    clearTimeout(this._timer);
    this._locked = false;
    this._timer = null;
  },
  _forget: function() {
    const that = this;
    this._timer = setTimeout(function() {
      that._clearTimer();
    }, this._timeout);
  },
  dispose: function() {
    this.callBase();
    this._clearTimer();
  }
});
var WheelLocker = TimeoutLocker.inherit({
  ctor: function(element) {
    this.callBase(element, 400);
    this._lastWheelDirection = null;
  },
  check: function(e, callback) {
    this._checkDirectionChanged(e);
    this.callBase(e, callback);
  },
  _checkDirectionChanged: function(e) {
    if (!isDxMouseWheelEvent(e)) {
      this._lastWheelDirection = null;
      return;
    }
    const direction = e.shiftKey || false;
    const directionChange = null !== this._lastWheelDirection && direction !== this._lastWheelDirection;
    this._lastWheelDirection = direction;
    this._locked = this._locked && !directionChange;
  }
});
var PointerLocker = TimeoutLocker.inherit({
  ctor: function(element) {
    this.callBase(element, 400);
  }
});
!function() {
  const {
    ios: isIos,
    android: isAndroid
  } = realDevice;
  if (!(isIos || isAndroid)) {
    return;
  }
  PointerLocker = Locker.inherit({
    _scroll: function() {
      this._locked = true;
      const that = this;
      cancelAnimationFrame(this._scrollFrame);
      this._scrollFrame = requestAnimationFrame(function() {
        that._locked = false;
      });
    },
    check: function(e, callback) {
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
      const that = this;
      const callBase = this.callBase;
      this._checkFrame = requestAnimationFrame(function() {
        callBase.call(that, e, callback);
        that._locked = false;
      });
    },
    dispose: function() {
      this.callBase();
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
    }
  });
}();
var ScrollEmitter = emitter_gesture_default.inherit(function() {
  const FRAME_DURATION2 = Math.round(1e3 / 60);
  return {
    ctor: function(element) {
      this.callBase.apply(this, arguments);
      this.direction = "both";
      this._pointerLocker = new PointerLocker(element);
      this._wheelLocker = new WheelLocker(element);
    },
    validate: function() {
      return true;
    },
    configure: function(data2) {
      if (data2.scrollTarget) {
        this._pointerLocker.dispose();
        this._wheelLocker.dispose();
        this._pointerLocker = new PointerLocker(data2.scrollTarget);
        this._wheelLocker = new WheelLocker(data2.scrollTarget);
      }
      this.callBase(data2);
    },
    _init: function(e) {
      this._wheelLocker.check(e, (function() {
        if (isDxMouseWheelEvent(e)) {
          this._accept(e);
        }
      }).bind(this));
      this._pointerLocker.check(e, (function() {
        const skipCheck = this.isNative && isMouseEvent(e);
        if (!isDxMouseWheelEvent(e) && !skipCheck) {
          this._accept(e);
        }
      }).bind(this));
      this._fireEvent("dxscrollinit", e);
      this._prevEventData = eventData(e);
    },
    move: function(e) {
      this.callBase.apply(this, arguments);
      e.isScrollingEvent = this.isNative || e.isScrollingEvent;
    },
    _start: function(e) {
      this._savedEventData = eventData(e);
      this._fireEvent("dxscrollstart", e);
      this._prevEventData = eventData(e);
    },
    _move: function(e) {
      const currentEventData = eventData(e);
      this._fireEvent("dxscroll", e, {
        delta: eventDelta(this._prevEventData, currentEventData)
      });
      const delta = eventDelta(this._savedEventData, currentEventData);
      if (delta.time > 200) {
        this._savedEventData = this._prevEventData;
      }
      this._prevEventData = eventData(e);
    },
    _end: function(e) {
      const endEventDelta = eventDelta(this._prevEventData, eventData(e));
      let velocity = {
        x: 0,
        y: 0
      };
      if (!isDxMouseWheelEvent(e) && endEventDelta.time < 100) {
        const delta = eventDelta(this._savedEventData, this._prevEventData);
        const velocityMultiplier = FRAME_DURATION2 / delta.time;
        velocity = {
          x: delta.x * velocityMultiplier,
          y: delta.y * velocityMultiplier
        };
      }
      this._fireEvent("dxscrollend", e, {
        velocity
      });
    },
    _stop: function(e) {
      this._fireEvent("dxscrollstop", e);
    },
    cancel: function(e) {
      this.callBase.apply(this, arguments);
      this._fireEvent("dxscrollcancel", e);
    },
    dispose: function() {
      this.callBase.apply(this, arguments);
      this._pointerLocker.dispose();
      this._wheelLocker.dispose();
    },
    _clearSelection: function() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    },
    _toggleGestureCover: function() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    }
  };
}());
emitter_registrator_default({
  emitter: ScrollEmitter,
  events: ["dxscrollinit", "dxscrollstart", "dxscroll", "dxscrollend", "dxscrollstop", "dxscrollcancel"]
});
var emitter_gesture_scroll_default = {
  init: "dxscrollinit",
  start: "dxscrollstart",
  move: "dxscroll",
  end: "dxscrollend",
  stop: "dxscrollstop",
  cancel: "dxscrollcancel",
  scroll: "scroll"
};

// ../../../../../../node_modules/devextreme/esm/renovation/utils/subscribe_to_event.js
function subscribeToEvent(eventName) {
  return (element, handler, eventData2, namespace) => {
    const event = namespace ? addNamespace2(eventName, namespace) : eventName;
    if (handler) {
      events_engine_default.on(element, event, eventData2, handler);
      return () => {
        events_engine_default.off(element, event, handler);
      };
    }
    return;
  };
}
var subscribeToClickEvent = subscribeToEvent(CLICK_EVENT_NAME);
var subscribeToScrollEvent = subscribeToEvent(emitter_gesture_scroll_default.scroll);
var subscribeToScrollInitEvent = subscribeToEvent(emitter_gesture_scroll_default.init);
var subscribeToDXScrollStartEvent = subscribeToEvent(emitter_gesture_scroll_default.start);
var subscribeToDXScrollMoveEvent = subscribeToEvent(emitter_gesture_scroll_default.move);
var subscribeToDXScrollEndEvent = subscribeToEvent(emitter_gesture_scroll_default.end);
var subscribeToDXScrollStopEvent = subscribeToEvent(emitter_gesture_scroll_default.stop);
var subscribeToDXScrollCancelEvent = subscribeToEvent(emitter_gesture_scroll_default.cancel);
var subscribeToDXPointerDownEvent = subscribeToEvent(pointer_default.down);
var subscribeToDXPointerUpEvent = subscribeToEvent(pointer_default.up);
var subscribeToDXPointerMoveEvent = subscribeToEvent(pointer_default.move);
var subscribeToMouseEnterEvent = subscribeToEvent("mouseenter");
var subscribeToMouseLeaveEvent = subscribeToEvent("mouseleave");
var subscribeToKeyDownEvent = subscribeToEvent("keydown");
var subscribeToDxActiveEvent = subscribeToEvent("dxactive");
var subscribeToDxInactiveEvent = subscribeToEvent("dxinactive");
var subscribeToDxHoverStartEvent = subscribeToEvent("dxhoverstart");
var subscribeToDxHoverEndEvent = subscribeToEvent("dxhoverend");
var subscribeToDxFocusInEvent = subscribeToEvent("focusin");
var subscribeToDxFocusOutEvent = subscribeToEvent("focusout");

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/base_props.js
var BaseWidgetProps = {
  className: "",
  activeStateEnabled: false,
  disabled: false,
  focusStateEnabled: false,
  hoverStateEnabled: false,
  tabIndex: 0,
  visible: true
};

// ../../../../../../node_modules/devextreme/esm/renovation/common/config_context.js
var ConfigContext = createContext(void 0);

// ../../../../../../node_modules/devextreme/esm/renovation/common/config_provider.js
var _excluded5 = ["children", "rtlEnabled"];
var viewFunction3 = (viewModel) => viewModel.props.children;
var ConfigProviderProps = {};
var ConfigProvider = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.__getterCache = {};
  }
  getChildContext() {
    return _extends({}, this.context, {
      [ConfigContext.id]: this.config || ConfigContext.defaultValue
    });
  }
  get config() {
    if (void 0 !== this.__getterCache.config) {
      return this.__getterCache.config;
    }
    return this.__getterCache.config = (() => ({
      rtlEnabled: this.props.rtlEnabled
    }))();
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded5);
    return restProps;
  }
  componentWillUpdate(nextProps, nextState, context2) {
    if (this.props.rtlEnabled !== nextProps.rtlEnabled) {
      this.__getterCache.config = void 0;
    }
  }
  render() {
    const props = this.props;
    return viewFunction3({
      props: _extends({}, props),
      config: this.config,
      restAttributes: this.restAttributes
    });
  }
};
ConfigProvider.defaultProps = ConfigProviderProps;

// ../../../../../../node_modules/devextreme/esm/renovation/utils/resolve_rtl.js
function resolveRtlEnabled(rtlProp, config3) {
  if (void 0 !== rtlProp) {
    return rtlProp;
  }
  if (void 0 !== (null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled)) {
    return config3.rtlEnabled;
  }
  return config_default().rtlEnabled;
}
function resolveRtlEnabledDefinition(rtlProp, config3) {
  const isPropDefined = isDefined(rtlProp);
  const onlyGlobalDefined = isDefined(config_default().rtlEnabled) && !isPropDefined && !isDefined(null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled);
  return isPropDefined && rtlProp !== (null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled) || onlyGlobalDefined;
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/widget.js
var _excluded6 = ["_feedbackHideTimeout", "_feedbackShowTimeout", "accessKey", "activeStateEnabled", "activeStateUnit", "addWidgetClass", "aria", "children", "className", "classes", "cssText", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "name", "onActive", "onClick", "onDimensionChanged", "onFocusIn", "onFocusOut", "onHoverEnd", "onHoverStart", "onInactive", "onKeyDown", "onRootElementRendered", "onVisibilityChange", "rootElementRef", "rtlEnabled", "tabIndex", "visible", "width"];
var getAria = (args) => Object.keys(args).reduce((r, key) => {
  if (args[key]) {
    return _extends({}, r, {
      ["role" === key || "id" === key ? key : `aria-${key}`]: String(args[key])
    });
  }
  return r;
}, {});
var viewFunction4 = (viewModel) => {
  const widget = normalizeProps(createVNode(1, "div", viewModel.cssClasses, viewModel.props.children, 0, _extends({}, viewModel.attributes, {
    tabIndex: viewModel.tabIndex,
    title: viewModel.props.hint,
    style: normalizeStyles(viewModel.styles)
  }), null, viewModel.widgetElementRef));
  return viewModel.shouldRenderConfigProvider ? createComponentVNode(2, ConfigProvider, {
    rtlEnabled: viewModel.rtlEnabled,
    children: widget
  }) : widget;
};
var WidgetProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(BaseWidgetProps), Object.getOwnPropertyDescriptors({
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  cssText: "",
  aria: Object.freeze({}),
  classes: "",
  name: "",
  addWidgetClass: true
})));
var Widget2 = class extends InfernoWrapperComponent {
  get config() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  constructor(props) {
    super(props);
    this.widgetElementRef = createRef();
    this.state = {
      active: false,
      focused: false,
      hovered: false
    };
    this.setRootElementRef = this.setRootElementRef.bind(this);
    this.activeEffect = this.activeEffect.bind(this);
    this.inactiveEffect = this.inactiveEffect.bind(this);
    this.clickEffect = this.clickEffect.bind(this);
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.activate = this.activate.bind(this);
    this.deactivate = this.deactivate.bind(this);
    this.focusInEffect = this.focusInEffect.bind(this);
    this.focusOutEffect = this.focusOutEffect.bind(this);
    this.hoverStartEffect = this.hoverStartEffect.bind(this);
    this.hoverEndEffect = this.hoverEndEffect.bind(this);
    this.keyboardEffect = this.keyboardEffect.bind(this);
    this.resizeEffect = this.resizeEffect.bind(this);
    this.windowResizeEffect = this.windowResizeEffect.bind(this);
    this.visibilityEffect = this.visibilityEffect.bind(this);
    this.checkDeprecation = this.checkDeprecation.bind(this);
    this.applyCssTextEffect = this.applyCssTextEffect.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.setRootElementRef, []), new InfernoEffect(this.activeEffect, [this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]), new InfernoEffect(this.inactiveEffect, [this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]), new InfernoEffect(this.clickEffect, [this.props.disabled, this.props.name, this.props.onClick]), new InfernoEffect(this.focusInEffect, [this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]), new InfernoEffect(this.focusOutEffect, [this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]), new InfernoEffect(this.hoverStartEffect, [this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]), new InfernoEffect(this.hoverEndEffect, [this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]), new InfernoEffect(this.keyboardEffect, [this.props.focusStateEnabled, this.props.onKeyDown]), new InfernoEffect(this.resizeEffect, [this.props.name, this.props.onDimensionChanged]), new InfernoEffect(this.windowResizeEffect, [this.props.onDimensionChanged]), new InfernoEffect(this.visibilityEffect, [this.props.name, this.props.onVisibilityChange]), new InfernoEffect(this.checkDeprecation, [this.props.height, this.props.width]), new InfernoEffect(this.applyCssTextEffect, [this.props.cssText]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$, _this$_effects$2, _this$_effects$3, _this$_effects$4, _this$_effects$5, _this$_effects$6, _this$_effects$7, _this$_effects$8, _this$_effects$9, _this$_effects$10, _this$_effects$11, _this$_effects$12, _this$_effects$13;
    null === (_this$_effects$ = this._effects[1]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]);
    null === (_this$_effects$2 = this._effects[2]) || void 0 === _this$_effects$2 || _this$_effects$2.update([this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]);
    null === (_this$_effects$3 = this._effects[3]) || void 0 === _this$_effects$3 || _this$_effects$3.update([this.props.disabled, this.props.name, this.props.onClick]);
    null === (_this$_effects$4 = this._effects[4]) || void 0 === _this$_effects$4 || _this$_effects$4.update([this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]);
    null === (_this$_effects$5 = this._effects[5]) || void 0 === _this$_effects$5 || _this$_effects$5.update([this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]);
    null === (_this$_effects$6 = this._effects[6]) || void 0 === _this$_effects$6 || _this$_effects$6.update([this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]);
    null === (_this$_effects$7 = this._effects[7]) || void 0 === _this$_effects$7 || _this$_effects$7.update([this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]);
    null === (_this$_effects$8 = this._effects[8]) || void 0 === _this$_effects$8 || _this$_effects$8.update([this.props.focusStateEnabled, this.props.onKeyDown]);
    null === (_this$_effects$9 = this._effects[9]) || void 0 === _this$_effects$9 || _this$_effects$9.update([this.props.name, this.props.onDimensionChanged]);
    null === (_this$_effects$10 = this._effects[10]) || void 0 === _this$_effects$10 || _this$_effects$10.update([this.props.onDimensionChanged]);
    null === (_this$_effects$11 = this._effects[11]) || void 0 === _this$_effects$11 || _this$_effects$11.update([this.props.name, this.props.onVisibilityChange]);
    null === (_this$_effects$12 = this._effects[12]) || void 0 === _this$_effects$12 || _this$_effects$12.update([this.props.height, this.props.width]);
    null === (_this$_effects$13 = this._effects[13]) || void 0 === _this$_effects$13 || _this$_effects$13.update([this.props.cssText]);
  }
  setRootElementRef() {
    const {
      onRootElementRendered,
      rootElementRef
    } = this.props;
    if (rootElementRef) {
      rootElementRef.current = this.widgetElementRef.current;
    }
    null === onRootElementRendered || void 0 === onRootElementRendered || onRootElementRendered(this.widgetElementRef.current);
  }
  activeEffect() {
    const {
      _feedbackShowTimeout,
      activeStateEnabled,
      activeStateUnit,
      disabled,
      onActive
    } = this.props;
    const selector = activeStateUnit;
    if (activeStateEnabled) {
      if (!disabled) {
        return subscribeToDxActiveEvent(this.widgetElementRef.current, (event) => {
          this.setState((__state_argument) => ({
            active: true
          }));
          null === onActive || void 0 === onActive || onActive(event);
        }, {
          timeout: _feedbackShowTimeout,
          selector
        }, "UIFeedback");
      }
    }
    return;
  }
  inactiveEffect() {
    const {
      _feedbackHideTimeout,
      activeStateEnabled,
      activeStateUnit,
      onInactive
    } = this.props;
    const selector = activeStateUnit;
    if (activeStateEnabled) {
      return subscribeToDxInactiveEvent(this.widgetElementRef.current, (event) => {
        if (this.state.active) {
          this.setState((__state_argument) => ({
            active: false
          }));
          null === onInactive || void 0 === onInactive || onInactive(event);
        }
      }, {
        timeout: _feedbackHideTimeout,
        selector
      }, "UIFeedback");
    }
    return;
  }
  clickEffect() {
    const {
      disabled,
      name: name2,
      onClick
    } = this.props;
    const namespace = name2;
    if (onClick && !disabled) {
      dxClick.on(this.widgetElementRef.current, onClick, {
        namespace
      });
      return () => dxClick.off(this.widgetElementRef.current, {
        namespace
      });
    }
    return;
  }
  focusInEffect() {
    const {
      disabled,
      focusStateEnabled,
      name: name2,
      onFocusIn
    } = this.props;
    const namespace = `${name2}Focus`;
    if (focusStateEnabled) {
      if (!disabled) {
        return subscribeToDxFocusInEvent(this.widgetElementRef.current, (event) => {
          if (!event.isDefaultPrevented()) {
            this.setState((__state_argument) => ({
              focused: true
            }));
            null === onFocusIn || void 0 === onFocusIn || onFocusIn(event);
          }
        }, null, namespace);
      }
    }
    return;
  }
  focusOutEffect() {
    const {
      focusStateEnabled,
      name: name2,
      onFocusOut
    } = this.props;
    const namespace = `${name2}Focus`;
    if (focusStateEnabled) {
      return subscribeToDxFocusOutEvent(this.widgetElementRef.current, (event) => {
        if (!event.isDefaultPrevented() && this.state.focused) {
          this.setState((__state_argument) => ({
            focused: false
          }));
          null === onFocusOut || void 0 === onFocusOut || onFocusOut(event);
        }
      }, null, namespace);
    }
    return;
  }
  hoverStartEffect() {
    const {
      activeStateUnit,
      disabled,
      hoverStateEnabled,
      onHoverStart
    } = this.props;
    const selector = activeStateUnit;
    if (hoverStateEnabled) {
      if (!disabled) {
        return subscribeToDxHoverStartEvent(this.widgetElementRef.current, (event) => {
          !this.state.active && this.setState((__state_argument) => ({
            hovered: true
          }));
          null === onHoverStart || void 0 === onHoverStart || onHoverStart(event);
        }, {
          selector
        }, "UIFeedback");
      }
    }
    return;
  }
  hoverEndEffect() {
    const {
      activeStateUnit,
      hoverStateEnabled,
      onHoverEnd
    } = this.props;
    const selector = activeStateUnit;
    if (hoverStateEnabled) {
      return subscribeToDxHoverEndEvent(this.widgetElementRef.current, (event) => {
        if (this.state.hovered) {
          this.setState((__state_argument) => ({
            hovered: false
          }));
          null === onHoverEnd || void 0 === onHoverEnd || onHoverEnd(event);
        }
      }, {
        selector
      }, "UIFeedback");
    }
    return;
  }
  keyboardEffect() {
    const {
      focusStateEnabled,
      onKeyDown
    } = this.props;
    if (focusStateEnabled && onKeyDown) {
      const id = keyboard.on(this.widgetElementRef.current, this.widgetElementRef.current, (e) => onKeyDown(e));
      return () => keyboard.off(id);
    }
    return;
  }
  resizeEffect() {
    const namespace = `${this.props.name}VisibilityChange`;
    const {
      onDimensionChanged
    } = this.props;
    if (onDimensionChanged) {
      resize.on(this.widgetElementRef.current, onDimensionChanged, {
        namespace
      });
      return () => resize.off(this.widgetElementRef.current, {
        namespace
      });
    }
    return;
  }
  windowResizeEffect() {
    const {
      onDimensionChanged
    } = this.props;
    if (onDimensionChanged) {
      resize_callbacks_default.add(onDimensionChanged);
      return () => {
        resize_callbacks_default.remove(onDimensionChanged);
      };
    }
    return;
  }
  visibilityEffect() {
    const {
      name: name2,
      onVisibilityChange
    } = this.props;
    const namespace = `${name2}VisibilityChange`;
    if (onVisibilityChange) {
      visibility.on(this.widgetElementRef.current, () => onVisibilityChange(true), () => onVisibilityChange(false), {
        namespace
      });
      return () => visibility.off(this.widgetElementRef.current, {
        namespace
      });
    }
    return;
  }
  checkDeprecation() {
    const {
      height,
      width
    } = this.props;
    if (isFunction(width)) {
      errors_default.log("W0017", "width");
    }
    if (isFunction(height)) {
      errors_default.log("W0017", "height");
    }
  }
  applyCssTextEffect() {
    const {
      cssText
    } = this.props;
    if ("" !== cssText) {
      this.widgetElementRef.current.style.cssText = cssText;
    }
  }
  get shouldRenderConfigProvider() {
    const {
      rtlEnabled
    } = this.props;
    return resolveRtlEnabledDefinition(rtlEnabled, this.config);
  }
  get rtlEnabled() {
    const {
      rtlEnabled
    } = this.props;
    return resolveRtlEnabled(rtlEnabled, this.config);
  }
  get attributes() {
    const {
      aria,
      disabled,
      focusStateEnabled,
      visible: visible2
    } = this.props;
    const accessKey = focusStateEnabled && !disabled && this.props.accessKey;
    return _extends({}, extend({}, accessKey && {
      accessKey
    }), getAria(_extends({}, aria, {
      disabled,
      hidden: !visible2
    })), extend({}, this.restAttributes));
  }
  get styles() {
    const {
      height,
      width
    } = this.props;
    const style = this.restAttributes.style || {};
    const computedWidth = normalizeStyleProp("width", isFunction(width) ? width() : width);
    const computedHeight = normalizeStyleProp("height", isFunction(height) ? height() : height);
    return _extends({}, style, {
      height: computedHeight ?? style.height,
      width: computedWidth ?? style.width
    });
  }
  get cssClasses() {
    const {
      activeStateEnabled,
      addWidgetClass,
      className,
      classes,
      disabled,
      focusStateEnabled,
      hoverStateEnabled,
      onVisibilityChange,
      visible: visible2
    } = this.props;
    const isFocusable = !!focusStateEnabled && !disabled;
    const isHoverable = !!hoverStateEnabled && !disabled;
    const canBeActive = !!activeStateEnabled && !disabled;
    const classesMap = {
      "dx-widget": !!addWidgetClass,
      [String(classes)]: !!classes,
      [String(className)]: !!className,
      "dx-state-disabled": !!disabled,
      "dx-state-invisible": !visible2,
      "dx-state-focused": !!this.state.focused && isFocusable,
      "dx-state-active": !!this.state.active && canBeActive,
      "dx-state-hover": !!this.state.hovered && isHoverable && !this.state.active,
      "dx-rtl": !!this.rtlEnabled,
      "dx-visibility-change-handler": !!onVisibilityChange
    };
    return combineClasses(classesMap);
  }
  get tabIndex() {
    const {
      disabled,
      focusStateEnabled,
      tabIndex
    } = this.props;
    const isFocusable = focusStateEnabled && !disabled;
    return isFocusable ? tabIndex : void 0;
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded6);
    return restProps;
  }
  focus() {
    focus.trigger(this.widgetElementRef.current);
  }
  blur() {
    const activeElement = dom_adapter_default.getActiveElement(this.widgetElementRef.current);
    if (this.widgetElementRef.current === activeElement) {
      activeElement.blur();
    }
  }
  activate() {
    this.setState((__state_argument) => ({
      active: true
    }));
  }
  deactivate() {
    this.setState((__state_argument) => ({
      active: false
    }));
  }
  render() {
    const props = this.props;
    return viewFunction4({
      props: _extends({}, props),
      active: this.state.active,
      focused: this.state.focused,
      hovered: this.state.hovered,
      widgetElementRef: this.widgetElementRef,
      config: this.config,
      shouldRenderConfigProvider: this.shouldRenderConfigProvider,
      rtlEnabled: this.rtlEnabled,
      attributes: this.attributes,
      styles: this.styles,
      cssClasses: this.cssClasses,
      tabIndex: this.tabIndex,
      restAttributes: this.restAttributes
    });
  }
};
Widget2.defaultProps = WidgetProps;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/button.js
var _excluded7 = ["accessKey", "activeStateEnabled", "children", "className", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "icon", "iconPosition", "iconTemplate", "onClick", "onKeyDown", "onSubmit", "pressed", "rtlEnabled", "stylingMode", "tabIndex", "template", "templateData", "text", "type", "useInkRipple", "useSubmitBehavior", "visible", "width"];
var stylingModes = ["outlined", "text", "contained"];
var getCssClasses2 = (model) => {
  const {
    icon,
    iconPosition,
    stylingMode,
    text,
    type: type2
  } = model;
  const isValidStylingMode = stylingMode && stylingModes.includes(stylingMode);
  const classesMap = {
    "dx-button": true,
    [`dx-button-mode-${isValidStylingMode ? stylingMode : "contained"}`]: true,
    [`dx-button-${type2 ?? "normal"}`]: true,
    "dx-button-has-text": !!text,
    "dx-button-has-icon": !!icon,
    "dx-button-icon-right": "left" !== iconPosition
  };
  return combineClasses(classesMap);
};
var viewFunction5 = (viewModel) => {
  const {
    children,
    iconPosition,
    iconTemplate: IconTemplate,
    template: ButtonTemplate,
    text
  } = viewModel.props;
  const renderText = !viewModel.props.template && !children && "" !== text;
  const isIconLeft = "left" === iconPosition;
  const iconComponent = !viewModel.props.template && !children && (viewModel.iconSource || viewModel.props.iconTemplate) && createComponentVNode(2, Icon, {
    source: viewModel.iconSource,
    position: iconPosition,
    iconTemplate: IconTemplate
  });
  return normalizeProps(createComponentVNode(2, Widget2, _extends({
    accessKey: viewModel.props.accessKey,
    activeStateEnabled: viewModel.props.activeStateEnabled,
    aria: viewModel.aria,
    className: viewModel.props.className,
    classes: viewModel.cssClasses,
    disabled: viewModel.props.disabled,
    focusStateEnabled: viewModel.props.focusStateEnabled,
    height: viewModel.props.height,
    hint: viewModel.props.hint,
    hoverStateEnabled: viewModel.props.hoverStateEnabled,
    onActive: viewModel.onActive,
    onClick: viewModel.onWidgetClick,
    onInactive: viewModel.onInactive,
    onKeyDown: viewModel.keyDown,
    rtlEnabled: viewModel.props.rtlEnabled,
    tabIndex: viewModel.props.tabIndex,
    visible: viewModel.props.visible,
    width: viewModel.props.width
  }, viewModel.restAttributes, {
    children: createVNode(1, "div", "dx-button-content", [viewModel.props.template && ButtonTemplate({
      data: viewModel.buttonTemplateData
    }), !viewModel.props.template && children, isIconLeft && iconComponent, renderText && createVNode(1, "span", "dx-button-text", text, 0), !isIconLeft && iconComponent, viewModel.props.useSubmitBehavior && createVNode(64, "input", "dx-button-submit-input", null, 1, {
      type: "submit",
      tabIndex: -1
    }, null, viewModel.submitInputRef), viewModel.props.useInkRipple && createComponentVNode(2, InkRipple, {
      config: viewModel.inkRippleConfig
    }, null, viewModel.inkRippleRef)], 0, null, null, viewModel.contentRef)
  }), null, viewModel.widgetRef));
};
var ButtonProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(BaseWidgetProps), Object.getOwnPropertyDescriptors({
  activeStateEnabled: true,
  hoverStateEnabled: true,
  icon: "",
  iconPosition: "left",
  stylingMode: "contained",
  text: "",
  type: "normal",
  useInkRipple: false,
  useSubmitBehavior: false,
  templateData: Object.freeze({})
})));
var defaultOptionRules = createDefaultOptionRules([{
  device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
  options: {
    focusStateEnabled: true
  }
}, {
  device: () => isMaterial(current()),
  options: {
    useInkRipple: true
  }
}]);
var getTemplate2 = (TemplateProp) => TemplateProp && (TemplateProp.defaultProps ? (props) => normalizeProps(createComponentVNode(2, TemplateProp, _extends({}, props))) : TemplateProp);
var Button = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.contentRef = createRef();
    this.inkRippleRef = createRef();
    this.submitInputRef = createRef();
    this.widgetRef = createRef();
    this.__getterCache = {};
    this.focus = this.focus.bind(this);
    this.activate = this.activate.bind(this);
    this.deactivate = this.deactivate.bind(this);
    this.submitEffect = this.submitEffect.bind(this);
    this.onActive = this.onActive.bind(this);
    this.onInactive = this.onInactive.bind(this);
    this.onWidgetClick = this.onWidgetClick.bind(this);
    this.keyDown = this.keyDown.bind(this);
    this.emitClickEvent = this.emitClickEvent.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.submitEffect, [this.props.onSubmit, this.props.useSubmitBehavior]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props.onSubmit, this.props.useSubmitBehavior]);
  }
  submitEffect() {
    const {
      onSubmit,
      useSubmitBehavior
    } = this.props;
    if (useSubmitBehavior && onSubmit) {
      click.on(this.submitInputRef.current, (event) => onSubmit({
        event,
        submitInput: this.submitInputRef.current
      }), {
        namespace: "UIFeedback"
      });
      return () => click.off(this.submitInputRef.current, {
        namespace: "UIFeedback"
      });
    }
    return;
  }
  onActive(event) {
    const {
      useInkRipple
    } = this.props;
    useInkRipple && this.inkRippleRef.current.showWave({
      element: this.contentRef.current,
      event
    });
  }
  onInactive(event) {
    const {
      useInkRipple
    } = this.props;
    useInkRipple && this.inkRippleRef.current.hideWave({
      element: this.contentRef.current,
      event
    });
  }
  onWidgetClick(event) {
    const {
      onClick,
      useSubmitBehavior
    } = this.props;
    null === onClick || void 0 === onClick || onClick({
      event
    });
    useSubmitBehavior && this.submitInputRef.current.click();
  }
  keyDown(e) {
    const {
      onKeyDown
    } = this.props;
    const {
      keyName,
      originalEvent,
      which
    } = e;
    const result2 = null === onKeyDown || void 0 === onKeyDown ? void 0 : onKeyDown(e);
    if (null !== result2 && void 0 !== result2 && result2.cancel) {
      return result2;
    }
    if ("space" === keyName || "space" === which || "enter" === keyName || "enter" === which) {
      originalEvent.preventDefault();
      this.emitClickEvent();
    }
    return;
  }
  emitClickEvent() {
    this.contentRef.current.click();
  }
  get aria() {
    const {
      icon,
      text
    } = this.props;
    let label = text ?? "";
    if (!text && icon) {
      const iconSource = getImageSourceType(icon);
      switch (iconSource) {
        case "image": {
          const notURLRegexp = /^(?!(?:https?:\/\/)|(?:ftp:\/\/)|(?:www\.))[^\s]+$/;
          const isPathToImage = !icon.includes("base64") && notURLRegexp.test(icon);
          label = isPathToImage ? icon.replace(/.+\/([^.]+)\..+$/, "$1") : "";
          break;
        }
        case "dxIcon":
          label = message_default.format(camelize(icon, true)) || icon;
          break;
        case "fontIcon":
          label = icon;
          break;
        case "svg": {
          var _titleRegexp$exec;
          const titleRegexp = /<title>(.*?)<\/title>/;
          const title = (null === (_titleRegexp$exec = titleRegexp.exec(icon)) || void 0 === _titleRegexp$exec ? void 0 : _titleRegexp$exec[1]) ?? "";
          label = title;
          break;
        }
      }
    }
    return _extends({
      role: "button"
    }, label ? {
      label
    } : {});
  }
  get cssClasses() {
    return getCssClasses2(this.props);
  }
  get iconSource() {
    const {
      icon
    } = this.props;
    return icon ?? "";
  }
  get inkRippleConfig() {
    if (void 0 !== this.__getterCache.inkRippleConfig) {
      return this.__getterCache.inkRippleConfig;
    }
    return this.__getterCache.inkRippleConfig = (() => {
      const {
        icon,
        text
      } = this.props;
      return !text && icon ? {
        isCentered: true,
        useHoldAnimation: false,
        waveSizeCoefficient: 1
      } : {};
    })();
  }
  get buttonTemplateData() {
    const {
      icon,
      templateData,
      text
    } = this.props;
    return _extends({
      icon,
      text
    }, templateData);
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded7);
    return restProps;
  }
  focus() {
    this.widgetRef.current.focus();
  }
  activate() {
    this.widgetRef.current.activate();
  }
  deactivate() {
    this.widgetRef.current.deactivate();
  }
  componentWillUpdate(nextProps, nextState, context2) {
    super.componentWillUpdate();
    if (this.props.icon !== nextProps.icon || this.props.text !== nextProps.text) {
      this.__getterCache.inkRippleConfig = void 0;
    }
  }
  render() {
    const props = this.props;
    return viewFunction5({
      props: _extends({}, props, {
        template: getTemplate2(props.template),
        iconTemplate: getTemplate2(props.iconTemplate)
      }),
      contentRef: this.contentRef,
      submitInputRef: this.submitInputRef,
      inkRippleRef: this.inkRippleRef,
      widgetRef: this.widgetRef,
      onActive: this.onActive,
      onInactive: this.onInactive,
      onWidgetClick: this.onWidgetClick,
      keyDown: this.keyDown,
      emitClickEvent: this.emitClickEvent,
      aria: this.aria,
      cssClasses: this.cssClasses,
      iconSource: this.iconSource,
      inkRippleConfig: this.inkRippleConfig,
      buttonTemplateData: this.buttonTemplateData,
      restAttributes: this.restAttributes
    });
  }
};
Button.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(ButtonProps), Object.getOwnPropertyDescriptors(_extends({}, convertRulesToOptions(defaultOptionRules)))));
var __defaultOptionRules = [];
function defaultOptions(rule) {
  __defaultOptionRules.push(rule);
  Button.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(Button.defaultProps), Object.getOwnPropertyDescriptors(convertRulesToOptions(defaultOptionRules)), Object.getOwnPropertyDescriptors(convertRulesToOptions(__defaultOptionRules))));
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/button.j.js
var Button2 = class extends ButtonWrapper {
  getProps() {
    const props = super.getProps();
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    return props;
  }
  focus() {
    var _this$viewRef;
    return null === (_this$viewRef = this.viewRef) || void 0 === _this$viewRef ? void 0 : _this$viewRef.focus(...arguments);
  }
  activate() {
    var _this$viewRef2;
    return null === (_this$viewRef2 = this.viewRef) || void 0 === _this$viewRef2 ? void 0 : _this$viewRef2.activate(...arguments);
  }
  deactivate() {
    var _this$viewRef3;
    return null === (_this$viewRef3 = this.viewRef) || void 0 === _this$viewRef3 ? void 0 : _this$viewRef3.deactivate(...arguments);
  }
  _getActionConfigs() {
    return {
      onClick: {
        excludeValidators: ["readOnly"]
      },
      onSubmit: {}
    };
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: ["onSubmit"],
      templates: ["template", "iconTemplate"],
      props: ["activeStateEnabled", "hoverStateEnabled", "icon", "iconPosition", "onClick", "onSubmit", "pressed", "stylingMode", "template", "iconTemplate", "text", "type", "useInkRipple", "useSubmitBehavior", "templateData", "className", "accessKey", "disabled", "focusStateEnabled", "height", "hint", "onKeyDown", "rtlEnabled", "tabIndex", "visible", "width"]
    };
  }
  get _viewComponent() {
    return Button;
  }
};
component_registrator_default("dxButton", Button2);
Button2.defaultOptions = defaultOptions;

// ../../../../../../node_modules/devextreme/esm/ui/button.js
var button_default = Button2;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_custom.js
var CustomButton = class extends TextEditorButton {
  _attachEvents(instance, $element) {
    const {
      editor
    } = this;
    events_engine_default.on($element, HOVERSTART, () => {
      editor.$element().addClass("dx-custom-button-hovered");
    });
    events_engine_default.on($element, HOVEREND, () => {
      editor.$element().removeClass("dx-custom-button-hovered");
    });
    events_engine_default.on($element, CLICK_EVENT_NAME, (e) => {
      e.stopPropagation();
    });
  }
  _create() {
    const {
      editor
    } = this;
    const $element = renderer_default("<div>");
    this._addToContainer($element);
    const instance = editor._createComponent($element, button_default, extend({}, this.options, {
      ignoreParentReadOnly: true,
      disabled: this._isDisabled(),
      integrationOptions: this._prepareIntegrationOptions(editor)
    }));
    return {
      $element,
      instance
    };
  }
  _prepareIntegrationOptions(editor) {
    return extend({}, editor.option("integrationOptions"), {
      skipTemplates: ["content"]
    });
  }
  update() {
    const isUpdated = super.update();
    if (this.instance) {
      this.instance.option("disabled", this._isDisabled());
    }
    return isUpdated;
  }
  _isVisible() {
    const {
      editor
    } = this;
    return editor.option("visible");
  }
  _isDisabled() {
    const isDefinedByUser = void 0 !== this.options.disabled;
    if (isDefinedByUser) {
      return this.instance ? this.instance.option("disabled") : this.options.disabled;
    }
    return this.editor.option("readOnly");
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_index.js
function checkButtonInfo(buttonInfo) {
  (() => {
    if (!buttonInfo || "object" !== typeof buttonInfo || Array.isArray(buttonInfo)) {
      throw ui_errors_default.Error("E1053");
    }
  })();
  (() => {
    if (!("name" in buttonInfo)) {
      throw ui_errors_default.Error("E1054");
    }
  })();
  (() => {
    const {
      name: name2
    } = buttonInfo;
    if ("string" !== typeof name2) {
      throw ui_errors_default.Error("E1055");
    }
  })();
  (() => {
    const {
      location
    } = buttonInfo;
    if ("location" in buttonInfo && "after" !== location && "before" !== location) {
      buttonInfo.location = "after";
    }
  })();
}
function checkNamesUniqueness(existingNames, newName) {
  if (-1 !== existingNames.indexOf(newName)) {
    throw ui_errors_default.Error("E1055", newName);
  }
  existingNames.push(newName);
}
function isPredefinedButtonName(name2, predefinedButtonsInfo) {
  return !!predefinedButtonsInfo.find((info) => info.name === name2);
}
var TextEditorButtonCollection = class {
  constructor(editor, defaultButtonsInfo) {
    this.buttons = [];
    this.defaultButtonsInfo = defaultButtonsInfo;
    this.editor = editor;
  }
  _compileButtonInfo(buttons) {
    const names = [];
    return buttons.map((button) => {
      const isStringButton = "string" === typeof button;
      if (!isStringButton) {
        checkButtonInfo(button);
      }
      const isDefaultButton = isStringButton || isPredefinedButtonName(button.name, this.defaultButtonsInfo);
      if (isDefaultButton) {
        const defaultButtonInfo = this.defaultButtonsInfo.find((_ref) => {
          let {
            name: name3
          } = _ref;
          return name3 === button || name3 === button.name;
        });
        if (!defaultButtonInfo) {
          throw ui_errors_default.Error("E1056", this.editor.NAME, button);
        }
        checkNamesUniqueness(names, button);
        return defaultButtonInfo;
      }
      const {
        name: name2
      } = button;
      checkNamesUniqueness(names, name2);
      return extend(button, {
        Ctor: CustomButton
      });
    });
  }
  _createButton(buttonsInfo) {
    const {
      Ctor,
      options: options2,
      name: name2
    } = buttonsInfo;
    const button = new Ctor(name2, this.editor, options2);
    this.buttons.push(button);
    return button;
  }
  _renderButtons(buttons, $container, targetLocation) {
    let $buttonsContainer = null;
    const buttonsInfo = buttons ? this._compileButtonInfo(buttons) : this.defaultButtonsInfo;
    buttonsInfo.forEach((buttonsInfo2) => {
      const {
        location = "after"
      } = buttonsInfo2;
      if (location === targetLocation) {
        this._createButton(buttonsInfo2).render((() => {
          $buttonsContainer = $buttonsContainer ?? renderer_default("<div>").addClass("dx-texteditor-buttons-container");
          "before" === targetLocation ? $container.prepend($buttonsContainer) : $container.append($buttonsContainer);
          return $buttonsContainer;
        })());
      }
    });
    return $buttonsContainer;
  }
  clean() {
    this.buttons.forEach((button) => button.dispose());
    this.buttons = [];
  }
  getButton(buttonName) {
    const button = this.buttons.find((_ref2) => {
      let {
        name: name2
      } = _ref2;
      return name2 === buttonName;
    });
    return button && button.instance;
  }
  renderAfterButtons(buttons, $container) {
    return this._renderButtons(buttons, $container, "after");
  }
  renderBeforeButtons(buttons, $container) {
    return this._renderButtons(buttons, $container, "before");
  }
  updateButtons(names) {
    this.buttons.forEach((button) => {
      if (!names || -1 !== names.indexOf(button.name)) {
        button.update();
      }
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.base.js
var EVENTS_LIST = ["KeyDown", "KeyPress", "KeyUp", "Change", "Cut", "Copy", "Paste", "Input"];
var CONTROL_KEYS = ["tab", "enter", "shift", "control", "alt", "escape", "pageUp", "pageDown", "end", "home", "leftArrow", "upArrow", "rightArrow", "downArrow"];
var TextEditorLabelCreator = TextEditorLabel;
function checkButtonsOptionType(buttons) {
  if (isDefined(buttons) && !Array.isArray(buttons)) {
    throw ui_errors_default.Error("E1053");
  }
}
var TextEditorBase = editor_default.inherit({
  ctor(_, options2) {
    if (options2) {
      checkButtonsOptionType(options2.buttons);
    }
    this._buttonCollection = new TextEditorButtonCollection(this, this._getDefaultButtons());
    this._$beforeButtonsContainer = null;
    this._$afterButtonsContainer = null;
    this._labelContainerElement = null;
    this.callBase.apply(this, arguments);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      buttons: void 0,
      value: "",
      spellcheck: false,
      showClearButton: false,
      valueChangeEvent: "change",
      placeholder: "",
      inputAttr: {},
      onFocusIn: null,
      onFocusOut: null,
      onKeyDown: null,
      onKeyUp: null,
      onChange: null,
      onInput: null,
      onCut: null,
      onCopy: null,
      onPaste: null,
      onEnterKey: null,
      mode: "text",
      hoverStateEnabled: true,
      focusStateEnabled: true,
      text: void 0,
      displayValueFormatter: (value2) => isDefined(value2) && false !== value2 ? value2 : "",
      stylingMode: config_default().editorStylingMode || "outlined",
      showValidationMark: true,
      label: "",
      labelMode: "static",
      labelMark: ""
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device() {
        const themeName = current();
        return isMaterial(themeName);
      },
      options: {
        labelMode: "floating",
        stylingMode: config_default().editorStylingMode || "filled"
      }
    }, {
      device() {
        const themeName = current();
        return isFluent(themeName);
      },
      options: {
        labelMode: "outside"
      }
    }]);
  },
  _getDefaultButtons: () => [{
    name: "clear",
    Ctor: ClearButton
  }],
  _isClearButtonVisible() {
    return this.option("showClearButton") && !this.option("readOnly");
  },
  _input() {
    return this.$element().find(".dx-texteditor-input").first();
  },
  _isFocused() {
    return focused(this._input()) || this.callBase();
  },
  _inputWrapper() {
    return this.$element();
  },
  _buttonsContainer() {
    return this._inputWrapper().find(".dx-texteditor-buttons-container").eq(0);
  },
  _isControlKey: (key) => CONTROL_KEYS.includes(key),
  _renderStylingMode() {
    this.callBase();
    this._updateButtonsStyling(this.option("stylingMode"));
  },
  _initMarkup() {
    this.$element().addClass("dx-texteditor");
    this._renderInput();
    this._renderButtonContainers();
    this._renderStylingMode();
    this._renderInputType();
    this._renderPlaceholder();
    this._renderProps();
    this.callBase();
    this._renderValue();
    this._renderLabel();
  },
  _render() {
    this.callBase();
    this._refreshValueChangeEvent();
    this._refreshEvents();
    this._renderEnterKeyAction();
    this._renderEmptinessEvent();
  },
  _renderInput() {
    this._$textEditorContainer = renderer_default("<div>").addClass("dx-texteditor-container").appendTo(this.$element());
    this._$textEditorInputContainer = renderer_default("<div>").addClass("dx-texteditor-input-container").appendTo(this._$textEditorContainer);
    this._$textEditorInputContainer.append(this._createInput());
  },
  _getInputContainer() {
    return this._$textEditorInputContainer;
  },
  _renderPendingIndicator() {
    this.$element().addClass("dx-validation-pending");
    const $inputContainer = this._getInputContainer();
    const $indicatorElement = renderer_default("<div>").addClass("dx-pending-indicator").appendTo($inputContainer);
    this._pendingIndicator = this._createComponent($indicatorElement, load_indicator_default);
  },
  _disposePendingIndicator() {
    if (!this._pendingIndicator) {
      return;
    }
    this._pendingIndicator.dispose();
    this._pendingIndicator.$element().remove();
    this._pendingIndicator = null;
    this.$element().removeClass("dx-validation-pending");
  },
  _renderValidationState() {
    this.callBase();
    const isPending2 = "pending" === this.option("validationStatus");
    if (isPending2) {
      !this._pendingIndicator && this._renderPendingIndicator();
      this._showValidMark = false;
    } else {
      if ("invalid" === this.option("validationStatus")) {
        this._showValidMark = false;
      }
      if (!this._showValidMark && true === this.option("showValidationMark")) {
        this._showValidMark = "valid" === this.option("validationStatus") && !!this._pendingIndicator;
      }
      this._disposePendingIndicator();
    }
    this._toggleValidMark();
  },
  _getButtonsContainer() {
    return this._$textEditorContainer;
  },
  _renderButtonContainers() {
    const buttons = this.option("buttons");
    const $buttonsContainer = this._getButtonsContainer();
    this._$beforeButtonsContainer = this._buttonCollection.renderBeforeButtons(buttons, $buttonsContainer);
    this._$afterButtonsContainer = this._buttonCollection.renderAfterButtons(buttons, $buttonsContainer);
  },
  _cleanButtonContainers() {
    var _this$_$beforeButtons, _this$_$afterButtonsC;
    null === (_this$_$beforeButtons = this._$beforeButtonsContainer) || void 0 === _this$_$beforeButtons || _this$_$beforeButtons.remove();
    null === (_this$_$afterButtonsC = this._$afterButtonsContainer) || void 0 === _this$_$afterButtonsC || _this$_$afterButtonsC.remove();
    this._buttonCollection.clean();
  },
  _clean() {
    this._buttonCollection.clean();
    this._disposePendingIndicator();
    this._unobserveLabelContainerResize();
    this._$beforeButtonsContainer = null;
    this._$afterButtonsContainer = null;
    this._$textEditorContainer = null;
    this.callBase();
  },
  _createInput() {
    const $input = renderer_default("<input>");
    this._applyInputAttributes($input, this.option("inputAttr"));
    return $input;
  },
  _setSubmitElementName(name2) {
    const inputAttrName = this.option("inputAttr.name");
    return this.callBase(name2 || inputAttrName || "");
  },
  _applyInputAttributes($input, customAttributes) {
    const inputAttributes = extend(this._getDefaultAttributes(), customAttributes);
    $input.attr(inputAttributes).addClass("dx-texteditor-input");
    this._setInputMinHeight($input);
  },
  _setInputMinHeight($input) {
    $input.css("minHeight", this.option("height") ? "0" : "");
  },
  _getPlaceholderAttr() {
    const {
      ios: ios2,
      mac: mac2
    } = devices_default.real();
    const {
      placeholder
    } = this.option();
    const value2 = placeholder || (ios2 || mac2 ? " " : null);
    return value2;
  },
  _getDefaultAttributes() {
    const defaultAttributes = {
      autocomplete: "off",
      placeholder: this._getPlaceholderAttr()
    };
    return defaultAttributes;
  },
  _updateButtons(names) {
    this._buttonCollection.updateButtons(names);
  },
  _updateButtonsStyling(editorStylingMode) {
    each(this.option("buttons"), (_, _ref) => {
      let {
        options: options2,
        name: buttonName
      } = _ref;
      if (options2 && !options2.stylingMode && this.option("visible")) {
        const buttonInstance = this.getButton(buttonName);
        buttonInstance.option && buttonInstance.option("stylingMode", "underlined" === editorStylingMode ? "text" : "contained");
      }
    });
  },
  _renderValue() {
    const renderInputPromise = this._renderInputValue();
    return renderInputPromise.promise();
  },
  _renderInputValue(value2) {
    value2 = value2 ?? this.option("value");
    let text = this.option("text");
    const displayValue = this.option("displayValue");
    const displayValueFormatter = this.option("displayValueFormatter");
    if (void 0 !== displayValue && null !== value2) {
      text = displayValueFormatter(displayValue);
    } else if (!isDefined(text)) {
      text = displayValueFormatter(value2);
    }
    this.option("text", text);
    if (this._input().val() !== (isDefined(text) ? text : "")) {
      this._renderDisplayText(text);
    } else {
      this._toggleEmptinessEventHandler();
    }
    return Deferred().resolve();
  },
  _renderDisplayText(text) {
    this._input().val(text);
    this._toggleEmptinessEventHandler();
  },
  _isValueValid() {
    if (this._input().length) {
      const {
        validity
      } = this._input().get(0);
      if (validity) {
        return validity.valid;
      }
    }
    return true;
  },
  _toggleEmptiness(isEmpty2) {
    this.$element().toggleClass("dx-texteditor-empty", isEmpty2);
    this._togglePlaceholder(isEmpty2);
  },
  _togglePlaceholder(isEmpty2) {
    this.$element().find(".dx-placeholder").eq(0).toggleClass("dx-state-invisible", !isEmpty2);
  },
  _renderProps() {
    this._toggleReadOnlyState();
    this._toggleSpellcheckState();
    this._toggleTabIndex();
  },
  _toggleDisabledState(value2) {
    this.callBase.apply(this, arguments);
    const $input = this._input();
    $input.prop("disabled", value2);
  },
  _toggleTabIndex() {
    const $input = this._input();
    const disabled = this.option("disabled");
    const focusStateEnabled = this.option("focusStateEnabled");
    if (disabled || !focusStateEnabled) {
      $input.attr("tabIndex", -1);
    } else {
      $input.removeAttr("tabIndex");
    }
  },
  _toggleReadOnlyState() {
    this._input().prop("readOnly", this._readOnlyPropValue());
    this.callBase();
  },
  _readOnlyPropValue() {
    return this.option("readOnly");
  },
  _toggleSpellcheckState() {
    this._input().prop("spellcheck", this.option("spellcheck"));
  },
  _unobserveLabelContainerResize() {
    if (this._labelContainerElement) {
      resize_observer_default.unobserve(this._labelContainerElement);
      this._labelContainerElement = null;
    }
  },
  _getLabelContainer() {
    return this._input();
  },
  _getLabelContainerWidth() {
    return getWidth(this._getLabelContainer());
  },
  _getLabelBeforeWidth() {
    const buttonsBeforeWidth = this._$beforeButtonsContainer && getWidth(this._$beforeButtonsContainer);
    return buttonsBeforeWidth ?? 0;
  },
  _updateLabelWidth() {
    this._label.updateBeforeWidth(this._getLabelBeforeWidth());
    this._label.updateMaxWidth(this._getLabelContainerWidth());
  },
  _getFieldElement() {
    return this._getLabelContainer();
  },
  _setFieldAria(force) {
    var _this$_label;
    const inputAttr = this.option("inputAttr");
    const ariaLabel = null === inputAttr || void 0 === inputAttr ? void 0 : inputAttr["aria-label"];
    const labelId = null === (_this$_label = this._label) || void 0 === _this$_label ? void 0 : _this$_label.getId();
    const value2 = ariaLabel ? void 0 : labelId;
    if (value2 || force) {
      const aria = {
        labelledby: value2,
        label: ariaLabel
      };
      this.setAria(aria, this._getFieldElement());
    }
  },
  _renderLabel() {
    this._unobserveLabelContainerResize();
    this._labelContainerElement = renderer_default(this._getLabelContainer()).get(0);
    const {
      label,
      labelMode,
      labelMark,
      rtlEnabled
    } = this.option();
    const labelConfig = {
      onClickHandler: () => {
        this.focus();
      },
      onHoverHandler: (e) => {
        e.stopPropagation();
      },
      onActiveHandler: (e) => {
        e.stopPropagation();
      },
      $editor: this.$element(),
      text: label,
      mark: labelMark,
      mode: labelMode,
      rtlEnabled,
      containsButtonsBefore: !!this._$beforeButtonsContainer,
      getContainerWidth: () => this._getLabelContainerWidth(),
      getBeforeWidth: () => this._getLabelBeforeWidth()
    };
    this._label = new TextEditorLabelCreator(labelConfig);
    this._setFieldAria();
    if (this._labelContainerElement) {
      resize_observer_default.observe(this._labelContainerElement, this._updateLabelWidth.bind(this));
    }
  },
  _renderPlaceholder() {
    this._renderPlaceholderMarkup();
    this._attachPlaceholderEvents();
  },
  _renderPlaceholderMarkup() {
    if (this._$placeholder) {
      this._$placeholder.remove();
      this._$placeholder = null;
    }
    const $input = this._input();
    const placeholder = this.option("placeholder");
    const placeholderAttributes = {
      id: placeholder ? `dx-${new guid_default()}` : void 0,
      "data-dx_placeholder": placeholder
    };
    const $placeholder = this._$placeholder = renderer_default("<div>").attr(placeholderAttributes);
    $placeholder.insertAfter($input);
    $placeholder.addClass("dx-placeholder");
  },
  _attachPlaceholderEvents() {
    const startEvent = addNamespace2(pointer_default.up, this.NAME);
    events_engine_default.on(this._$placeholder, startEvent, () => {
      events_engine_default.trigger(this._input(), "focus");
    });
    this._toggleEmptinessEventHandler();
  },
  _placeholder() {
    return this._$placeholder || renderer_default();
  },
  _clearValueHandler(e) {
    const $input = this._input();
    e.stopPropagation();
    this._saveValueChangeEvent(e);
    this._clearValue();
    !this._isFocused() && events_engine_default.trigger($input, "focus");
    events_engine_default.trigger($input, "input");
  },
  _clearValue() {
    this.clear();
  },
  _renderEvents() {
    const $input = this._input();
    each(EVENTS_LIST, (_, event) => {
      if (this.hasActionSubscription(`on${event}`)) {
        const action = this._createActionByOption(`on${event}`, {
          excludeValidators: ["readOnly"]
        });
        events_engine_default.on($input, addNamespace2(event.toLowerCase(), this.NAME), (e) => {
          if (this._disposed) {
            return;
          }
          action({
            event: e
          });
        });
      }
    });
  },
  _refreshEvents() {
    const $input = this._input();
    each(EVENTS_LIST, (_, event) => {
      events_engine_default.off($input, addNamespace2(event.toLowerCase(), this.NAME));
    });
    this._renderEvents();
  },
  _keyPressHandler() {
    this.option("text", this._input().val());
  },
  _keyDownHandler(e) {
    const $input = this._input();
    const isCtrlEnter = e.ctrlKey && "enter" === normalizeKeyName(e);
    const isNewValue = $input.val() !== this.option("value");
    if (isCtrlEnter && isNewValue) {
      events_engine_default.trigger($input, "change");
    }
  },
  _getValueChangeEventOptionName: () => "valueChangeEvent",
  _renderValueChangeEvent() {
    const keyPressEvent = addNamespace2(this._renderValueEventName(), `${this.NAME}TextChange`);
    const valueChangeEvent = addNamespace2(this.option(this._getValueChangeEventOptionName()), `${this.NAME}ValueChange`);
    const keyDownEvent = addNamespace2("keydown", `${this.NAME}TextChange`);
    const $input = this._input();
    events_engine_default.on($input, keyPressEvent, this._keyPressHandler.bind(this));
    events_engine_default.on($input, valueChangeEvent, this._valueChangeEventHandler.bind(this));
    events_engine_default.on($input, keyDownEvent, this._keyDownHandler.bind(this));
  },
  _cleanValueChangeEvent() {
    const valueChangeNamespace = `.${this.NAME}ValueChange`;
    const textChangeNamespace = `.${this.NAME}TextChange`;
    events_engine_default.off(this._input(), valueChangeNamespace);
    events_engine_default.off(this._input(), textChangeNamespace);
  },
  _refreshValueChangeEvent() {
    this._cleanValueChangeEvent();
    this._renderValueChangeEvent();
  },
  _renderValueEventName: () => "input change keypress",
  _focusTarget() {
    return this._input();
  },
  _focusEventTarget() {
    return this.element();
  },
  _isInput(element) {
    return element === this._input().get(0);
  },
  _preventNestedFocusEvent(event) {
    if (event.isDefaultPrevented()) {
      return true;
    }
    let shouldPrevent = this._isNestedTarget(event.relatedTarget);
    if ("focusin" === event.type) {
      shouldPrevent = shouldPrevent && this._isNestedTarget(event.target) && !this._isInput(event.target);
    } else if (!shouldPrevent) {
      this._toggleFocusClass(false, this.$element());
    }
    shouldPrevent && event.preventDefault();
    return shouldPrevent;
  },
  _isNestedTarget(target) {
    return !!this.$element().find(target).length;
  },
  _focusClassTarget() {
    return this.$element();
  },
  _focusInHandler(event) {
    this._preventNestedFocusEvent(event);
    this.callBase.apply(this, arguments);
  },
  _focusOutHandler(event) {
    this._preventNestedFocusEvent(event);
    this.callBase.apply(this, arguments);
  },
  _toggleFocusClass(isFocused, $element) {
    this.callBase(isFocused, this._focusClassTarget($element));
  },
  _hasFocusClass(element) {
    return this.callBase(renderer_default(element || this.$element()));
  },
  _renderEmptinessEvent() {
    const $input = this._input();
    events_engine_default.on($input, "input blur", this._toggleEmptinessEventHandler.bind(this));
  },
  _toggleEmptinessEventHandler() {
    const text = this._input().val();
    const isEmpty2 = ("" === text || null === text) && this._isValueValid();
    this._toggleEmptiness(isEmpty2);
  },
  _valueChangeEventHandler(e, formattedValue) {
    if (this.option("readOnly")) {
      return;
    }
    this._saveValueChangeEvent(e);
    this.option("value", arguments.length > 1 ? formattedValue : this._input().val());
    this._saveValueChangeEvent(void 0);
  },
  _renderEnterKeyAction() {
    this._enterKeyAction = this._createActionByOption("onEnterKey", {
      excludeValidators: ["readOnly"]
    });
    events_engine_default.off(this._input(), "keyup.onEnterKey.dxTextEditor");
    events_engine_default.on(this._input(), "keyup.onEnterKey.dxTextEditor", this._enterKeyHandlerUp.bind(this));
  },
  _enterKeyHandlerUp(e) {
    if (this._disposed) {
      return;
    }
    if ("enter" === normalizeKeyName(e)) {
      this._enterKeyAction({
        event: e
      });
    }
  },
  _updateValue() {
    this._options.silent("text", null);
    this._renderValue();
  },
  _dispose() {
    this._enterKeyAction = void 0;
    this.callBase();
  },
  _getSubmitElement() {
    return this._input();
  },
  _hasActiveElement() {
    return this._input().is(dom_adapter_default.getActiveElement(this._input()[0]));
  },
  _optionChanged(args) {
    const {
      name: name2,
      fullName,
      value: value2
    } = args;
    const eventName = name2.replace("on", "");
    if (EVENTS_LIST.includes(eventName)) {
      this._refreshEvents();
      return;
    }
    switch (name2) {
      case "valueChangeEvent":
        this._refreshValueChangeEvent();
        this._refreshFocusEvent();
        this._refreshEvents();
        break;
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "focusStateEnabled":
        this.callBase(args);
        this._toggleTabIndex();
        break;
      case "spellcheck":
        this._toggleSpellcheckState();
        break;
      case "mode":
        this._renderInputType();
        break;
      case "onEnterKey":
        this._renderEnterKeyAction();
        break;
      case "placeholder":
        this._renderPlaceholder();
        this._setFieldAria(true);
        this._input().attr({
          placeholder: this._getPlaceholderAttr()
        });
        break;
      case "label":
        this._label.updateText(value2);
        this._setFieldAria(true);
        break;
      case "labelMark":
        this._label.updateMark(value2);
        break;
      case "labelMode":
        this._label.updateMode(value2);
        this._setFieldAria();
        break;
      case "width":
        this.callBase(args);
        this._label.updateMaxWidth(this._getLabelContainerWidth());
        break;
      case "readOnly":
      case "disabled":
        this._updateButtons();
        this.callBase(args);
        break;
      case "showClearButton":
        this._updateButtons(["clear"]);
        break;
      case "text":
      case "showValidationMark":
        break;
      case "value":
        this._updateValue();
        this.callBase(args);
        break;
      case "inputAttr":
        this._applyInputAttributes(this._input(), this.option(name2));
        break;
      case "stylingMode":
        this._renderStylingMode();
        this._updateLabelWidth();
        break;
      case "buttons":
        if (fullName === name2) {
          checkButtonsOptionType(value2);
        }
        this._cleanButtonContainers();
        this._renderButtonContainers();
        this._updateButtonsStyling(this.option("stylingMode"));
        this._updateLabelWidth();
        this._label.updateContainsButtonsBefore(!!this._$beforeButtonsContainer);
        break;
      case "visible":
        this.callBase(args);
        if (value2 && this.option("buttons")) {
          this._cleanButtonContainers();
          this._renderButtonContainers();
          this._updateButtonsStyling(this.option("stylingMode"));
        }
        break;
      case "displayValueFormatter":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  },
  _renderInputType() {
    this._setInputType(this.option("mode"));
  },
  _setInputType(type2) {
    const input = this._input();
    if ("search" === type2) {
      type2 = "text";
    }
    try {
      input.prop("type", type2);
    } catch (e) {
      input.prop("type", "text");
    }
  },
  getButton(name2) {
    return this._buttonCollection.getButton(name2);
  },
  focus() {
    events_engine_default.trigger(this._input(), "focus");
  },
  clear() {
    if (this._showValidMark) {
      this._showValidMark = false;
      this._renderValidationState();
    }
    const defaultOptions3 = this._getDefaultOptions();
    if (this.option("value") === defaultOptions3.value) {
      this._options.silent("text", "");
      this._renderValue();
    } else {
      this.option("value", defaultOptions3.value);
    }
  },
  _resetToInitialValue() {
    if (this.option("value") === this._initialValue) {
      this._options.silent("text", this._initialValue);
      this._renderValue();
    } else {
      this.callBase();
    }
    this._disposePendingIndicator();
    this._showValidMark = false;
    this._toggleValidMark();
  },
  _toggleValidMark() {
    this.$element().toggleClass("dx-valid", !!this._showValidMark);
  },
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      this.callBase(value2);
    } else {
      this.callBase();
    }
  },
  on(eventName, eventHandler) {
    const result2 = this.callBase(eventName, eventHandler);
    const event = eventName.charAt(0).toUpperCase() + eventName.substr(1);
    if (EVENTS_LIST.includes(event)) {
      this._refreshEvents();
    }
    return result2;
  }
});
var m_text_editor_base_default = TextEditorBase;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.rule.js
var BaseMaskRule = class {
  constructor(config3) {
    this._value = " ";
    extend(this, config3);
  }
  next(rule) {
    if (!arguments.length) {
      return this._next;
    }
    this._next = rule;
  }
  _prepareHandlingArgs(args, config3) {
    config3 = config3 || {};
    const handlingProperty = Object.prototype.hasOwnProperty.call(args, "value") ? "value" : "text";
    args[handlingProperty] = config3.str ?? args[handlingProperty];
    args.start = config3.start ?? args.start;
    args.length = config3.length ?? args.length;
    args.index += 1;
    return args;
  }
  first(index2) {
    index2 = index2 || 0;
    return this.next().first(index2 + 1);
  }
  isAccepted(caret3) {
    return false;
  }
  adjustedCaret(caret3, isForwardDirection, char) {
    return isForwardDirection ? this._adjustedForward(caret3, 0, char) : this._adjustedBackward(caret3, 0, char);
  }
  _adjustedForward(caret3, index2, char) {
  }
  _adjustedBackward(caret3, index2, char) {
  }
  isValid(args) {
  }
  reset() {
  }
  clear(args) {
  }
  text() {
  }
  value() {
  }
  rawValue() {
  }
  handle(args) {
  }
};
var EmptyMaskRule = class extends BaseMaskRule {
  next() {
  }
  handle() {
    return 0;
  }
  text() {
    return "";
  }
  value() {
    return "";
  }
  first() {
    return 0;
  }
  rawValue() {
    return "";
  }
  adjustedCaret() {
    return 0;
  }
  isValid() {
    return true;
  }
};
var MaskRule = class extends BaseMaskRule {
  text() {
    return (" " !== this._value ? this._value : this.maskChar) + this.next().text();
  }
  value() {
    return this._value + this.next().value();
  }
  rawValue() {
    return this._value + this.next().rawValue();
  }
  handle(args) {
    const str = Object.prototype.hasOwnProperty.call(args, "value") ? args.value : args.text;
    if (!str || !str.length || !args.length) {
      return 0;
    }
    if (args.start) {
      return this.next().handle(this._prepareHandlingArgs(args, {
        start: args.start - 1
      }));
    }
    const char = str[0];
    const rest = str.substring(1);
    this._tryAcceptChar(char, args);
    return this._accepted() ? this.next().handle(this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    })) + 1 : this.handle(this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    }));
  }
  clear(args) {
    this._tryAcceptChar(" ", args);
    this.next().clear(this._prepareHandlingArgs(args));
  }
  reset() {
    this._accepted(false);
    this.next().reset();
  }
  _tryAcceptChar(char, args) {
    this._accepted(false);
    if (!this._isAllowed(char, args)) {
      return;
    }
    const acceptedChar = " " === char ? this.maskChar : char;
    args.fullText = args.fullText.substring(0, args.index) + acceptedChar + args.fullText.substring(args.index + 1);
    this._accepted(true);
    this._value = char;
  }
  _accepted(value2) {
    if (!arguments.length) {
      return !!this._isAccepted;
    }
    this._isAccepted = !!value2;
  }
  first(index2) {
    return " " === this._value ? index2 || 0 : super.first(index2);
  }
  _isAllowed(char, args) {
    if (" " === char) {
      return true;
    }
    return this._isValid(char, args);
  }
  _isValid(char, args) {
    const {
      allowedChars
    } = this;
    if (allowedChars instanceof RegExp) {
      return allowedChars.test(char);
    }
    if (isFunction(allowedChars)) {
      return allowedChars(char, args.index, args.fullText);
    }
    if (Array.isArray(allowedChars)) {
      return allowedChars.includes(char);
    }
    return allowedChars === char;
  }
  isAccepted(caret3) {
    return 0 === caret3 ? this._accepted() : this.next().isAccepted(caret3 - 1);
  }
  _adjustedForward(caret3, index2, char) {
    if (index2 >= caret3) {
      return index2;
    }
    return this.next()._adjustedForward(caret3, index2 + 1, char) || index2 + 1;
  }
  _adjustedBackward(caret3, index2) {
    if (index2 >= caret3 - 1) {
      return caret3;
    }
    return this.next()._adjustedBackward(caret3, index2 + 1) || index2 + 1;
  }
  isValid(args) {
    return this._isValid(this._value, args) && this.next().isValid(this._prepareHandlingArgs(args));
  }
};
var StubMaskRule = class extends MaskRule {
  value() {
    return this.next().value();
  }
  handle(args) {
    const hasValueProperty = Object.prototype.hasOwnProperty.call(args, "value");
    const str = hasValueProperty ? args.value : args.text;
    if (!str.length || !args.length) {
      return 0;
    }
    if (args.start || hasValueProperty) {
      return this.next().handle(this._prepareHandlingArgs(args, {
        start: args.start && args.start - 1
      }));
    }
    const char = str[0];
    const rest = str.substring(1);
    this._tryAcceptChar(char);
    const nextArgs = this._isAllowed(char) ? this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    }) : args;
    return this.next().handle(nextArgs) + 1;
  }
  clear(args) {
    this._accepted(false);
    this.next().clear(this._prepareHandlingArgs(args));
  }
  _tryAcceptChar(char) {
    this._accepted(this._isValid(char));
  }
  _isValid(char) {
    return char === this.maskChar;
  }
  first(index2) {
    index2 = index2 || 0;
    return this.next().first(index2 + 1);
  }
  _adjustedForward(caret3, index2, char) {
    if (index2 >= caret3 && char === this.maskChar) {
      return index2;
    }
    if (caret3 === index2 + 1 && this._accepted()) {
      return caret3;
    }
    return this.next()._adjustedForward(caret3, index2 + 1, char);
  }
  _adjustedBackward(caret3, index2) {
    if (index2 >= caret3 - 1) {
      return 0;
    }
    return this.next()._adjustedBackward(caret3, index2 + 1);
  }
  isValid(args) {
    return this.next().isValid(this._prepareHandlingArgs(args));
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.strategy.js
var BLUR_EVENT = "blur beforedeactivate";
var DELETE_INPUT_TYPES = ["deleteContentBackward", "deleteSoftLineBackward", "deleteContent", "deleteHardLineBackward"];
var HISTORY_INPUT_TYPES = ["historyUndo", "historyRedo"];
var EVENT_NAMES = ["focusIn", "focusOut", "input", "paste", "cut", "drop", "beforeInput"];
function getEmptyString(length) {
  return " ".repeat(length);
}
var MaskStrategy = class {
  constructor(editor) {
    this.editor = editor;
  }
  _editorOption() {
    return this.editor.option(...arguments);
  }
  _editorInput() {
    return this.editor._input();
  }
  _editorCaret(newCaret) {
    if (!newCaret) {
      return this.editor._caret();
    }
    this.editor._caret(newCaret);
  }
  _attachChangeEventHandler() {
    if (!this._editorOption("valueChangeEvent").split(" ").includes("change")) {
      return;
    }
    const $input = this._editorInput();
    const namespace = addNamespace2(BLUR_EVENT, "dxMask");
    events_engine_default.on($input, namespace, (e) => {
      this.editor._changeHandler(e);
    });
  }
  _beforeInputHandler() {
    this._previousText = this._editorOption("text");
    this._prevCaret = this._editorCaret();
  }
  _inputHandler(event) {
    const {
      originalEvent
    } = event;
    if (!originalEvent) {
      return;
    }
    const {
      inputType: inputType2
    } = originalEvent;
    if (HISTORY_INPUT_TYPES.includes(inputType2)) {
      this._handleHistoryInputEvent();
    } else if (DELETE_INPUT_TYPES.includes(inputType2)) {
      this._handleBackwardDeleteInputEvent();
    } else {
      const currentCaret = this._editorCaret();
      if (!currentCaret.end) {
        return;
      }
      this._clearSelectedText();
      this._autoFillHandler(originalEvent);
      this._editorCaret(currentCaret);
      this._handleInsertTextInputEvent(originalEvent.data);
    }
    if (this._editorOption("text") === this._previousText) {
      event.stopImmediatePropagation();
    }
  }
  _handleHistoryInputEvent() {
    const caret3 = this._editorCaret();
    this._updateEditorMask({
      start: caret3.start,
      length: caret3.end - caret3.start,
      text: ""
    });
    this._editorCaret(this._prevCaret);
  }
  _handleBackwardDeleteInputEvent() {
    this._clearSelectedText();
    const caret3 = this._editorCaret();
    this.editor.setForwardDirection();
    this.editor._adjustCaret();
    const adjustedForwardCaret = this._editorCaret();
    if (adjustedForwardCaret.start !== caret3.start) {
      this.editor.setBackwardDirection();
      this.editor._adjustCaret();
    }
  }
  _clearSelectedText() {
    var _this$_prevCaret, _this$_prevCaret2;
    const length = (null === (_this$_prevCaret = this._prevCaret) || void 0 === _this$_prevCaret ? void 0 : _this$_prevCaret.end) - (null === (_this$_prevCaret2 = this._prevCaret) || void 0 === _this$_prevCaret2 ? void 0 : _this$_prevCaret2.start) || 1;
    const caret3 = this._editorCaret();
    if (!this._isAutoFill()) {
      this.editor.setBackwardDirection();
      this._updateEditorMask({
        start: caret3.start,
        length,
        text: getEmptyString(length)
      });
    }
  }
  _handleInsertTextInputEvent(data2) {
    var _this$_prevCaret3;
    const text = data2 ?? "";
    this.editor.setForwardDirection();
    const hasValidChars = this._updateEditorMask({
      start: (null === (_this$_prevCaret3 = this._prevCaret) || void 0 === _this$_prevCaret3 ? void 0 : _this$_prevCaret3.start) ?? 0,
      length: text.length || 1,
      text
    });
    if (!hasValidChars) {
      this._editorCaret(this._prevCaret);
    }
  }
  _updateEditorMask(args) {
    const textLength = args.text.length;
    const processedCharsCount = this.editor._handleChain(args);
    this.editor._displayMask();
    if (this.editor.isForwardDirection()) {
      const {
        start,
        end
      } = this._editorCaret();
      const correction = processedCharsCount - textLength;
      const hasSkippedStub = processedCharsCount > 1;
      if (hasSkippedStub && 1 === textLength) {
        this._editorCaret({
          start: start + correction,
          end: end + correction
        });
      }
      this.editor._adjustCaret();
    }
    return !!processedCharsCount;
  }
  _focusInHandler() {
    this.editor._showMaskPlaceholder();
    this.editor.setForwardDirection();
    if (!this.editor._isValueEmpty() && this._editorOption("isValid")) {
      this.editor._adjustCaret();
    } else {
      const caret3 = this.editor._maskRulesChain.first();
      this._caretTimeout = setTimeout(() => {
        this._editorCaret({
          start: caret3,
          end: caret3
        });
      }, 0);
    }
  }
  _focusOutHandler(event) {
    this.editor._changeHandler(event);
    if ("onFocus" === this._editorOption("showMaskMode") && this.editor._isValueEmpty()) {
      this._editorOption("text", "");
      this.editor._renderDisplayText("");
    }
  }
  _delHandler(event) {
    const {
      editor
    } = this;
    editor._maskKeyHandler(event, () => {
      if (!editor._hasSelection()) {
        editor._handleKey(" ");
      }
    });
  }
  _cutHandler(event) {
    const caret3 = this._editorCaret();
    const selectedText = this._editorInput().val().substring(caret3.start, caret3.end);
    this.editor._maskKeyHandler(event, () => clipboardText(event, selectedText));
  }
  _dropHandler() {
    this._clearDragTimer();
    this._dragTimer = setTimeout(() => {
      const value2 = this.editor._convertToValue(this._editorInput().val());
      this._editorOption("value", value2);
    });
  }
  _pasteHandler(event) {
    const {
      editor
    } = this;
    if (this._editorOption("disabled")) {
      return;
    }
    const caret3 = this._editorCaret();
    editor._maskKeyHandler(event, () => {
      const pastedText = clipboardText(event);
      const restText = editor._maskRulesChain.text().substring(caret3.end);
      const accepted = editor._handleChain({
        text: pastedText,
        start: caret3.start,
        length: pastedText.length
      });
      const newCaret = caret3.start + accepted;
      editor._handleChain({
        text: restText,
        start: newCaret,
        length: restText.length
      });
      editor._caret({
        start: newCaret,
        end: newCaret
      });
    });
  }
  _autoFillHandler(event) {
    const {
      editor
    } = this;
    const inputVal = this._editorInput().val();
    this._inputHandlerTimer = setTimeout(() => {
      if (this._isAutoFill()) {
        editor._maskKeyHandler(event, () => {
          editor._handleChain({
            text: inputVal,
            start: 0,
            length: inputVal.length
          });
        });
        editor._validateMask();
      }
    });
  }
  _isAutoFill() {
    const $input = this._editorInput();
    if (browser_default.webkit) {
      const input = $input.get(0);
      return (null === input || void 0 === input ? void 0 : input.matches(":-webkit-autofill")) ?? false;
    }
    return false;
  }
  _clearDragTimer() {
    clearTimeout(this._dragTimer);
  }
  _clearTimers() {
    this._clearDragTimer();
    clearTimeout(this._caretTimeout);
    clearTimeout(this._inputHandlerTimer);
  }
  getHandler(handlerName) {
    return (args) => {
      var _this;
      null === (_this = this[`_${handlerName}Handler`]) || void 0 === _this || _this.call(this, args);
    };
  }
  attachEvents() {
    const $input = this._editorInput();
    EVENT_NAMES.forEach((eventName) => {
      const namespace = addNamespace2(eventName.toLowerCase(), "dxMask");
      events_engine_default.on($input, namespace, this.getHandler(eventName));
    });
    this._attachChangeEventHandler();
  }
  detachEvents() {
    this._clearTimers();
    events_engine_default.off(this._editorInput(), ".dxMask");
  }
  clean() {
    this._clearTimers();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_utils.caret.js
var {
  ios,
  mac
} = devices_default.real();
var isFocusingOnCaretChange = ios || mac;
var getCaret = function(input) {
  let range;
  try {
    range = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } catch (e) {
    range = {
      start: 0,
      end: 0
    };
  }
  return range;
};
var setCaret = function(input, position3) {
  const body = dom_adapter_default.getBody();
  if (!body.contains(input) && !body.contains(input.getRootNode().host)) {
    return;
  }
  try {
    input.selectionStart = position3.start;
    input.selectionEnd = position3.end;
  } catch (e) {
  }
};
var caret = function(input, position3) {
  let force = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
  input = renderer_default(input).get(0);
  if (!isDefined(position3)) {
    return getCaret(input);
  }
  if (!force && isFocusingOnCaretChange && dom_adapter_default.getActiveElement(input) !== input) {
    return;
  }
  setCaret(input, position3);
};
var m_utils_caret_default = caret;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.js
var caret2 = m_utils_caret_default;
var buildInMaskRules = {
  0: /[0-9]/,
  9: /[0-9\s]/,
  "#": /[-+0-9\s]/,
  L: (char) => isLiteralChar(char),
  l: (char) => isLiteralChar(char) || isSpaceChar(char),
  C: /\S/,
  c: /./,
  A: (char) => isLiteralChar(char) || isNumericChar(char),
  a: (char) => isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char)
};
function isNumericChar(char) {
  return /[0-9]/.test(char);
}
function isLiteralChar(char) {
  const code = char.charCodeAt();
  return code > 64 && code < 91 || code > 96 && code < 123 || code > 127;
}
function isSpaceChar(char) {
  return " " === char;
}
var TextEditorMask = m_text_editor_base_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      mask: "",
      maskChar: "_",
      maskRules: {},
      maskInvalidMessage: message_default.format("validation-mask"),
      useMaskedValue: false,
      showMaskMode: "always"
    });
  },
  _supportedKeys() {
    const that = this;
    const keyHandlerMap = {
      del: that._maskStrategy.getHandler("del"),
      enter: that._changeHandler
    };
    const result2 = that.callBase();
    each(keyHandlerMap, (key, callback) => {
      const parentHandler = result2[key];
      result2[key] = function(e) {
        that.option("mask") && callback.call(that, e);
        parentHandler && parentHandler(e);
      };
    });
    return result2;
  },
  _getSubmitElement() {
    return !this.option("mask") ? this.callBase() : this._$hiddenElement;
  },
  _init() {
    this.callBase();
    this._initMaskStrategy();
  },
  _initMaskStrategy() {
    this._maskStrategy = new MaskStrategy(this);
  },
  _initMarkup() {
    this._renderHiddenElement();
    this.callBase();
  },
  _attachMouseWheelEventHandlers() {
    const hasMouseWheelHandler = this._onMouseWheel !== noop2;
    if (!hasMouseWheelHandler) {
      return;
    }
    const input = this._input();
    const eventName = addNamespace2(EVENT_NAME, this.NAME);
    const mouseWheelAction = this._createAction((e) => {
      const {
        event
      } = e;
      if (focused(input) && !isCommandKeyPressed(event)) {
        this._onMouseWheel(event);
        event.preventDefault();
        event.stopPropagation();
      }
    });
    events_engine_default.off(input, eventName);
    events_engine_default.on(input, eventName, (e) => {
      mouseWheelAction({
        event: e
      });
    });
  },
  _onMouseWheel: noop2,
  _useMaskBehavior() {
    return Boolean(this.option("mask"));
  },
  _attachDropEventHandler() {
    const useMaskBehavior = this._useMaskBehavior();
    if (!useMaskBehavior) {
      return;
    }
    const eventName = addNamespace2("drop", this.NAME);
    const input = this._input();
    events_engine_default.off(input, eventName);
    events_engine_default.on(input, eventName, (e) => e.preventDefault());
  },
  _render() {
    this._attachMouseWheelEventHandlers();
    this._renderMask();
    this.callBase();
    this._attachDropEventHandler();
  },
  _renderHiddenElement() {
    if (this.option("mask")) {
      this._$hiddenElement = renderer_default("<input>").attr("type", "hidden").appendTo(this._inputWrapper());
    }
  },
  _removeHiddenElement() {
    this._$hiddenElement && this._$hiddenElement.remove();
  },
  _renderMask() {
    this.$element().removeClass("dx-texteditor-masked");
    this._maskRulesChain = null;
    this._maskStrategy.detachEvents();
    if (!this.option("mask")) {
      return;
    }
    this.$element().addClass("dx-texteditor-masked");
    this._maskStrategy.attachEvents();
    this._parseMask();
    this._renderMaskedValue();
  },
  _changeHandler(e) {
    const $input = this._input();
    const inputValue = $input.val();
    if (inputValue === this._changedValue) {
      return;
    }
    this._changedValue = inputValue;
    const changeEvent = createEvent(e, {
      type: "change"
    });
    events_engine_default.trigger($input, changeEvent);
  },
  _parseMask() {
    this._maskRules = extend({}, buildInMaskRules, this.option("maskRules"));
    this._maskRulesChain = this._parseMaskRule(0);
  },
  _parseMaskRule(index2) {
    const mask = this.option("mask");
    if (index2 >= mask.length) {
      return new EmptyMaskRule();
    }
    const currentMaskChar = mask[index2];
    const isEscapedChar = "\\" === currentMaskChar;
    const result2 = isEscapedChar ? new StubMaskRule({
      maskChar: mask[index2 + 1]
    }) : this._getMaskRule(currentMaskChar);
    result2.next(this._parseMaskRule(index2 + 1 + isEscapedChar));
    return result2;
  },
  _getMaskRule(pattern) {
    let ruleConfig;
    each(this._maskRules, (rulePattern, allowedChars) => {
      if (rulePattern === pattern) {
        ruleConfig = {
          pattern: rulePattern,
          allowedChars
        };
        return false;
      }
    });
    return isDefined(ruleConfig) ? new MaskRule(extend({
      maskChar: this.option("maskChar") || " "
    }, ruleConfig)) : new StubMaskRule({
      maskChar: pattern
    });
  },
  _renderMaskedValue() {
    if (!this._maskRulesChain) {
      return;
    }
    const value2 = this.option("value") || "";
    this._maskRulesChain.clear(this._normalizeChainArguments());
    const chainArgs = {
      length: value2.length
    };
    chainArgs[this._isMaskedValueMode() ? "text" : "value"] = value2;
    this._handleChain(chainArgs);
    this._displayMask();
  },
  _replaceSelectedText(text, selection, char) {
    if (void 0 === char) {
      return text;
    }
    const textBefore = text.slice(0, selection.start);
    const textAfter = text.slice(selection.end);
    const edited = textBefore + char + textAfter;
    return edited;
  },
  _isMaskedValueMode() {
    return this.option("useMaskedValue");
  },
  _displayMask(caret3) {
    caret3 = caret3 || this._caret();
    this._renderValue();
    this._caret(caret3);
  },
  _isValueEmpty() {
    return isEmpty(this._value);
  },
  _shouldShowMask() {
    const showMaskMode = this.option("showMaskMode");
    if ("onFocus" === showMaskMode) {
      return focused(this._input()) || !this._isValueEmpty();
    }
    return true;
  },
  _showMaskPlaceholder() {
    if (this._shouldShowMask()) {
      const text = this._maskRulesChain.text();
      this.option("text", text);
      if ("onFocus" === this.option("showMaskMode")) {
        this._renderDisplayText(text);
      }
    }
  },
  _renderValue() {
    if (this._maskRulesChain) {
      this._showMaskPlaceholder();
      if (this._$hiddenElement) {
        const value2 = this._maskRulesChain.value();
        const submitElementValue = !isEmpty(value2) ? this._getPreparedValue() : "";
        this._$hiddenElement.val(submitElementValue);
      }
    }
    return this.callBase();
  },
  _getPreparedValue() {
    return this._convertToValue().replace(/\s+$/, "");
  },
  _valueChangeEventHandler(e) {
    if (!this._maskRulesChain) {
      this.callBase.apply(this, arguments);
      return;
    }
    this._saveValueChangeEvent(e);
    this.option("value", this._getPreparedValue());
  },
  _isControlKeyFired(e) {
    return this._isControlKey(normalizeKeyName(e)) || isCommandKeyPressed(e);
  },
  _handleChain(args) {
    const handledCount = this._maskRulesChain.handle(this._normalizeChainArguments(args));
    this._updateMaskInfo();
    return handledCount;
  },
  _normalizeChainArguments(args) {
    args = args || {};
    args.index = 0;
    args.fullText = this._maskRulesChain.text();
    return args;
  },
  _convertToValue(text) {
    if (this._isMaskedValueMode()) {
      text = this._replaceMaskCharWithEmpty(text || this._textValue || "");
    } else {
      text = text || this._value || "";
    }
    return text;
  },
  _replaceMaskCharWithEmpty(text) {
    return text.replace(new RegExp(this.option("maskChar"), "g"), " ");
  },
  _maskKeyHandler(e, keyHandler) {
    if (this.option("readOnly")) {
      return;
    }
    this.setForwardDirection();
    e.preventDefault();
    this._handleSelection();
    const previousText = this._input().val();
    const raiseInputEvent = () => {
      if (previousText !== this._input().val()) {
        events_engine_default.trigger(this._input(), "input");
      }
    };
    const handled = keyHandler();
    if (handled) {
      handled.then(raiseInputEvent);
    } else {
      this.setForwardDirection();
      this._adjustCaret();
      this._displayMask();
      this._maskRulesChain.reset();
      raiseInputEvent();
    }
  },
  _handleKey(key, direction) {
    this._direction(direction || "forward");
    this._adjustCaret(key);
    this._handleKeyChain(key);
    this._moveCaret();
  },
  _handleSelection() {
    if (!this._hasSelection()) {
      return;
    }
    const caret3 = this._caret();
    const emptyChars = new Array(caret3.end - caret3.start + 1).join(" ");
    this._handleKeyChain(emptyChars);
  },
  _handleKeyChain(chars) {
    const caret3 = this._caret();
    const start = this.isForwardDirection() ? caret3.start : caret3.start - 1;
    const end = this.isForwardDirection() ? caret3.end : caret3.end - 1;
    const length = start === end ? 1 : end - start;
    this._handleChain({
      text: chars,
      start,
      length
    });
  },
  _tryMoveCaretBackward() {
    this.setBackwardDirection();
    const currentCaret = this._caret().start;
    this._adjustCaret();
    return !currentCaret || currentCaret !== this._caret().start;
  },
  _adjustCaret(char) {
    const caretStart = this._caret().start;
    const isForwardDirection = this.isForwardDirection();
    const caret3 = this._maskRulesChain.adjustedCaret(caretStart, isForwardDirection, char);
    this._caret({
      start: caret3,
      end: caret3
    });
  },
  _moveCaret() {
    const currentCaret = this._caret().start;
    const maskRuleIndex = currentCaret + (this.isForwardDirection() ? 0 : -1);
    const caret3 = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this.isForwardDirection() ? 1 : -1) : currentCaret;
    this._caret({
      start: caret3,
      end: caret3
    });
  },
  _caret(position3, force) {
    const $input = this._input();
    if (!$input.length) {
      return;
    }
    if (!arguments.length) {
      return caret2($input);
    }
    caret2($input, position3, force);
  },
  _hasSelection() {
    const caret3 = this._caret();
    return caret3.start !== caret3.end;
  },
  _direction(direction) {
    if (!arguments.length) {
      return this._typingDirection;
    }
    this._typingDirection = direction;
  },
  setForwardDirection() {
    this._direction("forward");
  },
  setBackwardDirection() {
    this._direction("backward");
  },
  isForwardDirection() {
    return "forward" === this._direction();
  },
  _updateMaskInfo() {
    this._textValue = this._maskRulesChain.text();
    this._value = this._maskRulesChain.value();
  },
  _clean() {
    this._maskStrategy && this._maskStrategy.clean();
    this.callBase();
  },
  _validateMask() {
    if (!this._maskRulesChain) {
      return;
    }
    const isValid = isEmpty(this.option("value")) || this._maskRulesChain.isValid(this._normalizeChainArguments());
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: this.option("maskInvalidMessage")
      }
    });
  },
  _updateHiddenElement() {
    this._removeHiddenElement();
    if (this.option("mask")) {
      this._input().removeAttr("name");
      this._renderHiddenElement();
    }
    this._setSubmitElementName(this.option("name"));
  },
  _updateMaskOption() {
    this._updateHiddenElement();
    this._renderMask();
    this._validateMask();
    this._refreshValueChangeEvent();
  },
  _processEmptyMask(mask) {
    if (mask) {
      return;
    }
    const value2 = this.option("value");
    this.option({
      text: value2,
      isValid: true,
      validationError: null
    });
    this.validationRequest.fire({
      value: value2,
      editor: this
    });
    this._renderValue();
  },
  _optionChanged(args) {
    switch (args.name) {
      case "mask":
        this._updateMaskOption();
        this._processEmptyMask(args.value);
        break;
      case "maskChar":
      case "maskRules":
      case "useMaskedValue":
        this._updateMaskOption();
        break;
      case "value":
        this._renderMaskedValue();
        this._validateMask();
        this.callBase(args);
        this._changedValue = this._input().val();
        break;
      case "maskInvalidMessage":
        break;
      case "showMaskMode":
        this.option("text", "");
        this._renderValue();
        break;
      default:
        this.callBase(args);
    }
  },
  clear() {
    const {
      value: defaultValue
    } = this._getDefaultOptions();
    if (this.option("value") === defaultValue) {
      this._renderMaskedValue();
    }
    this.callBase();
  }
});
var m_text_editor_mask_default = TextEditorMask;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.js
component_registrator_default("dxTextEditor", m_text_editor_mask_default);
var m_text_editor_default = m_text_editor_mask_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_box.js
var window15 = getWindow();
var ignoreKeys = ["backspace", "tab", "enter", "pageUp", "pageDown", "end", "home", "leftArrow", "rightArrow", "downArrow", "upArrow", "del"];
var TextBox = m_text_editor_default.inherit({
  ctor(element, options2) {
    if (options2) {
      this._showClearButton = options2.showClearButton;
    }
    this.callBase.apply(this, arguments);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: "",
      mode: "text",
      maxLength: null
    });
  },
  _initMarkup() {
    this.$element().addClass("dx-textbox");
    this.callBase();
    this.setAria("role", "textbox");
  },
  _renderInputType() {
    this.callBase();
    this._renderSearchMode();
  },
  _useTemplates: () => false,
  _renderProps() {
    this.callBase();
    this._toggleMaxLengthProp();
  },
  _toggleMaxLengthProp() {
    const maxLength = this._getMaxLength();
    if (maxLength && maxLength > 0) {
      this._input().attr("maxLength", maxLength);
    } else {
      this._input().removeAttr("maxLength");
    }
  },
  _renderSearchMode() {
    const $element = this._$element;
    if ("search" === this.option("mode")) {
      $element.addClass("dx-searchbox");
      this._renderSearchIcon();
      if (void 0 === this._showClearButton) {
        this._showClearButton = this.option("showClearButton");
        this.option("showClearButton", true);
      }
    } else {
      $element.removeClass("dx-searchbox");
      this._$searchIcon && this._$searchIcon.remove();
      this.option("showClearButton", void 0 === this._showClearButton ? this.option("showClearButton") : this._showClearButton);
      delete this._showClearButton;
    }
  },
  _renderSearchIcon() {
    const $searchIcon = renderer_default("<div>").addClass("dx-icon").addClass("dx-icon-search");
    $searchIcon.prependTo(this._input().parent());
    this._$searchIcon = $searchIcon;
  },
  _getLabelContainerWidth() {
    if (this._$searchIcon) {
      const $inputContainer = this._input().parent();
      return getWidth($inputContainer) - this._getLabelBeforeWidth();
    }
    return this.callBase();
  },
  _getLabelBeforeWidth() {
    let labelBeforeWidth = this.callBase();
    if (this._$searchIcon) {
      labelBeforeWidth += getOuterWidth(this._$searchIcon);
    }
    return labelBeforeWidth;
  },
  _optionChanged(args) {
    switch (args.name) {
      case "maxLength":
        this._toggleMaxLengthProp();
        break;
      case "mode":
        this.callBase(args);
        this._updateLabelWidth();
        break;
      case "mask":
        this.callBase(args);
        this._toggleMaxLengthProp();
        break;
      default:
        this.callBase(args);
    }
  },
  _onKeyDownCutOffHandler(e) {
    const actualMaxLength = this._getMaxLength();
    if (actualMaxLength && !e.ctrlKey && !this._hasSelection()) {
      const $input = renderer_default(e.target);
      const key = normalizeKeyName(e);
      this._cutOffExtraChar($input);
      return $input.val().length < actualMaxLength || ignoreKeys.includes(key) || "" !== window15.getSelection().toString();
    }
    return true;
  },
  _onChangeCutOffHandler(e) {
    const $input = renderer_default(e.target);
    if (this.option("maxLength")) {
      this._cutOffExtraChar($input);
    }
  },
  _cutOffExtraChar($input) {
    const actualMaxLength = this._getMaxLength();
    const textInput = $input.val();
    if (actualMaxLength && textInput.length > actualMaxLength) {
      $input.val(textInput.substr(0, actualMaxLength));
    }
  },
  _getMaxLength() {
    const isMaskSpecified = !!this.option("mask");
    return isMaskSpecified ? null : this.option("maxLength");
  }
});
component_registrator_default("dxTextBox", TextBox);
var m_text_box_default = TextBox;

// ../../../../../../node_modules/devextreme/esm/ui/text_box/text_box.js
var text_box_default = m_text_box_default;

// ../../../../../../node_modules/devextreme/esm/ui/text_box.js
var text_box_default2 = text_box_default;

// ../../../../../../node_modules/devextreme/esm/__internal/events/dblclick.js
var DBLCLICK_EVENT_NAME = "dxdblclick";
var NAMESPACED_CLICK_EVENT = addNamespace2(CLICK_EVENT_NAME, "dxDblClick");
var DblClick = class_default.inherit({
  ctor() {
    this._handlerCount = 0;
    this._forgetLastClick();
  },
  _forgetLastClick() {
    this._firstClickTarget = null;
    this._lastClickTimeStamp = -300;
  },
  add() {
    if (this._handlerCount <= 0) {
      events_engine_default.on(dom_adapter_default.getDocument(), NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this));
    }
    this._handlerCount += 1;
  },
  _clickHandler(e) {
    const timeStamp = e.timeStamp || Date.now();
    const timeBetweenClicks = timeStamp - this._lastClickTimeStamp;
    const isSimulated = timeBetweenClicks < 0;
    const isDouble = !isSimulated && timeBetweenClicks < 300;
    if (isDouble) {
      fireEvent({
        type: "dxdblclick",
        target: closestCommonParent(this._firstClickTarget, e.target),
        originalEvent: e
      });
      this._forgetLastClick();
    } else {
      this._firstClickTarget = e.target;
      this._lastClickTimeStamp = timeStamp;
      clearTimeout(this._lastClickClearTimeout);
      this._lastClickClearTimeout = setTimeout(() => {
        this._forgetLastClick();
      }, 600);
    }
  },
  remove() {
    this._handlerCount -= 1;
    if (this._handlerCount <= 0) {
      this._forgetLastClick();
      events_engine_default.off(dom_adapter_default.getDocument(), NAMESPACED_CLICK_EVENT, void 0);
      clearTimeout(this._lastClickClearTimeout);
      this._handlerCount = 0;
    }
  }
});
var dblClick = new DblClick();

// ../../../../../../node_modules/devextreme/esm/events/double_click.js
event_registrator_default(DBLCLICK_EVENT_NAME, dblClick);

// ../../../../../../node_modules/devextreme/esm/ui/text_box/ui.text_editor.js
var ui_text_editor_default = m_text_editor_default;

// ../../../../../../node_modules/devextreme/esm/events/hold.js
var abs2 = Math.abs;
var HoldEmitter = emitter_default.inherit({
  start: function(e) {
    this._startEventData = eventData(e);
    this._startTimer(e);
  },
  _startTimer: function(e) {
    const holdTimeout = "timeout" in this ? this.timeout : 750;
    this._holdTimer = setTimeout((function() {
      this._requestAccept(e);
      this._fireEvent("dxhold", e, {
        target: e.target
      });
      this._forgetAccept();
    }).bind(this), holdTimeout);
  },
  move: function(e) {
    if (this._touchWasMoved(e)) {
      this._cancel(e);
    }
  },
  _touchWasMoved: function(e) {
    const delta = eventDelta(this._startEventData, eventData(e));
    return abs2(delta.x) > 5 || abs2(delta.y) > 5;
  },
  end: function() {
    this._stopTimer();
  },
  _stopTimer: function() {
    clearTimeout(this._holdTimer);
  },
  cancel: function() {
    this._stopTimer();
  },
  dispose: function() {
    this._stopTimer();
  }
});
emitter_registrator_default({
  emitter: HoldEmitter,
  bubble: true,
  events: ["dxhold"]
});
var hold_default = {
  name: "dxhold"
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.spin.js
var SPIN_CLASS = "dx-numberbox-spin";
var SPIN_BUTTON_CLASS = "dx-numberbox-spin-button";
var NUMBER_BOX = "dxNumberBox";
var POINTERUP_EVENT_NAME = addNamespace2(pointer_default.up, NUMBER_BOX);
var POINTERCANCEL_EVENT_NAME = addNamespace2(pointer_default.cancel, NUMBER_BOX);
var SpinButton = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      direction: "up",
      onChange: null,
      activeStateEnabled: true,
      hoverStateEnabled: true
    });
  },
  _initMarkup() {
    this.callBase();
    const direction = `${SPIN_CLASS}-${this.option("direction")}`;
    this.$element().addClass(SPIN_BUTTON_CLASS).addClass(direction);
    this._spinIcon = renderer_default("<div>").addClass(`${direction}-icon`).appendTo(this.$element());
  },
  _render() {
    this.callBase();
    const eventName = addNamespace2(pointer_default.down, this.NAME);
    const $element = this.$element();
    events_engine_default.off($element, eventName);
    events_engine_default.on($element, eventName, this._spinDownHandler.bind(this));
    this._spinChangeHandler = this._createActionByOption("onChange");
  },
  _spinDownHandler(e) {
    e.preventDefault();
    this._clearTimer();
    events_engine_default.on(this.$element(), hold_default.name, () => {
      this._feedBackDeferred = Deferred();
      lock(this._feedBackDeferred);
      this._spinChangeHandler({
        event: e
      });
      this._holdTimer = setInterval(this._spinChangeHandler, 100, {
        event: e
      });
    });
    const document2 = dom_adapter_default.getDocument();
    events_engine_default.on(document2, POINTERUP_EVENT_NAME, this._clearTimer.bind(this));
    events_engine_default.on(document2, POINTERCANCEL_EVENT_NAME, this._clearTimer.bind(this));
    this._spinChangeHandler({
      event: e
    });
  },
  _dispose() {
    this._clearTimer();
    this.callBase();
  },
  _clearTimer() {
    events_engine_default.off(this.$element(), hold_default.name);
    const document2 = dom_adapter_default.getDocument();
    events_engine_default.off(document2, POINTERUP_EVENT_NAME);
    events_engine_default.off(document2, POINTERCANCEL_EVENT_NAME);
    if (this._feedBackDeferred) {
      this._feedBackDeferred.resolve();
    }
    if (this._holdTimer) {
      clearInterval(this._holdTimer);
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "onChange":
      case "direction":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  }
});
var m_number_box_spin_default = SpinButton;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.spins.js
var SPIN_CLASS2 = "dx-numberbox-spin";
var SPIN_CONTAINER_CLASS = "dx-numberbox-spin-container";
var SPIN_TOUCH_FRIENDLY_CLASS = "dx-numberbox-spin-touch-friendly";
var SpinButtons = class extends TextEditorButton {
  _attachEvents(instance, $spinContainer) {
    const {
      editor
    } = this;
    const eventName = addNamespace2(pointer_default.down, editor.NAME);
    const $spinContainerChildren = $spinContainer.children();
    const pointerDownAction = editor._createAction((e) => editor._spinButtonsPointerDownHandler(e));
    events_engine_default.off($spinContainer, eventName);
    events_engine_default.on($spinContainer, eventName, (e) => pointerDownAction({
      event: e
    }));
    m_number_box_spin_default.getInstance($spinContainerChildren.eq(0)).option("onChange", (e) => editor._spinUpChangeHandler(e));
    m_number_box_spin_default.getInstance($spinContainerChildren.eq(1)).option("onChange", (e) => editor._spinDownChangeHandler(e));
  }
  _create() {
    const {
      editor
    } = this;
    const $spinContainer = renderer_default("<div>").addClass(SPIN_CONTAINER_CLASS);
    const $spinUp = renderer_default("<div>").appendTo($spinContainer);
    const $spinDown = renderer_default("<div>").appendTo($spinContainer);
    const options2 = this._getOptions();
    this._addToContainer($spinContainer);
    editor._createComponent($spinUp, m_number_box_spin_default, extend({
      direction: "up"
    }, options2));
    editor._createComponent($spinDown, m_number_box_spin_default, extend({
      direction: "down"
    }, options2));
    this._legacyRender(editor.$element(), this._isTouchFriendly(), options2.visible);
    return {
      instance: $spinContainer,
      $element: $spinContainer
    };
  }
  _getOptions() {
    const {
      editor
    } = this;
    const visible2 = this._isVisible();
    const disabled = editor.option("disabled");
    return {
      visible: visible2,
      disabled
    };
  }
  _isVisible() {
    const {
      editor
    } = this;
    return super._isVisible() && editor.option("showSpinButtons");
  }
  _isTouchFriendly() {
    const {
      editor
    } = this;
    return editor.option("showSpinButtons") && editor.option("useLargeSpinButtons");
  }
  _legacyRender($editor, isTouchFriendly, isVisible2) {
    $editor.toggleClass(SPIN_TOUCH_FRIENDLY_CLASS, isTouchFriendly);
    $editor.toggleClass(SPIN_CLASS2, isVisible2);
  }
  update() {
    const shouldUpdate = super.update();
    if (shouldUpdate) {
      const {
        editor,
        instance
      } = this;
      const $editor = editor.$element();
      const isVisible2 = this._isVisible();
      const isTouchFriendly = this._isTouchFriendly();
      const $spinButtons = instance.children();
      const spinUp = m_number_box_spin_default.getInstance($spinButtons.eq(0));
      const spinDown = m_number_box_spin_default.getInstance($spinButtons.eq(1));
      const options2 = this._getOptions();
      spinUp.option(options2);
      spinDown.option(options2);
      this._legacyRender($editor, isTouchFriendly, isVisible2);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.base.js
var math = Math;
var WIDGET_CLASS = "dx-numberbox";
var FIREFOX_CONTROL_KEYS = ["tab", "del", "backspace", "leftArrow", "rightArrow", "home", "end", "enter"];
var NumberBoxBase = ui_text_editor_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), {
      upArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          this._spinUpChangeHandler(e);
        }
      },
      downArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          this._spinDownChangeHandler(e);
        }
      },
      enter() {
      }
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: 0,
      min: void 0,
      max: void 0,
      step: 1,
      showSpinButtons: false,
      useLargeSpinButtons: true,
      mode: "text",
      invalidValueMessage: message_default.format("dxNumberBox-invalidValueMessage"),
      buttons: void 0
    });
  },
  _useTemplates: () => false,
  _getDefaultButtons() {
    return this.callBase().concat([{
      name: "spins",
      Ctor: SpinButtons
    }]);
  },
  _isSupportInputMode() {
    const version3 = parseFloat(browser_default.version);
    return browser_default.chrome && version3 >= 66 || browser_default.safari && version3 >= 12;
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => devices_default.real().generic && !devices_default.isSimulator(),
      options: {
        useLargeSpinButtons: false
      }
    }, {
      device: (function() {
        return "desktop" !== devices_default.real().deviceType && !this._isSupportInputMode();
      }).bind(this),
      options: {
        mode: "number"
      }
    }]);
  },
  _initMarkup() {
    this._renderSubmitElement();
    this.$element().addClass(WIDGET_CLASS);
    this.callBase();
  },
  _getDefaultAttributes() {
    const attributes = this.callBase();
    attributes.inputmode = "decimal";
    return attributes;
  },
  _renderContentImpl() {
    this.option("isValid") && this._validateValue(this.option("value"));
    this.setAria("role", "spinbutton");
  },
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    this._setSubmitValue(this.option("value"));
  },
  _setSubmitValue(value2) {
    this._getSubmitElement().val(applyServerDecimalSeparator(value2));
  },
  _getSubmitElement() {
    return this._$submitElement;
  },
  _keyPressHandler(e) {
    this.callBase(e);
    const char = getChar(e);
    const isInputCharValid = /[\d.,eE\-+]/.test(char);
    if (!isInputCharValid) {
      const keyName = normalizeKeyName(e);
      if (isCommandKeyPressed(e) || keyName && FIREFOX_CONTROL_KEYS.includes(keyName)) {
        return;
      }
      e.preventDefault();
      return false;
    }
    this._keyPressed = true;
  },
  _onMouseWheel(dxEvent) {
    dxEvent.delta > 0 ? this._spinValueChange(1, dxEvent) : this._spinValueChange(-1, dxEvent);
  },
  _renderValue() {
    const inputValue = this._input().val();
    const value2 = this.option("value");
    if (!inputValue.length || Number(inputValue) !== value2) {
      this._forceValueRender();
      this._toggleEmptinessEventHandler();
    }
    const valueText = isDefined(value2) ? null : message_default.format("dxNumberBox-noDataText");
    this.setAria({
      valuenow: ensureDefined(value2, ""),
      valuetext: valueText
    });
    this.option("text", this._input().val());
    this._updateButtons();
    return Deferred().resolve();
  },
  _forceValueRender() {
    const value2 = this.option("value");
    const number = Number(value2);
    const formattedValue = isNaN(number) ? "" : this._applyDisplayValueFormatter(value2);
    this._renderDisplayText(formattedValue);
  },
  _applyDisplayValueFormatter(value2) {
    return this.option("displayValueFormatter")(value2);
  },
  _renderProps() {
    this._input().prop({
      min: this.option("min"),
      max: this.option("max"),
      step: this.option("step")
    });
    this.setAria({
      valuemin: ensureDefined(this.option("min"), ""),
      valuemax: ensureDefined(this.option("max"), "")
    });
  },
  _spinButtonsPointerDownHandler() {
    const $input = this._input();
    if (!this.option("useLargeSpinButtons") && dom_adapter_default.getActiveElement() !== $input[0]) {
      events_engine_default.trigger($input, "focus");
    }
  },
  _spinUpChangeHandler(e) {
    if (!this.option("readOnly")) {
      this._spinValueChange(1, e.event || e);
    }
  },
  _spinDownChangeHandler(e) {
    if (!this.option("readOnly")) {
      this._spinValueChange(-1, e.event || e);
    }
  },
  _spinValueChange(sign2, dxEvent) {
    const step = parseFloat(this.option("step"));
    if (0 === step) {
      return;
    }
    let value2 = parseFloat(this._normalizeInputValue()) || 0;
    value2 = this._correctRounding(value2, step * sign2);
    const min = this.option("min");
    const max = this.option("max");
    if (isDefined(min)) {
      value2 = Math.max(min, value2);
    }
    if (isDefined(max)) {
      value2 = Math.min(max, value2);
    }
    this._saveValueChangeEvent(dxEvent);
    this.option("value", value2);
  },
  _correctRounding(value2, step) {
    const regex = /[,.](.*)/;
    const isFloatValue = regex.test(value2);
    const isFloatStep = regex.test(step);
    if (isFloatValue || isFloatStep) {
      const valueAccuracy = isFloatValue ? regex.exec(value2)[0].length : 0;
      const stepAccuracy = isFloatStep ? regex.exec(step)[0].length : 0;
      const accuracy = math.max(valueAccuracy, stepAccuracy);
      value2 = this._round(value2 + step, accuracy);
      return value2;
    }
    return value2 + step;
  },
  _round(value2, precision) {
    precision = precision || 0;
    const multiplier = 10 ** precision;
    value2 *= multiplier;
    value2 = Math.round(value2) / multiplier;
    return value2;
  },
  _renderValueChangeEvent() {
    this.callBase();
    const forceValueChangeEvent = addNamespace2("focusout", "NumberBoxForceValueChange");
    events_engine_default.off(this.element(), forceValueChangeEvent);
    events_engine_default.on(this.element(), forceValueChangeEvent, this._forceRefreshInputValue.bind(this));
  },
  _forceRefreshInputValue() {
    if ("number" === this.option("mode")) {
      return;
    }
    const $input = this._input();
    const formattedValue = this._applyDisplayValueFormatter(this.option("value"));
    $input.val(null);
    $input.val(formattedValue);
  },
  _valueChangeEventHandler(e) {
    const $input = this._input();
    const inputValue = this._normalizeText();
    const value2 = this._parseValue(inputValue);
    const valueHasDigits = "." !== inputValue && "-" !== inputValue;
    if (this._isValueValid() && !this._validateValue(value2)) {
      $input.val(this._applyDisplayValueFormatter(value2));
      return;
    }
    if (valueHasDigits) {
      this.callBase(e, isNaN(value2) ? null : value2);
    }
    this._applyValueBoundaries(inputValue, value2);
    this.validationRequest.fire({
      value: value2,
      editor: this
    });
  },
  _applyValueBoundaries(inputValue, parsedValue) {
    const isValueIncomplete = this._isValueIncomplete(inputValue);
    const isValueCorrect = this._isValueInRange(inputValue);
    if (!isValueIncomplete && !isValueCorrect && null !== parsedValue) {
      if (Number(inputValue) !== parsedValue) {
        this._input().val(this._applyDisplayValueFormatter(parsedValue));
      }
    }
  },
  _replaceCommaWithPoint: (value2) => value2.replace(",", "."),
  _inputIsInvalid() {
    const isNumberMode = "number" === this.option("mode");
    const validityState = this._input().get(0).validity;
    return isNumberMode && validityState && validityState.badInput;
  },
  _renderDisplayText(text) {
    if (this._inputIsInvalid()) {
      return;
    }
    this.callBase(text);
  },
  _isValueIncomplete: (value2) => /(^-$)|(^-?\d*\.$)|(\d+e-?$)/i.test(value2),
  _isValueInRange(value2) {
    return inRange(value2, this.option("min"), this.option("max"));
  },
  _isNumber(value2) {
    return null !== this._parseValue(value2);
  },
  _validateValue(value2) {
    const inputValue = this._normalizeText();
    const isValueValid = this._isValueValid();
    let isValid = true;
    const isNumber2 = this._isNumber(inputValue);
    if (isNaN(Number(value2))) {
      isValid = false;
    }
    if (!value2 && isValueValid) {
      isValid = true;
    } else if (!isNumber2 && !isValueValid) {
      isValid = false;
    }
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: this.option("invalidValueMessage")
      }
    });
    return isValid;
  },
  _normalizeInputValue() {
    return this._parseValue(this._normalizeText());
  },
  _normalizeText() {
    const value2 = this._input().val().trim();
    return this._replaceCommaWithPoint(value2);
  },
  _parseValue(value2) {
    const number = parseFloat(value2);
    if (isNaN(number)) {
      return null;
    }
    return fitIntoRange(number, this.option("min"), this.option("max"));
  },
  _clearValue() {
    if (this._inputIsInvalid()) {
      this._input().val("");
      this._validateValue();
    }
    this.callBase();
  },
  clear() {
    if (null === this.option("value")) {
      this.option("text", "");
      if (this._input().length) {
        this._renderValue();
      }
    } else {
      this.option("value", null);
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "value":
        this._validateValue(args.value);
        this._setSubmitValue(args.value);
        this.callBase(args);
        this._resumeValueChangeAction();
        break;
      case "step":
        this._renderProps();
        break;
      case "min":
      case "max":
        this._renderProps();
        this.option("value", this._parseValue(this.option("value")));
        break;
      case "showSpinButtons":
      case "useLargeSpinButtons":
        this._updateButtons(["spins"]);
        break;
      case "invalidValueMessage":
        break;
      default:
        this.callBase(args);
    }
  }
});
var m_number_box_base_default = NumberBoxBase;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_utils.js
var getRealSeparatorIndex = function(str) {
  let quoteBalance = 0;
  let separatorCount = 0;
  for (let i = 0; i < str.length; ++i) {
    if ("'" === str[i]) {
      quoteBalance++;
    }
    if ("." === str[i]) {
      ++separatorCount;
      if (quoteBalance % 2 === 0) {
        return {
          occurrence: separatorCount,
          index: i
        };
      }
    }
  }
  return {
    occurrence: 1,
    index: -1
  };
};
var getNthOccurrence = function(str, c, n) {
  let i = -1;
  while (n-- && i++ < str.length) {
    i = str.indexOf(c, i);
  }
  return i;
};
var splitByIndex = function(str, index2) {
  if (-1 === index2) {
    return [str];
  }
  return [str.slice(0, index2), str.slice(index2 + 1)];
};
var adjustPercentValue = function(rawValue, precision) {
  return rawValue && adjust(rawValue / 100, precision);
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.caret.js
var getCaretBoundaries = function(text, format2) {
  if ("string" === typeof format2) {
    const signParts = format2.split(";");
    const sign2 = number_default2.getSign(text, format2);
    signParts[1] = signParts[1] || `-${signParts[0]}`;
    format2 = signParts[sign2 < 0 ? 1 : 0];
    const mockEscapedStubs = (str) => str.replace(/'([^']*)'/g, (str2) => str2.split("").map(() => " ").join("").substr(2));
    format2 = mockEscapedStubs(format2);
    const prefixStubLength = /^[^#0.,]*/.exec(format2)[0].length;
    const postfixStubLength = /[^#0.,]*$/.exec(format2)[0].length;
    return {
      start: prefixStubLength,
      end: text.length - postfixStubLength
    };
  }
  return {
    start: 0,
    end: text.length
  };
};
var _getDigitCountBeforeIndex = function(index2, text) {
  const decimalSeparator = number_default2.getDecimalSeparator();
  const regExp = new RegExp(`[^0-9${escapeRegExp(decimalSeparator)}]`, "g");
  const textBeforePosition = text.slice(0, index2);
  return textBeforePosition.replace(regExp, "").length;
};
var _reverseText = function(text) {
  return text.split("").reverse().join("");
};
var _getDigitPositionByIndex = function(digitIndex, text) {
  if (!digitIndex) {
    return -1;
  }
  const regExp = /[0-9]/g;
  let counter = 1;
  let index2 = null;
  let result2 = regExp.exec(text);
  while (result2) {
    index2 = result2.index;
    if (counter >= digitIndex) {
      return index2;
    }
    counter++;
    result2 = regExp.exec(text);
  }
  return null === index2 ? text.length : index2;
};
var _trimNonNumericCharsFromEnd = function(text) {
  return text.replace(/[^0-9e]+$/, "");
};
var getCaretWithOffset = function(caret3, offset2) {
  if (void 0 === caret3.start) {
    caret3 = {
      start: caret3,
      end: caret3
    };
  }
  return {
    start: caret3.start + offset2,
    end: caret3.end + offset2
  };
};
var getCaretAfterFormat = function(text, formatted, caret3, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const point = number_default2.getDecimalSeparator();
  const isSeparatorBasedText = isSeparatorBasedString(text);
  const realSeparatorOccurrenceIndex = getRealSeparatorIndex(format2).occurrence;
  const pointPosition = isSeparatorBasedText ? 0 : getNthOccurrence(text, point, realSeparatorOccurrenceIndex);
  const newPointPosition = getNthOccurrence(formatted, point, realSeparatorOccurrenceIndex);
  const textParts = splitByIndex(text, pointPosition);
  const formattedParts = splitByIndex(formatted, newPointPosition);
  const isCaretOnFloat = -1 !== pointPosition && caret3.start > pointPosition;
  if (isCaretOnFloat) {
    const relativeIndex = caret3.start - pointPosition - 1;
    const digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);
    const newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;
    return getCaretInBoundaries(newPosition, formatted, format2);
  }
  const formattedIntPart = _trimNonNumericCharsFromEnd(formattedParts[0]);
  const positionFromEnd = textParts[0].length - caret3.start;
  const digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));
  const newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedIntPart));
  const newPositionFromBegin = formattedIntPart.length - (newPositionFromEnd + 1);
  return getCaretInBoundaries(newPositionFromBegin, formatted, format2);
};
function isSeparatorBasedString(text) {
  return 1 === text.length && !!text.match(/^[,.][0-9]*$/g);
}
var isCaretInBoundaries = function(caret3, text, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const boundaries = getCaretInBoundaries(caret3, text, format2);
  return caret3.start >= boundaries.start && caret3.end <= boundaries.end;
};
function getCaretInBoundaries(caret3, text, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const boundaries = getCaretBoundaries(text, format2);
  const adjustedCaret = {
    start: fitIntoRange(caret3.start, boundaries.start, boundaries.end),
    end: fitIntoRange(caret3.end, boundaries.start, boundaries.end)
  };
  return adjustedCaret;
}
var getCaretOffset = function(previousText, newText, format2) {
  const previousBoundaries = getCaretBoundaries(previousText, format2);
  const newBoundaries = getCaretBoundaries(newText, format2);
  return newBoundaries.start - previousBoundaries.start;
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.mask.js
var NumberBoxMask = m_number_box_base_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      useMaskBehavior: true,
      format: null
    });
  },
  _isDeleteKey: (key) => "del" === key,
  _supportedKeys() {
    if (!this._useMaskBehavior()) {
      return this.callBase();
    }
    return extend(this.callBase(), {
      minus: this._revertSign.bind(this),
      del: this._removeHandler.bind(this),
      backspace: this._removeHandler.bind(this),
      leftArrow: this._arrowHandler.bind(this, -1),
      rightArrow: this._arrowHandler.bind(this, 1),
      home: this._moveCaretToBoundaryEventHandler.bind(this, 1),
      enter: this._updateFormattedValue.bind(this),
      end: this._moveCaretToBoundaryEventHandler.bind(this, -1)
    });
  },
  _getTextSeparatorIndex(text) {
    const decimalSeparator = number_default2.getDecimalSeparator();
    const realSeparatorOccurrenceIndex = getRealSeparatorIndex(this.option("format")).occurrence;
    return getNthOccurrence(text, decimalSeparator, realSeparatorOccurrenceIndex);
  },
  _focusInHandler(e) {
    if (!this._preventNestedFocusEvent(e)) {
      this.clearCaretTimeout();
      this._caretTimeout = setTimeout(() => {
        this._caretTimeout = void 0;
        const caret3 = this._caret();
        if (caret3.start === caret3.end && this._useMaskBehavior()) {
          const text = this._getInputVal();
          const decimalSeparatorIndex = this._getTextSeparatorIndex(text);
          if (decimalSeparatorIndex >= 0) {
            this._caret({
              start: decimalSeparatorIndex,
              end: decimalSeparatorIndex
            });
          } else {
            this._moveCaretToBoundaryEventHandler(-1, e);
          }
        }
      }, 0);
    }
    this.callBase(e);
  },
  _focusOutHandler(e) {
    const shouldHandleEvent = !this._preventNestedFocusEvent(e);
    if (shouldHandleEvent) {
      this._focusOutOccurs = true;
      if (this._useMaskBehavior()) {
        this._updateFormattedValue();
      }
    }
    this.callBase(e);
    if (shouldHandleEvent) {
      this._focusOutOccurs = false;
    }
  },
  _hasValueBeenChanged(inputValue) {
    const format2 = this._getFormatPattern();
    const value2 = this.option("value");
    const formatted = this._format(value2, format2) || "";
    return formatted !== inputValue;
  },
  _updateFormattedValue() {
    const inputValue = this._getInputVal();
    if (this._hasValueBeenChanged(inputValue)) {
      this._updateParsedValue();
      this._adjustParsedValue();
      this._setTextByParsedValue();
      if (this._parsedValue !== this.option("value")) {
        events_engine_default.trigger(this._input(), "change");
      }
    }
  },
  _arrowHandler(step, e) {
    if (!this._useMaskBehavior()) {
      return;
    }
    const text = this._getInputVal();
    const format2 = this._getFormatPattern();
    let nextCaret = getCaretWithOffset(this._caret(), step);
    if (!isCaretInBoundaries(nextCaret, text, format2)) {
      nextCaret = 1 === step ? nextCaret.end : nextCaret.start;
      e.preventDefault();
      this._caret(getCaretInBoundaries(nextCaret, text, format2));
    }
  },
  _moveCaretToBoundary(direction) {
    const boundaries = getCaretBoundaries(this._getInputVal(), this._getFormatPattern());
    const newCaret = getCaretWithOffset(1 === direction ? boundaries.start : boundaries.end, 0);
    this._caret(newCaret);
  },
  _moveCaretToBoundaryEventHandler(direction, e) {
    if (!this._useMaskBehavior() || e && e.shiftKey) {
      return;
    }
    this._moveCaretToBoundary(direction);
    e && e.preventDefault();
  },
  _shouldMoveCaret(text, caret3) {
    const decimalSeparator = number_default2.getDecimalSeparator();
    const isDecimalSeparatorNext = text.charAt(caret3.end) === decimalSeparator;
    const moveToFloat = (this._lastKey === decimalSeparator || "." === this._lastKey || "," === this._lastKey) && isDecimalSeparatorNext;
    return moveToFloat;
  },
  _getInputVal() {
    return number_default2.convertDigits(this._input().val(), true);
  },
  _keyboardHandler(e) {
    this.clearCaretTimeout();
    this._lastKey = number_default2.convertDigits(getChar(e), true);
    this._lastKeyName = normalizeKeyName(e);
    if (!this._shouldHandleKey(e.originalEvent)) {
      return this.callBase(e);
    }
    const normalizedText = this._getInputVal();
    const caret3 = this._caret();
    let enteredChar;
    if ("minus" === this._lastKeyName) {
      enteredChar = "";
    } else {
      enteredChar = 110 === e.which ? number_default2.getDecimalSeparator() : this._lastKey;
    }
    const newValue = this._tryParse(normalizedText, caret3, enteredChar);
    if (this._shouldMoveCaret(normalizedText, caret3)) {
      this._moveCaret(1);
      e.originalEvent.preventDefault();
    }
    if (void 0 === newValue) {
      if ("minus" !== this._lastKeyName) {
        e.originalEvent.preventDefault();
      }
    } else {
      this._parsedValue = newValue;
    }
    return this.callBase(e);
  },
  _keyPressHandler(e) {
    if (!this._useMaskBehavior()) {
      this.callBase(e);
    }
  },
  _removeHandler(e) {
    const caret3 = this._caret();
    const text = this._getInputVal();
    let {
      start
    } = caret3;
    let {
      end
    } = caret3;
    this._lastKey = getChar(e);
    this._lastKeyName = normalizeKeyName(e);
    const isDeleteKey = this._isDeleteKey(this._lastKeyName);
    const isBackspaceKey = !isDeleteKey;
    if (start === end) {
      const caretPosition = start;
      const canDelete = isBackspaceKey && caretPosition > 0 || isDeleteKey && caretPosition < text.length;
      if (canDelete) {
        isDeleteKey && end++;
        isBackspaceKey && start--;
      } else {
        e.preventDefault();
        return;
      }
    }
    const char = text.slice(start, end);
    if (this._isStub(char)) {
      this._moveCaret(isDeleteKey ? 1 : -1);
      if (this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0) {
        this._revertSign(e);
        this._setTextByParsedValue();
        const shouldTriggerInputEvent = this.option("valueChangeEvent").split(" ").includes("input");
        if (shouldTriggerInputEvent) {
          events_engine_default.trigger(this._input(), "input");
        }
      }
      e.preventDefault();
      return;
    }
    const decimalSeparator = number_default2.getDecimalSeparator();
    if (char === decimalSeparator) {
      const decimalSeparatorIndex = text.indexOf(decimalSeparator);
      if (this._isNonStubAfter(decimalSeparatorIndex + 1)) {
        this._moveCaret(isDeleteKey ? 1 : -1);
        e.preventDefault();
      }
      return;
    }
    if (end - start < text.length) {
      const editedText = this._replaceSelectedText(text, {
        start,
        end
      }, "");
      const noDigits = editedText.search(/[0-9]/) < 0;
      if (noDigits && this._isValueInRange(0)) {
        this._parsedValue = this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0 ? -0 : 0;
        return;
      }
    }
    const valueAfterRemoving = this._tryParse(text, {
      start,
      end
    }, "");
    if (void 0 === valueAfterRemoving) {
      e.preventDefault();
    } else {
      this._parsedValue = valueAfterRemoving;
    }
  },
  _isPercentFormat() {
    const format2 = this._getFormatPattern();
    const noEscapedFormat = format2.replace(/'[^']+'/g, "");
    return -1 !== noEscapedFormat.indexOf("%");
  },
  _parse(text, format2) {
    const formatOption = this.option("format");
    const isCustomParser = isFunction(formatOption.parser);
    const parser = isCustomParser ? formatOption.parser : number_default2.parse;
    let integerPartStartIndex = 0;
    if (!isCustomParser) {
      const formatPointIndex = getRealSeparatorIndex(format2).index;
      const textPointIndex = this._getTextSeparatorIndex(text);
      const formatIntegerPartLength = -1 !== formatPointIndex ? formatPointIndex : format2.length;
      const textIntegerPartLength = -1 !== textPointIndex ? textPointIndex : text.length;
      if (textIntegerPartLength > formatIntegerPartLength && -1 === format2.indexOf("#")) {
        integerPartStartIndex = textIntegerPartLength - formatIntegerPartLength;
      }
    }
    text = text.substr(integerPartStartIndex);
    return parser(text, format2);
  },
  _format(value2, format2) {
    const formatOption = this.option("format");
    const customFormatter = (null === formatOption || void 0 === formatOption ? void 0 : formatOption.formatter) || formatOption;
    const formatter = isFunction(customFormatter) ? customFormatter : number_default2.format;
    const formattedValue = null === value2 ? "" : formatter(value2, format2);
    return formattedValue;
  },
  _getFormatPattern() {
    if (!this._currentFormat) {
      this._updateFormat();
    }
    return this._currentFormat;
  },
  _updateFormat() {
    const format2 = this.option("format");
    const isCustomParser = isFunction(null === format2 || void 0 === format2 ? void 0 : format2.parser);
    const isLDMLPattern = isString(format2) && (format2.includes("0") || format2.includes("#"));
    const isExponentialFormat = "exponential" === format2 || "exponential" === (null === format2 || void 0 === format2 ? void 0 : format2.type);
    const shouldUseFormatAsIs = isCustomParser || isLDMLPattern || isExponentialFormat;
    this._currentFormat = shouldUseFormatAsIs ? format2 : getFormat((value2) => {
      const text = this._format(value2, format2);
      return number_default2.convertDigits(text, true);
    });
  },
  _getFormatForSign(text) {
    const format2 = this._getFormatPattern();
    if (isString(format2)) {
      const signParts = format2.split(";");
      const sign3 = number_default2.getSign(text, format2);
      signParts[1] = signParts[1] || `-${signParts[0]}`;
      return sign3 < 0 ? signParts[1] : signParts[0];
    }
    const sign2 = number_default2.getSign(text);
    return sign2 < 0 ? "-" : "";
  },
  _removeStubs(text, excludeComma) {
    const format2 = this._getFormatForSign(text);
    const thousandsSeparator = number_default2.getThousandsSeparator();
    const stubs = this._getStubs(format2);
    let result2 = text;
    if (stubs.length) {
      const prefixStubs = stubs[0];
      const postfixRegex = new RegExp(`(${escapeRegExp(stubs[1] || "")})$`, "g");
      const decoratorsRegex = new RegExp(`[-${escapeRegExp(excludeComma ? "" : thousandsSeparator)}]`, "g");
      result2 = result2.replace(prefixStubs, "").replace(postfixRegex, "").replace(decoratorsRegex, "");
    }
    return result2;
  },
  _getStubs(format2) {
    const regExpResult = /[^']([#0.,]+)/g.exec(format2);
    const pattern = regExpResult && regExpResult[0].trim();
    return format2.split(pattern).map((stub) => stub.replace(/'/g, ""));
  },
  _truncateToPrecision(value2, maxPrecision) {
    if (isDefined(value2)) {
      const strValue = value2.toString();
      const decimalSeparatorIndex = strValue.indexOf(".");
      if (strValue && decimalSeparatorIndex > -1) {
        const parsedValue = parseFloat(strValue.substr(0, decimalSeparatorIndex + maxPrecision + 1));
        return isNaN(parsedValue) ? value2 : parsedValue;
      }
    }
    return value2;
  },
  _tryParse(text, selection, char) {
    const isTextSelected = selection.start !== selection.end;
    const isWholeTextSelected = isTextSelected && 0 === selection.start && selection.end === text.length;
    const decimalSeparator = number_default2.getDecimalSeparator();
    if (isWholeTextSelected && char === decimalSeparator) {
      return 0;
    }
    const editedText = this._replaceSelectedText(text, selection, char);
    const format2 = this._getFormatPattern();
    let parsedValue = this._getParsedValue(editedText, format2);
    const maxPrecision = !format2.parser && this._getPrecisionLimits(editedText).max;
    const isValueChanged = parsedValue !== this._parsedValue;
    const isDecimalPointRestricted = char === decimalSeparator && 0 === maxPrecision;
    const isUselessCharRestricted = !isTextSelected && !isValueChanged && "-" !== char && this._isStub(char);
    if (isDecimalPointRestricted || isUselessCharRestricted) {
      return;
    }
    if ("" === this._removeStubs(editedText)) {
      parsedValue = Math.abs(0 * this._parsedValue);
    }
    if (isNaN(parsedValue)) {
      return;
    }
    const value2 = null === parsedValue ? this._parsedValue : parsedValue;
    parsedValue = maxPrecision ? this._truncateToPrecision(value2, maxPrecision) : parsedValue;
    return !format2.parser && this._isPercentFormat() ? adjustPercentValue(parsedValue, maxPrecision) : parsedValue;
  },
  _getParsedValue(text, format2) {
    const sign2 = number_default2.getSign(text, (null === format2 || void 0 === format2 ? void 0 : format2.formatter) || format2);
    const textWithoutStubs = this._removeStubs(text, true);
    const parsedValue = this._parse(textWithoutStubs, format2);
    const parsedValueSign = parsedValue < 0 ? -1 : 1;
    const parsedValueWithSign = isNumeric(parsedValue) && sign2 !== parsedValueSign ? sign2 * parsedValue : parsedValue;
    return parsedValueWithSign;
  },
  _isValueIncomplete(text) {
    if (!this._useMaskBehavior()) {
      return this.callBase(text);
    }
    const caret3 = this._caret();
    const point = number_default2.getDecimalSeparator();
    const pointIndex = this._getTextSeparatorIndex(text);
    const isCaretOnFloat = pointIndex >= 0 && pointIndex < caret3.start;
    const textParts = this._removeStubs(text, true).split(point);
    if (!isCaretOnFloat || 2 !== textParts.length) {
      return false;
    }
    const floatLength = textParts[1].length;
    const format2 = this._getFormatPattern();
    const isCustomParser = !!format2.parser;
    const precision = !isCustomParser && this._getPrecisionLimits(this._getFormatPattern(), text);
    const isPrecisionInRange = isCustomParser ? true : inRange(floatLength, precision.min, precision.max);
    const endsWithZero = "0" === textParts[1].charAt(floatLength - 1);
    return isPrecisionInRange && (endsWithZero || !floatLength);
  },
  _isValueInRange(value2) {
    const min = ensureDefined(this.option("min"), -1 / 0);
    const max = ensureDefined(this.option("max"), 1 / 0);
    return inRange(value2, min, max);
  },
  _setInputText(text) {
    const normalizedText = number_default2.convertDigits(text, true);
    const newCaret = getCaretAfterFormat(this._getInputVal(), normalizedText, this._caret(), this._getFormatPattern());
    this._input().val(text);
    this._toggleEmptinessEventHandler();
    this._formattedValue = text;
    if (!this._focusOutOccurs) {
      this._caret(newCaret);
    }
  },
  _useMaskBehavior() {
    return !!this.option("format") && this.option("useMaskBehavior");
  },
  _renderInputType() {
    const isNumberType = "number" === this.option("mode");
    const isDesktop = "desktop" === devices_default.real().deviceType;
    if (this._useMaskBehavior() && isNumberType) {
      this._setInputType(isDesktop || this._isSupportInputMode() ? "text" : "tel");
    } else {
      this.callBase();
    }
  },
  _isChar: (str) => isString(str) && 1 === str.length,
  _moveCaret(offset2) {
    if (!offset2) {
      return;
    }
    const newCaret = getCaretWithOffset(this._caret(), offset2);
    const adjustedCaret = getCaretInBoundaries(newCaret, this._getInputVal(), this._getFormatPattern());
    this._caret(adjustedCaret);
  },
  _shouldHandleKey(e) {
    const keyName = normalizeKeyName(e);
    const isSpecialChar = isCommandKeyPressed(e) || e.altKey || e.shiftKey || !this._isChar(keyName);
    const isMinusKey = "minus" === keyName;
    const useMaskBehavior = this._useMaskBehavior();
    return useMaskBehavior && !isSpecialChar && !isMinusKey;
  },
  _renderInput() {
    this.callBase();
    this._renderFormatter();
  },
  _renderFormatter() {
    this._clearCache();
    this._detachFormatterEvents();
    if (this._useMaskBehavior()) {
      this._attachFormatterEvents();
    }
  },
  _detachFormatterEvents() {
    events_engine_default.off(this._input(), ".dxNumberFormatter");
  },
  _isInputFromPaste(e) {
    const inputType2 = e.originalEvent && e.originalEvent.inputType;
    if (isDefined(inputType2)) {
      return "insertFromPaste" === inputType2;
    }
    return this._isValuePasted;
  },
  _attachFormatterEvents() {
    const $input = this._input();
    events_engine_default.on($input, addNamespace2("input", "dxNumberFormatter"), (e) => {
      this._formatValue(e);
      this._isValuePasted = false;
    });
    events_engine_default.on($input, addNamespace2("dxclick", "dxNumberFormatter"), () => {
      if (!this._caretTimeout) {
        this._caretTimeout = setTimeout(() => {
          this._caretTimeout = void 0;
          this._caret(getCaretInBoundaries(this._caret(), this._getInputVal(), this._getFormatPattern()));
        }, 0);
      }
    });
    events_engine_default.on($input, DBLCLICK_EVENT_NAME, () => {
      this.clearCaretTimeout();
    });
  },
  clearCaretTimeout() {
    clearTimeout(this._caretTimeout);
    this._caretTimeout = void 0;
  },
  _forceRefreshInputValue() {
    if (!this._useMaskBehavior()) {
      return this.callBase();
    }
  },
  _isNonStubAfter(index2) {
    const text = this._getInputVal().slice(index2);
    return text && !this._isStub(text, true);
  },
  _isStub(str, isString4) {
    const escapedDecimalSeparator = escapeRegExp(number_default2.getDecimalSeparator());
    const regExpString = `^[^0-9${escapedDecimalSeparator}]+$`;
    const stubRegExp = new RegExp(regExpString, "g");
    return stubRegExp.test(str) && (isString4 || this._isChar(str));
  },
  _parseValue(text) {
    if (!this._useMaskBehavior()) {
      return this.callBase(text);
    }
    return this._parsedValue;
  },
  _getPrecisionLimits(text) {
    const currentFormat = this._getFormatForSign(text);
    const realSeparatorIndex = getRealSeparatorIndex(currentFormat).index;
    const floatPart = (splitByIndex(currentFormat, realSeparatorIndex)[1] || "").replace(/[^#0]/g, "");
    const minPrecision = floatPart.replace(/^(0*)#*/, "$1").length;
    const maxPrecision = floatPart.length;
    return {
      min: minPrecision,
      max: maxPrecision
    };
  },
  _revertSign(e) {
    if (!this._useMaskBehavior()) {
      return;
    }
    const caret3 = this._caret();
    if (caret3.start !== caret3.end) {
      if ("minus" === normalizeKeyName(e)) {
        this._applyRevertedSign(e, caret3, true);
        return;
      }
      this._caret(getCaretInBoundaries(0, this._getInputVal(), this._getFormatPattern()));
    }
    this._applyRevertedSign(e, caret3);
  },
  _applyRevertedSign(e, caret3, preserveSelectedText) {
    const newValue = -1 * ensureDefined(this._parsedValue, null);
    if (this._isValueInRange(newValue) || 0 === newValue) {
      this._parsedValue = newValue;
      if (preserveSelectedText) {
        const format2 = this._getFormatPattern();
        const previousText = this._getInputVal();
        this._setTextByParsedValue();
        e.preventDefault();
        const currentText = this._getInputVal();
        const offset2 = getCaretOffset(previousText, currentText, format2);
        caret3 = getCaretWithOffset(caret3, offset2);
        const caretInBoundaries = getCaretInBoundaries(caret3, currentText, format2);
        this._caret(caretInBoundaries);
      }
    }
  },
  _removeMinusFromText(text, caret3) {
    const isMinusPressed = "minus" === this._lastKeyName && "-" === text.charAt(caret3.start - 1);
    return isMinusPressed ? this._replaceSelectedText(text, {
      start: caret3.start - 1,
      end: caret3.start
    }, "") : text;
  },
  _setTextByParsedValue() {
    const format2 = this._getFormatPattern();
    const parsed = this._parseValue();
    const formatted = this._format(parsed, format2) || "";
    this._setInputText(formatted);
  },
  _formatValue(e) {
    let normalizedText = this._getInputVal();
    const caret3 = this._caret();
    const textWithoutMinus = this._removeMinusFromText(normalizedText, caret3);
    const wasMinusRemoved = textWithoutMinus !== normalizedText;
    normalizedText = textWithoutMinus;
    if (!this._isInputFromPaste(e) && this._isValueIncomplete(textWithoutMinus)) {
      this._formattedValue = normalizedText;
      if (wasMinusRemoved) {
        this._setTextByParsedValue();
      }
      return;
    }
    const textWasChanged = number_default2.convertDigits(this._formattedValue, true) !== normalizedText;
    if (textWasChanged) {
      const value2 = this._tryParse(normalizedText, caret3, "");
      if (isDefined(value2)) {
        this._parsedValue = value2;
      }
    }
    this._setTextByParsedValue();
  },
  _renderDisplayText() {
    if (this._useMaskBehavior()) {
      this._toggleEmptinessEventHandler();
    } else {
      this.callBase.apply(this, arguments);
    }
  },
  _renderValue() {
    if (this._useMaskBehavior()) {
      this._parsedValue = this.option("value");
      this._setTextByParsedValue();
    }
    return this.callBase();
  },
  _updateParsedValue() {
    const inputValue = this._getInputVal();
    this._parsedValue = this._tryParse(inputValue, this._caret());
  },
  _adjustParsedValue() {
    if (!this._useMaskBehavior()) {
      return;
    }
    const clearedText = this._removeStubs(this._getInputVal());
    const parsedValue = clearedText ? this._parseValue() : null;
    if (!isNumeric(parsedValue)) {
      this._parsedValue = parsedValue;
      return;
    }
    this._parsedValue = fitIntoRange(parsedValue, this.option("min"), this.option("max"));
  },
  _valueChangeEventHandler(e) {
    if (!this._useMaskBehavior()) {
      return this.callBase(e);
    }
    const caret3 = this._caret();
    this._saveValueChangeEvent(e);
    this._lastKey = null;
    this._lastKeyName = null;
    this._updateParsedValue();
    this._adjustParsedValue();
    this.option("value", this._parsedValue);
    if (caret3) {
      this._caret(caret3);
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "format":
      case "useMaskBehavior":
        this._renderInputType();
        this._updateFormat();
        this._renderFormatter();
        this._renderValue();
        this._refreshValueChangeEvent();
        this._refreshEvents();
        break;
      case "min":
      case "max":
        this._adjustParsedValue();
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  },
  _clearCache() {
    delete this._formattedValue;
    delete this._lastKey;
    delete this._lastKeyName;
    delete this._parsedValue;
    delete this._focusOutOccurs;
    clearTimeout(this._caretTimeout);
    delete this._caretTimeout;
  },
  _clean() {
    this._clearCache();
    this.callBase();
  }
});
var m_number_box_mask_default = NumberBoxMask;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.js
component_registrator_default("dxNumberBox", m_number_box_mask_default);
var m_number_box_default = m_number_box_mask_default;

// ../../../../../../node_modules/devextreme/esm/ui/number_box.js
var number_box_default = m_number_box_default;

// ../../../../../../node_modules/devextreme/esm/renovation/utils/dom.js
function querySelectorInSameDocument(el, selector) {
  var _el$getRootNode;
  const root = (null === (_el$getRootNode = el.getRootNode) || void 0 === _el$getRootNode ? void 0 : _el$getRootNode.call(el)) ?? document;
  return root.querySelector(selector);
}

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/editors/editor.js
var INVALID_MESSAGE_AUTO3 = "dx-invalid-message-auto";
var VALIDATION_TARGET2 = "dx-validation-target";
var Editor2 = class extends component_default {
  getProps() {
    const props = super.getProps();
    props.onFocusIn = () => {
      const isValidationMessageShownOnFocus = "auto" === this.option("validationMessageMode");
      if (isValidationMessageShownOnFocus) {
        const $validationMessageWrapper = renderer_default(querySelectorInSameDocument(this.element(), ".dx-invalid-message.dx-overlay-wrapper"));
        null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO3);
        const timeToWaitBeforeShow = 150;
        if (this.showValidationMessageTimeout) {
          clearTimeout(this.showValidationMessageTimeout);
        }
        this.showValidationMessageTimeout = setTimeout(() => {
          null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO3);
        }, timeToWaitBeforeShow);
      }
    };
    props.saveValueChangeEvent = (e) => {
      this._valueChangeEventInstance = e;
    };
    return props;
  }
  _createElement(element) {
    super._createElement(element);
    this.showValidationMessageTimeout = void 0;
    this.validationRequest = callbacks_default();
    data(this.$element()[0], VALIDATION_TARGET2, this);
  }
  _render() {
    var _this$option;
    null === (_this$option = this.option("_onMarkupRendered")) || void 0 === _this$option || _this$option();
  }
  _init() {
    super._init();
    this._initialValue = this.option("value");
  }
  _initializeComponent() {
    super._initializeComponent();
    this._valueChangeAction = this._createActionByOption("onValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initOptions(options2) {
    super._initOptions(options2);
    this.option(validation_engine_default.initValidationOptions(options2));
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {}
    });
  }
  _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    const innerWidgetOptions = extend({}, innerWidget.option());
    const syncOptions = () => this._silent(optionsContainer, innerWidgetOptions);
    syncOptions();
    innerWidget.on("optionChanged", syncOptions);
  }
  _raiseValidation(value2, previousValue) {
    const areValuesEmpty = !isDefined(value2) && !isDefined(previousValue);
    if (value2 !== previousValue && !areValuesEmpty) {
      this.validationRequest.fire({
        value: value2,
        editor: this
      });
    }
  }
  _raiseValueChangeAction(value2, previousValue) {
    var _this$_valueChangeAct;
    null === (_this$_valueChangeAct = this._valueChangeAction) || void 0 === _this$_valueChangeAct || _this$_valueChangeAct.call(this, {
      element: this.$element(),
      previousValue,
      value: value2,
      event: this._valueChangeEventInstance
    });
    this._valueChangeEventInstance = void 0;
  }
  _optionChanged(option) {
    const {
      name: name2,
      previousValue,
      value: value2
    } = option;
    if (name2 && void 0 !== this._getActionConfigs()[name2]) {
      this._addAction(name2);
    }
    switch (name2) {
      case "value":
        this._raiseValidation(value2, previousValue);
        this.option("isDirty", this._initialValue !== value2);
        this._raiseValueChangeAction(value2, previousValue);
        break;
      case "onValueChanged":
        this._valueChangeAction = this._createActionByOption("onValueChanged", {
          excludeValidators: ["disabled", "readOnly"]
        });
        break;
      case "isValid":
      case "validationError":
      case "validationErrors":
      case "validationStatus":
        this.option(validation_engine_default.synchronizeValidationOptions(option, this.option()));
    }
    super._optionChanged(option);
  }
  clear() {
    const {
      value: value2
    } = this._getDefaultOptions();
    this.option({
      value: value2
    });
  }
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      this._initialValue = value2;
    }
    this.option("value", this._initialValue);
    this.option("isDirty", false);
    this.option("isValid", true);
  }
  _dispose() {
    super._dispose();
    data(this.element(), VALIDATION_TARGET2, null);
    if (this.showValidationMessageTimeout) {
      clearTimeout(this.showValidationMessageTimeout);
    }
  }
};
var prevIsEditor = editor_default.isEditor;
var newIsEditor = (instance) => prevIsEditor(instance) || instance instanceof Editor2;
Editor2.isEditor = newIsEditor;
editor_default.isEditor = newIsEditor;

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/editors/check_box.js
var CheckBox = class extends Editor2 {
  _useTemplates() {
    return false;
  }
  _isFocused() {
    const focusTarget = this.$element()[0];
    return focusTarget.classList.contains("dx-state-focused");
  }
  getSupportedKeyNames() {
    return ["space"];
  }
  getProps() {
    const props = super.getProps();
    if (null !== props.value) {
      props.value = Boolean(props.value);
    }
    return props;
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/utils/get_updated_options.js
var defaultNotDeepCopyArrays = ["dataSource", "selectedRowKeys"];
var propsToIgnore = {
  integrationOptions: true
};
function getDiffItem(key, value2, previousValue) {
  return {
    path: key,
    value: value2,
    previousValue
  };
}
function compare2(resultPaths, item1, item2, key, fullPropName, notDeepCopyArrays) {
  if (propsToIgnore[key]) {
    return;
  }
  const type1 = type(item1);
  const type2 = type(item2);
  if (item1 === item2) {
    return;
  }
  if (type1 !== type2) {
    resultPaths.push(getDiffItem(key, item2, item1));
  } else if ("object" === type1) {
    if (!isPlainObject(item2)) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else {
      const diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);
      resultPaths.push(...diffPaths.map((item) => _extends({}, item, {
        path: `${key}.${item.path}`
      })));
    }
  } else if ("array" === type1) {
    const notDeepCopy = notDeepCopyArrays.some((prop) => fullPropName.includes(prop));
    if (notDeepCopy && item1 !== item2) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else if (item1.length !== item2.length) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else {
      const diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);
      [].push.apply(resultPaths, diffPaths.map((item) => _extends({}, item, {
        path: `${key}${item.path}`
      })));
    }
  } else {
    resultPaths.push(getDiffItem(key, item2, item1));
  }
}
var objectDiffsFiltered = (propsEnumerator) => (oldProps, props, fullPropName, notDeepCopyArrays) => {
  const resultPaths = [];
  const processItem = !Array.isArray(oldProps) ? (propName) => {
    compare2(resultPaths, oldProps[propName], props[propName], propName, `${fullPropName}.${propName}`, notDeepCopyArrays);
  } : (propName) => {
    compare2(resultPaths, oldProps[propName], props[propName], `[${propName}]`, `${fullPropName}.${propName}`, notDeepCopyArrays);
  };
  propsEnumerator(oldProps).forEach(processItem);
  Object.keys(props).filter((propName) => !Object.prototype.hasOwnProperty.call(oldProps, propName) && oldProps[propName] !== props[propName]).forEach((propName) => {
    resultPaths.push({
      path: propName,
      value: props[propName],
      previousValue: oldProps[propName]
    });
  });
  return resultPaths;
};
var objectDiffs = objectDiffsFiltered((oldProps) => Object.keys(oldProps));
var reactProps = {
  key: true,
  ref: true,
  children: true,
  style: true
};
var objectDiffsWithoutReactProps = objectDiffsFiltered((prop) => Object.keys(prop).filter((p2) => !reactProps[p2]));
function getUpdatedOptions(oldProps, props) {
  let notDeepCopyArrays = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : defaultNotDeepCopyArrays;
  return objectDiffsWithoutReactProps(oldProps, props, "", notDeepCopyArrays);
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/dom_component_wrapper.js
var _excluded8 = ["valueChange"];
var _excluded22 = ["componentProps", "componentType", "templateNames"];
var normalizeProps2 = (props) => Object.keys(props).reduce((accumulator, key) => {
  if (void 0 !== props[key]) {
    accumulator[key] = props[key];
  }
  return accumulator;
}, {});
var viewFunction6 = (_ref) => {
  let {
    props: {
      componentProps: {
        className
      }
    },
    restAttributes,
    widgetRef
  } = _ref;
  return normalizeProps2(createVNode(1, "div", className, null, 1, _extends({}, restAttributes), null, widgetRef));
};
var DomComponentWrapperProps = {};
var DomComponentWrapper = class extends InfernoComponent {
  get config() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  constructor(props) {
    super(props);
    this.state = {};
    this.widgetRef = createRef();
    this.getInstance = this.getInstance.bind(this);
    this.setupWidget = this.setupWidget.bind(this);
    this.updateWidget = this.updateWidget.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.setupWidget, []), new InfernoEffect(this.updateWidget, [this.props.componentProps, this.config, this.props.templateNames])];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[1]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props.componentProps, this.config, this.props.templateNames]);
  }
  setupWidget() {
    const componentInstance = new this.props.componentType(this.widgetRef.current, this.properties);
    this.instance = componentInstance;
    return () => {
      componentInstance.dispose();
      this.instance = null;
    };
  }
  updateWidget() {
    const instance = this.getInstance();
    if (!instance) {
      return;
    }
    const updatedOptions = getUpdatedOptions(this.prevProps || {}, this.properties);
    if (updatedOptions.length) {
      instance.beginUpdate();
      updatedOptions.forEach((_ref2) => {
        let {
          path,
          value: value2
        } = _ref2;
        instance.option(path, value2);
      });
      instance.endUpdate();
    }
    this.prevProps = this.properties;
  }
  get properties() {
    var _this$config;
    const normalizedProps = normalizeProps2(this.props.componentProps);
    const {
      valueChange
    } = normalizedProps, restProps = _objectWithoutPropertiesLoose(normalizedProps, _excluded8);
    const properties = _extends({
      rtlEnabled: !!(null !== (_this$config = this.config) && void 0 !== _this$config && _this$config.rtlEnabled),
      isRenovated: true
    }, restProps);
    if (valueChange) {
      properties.onValueChanged = (_ref3) => {
        let {
          value: value2
        } = _ref3;
        return valueChange(value2);
      };
    }
    const templates = this.props.templateNames;
    templates.forEach((name2) => {
      if (hasTemplate(name2, properties, this)) {
        properties[name2] = (item, index2, container) => {
          renderTemplate(this.props.componentProps[name2], {
            item,
            index: index2,
            container
          }, this);
        };
      }
    });
    return properties;
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded22);
    return restProps;
  }
  getInstance() {
    return this.instance;
  }
  render() {
    const props = this.props;
    return viewFunction6({
      props: _extends({}, props),
      widgetRef: this.widgetRef,
      config: this.config,
      properties: this.properties,
      restAttributes: this.restAttributes
    });
  }
};
DomComponentWrapper.defaultProps = DomComponentWrapperProps;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/overlays/validation_message.js
var _excluded9 = ["accessKey", "activeStateEnabled", "boundary", "className", "contentId", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "mode", "offset", "onClick", "onKeyDown", "positionSide", "rtlEnabled", "tabIndex", "target", "validationErrors", "visible", "visualContainer", "width"];
var viewFunction7 = (_ref) => {
  let {
    componentProps,
    restAttributes
  } = _ref;
  return normalizeProps(createComponentVNode(2, DomComponentWrapper, _extends({
    componentType: validation_message_default,
    componentProps,
    templateNames: []
  }, restAttributes)));
};
var ValidationMessageProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(BaseWidgetProps), Object.getOwnPropertyDescriptors({
  mode: "auto",
  positionSide: "top",
  offset: Object.freeze({
    h: 0,
    v: 0
  }),
  isReactComponentWrapper: true
})));
var ValidationMessage2 = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }
  get componentProps() {
    return this.props;
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded9);
    return restProps;
  }
  render() {
    const props = this.props;
    return viewFunction7({
      props: _extends({}, props),
      componentProps: this.componentProps,
      restAttributes: this.restAttributes
    });
  }
};
ValidationMessage2.defaultProps = ValidationMessageProps;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/editors/common/editor.js
var _excluded10 = ["accessKey", "activeStateEnabled", "aria", "children", "className", "classes", "defaultValue", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "inputAttr", "isDirty", "isValid", "name", "onClick", "onFocusIn", "onKeyDown", "readOnly", "rtlEnabled", "tabIndex", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "value", "valueChange", "visible", "width"];
var getCssClasses3 = (model) => {
  const {
    classes,
    isValid,
    readOnly
  } = model;
  const classesMap = {
    "dx-state-readonly": !!readOnly,
    "dx-invalid": !isValid,
    [String(classes)]: !!classes
  };
  return combineClasses(classesMap);
};
var viewFunction8 = (viewModel) => {
  const {
    aria,
    cssClasses: classes,
    isValidationMessageVisible,
    onFocusIn,
    props: {
      accessKey,
      activeStateEnabled,
      children,
      className,
      disabled,
      focusStateEnabled,
      height,
      hint,
      hoverStateEnabled,
      onClick,
      onKeyDown,
      rtlEnabled,
      tabIndex,
      validationMessageMode,
      validationMessagePosition,
      visible: visible2,
      width
    },
    restAttributes,
    rootElementRef,
    validationErrors,
    validationMessageGuid,
    validationMessageTarget,
    widgetRef
  } = viewModel;
  return normalizeProps(createComponentVNode(2, Widget2, _extends({
    rootElementRef,
    aria,
    classes,
    activeStateEnabled,
    focusStateEnabled,
    hoverStateEnabled,
    accessKey,
    className,
    rtlEnabled,
    hint,
    disabled,
    height,
    width,
    onFocusIn,
    onClick,
    onKeyDown,
    tabIndex,
    visible: visible2
  }, restAttributes, {
    children: createFragment([children, isValidationMessageVisible && createComponentVNode(2, ValidationMessage2, {
      validationErrors,
      mode: validationMessageMode,
      positionSide: validationMessagePosition,
      rtlEnabled,
      target: validationMessageTarget,
      boundary: validationMessageTarget,
      visualContainer: validationMessageTarget,
      contentId: validationMessageGuid
    })], 0)
  }), null, widgetRef));
};
var EditorProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(BaseWidgetProps), Object.getOwnPropertyDescriptors({
  readOnly: false,
  name: "",
  validationError: null,
  validationErrors: null,
  validationMessageMode: "auto",
  validationMessagePosition: "bottom",
  validationStatus: "valid",
  isValid: true,
  isDirty: false,
  inputAttr: Object.freeze({}),
  defaultValue: null,
  valueChange: () => {
  }
})));
var EditorPropsType = {
  get readOnly() {
    return EditorProps.readOnly;
  },
  get name() {
    return EditorProps.name;
  },
  get validationError() {
    return EditorProps.validationError;
  },
  get validationErrors() {
    return EditorProps.validationErrors;
  },
  get validationMessageMode() {
    return EditorProps.validationMessageMode;
  },
  get validationMessagePosition() {
    return EditorProps.validationMessagePosition;
  },
  get validationStatus() {
    return EditorProps.validationStatus;
  },
  get isValid() {
    return EditorProps.isValid;
  },
  get isDirty() {
    return EditorProps.isDirty;
  },
  get inputAttr() {
    return EditorProps.inputAttr;
  },
  get defaultValue() {
    return EditorProps.defaultValue;
  },
  get valueChange() {
    return EditorProps.valueChange;
  },
  get className() {
    return EditorProps.className;
  },
  get activeStateEnabled() {
    return EditorProps.activeStateEnabled;
  },
  get disabled() {
    return EditorProps.disabled;
  },
  get focusStateEnabled() {
    return EditorProps.focusStateEnabled;
  },
  get hoverStateEnabled() {
    return EditorProps.hoverStateEnabled;
  },
  get tabIndex() {
    return EditorProps.tabIndex;
  },
  get visible() {
    return EditorProps.visible;
  },
  get aria() {
    return WidgetProps.aria;
  },
  get classes() {
    return WidgetProps.classes;
  }
};
var Editor3 = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.widgetRef = createRef();
    this.rootElementRef = createRef();
    this.__getterCache = {};
    this.state = {
      validationMessageGuid: `dx-${new guid_default()}`,
      isValidationMessageVisible: false,
      value: void 0 !== this.props.value ? this.props.value : this.props.defaultValue
    };
    this.updateValidationMessageVisibility = this.updateValidationMessageVisibility.bind(this);
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.onFocusIn = this.onFocusIn.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.updateValidationMessageVisibility, [this.props.isValid, this.props.validationStatus, this.props.validationError, this.props.validationErrors]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props.isValid, this.props.validationStatus, this.props.validationError, this.props.validationErrors]);
  }
  updateValidationMessageVisibility() {
    this.setState((__state_argument) => ({
      isValidationMessageVisible: this.shouldShowValidationMessage
    }));
  }
  onFocusIn(event) {
    const {
      onFocusIn
    } = this.props;
    null === onFocusIn || void 0 === onFocusIn || onFocusIn(event);
  }
  get cssClasses() {
    return `${getCssClasses3(_extends({}, this.props, { value: void 0 !== this.props.value ? this.props.value : this.state.value }))}`;
  }
  get shouldShowValidationMessage() {
    const {
      isValid,
      validationStatus
    } = this.props;
    const validationErrors = this.validationErrors ?? [];
    const isEditorValid = isValid && "invalid" !== validationStatus;
    return !isEditorValid && validationErrors.length > 0;
  }
  get aria() {
    const {
      isValid,
      readOnly
    } = this.props;
    const result2 = {
      readonly: readOnly ? "true" : "false",
      invalid: !isValid ? "true" : "false"
    };
    if (this.shouldShowValidationMessage) {
      result2.describedBy = this.state.validationMessageGuid;
    }
    return _extends({}, result2, this.props.aria);
  }
  get validationErrors() {
    if (void 0 !== this.__getterCache.validationErrors) {
      return this.__getterCache.validationErrors;
    }
    return this.__getterCache.validationErrors = (() => {
      const {
        validationError,
        validationErrors
      } = this.props;
      let allValidationErrors = validationErrors && [...validationErrors];
      if (!allValidationErrors && validationError) {
        allValidationErrors = [_extends({}, validationError)];
      }
      return allValidationErrors;
    })();
  }
  get validationMessageTarget() {
    var _this$rootElementRef;
    return null === (_this$rootElementRef = this.rootElementRef) || void 0 === _this$rootElementRef ? void 0 : _this$rootElementRef.current;
  }
  get restAttributes() {
    const _this$props$value = _extends({}, this.props, {
      value: void 0 !== this.props.value ? this.props.value : this.state.value
    }), restProps = _objectWithoutPropertiesLoose(_this$props$value, _excluded10);
    return restProps;
  }
  focus() {
    this.widgetRef.current.focus();
  }
  blur() {
    this.widgetRef.current.blur();
  }
  componentWillUpdate(nextProps, nextState, context2) {
    super.componentWillUpdate();
    if (this.props.validationError !== nextProps.validationError || this.props.validationErrors !== nextProps.validationErrors) {
      this.__getterCache.validationErrors = void 0;
    }
  }
  render() {
    const props = this.props;
    return viewFunction8({
      props: _extends({}, props, {
        value: void 0 !== this.props.value ? this.props.value : this.state.value
      }),
      validationMessageGuid: this.state.validationMessageGuid,
      isValidationMessageVisible: this.state.isValidationMessageVisible,
      rootElementRef: this.rootElementRef,
      widgetRef: this.widgetRef,
      onFocusIn: this.onFocusIn,
      cssClasses: this.cssClasses,
      shouldShowValidationMessage: this.shouldShowValidationMessage,
      aria: this.aria,
      validationErrors: this.validationErrors,
      validationMessageTarget: this.validationMessageTarget,
      restAttributes: this.restAttributes
    });
  }
};
Editor3.defaultProps = EditorPropsType;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/editors/check_box/check_box_icon.js
var _excluded11 = ["size"];
var viewFunction9 = (viewModel) => {
  const {
    cssStyles,
    elementRef
  } = viewModel;
  return createVNode(1, "span", "dx-checkbox-icon", null, 1, {
    style: normalizeStyles(cssStyles)
  }, null, elementRef);
};
var CheckBoxIconProps = {};
var CheckBoxIcon = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.elementRef = createRef();
    this.__getterCache = {};
  }
  get cssStyles() {
    if (void 0 !== this.__getterCache.cssStyles) {
      return this.__getterCache.cssStyles;
    }
    return this.__getterCache.cssStyles = (() => {
      const {
        size
      } = this.props;
      const fontSize = normalizeStyleProp("fontSize", size);
      return {
        fontSize
      };
    })();
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded11);
    return restProps;
  }
  componentWillUpdate(nextProps, nextState, context2) {
    if (this.props.size !== nextProps.size) {
      this.__getterCache.cssStyles = void 0;
    }
  }
  render() {
    const props = this.props;
    return viewFunction9({
      props: _extends({}, props),
      elementRef: this.elementRef,
      cssStyles: this.cssStyles,
      restAttributes: this.restAttributes
    });
  }
};
CheckBoxIcon.defaultProps = CheckBoxIconProps;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/editors/check_box/check_box.js
var _excluded12 = ["accessKey", "activeStateEnabled", "aria", "className", "defaultValue", "disabled", "enableThreeStateBehavior", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "iconSize", "inputAttr", "isDirty", "isValid", "name", "onClick", "onFocusIn", "onKeyDown", "readOnly", "rtlEnabled", "saveValueChangeEvent", "tabIndex", "text", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "value", "valueChange", "visible", "width"];
var getCssClasses4 = (model) => {
  const {
    text,
    value: value2
  } = model;
  const checked = value2;
  const indeterminate = null === checked;
  const classesMap = {
    "dx-checkbox": true,
    "dx-checkbox-checked": true === checked,
    "dx-checkbox-has-text": !!text,
    "dx-checkbox-indeterminate": indeterminate
  };
  return combineClasses(classesMap);
};
var viewFunction10 = (viewModel) => {
  const {
    aria,
    cssClasses: classes,
    editorRef,
    keyDown: onKeyDown,
    onWidgetClick: onClick,
    props: {
      accessKey,
      activeStateEnabled,
      className,
      disabled,
      focusStateEnabled,
      height,
      hint,
      hoverStateEnabled,
      iconSize,
      isValid,
      name: name2,
      onFocusIn,
      readOnly,
      rtlEnabled,
      tabIndex,
      text,
      validationError,
      validationErrors,
      validationMessageMode,
      validationMessagePosition,
      validationStatus,
      value: value2,
      visible: visible2,
      width
    },
    restAttributes
  } = viewModel;
  return normalizeProps(createComponentVNode(2, Editor3, _extends({
    aria,
    classes,
    onClick,
    onKeyDown,
    accessKey,
    activeStateEnabled,
    focusStateEnabled,
    hoverStateEnabled,
    className,
    disabled,
    readOnly,
    hint,
    height,
    width,
    rtlEnabled,
    tabIndex,
    visible: visible2,
    validationError,
    validationErrors,
    validationMessageMode,
    validationMessagePosition,
    validationStatus,
    isValid,
    onFocusIn
  }, restAttributes, {
    children: createFragment([normalizeProps(createVNode(64, "input", null, null, 1, _extends({
      type: "hidden",
      value: `${value2}`
    }, name2 && {
      name: name2
    }))), createVNode(1, "div", "dx-checkbox-container", [createComponentVNode(2, CheckBoxIcon, {
      size: iconSize,
      isChecked: true === value2
    }), text && createVNode(1, "span", "dx-checkbox-text", text, 0)], 0)], 4)
  }), null, editorRef));
};
var CheckBoxProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(EditorProps), Object.getOwnPropertyDescriptors({
  text: "",
  enableThreeStateBehavior: false,
  activeStateEnabled: true,
  hoverStateEnabled: true,
  get focusStateEnabled() {
    return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
  },
  defaultValue: false,
  valueChange: () => {
  }
})));
var CheckBoxPropsType = {
  get text() {
    return CheckBoxProps.text;
  },
  get enableThreeStateBehavior() {
    return CheckBoxProps.enableThreeStateBehavior;
  },
  get activeStateEnabled() {
    return CheckBoxProps.activeStateEnabled;
  },
  get hoverStateEnabled() {
    return CheckBoxProps.hoverStateEnabled;
  },
  get focusStateEnabled() {
    return CheckBoxProps.focusStateEnabled;
  },
  get defaultValue() {
    return CheckBoxProps.defaultValue;
  },
  get valueChange() {
    return CheckBoxProps.valueChange;
  },
  get readOnly() {
    return CheckBoxProps.readOnly;
  },
  get name() {
    return CheckBoxProps.name;
  },
  get validationError() {
    return CheckBoxProps.validationError;
  },
  get validationErrors() {
    return CheckBoxProps.validationErrors;
  },
  get validationMessageMode() {
    return CheckBoxProps.validationMessageMode;
  },
  get validationMessagePosition() {
    return CheckBoxProps.validationMessagePosition;
  },
  get validationStatus() {
    return CheckBoxProps.validationStatus;
  },
  get isValid() {
    return CheckBoxProps.isValid;
  },
  get isDirty() {
    return CheckBoxProps.isDirty;
  },
  get inputAttr() {
    return CheckBoxProps.inputAttr;
  },
  get className() {
    return CheckBoxProps.className;
  },
  get disabled() {
    return CheckBoxProps.disabled;
  },
  get tabIndex() {
    return CheckBoxProps.tabIndex;
  },
  get visible() {
    return CheckBoxProps.visible;
  },
  get aria() {
    return WidgetProps.aria;
  }
};
var CheckBox2 = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.editorRef = createRef();
    this.state = {
      value: void 0 !== this.props.value ? this.props.value : this.props.defaultValue
    };
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.onWidgetClick = this.onWidgetClick.bind(this);
    this.keyDown = this.keyDown.bind(this);
  }
  createEffects() {
    return [createReRenderEffect()];
  }
  onWidgetClick(event) {
    const {
      enableThreeStateBehavior,
      readOnly,
      saveValueChangeEvent
    } = this.props;
    if (!readOnly) {
      null === saveValueChangeEvent || void 0 === saveValueChangeEvent || saveValueChangeEvent(event);
      if (enableThreeStateBehavior) {
        let __newValue;
        this.setState((__state_argument) => {
          __newValue = null === (void 0 !== this.props.value ? this.props.value : __state_argument.value) || (!(void 0 !== this.props.value ? this.props.value : __state_argument.value) ? null : false);
          return {
            value: __newValue
          };
        });
        this.props.valueChange(__newValue);
      } else {
        let __newValue;
        this.setState((__state_argument) => {
          __newValue = !((void 0 !== this.props.value ? this.props.value : __state_argument.value) ?? false);
          return {
            value: __newValue
          };
        });
        this.props.valueChange(__newValue);
      }
    }
  }
  keyDown(e) {
    const {
      onKeyDown
    } = this.props;
    const {
      keyName,
      originalEvent,
      which
    } = e;
    const result2 = null === onKeyDown || void 0 === onKeyDown ? void 0 : onKeyDown(e);
    if (null !== result2 && void 0 !== result2 && result2.cancel) {
      return result2;
    }
    if ("space" === keyName || "space" === which) {
      originalEvent.preventDefault();
      this.onWidgetClick(originalEvent);
    }
    return;
  }
  get cssClasses() {
    return getCssClasses4(_extends({}, this.props, {
      value: void 0 !== this.props.value ? this.props.value : this.state.value
    }));
  }
  get aria() {
    const checked = true === (void 0 !== this.props.value ? this.props.value : this.state.value);
    const indeterminate = null === (void 0 !== this.props.value ? this.props.value : this.state.value);
    const result2 = {
      role: "checkbox",
      checked: indeterminate ? "mixed" : `${checked}`
    };
    return _extends({}, result2, this.props.aria);
  }
  get restAttributes() {
    const _this$props$value = _extends({}, this.props, {
      value: void 0 !== this.props.value ? this.props.value : this.state.value
    }), restProps = _objectWithoutPropertiesLoose(_this$props$value, _excluded12);
    return restProps;
  }
  focus() {
    this.editorRef.current.focus();
  }
  blur() {
    this.editorRef.current.blur();
  }
  render() {
    const props = this.props;
    return viewFunction10({
      props: _extends({}, props, {
        value: void 0 !== this.props.value ? this.props.value : this.state.value
      }),
      editorRef: this.editorRef,
      onWidgetClick: this.onWidgetClick,
      keyDown: this.keyDown,
      cssClasses: this.cssClasses,
      aria: this.aria,
      restAttributes: this.restAttributes
    });
  }
};
function __processTwoWayProps(defaultProps) {
  const twoWayProps = ["value"];
  return Object.keys(defaultProps).reduce((props, propName) => {
    const propValue = defaultProps[propName];
    const defaultPropName = twoWayProps.some((p2) => p2 === propName) ? "default" + propName.charAt(0).toUpperCase() + propName.slice(1) : propName;
    props[defaultPropName] = propValue;
    return props;
  }, {});
}
CheckBox2.defaultProps = CheckBoxPropsType;
var __defaultOptionRules2 = [];
function defaultOptions2(rule) {
  __defaultOptionRules2.push(rule);
  CheckBox2.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(CheckBox2.defaultProps), Object.getOwnPropertyDescriptors(__processTwoWayProps(convertRulesToOptions(__defaultOptionRules2)))));
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/editors/check_box/check_box.j.js
var CheckBox3 = class extends CheckBox {
  getProps() {
    const props = super.getProps();
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    return props;
  }
  focus() {
    var _this$viewRef;
    return null === (_this$viewRef = this.viewRef) || void 0 === _this$viewRef ? void 0 : _this$viewRef.focus(...arguments);
  }
  blur() {
    var _this$viewRef2;
    return null === (_this$viewRef2 = this.viewRef) || void 0 === _this$viewRef2 ? void 0 : _this$viewRef2.blur(...arguments);
  }
  _getActionConfigs() {
    return {
      onFocusIn: {},
      onClick: {}
    };
  }
  get _propsInfo() {
    return {
      twoWay: [
        ["value", "defaultValue", "valueChange"]
      ],
      allowNull: ["defaultValue", "validationError", "validationErrors", "value"],
      elements: [],
      templates: [],
      props: ["text", "iconSize", "enableThreeStateBehavior", "activeStateEnabled", "hoverStateEnabled", "focusStateEnabled", "saveValueChangeEvent", "defaultValue", "valueChange", "readOnly", "name", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "isValid", "isDirty", "inputAttr", "onFocusIn", "className", "accessKey", "disabled", "height", "hint", "onClick", "onKeyDown", "rtlEnabled", "tabIndex", "visible", "width", "aria", "value"]
    };
  }
  get _viewComponent() {
    return CheckBox2;
  }
};
component_registrator_default("dxCheckBox", CheckBox3);
CheckBox3.defaultOptions = defaultOptions2;

// ../../../../../../node_modules/devextreme/esm/ui/check_box.js
var check_box_default = CheckBox3;

// ../../../../../../node_modules/devextreme/esm/localization/ldml/date.formatter.js
function leftPad(text, length) {
  while (text.length < length) {
    text = "0" + text;
  }
  return text;
}
var FORMAT_TYPES = {
  3: "abbreviated",
  4: "wide",
  5: "narrow"
};
var LDML_FORMATTERS = {
  y: function(date, count, useUtc) {
    let year = date[useUtc ? "getUTCFullYear" : "getFullYear"]();
    if (2 === count) {
      year %= 100;
    }
    return leftPad(year.toString(), count);
  },
  M: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, "format")[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  L: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, "standalone")[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  Q: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const quarter = Math.floor(month / 3);
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getQuarterNames(formatType)[quarter];
    }
    return leftPad((quarter + 1).toString(), Math.min(count, 2));
  },
  E: function(date, count, useUtc, dateParts) {
    const day = date[useUtc ? "getUTCDay" : "getDay"]();
    const formatType = FORMAT_TYPES[count < 3 ? 3 : count];
    return dateParts.getDayNames(formatType)[day];
  },
  a: function(date, count, useUtc, dateParts) {
    const hours = date[useUtc ? "getUTCHours" : "getHours"]();
    const period = hours < 12 ? 0 : 1;
    const formatType = FORMAT_TYPES[count];
    return dateParts.getPeriodNames(formatType)[period];
  },
  d: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCDate" : "getDate"]().toString(), Math.min(count, 2));
  },
  H: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCHours" : "getHours"]().toString(), Math.min(count, 2));
  },
  h: function(date, count, useUtc) {
    const hours = date[useUtc ? "getUTCHours" : "getHours"]();
    return leftPad((hours % 12 || 12).toString(), Math.min(count, 2));
  },
  m: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCMinutes" : "getMinutes"]().toString(), Math.min(count, 2));
  },
  s: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCSeconds" : "getSeconds"]().toString(), Math.min(count, 2));
  },
  S: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCMilliseconds" : "getMilliseconds"]().toString(), 3).substr(0, count);
  },
  x: function(date, count, useUtc) {
    const timezoneOffset = useUtc ? 0 : date.getTimezoneOffset();
    const signPart = timezoneOffset > 0 ? "-" : "+";
    const timezoneOffsetAbs = Math.abs(timezoneOffset);
    const hours = Math.floor(timezoneOffsetAbs / 60);
    const minutes = timezoneOffsetAbs % 60;
    const hoursPart = leftPad(hours.toString(), 2);
    const minutesPart = leftPad(minutes.toString(), 2);
    return signPart + hoursPart + (count >= 3 ? ":" : "") + (count > 1 || minutes ? minutesPart : "");
  },
  X: function(date, count, useUtc) {
    if (useUtc || !date.getTimezoneOffset()) {
      return "Z";
    }
    return LDML_FORMATTERS.x(date, count, useUtc);
  },
  Z: function(date, count, useUtc) {
    return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc);
  }
};
var getFormatter3 = function(format2, dateParts) {
  return function(date) {
    let charIndex;
    let formatter;
    let char;
    let charCount = 0;
    let isEscaping = false;
    let isCurrentCharEqualsNext;
    let result2 = "";
    if (!date) {
      return null;
    }
    if (!format2) {
      return date;
    }
    const useUtc = "Z" === format2[format2.length - 1] || "'Z'" === format2.slice(-3);
    for (charIndex = 0; charIndex < format2.length; charIndex++) {
      char = format2[charIndex];
      formatter = LDML_FORMATTERS[char];
      isCurrentCharEqualsNext = char === format2[charIndex + 1];
      charCount++;
      if (!isCurrentCharEqualsNext) {
        if (formatter && !isEscaping) {
          result2 += formatter(date, charCount, useUtc, dateParts);
        }
        charCount = 0;
      }
      if ("'" === char && !isCurrentCharEqualsNext) {
        isEscaping = !isEscaping;
      } else if (isEscaping || !formatter) {
        result2 += char;
      }
      if ("'" === char && isCurrentCharEqualsNext) {
        charIndex++;
      }
    }
    return result2;
  };
};

// ../../../../../../node_modules/devextreme/esm/localization/ldml/date.format.js
var FORMAT_SEPARATORS = " .,:;/\\<>()-[]،";
var checkDigit = function(char) {
  const code = char && number_default2.convertDigits(char, false).charCodeAt(0);
  const zeroCode = number_default2.convertDigits("0", false).charCodeAt(0);
  return zeroCode <= code && code < zeroCode + 10;
};
var checkPatternContinue = function(text, patterns, index2, isDigit) {
  const char = text[index2];
  const nextChar = text[index2 + 1];
  if (!isDigit) {
    if ("." === char || " " === char && ". m." === text.slice(index2 - 1, index2 + 3)) {
      return true;
    }
    if ("-" === char && !checkDigit(nextChar)) {
      return true;
    }
  }
  const isDigitChanged = isDigit && patterns.some((pattern) => text[index2] !== pattern[index2]);
  return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char) && (!isDigit || isDigitChanged);
};
var getPatternStartIndex = function(defaultPattern, index2) {
  if (!checkDigit(defaultPattern[index2])) {
    while (index2 > 0 && !checkDigit(defaultPattern[index2 - 1]) && ("." === defaultPattern[index2 - 1] || FORMAT_SEPARATORS.indexOf(defaultPattern[index2 - 1]) < 0)) {
      index2--;
    }
  }
  return index2;
};
var getDifference = function(defaultPattern, patterns, processedIndexes, isDigit) {
  let i = 0;
  const result2 = [];
  const patternsFilter = function(pattern) {
    return defaultPattern[i] !== pattern[i] && (void 0 === isDigit || checkDigit(defaultPattern[i]) === isDigit);
  };
  if (!Array.isArray(patterns)) {
    patterns = [patterns];
  }
  for (i = 0; i < defaultPattern.length; i++) {
    if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {
      i = getPatternStartIndex(defaultPattern, i);
      do {
        isDigit = checkDigit(defaultPattern[i]);
        if (!result2.length && !isDigit && checkDigit(patterns[0][i])) {
          break;
        }
        result2.push(i);
        processedIndexes.unshift(i);
        i++;
      } while (defaultPattern[i] && checkPatternContinue(defaultPattern, patterns, i, isDigit));
      break;
    }
  }
  if (1 === result2.length && ("0" === defaultPattern[processedIndexes[0] - 1] || "٠" === defaultPattern[processedIndexes[0] - 1])) {
    processedIndexes.unshift(processedIndexes[0] - 1);
  }
  return result2;
};
var replaceCharsCore = function(pattern, indexes, char, patternPositions) {
  const baseCharIndex = indexes[0];
  const patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;
  indexes.forEach(function(_, index2) {
    pattern = pattern.substr(0, patternIndex + index2) + (char.length > 1 ? char[index2] : char) + pattern.substr(patternIndex + index2 + 1);
  });
  if (1 === indexes.length) {
    pattern = pattern.replace("0" + char, char + char);
    pattern = pattern.replace("٠" + char, char + char);
  }
  return pattern;
};
var replaceChars = function(pattern, indexes, char, patternPositions) {
  let i;
  let index2;
  let patternIndex;
  if (!checkDigit(pattern[indexes[0]] || "0")) {
    const letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);
    while (indexes.length > letterCount) {
      index2 = indexes.pop();
      patternIndex = patternPositions[index2];
      patternPositions[index2] = -1;
      for (i = index2 + 1; i < patternPositions.length; i++) {
        patternPositions[i]--;
      }
      pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1);
    }
    index2 = indexes[indexes.length - 1] + 1, patternIndex = index2 < patternPositions.length ? patternPositions[index2] : index2;
    while (indexes.length < letterCount) {
      indexes.push(indexes[indexes.length - 1] + 1);
      for (i = index2; i < patternPositions.length; i++) {
        patternPositions[i]++;
      }
      pattern = pattern.substr(0, patternIndex) + " " + pattern.substr(patternIndex);
    }
  }
  pattern = replaceCharsCore(pattern, indexes, char, patternPositions);
  return pattern;
};
var formatValue = function(value2, formatter) {
  if (Array.isArray(value2)) {
    return value2.map(function(value3) {
      return (formatter(value3) || "").toString();
    });
  }
  return (formatter(value2) || "").toString();
};
var ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;
var escapeChars = function(pattern, defaultPattern, processedIndexes, patternPositions) {
  const escapeIndexes = defaultPattern.split("").map(function(char, index2) {
    if (processedIndexes.indexOf(index2) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || "'" === char)) {
      return patternPositions[index2];
    }
    return -1;
  });
  pattern = pattern.split("").map(function(char, index2) {
    let result2 = char;
    const isCurrentCharEscaped = escapeIndexes.indexOf(index2) >= 0;
    const isPrevCharEscaped = index2 > 0 && escapeIndexes.indexOf(index2 - 1) >= 0;
    const isNextCharEscaped = escapeIndexes.indexOf(index2 + 1) >= 0;
    if (isCurrentCharEscaped) {
      if (!isPrevCharEscaped) {
        result2 = "'" + result2;
      }
      if (!isNextCharEscaped) {
        result2 += "'";
      }
    }
    return result2;
  }).join("");
  return pattern;
};
var getFormat2 = function(formatter) {
  const processedIndexes = [];
  const defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter);
  const patternPositions = defaultPattern.split("").map(function(_, index2) {
    return index2;
  });
  let result2 = defaultPattern;
  const replacedPatterns = {};
  const datePatterns = [{
    date: new Date(2009, 8, 8, 6, 5, 4, 111),
    pattern: "S"
  }, {
    date: new Date(2009, 8, 8, 6, 5, 2),
    pattern: "s"
  }, {
    date: new Date(2009, 8, 8, 6, 2, 4),
    pattern: "m"
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: "H",
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 2, 5, 4),
    pattern: "h",
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: "a",
    isDigit: false
  }, {
    date: new Date(2009, 8, 1, 6, 5, 4),
    pattern: "d"
  }, {
    date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],
    pattern: "E"
  }, {
    date: new Date(2009, 9, 6, 6, 5, 4),
    pattern: "M"
  }, {
    date: new Date(1998, 8, 8, 6, 5, 4),
    pattern: "y"
  }];
  if (!result2) {
    return;
  }
  datePatterns.forEach(function(test) {
    const diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit);
    const pattern = "M" === test.pattern && !replacedPatterns.d ? "L" : test.pattern;
    result2 = replaceChars(result2, diff, pattern, patternPositions);
    replacedPatterns[pattern] = diff.length;
  });
  result2 = escapeChars(result2, defaultPattern, processedIndexes, patternPositions);
  if (processedIndexes.length) {
    return result2;
  }
};

// ../../../../../../node_modules/devextreme/esm/localization/ldml/date.parser.js
var FORMAT_TYPES2 = {
  3: "abbreviated",
  4: "wide",
  5: "narrow"
};
var monthRegExpGenerator = function(count, dateParts) {
  if (count > 2) {
    return Object.keys(FORMAT_TYPES2).map(function(count2) {
      return ["format", "standalone"].map(function(type2) {
        return dateParts.getMonthNames(FORMAT_TYPES2[count2], type2).join("|");
      }).join("|");
    }).join("|");
  }
  return 2 === count ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
};
var PATTERN_REGEXPS = {
  ":": function(count, dateParts) {
    const countSuffix = count > 1 ? `{${count}}` : "";
    let timeSeparator = escapeRegExp(dateParts.getTimeSeparator());
    ":" !== timeSeparator && (timeSeparator = `${timeSeparator}|:`);
    return `${timeSeparator}${countSuffix}`;
  },
  y: function(count) {
    return 2 === count ? `[0-9]{${count}}` : "[0-9]+?";
  },
  M: monthRegExpGenerator,
  L: monthRegExpGenerator,
  Q: function(count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES2[count], "format").join("|");
    }
    return "0?[1-4]";
  },
  E: function(count, dateParts) {
    return "\\D*";
  },
  a: function(count, dateParts) {
    return dateParts.getPeriodNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format").join("|");
  },
  d: function(count) {
    return 2 === count ? "3[01]|[12][0-9]|0?[1-9]" : "0??[1-9]|[12][0-9]|3[01]";
  },
  H: function(count) {
    return 2 === count ? "2[0-3]|1[0-9]|0?[0-9]" : "0??[0-9]|1[0-9]|2[0-3]";
  },
  h: function(count) {
    return 2 === count ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
  },
  m: function(count) {
    return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  s: function(count) {
    return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  S: function(count) {
    return `[0-9]{1,${count}}`;
  },
  w: function(count) {
    return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  x: function(count) {
    return 3 === count ? "[+-](?:2[0-3]|[01][0-9]):(?:[0-5][0-9])|Z" : "[+-](?:2[0-3]|[01][0-9])(?:[0-5][0-9])|Z";
  }
};
var parseNumber = Number;
var caseInsensitiveIndexOf = function(array, value2) {
  return array.map((item) => item.toLowerCase()).indexOf(value2.toLowerCase());
};
var monthPatternParser = function(text, count, dateParts) {
  if (count > 2) {
    return ["format", "standalone"].map(function(type2) {
      return Object.keys(FORMAT_TYPES2).map(function(count2) {
        const monthNames = dateParts.getMonthNames(FORMAT_TYPES2[count2], type2);
        return caseInsensitiveIndexOf(monthNames, text);
      });
    }).reduce(function(a, b) {
      return a.concat(b);
    }).filter(function(index2) {
      return index2 >= 0;
    })[0];
  }
  return parseNumber(text) - 1;
};
var PATTERN_PARSERS = {
  y: function(text, count) {
    const year = parseNumber(text);
    if (2 === count) {
      return year < 30 ? 2e3 + year : 1900 + year;
    }
    return year;
  },
  M: monthPatternParser,
  L: monthPatternParser,
  Q: function(text, count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES2[count], "format").indexOf(text);
    }
    return parseNumber(text) - 1;
  },
  E: function(text, count, dateParts) {
    const dayNames = dateParts.getDayNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format");
    return caseInsensitiveIndexOf(dayNames, text);
  },
  a: function(text, count, dateParts) {
    const periodNames = dateParts.getPeriodNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format");
    return caseInsensitiveIndexOf(periodNames, text);
  },
  d: parseNumber,
  H: parseNumber,
  h: parseNumber,
  m: parseNumber,
  s: parseNumber,
  S: function(text, count) {
    count = Math.max(count, 3);
    text = text.slice(0, 3);
    while (count < 3) {
      text += "0";
      count++;
    }
    return parseNumber(text);
  }
};
var ORDERED_PATTERNS = ["y", "M", "d", "h", "m", "s", "S"];
var PATTERN_SETTERS = {
  y: "setFullYear",
  M: "setMonth",
  L: "setMonth",
  a: function(date, value2, datePartValues) {
    let hours = date.getHours();
    const hourPartValue = datePartValues.h;
    if (void 0 !== hourPartValue && hourPartValue !== hours) {
      hours--;
    }
    if (!value2 && 12 === hours) {
      hours = 0;
    } else if (value2 && 12 !== hours) {
      hours += 12;
    }
    date.setHours(hours);
  },
  d: "setDate",
  H: "setHours",
  h: "setHours",
  m: "setMinutes",
  s: "setSeconds",
  S: "setMilliseconds"
};
var getSameCharCount = function(text, index2) {
  const char = text[index2];
  if (!char) {
    return 0;
  }
  let count = 0;
  do {
    index2++;
    count++;
  } while (text[index2] === char);
  return count;
};
var createPattern = function(char, count) {
  let result2 = "";
  for (let i = 0; i < count; i++) {
    result2 += char;
  }
  return result2;
};
var getRegExpInfo = function(format2, dateParts) {
  let regexpText = "";
  let stubText = "";
  let isEscaping;
  const patterns = [];
  const addPreviousStub = function() {
    if (stubText) {
      patterns.push(`'${stubText}'`);
      regexpText += `${escapeRegExp(stubText)})`;
      stubText = "";
    }
  };
  for (let i = 0; i < format2.length; i++) {
    const char = format2[i];
    const isEscapeChar = "'" === char;
    const regexpPart = PATTERN_REGEXPS[char];
    if (isEscapeChar) {
      isEscaping = !isEscaping;
      if ("'" !== format2[i - 1]) {
        continue;
      }
    }
    if (regexpPart && !isEscaping) {
      const count = getSameCharCount(format2, i);
      const pattern = createPattern(char, count);
      addPreviousStub();
      patterns.push(pattern);
      regexpText += `(${regexpPart(count, dateParts)})`;
      i += count - 1;
    } else {
      if (!stubText) {
        regexpText += "(";
      }
      stubText += char;
    }
  }
  addPreviousStub();
  if (!isPossibleForParsingFormat(patterns)) {
    logger.warn(`The following format may be parsed incorrectly: ${format2}.`);
  }
  return {
    patterns,
    regexp: new RegExp(`^${regexpText}$`, "i")
  };
};
var digitFieldSymbols = ["d", "H", "h", "m", "s", "w", "M", "L", "Q"];
var isPossibleForParsingFormat = function(patterns) {
  const isDigitPattern = (pattern) => {
    if (!pattern) {
      return false;
    }
    const char = pattern[0];
    return ["y", "S"].includes(char) || digitFieldSymbols.includes(char) && pattern.length < 3;
  };
  let possibleForParsing = true;
  let ambiguousDigitPatternsCount = 0;
  return patterns.every((pattern, index2, patterns2) => {
    if (isDigitPattern(pattern)) {
      if (((pattern2) => "S" !== pattern2[0] && 2 !== pattern2.length)(pattern)) {
        possibleForParsing = ++ambiguousDigitPatternsCount < 2;
      }
      if (!isDigitPattern(patterns2[index2 + 1])) {
        ambiguousDigitPatternsCount = 0;
      }
    }
    return possibleForParsing;
  });
};
var getPatternSetters = function() {
  return PATTERN_SETTERS;
};
var setPatternPart = function(date, pattern, text, dateParts, datePartValues) {
  const patternChar = pattern[0];
  const partSetter = PATTERN_SETTERS[patternChar];
  const partParser = PATTERN_PARSERS[patternChar];
  if (partSetter && partParser) {
    const value2 = partParser(text, pattern.length, dateParts);
    datePartValues[pattern] = value2;
    if (date[partSetter]) {
      date[partSetter](value2);
    } else {
      partSetter(date, value2, datePartValues);
    }
  }
};
var setPatternPartFromNow = function(date, pattern, now) {
  const setterName = PATTERN_SETTERS[pattern];
  const getterName = "g" + setterName.substr(1);
  const value2 = now[getterName]();
  date[setterName](value2);
};
var getShortPatterns = function(fullPatterns) {
  return fullPatterns.map(function(pattern) {
    if ("'" === pattern[0]) {
      return "";
    } else {
      return "H" === pattern[0] ? "h" : pattern[0];
    }
  });
};
var getMaxOrderedPatternIndex = function(patterns) {
  const indexes = patterns.map(function(pattern) {
    return ORDERED_PATTERNS.indexOf(pattern);
  });
  return Math.max.apply(Math, indexes);
};
var getOrderedFormatPatterns = function(formatPatterns) {
  const otherPatterns = formatPatterns.filter(function(pattern) {
    return ORDERED_PATTERNS.indexOf(pattern) < 0;
  });
  return ORDERED_PATTERNS.concat(otherPatterns);
};
var getParser = function(format2, dateParts) {
  const regExpInfo = getRegExpInfo(format2, dateParts);
  return function(text) {
    const regExpResult = regExpInfo.regexp.exec(text);
    if (regExpResult) {
      const now = /* @__PURE__ */ new Date();
      const date = new Date(now.getFullYear(), 0, 1);
      const formatPatterns = getShortPatterns(regExpInfo.patterns);
      const maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);
      const orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);
      const datePartValues = {};
      orderedFormatPatterns.forEach(function(pattern, index2) {
        if (!pattern || index2 < ORDERED_PATTERNS.length && index2 > maxPatternIndex) {
          return;
        }
        const patternIndex = formatPatterns.indexOf(pattern);
        if (patternIndex >= 0) {
          const regExpPattern = regExpInfo.patterns[patternIndex];
          const regExpText = regExpResult[patternIndex + 1];
          setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues);
        } else {
          setPatternPartFromNow(date, pattern, now);
        }
      });
      return date;
    }
    return null;
  };
};

// ../../../../../../node_modules/devextreme/esm/localization/default_date_names.js
var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
var DAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var PERIODS = ["AM", "PM"];
var QUARTERS = ["Q1", "Q2", "Q3", "Q4"];
var cutCaptions = (captions, format2) => {
  const lengthByFormat = {
    abbreviated: 3,
    short: 2,
    narrow: 1
  };
  return map(captions, (caption) => caption.substr(0, lengthByFormat[format2]));
};
var default_date_names_default = {
  getMonthNames: function(format2) {
    return cutCaptions(MONTHS, format2);
  },
  getDayNames: function(format2) {
    return cutCaptions(DAYS, format2);
  },
  getQuarterNames: function(format2) {
    return QUARTERS;
  },
  getPeriodNames: function(format2) {
    return PERIODS;
  }
};

// ../../../../../../node_modules/devextreme/esm/localization/cldr-data/first_day_of_week_data.js
var first_day_of_week_data_default = {
  "af-NA": 1,
  agq: 1,
  ak: 1,
  ar: 6,
  "ar-EH": 1,
  "ar-ER": 1,
  "ar-KM": 1,
  "ar-LB": 1,
  "ar-MA": 1,
  "ar-MR": 1,
  "ar-PS": 1,
  "ar-SO": 1,
  "ar-SS": 1,
  "ar-TD": 1,
  "ar-TN": 1,
  asa: 1,
  ast: 1,
  az: 1,
  "az-Cyrl": 1,
  bas: 1,
  be: 1,
  bem: 1,
  bez: 1,
  bg: 1,
  bm: 1,
  br: 1,
  bs: 1,
  "bs-Cyrl": 1,
  ca: 1,
  ce: 1,
  cgg: 1,
  ckb: 6,
  cs: 1,
  cy: 1,
  da: 1,
  de: 1,
  dje: 1,
  dsb: 1,
  dua: 1,
  dyo: 1,
  ee: 1,
  el: 1,
  "en-001": 1,
  "en-AE": 6,
  "en-BI": 1,
  "en-MP": 1,
  "en-MV": 5,
  "en-SD": 6,
  eo: 1,
  es: 1,
  et: 1,
  eu: 1,
  ewo: 1,
  fa: 6,
  ff: 1,
  "ff-Adlm": 1,
  fi: 1,
  fo: 1,
  fr: 1,
  "fr-DJ": 6,
  "fr-DZ": 6,
  "fr-SY": 6,
  fur: 1,
  fy: 1,
  ga: 1,
  gd: 1,
  gl: 1,
  gsw: 1,
  gv: 1,
  ha: 1,
  hr: 1,
  hsb: 1,
  hu: 1,
  hy: 1,
  ia: 1,
  ig: 1,
  is: 1,
  it: 1,
  jgo: 1,
  jmc: 1,
  ka: 1,
  kab: 6,
  kde: 1,
  kea: 1,
  khq: 1,
  kk: 1,
  kkj: 1,
  kl: 1,
  "ko-KP": 1,
  ksb: 1,
  ksf: 1,
  ksh: 1,
  ku: 1,
  kw: 1,
  ky: 1,
  lag: 1,
  lb: 1,
  lg: 1,
  ln: 1,
  lrc: 6,
  lt: 1,
  lu: 1,
  lv: 1,
  "mas-TZ": 1,
  mfe: 1,
  mg: 1,
  mgo: 1,
  mi: 1,
  mk: 1,
  mn: 1,
  ms: 1,
  mua: 1,
  mzn: 6,
  naq: 1,
  nds: 1,
  nl: 1,
  nmg: 1,
  nnh: 1,
  no: 1,
  nus: 1,
  nyn: 1,
  os: 1,
  pcm: 1,
  pl: 1,
  ps: 6,
  "pt-AO": 1,
  "pt-CH": 1,
  "pt-CV": 1,
  "pt-GQ": 1,
  "pt-GW": 1,
  "pt-LU": 1,
  "pt-ST": 1,
  "pt-TL": 1,
  "qu-BO": 1,
  "qu-EC": 1,
  rm: 1,
  rn: 1,
  ro: 1,
  rof: 1,
  ru: 1,
  rw: 1,
  rwk: 1,
  sah: 1,
  sbp: 1,
  sc: 1,
  se: 1,
  ses: 1,
  sg: 1,
  shi: 1,
  "shi-Latn": 1,
  si: 1,
  sk: 1,
  sl: 1,
  smn: 1,
  so: 1,
  "so-DJ": 6,
  sq: 1,
  sr: 1,
  "sr-Latn": 1,
  sv: 1,
  sw: 1,
  "ta-LK": 1,
  "ta-MY": 1,
  teo: 1,
  tg: 1,
  "ti-ER": 1,
  tk: 1,
  to: 1,
  tr: 1,
  tt: 1,
  twq: 1,
  tzm: 1,
  uk: 1,
  uz: 1,
  "uz-Arab": 6,
  "uz-Cyrl": 1,
  vai: 1,
  "vai-Latn": 1,
  vi: 1,
  vun: 1,
  wae: 1,
  wo: 1,
  xog: 1,
  yav: 1,
  yi: 1,
  yo: 1,
  zgh: 1
};

// ../../../../../../node_modules/devextreme/esm/localization/intl/date.js
var SYMBOLS_TO_REMOVE_REGEX = /[\u200E\u200F]/g;
var NARROW_NO_BREAK_SPACE_REGEX = /[\u202F]/g;
var getIntlFormatter = (format2) => (date) => {
  if (!format2.timeZoneName) {
    const year = date.getFullYear();
    const recognizableAsTwentyCentury = String(year).length < 3;
    const safeYearShift = 400;
    const temporaryYearValue = recognizableAsTwentyCentury ? year + safeYearShift : year;
    const utcDate = new Date(Date.UTC(temporaryYearValue, date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
    if (recognizableAsTwentyCentury) {
      utcDate.setFullYear(year);
    }
    const utcFormat = extend({
      timeZone: "UTC"
    }, format2);
    return formatDateTime(utcDate, utcFormat);
  }
  return formatDateTime(date, format2);
};
var formattersCache2 = {};
var getFormatter4 = (format2) => {
  const key = core_default.locale() + "/" + JSON.stringify(format2);
  if (!formattersCache2[key]) {
    formattersCache2[key] = new Intl.DateTimeFormat(core_default.locale(), format2).format;
  }
  return formattersCache2[key];
};
function formatDateTime(date, format2) {
  return getFormatter4(format2)(date).replace(SYMBOLS_TO_REMOVE_REGEX, "").replace(NARROW_NO_BREAK_SPACE_REGEX, " ");
}
var formatNumber = (number) => new Intl.NumberFormat(core_default.locale()).format(number);
var getAlternativeNumeralsMap = (() => {
  const numeralsMapCache = {};
  return (locale) => {
    if (!(locale in numeralsMapCache)) {
      if ("0" === formatNumber(0)) {
        numeralsMapCache[locale] = false;
        return false;
      }
      numeralsMapCache[locale] = {};
      for (let i = 0; i < 10; ++i) {
        numeralsMapCache[locale][formatNumber(i)] = i;
      }
    }
    return numeralsMapCache[locale];
  };
})();
var normalizeNumerals = (dateString) => {
  const alternativeNumeralsMap = getAlternativeNumeralsMap(core_default.locale());
  if (!alternativeNumeralsMap) {
    return dateString;
  }
  return dateString.split("").map((sign2) => sign2 in alternativeNumeralsMap ? String(alternativeNumeralsMap[sign2]) : sign2).join("");
};
var removeLeadingZeroes = (str) => str.replace(/(\D)0+(\d)/g, "$1$2");
var dateStringEquals = (actual, expected) => removeLeadingZeroes(actual) === removeLeadingZeroes(expected);
var normalizeMonth = (text) => text.replace("d’", "de ");
var intlFormats = {
  day: {
    day: "numeric"
  },
  date: {
    year: "numeric",
    month: "long",
    day: "numeric"
  },
  dayofweek: {
    weekday: "long"
  },
  longdate: {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  },
  longdatelongtime: {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  },
  longtime: {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  },
  month: {
    month: "long"
  },
  monthandday: {
    month: "long",
    day: "numeric"
  },
  monthandyear: {
    year: "numeric",
    month: "long"
  },
  shortdate: {},
  shorttime: {
    hour: "numeric",
    minute: "numeric"
  },
  shortyear: {
    year: "2-digit"
  },
  year: {
    year: "numeric"
  }
};
Object.defineProperty(intlFormats, "shortdateshorttime", {
  get: function() {
    const defaultOptions3 = Intl.DateTimeFormat(core_default.locale()).resolvedOptions();
    return {
      year: defaultOptions3.year,
      month: defaultOptions3.month,
      day: defaultOptions3.day,
      hour: "numeric",
      minute: "numeric"
    };
  }
});
var getIntlFormat = (format2) => "string" === typeof format2 && intlFormats[format2.toLowerCase()];
var monthNameStrategies = {
  standalone: function(monthIndex, monthFormat) {
    const date = new Date(1999, monthIndex, 13, 1);
    const dateString = getIntlFormatter({
      month: monthFormat
    })(date);
    return dateString;
  },
  format: function(monthIndex, monthFormat) {
    const date = new Date(0, monthIndex, 13, 1);
    const dateString = normalizeMonth(getIntlFormatter({
      day: "numeric",
      month: monthFormat
    })(date));
    const parts = dateString.split(" ").filter((part) => part.indexOf("13") < 0);
    if (1 === parts.length) {
      return parts[0];
    } else if (2 === parts.length) {
      return parts[0].length > parts[1].length ? parts[0] : parts[1];
    }
    return monthNameStrategies.standalone(monthIndex, monthFormat);
  }
};
var date_default = {
  engine: function() {
    return "intl";
  },
  getMonthNames: function(format2, type2) {
    const monthFormat = {
      wide: "long",
      abbreviated: "short",
      narrow: "narrow"
    }[format2 || "wide"];
    type2 = "format" === type2 ? type2 : "standalone";
    return Array.apply(null, new Array(12)).map((_, monthIndex) => monthNameStrategies[type2](monthIndex, monthFormat));
  },
  getDayNames: function(format2) {
    const result2 = ((format3) => Array.apply(null, new Array(7)).map((_, dayIndex) => getIntlFormatter({
      weekday: format3
    })(new Date(0, 0, dayIndex))))({
      wide: "long",
      abbreviated: "short",
      short: "narrow",
      narrow: "narrow"
    }[format2 || "wide"]);
    return result2;
  },
  getPeriodNames: function() {
    const hour12Formatter = getIntlFormatter({
      hour: "numeric",
      hour12: true
    });
    return [1, 13].map((hours) => {
      const hourNumberText = formatNumber(1);
      const timeParts = hour12Formatter(new Date(0, 0, 1, hours)).split(hourNumberText);
      if (2 !== timeParts.length) {
        return "";
      }
      const biggerPart = timeParts[0].length > timeParts[1].length ? timeParts[0] : timeParts[1];
      return biggerPart.trim();
    });
  },
  format: function(date, format2) {
    if (!date) {
      return;
    }
    if (!format2) {
      return date;
    }
    if ("function" !== typeof format2 && !format2.formatter) {
      format2 = format2.type || format2;
    }
    const intlFormat = getIntlFormat(format2);
    if (intlFormat) {
      return getIntlFormatter(intlFormat)(date);
    }
    const formatType = typeof format2;
    if (format2.formatter || "function" === formatType || "string" === formatType) {
      return this.callBase.apply(this, arguments);
    }
    return getIntlFormatter(format2)(date);
  },
  parse: function(dateString, format2) {
    let formatter;
    if (format2 && !format2.parser && "string" === typeof dateString) {
      dateString = normalizeMonth(dateString);
      formatter = (date) => normalizeMonth(this.format(date, format2));
    }
    return this.callBase(dateString, formatter || format2);
  },
  _parseDateBySimpleFormat: function(dateString, format2) {
    dateString = normalizeNumerals(dateString);
    const formatParts = this.getFormatParts(format2);
    const dateParts = dateString.split(/\D+/).filter((part) => part.length > 0);
    if (formatParts.length !== dateParts.length) {
      return;
    }
    const dateArgs = this._generateDateArgs(formatParts, dateParts);
    const constructValidDate = (ampmShift) => {
      const parsedDate = ((dateArgs2, ampmShift2) => {
        const hoursShift = ampmShift2 ? 12 : 0;
        return new Date(dateArgs2.year, dateArgs2.month, dateArgs2.day, (dateArgs2.hours + hoursShift) % 24, dateArgs2.minutes, dateArgs2.seconds);
      })(dateArgs, ampmShift);
      if (dateStringEquals(normalizeNumerals(this.format(parsedDate, format2)), dateString)) {
        return parsedDate;
      }
    };
    return constructValidDate(false) || constructValidDate(true);
  },
  _generateDateArgs: function(formatParts, dateParts) {
    const currentDate = /* @__PURE__ */ new Date();
    const dateArgs = {
      year: currentDate.getFullYear(),
      month: currentDate.getMonth(),
      day: currentDate.getDate(),
      hours: 0,
      minutes: 0,
      seconds: 0
    };
    formatParts.forEach((formatPart, index2) => {
      const datePart = dateParts[index2];
      let parsed = parseInt(datePart, 10);
      if ("month" === formatPart) {
        parsed -= 1;
      }
      dateArgs[formatPart] = parsed;
    });
    return dateArgs;
  },
  formatUsesMonthName: function(format2) {
    if ("object" === typeof format2 && !(format2.type || format2.format)) {
      return "long" === format2.month;
    }
    return this.callBase.apply(this, arguments);
  },
  formatUsesDayName: function(format2) {
    if ("object" === typeof format2 && !(format2.type || format2.format)) {
      return "long" === format2.weekday;
    }
    return this.callBase.apply(this, arguments);
  },
  getTimeSeparator: function() {
    return normalizeNumerals(formatDateTime(new Date(2001, 1, 1, 11, 11), {
      hour: "numeric",
      minute: "numeric",
      hour12: false
    })).replace(/\d/g, "");
  },
  getFormatParts: function(format2) {
    if ("string" === typeof format2) {
      return this.callBase(format2);
    }
    const intlFormat = extend({}, intlFormats[format2.toLowerCase()]);
    const date = new Date(2001, 2, 4, 5, 6, 7);
    let formattedDate = getIntlFormatter(intlFormat)(date);
    formattedDate = normalizeNumerals(formattedDate);
    return [{
      name: "year",
      value: 1
    }, {
      name: "month",
      value: 3
    }, {
      name: "day",
      value: 4
    }, {
      name: "hours",
      value: 5
    }, {
      name: "minutes",
      value: 6
    }, {
      name: "seconds",
      value: 7
    }].map((part) => ({
      name: part.name,
      index: formattedDate.indexOf(part.value)
    })).filter((part) => part.index > -1).sort((a, b) => a.index - b.index).map((part) => part.name);
  }
};

// ../../../../../../node_modules/devextreme/esm/localization/date.js
var hasIntl2 = "undefined" !== typeof Intl;
var FORMATS_TO_PATTERN_MAP = {
  shortdate: "M/d/y",
  shorttime: "h:mm a",
  longdate: "EEEE, MMMM d, y",
  longtime: "h:mm:ss a",
  monthandday: "MMMM d",
  monthandyear: "MMMM y",
  quarterandyear: "QQQ y",
  day: "d",
  year: "y",
  shortdateshorttime: "M/d/y, h:mm a",
  longdatelongtime: "EEEE, MMMM d, y, h:mm:ss a",
  month: "LLLL",
  shortyear: "yy",
  dayofweek: "EEEE",
  quarter: "QQQ",
  hour: "HH",
  minute: "mm",
  second: "ss",
  millisecond: "SSS",
  "datetime-local": "yyyy-MM-ddTHH':'mm':'ss"
};
var possiblePartPatterns = {
  year: ["y", "yy", "yyyy"],
  day: ["d", "dd"],
  month: ["M", "MM", "MMM", "MMMM"],
  hours: ["H", "HH", "h", "hh", "ah"],
  minutes: ["m", "mm"],
  seconds: ["s", "ss"],
  milliseconds: ["S", "SS", "SSS"]
};
var dateLocalization = dependency_injector_default({
  engine: function() {
    return "base";
  },
  _getPatternByFormat: function(format2) {
    return FORMATS_TO_PATTERN_MAP[format2.toLowerCase()];
  },
  _expandPattern: function(pattern) {
    return this._getPatternByFormat(pattern) || pattern;
  },
  formatUsesMonthName: function(format2) {
    return -1 !== this._expandPattern(format2).indexOf("MMMM");
  },
  formatUsesDayName: function(format2) {
    return -1 !== this._expandPattern(format2).indexOf("EEEE");
  },
  getFormatParts: function(format2) {
    const pattern = this._getPatternByFormat(format2) || format2;
    const result2 = [];
    each(pattern.split(/\W+/), (_, formatPart) => {
      each(possiblePartPatterns, (partName, possiblePatterns) => {
        if (possiblePatterns.includes(formatPart)) {
          result2.push(partName);
        }
      });
    });
    return result2;
  },
  getMonthNames: function(format2) {
    return default_date_names_default.getMonthNames(format2);
  },
  getDayNames: function(format2) {
    return default_date_names_default.getDayNames(format2);
  },
  getQuarterNames: function(format2) {
    return default_date_names_default.getQuarterNames(format2);
  },
  getPeriodNames: function(format2) {
    return default_date_names_default.getPeriodNames(format2);
  },
  getTimeSeparator: function() {
    return ":";
  },
  is24HourFormat: function(format2) {
    const amTime = new Date(2017, 0, 20, 11, 0, 0, 0);
    const pmTime = new Date(2017, 0, 20, 23, 0, 0, 0);
    const amTimeFormatted = this.format(amTime, format2);
    const pmTimeFormatted = this.format(pmTime, format2);
    for (let i = 0; i < amTimeFormatted.length; i++) {
      if (amTimeFormatted[i] !== pmTimeFormatted[i]) {
        return !isNaN(parseInt(amTimeFormatted[i]));
      }
    }
  },
  format: function(date, format2) {
    if (!date) {
      return;
    }
    if (!format2) {
      return date;
    }
    let formatter;
    if ("function" === typeof format2) {
      formatter = format2;
    } else if (format2.formatter) {
      formatter = format2.formatter;
    } else {
      format2 = format2.type || format2;
      if (isString(format2)) {
        format2 = FORMATS_TO_PATTERN_MAP[format2.toLowerCase()] || format2;
        return number_default2.convertDigits(getFormatter3(format2, this)(date));
      }
    }
    if (!formatter) {
      return;
    }
    return formatter(date);
  },
  parse: function(text, format2) {
    const that = this;
    let ldmlFormat;
    let formatter;
    if (!text) {
      return;
    }
    if (!format2) {
      return this.parse(text, "shortdate");
    }
    if (format2.parser) {
      return format2.parser(text);
    }
    if ("string" === typeof format2 && !FORMATS_TO_PATTERN_MAP[format2.toLowerCase()]) {
      ldmlFormat = format2;
    } else {
      formatter = (value2) => {
        const text2 = that.format(value2, format2);
        return number_default2.convertDigits(text2, true);
      };
      try {
        ldmlFormat = getFormat2(formatter);
      } catch (e) {
      }
    }
    if (ldmlFormat) {
      text = number_default2.convertDigits(text, true);
      return getParser(ldmlFormat, this)(text);
    }
    errors_default.log("W0012");
    const result2 = new Date(text);
    if (!result2 || isNaN(result2.getTime())) {
      return;
    }
    return result2;
  },
  firstDayOfWeekIndex: function() {
    const index2 = core_default.getValueByClosestLocale((locale) => first_day_of_week_data_default[locale]);
    return void 0 === index2 ? 0 : index2;
  }
});
if (hasIntl2) {
  dateLocalization.inject(date_default);
}
var date_default2 = dateLocalization;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/utils/date/toMilliseconds.js
var timeIntervals = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 864e5,
  week: 6048e5,
  month: 2592e6,
  quarter: 7776e6,
  year: 31536e6
};
function toMilliseconds(value2) {
  return timeIntervals[value2];
}

// ../../../../../../node_modules/devextreme/esm/core/utils/date.js
var DAYS_IN_WEEK = 7;
var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"];
var getDatesInterval = function(startDate, endDate, intervalUnit) {
  const delta = endDate.getTime() - startDate.getTime();
  const millisecondCount = toMilliseconds(intervalUnit) || 1;
  return Math.floor(delta / millisecondCount);
};
var getNextDateUnit = function(unit, withWeeks) {
  const interval = getDateUnitInterval(unit);
  switch (interval) {
    case "millisecond":
      return "second";
    case "second":
      return "minute";
    case "minute":
      return "hour";
    case "hour":
      return "day";
    case "day":
      return withWeeks ? "week" : "month";
    case "week":
      return "month";
    case "month":
      return "quarter";
    case "quarter":
    case "year":
      return "year";
    default:
      return 0;
  }
};
var convertMillisecondsToDateUnits = function(value2) {
  let i;
  let dateUnitCount;
  let dateUnitInterval;
  const dateUnitIntervals2 = ["millisecond", "second", "minute", "hour", "day", "month", "year"];
  const result2 = {};
  for (i = dateUnitIntervals2.length - 1; i >= 0; i--) {
    dateUnitInterval = dateUnitIntervals2[i];
    dateUnitCount = Math.floor(value2 / toMilliseconds(dateUnitInterval));
    if (dateUnitCount > 0) {
      result2[dateUnitInterval + "s"] = dateUnitCount;
      value2 -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount);
    }
  }
  return result2;
};
var dateToMilliseconds = function(tickInterval) {
  let milliseconds = 0;
  if (isObject(tickInterval)) {
    each(tickInterval, function(key, value2) {
      milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value2);
    });
  }
  if (isString(tickInterval)) {
    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
  }
  return milliseconds;
};
function convertDateUnitToMilliseconds(dateUnit, count) {
  return toMilliseconds(dateUnit) * count;
}
function getDateUnitInterval(tickInterval) {
  let maxInterval = -1;
  let i;
  if (isString(tickInterval)) {
    return tickInterval;
  }
  if (isObject(tickInterval)) {
    each(tickInterval, function(key, value2) {
      for (i = 0; i < dateUnitIntervals.length; i++) {
        if (value2 && (key === dateUnitIntervals[i] + "s" || key === dateUnitIntervals[i]) && maxInterval < i) {
          maxInterval = i;
        }
      }
    });
    return dateUnitIntervals[maxInterval];
  }
  return "";
}
var tickIntervalToFormatMap = {
  millisecond: "millisecond",
  second: "longtime",
  minute: "shorttime",
  hour: "shorttime",
  day: "day",
  week: "day",
  month: "month",
  quarter: "quarter",
  year: "year"
};
function getDateFormatByTickInterval(tickInterval) {
  return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || "";
}
var getQuarter = function(month) {
  return Math.floor(month / 3);
};
var getFirstQuarterMonth = function(month) {
  return 3 * getQuarter(month);
};
function correctDateWithUnitBeginning(date, dateInterval, withCorrection, firstDayOfWeek) {
  date = new Date(date.getTime());
  const oldDate = new Date(date.getTime());
  let firstQuarterMonth;
  let month;
  const dateUnitInterval = getDateUnitInterval(dateInterval);
  switch (dateUnitInterval) {
    case "second":
      date = new Date(1e3 * Math.floor(oldDate.getTime() / 1e3));
      break;
    case "minute":
      date = new Date(6e4 * Math.floor(oldDate.getTime() / 6e4));
      break;
    case "hour":
      date = new Date(36e5 * Math.floor(oldDate.getTime() / 36e5));
      break;
    case "year":
      date.setMonth(0);
    case "month":
      date.setDate(1);
    case "day":
      date.setHours(0, 0, 0, 0);
      break;
    case "week":
      date = getFirstWeekDate(date, firstDayOfWeek || 0);
      date.setHours(0, 0, 0, 0);
      break;
    case "quarter":
      firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
      month = date.getMonth();
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
      if (month !== firstQuarterMonth) {
        date.setMonth(firstQuarterMonth);
      }
  }
  if (withCorrection && "hour" !== dateUnitInterval && "minute" !== dateUnitInterval && "second" !== dateUnitInterval) {
    fixTimezoneGap(oldDate, date);
  }
  return date;
}
function trimTime(date) {
  return correctDateWithUnitBeginning(date, "day");
}
var setToDayEnd = function(date) {
  const result2 = trimTime(date);
  result2.setDate(result2.getDate() + 1);
  return new Date(result2.getTime() - 1);
};
var getDatesDifferences = function(date1, date2) {
  let counter = 0;
  const differences = {
    year: date1.getFullYear() !== date2.getFullYear(),
    month: date1.getMonth() !== date2.getMonth(),
    day: date1.getDate() !== date2.getDate(),
    hour: date1.getHours() !== date2.getHours(),
    minute: date1.getMinutes() !== date2.getMinutes(),
    second: date1.getSeconds() !== date2.getSeconds(),
    millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
  };
  each(differences, function(key, value2) {
    if (value2) {
      counter++;
    }
  });
  if (0 === counter && 0 !== getTimezonesDifference(date1, date2)) {
    differences.hour = true;
    counter++;
  }
  differences.count = counter;
  return differences;
};
function addDateInterval(value2, interval, dir) {
  const result2 = new Date(value2.getTime());
  const intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : isNumeric(interval) ? convertMillisecondsToDateUnits(interval) : interval;
  if (intervalObject.years) {
    result2.setFullYear(result2.getFullYear() + intervalObject.years * dir);
  }
  if (intervalObject.quarters) {
    result2.setMonth(result2.getMonth() + 3 * intervalObject.quarters * dir);
  }
  if (intervalObject.months) {
    result2.setMonth(result2.getMonth() + intervalObject.months * dir);
  }
  if (intervalObject.weeks) {
    result2.setDate(result2.getDate() + 7 * intervalObject.weeks * dir);
  }
  if (intervalObject.days) {
    result2.setDate(result2.getDate() + intervalObject.days * dir);
  }
  if (intervalObject.hours) {
    result2.setTime(result2.getTime() + 36e5 * intervalObject.hours * dir);
  }
  if (intervalObject.minutes) {
    result2.setTime(result2.getTime() + 6e4 * intervalObject.minutes * dir);
  }
  if (intervalObject.seconds) {
    result2.setTime(result2.getTime() + 1e3 * intervalObject.seconds * dir);
  }
  if (intervalObject.milliseconds) {
    result2.setTime(result2.getTime() + intervalObject.milliseconds * dir);
  }
  return result2;
}
var addInterval = function(value2, interval, isNegative) {
  const dir = isNegative ? -1 : 1;
  return isDate(value2) ? addDateInterval(value2, interval, dir) : adjust(value2 + interval * dir, interval);
};
var getSequenceByInterval = function(min, max, interval) {
  const intervals = [];
  let cur;
  intervals.push(isDate(min) ? new Date(min.getTime()) : min);
  cur = min;
  while (cur < max) {
    cur = addInterval(cur, interval);
    intervals.push(cur);
  }
  return intervals;
};
var getViewFirstCellDate = function(viewType, date) {
  if ("month" === viewType) {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  }
  if ("year" === viewType) {
    return createDateWithFullYear(date.getFullYear(), 0, date.getDate());
  }
  if ("decade" === viewType) {
    return createDateWithFullYear(getFirstYearInDecade(date), date.getMonth(), date.getDate());
  }
  if ("century" === viewType) {
    return createDateWithFullYear(getFirstDecadeInCentury(date), date.getMonth(), date.getDate());
  }
};
var getViewLastCellDate = function(viewType, date) {
  if ("month" === viewType) {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
  }
  if ("year" === viewType) {
    return createDateWithFullYear(date.getFullYear(), 11, date.getDate());
  }
  if ("decade" === viewType) {
    return createDateWithFullYear(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate());
  }
  if ("century" === viewType) {
    return createDateWithFullYear(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate());
  }
};
var getViewMinBoundaryDate = function(viewType, date) {
  const resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  if ("month" === viewType) {
    return resultDate;
  }
  resultDate.setMonth(0);
  if ("year" === viewType) {
    return resultDate;
  }
  if ("decade" === viewType) {
    resultDate.setFullYear(getFirstYearInDecade(date));
  }
  if ("century" === viewType) {
    resultDate.setFullYear(getFirstDecadeInCentury(date));
  }
  return resultDate;
};
var getViewMaxBoundaryDate = function(viewType, date) {
  const resultDate = new Date(date);
  resultDate.setDate(getLastMonthDay(date));
  if ("month" === viewType) {
    return resultDate;
  }
  resultDate.setMonth(11);
  resultDate.setDate(getLastMonthDay(resultDate));
  if ("year" === viewType) {
    return resultDate;
  }
  if ("decade" === viewType) {
    resultDate.setFullYear(getFirstYearInDecade(date) + 9);
  }
  if ("century" === viewType) {
    resultDate.setFullYear(getFirstDecadeInCentury(date) + 99);
  }
  return resultDate;
};
function getLastMonthDay(date) {
  const resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
  return resultDate.getDate();
}
var getViewUp = function(typeView) {
  switch (typeView) {
    case "month":
      return "year";
    case "year":
      return "decade";
    case "decade":
      return "century";
  }
};
var getViewDown = function(typeView) {
  switch (typeView) {
    case "century":
      return "decade";
    case "decade":
      return "year";
    case "year":
      return "month";
  }
};
var getDifferenceInMonth = function(typeView) {
  let difference = 1;
  if ("year" === typeView) {
    difference = 12;
  }
  if ("decade" === typeView) {
    difference = 120;
  }
  if ("century" === typeView) {
    difference = 1200;
  }
  return difference;
};
var getDifferenceInMonthForCells = function(typeView) {
  let difference = 1;
  if ("decade" === typeView) {
    difference = 12;
  }
  if ("century" === typeView) {
    difference = 120;
  }
  return difference;
};
function getDateIntervalByString(intervalString) {
  const result2 = {};
  switch (intervalString) {
    case "year":
      result2.years = 1;
      break;
    case "month":
      result2.months = 1;
      break;
    case "quarter":
      result2.months = 3;
      break;
    case "week":
      result2.weeks = 1;
      break;
    case "day":
      result2.days = 1;
      break;
    case "hour":
      result2.hours = 1;
      break;
    case "minute":
      result2.minutes = 1;
      break;
    case "second":
      result2.seconds = 1;
      break;
    case "millisecond":
      result2.milliseconds = 1;
  }
  return result2;
}
function sameDate(date1, date2) {
  return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate();
}
function sameMonthAndYear(date1, date2) {
  return sameYear(date1, date2) && date1.getMonth() === date2.getMonth();
}
function sameYear(date1, date2) {
  return date1 && date2 && date1.getFullYear() === date2.getFullYear();
}
function sameHoursAndMinutes(date1, date2) {
  return date1 && date2 && date1.getHours() === date2.getHours() && date1.getMinutes() === date2.getMinutes();
}
var sameDecade = function(date1, date2) {
  if (!isDefined(date1) || !isDefined(date2)) {
    return;
  }
  const startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10;
  const startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
  return date1 && date2 && startDecadeDate1 === startDecadeDate2;
};
var sameCentury = function(date1, date2) {
  if (!isDefined(date1) || !isDefined(date2)) {
    return;
  }
  const startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100;
  const startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
  return date1 && date2 && startCenturyDate1 === startCenturyDate2;
};
function getFirstDecadeInCentury(date) {
  return date && date.getFullYear() - date.getFullYear() % 100;
}
function getFirstYearInDecade(date) {
  return date && date.getFullYear() - date.getFullYear() % 10;
}
var getShortDateFormat = function() {
  return "yyyy/MM/dd";
};
var getFirstMonthDate = function(date) {
  if (!isDefined(date)) {
    return;
  }
  return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
};
var getLastMonthDate = function(date) {
  if (!isDefined(date)) {
    return;
  }
  return createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
};
function getFirstWeekDate(date, firstDayOfWeek) {
  const delta = (date.getDay() - firstDayOfWeek + DAYS_IN_WEEK) % DAYS_IN_WEEK;
  const result2 = new Date(date);
  result2.setDate(date.getDate() - delta);
  return result2;
}
function getUTCTime(date) {
  return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
}
function getDayNumber(date) {
  const ms = getUTCTime(date) - getUTCTime(getFirstDateInYear(date.getFullYear()));
  return 1 + Math.floor(ms / toMilliseconds("day"));
}
function getFirstDateInYear(year) {
  return new Date(year, 0, 1);
}
function getLastDateInYear(year) {
  return new Date(year, 11, 31);
}
function getDayWeekNumber(date, firstDayOfWeek) {
  let day = date.getDay() - firstDayOfWeek + 1;
  if (day <= 0) {
    day += DAYS_IN_WEEK;
  }
  return day;
}
function getWeekNumber(date, firstDayOfWeek, rule) {
  const firstWeekDayInYear = getDayWeekNumber(getFirstDateInYear(date.getFullYear()), firstDayOfWeek);
  const lastWeekDayInYear = getDayWeekNumber(getLastDateInYear(date.getFullYear()), firstDayOfWeek);
  const daysInFirstWeek = DAYS_IN_WEEK - firstWeekDayInYear + 1;
  let weekNumber = Math.ceil((getDayNumber(date) - daysInFirstWeek) / 7);
  switch (rule) {
    case "fullWeek":
      if (daysInFirstWeek === DAYS_IN_WEEK) {
        weekNumber++;
      }
      if (0 === weekNumber) {
        const lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
        return getWeekNumber(lastDateInPreviousYear, firstDayOfWeek, rule);
      }
      return weekNumber;
    case "firstDay": {
      if (daysInFirstWeek > 0) {
        weekNumber++;
      }
      const isSunday = 7 === firstWeekDayInYear || 7 === lastWeekDayInYear;
      if (weekNumber > 52 && !isSunday || 54 === weekNumber) {
        weekNumber = 1;
      }
      return weekNumber;
    }
    case "firstFourDays": {
      if (daysInFirstWeek > 3) {
        weekNumber++;
      }
      const isThursday = 4 === firstWeekDayInYear || 4 === lastWeekDayInYear;
      if (weekNumber > 52 && !isThursday) {
        weekNumber = 1;
      }
      if (0 === weekNumber) {
        const lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
        return getWeekNumber(lastDateInPreviousYear, firstDayOfWeek, rule);
      }
      return weekNumber;
    }
  }
}
var normalizeDateByWeek = function(date, currentDate) {
  const differenceInDays = dateUtils.getDatesInterval(date, currentDate, "day");
  let resultDate = new Date(date);
  if (differenceInDays >= 6) {
    resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7));
  }
  return resultDate;
};
var dateInRange = function(date, min, max, format2) {
  if ("date" === format2) {
    min = min && dateUtils.correctDateWithUnitBeginning(min, "day");
    max = max && dateUtils.correctDateWithUnitBeginning(max, "day");
    date = date && dateUtils.correctDateWithUnitBeginning(date, "day");
  }
  return normalizeDate(date, min, max) === date;
};
var intervalsOverlap = function(options2) {
  const {
    firstMin,
    firstMax,
    secondMin,
    secondMax
  } = options2;
  return firstMin <= secondMin && secondMin <= firstMax || firstMin > secondMin && firstMin < secondMax || firstMin < secondMax && firstMax > secondMax;
};
var dateTimeFromDecimal = function(number) {
  const hours = Math.floor(number);
  const minutes = number % 1 * 60;
  return {
    hours,
    minutes
  };
};
var roundDateByStartDayHour = function(date, startDayHour) {
  const startTime = this.dateTimeFromDecimal(startDayHour);
  const result2 = new Date(date);
  if (date.getHours() === startTime.hours && date.getMinutes() < startTime.minutes || date.getHours() < startTime.hours) {
    result2.setHours(startTime.hours, startTime.minutes, 0, 0);
  }
  return result2;
};
function normalizeDate(date, min, max) {
  let normalizedDate = date;
  if (!isDefined(date)) {
    return date;
  }
  if (isDefined(min) && date < min) {
    normalizedDate = min;
  }
  if (isDefined(max) && date > max) {
    normalizedDate = max;
  }
  return normalizedDate;
}
function fixTimezoneGap(oldDate, newDate) {
  if (!isDefined(oldDate)) {
    return;
  }
  const diff = newDate.getHours() - oldDate.getHours();
  if (0 === diff) {
    return;
  }
  const sign2 = 1 === diff || -23 === diff ? -1 : 1;
  const trial = new Date(newDate.getTime() + 36e5 * sign2);
  if (sign2 > 0 || trial.getDate() === newDate.getDate()) {
    newDate.setTime(trial.getTime());
  }
}
var roundToHour = function(date) {
  const result2 = new Date(date.getTime());
  result2.setHours(result2.getHours() + 1);
  result2.setMinutes(0);
  return result2;
};
function getTimezonesDifference(min, max) {
  return 60 * (max.getTimezoneOffset() - min.getTimezoneOffset()) * 1e3;
}
var makeDate = function(date) {
  return new Date(date);
};
var getDatesOfInterval = function(startDate, endDate, step) {
  const result2 = [];
  let currentDate = new Date(startDate.getTime());
  while (currentDate < endDate) {
    result2.push(new Date(currentDate.getTime()));
    currentDate = this.addInterval(currentDate, step);
  }
  return result2;
};
var createDateWithFullYear = function(year) {
  const result2 = new Date(...arguments);
  result2.setFullYear(year);
  return result2;
};
var getMachineTimezoneName = () => {
  const hasIntl3 = "undefined" !== typeof Intl;
  return hasIntl3 ? Intl.DateTimeFormat().resolvedOptions().timeZone : null;
};
var dateUtils = {
  dateUnitIntervals,
  convertMillisecondsToDateUnits,
  dateToMilliseconds,
  getNextDateUnit,
  convertDateUnitToMilliseconds,
  getDateUnitInterval,
  getDateFormatByTickInterval,
  getDatesDifferences,
  correctDateWithUnitBeginning,
  trimTime,
  setToDayEnd,
  roundDateByStartDayHour,
  dateTimeFromDecimal,
  addDateInterval,
  addInterval,
  getSequenceByInterval,
  getDateIntervalByString,
  sameHoursAndMinutes,
  sameDate,
  sameMonthAndYear,
  sameMonth: sameMonthAndYear,
  sameYear,
  sameDecade,
  sameCentury,
  getDifferenceInMonth,
  getDifferenceInMonthForCells,
  getFirstYearInDecade,
  getFirstDecadeInCentury,
  getShortDateFormat,
  getViewFirstCellDate,
  getViewLastCellDate,
  getViewDown,
  getViewUp,
  getLastMonthDay,
  getLastMonthDate,
  getFirstMonthDate,
  getFirstWeekDate,
  getWeekNumber,
  normalizeDateByWeek,
  getQuarter,
  getFirstQuarterMonth,
  dateInRange,
  intervalsOverlap,
  roundToHour,
  normalizeDate,
  getViewMinBoundaryDate,
  getViewMaxBoundaryDate,
  fixTimezoneGap,
  getTimezonesDifference,
  makeDate,
  getDatesInterval,
  getDatesOfInterval,
  createDateWithFullYear,
  getMachineTimezoneName
};
dateUtils.sameView = function(view, date1, date2) {
  return dateUtils[camelize("same " + view)](date1, date2);
};
var date_default3 = dateUtils;

// ../../../../../../node_modules/devextreme/esm/core/utils/date_serialization.js
var ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/;
var ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
var ISO8601_PATTERN_PARTS = ["", "yyyy", "", "MM", "", "dd", "THH", "", "mm", "", "ss", ".SSS"];
var DATE_SERIALIZATION_PATTERN = /^(\d{4})\/(\d{2})\/(\d{2})$/;
var dateParser = function(text, skipISO8601Parsing) {
  let result2;
  if (isString(text) && !skipISO8601Parsing) {
    result2 = parseISO8601String(text);
  }
  return result2 || parseDate(text);
};
function getTimePart(part) {
  return +part || 0;
}
function parseDate(text) {
  const isDefaultSerializationFormat = "yyyy/MM/dd" === getDateSerializationFormat(text);
  const parsedValue = !isDate(text) && Date.parse(text);
  if (!parsedValue && isDefaultSerializationFormat) {
    const parts = text.match(DATE_SERIALIZATION_PATTERN);
    if (parts) {
      const newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));
      newDate.setFullYear(getTimePart(parts[1]));
      newDate.setMonth(getTimePart(parts[2]) - 1);
      newDate.setDate(getTimePart(parts[3]));
      return newDate;
    }
  }
  return isNumeric(parsedValue) ? new Date(parsedValue) : text;
}
function parseISO8601String(text) {
  let parts = text.match(ISO8601_PATTERN);
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]));
    }
    return;
  }
  const year = getTimePart(parts[1]);
  const month = --parts[3];
  const day = parts[5];
  let timeZoneHour = 0;
  let timeZoneMinute = 0;
  const correctYear = (d) => {
    year < 100 && d.setFullYear(year);
    return d;
  };
  timeZoneHour = getTimePart(parts[14]);
  timeZoneMinute = getTimePart(parts[16]);
  if ("-" === parts[13]) {
    timeZoneHour = -timeZoneHour;
    timeZoneMinute = -timeZoneMinute;
  }
  const hour = getTimePart(parts[6]) - timeZoneHour;
  const minute = getTimePart(parts[8]) - timeZoneMinute;
  const second = getTimePart(parts[10]);
  const millisecond = function(part) {
    part = part || "";
    return getTimePart(part) * Math.pow(10, 3 - part.length);
  }(parts[11]);
  if (parts[12]) {
    return correctYear(new Date(Date.UTC(year, month, day, hour, minute, second, millisecond)));
  }
  return correctYear(new Date(year, month, day, hour, minute, second, millisecond));
}
var getIso8601Format = function(text, useUtc) {
  let parts = text.match(ISO8601_PATTERN);
  let result2 = "";
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return parts[3] ? "HH:mm:ss" : "HH:mm";
    }
    return;
  }
  for (let i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
    if (parts[i]) {
      result2 += ISO8601_PATTERN_PARTS[i] || parts[i];
    }
  }
  if ("Z" === parts[12]) {
    result2 += "'Z'";
  }
  if (parts[14]) {
    if (parts[15]) {
      result2 += "xxx";
    } else if (parts[16]) {
      result2 += "xx";
    } else {
      result2 += "x";
    }
  }
  return result2;
};
var deserializeDate = function(value2) {
  if ("number" === typeof value2) {
    return new Date(value2);
  }
  return dateParser(value2, !config_default().forceIsoDateParsing);
};
var serializeDate = function(value2, serializationFormat) {
  if (!serializationFormat) {
    return value2;
  }
  if (!isDate(value2)) {
    return null;
  }
  if ("number" === serializationFormat) {
    return value2 && value2.valueOf ? value2.valueOf() : null;
  }
  return getFormatter3(serializationFormat, default_date_names_default)(value2);
};
var getDateSerializationFormat = function(value2) {
  if ("number" === typeof value2) {
    return "number";
  } else if (isString(value2)) {
    let format2;
    if (config_default().forceIsoDateParsing) {
      format2 = getIso8601Format(value2);
    }
    if (format2) {
      return format2;
    } else if (value2.indexOf(":") >= 0) {
      return "yyyy/MM/dd HH:mm:ss";
    } else {
      return "yyyy/MM/dd";
    }
  } else if (value2) {
    return null;
  }
};
var date_serialization_default = {
  dateParser,
  deserializeDate,
  serializeDate,
  getDateSerializationFormat
};

// ../../../../../../node_modules/devextreme/esm/core/templates/bindable_template.js
var watchChanges = function(rawData, watchMethod, fields, fieldsMap, callback) {
  let fieldsDispose;
  const globalDispose = ((data2, watchMethod2, callback2) => watchMethod2(() => data2, callback2))(rawData, watchMethod, function(dataWithRawFields) {
    fieldsDispose && fieldsDispose();
    if (isPrimitive(dataWithRawFields)) {
      callback(dataWithRawFields);
      return;
    }
    fieldsDispose = function(data2, watchMethod2, fields2, fieldsMap2, callback2) {
      const resolvedData = {};
      const missedFields = fields2.slice();
      const watchHandlers = fields2.map(function(name2) {
        const fieldGetter = fieldsMap2[name2];
        return watchMethod2(fieldGetter ? () => fieldGetter(data2) : () => data2[name2], function(value2) {
          resolvedData[name2] = value2;
          if (missedFields.length) {
            const index2 = missedFields.indexOf(name2);
            if (index2 >= 0) {
              missedFields.splice(index2, 1);
            }
          }
          if (!missedFields.length) {
            callback2(resolvedData);
          }
        });
      });
      return function() {
        watchHandlers.forEach((dispose) => dispose());
      };
    }(dataWithRawFields, watchMethod, fields, fieldsMap, callback);
  });
  return function() {
    fieldsDispose && fieldsDispose();
    globalDispose && globalDispose();
  };
};
var BindableTemplate = class extends TemplateBase {
  constructor(render4, fields, watchMethod, fieldsMap) {
    super();
    this._render = render4;
    this._fields = fields;
    this._fieldsMap = fieldsMap || {};
    this._watchMethod = watchMethod;
  }
  _renderCore(options2) {
    const $container = renderer_default(options2.container);
    const dispose = watchChanges(options2.model, this._watchMethod, this._fields, this._fieldsMap, (data2) => {
      $container.empty();
      this._render($container, data2, options2.model);
    });
    events_engine_default.on($container, removeEvent, dispose);
    return $container.contents();
  }
};

// ../../../../../../node_modules/devextreme/esm/data/utils.js
var ready5 = ready_callbacks_default.add;
var XHR_ERROR_UNLOAD = "DEVEXTREME_XHR_ERROR_UNLOAD";
var normalizeBinaryCriterion = function(crit) {
  return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]];
};
var normalizeSortingInfo = function(info) {
  if (!Array.isArray(info)) {
    info = [info];
  }
  return map(info, function(i) {
    const result2 = {
      selector: isFunction(i) || "string" === typeof i ? i : i.getter || i.field || i.selector,
      desc: !!(i.desc || "d" === String(i.dir).charAt(0).toLowerCase())
    };
    if (i.compare) {
      result2.compare = i.compare;
    }
    return result2;
  });
};
var errorMessageFromXhr = function() {
  const textStatusMessages = {
    timeout: "Network connection timeout",
    error: "Unspecified network error",
    parsererror: "Unexpected server response"
  };
  let unloading;
  ready5(function() {
    const window26 = getWindow();
    dom_adapter_default.listen(window26, "beforeunload", function() {
      unloading = true;
    });
  });
  return function(xhr, textStatus) {
    if (unloading) {
      return XHR_ERROR_UNLOAD;
    }
    if (xhr.status < 400) {
      return function(textStatus2) {
        let result2 = textStatusMessages[textStatus2];
        if (!result2) {
          return textStatus2;
        }
        return result2;
      }(textStatus);
    }
    return xhr.statusText;
  };
}();
var aggregators = {
  count: {
    seed: 0,
    step: function(count) {
      return 1 + count;
    }
  },
  sum: {
    seed: 0,
    step: function(sum, item) {
      return sum + item;
    }
  },
  min: {
    step: function(min, item) {
      return item < min ? item : min;
    }
  },
  max: {
    step: function(max, item) {
      return item > max ? item : max;
    }
  },
  avg: {
    seed: [0, 0],
    step: function(pair, value2) {
      return [pair[0] + value2, pair[1] + 1];
    },
    finalize: function(pair) {
      return pair[1] ? pair[0] / pair[1] : NaN;
    }
  }
};
var processRequestResultLock = function() {
  let lockCount = 0;
  let lockDeferred;
  return {
    obtain: function() {
      if (0 === lockCount) {
        lockDeferred = new Deferred();
      }
      lockCount++;
    },
    release: function() {
      lockCount--;
      if (lockCount < 1) {
        lockDeferred.resolve();
      }
    },
    promise: function() {
      const deferred = 0 === lockCount ? new Deferred().resolve() : lockDeferred;
      return deferred.promise();
    },
    reset: function() {
      lockCount = 0;
      if (lockDeferred) {
        lockDeferred.resolve();
      }
    }
  };
}();
function isConjunctiveOperator(condition) {
  return /^(and|&&|&)$/i.test(condition);
}
var keysEqual = function(keyExpr, key1, key2) {
  if (Array.isArray(keyExpr)) {
    const names = map(key1, function(v, k) {
      return k;
    });
    let name2;
    for (let i = 0; i < names.length; i++) {
      name2 = names[i];
      if (!equalByValue(key1[name2], key2[name2], {
        strict: false
      })) {
        return false;
      }
    }
    return true;
  }
  return equalByValue(key1, key2, {
    strict: false
  });
};
var isUnaryOperation = function(crit) {
  return "!" === crit[0] && Array.isArray(crit[1]);
};
var isGroupOperator = function(value2) {
  return "and" === value2 || "or" === value2;
};
var isUniformEqualsByOr = function(crit) {
  if (crit.length > 2 && Array.isArray(crit[0]) && "or" === crit[1] && "string" === typeof crit[0][0] && "=" === crit[0][1]) {
    const [prop] = crit[0];
    return !crit.find((el, i) => i % 2 !== 0 ? "or" !== el : !Array.isArray(el) || 3 !== el.length || el[0] !== prop || "=" !== el[1]);
  }
  return false;
};
var isGroupCriterion = function(crit) {
  const first = crit[0];
  const second = crit[1];
  if (Array.isArray(first)) {
    return true;
  }
  if (isFunction(first)) {
    if (Array.isArray(second) || isFunction(second) || isGroupOperator(second)) {
      return true;
    }
  }
  return false;
};
var trivialPromise = function() {
  const d = new Deferred();
  return d.resolve.apply(d, arguments).promise();
};
var rejectedPromise = function() {
  const d = new Deferred();
  return d.reject.apply(d, arguments).promise();
};
function throttle(func, timeout) {
  let timeoutId;
  return function() {
    if (!timeoutId) {
      timeoutId = setTimeout(() => {
        timeoutId = void 0;
        func.call(this);
      }, isFunction(timeout) ? timeout() : timeout);
    }
    return timeoutId;
  };
}
function throttleChanges(func, timeout) {
  let cache = [];
  const throttled = throttle(function() {
    func.call(this, cache);
    cache = [];
  }, timeout);
  return function(changes) {
    if (Array.isArray(changes)) {
      cache.push(...changes);
    }
    return throttled.call(this, cache);
  };
}

// ../../../../../../node_modules/devextreme/esm/data/errors.js
var errors = error_default(errors_default.ERROR_MESSAGES, {
  E4000: "[DevExpress.data]: {0}",
  E4001: "Unknown aggregating function is detected: '{0}'",
  E4002: "Unsupported OData protocol version is used",
  E4003: "Unknown filter operation is used: {0}",
  E4004: "The thenby() method is called before the sortby() method",
  E4005: "Store requires a key expression for this operation",
  E4006: "ArrayStore 'data' option must be an array",
  E4007: "Compound keys cannot be auto-generated",
  E4008: "Attempt to insert an item with a duplicated key",
  E4009: "Data item cannot be found",
  E4010: "CustomStore does not support creating queries",
  E4011: "Custom Store method is not implemented or is not a function: {0}",
  E4012: "Custom Store method returns an invalid value: {0}",
  E4013: "Local Store requires the 'name' configuration option is specified",
  E4014: "Unknown data type is specified for ODataStore: {0}",
  E4015: "Unknown entity name or alias is used: {0}",
  E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
  E4017: "Keys cannot be modified",
  E4018: "The server has returned a non-numeric value in a response to an item count request",
  E4019: "Mixing of group operators inside a single group of filter expression is not allowed",
  E4020: "Unknown store type is detected: {0}",
  E4021: "The server response does not provide the totalCount value",
  E4022: "The server response does not provide the groupCount value",
  E4023: "Could not parse the following XML: {0}",
  E4024: "String function {0} cannot be used with the data field {1} of type {2}.",
  W4000: "Data returned from the server has an incorrect structure",
  W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',
  W4002: "Data loading has failed for some cells due to the following error: {0}"
});
var errorHandler = null;
var handleError = function(error) {
  var _errorHandler;
  null === (_errorHandler = errorHandler) || void 0 === _errorHandler || _errorHandler(error);
};

// ../../../../../../node_modules/devextreme/esm/data/array_utils.js
function hasKey(target, keyOrKeys) {
  let key;
  const keys = "string" === typeof keyOrKeys ? keyOrKeys.split() : keyOrKeys.slice();
  while (keys.length) {
    key = keys.shift();
    if (key in target) {
      return true;
    }
  }
  return false;
}
function findItems(keyInfo, items, key, groupCount) {
  let childItems;
  let result2;
  if (groupCount) {
    for (let i = 0; i < items.length; i++) {
      childItems = items[i].items || items[i].collapsedItems || [];
      result2 = findItems(keyInfo, childItems || [], key, groupCount - 1);
      if (result2) {
        return result2;
      }
    }
  } else if (indexByKey(keyInfo, items, key) >= 0) {
    return items;
  }
}
function getItems(keyInfo, items, key, groupCount) {
  if (groupCount) {
    return findItems(keyInfo, items, key, groupCount) || [];
  }
  return items;
}
function generateDataByKeyMap(keyInfo, array) {
  if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {
    const dataByKeyMap = {};
    const arrayLength = array.length;
    for (let i = 0; i < arrayLength; i++) {
      dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i];
    }
    array._dataByKeyMap = dataByKeyMap;
    array._dataByKeyMapLength = arrayLength;
  }
}
function getCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
}
function getHasKeyCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
  return true;
}
function setDataByKeyMapValue(array, key, data2) {
  if (array._dataByKeyMap) {
    array._dataByKeyMap[JSON.stringify(key)] = data2;
    array._dataByKeyMapLength += data2 ? 1 : -1;
  }
}
function cloneInstanceWithChangedPaths(instance, changes, clonedInstances) {
  clonedInstances = clonedInstances || /* @__PURE__ */ new WeakMap();
  const result2 = instance ? Object.create(Object.getPrototypeOf(instance)) : {};
  if (instance) {
    clonedInstances.set(instance, result2);
  }
  const instanceWithoutPrototype = _extends({}, instance);
  deepExtendArraySafe(result2, instanceWithoutPrototype, true, true);
  for (const name2 in instanceWithoutPrototype) {
    const value2 = instanceWithoutPrototype[name2];
    const change = null === changes || void 0 === changes ? void 0 : changes[name2];
    if (isObject(value2) && !isPlainObject(value2) && isObject(change) && !clonedInstances.has(value2)) {
      result2[name2] = cloneInstanceWithChangedPaths(value2, change, clonedInstances);
    }
  }
  for (const name2 in result2) {
    const prop = result2[name2];
    if (isObject(prop) && clonedInstances.has(prop)) {
      result2[name2] = clonedInstances.get(prop);
    }
  }
  return result2;
}
function createObjectWithChanges(target, changes) {
  const result2 = cloneInstanceWithChangedPaths(target, changes);
  return deepExtendArraySafe(result2, changes, true, true);
}
function applyBatch(_ref) {
  let {
    keyInfo,
    data: data2,
    changes,
    groupCount,
    useInsertIndex,
    immutable,
    disableCache,
    logError,
    skipCopying
  } = _ref;
  const resultItems = true === immutable ? [...data2] : data2;
  changes.forEach((item) => {
    const items = "insert" === item.type ? resultItems : getItems(keyInfo, resultItems, item.key, groupCount);
    !disableCache && generateDataByKeyMap(keyInfo, items);
    switch (item.type) {
      case "update":
        update(keyInfo, items, item.key, item.data, true, immutable, logError);
        break;
      case "insert":
        insert(keyInfo, items, item.data, useInsertIndex && isDefined(item.index) ? item.index : -1, true, logError, skipCopying);
        break;
      case "remove":
        remove4(keyInfo, items, item.key, true, logError);
    }
  });
  return resultItems;
}
function getErrorResult(isBatch, logError, errorCode) {
  return !isBatch ? rejectedPromise(errors.Error(errorCode)) : logError && errors.log(errorCode);
}
function update(keyInfo, array, key, data2, isBatch, immutable, logError) {
  let target;
  const keyExpr = keyInfo.key();
  if (keyExpr) {
    if (hasKey(data2, keyExpr) && !keysEqual(keyExpr, key, keyInfo.keyOf(data2))) {
      return getErrorResult(isBatch, logError, "E4017");
    }
    target = getCacheValue(array, key);
    if (!target) {
      const index2 = indexByKey(keyInfo, array, key);
      if (index2 < 0) {
        return getErrorResult(isBatch, logError, "E4009");
      }
      target = array[index2];
      if (true === immutable && isDefined(target)) {
        const newTarget = createObjectWithChanges(target, data2);
        array[index2] = newTarget;
        return !isBatch && trivialPromise(newTarget, key);
      }
    }
  } else {
    target = key;
  }
  deepExtendArraySafe(target, data2, true);
  if (!isBatch) {
    if (config_default().useLegacyStoreResult) {
      return trivialPromise(key, data2);
    } else {
      return trivialPromise(target, key);
    }
  }
}
function insert(keyInfo, array, data2, index2, isBatch, logError, skipCopying) {
  let keyValue;
  const keyExpr = keyInfo.key();
  const obj = isPlainObject(data2) && !skipCopying ? extend({}, data2) : data2;
  if (keyExpr) {
    keyValue = keyInfo.keyOf(obj);
    if (void 0 === keyValue || "object" === typeof keyValue && isEmptyObject(keyValue)) {
      if (Array.isArray(keyExpr)) {
        throw errors.Error("E4007");
      }
      keyValue = obj[keyExpr] = String(new guid_default());
    } else if (void 0 !== array[indexByKey(keyInfo, array, keyValue)]) {
      return getErrorResult(isBatch, logError, "E4008");
    }
  } else {
    keyValue = obj;
  }
  if (index2 >= 0) {
    array.splice(index2, 0, obj);
  } else {
    array.push(obj);
  }
  setDataByKeyMapValue(array, keyValue, obj);
  if (!isBatch) {
    return trivialPromise(config_default().useLegacyStoreResult ? data2 : obj, keyValue);
  }
}
function remove4(keyInfo, array, key, isBatch, logError) {
  const index2 = indexByKey(keyInfo, array, key);
  if (index2 > -1) {
    array.splice(index2, 1);
    setDataByKeyMapValue(array, key, null);
  }
  if (!isBatch) {
    return trivialPromise(key);
  } else if (index2 < 0) {
    return getErrorResult(isBatch, logError, "E4009");
  }
}
function indexByKey(keyInfo, array, key) {
  const keyExpr = keyInfo.key();
  if (!getHasKeyCacheValue(array, key)) {
    return -1;
  }
  for (let i = 0, arrayLength = array.length; i < arrayLength; i++) {
    if (keysEqual(keyExpr, keyInfo.keyOf(array[i]), key)) {
      return i;
    }
  }
  return -1;
}

// ../../../../../../node_modules/devextreme/esm/data/array_query.js
var Iterator = class_default.inherit({
  toArray: function() {
    const result2 = [];
    this.reset();
    while (this.next()) {
      result2.push(this.current());
    }
    return result2;
  },
  countable: function() {
    return false;
  }
});
var ArrayIterator = Iterator.inherit({
  ctor: function(array) {
    this.array = array;
    this.index = -1;
  },
  next: function() {
    if (this.index + 1 < this.array.length) {
      this.index++;
      return true;
    }
    return false;
  },
  current: function() {
    return this.array[this.index];
  },
  reset: function() {
    this.index = -1;
  },
  toArray: function() {
    return this.array.slice(0);
  },
  countable: function() {
    return true;
  },
  count: function() {
    return this.array.length;
  }
});
var WrappedIterator = Iterator.inherit({
  ctor: function(iter) {
    this.iter = iter;
  },
  next: function() {
    return this.iter.next();
  },
  current: function() {
    return this.iter.current();
  },
  reset: function() {
    return this.iter.reset();
  }
});
var MapIterator = WrappedIterator.inherit({
  ctor: function(iter, mapper) {
    this.callBase(iter);
    this.index = -1;
    this.mapper = mapper;
  },
  current: function() {
    return this.mapper(this.callBase(), this.index);
  },
  next: function() {
    const hasNext = this.callBase();
    if (hasNext) {
      this.index++;
    }
    return hasNext;
  }
});
var defaultCompare = function(xValue, yValue, options2) {
  if (isString(xValue) && isString(yValue) && (null !== options2 && void 0 !== options2 && options2.locale || null !== options2 && void 0 !== options2 && options2.collatorOptions)) {
    return new Intl.Collator((null === options2 || void 0 === options2 ? void 0 : options2.locale) || void 0, (null === options2 || void 0 === options2 ? void 0 : options2.collatorOptions) || void 0).compare(xValue, yValue);
  }
  xValue = toComparable(xValue, false, options2);
  yValue = toComparable(yValue, false, options2);
  if (null === xValue && null !== yValue) {
    return -1;
  }
  if (null !== xValue && null === yValue) {
    return 1;
  }
  if (void 0 === xValue && void 0 !== yValue) {
    return 1;
  }
  if (void 0 !== xValue && void 0 === yValue) {
    return -1;
  }
  if (xValue < yValue) {
    return -1;
  }
  if (xValue > yValue) {
    return 1;
  }
  return 0;
};
var SortIterator = Iterator.inherit({
  ctor: function(iter, getter, desc, compare3) {
    this.langParams = iter.langParams;
    if (!(iter instanceof MapIterator)) {
      iter = new MapIterator(iter, this._wrap);
      iter.langParams = this.langParams;
    }
    this.iter = iter;
    this.rules = [{
      getter,
      desc,
      compare: compare3,
      langParams: this.langParams
    }];
  },
  thenBy: function(getter, desc, compare3) {
    const result2 = new SortIterator(this.sortedIter || this.iter, getter, desc, compare3);
    if (!this.sortedIter) {
      result2.rules = this.rules.concat(result2.rules);
    }
    return result2;
  },
  next: function() {
    this._ensureSorted();
    return this.sortedIter.next();
  },
  current: function() {
    this._ensureSorted();
    return this.sortedIter.current();
  },
  reset: function() {
    delete this.sortedIter;
  },
  countable: function() {
    return this.sortedIter || this.iter.countable();
  },
  count: function() {
    if (this.sortedIter) {
      return this.sortedIter.count();
    }
    return this.iter.count();
  },
  _ensureSorted: function() {
    const that = this;
    if (that.sortedIter) {
      return;
    }
    each(that.rules, function() {
      this.getter = compileGetter(this.getter);
    });
    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function(x, y) {
      return that._compare(x, y);
    })), that._unwrap);
  },
  _wrap: function(record, index2) {
    return {
      index: index2,
      value: record
    };
  },
  _unwrap: function(wrappedItem) {
    return wrappedItem.value;
  },
  _getDefaultCompare: (langParams) => (xValue, yValue) => defaultCompare(xValue, yValue, langParams),
  _compare: function(x, y) {
    const xIndex = x.index;
    const yIndex = y.index;
    x = x.value;
    y = y.value;
    if (x === y) {
      return xIndex - yIndex;
    }
    for (let i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
      const rule = this.rules[i];
      const xValue = rule.getter(x);
      const yValue = rule.getter(y);
      const compare3 = rule.compare || this._getDefaultCompare(rule.langParams);
      const compareResult = compare3(xValue, yValue);
      if (compareResult) {
        return rule.desc ? -compareResult : compareResult;
      }
    }
    return xIndex - yIndex;
  }
});
var compileCriteria = function() {
  let langParams = {};
  const _toComparable = (value2) => toComparable(value2, false, langParams);
  const compileGroup = function(crit) {
    if (isUniformEqualsByOr(crit)) {
      return ((crit2) => {
        const getter = compileGetter(crit2[0][0]);
        const filterValues = crit2.reduce((acc, item, i) => {
          if (i % 2 === 0) {
            acc.push(_toComparable(item[2]));
          }
          return acc;
        }, []);
        return (obj) => {
          const value2 = _toComparable(getter(obj));
          return filterValues.some((filterValue) => useStrictComparison(filterValue) ? value2 === filterValue : value2 == filterValue);
        };
      })(crit);
    }
    const ops = [];
    let isConjunctiveOperator2 = false;
    let isConjunctiveNextOperator = false;
    each(crit, function() {
      if (Array.isArray(this) || isFunction(this)) {
        if (ops.length > 1 && isConjunctiveOperator2 !== isConjunctiveNextOperator) {
          throw new errors.Error("E4019");
        }
        ops.push(compileCriteria(this, langParams));
        isConjunctiveOperator2 = isConjunctiveNextOperator;
        isConjunctiveNextOperator = true;
      } else {
        isConjunctiveNextOperator = isConjunctiveOperator(this);
      }
    });
    return function(d) {
      let result2 = isConjunctiveOperator2;
      for (let i = 0; i < ops.length; i++) {
        if (ops[i](d) !== isConjunctiveOperator2) {
          result2 = !isConjunctiveOperator2;
          break;
        }
      }
      return result2;
    };
  };
  const toString = function(value2) {
    var _langParams;
    return isDefined(value2) ? null !== (_langParams = langParams) && void 0 !== _langParams && _langParams.locale ? value2.toLocaleString(langParams.locale) : value2.toString() : "";
  };
  function compileEquals(getter, value2, negate) {
    return function(obj) {
      obj = _toComparable(getter(obj));
      let result2 = useStrictComparison(value2) ? obj === value2 : obj == value2;
      if (negate) {
        result2 = !result2;
      }
      return result2;
    };
  }
  function useStrictComparison(value2) {
    return "" === value2 || 0 === value2 || false === value2;
  }
  return function(crit, options2) {
    langParams = options2 || {};
    if (isFunction(crit)) {
      return crit;
    }
    if (isGroupCriterion(crit)) {
      return compileGroup(crit);
    }
    if (isUnaryOperation(crit)) {
      return function(crit2) {
        const op = crit2[0];
        const criteria = compileCriteria(crit2[1], langParams);
        if ("!" === op) {
          return function(obj) {
            return !criteria(obj);
          };
        }
        throw errors.Error("E4003", op);
      }(crit);
    }
    return function(crit2) {
      crit2 = normalizeBinaryCriterion(crit2);
      const getter = compileGetter(crit2[0]);
      const op = crit2[1];
      let value2 = crit2[2];
      value2 = _toComparable(value2);
      const compare3 = (obj, operatorFn) => {
        obj = _toComparable(getter(obj));
        return (null == value2 || null == obj) && value2 !== obj ? false : operatorFn(obj, value2);
      };
      switch (op.toLowerCase()) {
        case "=":
          return compileEquals(getter, value2);
        case "<>":
          return compileEquals(getter, value2, true);
        case ">":
          return (obj) => compare3(obj, (a, b) => a > b);
        case "<":
          return (obj) => compare3(obj, (a, b) => a < b);
        case ">=":
          return (obj) => compare3(obj, (a, b) => a >= b);
        case "<=":
          return (obj) => compare3(obj, (a, b) => a <= b);
        case "startswith":
          return function(obj) {
            return 0 === _toComparable(toString(getter(obj))).indexOf(value2);
          };
        case "endswith":
          return function(obj) {
            const getterValue = _toComparable(toString(getter(obj)));
            const searchValue = toString(value2);
            if (getterValue.length < searchValue.length) {
              return false;
            }
            const index2 = getterValue.lastIndexOf(value2);
            return -1 !== index2 && index2 === getterValue.length - value2.length;
          };
        case "contains":
          return function(obj) {
            return _toComparable(toString(getter(obj))).indexOf(value2) > -1;
          };
        case "notcontains":
          return function(obj) {
            return -1 === _toComparable(toString(getter(obj))).indexOf(value2);
          };
      }
      throw errors.Error("E4003", op);
    }(crit);
  };
}();
var FilterIterator = WrappedIterator.inherit({
  ctor: function(iter, criteria) {
    this.callBase(iter);
    this.langParams = iter.langParams;
    this.criteria = compileCriteria(criteria, this.langParams);
  },
  next: function() {
    while (this.iter.next()) {
      if (this.criteria(this.current())) {
        return true;
      }
    }
    return false;
  }
});
var GroupIterator = Iterator.inherit({
  ctor: function(iter, getter) {
    this.iter = iter;
    this.getter = getter;
  },
  next: function() {
    this._ensureGrouped();
    return this.groupedIter.next();
  },
  current: function() {
    this._ensureGrouped();
    return this.groupedIter.current();
  },
  reset: function() {
    delete this.groupedIter;
  },
  countable: function() {
    return !!this.groupedIter;
  },
  count: function() {
    return this.groupedIter.count();
  },
  _ensureGrouped: function() {
    if (this.groupedIter) {
      return;
    }
    const hash = {};
    const keys = [];
    const iter = this.iter;
    const getter = compileGetter(this.getter);
    iter.reset();
    while (iter.next()) {
      const current2 = iter.current();
      const key = getter(current2);
      if (key in hash) {
        hash[key].push(current2);
      } else {
        hash[key] = [current2];
        keys.push(key);
      }
    }
    this.groupedIter = new ArrayIterator(map(keys, function(key) {
      return {
        key,
        items: hash[key]
      };
    }));
  }
});
var SelectIterator = WrappedIterator.inherit({
  ctor: function(iter, getter) {
    this.callBase(iter);
    this.getter = compileGetter(getter);
  },
  current: function() {
    return this.getter(this.callBase());
  },
  countable: function() {
    return this.iter.countable();
  },
  count: function() {
    return this.iter.count();
  }
});
var SliceIterator = WrappedIterator.inherit({
  ctor: function(iter, skip, take) {
    this.callBase(iter);
    this.skip = Math.max(0, skip);
    this.take = Math.max(0, take);
    this.pos = 0;
  },
  next: function() {
    if (this.pos >= this.skip + this.take) {
      return false;
    }
    while (this.pos < this.skip && this.iter.next()) {
      this.pos++;
    }
    this.pos++;
    return this.iter.next();
  },
  reset: function() {
    this.callBase();
    this.pos = 0;
  },
  countable: function() {
    return this.iter.countable();
  },
  count: function() {
    return Math.min(this.iter.count() - this.skip, this.take);
  }
});
var arrayQueryImpl = function(iter, queryOptions) {
  queryOptions = queryOptions || {};
  if (!(iter instanceof Iterator)) {
    iter = new ArrayIterator(iter);
  }
  if (queryOptions.langParams) {
    iter.langParams = queryOptions.langParams;
  }
  const handleError2 = function(error) {
    const handler = queryOptions.errorHandler;
    if (handler) {
      handler(error);
    }
    handleError(error);
  };
  const aggregateCore = function(aggregator) {
    const d = new Deferred().fail(handleError2);
    let seed;
    const step = aggregator.step;
    const finalize = aggregator.finalize;
    try {
      iter.reset();
      if ("seed" in aggregator) {
        seed = aggregator.seed;
      } else {
        seed = iter.next() ? iter.current() : NaN;
      }
      let accumulator = seed;
      while (iter.next()) {
        accumulator = step(accumulator, iter.current());
      }
      d.resolve(finalize ? finalize(accumulator) : accumulator);
    } catch (x) {
      d.reject(x);
    }
    return d.promise();
  };
  const standardAggregate = function(name2) {
    return aggregateCore(aggregators[name2]);
  };
  const select = function(getter) {
    if (!isFunction(getter) && !Array.isArray(getter)) {
      getter = [].slice.call(arguments);
    }
    return chainQuery(new SelectIterator(iter, getter));
  };
  const selectProp = function(name2) {
    return select(compileGetter(name2));
  };
  function chainQuery(iter2) {
    return arrayQueryImpl(iter2, queryOptions);
  }
  return {
    toArray: function() {
      return iter.toArray();
    },
    enumerate: function() {
      const d = new Deferred().fail(handleError2);
      try {
        d.resolve(iter.toArray());
      } catch (x) {
        d.reject(x);
      }
      return d.promise();
    },
    setLangParams(options2) {
      iter.langParams = options2;
    },
    sortBy: function(getter, desc, compare3) {
      return chainQuery(new SortIterator(iter, getter, desc, compare3));
    },
    thenBy: function(getter, desc, compare3) {
      if (iter instanceof SortIterator) {
        return chainQuery(iter.thenBy(getter, desc, compare3));
      }
      throw errors.Error("E4004");
    },
    filter: function(criteria) {
      if (!Array.isArray(criteria)) {
        criteria = [].slice.call(arguments);
      }
      return chainQuery(new FilterIterator(iter, criteria));
    },
    slice: function(skip, take) {
      if (void 0 === take) {
        take = Number.MAX_VALUE;
      }
      return chainQuery(new SliceIterator(iter, skip, take));
    },
    select,
    groupBy: function(getter) {
      return chainQuery(new GroupIterator(iter, getter));
    },
    aggregate: function(seed, step, finalize) {
      if (arguments.length < 2) {
        return aggregateCore({
          step: arguments[0]
        });
      }
      return aggregateCore({
        seed,
        step,
        finalize
      });
    },
    count: function() {
      if (iter.countable()) {
        const d = new Deferred().fail(handleError2);
        try {
          d.resolve(iter.count());
        } catch (x) {
          d.reject(x);
        }
        return d.promise();
      }
      return standardAggregate("count");
    },
    sum: function(getter) {
      if (getter) {
        return selectProp(getter).sum();
      }
      return standardAggregate("sum");
    },
    min: function(getter) {
      if (getter) {
        return selectProp(getter).min();
      }
      return standardAggregate("min");
    },
    max: function(getter) {
      if (getter) {
        return selectProp(getter).max();
      }
      return standardAggregate("max");
    },
    avg: function(getter) {
      if (getter) {
        return selectProp(getter).avg();
      }
      return standardAggregate("avg");
    }
  };
};
var array_query_default = arrayQueryImpl;

// ../../../../../../node_modules/devextreme/esm/data/store_helper.js
function multiLevelGroup(query2, groupInfo) {
  query2 = query2.groupBy(groupInfo[0].selector);
  if (groupInfo.length > 1) {
    query2 = query2.select(function(g) {
      return extend({}, g, {
        items: multiLevelGroup(array_query_default(g.items), groupInfo.slice(1)).toArray()
      });
    });
  }
  return query2;
}
function arrangeSortingInfo(groupInfo, sortInfo) {
  const filteredGroup = [];
  each(groupInfo, function(_, group) {
    const collision = grep(sortInfo, function(sort) {
      return group.selector === sort.selector;
    });
    if (collision.length < 1) {
      filteredGroup.push(group);
    }
  });
  return filteredGroup.concat(sortInfo);
}
function queryByOptions(query2, options2, isCountQuery) {
  var _options;
  options2 = options2 || {};
  const filter = options2.filter;
  if (null !== (_options = options2) && void 0 !== _options && _options.langParams) {
    var _query$setLangParams, _query;
    null === (_query$setLangParams = (_query = query2).setLangParams) || void 0 === _query$setLangParams || _query$setLangParams.call(_query, options2.langParams);
  }
  if (filter) {
    query2 = query2.filter(filter);
  }
  if (isCountQuery) {
    return query2;
  }
  let sort = options2.sort;
  const select = options2.select;
  let group = options2.group;
  const skip = options2.skip;
  const take = options2.take;
  if (group) {
    group = normalizeSortingInfo(group);
    group.keepInitialKeyOrder = !!options2.group.keepInitialKeyOrder;
  }
  if (sort || group) {
    sort = normalizeSortingInfo(sort || []);
    if (group && !group.keepInitialKeyOrder) {
      sort = arrangeSortingInfo(group, sort);
    }
    each(sort, function(index2) {
      query2 = query2[index2 ? "thenBy" : "sortBy"](this.selector, this.desc, this.compare);
    });
  }
  if (select) {
    query2 = query2.select(select);
  }
  if (group) {
    query2 = multiLevelGroup(query2, group);
  }
  if (take || skip) {
    query2 = query2.slice(skip || 0, take);
  }
  return query2;
}
var store_helper_default = {
  multiLevelGroup,
  arrangeSortingInfo,
  queryByOptions
};

// ../../../../../../node_modules/devextreme/esm/data/abstract_store.js
var abstract4 = class_default.abstract;
var queryByOptions2 = store_helper_default.queryByOptions;
var storeImpl = {};
var Store = class_default.inherit({
  _langParams: {},
  ctor: function(options2) {
    const that = this;
    options2 = options2 || {};
    this._eventsStrategy = new EventsStrategy(this);
    each(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onPush", "onRemoved", "onRemoving", "onModified", "onModifying"], function(_, optionName) {
      if (optionName in options2) {
        that.on(optionName.slice(2).toLowerCase(), options2[optionName]);
      }
    });
    this._key = options2.key;
    this._errorHandler = options2.errorHandler;
    this._useDefaultSearch = true;
  },
  _clearCache: noop2,
  _customLoadOptions: function() {
    return null;
  },
  key: function() {
    return this._key;
  },
  keyOf: function(obj) {
    if (!this._keyGetter) {
      this._keyGetter = compileGetter(this.key());
    }
    return this._keyGetter(obj);
  },
  _requireKey: function() {
    if (!this.key()) {
      throw errors.Error("E4005");
    }
  },
  load: function(options2) {
    const that = this;
    options2 = options2 || {};
    this._eventsStrategy.fireEvent("loading", [options2]);
    return this._withLock(this._loadImpl(options2)).done(function(result2) {
      that._eventsStrategy.fireEvent("loaded", [result2, options2]);
    });
  },
  _loadImpl: function(options2) {
    if (!isEmptyObject(this._langParams)) {
      options2 = options2 || {};
      options2._langParams = _extends({}, this._langParams, options2._langParams);
    }
    return queryByOptions2(this.createQuery(options2), options2).enumerate();
  },
  _withLock: function(task) {
    const result2 = new Deferred();
    task.done(function() {
      const that = this;
      const args = arguments;
      processRequestResultLock.promise().done(function() {
        result2.resolveWith(that, args);
      });
    }).fail(function() {
      result2.rejectWith(this, arguments);
    });
    return result2;
  },
  createQuery: abstract4,
  totalCount: function(options2) {
    return this._totalCountImpl(options2);
  },
  _totalCountImpl: function(options2) {
    return queryByOptions2(this.createQuery(options2), options2, true).count();
  },
  byKey: function(key, extraOptions) {
    return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)));
  },
  _byKeyImpl: abstract4,
  insert: function(values) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("inserting", [values]);
    return that._addFailHandlers(that._insertImpl(values).done(function(callbackValues, callbackKey) {
      that._eventsStrategy.fireEvent("inserted", [callbackValues, callbackKey]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _insertImpl: abstract4,
  update: function(key, values) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("updating", [key, values]);
    return that._addFailHandlers(that._updateImpl(key, values).done(function() {
      that._eventsStrategy.fireEvent("updated", [key, values]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _updateImpl: abstract4,
  push: function(changes) {
    const beforePushArgs = {
      changes,
      waitFor: []
    };
    this._eventsStrategy.fireEvent("beforePushAggregation", [beforePushArgs]);
    when(...beforePushArgs.waitFor).done(() => {
      this._pushImpl(changes);
      this._eventsStrategy.fireEvent("beforePush", [{
        changes
      }]);
      this._eventsStrategy.fireEvent("push", [changes]);
    });
  },
  _pushImpl: noop2,
  remove: function(key) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("removing", [key]);
    return that._addFailHandlers(that._removeImpl(key).done(function(callbackKey) {
      that._eventsStrategy.fireEvent("removed", [callbackKey]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _removeImpl: abstract4,
  _addFailHandlers: function(deferred) {
    return deferred.fail(this._errorHandler).fail(handleError);
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
Store.create = function(alias, options2) {
  if (!(alias in storeImpl)) {
    throw errors.Error("E4020", alias);
  }
  return new storeImpl[alias](options2);
};
Store.registerClass = function(type2, alias) {
  if (alias) {
    storeImpl[alias] = type2;
  }
  return type2;
};
Store.inherit = function(inheritor) {
  return function(members, alias) {
    const type2 = inheritor.apply(this, [members]);
    Store.registerClass(type2, alias);
    return type2;
  };
}(Store.inherit);
var abstract_store_default = Store;

// ../../../../../../node_modules/devextreme/esm/data/custom_store.js
var TOTAL_COUNT = "totalCount";
var LOAD = "load";
var BY_KEY = "byKey";
var INSERT = "insert";
var UPDATE = "update";
var REMOVE = "remove";
function isPromise2(obj) {
  return obj && isFunction(obj.then);
}
function trivialPromise2(value2) {
  return new Deferred().resolve(value2).promise();
}
function ensureRequiredFuncOption(name2, obj) {
  if (!isFunction(obj)) {
    throw errors.Error("E4011", name2);
  }
}
function throwInvalidUserFuncResult(name2) {
  throw errors.Error("E4012", name2);
}
function createUserFuncFailureHandler(pendingDeferred) {
  return function(arg) {
    let error;
    if (arg instanceof Error) {
      error = arg;
    } else {
      error = new Error(function(promiseArguments) {
        const xhr = promiseArguments[0];
        const textStatus = promiseArguments[1];
        if (!xhr || !xhr.getResponseHeader) {
          return null;
        }
        return errorMessageFromXhr(xhr, textStatus);
      }(arguments) || arg && String(arg) || "Unknown error");
    }
    if (error.message !== XHR_ERROR_UNLOAD) {
      pendingDeferred.reject(error);
    }
  };
}
function invokeUserLoad(store, options2) {
  const userFunc = store._loadFunc;
  let userResult;
  ensureRequiredFuncOption(LOAD, userFunc);
  userResult = userFunc.apply(store, [options2]);
  if (Array.isArray(userResult)) {
    userResult = trivialPromise2(userResult);
  } else if (null === userResult || void 0 === userResult) {
    userResult = trivialPromise2([]);
  } else if (!isPromise2(userResult)) {
    throwInvalidUserFuncResult(LOAD);
  }
  return fromPromise(userResult);
}
function invokeUserTotalCountFunc(store, options2) {
  const userFunc = store._totalCountFunc;
  let userResult;
  if (!isFunction(userFunc)) {
    throw errors.Error("E4021");
  }
  userResult = userFunc.apply(store, [options2]);
  if (!isPromise2(userResult)) {
    userResult = Number(userResult);
    if (!isFinite(userResult)) {
      throwInvalidUserFuncResult(TOTAL_COUNT);
    }
    userResult = trivialPromise2(userResult);
  }
  return fromPromise(userResult);
}
function invokeUserByKeyFunc(store, key, extraOptions) {
  const userFunc = store._byKeyFunc;
  let userResult;
  ensureRequiredFuncOption(BY_KEY, userFunc);
  userResult = userFunc.apply(store, [key, extraOptions]);
  if (!isPromise2(userResult)) {
    userResult = trivialPromise2(userResult);
  }
  return fromPromise(userResult);
}
function runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {
  if (store.__rawData) {
    continuation(store.__rawData);
  } else {
    const loadPromise = store.__rawDataPromise || invokeUserLoad(store, userFuncOptions);
    if (store._cacheRawData) {
      store.__rawDataPromise = loadPromise;
    }
    loadPromise.always(function() {
      delete store.__rawDataPromise;
    }).done(function(rawData) {
      if (store._cacheRawData) {
        store.__rawData = rawData;
      }
      continuation(rawData);
    }).fail((error) => {
      var _store$_errorHandler;
      const userFuncFailureHandler = createUserFuncFailureHandler(pendingDeferred);
      null === (_store$_errorHandler = store._errorHandler) || void 0 === _store$_errorHandler || _store$_errorHandler.call(store, error);
      userFuncFailureHandler(error);
    });
  }
}
function runRawLoadWithQuery(pendingDeferred, store, options2, countOnly) {
  options2 = options2 || {};
  const userFuncOptions = {};
  if ("userData" in options2) {
    userFuncOptions.userData = options2.userData;
  }
  runRawLoad(pendingDeferred, store, userFuncOptions, function(rawData) {
    const rawDataQuery = array_query_default(rawData, {
      errorHandler: store._errorHandler
    });
    let itemsQuery;
    let totalCountQuery;
    const waitList = [];
    let items;
    let totalCount;
    if (!countOnly) {
      itemsQuery = store_helper_default.queryByOptions(rawDataQuery, options2);
      if (itemsQuery === rawDataQuery) {
        items = rawData.slice(0);
      } else {
        waitList.push(itemsQuery.enumerate().done(function(asyncResult) {
          items = asyncResult;
        }));
      }
    }
    if (options2.requireTotalCount || countOnly) {
      totalCountQuery = store_helper_default.queryByOptions(rawDataQuery, options2, true);
      if (totalCountQuery === rawDataQuery) {
        totalCount = rawData.length;
      } else {
        waitList.push(totalCountQuery.count().done(function(asyncResult) {
          totalCount = asyncResult;
        }));
      }
    }
    when.apply(renderer_default, waitList).done(function() {
      if (countOnly) {
        pendingDeferred.resolve(totalCount);
      } else if (options2.requireTotalCount) {
        pendingDeferred.resolve(items, {
          totalCount
        });
      } else {
        pendingDeferred.resolve(items);
      }
    }).fail(function(x) {
      pendingDeferred.reject(x);
    });
  });
}
function runRawLoadWithKey(pendingDeferred, store, key) {
  runRawLoad(pendingDeferred, store, {}, function(rawData) {
    const keyExpr = store.key();
    let item;
    for (let i = 0, len = rawData.length; i < len; i++) {
      item = rawData[i];
      if (keysEqual(keyExpr, store.keyOf(rawData[i]), key)) {
        pendingDeferred.resolve(item);
        return;
      }
    }
    pendingDeferred.reject(errors.Error("E4009"));
  });
}
var CustomStore = abstract_store_default.inherit({
  ctor: function(options2) {
    options2 = options2 || {};
    this.callBase(options2);
    this._useDefaultSearch = !!options2.useDefaultSearch || "raw" === options2.loadMode;
    this._loadMode = options2.loadMode;
    this._cacheRawData = false !== options2.cacheRawData;
    this._loadFunc = options2[LOAD];
    this._totalCountFunc = options2[TOTAL_COUNT];
    this._byKeyFunc = options2[BY_KEY];
    this._insertFunc = options2[INSERT];
    this._updateFunc = options2[UPDATE];
    this._removeFunc = options2[REMOVE];
  },
  _clearCache() {
    delete this.__rawData;
  },
  createQuery: function() {
    throw errors.Error("E4010");
  },
  clearRawDataCache: function() {
    this._clearCache();
  },
  _totalCountImpl: function(options2) {
    let d = new Deferred();
    if ("raw" === this._loadMode && !this._totalCountFunc) {
      runRawLoadWithQuery(d, this, options2, true);
    } else {
      invokeUserTotalCountFunc(this, options2).done(function(count) {
        d.resolve(Number(count));
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _pushImpl: function(changes) {
    if (this.__rawData) {
      applyBatch({
        keyInfo: this,
        data: this.__rawData,
        changes
      });
    }
  },
  _loadImpl: function(options2) {
    let d = new Deferred();
    if ("raw" === this._loadMode) {
      runRawLoadWithQuery(d, this, options2, false);
    } else {
      invokeUserLoad(this, options2).done(function(data2, extra) {
        d.resolve(data2, extra);
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _byKeyImpl: function(key, extraOptions) {
    const d = new Deferred();
    if (this._byKeyViaLoad()) {
      this._requireKey();
      runRawLoadWithKey(d, this, key);
    } else {
      invokeUserByKeyFunc(this, key, extraOptions).done(function(obj) {
        d.resolve(obj);
      }).fail(createUserFuncFailureHandler(d));
    }
    return d.promise();
  },
  _byKeyViaLoad: function() {
    return "raw" === this._loadMode && !this._byKeyFunc;
  },
  _insertImpl: function(values) {
    const that = this;
    const userFunc = that._insertFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(INSERT, userFunc);
    userResult = userFunc.apply(that, [values]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2(userResult);
    }
    fromPromise(userResult).done(function(serverResponse) {
      if (config_default().useLegacyStoreResult) {
        d.resolve(values, serverResponse);
      } else {
        d.resolve(serverResponse || values, that.keyOf(serverResponse));
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _updateImpl: function(key, values) {
    const userFunc = this._updateFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(UPDATE, userFunc);
    userResult = userFunc.apply(this, [key, values]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2(userResult);
    }
    fromPromise(userResult).done(function(serverResponse) {
      if (config_default().useLegacyStoreResult) {
        d.resolve(key, values);
      } else {
        d.resolve(serverResponse || values, key);
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _removeImpl: function(key) {
    const userFunc = this._removeFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(REMOVE, userFunc);
    userResult = userFunc.apply(this, [key]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2();
    }
    fromPromise(userResult).done(function() {
      d.resolve(key);
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  }
});
var custom_store_default = CustomStore;

// ../../../../../../node_modules/devextreme/esm/core/utils/queue.js
function createQueue2(discardPendingTasks) {
  let _tasks = [];
  let _busy = false;
  function exec() {
    while (_tasks.length) {
      _busy = true;
      const task = _tasks.shift();
      const result2 = task();
      if (void 0 === result2) {
        continue;
      }
      if (result2.then) {
        when(result2).always(exec);
        return;
      }
      throw errors_default.Error("E0015");
    }
    _busy = false;
  }
  return {
    add: function(task, removeTaskCallback) {
      if (!discardPendingTasks) {
        _tasks.push(task);
      } else {
        if (_tasks[0] && removeTaskCallback) {
          removeTaskCallback(_tasks[0]);
        }
        _tasks = [task];
      }
      if (!_busy) {
        exec();
      }
    },
    busy: function() {
      return _busy;
    }
  };
}
var enqueue = createQueue2().add;

// ../../../../../../node_modules/devextreme/esm/core/http_request.js
var window16 = getWindow();
var nativeXMLHttpRequest = {
  getXhr: function() {
    return new window16.XMLHttpRequest();
  }
};
var http_request_default = dependency_injector_default(nativeXMLHttpRequest);

// ../../../../../../node_modules/devextreme/esm/core/utils/ajax_utils.js
var window17 = getWindow();
var createScript = function(options2) {
  const script = dom_adapter_default.createElement("script");
  for (const name2 in options2) {
    script[name2] = options2[name2];
  }
  return script;
};
var appendToHead = function(element) {
  return dom_adapter_default.getHead().appendChild(element);
};
var removeScript = function(scriptNode) {
  scriptNode.parentNode.removeChild(scriptNode);
};
var evalScript = function(code) {
  const script = createScript({
    text: code
  });
  appendToHead(script);
  removeScript(script);
};
var evalCrossDomainScript = function(url) {
  const script = createScript({
    src: url
  });
  return new Promise(function(resolve, reject) {
    const events = {
      load: resolve,
      error: reject
    };
    const loadHandler = function(e) {
      events[e.type]();
      removeScript(script);
    };
    for (const event in events) {
      dom_adapter_default.listen(script, event, loadHandler);
    }
    appendToHead(script);
  });
};
function getMethod(options2) {
  return (options2.method || "GET").toUpperCase();
}
var paramsConvert = function(params) {
  const result2 = [];
  for (const name2 in params) {
    let value2 = params[name2];
    if (void 0 === value2) {
      continue;
    }
    if (null === value2) {
      value2 = "";
    }
    if ("function" === typeof value2) {
      value2 = value2();
    }
    result2.push(encodeURIComponent(name2) + "=" + encodeURIComponent(value2));
  }
  return result2.join("&");
};
var getContentTypeHeader = function(options2) {
  let defaultContentType;
  if (options2.data && !options2.upload && "GET" !== getMethod(options2)) {
    defaultContentType = "application/x-www-form-urlencoded;charset=utf-8";
  }
  return options2.contentType || defaultContentType;
};
var getAcceptHeader = function(options2) {
  const dataType = options2.dataType || "*";
  const scriptAccept = "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript";
  const accepts = {
    "*": "*/*",
    text: "text/plain",
    html: "text/html",
    xml: "application/xml, text/xml",
    json: "application/json, text/javascript",
    jsonp: scriptAccept,
    script: scriptAccept
  };
  extendFromObject(accepts, options2.accepts, true);
  return accepts[dataType] ? accepts[dataType] + ("*" !== dataType ? ", */*; q=0.01" : "") : accepts["*"];
};
var getRequestHeaders = function(options2) {
  const headers = options2.headers || {};
  headers["Content-Type"] = headers["Content-Type"] || getContentTypeHeader(options2);
  headers.Accept = headers.Accept || getAcceptHeader(options2);
  if (!options2.crossDomain && !headers["X-Requested-With"]) {
    headers["X-Requested-With"] = "XMLHttpRequest";
  }
  return headers;
};
var getJsonpOptions = function(options2) {
  if ("jsonp" === options2.dataType) {
    const random = Math.random().toString().replace(/\D/g, "");
    const callbackName = options2.jsonpCallback || "dxCallback" + Date.now() + "_" + random;
    const callbackParameter = options2.jsonp || "callback";
    options2.data = options2.data || {};
    options2.data[callbackParameter] = callbackName;
    return callbackName;
  }
};
var getRequestOptions = function(options2, headers) {
  let params = options2.data;
  const paramsAlreadyString = "string" === typeof params;
  let url = options2.url || window17.location.href;
  if (!paramsAlreadyString && !options2.cache) {
    params = params || {};
    params._ = Date.now();
  }
  if (params && !options2.upload) {
    if (!paramsAlreadyString) {
      params = paramsConvert(params);
    }
    if ("GET" === getMethod(options2)) {
      if ("" !== params) {
        url += (url.indexOf("?") > -1 ? "&" : "?") + params;
      }
      params = null;
    } else if (headers["Content-Type"] && headers["Content-Type"].indexOf("application/x-www-form-urlencoded") > -1) {
      params = params.replace(/%20/g, "+");
    }
  }
  return {
    url,
    parameters: params
  };
};
var isCrossDomain = function(url) {
  if (!hasWindow()) {
    return true;
  }
  let crossDomain = false;
  const originAnchor = dom_adapter_default.createElement("a");
  const urlAnchor = dom_adapter_default.createElement("a");
  originAnchor.href = window17.location.href;
  try {
    urlAnchor.href = url;
    urlAnchor.href = urlAnchor.href;
    crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
  } catch (e) {
    crossDomain = true;
  }
  return crossDomain;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/ajax.js
var window18 = getWindow();
var SUCCESS = "success";
var ERROR = "error";
var TIMEOUT = "timeout";
var NO_CONTENT = "nocontent";
var PARSER_ERROR = "parsererror";
var isStatusSuccess = function(status) {
  return 200 <= status && status < 300;
};
var hasContent = function(status) {
  return 204 !== status;
};
var getDataFromResponse = function(xhr) {
  return xhr.responseType && "text" !== xhr.responseType || "string" !== typeof xhr.responseText ? xhr.response : xhr.responseText;
};
var postProcess = function(deferred, xhr, dataType) {
  const data2 = getDataFromResponse(xhr);
  switch (dataType) {
    case "jsonp":
      evalScript(data2);
      break;
    case "script":
      evalScript(data2);
      deferred.resolve(data2, SUCCESS, xhr);
      break;
    case "json":
      try {
        deferred.resolve(JSON.parse(data2), SUCCESS, xhr);
      } catch (e) {
        deferred.reject(xhr, PARSER_ERROR, e);
      }
      break;
    default:
      deferred.resolve(data2, SUCCESS, xhr);
  }
};
var setHttpTimeout = function(timeout, xhr) {
  return timeout && setTimeout(function() {
    xhr.customStatus = TIMEOUT;
    xhr.abort();
  }, timeout);
};
var sendRequest = function(options2) {
  const xhr = http_request_default.getXhr();
  const d = new Deferred();
  const result2 = d.promise();
  const async = isDefined(options2.async) ? options2.async : true;
  const dataType = options2.dataType;
  const timeout = options2.timeout || 0;
  let timeoutId;
  options2.crossDomain = isCrossDomain(options2.url);
  const needScriptEvaluation = "jsonp" === dataType || "script" === dataType;
  if (void 0 === options2.cache) {
    options2.cache = !needScriptEvaluation;
  }
  const callbackName = getJsonpOptions(options2);
  const headers = getRequestHeaders(options2);
  const requestOptions = getRequestOptions(options2, headers);
  const url = requestOptions.url;
  const parameters = requestOptions.parameters;
  if (callbackName) {
    window18[callbackName] = function(data2) {
      d.resolve(data2, SUCCESS, xhr);
    };
  }
  if (options2.crossDomain && needScriptEvaluation) {
    const reject = function() {
      d.reject(xhr, ERROR);
    };
    const resolve = function() {
      if ("jsonp" === dataType) {
        return;
      }
      d.resolve(null, SUCCESS, xhr);
    };
    evalCrossDomainScript(url).then(resolve, reject);
    return result2;
  }
  if (options2.crossDomain && !("withCredentials" in xhr)) {
    d.reject(xhr, ERROR);
    return result2;
  }
  xhr.open(getMethod(options2), url, async, options2.username, options2.password);
  if (async) {
    xhr.timeout = timeout;
    timeoutId = setHttpTimeout(timeout, xhr);
  }
  xhr.onreadystatechange = function(e) {
    if (4 === xhr.readyState) {
      clearTimeout(timeoutId);
      if (isStatusSuccess(xhr.status)) {
        if (hasContent(xhr.status)) {
          postProcess(d, xhr, dataType);
        } else {
          d.resolve(null, NO_CONTENT, xhr);
        }
      } else {
        d.reject(xhr, xhr.customStatus || ERROR);
      }
    }
  };
  if (options2.upload) {
    xhr.upload.onprogress = options2.upload.onprogress;
    xhr.upload.onloadstart = options2.upload.onloadstart;
    xhr.upload.onabort = options2.upload.onabort;
  }
  if (options2.xhrFields) {
    for (const field in options2.xhrFields) {
      xhr[field] = options2.xhrFields[field];
    }
  }
  if ("arraybuffer" === options2.responseType) {
    xhr.responseType = options2.responseType;
  }
  for (const name2 in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name2) && isDefined(headers[name2])) {
      xhr.setRequestHeader(name2, headers[name2]);
    }
  }
  if (options2.beforeSend) {
    options2.beforeSend(xhr);
  }
  xhr.send(parameters);
  result2.abort = function() {
    xhr.abort();
  };
  return result2;
};
var ajax_default = dependency_injector_default({
  sendRequest
});

// ../../../../../../node_modules/devextreme/esm/data/query_adapters.js
var query_adapters_default = {};

// ../../../../../../node_modules/devextreme/esm/data/remote_query.js
var remoteQueryImpl = function(url, queryOptions, tasks) {
  tasks = tasks || [];
  queryOptions = queryOptions || {};
  const createTask = function(name2, args) {
    return {
      name: name2,
      args
    };
  };
  const exec = function(executorTask) {
    const d = new Deferred();
    let _adapterFactory;
    let _adapter;
    let _taskQueue;
    let _currentTask;
    let _mergedSortArgs;
    const rejectWithNotify = function(error) {
      const handler = queryOptions.errorHandler;
      if (handler) {
        handler(error);
      }
      handleError(error);
      d.reject(error);
    };
    function mergeSortTask(task) {
      switch (task.name) {
        case "sortBy":
          _mergedSortArgs = [task.args];
          return true;
        case "thenBy":
          if (!_mergedSortArgs) {
            throw errors.Error("E4004");
          }
          _mergedSortArgs.push(task.args);
          return true;
      }
      return false;
    }
    try {
      _adapterFactory = queryOptions.adapter;
      if (!isFunction(_adapterFactory)) {
        _adapterFactory = query_adapters_default[_adapterFactory];
      }
      _adapter = _adapterFactory(queryOptions);
      _taskQueue = [].concat(tasks).concat(executorTask);
      const optimize = _adapter.optimize;
      if (optimize) {
        optimize(_taskQueue);
      }
      while (_taskQueue.length) {
        _currentTask = _taskQueue[0];
        if (!mergeSortTask(_currentTask)) {
          if (_mergedSortArgs) {
            _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
            _mergedSortArgs = null;
            continue;
          }
          if ("enumerate" !== String(_currentTask.name)) {
            if (!_adapter[_currentTask.name] || false === _adapter[_currentTask.name].apply(_adapter, _currentTask.args)) {
              break;
            }
          }
        }
        _taskQueue.shift();
      }
      !function() {
        const head = _taskQueue[0];
        const unmergedTasks = [];
        if (head && "multiSort" === head.name) {
          _taskQueue.shift();
          each(head.args[0], function() {
            unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this));
          });
        }
        _taskQueue = unmergedTasks.concat(_taskQueue);
      }();
      _adapter.exec(url).done(function(result2, extra) {
        if (!_taskQueue.length) {
          d.resolve(result2, extra);
        } else {
          let clientChain = array_query_default(result2, {
            errorHandler: queryOptions.errorHandler
          });
          each(_taskQueue, function() {
            clientChain = clientChain[this.name].apply(clientChain, this.args);
          });
          clientChain.done(d.resolve).fail(d.reject);
        }
      }).fail(rejectWithNotify);
    } catch (x) {
      rejectWithNotify(x);
    }
    return d.promise();
  };
  const query2 = {};
  each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
    const name2 = String(this);
    query2[name2] = function() {
      return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name2, arguments)));
    };
  });
  each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
    const name2 = String(this);
    query2[name2] = function() {
      return exec.call(this, createTask(name2, arguments));
    };
  });
  return query2;
};
var remote_query_default = remoteQueryImpl;

// ../../../../../../node_modules/devextreme/esm/data/query_implementation.js
var queryImpl = {
  array: array_query_default,
  remote: remote_query_default
};

// ../../../../../../node_modules/devextreme/esm/data/query.js
var query = function() {
  const impl = Array.isArray(arguments[0]) ? "array" : "remote";
  return queryImpl[impl].apply(this, arguments);
};
var query_default = query;

// ../../../../../../node_modules/devextreme/esm/data/array_store.js
var ArrayStore = abstract_store_default.inherit({
  ctor: function(options2) {
    if (Array.isArray(options2)) {
      options2 = {
        data: options2
      };
    } else {
      options2 = options2 || {};
    }
    this.callBase(options2);
    const initialArray = options2.data;
    if (initialArray && !Array.isArray(initialArray)) {
      throw errors.Error("E4006");
    }
    this._array = initialArray || [];
  },
  createQuery: function() {
    return query_default(this._array, {
      errorHandler: this._errorHandler
    });
  },
  _byKeyImpl: function(key) {
    const index2 = indexByKey(this, this._array, key);
    if (-1 === index2) {
      return rejectedPromise(errors.Error("E4009"));
    }
    return trivialPromise(this._array[index2]);
  },
  _insertImpl: function(values) {
    return insert(this, this._array, values);
  },
  _pushImpl: function(changes) {
    applyBatch({
      keyInfo: this,
      data: this._array,
      changes
    });
  },
  _updateImpl: function(key, values) {
    return update(this, this._array, key, values);
  },
  _removeImpl: function(key) {
    return remove4(this, this._array, key);
  },
  clear: function() {
    this._eventsStrategy.fireEvent("modifying");
    this._array = [];
    this._eventsStrategy.fireEvent("modified");
  }
}, "array");
var array_store_default = ArrayStore;

// ../../../../../../node_modules/devextreme/esm/data/data_source/utils.js
var _excluded13 = ["items"];
var CANCELED_TOKEN = "canceled";
var isPending = (deferred) => "pending" === deferred.state();
var normalizeStoreLoadOptionAccessorArguments = (originalArguments) => {
  switch (originalArguments.length) {
    case 0:
      return;
    case 1:
      return originalArguments[0];
  }
  return [].slice.call(originalArguments);
};
var mapGroup = (group, level, mapper) => map(group, (item) => {
  const restItem = _objectWithoutPropertiesLoose(item, _excluded13);
  return _extends({}, restItem, {
    items: mapRecursive(item.items, level - 1, mapper)
  });
});
var mapRecursive = (items, level, mapper) => {
  if (!Array.isArray(items)) {
    return items;
  }
  return level ? mapGroup(items, level, mapper) : map(items, mapper);
};
var mapDataRespectingGrouping = (items, mapper, groupInfo) => {
  const level = groupInfo ? normalizeSortingInfo(groupInfo).length : 0;
  return mapRecursive(items, level, mapper);
};
var normalizeLoadResult = (data2, extra) => {
  var _data;
  if (null !== (_data = data2) && void 0 !== _data && _data.data) {
    extra = data2;
    data2 = data2.data;
  }
  if (!Array.isArray(data2)) {
    data2 = [data2];
  }
  return {
    data: data2,
    extra
  };
};
var createCustomStoreFromLoadFunc = (options2) => {
  const storeConfig = {};
  each(["useDefaultSearch", "key", "load", "loadMode", "cacheRawData", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
    storeConfig[this] = options2[this];
    delete options2[this];
  });
  return new custom_store_default(storeConfig);
};
var createStoreFromConfig = (storeConfig) => {
  const alias = storeConfig.type;
  delete storeConfig.type;
  return abstract_store_default.create(alias, storeConfig);
};
var createCustomStoreFromUrl = (url, normalizationOptions) => new custom_store_default({
  load: () => ajax_default.sendRequest({
    url,
    dataType: "json"
  }),
  loadMode: null === normalizationOptions || void 0 === normalizationOptions ? void 0 : normalizationOptions.fromUrlLoadMode
});
var normalizeDataSourceOptions = (options2, normalizationOptions) => {
  let store;
  if ("string" === typeof options2) {
    options2 = {
      paginate: false,
      store: createCustomStoreFromUrl(options2, normalizationOptions)
    };
  }
  if (void 0 === options2) {
    options2 = [];
  }
  if (Array.isArray(options2) || options2 instanceof abstract_store_default) {
    options2 = {
      store: options2
    };
  } else {
    options2 = extend({}, options2);
  }
  if (void 0 === options2.store) {
    options2.store = [];
  }
  store = options2.store;
  if ("load" in options2) {
    store = createCustomStoreFromLoadFunc(options2);
  } else if (Array.isArray(store)) {
    store = new array_store_default(store);
  } else if (isPlainObject(store)) {
    store = createStoreFromConfig(extend({}, store));
  }
  options2.store = store;
  return options2;
};

// ../../../../../../node_modules/devextreme/esm/data/data_source/operation_manager.js
var OperationManager = class {
  constructor() {
    this._counter = -1;
    this._deferreds = {};
  }
  add(deferred) {
    this._counter++;
    this._deferreds[this._counter] = deferred;
    return this._counter;
  }
  remove(operationId) {
    return delete this._deferreds[operationId];
  }
  cancel(operationId) {
    if (operationId in this._deferreds) {
      this._deferreds[operationId].reject(CANCELED_TOKEN);
      return true;
    }
    return false;
  }
  cancelAll() {
    while (this._counter > -1) {
      this.cancel(this._counter);
      this._counter--;
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/data/data_source/data_source.js
var DataSource = class_default.inherit({
  ctor(options2) {
    options2 = normalizeDataSourceOptions(options2);
    this._eventsStrategy = new EventsStrategy(this, {
      syncStrategy: true
    });
    this._store = options2.store;
    this._changedTime = 0;
    const needThrottling = 0 !== options2.pushAggregationTimeout;
    if (needThrottling) {
      const throttlingTimeout = void 0 === options2.pushAggregationTimeout ? () => 5 * this._changedTime : options2.pushAggregationTimeout;
      let pushDeferred;
      let lastPushWaiters;
      const throttlingPushHandler = throttleChanges((changes) => {
        pushDeferred.resolve();
        const storePushPending = when(...lastPushWaiters);
        storePushPending.done(() => this._onPush(changes));
        lastPushWaiters = void 0;
        pushDeferred = void 0;
      }, throttlingTimeout);
      this._onPushHandler = (args) => {
        this._aggregationTimeoutId = throttlingPushHandler(args.changes);
        if (!pushDeferred) {
          pushDeferred = new Deferred();
        }
        lastPushWaiters = args.waitFor;
        args.waitFor.push(pushDeferred.promise());
      };
      this._store.on("beforePushAggregation", this._onPushHandler);
    } else {
      this._onPushHandler = (changes) => this._onPush(changes);
      this._store.on("push", this._onPushHandler);
    }
    this._storeLoadOptions = this._extractLoadOptions(options2);
    this._mapFunc = options2.map;
    this._postProcessFunc = options2.postProcess;
    this._pageIndex = void 0 !== options2.pageIndex ? options2.pageIndex : 0;
    this._pageSize = void 0 !== options2.pageSize ? options2.pageSize : 20;
    this._loadingCount = 0;
    this._loadQueue = this._createLoadQueue();
    this._searchValue = "searchValue" in options2 ? options2.searchValue : null;
    this._searchOperation = options2.searchOperation || "contains";
    this._searchExpr = options2.searchExpr;
    this._paginate = options2.paginate;
    this._reshapeOnPush = options2.reshapeOnPush ?? false;
    each(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], (_, optionName) => {
      if (optionName in options2) {
        this.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options2[optionName]);
      }
    });
    this._operationManager = new OperationManager();
    this._init();
  },
  _init() {
    this._items = [];
    this._userData = {};
    this._totalCount = -1;
    this._isLoaded = false;
    if (!isDefined(this._paginate)) {
      this._paginate = !this.group();
    }
    this._isLastPage = !this._paginate;
  },
  dispose() {
    var _this$_delayedLoadTas;
    this._store.off("beforePushAggregation", this._onPushHandler);
    this._store.off("push", this._onPushHandler);
    this._eventsStrategy.dispose();
    clearTimeout(this._aggregationTimeoutId);
    null === (_this$_delayedLoadTas = this._delayedLoadTask) || void 0 === _this$_delayedLoadTas || _this$_delayedLoadTas.abort();
    this._operationManager.cancelAll();
    delete this._store;
    delete this._items;
    delete this._delayedLoadTask;
    this._disposed = true;
  },
  _extractLoadOptions(options2) {
    const result2 = {};
    let names = ["sort", "filter", "langParams", "select", "group", "requireTotalCount"];
    const customNames = this._store._customLoadOptions();
    if (customNames) {
      names = names.concat(customNames);
    }
    each(names, function() {
      result2[this] = options2[this];
    });
    return result2;
  },
  loadOptions() {
    return this._storeLoadOptions;
  },
  items() {
    return this._items;
  },
  pageIndex(newIndex) {
    if (!isNumeric(newIndex)) {
      return this._pageIndex;
    }
    this._pageIndex = newIndex;
    this._isLastPage = !this._paginate;
  },
  paginate(value2) {
    if (!isBoolean(value2)) {
      return this._paginate;
    }
    if (this._paginate !== value2) {
      this._paginate = value2;
      this.pageIndex(0);
    }
  },
  pageSize(value2) {
    if (!isNumeric(value2)) {
      return this._pageSize;
    }
    this._pageSize = value2;
  },
  isLastPage() {
    return this._isLastPage;
  },
  generateStoreLoadOptionAccessor(optionName) {
    return (args) => {
      const normalizedArgs = normalizeStoreLoadOptionAccessorArguments(args);
      if (void 0 === normalizedArgs) {
        return this._storeLoadOptions[optionName];
      }
      this._storeLoadOptions[optionName] = normalizedArgs;
    };
  },
  sort() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.generateStoreLoadOptionAccessor("sort")(args);
  },
  filter() {
    const newFilter = normalizeStoreLoadOptionAccessorArguments(arguments);
    if (void 0 === newFilter) {
      return this._storeLoadOptions.filter;
    }
    this._storeLoadOptions.filter = newFilter;
    this.pageIndex(0);
  },
  group() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.generateStoreLoadOptionAccessor("group")(args);
  },
  select() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.generateStoreLoadOptionAccessor("select")(args);
  },
  requireTotalCount(value2) {
    if (!isBoolean(value2)) {
      return this._storeLoadOptions.requireTotalCount;
    }
    this._storeLoadOptions.requireTotalCount = value2;
  },
  searchValue(value2) {
    if (arguments.length < 1) {
      return this._searchValue;
    }
    this._searchValue = value2;
    this.pageIndex(0);
  },
  searchOperation(op) {
    if (!isString(op)) {
      return this._searchOperation;
    }
    this._searchOperation = op;
    this.pageIndex(0);
  },
  searchExpr(expr) {
    const argc = arguments.length;
    if (0 === argc) {
      return this._searchExpr;
    }
    if (argc > 1) {
      expr = [].slice.call(arguments);
    }
    this._searchExpr = expr;
    this.pageIndex(0);
  },
  store() {
    return this._store;
  },
  key() {
    var _this$_store;
    return null === (_this$_store = this._store) || void 0 === _this$_store ? void 0 : _this$_store.key();
  },
  totalCount() {
    return this._totalCount;
  },
  isLoaded() {
    return this._isLoaded;
  },
  isLoading() {
    return this._loadingCount > 0;
  },
  beginLoading() {
    this._changeLoadingCount(1);
  },
  endLoading() {
    this._changeLoadingCount(-1);
  },
  _createLoadQueue: () => createQueue2(),
  _changeLoadingCount(increment) {
    const oldLoading = this.isLoading();
    this._loadingCount += increment;
    const newLoading = this.isLoading();
    if (oldLoading ^ newLoading) {
      this._eventsStrategy.fireEvent("loadingChanged", [newLoading]);
    }
  },
  _scheduleLoadCallbacks(deferred) {
    this.beginLoading();
    deferred.always(() => {
      this.endLoading();
    });
  },
  _scheduleFailCallbacks(deferred) {
    var _this = this;
    deferred.fail(function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      if (args[0] === CANCELED_TOKEN) {
        return;
      }
      _this._eventsStrategy.fireEvent("loadError", args);
    });
  },
  _fireChanged(args) {
    const date = /* @__PURE__ */ new Date();
    this._eventsStrategy.fireEvent("changed", args);
    this._changedTime = /* @__PURE__ */ new Date() - date;
  },
  _scheduleChangedCallbacks(deferred) {
    deferred.done(() => this._fireChanged());
  },
  loadSingle(propName, propValue) {
    const d = new Deferred();
    const key = this.key();
    const store = this._store;
    const options2 = this._createStoreLoadOptions();
    this._scheduleFailCallbacks(d);
    if (arguments.length < 2) {
      propValue = propName;
      propName = key;
    }
    delete options2.skip;
    delete options2.group;
    delete options2.refresh;
    delete options2.pageIndex;
    delete options2.searchString;
    (() => {
      if (propName === key || store instanceof custom_store_default && !store._byKeyViaLoad()) {
        return store.byKey(propValue, options2);
      }
      options2.take = 1;
      options2.filter = options2.filter ? [options2.filter, [propName, propValue]] : [propName, propValue];
      return store.load(options2);
    })().fail(d.reject).done((data2) => {
      const isEmptyArray = Array.isArray(data2) && !data2.length;
      if (!isDefined(data2) || isEmptyArray) {
        d.reject(new errors.Error("E4009"));
      } else {
        if (!Array.isArray(data2)) {
          data2 = [data2];
        }
        d.resolve(this._applyMapFunction(data2)[0]);
      }
    });
    return d.promise();
  },
  load() {
    const d = new Deferred();
    const loadTask = () => {
      if (this._disposed) {
        return;
      }
      if (!isPending(d)) {
        return;
      }
      return this._loadFromStore(loadOperation, d);
    };
    this._scheduleLoadCallbacks(d);
    this._scheduleFailCallbacks(d);
    this._scheduleChangedCallbacks(d);
    const loadOperation = this._createLoadOperation(d);
    this._eventsStrategy.fireEvent("customizeStoreLoadOptions", [loadOperation]);
    this._loadQueue.add(() => {
      if ("number" === typeof loadOperation.delay) {
        this._delayedLoadTask = executeAsync(loadTask, loadOperation.delay);
      } else {
        loadTask();
      }
      return d.promise();
    });
    return d.promise({
      operationId: loadOperation.operationId
    });
  },
  _onPush(changes) {
    if (this._reshapeOnPush) {
      this.load();
    } else {
      const changingArgs = {
        changes
      };
      this._eventsStrategy.fireEvent("changing", [changingArgs]);
      const group = this.group();
      const items = this.items();
      let groupLevel = 0;
      let dataSourceChanges = this.paginate() || group ? changes.filter((item) => "update" === item.type) : changes;
      if (group) {
        groupLevel = Array.isArray(group) ? group.length : 1;
      }
      if (this._mapFunc) {
        dataSourceChanges.forEach((item) => {
          if ("insert" === item.type) {
            item.data = this._mapFunc(item.data);
          }
        });
      }
      if (changingArgs.postProcessChanges) {
        dataSourceChanges = changingArgs.postProcessChanges(dataSourceChanges);
      }
      applyBatch({
        keyInfo: this.store(),
        data: items,
        changes: dataSourceChanges,
        groupCount: groupLevel,
        useInsertIndex: true
      });
      this._fireChanged([{
        changes
      }]);
    }
  },
  _createLoadOperation(deferred) {
    const operationId = this._operationManager.add(deferred);
    const storeLoadOptions = this._createStoreLoadOptions();
    if (this._store && !isEmptyObject(null === storeLoadOptions || void 0 === storeLoadOptions ? void 0 : storeLoadOptions.langParams)) {
      this._store._langParams = _extends({}, this._store._langParams, storeLoadOptions.langParams);
    }
    deferred.always(() => this._operationManager.remove(operationId));
    return {
      operationId,
      storeLoadOptions
    };
  },
  reload() {
    const store = this.store();
    store._clearCache();
    this._init();
    return this.load();
  },
  cancel(operationId) {
    return this._operationManager.cancel(operationId);
  },
  cancelAll() {
    return this._operationManager.cancelAll();
  },
  _addSearchOptions(storeLoadOptions) {
    if (this._disposed) {
      return;
    }
    if (this.store()._useDefaultSearch) {
      this._addSearchFilter(storeLoadOptions);
    } else {
      storeLoadOptions.searchOperation = this._searchOperation;
      storeLoadOptions.searchValue = this._searchValue;
      storeLoadOptions.searchExpr = this._searchExpr;
    }
  },
  _createStoreLoadOptions() {
    const result2 = extend({}, this._storeLoadOptions);
    this._addSearchOptions(result2);
    if (this._paginate) {
      if (this._pageSize) {
        result2.skip = this._pageIndex * this._pageSize;
        result2.take = this._pageSize;
      }
    }
    result2.userData = this._userData;
    return result2;
  },
  _addSearchFilter(storeLoadOptions) {
    const value2 = this._searchValue;
    const op = this._searchOperation;
    let selector = this._searchExpr;
    const searchFilter = [];
    if (!value2) {
      return;
    }
    if (!selector) {
      selector = "this";
    }
    if (!Array.isArray(selector)) {
      selector = [selector];
    }
    each(selector, function(i, item) {
      if (searchFilter.length) {
        searchFilter.push("or");
      }
      searchFilter.push([item, op, value2]);
    });
    if (storeLoadOptions.filter) {
      storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter];
    } else {
      storeLoadOptions.filter = searchFilter;
    }
  },
  _loadFromStore(loadOptions, pendingDeferred) {
    const handleSuccess = (data2, extra) => {
      if (this._disposed) {
        return;
      }
      if (!isPending(pendingDeferred)) {
        return;
      }
      const loadResult = extend(normalizeLoadResult(data2, extra), loadOptions);
      this._eventsStrategy.fireEvent("customizeLoadResult", [loadResult]);
      when(loadResult.data).done((data3) => {
        loadResult.data = data3;
        this._processStoreLoadResult(loadResult, pendingDeferred);
      }).fail(pendingDeferred.reject);
    };
    if (loadOptions.data) {
      return new Deferred().resolve(loadOptions.data).done(handleSuccess);
    }
    return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject);
  },
  _processStoreLoadResult(loadResult, pendingDeferred) {
    let data2 = loadResult.data;
    let extra = loadResult.extra;
    const storeLoadOptions = loadResult.storeLoadOptions;
    const resolvePendingDeferred = () => {
      this._isLoaded = true;
      this._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
      return pendingDeferred.resolve(data2, extra);
    };
    const proceedLoadingTotalCount = () => {
      this.store().totalCount(storeLoadOptions).done(function(count) {
        extra.totalCount = count;
        resolvePendingDeferred();
      }).fail(pendingDeferred.reject);
    };
    if (this._disposed) {
      return;
    }
    data2 = this._applyPostProcessFunction(this._applyMapFunction(data2));
    if (!isObject(extra)) {
      extra = {};
    }
    this._items = data2;
    if (!data2.length || !this._paginate || this._pageSize && data2.length < this._pageSize) {
      this._isLastPage = true;
    }
    if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
      proceedLoadingTotalCount();
    } else {
      resolvePendingDeferred();
    }
  },
  _applyMapFunction(data2) {
    if (this._mapFunc) {
      return mapDataRespectingGrouping(data2, this._mapFunc, this.group());
    }
    return data2;
  },
  _applyPostProcessFunction(data2) {
    if (this._postProcessFunc) {
      return this._postProcessFunc(data2);
    }
    return data2;
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});

// ../../../../../../node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.js
var SelectionStrategy = class {
  constructor(options2) {
    this.options = options2;
    this._setOption("disabledItemKeys", []);
    this._clearItemKeys();
  }
  _clearItemKeys() {
    this._setOption("addedItemKeys", []);
    this._setOption("removedItemKeys", []);
    this._setOption("removedItems", []);
    this._setOption("addedItems", []);
  }
  validate() {
  }
  _setOption(name2, value2) {
    this.options[name2] = value2;
  }
  onSelectionChanged() {
    const {
      addedItemKeys
    } = this.options;
    const {
      removedItemKeys
    } = this.options;
    const {
      addedItems
    } = this.options;
    const {
      removedItems
    } = this.options;
    const {
      selectedItems
    } = this.options;
    const {
      selectedItemKeys
    } = this.options;
    const onSelectionChanged = this.options.onSelectionChanged || noop2;
    this._clearItemKeys();
    onSelectionChanged({
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems
    });
  }
  equalKeys(key1, key2) {
    if (this.options.equalByReference) {
      if (isObject(key1) && isObject(key2)) {
        return key1 === key2;
      }
    }
    return equalByValue(key1, key2);
  }
  getSelectableItems(items) {
    return items.filter((item) => !(null !== item && void 0 !== item && item.disabled));
  }
  _clearSelection(keys, preserve, isDeselect, isSelectAll) {
    keys = keys || [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll);
  }
  _removeTemplateProperty(remoteFilter) {
    if (Array.isArray(remoteFilter)) {
      return remoteFilter.map((f) => this._removeTemplateProperty(f));
    }
    if (isObject(remoteFilter)) {
      delete remoteFilter.template;
    }
    return remoteFilter;
  }
  _loadFilteredData(remoteFilter, localFilter, select, isSelectAll) {
    const filterLength = encodeURI(JSON.stringify(this._removeTemplateProperty(remoteFilter))).length;
    const needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest;
    const deferred = Deferred();
    const loadOptions = {
      filter: needLoadAllData ? void 0 : remoteFilter,
      select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
    };
    if (remoteFilter && 0 === remoteFilter.length) {
      deferred.resolve([]);
    } else {
      this.options.load(loadOptions).done((items) => {
        let filteredItems = isPlainObject(items) ? items.data : items;
        if (localFilter && !isSelectAll) {
          filteredItems = filteredItems.filter(localFilter);
        } else if (needLoadAllData) {
          filteredItems = query_default(filteredItems).filter(remoteFilter).toArray();
        }
        deferred.resolve(filteredItems);
      }).fail(deferred.reject.bind(deferred));
    }
    return deferred;
  }
  updateSelectedItemKeyHash(keys) {
    for (let i = 0; i < keys.length; i++) {
      const keyHash = getKeyHash(keys[i]);
      if (!isObject(keyHash)) {
        this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
        const keyIndices = this.options.keyHashIndices[keyHash];
        keyIndices.push(i);
      }
    }
  }
  _isAnyItemSelected(items) {
    for (let i = 0; i < items.length; i++) {
      if (this.options.isItemSelected(items[i])) {
        return;
      }
    }
    return false;
  }
  _getFullSelectAllState() {
    const items = this.options.plainItems();
    const dataFilter = this.options.filter();
    let selectedItems = this.options.ignoreDisabledItems ? this.options.selectedItems : this.options.selectedItems.filter((item) => !(null !== item && void 0 !== item && item.disabled));
    if (dataFilter) {
      selectedItems = query_default(selectedItems).filter(dataFilter).toArray();
    }
    const selectedItemsLength = selectedItems.length;
    const disabledItemsLength = items.length - this.getSelectableItems(items).length;
    if (!selectedItemsLength) {
      return this._isAnyItemSelected(items);
    }
    if (selectedItemsLength >= this.options.totalCount() - disabledItemsLength) {
      return true;
    }
    return;
  }
  _getVisibleSelectAllState() {
    const items = this.getSelectableItems(this.options.plainItems());
    let hasSelectedItems = false;
    let hasUnselectedItems = false;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const itemData = this.options.getItemData(item);
      const key = this.options.keyOf(itemData);
      if (this.options.isSelectableItem(item)) {
        if (this.isItemKeySelected(key)) {
          hasSelectedItems = true;
        } else {
          hasUnselectedItems = true;
        }
      }
    }
    if (hasSelectedItems) {
      return !hasUnselectedItems ? true : void 0;
    }
    return false;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.deferred.js
var DeferredStrategy = class extends SelectionStrategy {
  getSelectedItems() {
    return this._loadFilteredData(this.options.selectionFilter);
  }
  getSelectedItemKeys() {
    const d = Deferred();
    const that = this;
    const key = this.options.key();
    const select = isString(key) ? [key] : key;
    this._loadFilteredData(this.options.selectionFilter, null, select).done((items) => {
      const keys = items.map((item) => that.options.keyOf(item));
      d.resolve(keys);
    }).fail(d.reject);
    return d.promise();
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll) {
    if (isSelectAll) {
      const filter = this.options.filter();
      const needResetSelectionFilter = !filter || JSON.stringify(filter) === JSON.stringify(this.options.selectionFilter) && isDeselect;
      if (needResetSelectionFilter) {
        this._setOption("selectionFilter", isDeselect ? [] : null);
      } else {
        this._addSelectionFilter(isDeselect, filter, isSelectAll);
      }
    } else {
      if (!preserve) {
        this._setOption("selectionFilter", []);
      }
      for (let i = 0; i < keys.length; i++) {
        if (isDeselect) {
          this.removeSelectedItem(keys[i]);
        } else {
          this.addSelectedItem(keys[i], isSelectAll, !preserve);
        }
      }
    }
    this.onSelectionChanged();
    return Deferred().resolve();
  }
  setSelectedItems(keys) {
    this._setOption("selectionFilter", null);
    for (let i = 0; i < keys.length; i++) {
      this.addSelectedItem(keys[i]);
    }
  }
  isItemDataSelected(itemData) {
    return this.isItemKeySelected(itemData);
  }
  isItemKeySelected(itemData) {
    const {
      selectionFilter,
      sensitivity
    } = this.options;
    if (!selectionFilter) {
      return true;
    }
    const queryParams = {
      langParams: {
        collatorOptions: {
          sensitivity
        }
      }
    };
    return !!query_default([itemData], queryParams).filter(selectionFilter).toArray().length;
  }
  _getKeyExpr() {
    const keyField = this.options.key();
    if (Array.isArray(keyField) && 1 === keyField.length) {
      return keyField[0];
    }
    return keyField;
  }
  _normalizeKey(key) {
    const keyExpr = this.options.key();
    if (Array.isArray(keyExpr) && 1 === keyExpr.length) {
      return key[keyExpr[0]];
    }
    return key;
  }
  _getFilterByKey(key) {
    const keyField = this._getKeyExpr();
    let filter = [keyField, "=", this._normalizeKey(key)];
    if (Array.isArray(keyField)) {
      filter = [];
      for (let i = 0; i < keyField.length; i++) {
        filter.push([keyField[i], "=", key[keyField[i]]]);
        if (i !== keyField.length - 1) {
          filter.push("and");
        }
      }
    }
    return filter;
  }
  addSelectedItem(key, isSelectAll, skipFilter) {
    const filter = this._getFilterByKey(key);
    this._addSelectionFilter(false, filter, isSelectAll, skipFilter);
  }
  removeSelectedItem(key) {
    const filter = this._getFilterByKey(key);
    this._addSelectionFilter(true, filter);
  }
  validate() {
    const {
      key
    } = this.options;
    if (key && void 0 === key()) {
      throw ui_errors_default.Error("E1042", "Deferred selection");
    }
  }
  _findSubFilter(selectionFilter, filter) {
    if (!selectionFilter) {
      return -1;
    }
    const filterString = JSON.stringify(filter);
    for (let index2 = 0; index2 < selectionFilter.length; index2++) {
      const subFilter = selectionFilter[index2];
      if (subFilter && JSON.stringify(subFilter) === filterString) {
        return index2;
      }
    }
    return -1;
  }
  _isLastSubFilter(selectionFilter, filter) {
    if (selectionFilter && filter) {
      return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || 0 === this._findSubFilter([selectionFilter], filter);
    }
    return false;
  }
  _addFilterOperator(selectionFilter, filterOperator) {
    if (selectionFilter.length > 1 && isString(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
      selectionFilter = [selectionFilter];
    }
    if (selectionFilter.length) {
      selectionFilter.push(filterOperator);
    }
    return selectionFilter;
  }
  _denormalizeFilter(filter) {
    if (filter && isString(filter[0])) {
      filter = [filter];
    }
    return filter;
  }
  _isOnlyNegativeFiltersLeft(filters) {
    return filters.every((filterItem, i) => {
      if (i % 2 === 0) {
        return Array.isArray(filterItem) && "!" === filterItem[0];
      }
      return "and" === filterItem;
    });
  }
  _addSelectionFilter(isDeselect, filter, isSelectAll, skipFilter) {
    var _selectionFilter;
    const that = this;
    const currentFilter = isDeselect ? ["!", filter] : filter;
    const currentOperation = isDeselect ? "and" : "or";
    let needAddFilter = true;
    let selectionFilter = that.options.selectionFilter || [];
    selectionFilter = that._denormalizeFilter(selectionFilter);
    if (null !== (_selectionFilter = selectionFilter) && void 0 !== _selectionFilter && _selectionFilter.length && !skipFilter) {
      const removedIndex = that._removeSameFilter(selectionFilter, filter, isDeselect, isSelectAll);
      const filterIndex = that._removeSameFilter(selectionFilter, filter, !isDeselect);
      const shouldCleanFilter = isDeselect && (-1 !== removedIndex || -1 !== filterIndex) && this._isOnlyNegativeFiltersLeft(selectionFilter);
      if (shouldCleanFilter) {
        selectionFilter = [];
      }
      const isKeyOperatorsAfterRemoved = this._isKeyFilter(filter) && this._hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex);
      needAddFilter = filter.length && !isKeyOperatorsAfterRemoved;
    }
    if (needAddFilter) {
      selectionFilter = that._addFilterOperator(selectionFilter, currentOperation);
      selectionFilter.push(currentFilter);
    }
    selectionFilter = that._normalizeFilter(selectionFilter);
    that._setOption("selectionFilter", !isDeselect && !selectionFilter.length ? null : selectionFilter);
  }
  _normalizeFilter(filter) {
    if (filter && 1 === filter.length) {
      filter = filter[0];
    }
    return filter;
  }
  _removeFilterByIndex(filter, filterIndex, isSelectAll) {
    const operation = filter[1];
    if (filterIndex > 0) {
      filter.splice(filterIndex - 1, 2);
    } else {
      filter.splice(filterIndex, 2);
    }
    if (isSelectAll && "and" === operation) {
      filter.splice(0, filter.length);
    }
  }
  _isSimpleKeyFilter(filter, key) {
    return 3 === filter.length && filter[0] === key && "=" === filter[1];
  }
  _isKeyFilter(filter) {
    if (2 === filter.length && "!" === filter[0]) {
      return this._isKeyFilter(filter[1]);
    }
    const keyField = this._getKeyExpr();
    if (Array.isArray(keyField)) {
      if (filter.length !== 2 * keyField.length - 1) {
        return false;
      }
      for (let i = 0; i < keyField.length; i++) {
        if (i > 0 && "and" !== filter[2 * i - 1]) {
          return false;
        }
        if (!this._isSimpleKeyFilter(filter[2 * i], keyField[i])) {
          return false;
        }
      }
      return true;
    }
    return this._isSimpleKeyFilter(filter, keyField);
  }
  _hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex) {
    if (filterIndex >= 0) {
      for (let i = filterIndex; i < selectionFilter.length; i++) {
        if ("string" !== typeof selectionFilter[i] && !this._isKeyFilter(selectionFilter[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  _removeSameFilter(selectionFilter, filter, inverted, isSelectAll) {
    filter = inverted ? ["!", filter] : filter;
    if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
      selectionFilter.splice(0, selectionFilter.length);
      return 0;
    }
    const filterIndex = this._findSubFilter(selectionFilter, filter);
    if (filterIndex >= 0) {
      this._removeFilterByIndex(selectionFilter, filterIndex, isSelectAll);
      return filterIndex;
    }
    for (let i = 0; i < selectionFilter.length; i++) {
      if (Array.isArray(selectionFilter[i]) && selectionFilter[i].length > 2) {
        const filterIndex2 = this._removeSameFilter(selectionFilter[i], filter, false, isSelectAll);
        if (filterIndex2 >= 0) {
          if (!selectionFilter[i].length) {
            this._removeFilterByIndex(selectionFilter, i, isSelectAll);
          } else if (1 === selectionFilter[i].length) {
            selectionFilter[i] = selectionFilter[i][0];
          }
          return filterIndex2;
        }
      }
    }
    return -1;
  }
  getSelectAllState() {
    const filter = this.options.filter();
    let {
      selectionFilter
    } = this.options;
    if (!selectionFilter) {
      return true;
    }
    if (!selectionFilter.length) {
      return false;
    }
    if (!filter || !filter.length) {
      return;
    }
    selectionFilter = this._denormalizeFilter(selectionFilter);
    if (this._isLastSubFilter(selectionFilter, filter)) {
      return true;
    }
    if (this._isLastSubFilter(selectionFilter, ["!", filter])) {
      return false;
    }
    return;
  }
  loadSelectedItemsWithFilter() {
    const componentFilter = this.options.filter();
    const {
      selectionFilter
    } = this.options;
    const filter = componentFilter ? [componentFilter, "and", selectionFilter] : selectionFilter;
    return this._loadFilteredData(filter);
  }
};

// ../../../../../../node_modules/devextreme/esm/core/utils/array_compare.js
var getKeyWrapper = function(item, getKey) {
  const key = getKey(item);
  if (isObject(key)) {
    try {
      return JSON.stringify(key);
    } catch (e) {
      return key;
    }
  }
  return key;
};
var getSameNewByOld = function(oldItem, newItems, newIndexByKey, getKey) {
  const key = getKeyWrapper(oldItem, getKey);
  return newItems[newIndexByKey[key]];
};
var isKeysEqual = function(oldKeys, newKeys) {
  if (oldKeys.length !== newKeys.length) {
    return false;
  }
  for (let i = 0; i < newKeys.length; i++) {
    if (oldKeys[i] !== newKeys[i]) {
      return false;
    }
  }
  return true;
};
var findChanges = function(oldItems, newItems, getKey, isItemEquals) {
  const oldIndexByKey = {};
  const newIndexByKey = {};
  let addedCount = 0;
  let removeCount = 0;
  const result2 = [];
  oldItems.forEach(function(item, index2) {
    const key = getKeyWrapper(item, getKey);
    oldIndexByKey[key] = index2;
  });
  newItems.forEach(function(item, index2) {
    const key = getKeyWrapper(item, getKey);
    newIndexByKey[key] = index2;
  });
  const itemCount = Math.max(oldItems.length, newItems.length);
  for (let index2 = 0; index2 < itemCount + addedCount; index2++) {
    const newItem = newItems[index2];
    const oldNextIndex = index2 - addedCount + removeCount;
    const nextOldItem = oldItems[oldNextIndex];
    const isRemoved = !newItem || nextOldItem && !getSameNewByOld(nextOldItem, newItems, newIndexByKey, getKey);
    if (isRemoved) {
      if (nextOldItem) {
        result2.push({
          type: "remove",
          key: getKey(nextOldItem),
          index: index2,
          oldItem: nextOldItem
        });
        removeCount++;
        index2--;
      }
    } else {
      const key = getKeyWrapper(newItem, getKey);
      const oldIndex = oldIndexByKey[key];
      const oldItem = oldItems[oldIndex];
      if (!oldItem) {
        addedCount++;
        result2.push({
          type: "insert",
          data: newItem,
          index: index2
        });
      } else if (oldIndex === oldNextIndex) {
        if (!isItemEquals(oldItem, newItem)) {
          result2.push({
            type: "update",
            data: newItem,
            key: getKey(newItem),
            index: index2,
            oldItem
          });
        }
      } else {
        return;
      }
    }
  }
  return result2;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/selection_filter.js
var SelectionFilterCreator = function(selectedItemKeys, isSelectAll) {
  this.getLocalFilter = function(keyGetter, equalKeys, equalByReference, keyExpr) {
    equalKeys = void 0 === equalKeys ? equalByValue : equalKeys;
    return functionFilter.bind(this, equalKeys, keyGetter, equalByReference, keyExpr);
  };
  this.getExpr = function(keyExpr) {
    if (!keyExpr) {
      return;
    }
    let filterExpr;
    selectedItemKeys.forEach(function(key, index2) {
      filterExpr = filterExpr || [];
      let filterExprPart;
      if (index2 > 0) {
        filterExpr.push(isSelectAll ? "and" : "or");
      }
      if (isString(keyExpr)) {
        filterExprPart = getFilterForPlainKey(keyExpr, key);
      } else {
        filterExprPart = function(keyExpr2, itemKeyValue) {
          const filterExpr2 = [];
          for (let i = 0, length = keyExpr2.length; i < length; i++) {
            const currentKeyExpr = keyExpr2[i];
            const keyValueGetter = compileGetter(currentKeyExpr);
            const currentKeyValue = itemKeyValue && keyValueGetter(itemKeyValue);
            const filterExprPart2 = getFilterForPlainKey(currentKeyExpr, currentKeyValue);
            if (!filterExprPart2) {
              break;
            }
            if (i > 0) {
              filterExpr2.push(isSelectAll ? "or" : "and");
            }
            filterExpr2.push(filterExprPart2);
          }
          return filterExpr2;
        }(keyExpr, key);
      }
      filterExpr.push(filterExprPart);
    });
    if (filterExpr && 1 === filterExpr.length) {
      filterExpr = filterExpr[0];
    }
    return filterExpr;
  };
  this.getCombinedFilter = function(keyExpr, dataSourceFilter) {
    let forceCombinedFilter = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    const filterExpr = this.getExpr(keyExpr);
    let combinedFilter = filterExpr;
    if ((forceCombinedFilter || isSelectAll) && dataSourceFilter) {
      if (filterExpr) {
        combinedFilter = [];
        combinedFilter.push(filterExpr);
        combinedFilter.push(dataSourceFilter);
      } else {
        combinedFilter = dataSourceFilter;
      }
    }
    return combinedFilter;
  };
  let selectedItemKeyHashesMap;
  const getSelectedItemKeyHashesMap = function(keyOf, keyExpr) {
    if (!selectedItemKeyHashesMap) {
      selectedItemKeyHashesMap = {};
      const normalizedKeys = normalizeKeys(selectedItemKeys, keyOf, keyExpr);
      for (let i = 0; i < normalizedKeys.length; i++) {
        selectedItemKeyHashesMap[getKeyHash(normalizedKeys[i])] = true;
      }
    }
    return selectedItemKeyHashesMap;
  };
  const normalizeKeys = function(keys, keyOf, keyExpr) {
    return Array.isArray(keyExpr) ? keys.map((key) => keyOf(key)) : keys;
  };
  function functionFilter(equalKeys, keyOf, equalByReference, keyExpr, item) {
    const key = keyOf(item);
    let keyHash;
    let i;
    if (!equalByReference) {
      keyHash = getKeyHash(key);
      if (!isObject(keyHash)) {
        const selectedKeyHashesMap = getSelectedItemKeyHashesMap(keyOf, keyExpr);
        if (selectedKeyHashesMap[keyHash]) {
          return !isSelectAll;
        }
        return !!isSelectAll;
      }
    }
    for (i = 0; i < selectedItemKeys.length; i++) {
      if (equalKeys(selectedItemKeys[i], key)) {
        return !isSelectAll;
      }
    }
    return !!isSelectAll;
  }
  function getFilterForPlainKey(keyExpr, keyValue) {
    if (void 0 === keyValue) {
      return;
    }
    return [keyExpr, isSelectAll ? "<>" : "=", keyValue];
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.standard.js
var StandardStrategy = class extends SelectionStrategy {
  constructor(options2) {
    super(options2);
    this._initSelectedItemKeyHash();
  }
  _initSelectedItemKeyHash() {
    this._setOption("keyHashIndices", this.options.equalByReference ? null : {});
  }
  getSelectedItemKeys() {
    return this.options.selectedItemKeys.slice(0);
  }
  getSelectedItems() {
    return this.options.selectedItems.slice(0);
  }
  _preserveSelectionUpdate(items, isDeselect) {
    const {
      keyOf
    } = this.options;
    let keyIndicesToRemoveMap;
    let keyIndex;
    let i;
    if (!keyOf) {
      return;
    }
    const isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;
    if (isBatchDeselect) {
      keyIndicesToRemoveMap = {};
    }
    for (i = 0; i < items.length; i++) {
      const item = items[i];
      const key = keyOf(item);
      if (isDeselect) {
        keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap, null === item || void 0 === item ? void 0 : item.disabled);
        if (keyIndicesToRemoveMap && keyIndex >= 0) {
          keyIndicesToRemoveMap[keyIndex] = true;
        }
      } else {
        this.addSelectedItem(key, item);
      }
    }
    if (isBatchDeselect) {
      this._batchRemoveSelectedItems(keyIndicesToRemoveMap);
    }
  }
  _batchRemoveSelectedItems(keyIndicesToRemoveMap) {
    const selectedItemKeys = this.options.selectedItemKeys.slice(0);
    const selectedItems = this.options.selectedItems.slice(0);
    this.options.selectedItemKeys.length = 0;
    this.options.selectedItems.length = 0;
    for (let i = 0; i < selectedItemKeys.length; i++) {
      if (!keyIndicesToRemoveMap[i]) {
        this.options.selectedItemKeys.push(selectedItemKeys[i]);
        this.options.selectedItems.push(selectedItems[i]);
      }
    }
    this._initSelectedItemKeyHash();
    this.updateSelectedItemKeyHash(this.options.selectedItemKeys);
  }
  _loadSelectedItemsCore(keys, isDeselect, isSelectAll, filter) {
    let forceCombinedFilter = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    let deferred = Deferred();
    const key = this.options.key();
    if (!keys.length && !isSelectAll) {
      deferred.resolve([]);
      return deferred;
    }
    if (isSelectAll && isDeselect && !filter) {
      deferred.resolve(this.getSelectedItems());
      return deferred;
    }
    const selectionFilterCreator = new SelectionFilterCreator(keys, isSelectAll);
    const combinedFilter = selectionFilterCreator.getCombinedFilter(key, filter, forceCombinedFilter);
    let deselectedItems = [];
    if (isDeselect) {
      const {
        selectedItems
      } = this.options;
      deselectedItems = combinedFilter && keys.length !== selectedItems.length ? query_default(selectedItems).filter(combinedFilter).toArray() : selectedItems.slice(0);
    }
    let filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems(true).filter(this.options.isSelectableItem).map(this.options.getItemData);
    const localFilter = selectionFilterCreator.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, key);
    filteredItems = filteredItems.filter(localFilter);
    if (deselectedItems.length || !isSelectAll && filteredItems.length === keys.length) {
      deferred.resolve(filteredItems);
    } else {
      deferred = this._loadFilteredData(combinedFilter, localFilter, null, isSelectAll);
    }
    return deferred;
  }
  _replaceSelectionUpdate(items) {
    const internalKeys = [];
    const {
      keyOf
    } = this.options;
    if (!keyOf) {
      return;
    }
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const key = keyOf(item);
      internalKeys.push(key);
    }
    this.setSelectedItems(internalKeys, items);
  }
  _warnOnIncorrectKeys(keys) {
    const {
      allowNullValue
    } = this.options;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if ((!allowNullValue || null !== key) && !this.isItemKeySelected(key)) {
        ui_errors_default.log("W1002", key);
      }
    }
  }
  _isMultiSelectEnabled() {
    const {
      mode
    } = this.options;
    return "all" === mode || "multiple" === mode;
  }
  _requestInProgress() {
    var _this$_lastLoadDeferr;
    return "pending" === (null === (_this$_lastLoadDeferr = this._lastLoadDeferred) || void 0 === _this$_lastLoadDeferr ? void 0 : _this$_lastLoadDeferr.state());
  }
  _concatRequestsItems(keys, isDeselect, oldRequestItems, updatedKeys) {
    let selectedItems;
    const deselectedItems = isDeselect ? keys : [];
    if (updatedKeys) {
      selectedItems = updatedKeys;
    } else {
      selectedItems = removeDuplicates(keys, this.options.selectedItemKeys);
    }
    return {
      addedItems: oldRequestItems.added.concat(selectedItems),
      removedItems: oldRequestItems.removed.concat(deselectedItems),
      keys
    };
  }
  _collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys) {
    const isDeselectAll = isDeselect && isSelectAll;
    const oldRequestItems = {
      added: [],
      removed: []
    };
    const multiSelectEnabled = this._isMultiSelectEnabled();
    let lastRequestData = multiSelectEnabled ? this._lastRequestData : {};
    if (multiSelectEnabled) {
      if (this._shouldMergeWithLastRequest) {
        if (isDeselectAll) {
          this._lastLoadDeferred.reject();
          lastRequestData = {};
        } else if (!isKeysEqual(keys, this.options.selectedItemKeys)) {
          oldRequestItems.added = lastRequestData.addedItems;
          oldRequestItems.removed = lastRequestData.removedItems;
          if (!isDeselect) {
            this._lastLoadDeferred.reject();
          }
        }
      }
      lastRequestData = this._concatRequestsItems(keys, isDeselect, oldRequestItems, this._shouldMergeWithLastRequest ? void 0 : updatedKeys);
    }
    return lastRequestData;
  }
  _updateKeysByLastRequestData(keys, isDeselect, isSelectAll) {
    let currentKeys = keys;
    if (this._isMultiSelectEnabled() && this._shouldMergeWithLastRequest && !isDeselect && !isSelectAll) {
      var _this$_lastRequestDat, _this$_lastRequestDat2;
      currentKeys = removeDuplicates(keys.concat(null === (_this$_lastRequestDat = this._lastRequestData) || void 0 === _this$_lastRequestDat ? void 0 : _this$_lastRequestDat.addedItems), null === (_this$_lastRequestDat2 = this._lastRequestData) || void 0 === _this$_lastRequestDat2 ? void 0 : _this$_lastRequestDat2.removedItems);
      currentKeys = getUniqueValues(currentKeys);
    }
    return currentKeys;
  }
  _loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys) {
    let forceCombinedFilter = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    const that = this;
    const deferred = Deferred();
    const filter = that.options.filter();
    this._shouldMergeWithLastRequest = this._requestInProgress();
    this._lastRequestData = this._collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys);
    when(that._lastLoadDeferred).always(() => {
      const currentKeys = that._updateKeysByLastRequestData(keys, isDeselect, isSelectAll);
      that._shouldMergeWithLastRequest = false;
      that._loadSelectedItemsCore(currentKeys, isDeselect, isSelectAll, filter, forceCombinedFilter).done(deferred.resolve).fail(deferred.reject);
    });
    that._lastLoadDeferred = deferred;
    return deferred;
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    let forceCombinedFilter = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : false;
    const that = this;
    const deferred = that._loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys, forceCombinedFilter);
    deferred.done((items) => {
      if (preserve) {
        that._preserveSelectionUpdate(items, isDeselect);
      } else {
        that._replaceSelectionUpdate(items);
      }
      that.onSelectionChanged();
    });
    return deferred;
  }
  addSelectedItem(key, itemData) {
    if (isDefined(itemData) && !this.options.ignoreDisabledItems && itemData.disabled) {
      if (-1 === this.options.disabledItemKeys.indexOf(key)) {
        this.options.disabledItemKeys.push(key);
      }
      return;
    }
    const keyHash = this._getKeyHash(key);
    if (-1 === this._indexOfSelectedItemKey(keyHash)) {
      if (!isObject(keyHash) && this.options.keyHashIndices) {
        this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length];
      }
      this.options.selectedItemKeys.push(key);
      this.options.addedItemKeys.push(key);
      this.options.addedItems.push(itemData);
      this.options.selectedItems.push(itemData);
    }
  }
  _getSelectedIndexByKey(key, ignoreIndicesMap) {
    const {
      selectedItemKeys
    } = this.options;
    for (let index2 = 0; index2 < selectedItemKeys.length; index2++) {
      if ((!ignoreIndicesMap || !ignoreIndicesMap[index2]) && this.equalKeys(selectedItemKeys[index2], key)) {
        return index2;
      }
    }
    return -1;
  }
  _getSelectedIndexByHash(key, ignoreIndicesMap) {
    let indices = this.options.keyHashIndices[key];
    if (indices && indices.length > 1 && ignoreIndicesMap) {
      indices = indices.filter((index2) => !ignoreIndicesMap[index2]);
    }
    return indices && indices[0] >= 0 ? indices[0] : -1;
  }
  _indexOfSelectedItemKey(key, ignoreIndicesMap) {
    let selectedIndex;
    if (this.options.equalByReference) {
      selectedIndex = this.options.selectedItemKeys.indexOf(key);
    } else if (isObject(key)) {
      selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap);
    } else {
      selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap);
    }
    return selectedIndex;
  }
  _shiftSelectedKeyIndices(keyIndex) {
    for (let currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
      const currentKey = this.options.selectedItemKeys[currentKeyIndex];
      const currentKeyHash = getKeyHash(currentKey);
      const currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
      if (!currentKeyIndices) {
        continue;
      }
      for (let i = 0; i < currentKeyIndices.length; i++) {
        if (currentKeyIndices[i] > keyIndex) {
          currentKeyIndices[i]--;
        }
      }
    }
  }
  removeSelectedItem(key, keyIndicesToRemoveMap, isDisabled) {
    if (!this.options.ignoreDisabledItems && isDisabled) {
      return;
    }
    const keyHash = this._getKeyHash(key);
    const isBatchDeselect = !!keyIndicesToRemoveMap;
    const keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);
    if (keyIndex < 0) {
      return keyIndex;
    }
    this.options.removedItemKeys.push(key);
    this.options.removedItems.push(this.options.selectedItems[keyIndex]);
    if (isBatchDeselect) {
      return keyIndex;
    }
    this.options.selectedItemKeys.splice(keyIndex, 1);
    this.options.selectedItems.splice(keyIndex, 1);
    if (isObject(keyHash) || !this.options.keyHashIndices) {
      return keyIndex;
    }
    const keyIndices = this.options.keyHashIndices[keyHash];
    if (!keyIndices) {
      return keyIndex;
    }
    keyIndices.shift();
    if (!keyIndices.length) {
      delete this.options.keyHashIndices[keyHash];
    }
    this._shiftSelectedKeyIndices(keyIndex);
    return keyIndex;
  }
  _updateAddedItemKeys(keys, items) {
    for (let i = 0; i < keys.length; i++) {
      if (!this.isItemKeySelected(keys[i])) {
        this.options.addedItemKeys.push(keys[i]);
        this.options.addedItems.push(items[i]);
      }
    }
  }
  _updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems) {
    for (let i = 0; i < oldSelectedKeys.length; i++) {
      if (!this.isItemKeySelected(oldSelectedKeys[i])) {
        this.options.removedItemKeys.push(oldSelectedKeys[i]);
        this.options.removedItems.push(oldSelectedItems[i]);
      }
    }
  }
  _isItemSelectionInProgress(key, checkPending) {
    const shouldCheckPending = checkPending && this._lastRequestData && this._requestInProgress();
    if (shouldCheckPending) {
      const addedItems = this._lastRequestData.addedItems ?? [];
      return addedItems.includes(key);
    }
    return false;
  }
  _getKeyHash(key) {
    return this.options.equalByReference ? key : getKeyHash(key);
  }
  setSelectedItems(keys, items) {
    this._updateAddedItemKeys(keys, items);
    const oldSelectedKeys = this.options.selectedItemKeys;
    const oldSelectedItems = this.options.selectedItems;
    if (!this.options.equalByReference) {
      this._initSelectedItemKeyHash();
      this.updateSelectedItemKeyHash(keys);
    }
    this._setOption("selectedItemKeys", keys);
    this._setOption("selectedItems", items);
    this._updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems);
  }
  isItemDataSelected(itemData) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const key = this.options.keyOf(itemData);
    return this.isItemKeySelected(key, options2);
  }
  isItemKeySelected(key) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    let result2 = this._isItemSelectionInProgress(key, options2.checkPending);
    if (!result2) {
      const keyHash = this._getKeyHash(key);
      const index2 = this._indexOfSelectedItemKey(keyHash);
      result2 = -1 !== index2;
    }
    return result2;
  }
  getSelectAllState(visibleOnly) {
    if (visibleOnly) {
      return this._getVisibleSelectAllState();
    }
    return this._getFullSelectAllState();
  }
  loadSelectedItemsWithFilter() {
    const keyExpr = this.options.key();
    const keys = this.getSelectedItemKeys();
    const filter = this.options.filter();
    if (!keys.length) {
      return Deferred().resolve([]);
    }
    const selectionFilterCreator = new SelectionFilterCreator(keys);
    const combinedFilter = selectionFilterCreator.getCombinedFilter(keyExpr, filter, true);
    return this._loadFilteredData(combinedFilter);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/selection/m_selection.js
var Selection = class {
  constructor(options2) {
    this.options = extend(this._getDefaultOptions(), options2, {
      selectedItemKeys: options2.selectedKeys || []
    });
    this._selectionStrategy = this.options.deferred ? new DeferredStrategy(this.options) : new StandardStrategy(this.options);
    this._focusedItemIndex = -1;
    if (!this.options.equalByReference) {
      this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys);
    }
  }
  _getDefaultOptions() {
    return {
      allowNullValue: false,
      deferred: false,
      equalByReference: false,
      mode: "multiple",
      selectedItems: [],
      selectionFilter: [],
      maxFilterLengthInRequest: 0,
      onSelectionChanged: noop2,
      key: noop2,
      keyOf: (item) => item,
      load: () => Deferred().resolve([]),
      totalCount: () => -1,
      isSelectableItem: () => true,
      isItemSelected: () => false,
      getItemData: (item) => item,
      dataFields: noop2,
      filter: noop2
    };
  }
  validate() {
    this._selectionStrategy.validate();
  }
  getSelectedItemKeys() {
    return this._selectionStrategy.getSelectedItemKeys();
  }
  getSelectedItems() {
    return this._selectionStrategy.getSelectedItems();
  }
  selectionFilter(value2) {
    if (void 0 === value2) {
      return this.options.selectionFilter;
    }
    const filterIsChanged = this.options.selectionFilter !== value2 && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value2);
    this.options.selectionFilter = value2;
    filterIsChanged && this.onSelectionChanged();
  }
  setSelection(keys, updatedKeys) {
    return this.selectedItemKeys(keys, false, false, false, updatedKeys);
  }
  select(keys) {
    return this.selectedItemKeys(keys, true);
  }
  deselect(keys) {
    return this.selectedItemKeys(keys, true, true);
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    keys = keys ?? [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys);
  }
  clearSelection() {
    return this.selectedItemKeys([]);
  }
  _addSelectedItem(itemData, key) {
    this._selectionStrategy.addSelectedItem(key, itemData);
  }
  _removeSelectedItem(key) {
    this._selectionStrategy.removeSelectedItem(key);
  }
  _setSelectedItems(keys, items) {
    this._selectionStrategy.setSelectedItems(keys, items);
  }
  onSelectionChanged() {
    this._selectionStrategy.onSelectionChanged();
  }
  changeItemSelection(itemIndex, keys, setFocusOnly) {
    var _this$options$allowLo, _this$options;
    let isSelectedItemsChanged;
    const items = this.options.plainItems();
    const item = items[itemIndex];
    let deferred;
    const {
      isVirtualPaging
    } = this.options;
    const allowLoadByRange = null === (_this$options$allowLo = (_this$options = this.options).allowLoadByRange) || void 0 === _this$options$allowLo ? void 0 : _this$options$allowLo.call(_this$options);
    const {
      alwaysSelectByShift
    } = this.options;
    let indexOffset;
    let focusedItemNotInLoadedRange = false;
    let shiftFocusedItemNotInLoadedRange = false;
    const itemIsNotInLoadedRange = (index2) => index2 >= 0 && !items.filter((it) => it.loadIndex === index2).length;
    if (isVirtualPaging && isDefined(item)) {
      if (allowLoadByRange) {
        indexOffset = item.loadIndex - itemIndex;
        itemIndex = item.loadIndex;
      }
      focusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._focusedItemIndex);
      if (isDefined(this._shiftFocusedItemIndex)) {
        shiftFocusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._shiftFocusedItemIndex);
      }
    }
    if (!this.isSelectable() || !this.isDataItem(item)) {
      return false;
    }
    const itemData = this.options.getItemData(item);
    const itemKey = this.options.keyOf(itemData);
    keys = keys || {};
    let allowSelectByShift = keys.shift;
    if (false === alwaysSelectByShift && allowSelectByShift) {
      allowSelectByShift = false !== allowLoadByRange || !focusedItemNotInLoadedRange && !shiftFocusedItemNotInLoadedRange;
    }
    if (allowSelectByShift && "multiple" === this.options.mode && this._focusedItemIndex >= 0) {
      if (allowLoadByRange && (focusedItemNotInLoadedRange || shiftFocusedItemNotInLoadedRange)) {
        isSelectedItemsChanged = itemIndex !== this._shiftFocusedItemIndex || this._focusedItemIndex !== this._shiftFocusedItemIndex;
        if (isSelectedItemsChanged) {
          deferred = this.changeItemSelectionWhenShiftKeyInVirtualPaging(itemIndex);
        }
      } else {
        isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset);
      }
    } else if (keys.control) {
      this._resetItemSelectionWhenShiftKeyPressed();
      if (!setFocusOnly) {
        const isSelected = this._selectionStrategy.isItemDataSelected(itemData);
        if ("single" === this.options.mode) {
          this.clearSelectedItems();
        }
        if (isSelected) {
          this._removeSelectedItem(itemKey);
        } else {
          this._addSelectedItem(itemData, itemKey);
        }
      }
      isSelectedItemsChanged = true;
    } else {
      this._resetItemSelectionWhenShiftKeyPressed();
      const isKeysEqual2 = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);
      if (1 !== this.options.selectedItemKeys.length || !isKeysEqual2) {
        this._setSelectedItems([itemKey], [itemData]);
        isSelectedItemsChanged = true;
      }
    }
    if (isSelectedItemsChanged) {
      when(deferred).done(() => {
        this._focusedItemIndex = itemIndex;
        !setFocusOnly && this.onSelectionChanged();
      });
      return true;
    }
  }
  isDataItem(item) {
    return this.options.isSelectableItem(item);
  }
  isSelectable() {
    return "single" === this.options.mode || "multiple" === this.options.mode;
  }
  isItemDataSelected(data2) {
    return this._selectionStrategy.isItemDataSelected(data2, {
      checkPending: true
    });
  }
  isItemSelected(arg, options2) {
    return this._selectionStrategy.isItemKeySelected(arg, options2);
  }
  _resetItemSelectionWhenShiftKeyPressed() {
    delete this._shiftFocusedItemIndex;
  }
  _resetFocusedItemIndex() {
    this._focusedItemIndex = -1;
  }
  changeItemSelectionWhenShiftKeyInVirtualPaging(loadIndex) {
    const loadOptions = this.options.getLoadOptions(loadIndex, this._focusedItemIndex, this._shiftFocusedItemIndex);
    const deferred = Deferred();
    const indexOffset = loadOptions.skip;
    this.options.load(loadOptions).done((items) => {
      this.changeItemSelectionWhenShiftKeyPressed(loadIndex, items, indexOffset);
      deferred.resolve();
    });
    return deferred.promise();
  }
  changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset) {
    let isSelectedItemsChanged = false;
    let itemIndexStep;
    const indexOffsetDefined = isDefined(indexOffset);
    let index2 = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
    const {
      keyOf
    } = this.options;
    const focusedItem = items[index2];
    const focusedData = this.options.getItemData(focusedItem);
    const focusedKey = keyOf(focusedData);
    const isFocusedItemSelected = focusedItem && this.isItemDataSelected(focusedData);
    if (!isDefined(this._shiftFocusedItemIndex)) {
      this._shiftFocusedItemIndex = this._focusedItemIndex;
    }
    let data2;
    let itemKey;
    let startIndex;
    let endIndex;
    if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
      itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index2 = startIndex; index2 !== endIndex; index2 += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index2])) {
          itemKey = keyOf(this.options.getItemData(items[index2]));
          this._removeSelectedItem(itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if (itemIndex !== this._shiftFocusedItemIndex) {
      itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? itemIndex - indexOffset : itemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index2 = startIndex; index2 !== endIndex; index2 += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index2])) {
          data2 = this.options.getItemData(items[index2]);
          itemKey = keyOf(data2);
          this._addSelectedItem(data2, itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if ((indexOffsetDefined || this.isDataItem(focusedItem)) && !isFocusedItemSelected) {
      this._addSelectedItem(focusedData, focusedKey);
      isSelectedItemsChanged = true;
    }
    return isSelectedItemsChanged;
  }
  clearSelectedItems() {
    this._setSelectedItems([], []);
  }
  selectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._onePageSelectAll(false);
    }
    return this.selectedItemKeys([], true, false, true);
  }
  deselectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._onePageSelectAll(true);
    }
    return this.selectedItemKeys([], true, true, true);
  }
  _onePageSelectAll(isDeselect) {
    const items = this._selectionStrategy.getSelectableItems(this.options.plainItems());
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (this.isDataItem(item)) {
        const itemData = this.options.getItemData(item);
        const itemKey = this.options.keyOf(itemData);
        const isSelected = this.isItemSelected(itemKey);
        if (!isSelected && !isDeselect) {
          this._addSelectedItem(itemData, itemKey);
        }
        if (isSelected && isDeselect) {
          this._removeSelectedItem(itemKey);
        }
      }
    }
    this.onSelectionChanged();
    return Deferred().resolve();
  }
  getSelectAllState(visibleOnly) {
    return this._selectionStrategy.getSelectAllState(visibleOnly);
  }
  loadSelectedItemsWithFilter() {
    return this._selectionStrategy.loadSelectedItemsWithFilter();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_data_controller.js
var DataControllerMock = {
  load: () => Deferred().reject(),
  loadSingle: () => Deferred().reject(),
  loadFromStore: () => Deferred().reject(),
  loadNextPage: () => Deferred().reject(),
  loadOptions: noop2,
  userData: noop2,
  cancel: noop2,
  cancelAll: noop2,
  filter: noop2,
  addSearchFilter: noop2,
  group: noop2,
  paginate: noop2,
  pageSize: noop2,
  pageIndex: noop2,
  resetDataSourcePageIndex: noop2,
  totalCount: noop2,
  isLastPage: noop2,
  isLoading: noop2,
  isLoaded: noop2,
  searchValue: noop2,
  searchOperation: noop2,
  searchExpr: noop2,
  select: noop2,
  key: noop2,
  keyOf: noop2,
  store: noop2,
  items: noop2,
  applyMapFunction: noop2,
  getDataSource: noop2,
  reload: noop2,
  on: noop2,
  off: noop2
};
var DataController = class {
  constructor(dataSource) {
    if (!dataSource) {
      return DataControllerMock;
    }
    this._dataSource = dataSource;
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(propName, propValue) {
    if (arguments.length < 2) {
      propValue = propName;
      propName = this.key();
    }
    return this._dataSource.loadSingle(propName, propValue);
  }
  loadFromStore(loadOptions) {
    return this.store().load(loadOptions);
  }
  loadNextPage() {
    this.pageIndex(1 + this.pageIndex());
    return this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(operationId) {
    this._dataSource.cancel(operationId);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(filter) {
    return this._dataSource.filter(filter);
  }
  addSearchFilter(storeLoadOptions) {
    this._dataSource._addSearchFilter(storeLoadOptions);
  }
  group(group) {
    return this._dataSource.group(group);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(pageIndex) {
    return this._dataSource.pageIndex(pageIndex);
  }
  resetDataSourcePageIndex() {
    if (this.pageIndex()) {
      this.pageIndex(0);
      this.load();
    }
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(value2) {
    if (!arguments.length) {
      return this._dataSource.searchValue();
    }
    return this._dataSource.searchValue(value2);
  }
  searchOperation(operation) {
    return this._dataSource.searchOperation(operation);
  }
  searchExpr(expr) {
    if (!arguments.length) {
      return this._dataSource.searchExpr();
    }
    return this._dataSource.searchExpr(expr);
  }
  select() {
    return this._dataSource.select(...arguments);
  }
  key() {
    return this._dataSource.key();
  }
  keyOf(item) {
    return this.store().keyOf(item);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    return this._dataSource.items();
  }
  applyMapFunction(data2) {
    return this._dataSource._applyMapFunction(data2);
  }
  getDataSource() {
    return this._dataSource || null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(event, handler) {
    this._dataSource.on(event, handler);
  }
  off(event, handler) {
    this._dataSource.off(event, handler);
  }
};
var m_data_controller_default = DataController;

// ../../../../../../node_modules/devextreme/esm/data_helper.js
var DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler";
var SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
var NORMALIZE_DATA_SOURCE = "_normalizeDataSource";
var DataHelperMixin = {
  postCtor: function() {
    this.on("disposing", (function() {
      this._disposeDataSource();
    }).bind(this));
  },
  _refreshDataSource: function() {
    this._initDataSource();
    this._loadDataSource();
  },
  _initDataSource: function() {
    let dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
    let widgetDataSourceOptions;
    let dataSourceType;
    this._disposeDataSource();
    if (dataSourceOptions) {
      if (dataSourceOptions instanceof DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = "_dataSourceOptions" in this ? this._dataSourceOptions() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
        dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
          fromUrlLoadMode: "_dataSourceFromUrlLoadMode" in this && this._dataSourceFromUrlLoadMode()
        });
        this._dataSource = new dataSourceType(extend(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }
      if (NORMALIZE_DATA_SOURCE in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource);
      }
      this._addDataSourceHandlers();
      this._initDataController();
    }
  },
  _initDataController: function() {
    var _this$option;
    const dataController = null === (_this$option = this.option) || void 0 === _this$option ? void 0 : _this$option.call(this, "_dataController");
    const dataSource = this._dataSource;
    if (dataController) {
      this._dataController = dataController;
    } else {
      this._dataController = new m_data_controller_default(dataSource);
    }
  },
  _addDataSourceHandlers: function() {
    if (DATA_SOURCE_CHANGED_METHOD in this) {
      this._addDataSourceChangeHandler();
    }
    if ("_dataSourceLoadErrorHandler" in this) {
      this._addDataSourceLoadErrorHandler();
    }
    if ("_dataSourceLoadingChangedHandler" in this) {
      this._addDataSourceLoadingChangedHandler();
    }
    this._addReadyWatcher();
  },
  _addReadyWatcher: function() {
    this.readyWatcher = (function(isLoading) {
      this._ready && this._ready(!isLoading);
    }).bind(this);
    this._dataSource.on("loadingChanged", this.readyWatcher);
  },
  _addDataSourceChangeHandler: function() {
    const dataSource = this._dataSource;
    this._proxiedDataSourceChangedHandler = (function(e) {
      this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e);
    }).bind(this);
    dataSource.on("changed", this._proxiedDataSourceChangedHandler);
  },
  _addDataSourceLoadErrorHandler: function() {
    this._proxiedDataSourceLoadErrorHandler = this._dataSourceLoadErrorHandler.bind(this);
    this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
  },
  _addDataSourceLoadingChangedHandler: function() {
    this._proxiedDataSourceLoadingChangedHandler = this._dataSourceLoadingChangedHandler.bind(this);
    this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
  },
  _loadDataSource: function() {
    const dataSource = this._dataSource;
    if (dataSource) {
      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  },
  _loadSingle: function(key, value2) {
    key = "this" === key ? this._dataSource.key() || "this" : key;
    return this._dataSource.loadSingle(key, value2);
  },
  _isLastPage: function() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  },
  _isDataSourceLoading: function() {
    return this._dataSource && this._dataSource.isLoading();
  },
  _disposeDataSource: function() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
        if (this._dataSource._eventsStrategy) {
          this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher);
        }
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  },
  getDataSource: function() {
    return this._dataSource || null;
  }
};
var data_helper_default = DataHelperMixin;

// ../../../../../../node_modules/devextreme/esm/events/contextmenu.js
var CONTEXTMENU_NAMESPACED_EVENT_NAME = addNamespace2("contextmenu", "dxContexMenu");
var HOLD_NAMESPACED_EVENT_NAME = addNamespace2(hold_default.name, "dxContexMenu");
var ContextMenu = class_default.inherit({
  setup: function(element) {
    const $element = renderer_default(element);
    events_engine_default.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
    if (touch || devices_default.isSimulator()) {
      events_engine_default.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this));
    }
  },
  _holdHandler: function(e) {
    if (isMouseEvent(e) && !devices_default.isSimulator()) {
      return;
    }
    this._fireContextMenu(e);
  },
  _contextMenuHandler: function(e) {
    this._fireContextMenu(e);
  },
  _fireContextMenu: function(e) {
    return fireEvent({
      type: "dxcontextmenu",
      originalEvent: e
    });
  },
  teardown: function(element) {
    events_engine_default.off(element, ".dxContexMenu");
  }
});
event_registrator_default("dxcontextmenu", new ContextMenu());
var name = "dxcontextmenu";

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_item.js
var forcibleWatcher = function(watchMethod, fn, callback) {
  const filteredCallback = function() {
    let oldValue;
    return function(value2) {
      if (oldValue !== value2) {
        callback(value2, oldValue);
        oldValue = value2;
      }
    };
  }();
  return {
    dispose: watchMethod(fn, filteredCallback),
    force() {
      filteredCallback(fn());
    }
  };
};
var CollectionItem = class_default.inherit({
  ctor($element, options2, rawData) {
    this._$element = $element;
    this._options = options2;
    this._rawData = rawData;
    attachInstanceToElement($element, this, this._dispose);
    this._render();
  },
  _render() {
    const $placeholder = renderer_default("<div>").addClass("dx-item-content-placeholder");
    this._$element.append($placeholder);
    this._watchers = [];
    this._renderWatchers();
  },
  _renderWatchers() {
    this._startWatcher("disabled", this._renderDisabled.bind(this));
    this._startWatcher("visible", this._renderVisible.bind(this));
  },
  _startWatcher(field, render4) {
    const rawData = this._rawData;
    const exprGetter = this._options.fieldGetter(field);
    const watcher = forcibleWatcher(this._options.watchMethod(), () => exprGetter(rawData), (value2, oldValue) => {
      this._dirty = true;
      render4(value2, oldValue);
    });
    this._watchers.push(watcher);
  },
  setDataField() {
    this._dirty = false;
    each(this._watchers, (_, watcher) => {
      watcher.force();
    });
    if (this._dirty) {
      return true;
    }
  },
  _renderDisabled(value2, oldValue) {
    this._$element.toggleClass("dx-state-disabled", !!value2);
    this._$element.attr("aria-disabled", !!value2);
    this._updateOwnerFocus(value2);
  },
  _updateOwnerFocus(isDisabled) {
    const ownerComponent = this._options.owner;
    if (ownerComponent && isDisabled) {
      ownerComponent._resetItemFocus(this._$element);
    }
  },
  _renderVisible(value2, oldValue) {
    this._$element.toggleClass("dx-state-invisible", void 0 !== value2 && !value2);
  },
  _dispose() {
    each(this._watchers, (_, watcher) => {
      watcher.dispose();
    });
  }
});
CollectionItem.getInstance = function($element) {
  return getInstanceByElement($element, this);
};
var m_item_default = CollectionItem;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.base.js
var ITEM_CLASS = "dx-item";
var EMPTY_COLLECTION = "dx-empty-collection";
var ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
var CollectionWidget = ui_widget_default.inherit({
  _activeStateUnit: `.${ITEM_CLASS}`,
  _supportedKeys() {
    const move2 = function(location, e) {
      if (!isCommandKeyPressed(e)) {
        e.preventDefault();
        e.stopPropagation();
        this._moveFocus(location, e);
      }
    };
    return extend(this.callBase(), {
      space: function(e) {
        e.preventDefault();
        this._enterKeyHandler(e);
      },
      enter: this._enterKeyHandler,
      leftArrow: move2.bind(this, "left"),
      rightArrow: move2.bind(this, "right"),
      upArrow: move2.bind(this, "up"),
      downArrow: move2.bind(this, "down"),
      pageUp: move2.bind(this, "up"),
      pageDown: move2.bind(this, "down"),
      home: move2.bind(this, "first"),
      end: move2.bind(this, "last")
    });
  },
  _enterKeyHandler(e) {
    const $itemElement = renderer_default(this.option("focusedElement"));
    if (!$itemElement.length) {
      return;
    }
    const itemData = this._getItemData($itemElement);
    if (null !== itemData && void 0 !== itemData && itemData.onClick) {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    }
    this._itemClickHandler(extend({}, e, {
      target: $itemElement.get(0),
      currentTarget: $itemElement.get(0)
    }));
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      selectOnFocus: false,
      loopItemFocus: true,
      items: [],
      itemTemplate: "item",
      onItemRendered: null,
      onItemClick: null,
      onItemHold: null,
      itemHoldTimeout: 750,
      onItemContextMenu: null,
      onFocusedItemChanged: null,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      encodeNoDataText: false,
      dataSource: null,
      _dataController: null,
      _itemAttributes: {},
      itemTemplateProperty: "template",
      focusOnSelectedItem: true,
      focusedElement: null,
      displayExpr: void 0,
      disabledExpr: (data2) => data2 ? data2.disabled : void 0,
      visibleExpr: (data2) => data2 ? data2.visible : void 0
    });
  },
  _init() {
    this._compileDisplayGetter();
    this._initDataController();
    this.callBase();
    this._cleanRenderedItems();
    this._refreshDataSource();
  },
  _compileDisplayGetter() {
    const displayExpr = this.option("displayExpr");
    this._displayGetter = displayExpr ? compileGetter(this.option("displayExpr")) : void 0;
  },
  _initTemplates() {
    this._initItemsFromMarkup();
    this._initDefaultItemTemplate();
    this.callBase();
  },
  _getAnonymousTemplateName: () => "item",
  _initDefaultItemTemplate() {
    const fieldsMap = this._getFieldsMap();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data2) => {
        if (isPlainObject(data2)) {
          this._prepareDefaultItemTemplate(data2, $container);
        } else {
          if (fieldsMap && isFunction(fieldsMap.text)) {
            data2 = fieldsMap.text(data2);
          }
          $container.text(String(ensureDefined(data2, "")));
        }
      }, this._getBindableFields(), this.option("integrationOptions.watchMethod"), fieldsMap)
    });
  },
  _getBindableFields: () => ["text", "html"],
  _getFieldsMap() {
    if (this._displayGetter) {
      return {
        text: this._displayGetter
      };
    }
  },
  _prepareDefaultItemTemplate(data2, $container) {
    if (isDefined(data2.text)) {
      $container.text(data2.text);
    }
    if (isDefined(data2.html)) {
      $container.html(data2.html);
    }
  },
  _initItemsFromMarkup() {
    const rawItems = findTemplates(this.$element(), "dxItem");
    if (!rawItems.length || this.option("items").length) {
      return;
    }
    const items = rawItems.map((_ref) => {
      let {
        element,
        options: options2
      } = _ref;
      const isTemplateRequired = /\S/.test(element.innerHTML) && !options2.template;
      if (isTemplateRequired) {
        options2.template = this._prepareItemTemplate(element);
      } else {
        renderer_default(element).remove();
      }
      return options2;
    });
    this.option("items", items);
  },
  _prepareItemTemplate(item) {
    const templateId = "tmpl-" + new guid_default();
    const $template = renderer_default(item).detach().clone().removeAttr("data-options").addClass("dx-template-wrapper");
    this._saveTemplate(templateId, $template);
    return templateId;
  },
  _dataSourceOptions: () => ({
    paginate: false
  }),
  _cleanRenderedItems() {
    this._renderedItemsCount = 0;
  },
  _focusTarget() {
    return this.$element();
  },
  _focusInHandler(e) {
    this.callBase.apply(this, arguments);
    if (!this._isFocusTarget(e.target)) {
      return;
    }
    const $focusedElement = renderer_default(this.option("focusedElement"));
    if ($focusedElement.length) {
      this._setFocusedItem($focusedElement);
    } else {
      const $activeItem = this._getActiveItem();
      if ($activeItem.length) {
        this.option("focusedElement", getPublicElement($activeItem));
      }
    }
  },
  _focusOutHandler() {
    this.callBase.apply(this, arguments);
    const $target = renderer_default(this.option("focusedElement"));
    this._updateFocusedItemState($target, false);
  },
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit);
  },
  _getActiveItem(last) {
    const $focusedElement = renderer_default(this.option("focusedElement"));
    if ($focusedElement.length) {
      return $focusedElement;
    }
    let index2 = this.option("focusOnSelectedItem") ? this.option("selectedIndex") : 0;
    const activeElements = this._getActiveElement();
    const lastIndex = activeElements.length - 1;
    if (index2 < 0) {
      index2 = last ? lastIndex : 0;
    }
    return activeElements.eq(index2);
  },
  _moveFocus(location) {
    const $items = this._getAvailableItems();
    let $newTarget;
    switch (location) {
      case "pageup":
      case "up":
        $newTarget = this._prevItem($items);
        break;
      case "pagedown":
      case "down":
        $newTarget = this._nextItem($items);
        break;
      case "right":
        $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
        break;
      case "left":
        $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
        break;
      case "first":
        $newTarget = $items.first();
        break;
      case "last":
        $newTarget = $items.last();
        break;
      default:
        return false;
    }
    if (0 !== $newTarget.length) {
      this.option("focusedElement", getPublicElement($newTarget));
    }
  },
  _getVisibleItems($itemElements) {
    $itemElements = $itemElements || this._itemElements();
    return $itemElements.filter(":visible");
  },
  _getAvailableItems($itemElements) {
    return this._getVisibleItems($itemElements);
  },
  _prevItem($items) {
    const $target = this._getActiveItem();
    const targetIndex = $items.index($target);
    const $last = $items.last();
    let $item = renderer_default($items[targetIndex - 1]);
    const loop = this.option("loopItemFocus");
    if (0 === $item.length && loop) {
      $item = $last;
    }
    return $item;
  },
  _nextItem($items) {
    const $target = this._getActiveItem(true);
    const targetIndex = $items.index($target);
    const $first = $items.first();
    let $item = renderer_default($items[targetIndex + 1]);
    const loop = this.option("loopItemFocus");
    if (0 === $item.length && loop) {
      $item = $first;
    }
    return $item;
  },
  _selectFocusedItem($target) {
    this.selectItem($target);
  },
  _updateFocusedItemState(target, isFocused, needCleanItemId) {
    const $target = renderer_default(target);
    if ($target.length) {
      this._refreshActiveDescendant();
      this._refreshItemId($target, needCleanItemId);
      this._toggleFocusClass(isFocused, $target);
    }
    this._updateParentActiveDescendant();
  },
  _refreshActiveDescendant($target) {
    this.setAria("activedescendant", isDefined(this.option("focusedElement")) ? this.getFocusedItemId() : null, $target);
  },
  _refreshItemId($target, needCleanItemId) {
    if (!needCleanItemId && this.option("focusedElement")) {
      this.setAria("id", this.getFocusedItemId(), $target);
    } else {
      this.setAria("id", null, $target);
    }
  },
  _isDisabled: ($element) => $element && "true" === renderer_default($element).attr("aria-disabled"),
  _setFocusedItem($target) {
    if (!$target || !$target.length) {
      return;
    }
    this._updateFocusedItemState($target, true);
    this.onFocusedItemChanged(this.getFocusedItemId());
    const {
      selectOnFocus
    } = this.option();
    const isTargetDisabled = this._isDisabled($target);
    if (selectOnFocus && !isTargetDisabled) {
      this._selectFocusedItem($target);
    }
  },
  _findItemElementByItem(item) {
    let result2 = renderer_default();
    const that = this;
    this.itemElements().each(function() {
      const $item = renderer_default(this);
      if ($item.data(that._itemDataKey()) === item) {
        result2 = $item;
        return false;
      }
    });
    return result2;
  },
  _getIndexByItem(item) {
    return this.option("items").indexOf(item);
  },
  _itemOptionChanged(item, property, value2, oldValue) {
    const $item = this._findItemElementByItem(item);
    if (!$item.length) {
      return;
    }
    if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value2)) {
      this._refreshItem($item, item);
    }
    const isDisabling = "disabled" === property && value2;
    if (isDisabling) {
      this._resetItemFocus($item);
    }
  },
  _resetItemFocus($item) {
    if ($item.is(this.option("focusedElement"))) {
      this.option("focusedElement", null);
    }
  },
  _refreshItem($item) {
    const itemData = this._getItemData($item);
    const index2 = $item.data(this._itemIndexKey());
    this._renderItem(this._renderedItemsCount + index2, itemData, null, $item);
  },
  _updateParentActiveDescendant: noop2,
  _optionChanged(args) {
    if ("items" === args.name) {
      const matches = args.fullName.match(ITEM_PATH_REGEX);
      if (matches && matches.length) {
        const property = matches[matches.length - 1];
        const itemPath = args.fullName.replace(`.${property}`, "");
        const item = this.option(itemPath);
        this._itemOptionChanged(item, property, args.value, args.previousValue);
        return;
      }
    }
    switch (args.name) {
      case "items":
      case "_itemAttributes":
      case "itemTemplateProperty":
      case "useItemTextAsTitle":
        this._cleanRenderedItems();
        this._invalidate();
        break;
      case "dataSource":
        this._refreshDataSource();
        this._renderEmptyMessage();
        break;
      case "noDataText":
      case "encodeNoDataText":
        this._renderEmptyMessage();
        break;
      case "itemTemplate":
      case "visibleExpr":
      case "disabledExpr":
        this._invalidate();
        break;
      case "onItemRendered":
        this._createItemRenderAction();
        break;
      case "onItemClick":
      case "selectOnFocus":
      case "loopItemFocus":
      case "focusOnSelectedItem":
        break;
      case "onItemHold":
      case "itemHoldTimeout":
        this._attachHoldEvent();
        break;
      case "onItemContextMenu":
        this._attachContextMenuEvent();
        break;
      case "onFocusedItemChanged":
        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
        break;
      case "focusedElement":
        this._updateFocusedItemState(args.previousValue, false, true);
        this._setFocusedItem(renderer_default(args.value));
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._initDefaultItemTemplate();
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  },
  _invalidate() {
    this.option("focusedElement", null);
    return this.callBase.apply(this, arguments);
  },
  _loadNextPage() {
    this._expectNextPageLoading();
    return this._dataController.loadNextPage();
  },
  _expectNextPageLoading() {
    this._startIndexForAppendedItems = 0;
  },
  _expectLastItemLoading() {
    this._startIndexForAppendedItems = -1;
  },
  _forgetNextPageLoading() {
    this._startIndexForAppendedItems = null;
  },
  _dataSourceChangedHandler(newItems) {
    const items = this.option("items");
    if (this._initialized && items && this._shouldAppendItems()) {
      this._renderedItemsCount = items.length;
      if (!this._isLastPage() || -1 !== this._startIndexForAppendedItems) {
        this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems));
      }
      this._forgetNextPageLoading();
      this._refreshContent();
    } else {
      this.option("items", newItems.slice());
    }
  },
  _refreshContent() {
    this._prepareContent();
    this._renderContent();
  },
  _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading();
    this.option("items", this.option("items"));
  },
  _shouldAppendItems() {
    return null != this._startIndexForAppendedItems && this._allowDynamicItemsAppend();
  },
  _allowDynamicItemsAppend: () => false,
  _clean() {
    this._cleanFocusState();
    this._cleanItemContainer();
    this._inkRipple && delete this._inkRipple;
    this._resetActiveState();
  },
  _cleanItemContainer() {
    renderer_default(this._itemContainer()).empty();
  },
  _dispose() {
    this.callBase();
    clearTimeout(this._itemFocusTimeout);
  },
  _refresh() {
    this._cleanRenderedItems();
    this.callBase.apply(this, arguments);
  },
  _itemContainer() {
    return this.$element();
  },
  _itemClass: () => ITEM_CLASS,
  _itemContentClass() {
    return this._itemClass() + "-content";
  },
  _selectedItemClass: () => "dx-item-selected",
  _itemResponseWaitClass: () => "dx-item-response-wait",
  _itemSelector() {
    return `.${this._itemClass()}`;
  },
  _itemDataKey: () => "dxItemData",
  _itemIndexKey: () => "dxItemIndex",
  _itemElements() {
    return this._itemContainer().find(this._itemSelector());
  },
  _initMarkup() {
    this.callBase();
    this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
    this.$element().addClass("dx-collection");
    this._prepareContent();
  },
  _prepareContent: deferRenderer(function() {
    this._renderContentImpl();
  }),
  _renderContent() {
    this._fireContentReadyAction();
  },
  _render() {
    this.callBase();
    this._attachClickEvent();
    this._attachHoldEvent();
    this._attachContextMenuEvent();
  },
  _getPointerEvent: () => pointer_default.down,
  _attachClickEvent() {
    const itemSelector = this._itemSelector();
    const pointerEvent = this._getPointerEvent();
    const clickEventNamespace = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const pointerEventNamespace = addNamespace2(pointerEvent, this.NAME);
    const pointerAction = new Action((args) => {
      const {
        event
      } = args;
      this._itemPointerDownHandler(event);
    });
    events_engine_default.off(this._itemContainer(), clickEventNamespace, itemSelector);
    events_engine_default.off(this._itemContainer(), pointerEventNamespace, itemSelector);
    events_engine_default.on(this._itemContainer(), clickEventNamespace, itemSelector, (e) => this._itemClickHandler(e));
    events_engine_default.on(this._itemContainer(), pointerEventNamespace, itemSelector, (e) => {
      pointerAction.execute({
        element: renderer_default(e.target),
        event: e
      });
    });
  },
  _itemClickHandler(e, args, config3) {
    this._itemDXEventHandler(e, "onItemClick", args, config3);
  },
  _itemPointerDownHandler(e) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    this._itemFocusHandler = (function() {
      clearTimeout(this._itemFocusTimeout);
      this._itemFocusHandler = null;
      if (e.isDefaultPrevented()) {
        return;
      }
      const $target = renderer_default(e.target);
      const $closestItem = $target.closest(this._itemElements());
      const $closestFocusable = this._closestFocusable($target);
      if ($closestItem.length && this._isFocusTarget(null === $closestFocusable || void 0 === $closestFocusable ? void 0 : $closestFocusable.get(0))) {
        this.option("focusedElement", getPublicElement($closestItem));
      }
    }).bind(this);
    this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this));
  },
  _closestFocusable($target) {
    if ($target.is(focusable)) {
      return $target;
    }
    $target = $target.parent();
    while ($target.length && !dom_adapter_default.isDocument($target.get(0)) && !dom_adapter_default.isDocumentFragment($target.get(0))) {
      if ($target.is(focusable)) {
        return $target;
      }
      $target = $target.parent();
    }
  },
  _forcePointerDownFocus() {
    this._itemFocusHandler && this._itemFocusHandler();
  },
  _updateFocusState() {
    this.callBase.apply(this, arguments);
    this._forcePointerDownFocus();
  },
  _attachHoldEvent() {
    const $itemContainer = this._itemContainer();
    const itemSelector = this._itemSelector();
    const eventName = addNamespace2(hold_default.name, this.NAME);
    events_engine_default.off($itemContainer, eventName, itemSelector);
    events_engine_default.on($itemContainer, eventName, itemSelector, {
      timeout: this._getHoldTimeout()
    }, this._itemHoldHandler.bind(this));
  },
  _getHoldTimeout() {
    return this.option("itemHoldTimeout");
  },
  _shouldFireHoldEvent() {
    return this.hasActionSubscription("onItemHold");
  },
  _itemHoldHandler(e) {
    if (this._shouldFireHoldEvent()) {
      this._itemDXEventHandler(e, "onItemHold");
    } else {
      e.cancel = true;
    }
  },
  _attachContextMenuEvent() {
    const $itemContainer = this._itemContainer();
    const itemSelector = this._itemSelector();
    const eventName = addNamespace2(name, this.NAME);
    events_engine_default.off($itemContainer, eventName, itemSelector);
    events_engine_default.on($itemContainer, eventName, itemSelector, this._itemContextMenuHandler.bind(this));
  },
  _shouldFireContextMenuEvent() {
    return this.hasActionSubscription("onItemContextMenu");
  },
  _itemContextMenuHandler(e) {
    if (this._shouldFireContextMenuEvent()) {
      this._itemDXEventHandler(e, "onItemContextMenu");
    } else {
      e.cancel = true;
    }
  },
  _renderContentImpl() {
    const items = this.option("items") || [];
    if (this._renderedItemsCount) {
      this._renderItems(items.slice(this._renderedItemsCount));
    } else {
      this._renderItems(items);
    }
  },
  _renderItems(items) {
    if (items.length) {
      each(items, (index2, itemData) => {
        this._renderItem(this._renderedItemsCount + index2, itemData);
      });
    }
    this._renderEmptyMessage();
  },
  _getItemsContainer() {
    return this._itemContainer();
  },
  _setAttributes($element) {
    const attributes = _extends({}, this.option("_itemAttributes"));
    const {
      class: customClassValue
    } = attributes;
    if (customClassValue) {
      const currentClassValue = $element.get(0).className;
      attributes.class = [currentClassValue, customClassValue].join(" ");
    }
    $element.attr(attributes);
  },
  _renderItem(index2, itemData, $container, $itemToReplace) {
    const itemIndex = (null === index2 || void 0 === index2 ? void 0 : index2.item) ?? index2;
    $container = $container || this._getItemsContainer();
    const $itemFrame = this._renderItemFrame(itemIndex, itemData, $container, $itemToReplace);
    this._setElementData($itemFrame, itemData, itemIndex);
    this._setAttributes($itemFrame);
    this._attachItemClickEvent(itemData, $itemFrame);
    const $itemContent = this._getItemContent($itemFrame);
    const renderContentPromise = this._renderItemContent({
      index: itemIndex,
      itemData,
      container: getPublicElement($itemContent),
      contentClass: this._itemContentClass(),
      defaultTemplateName: this.option("itemTemplate")
    });
    const that = this;
    when(renderContentPromise).done(($itemContent2) => {
      that._postprocessRenderItem({
        itemElement: $itemFrame,
        itemContent: $itemContent2,
        itemData,
        itemIndex
      });
      that._executeItemRenderAction(index2, itemData, getPublicElement($itemFrame));
    });
    return $itemFrame;
  },
  _getItemContent($itemFrame) {
    const $itemContent = $itemFrame.find(".dx-item-content-placeholder");
    $itemContent.removeClass("dx-item-content-placeholder");
    return $itemContent;
  },
  _attachItemClickEvent(itemData, $itemElement) {
    if (!itemData || !itemData.onClick) {
      return;
    }
    events_engine_default.on($itemElement, CLICK_EVENT_NAME, (e) => {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    });
  },
  _renderItemContent(args) {
    const itemTemplateName = this._getItemTemplateName(args);
    const itemTemplate = this._getTemplate(itemTemplateName);
    this._addItemContentClasses(args);
    const $templateResult = renderer_default(this._createItemByTemplate(itemTemplate, args));
    if (!$templateResult.hasClass("dx-template-wrapper")) {
      return args.container;
    }
    return this._renderItemContentByNode(args, $templateResult);
  },
  _renderItemContentByNode(args, $node) {
    renderer_default(args.container).replaceWith($node);
    args.container = getPublicElement($node);
    this._addItemContentClasses(args);
    return $node;
  },
  _addItemContentClasses(args) {
    const classes = [ITEM_CLASS + "-content", args.contentClass];
    renderer_default(args.container).addClass(classes.join(" "));
  },
  _appendItemToContainer($container, $itemFrame, index2) {
    $itemFrame.appendTo($container);
  },
  _renderItemFrame(index2, itemData, $container, $itemToReplace) {
    const $itemFrame = renderer_default("<div>");
    new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});
    if ($itemToReplace && $itemToReplace.length) {
      $itemToReplace.replaceWith($itemFrame);
    } else {
      this._appendItemToContainer.call(this, $container, $itemFrame, index2);
    }
    if (this.option("useItemTextAsTitle")) {
      const displayValue = this._displayGetter ? this._displayGetter(itemData) : itemData;
      $itemFrame.attr("title", displayValue);
    }
    return $itemFrame;
  },
  _itemOptions() {
    const that = this;
    return {
      watchMethod: () => that.option("integrationOptions.watchMethod"),
      owner: that,
      fieldGetter(field) {
        const expr = that.option(`${field}Expr`);
        const getter = compileGetter(expr);
        return getter;
      }
    };
  },
  _postprocessRenderItem: noop2,
  _executeItemRenderAction(index2, itemData, itemElement) {
    this._getItemRenderAction()({
      itemElement,
      itemIndex: index2,
      itemData
    });
  },
  _setElementData(element, data2, index2) {
    element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data2).data(this._itemIndexKey(), index2);
  },
  _createItemRenderAction() {
    return this._itemRenderAction = this._createActionByOption("onItemRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
  },
  _getItemRenderAction() {
    return this._itemRenderAction || this._createItemRenderAction();
  },
  _getItemTemplateName(args) {
    const data2 = args.itemData;
    const templateProperty = args.templateProperty || this.option("itemTemplateProperty");
    const template = data2 && data2[templateProperty];
    return template || args.defaultTemplateName;
  },
  _createItemByTemplate(itemTemplate, renderArgs) {
    return itemTemplate.render({
      model: renderArgs.itemData,
      container: renderArgs.container,
      index: renderArgs.index,
      onRendered: this._onItemTemplateRendered(itemTemplate, renderArgs)
    });
  },
  _onItemTemplateRendered: () => noop2,
  _emptyMessageContainer() {
    return this._itemContainer();
  },
  _renderEmptyMessage(items) {
    items = items || this.option("items");
    const noDataText = this.option("noDataText");
    const hideNoData = !noDataText || items && items.length || this._dataController.isLoading();
    if (hideNoData && this._$noData) {
      this._$noData.remove();
      this._$noData = null;
      this.setAria("label", void 0);
    }
    if (!hideNoData) {
      this._$noData = this._$noData || renderer_default("<div>").addClass("dx-empty-message");
      this._$noData.appendTo(this._emptyMessageContainer());
      if (this.option("encodeNoDataText")) {
        this._$noData.text(noDataText);
      } else {
        this._$noData.html(noDataText);
      }
    }
    this.$element().toggleClass(EMPTY_COLLECTION, !hideNoData);
  },
  _itemDXEventHandler(dxEvent, handlerOptionName, actionArgs, actionConfig) {
    this._itemEventHandler(dxEvent.target, handlerOptionName, extend(actionArgs, {
      event: dxEvent
    }), actionConfig);
  },
  _itemEventHandler(initiator, handlerOptionName, actionArgs, actionConfig) {
    const action = this._createActionByOption(handlerOptionName, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  },
  _itemEventHandlerByHandler(initiator, handler, actionArgs, actionConfig) {
    const action = this._createAction(handler, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  },
  _itemEventHandlerImpl(initiator, action, actionArgs) {
    const $itemElement = this._closestItemElement(renderer_default(initiator));
    const args = extend({}, actionArgs);
    return action(extend(actionArgs, this._extendActionArgs($itemElement), args));
  },
  _extendActionArgs($itemElement) {
    return {
      itemElement: getPublicElement($itemElement),
      itemIndex: this._itemElements().index($itemElement),
      itemData: this._getItemData($itemElement)
    };
  },
  _closestItemElement($element) {
    return renderer_default($element).closest(this._itemSelector());
  },
  _getItemData(itemElement) {
    return renderer_default(itemElement).data(this._itemDataKey());
  },
  _getSummaryItemsSize(dimension, items, includeMargin) {
    let result2 = 0;
    if (items) {
      each(items, (_, item) => {
        if ("width" === dimension) {
          result2 += getOuterWidth(item, includeMargin || false);
        } else if ("height" === dimension) {
          result2 += getOuterHeight(item, includeMargin || false);
        }
      });
    }
    return result2;
  },
  getFocusedItemId() {
    if (!this._focusedItemId) {
      this._focusedItemId = `dx-${new guid_default()}`;
    }
    return this._focusedItemId;
  },
  itemElements() {
    return this._itemElements();
  },
  itemsContainer() {
    return this._itemContainer();
  }
}).include(data_helper_default);
CollectionWidget.ItemClass = m_item_default;
var m_collection_widget_base_default = CollectionWidget;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.strategy.js
var {
  abstract: abstract5
} = class_default;
var EditStrategy = class_default.inherit({
  ctor(collectionWidget) {
    this._collectionWidget = collectionWidget;
  },
  getIndexByItemData: abstract5,
  getItemDataByIndex: abstract5,
  getKeysByItems: abstract5,
  getItemsByKeys: abstract5,
  itemsGetter: abstract5,
  getKeyByIndex(index2) {
    const resultIndex = this._denormalizeItemIndex(index2);
    return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0];
  },
  _equalKeys(key1, key2) {
    if (this._collectionWidget._isKeySpecified()) {
      return equalByValue(key1, key2);
    }
    return key1 === key2;
  },
  beginCache() {
    this._cache = {};
  },
  endCache() {
    this._cache = null;
  },
  getIndexByKey: abstract5,
  getNormalizedIndex(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return value2;
    }
    if (this._isItemIndex(value2)) {
      return this._normalizeItemIndex(value2);
    }
    if (this._isNode(value2)) {
      return this._getNormalizedItemIndex(value2);
    }
    return this._normalizeItemIndex(this.getIndexByItemData(value2));
  },
  getIndex(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._denormalizeItemIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return value2;
    }
    if (this._isNode(value2)) {
      return this._denormalizeItemIndex(this._getNormalizedItemIndex(value2));
    }
    return this.getIndexByItemData(value2);
  },
  getItemElement(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._getItemByNormalizedIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return this._getItemByNormalizedIndex(this._normalizeItemIndex(value2));
    }
    if (this._isNode(value2)) {
      return renderer_default(value2);
    }
    const normalizedItemIndex = this._normalizeItemIndex(this.getIndexByItemData(value2));
    return this._getItemByNormalizedIndex(normalizedItemIndex);
  },
  _isNode: (el) => dom_adapter_default.isNode(el && isRenderer(el) ? el.get(0) : el),
  deleteItemAtIndex: abstract5,
  itemPlacementFunc(movingIndex, destinationIndex) {
    return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before";
  },
  moveItemAtIndexToIndex: abstract5,
  _isNormalizedItemIndex: (index2) => "number" === typeof index2 && Math.round(index2) === index2,
  _isItemIndex: abstract5,
  _getNormalizedItemIndex: abstract5,
  _normalizeItemIndex: abstract5,
  _denormalizeItemIndex: abstract5,
  _getItemByNormalizedIndex: abstract5,
  _itemsFromSameParent: abstract5
});
var m_collection_widget_edit_strategy_default = EditStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.strategy.plain.js
var PlainEditStrategy = m_collection_widget_edit_strategy_default.inherit({
  _getPlainItems() {
    return this._collectionWidget.option("items") || [];
  },
  getIndexByItemData(itemData) {
    const keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    if (keyOf) {
      return this.getIndexByKey(keyOf(itemData));
    }
    return this._getPlainItems().indexOf(itemData);
  },
  getItemDataByIndex(index2) {
    return this._getPlainItems()[index2];
  },
  deleteItemAtIndex(index2) {
    this._getPlainItems().splice(index2, 1);
  },
  itemsGetter() {
    return this._getPlainItems();
  },
  getKeysByItems(items) {
    const keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    let result2 = items;
    if (keyOf) {
      result2 = [];
      for (let i = 0; i < items.length; i++) {
        result2.push(keyOf(items[i]));
      }
    }
    return result2;
  },
  getIndexByKey(key) {
    const cache = this._cache;
    const keys = cache && cache.keys || this.getKeysByItems(this._getPlainItems());
    if (cache && !cache.keys) {
      cache.keys = keys;
    }
    if ("object" === typeof key) {
      for (let i = 0, {
        length
      } = keys; i < length; i++) {
        if (this._equalKeys(key, keys[i])) {
          return i;
        }
      }
    } else {
      return keys.indexOf(key);
    }
    return -1;
  },
  getItemsByKeys: (keys, items) => (items || keys).slice(),
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    const items = this._getPlainItems();
    const movedItemData = items[movingIndex];
    items.splice(movingIndex, 1);
    items.splice(destinationIndex, 0, movedItemData);
  },
  _isItemIndex: (index2) => "number" === typeof index2 && Math.round(index2) === index2,
  _getNormalizedItemIndex(itemElement) {
    return this._collectionWidget._itemElements().index(itemElement);
  },
  _normalizeItemIndex: (index2) => index2,
  _denormalizeItemIndex: (index2) => index2,
  _getItemByNormalizedIndex(index2) {
    return index2 > -1 ? this._collectionWidget._itemElements().eq(index2) : null;
  },
  _itemsFromSameParent: () => true
});
var m_collection_widget_edit_strategy_plain_default = PlainEditStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.js
var indexExists = function(index2) {
  return -1 !== index2;
};
var CollectionWidget2 = m_collection_widget_base_default.inherit({
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      selectedItem: true
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      selectionMode: "none",
      selectionRequired: false,
      selectByClick: true,
      selectedItems: [],
      selectedItemKeys: [],
      maxFilterLengthInRequest: 1500,
      keyExpr: null,
      selectedIndex: -1,
      selectedItem: null,
      onSelectionChanged: null,
      onItemReordered: null,
      onItemDeleting: null,
      onItemDeleted: null
    });
  },
  ctor(element, options2) {
    this._userOptions = options2 || {};
    this.callBase(element, options2);
  },
  _init() {
    this._initEditStrategy();
    this.callBase();
    this._initKeyGetter();
    this._initSelectionModule();
  },
  _initKeyGetter() {
    this._keyGetter = compileGetter(this.option("keyExpr"));
  },
  _getKeysByItems(selectedItems) {
    return this._editStrategy.getKeysByItems(selectedItems);
  },
  _getItemsByKeys(selectedItemKeys, selectedItems) {
    return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems);
  },
  _getKeyByIndex(index2) {
    return this._editStrategy.getKeyByIndex(index2);
  },
  _getIndexByKey(key) {
    return this._editStrategy.getIndexByKey(key);
  },
  _getIndexByItemData(itemData) {
    return this._editStrategy.getIndexByItemData(itemData);
  },
  _isKeySpecified() {
    return !!this._dataController.key();
  },
  _getCombinedFilter() {
    return this._dataController.filter();
  },
  key() {
    if (this.option("keyExpr")) {
      return this.option("keyExpr");
    }
    return this._dataController.key();
  },
  keyOf(item) {
    let key = item;
    if (this.option("keyExpr")) {
      key = this._keyGetter(item);
    } else if (this._dataController.store()) {
      key = this._dataController.keyOf(item);
    }
    return key;
  },
  _nullValueSelectionSupported: () => false,
  _initSelectionModule() {
    const that = this;
    const {
      itemsGetter
    } = that._editStrategy;
    this._selection = new Selection({
      allowNullValue: this._nullValueSelectionSupported(),
      mode: this.option("selectionMode"),
      maxFilterLengthInRequest: this.option("maxFilterLengthInRequest"),
      equalByReference: !this._isKeySpecified(),
      onSelectionChanged(args) {
        if (args.addedItemKeys.length || args.removedItemKeys.length) {
          that.option("selectedItems", that._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
          that._updateSelectedItems(args);
        }
      },
      filter: that._getCombinedFilter.bind(that),
      totalCount() {
        const items = that.option("items");
        const totalCount = that._dataController.totalCount();
        return totalCount >= 0 ? totalCount : that._getItemsCount(items);
      },
      key: that.key.bind(that),
      keyOf: that.keyOf.bind(that),
      load(options2) {
        var _dataController$loadO;
        const dataController = that._dataController;
        options2.customQueryParams = null === (_dataController$loadO = dataController.loadOptions()) || void 0 === _dataController$loadO ? void 0 : _dataController$loadO.customQueryParams;
        options2.userData = dataController.userData();
        if (dataController.store()) {
          return dataController.loadFromStore(options2).done((loadResult) => {
            if (that._disposed) {
              return;
            }
            const items = normalizeLoadResult(loadResult).data;
            dataController.applyMapFunction(items);
          });
        }
        return Deferred().resolve(this.plainItems());
      },
      dataFields: () => that._dataController.select(),
      plainItems: itemsGetter.bind(that._editStrategy)
    });
  },
  _getItemsCount(items) {
    return items.reduce((itemsCount, item) => itemsCount + (item.items ? this._getItemsCount(item.items) : 1), 0);
  },
  _initEditStrategy() {
    const Strategy = m_collection_widget_edit_strategy_plain_default;
    this._editStrategy = new Strategy(this);
  },
  _getSelectedItemIndices(keys) {
    const that = this;
    const indices = [];
    keys = keys || this._selection.getSelectedItemKeys();
    that._editStrategy.beginCache();
    each(keys, (_, key) => {
      const selectedIndex = that._getIndexByKey(key);
      if (indexExists(selectedIndex)) {
        indices.push(selectedIndex);
      }
    });
    that._editStrategy.endCache();
    return indices;
  },
  _initMarkup() {
    this._rendering = true;
    if (!this._dataController.isLoading()) {
      this._syncSelectionOptions().done(() => this._normalizeSelectedItems());
    }
    this.callBase();
  },
  _render() {
    this.callBase();
    this._rendering = false;
  },
  _fireContentReadyAction() {
    this._rendering = false;
    this._rendered = true;
    this.callBase.apply(this, arguments);
  },
  _syncSelectionOptions(byOption) {
    byOption = byOption || this._chooseSelectOption();
    let selectedItem;
    let selectedIndex;
    let selectedItemKeys;
    let selectedItems;
    switch (byOption) {
      case "selectedIndex":
        selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedItem", selectedItem);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedItem", null);
        }
        break;
      case "selectedItems":
        selectedItems = this.option("selectedItems") || [];
        selectedIndex = selectedItems.length ? this._editStrategy.getIndexByItemData(selectedItems[0]) : -1;
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        this._setOptionWithoutOptionChange("selectedItem", selectedItems[0]);
        this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
        this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems(selectedItems));
        break;
      case "selectedItem":
        selectedItem = this.option("selectedItem");
        selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedIndex", -1);
        }
        break;
      case "selectedItemKeys":
        selectedItemKeys = this.option("selectedItemKeys");
        if (this.option("selectionRequired")) {
          const selectedItemIndex = this._getIndexByKey(selectedItemKeys[0]);
          if (!indexExists(selectedItemIndex)) {
            return this._syncSelectionOptions("selectedIndex");
          }
        }
        return this._selection.setSelection(selectedItemKeys);
    }
    return Deferred().resolve().promise();
  },
  _chooseSelectOption() {
    let optionName = "selectedIndex";
    const isOptionDefined = (function(optionName2) {
      const optionValue = this.option(optionName2);
      const length = isDefined(optionValue) && optionValue.length;
      return length || optionName2 in this._userOptions;
    }).bind(this);
    if (isOptionDefined("selectedItems")) {
      optionName = "selectedItems";
    } else if (isOptionDefined("selectedItem")) {
      optionName = "selectedItem";
    } else if (isOptionDefined("selectedItemKeys")) {
      optionName = "selectedItemKeys";
    }
    return optionName;
  },
  _compareKeys(oldKeys, newKeys) {
    if (oldKeys.length !== newKeys.length) {
      return false;
    }
    for (let i = 0; i < newKeys.length; i++) {
      if (oldKeys[i] !== newKeys[i]) {
        return false;
      }
    }
    return true;
  },
  _normalizeSelectedItems() {
    if ("none" === this.option("selectionMode")) {
      this._setOptionWithoutOptionChange("selectedItems", []);
      this._syncSelectionOptions("selectedItems");
    } else if ("single" === this.option("selectionMode")) {
      const newSelection = this.option("selectedItems");
      if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && this.option("items") && this.option("items").length) {
        const currentSelection = this._selection.getSelectedItems();
        let normalizedSelection = void 0 === newSelection[0] ? currentSelection[0] : newSelection[0];
        if (void 0 === normalizedSelection) {
          normalizedSelection = this._editStrategy.itemsGetter()[0];
        }
        if (this.option("grouped") && normalizedSelection && normalizedSelection.items) {
          normalizedSelection.items = [normalizedSelection.items[0]];
        }
        this._selection.setSelection(this._getKeysByItems([normalizedSelection]));
        this._setOptionWithoutOptionChange("selectedItems", [normalizedSelection]);
        return this._syncSelectionOptions("selectedItems");
      }
      this._selection.setSelection(this._getKeysByItems(newSelection));
    } else {
      const newKeys = this._getKeysByItems(this.option("selectedItems"));
      const oldKeys = this._selection.getSelectedItemKeys();
      if (!this._compareKeys(oldKeys, newKeys)) {
        this._selection.setSelection(newKeys);
      }
    }
    return Deferred().resolve().promise();
  },
  _itemClickHandler(e) {
    let itemSelectPromise = Deferred().resolve();
    const {
      callBase
    } = this;
    this._createAction((e2) => {
      itemSelectPromise = this._itemSelectHandler(e2.event) ?? itemSelectPromise;
    }, {
      validatingTargetName: "itemElement"
    })({
      itemElement: renderer_default(e.currentTarget),
      event: e
    });
    itemSelectPromise.always(() => {
      callBase.apply(this, arguments);
    });
  },
  _itemSelectHandler(e) {
    var _itemSelectPromise;
    let itemSelectPromise;
    if (!this.option("selectByClick")) {
      return;
    }
    const $itemElement = e.currentTarget;
    if (this.isItemSelected($itemElement)) {
      this.unselectItem(e.currentTarget);
    } else {
      itemSelectPromise = this.selectItem(e.currentTarget);
    }
    return null === (_itemSelectPromise = itemSelectPromise) || void 0 === _itemSelectPromise ? void 0 : _itemSelectPromise.promise();
  },
  _selectedItemElement(index2) {
    return this._itemElements().eq(index2);
  },
  _postprocessRenderItem(args) {
    if ("none" !== this.option("selectionMode")) {
      const $itemElement = renderer_default(args.itemElement);
      const normalizedItemIndex = this._editStrategy.getNormalizedIndex($itemElement);
      const isItemSelected = this._isItemSelected(normalizedItemIndex);
      this._processSelectableItem($itemElement, isItemSelected);
    }
  },
  _processSelectableItem($itemElement, isSelected) {
    $itemElement.toggleClass(this._selectedItemClass(), isSelected);
    this._setAriaSelectionAttribute($itemElement, String(isSelected));
  },
  _updateSelectedItems(args) {
    const that = this;
    const {
      addedItemKeys
    } = args;
    const {
      removedItemKeys
    } = args;
    if (that._rendered && (addedItemKeys.length || removedItemKeys.length)) {
      const selectionChangePromise = that._selectionChangePromise;
      if (!that._rendering) {
        const addedSelection = [];
        let normalizedIndex;
        const removedSelection = [];
        that._editStrategy.beginCache();
        for (let i = 0; i < addedItemKeys.length; i++) {
          normalizedIndex = that._getIndexByKey(addedItemKeys[i]);
          addedSelection.push(normalizedIndex);
          that._addSelection(normalizedIndex);
        }
        for (let i = 0; i < removedItemKeys.length; i++) {
          normalizedIndex = that._getIndexByKey(removedItemKeys[i]);
          removedSelection.push(normalizedIndex);
          that._removeSelection(normalizedIndex);
        }
        that._editStrategy.endCache();
        that._updateSelection(addedSelection, removedSelection);
      }
      when(selectionChangePromise).done(() => {
        that._fireSelectionChangeEvent(args.addedItems, args.removedItems);
      });
    }
  },
  _fireSelectionChangeEvent(addedItems, removedItems) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems,
      removedItems
    });
  },
  _updateSelection: noop2,
  _setAriaSelectionAttribute($target, value2) {
    this.setAria("selected", value2, $target);
  },
  _removeSelection(normalizedIndex) {
    const $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, false);
      events_engine_default.triggerHandler($itemElement, "stateChanged", false);
    }
  },
  _addSelection(normalizedIndex) {
    const $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, true);
      events_engine_default.triggerHandler($itemElement, "stateChanged", true);
    }
  },
  _isItemSelected(index2) {
    const key = this._getKeyByIndex(index2);
    return this._selection.isItemSelected(key, {
      checkPending: true
    });
  },
  _optionChanged(args) {
    switch (args.name) {
      case "selectionMode":
        this._invalidate();
        break;
      case "dataSource":
        if (!args.value || Array.isArray(args.value) && !args.value.length) {
          this.option("selectedItemKeys", []);
        }
        this.callBase(args);
        break;
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
      case "selectedItemKeys":
        this._syncSelectionOptions(args.name).done(() => this._normalizeSelectedItems());
        break;
      case "keyExpr":
        this._initKeyGetter();
        break;
      case "selectionRequired":
        this._normalizeSelectedItems();
        break;
      case "selectByClick":
      case "onSelectionChanged":
      case "onItemDeleting":
      case "onItemDeleted":
      case "onItemReordered":
      case "maxFilterLengthInRequest":
        break;
      default:
        this.callBase(args);
    }
  },
  _clearSelectedItems() {
    this._setOptionWithoutOptionChange("selectedItems", []);
    this._syncSelectionOptions("selectedItems");
  },
  _waitDeletingPrepare($itemElement) {
    if ($itemElement.data("dxItemDeleting")) {
      return Deferred().resolve().promise();
    }
    $itemElement.data("dxItemDeleting", true);
    const deferred = Deferred();
    const deletingActionArgs = {
      cancel: false
    };
    const deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", deletingActionArgs, {
      excludeValidators: ["disabled", "readOnly"]
    });
    when(deletePromise).always(function(value2) {
      const deletePromiseExists = !deletePromise;
      const deletePromiseResolved = !deletePromiseExists && "resolved" === deletePromise.state();
      const argumentsSpecified = !!arguments.length;
      const shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value2;
      when(fromPromise(deletingActionArgs.cancel)).always(() => {
        $itemElement.data("dxItemDeleting", false);
      }).done((cancel2) => {
        shouldDelete && !cancel2 ? deferred.resolve() : deferred.reject();
      }).fail(deferred.reject);
    });
    return deferred.promise();
  },
  _deleteItemFromDS($item) {
    const dataController = this._dataController;
    const deferred = Deferred();
    const disabledState = this.option("disabled");
    const dataStore = dataController.store();
    if (!dataStore) {
      return Deferred().resolve().promise();
    }
    if (!dataStore.remove) {
      throw ui_errors_default.Error("E1011");
    }
    this.option("disabled", true);
    dataStore.remove(dataController.keyOf(this._getItemData($item))).done((key) => {
      if (void 0 !== key) {
        deferred.resolve();
      } else {
        deferred.reject();
      }
    }).fail(() => {
      deferred.reject();
    });
    deferred.always(() => {
      this.option("disabled", disabledState);
    });
    return deferred;
  },
  _tryRefreshLastPage() {
    const deferred = Deferred();
    if (this._isLastPage() || this.option("grouped")) {
      deferred.resolve();
    } else {
      this._refreshLastPage().done(() => {
        deferred.resolve();
      });
    }
    return deferred.promise();
  },
  _refreshLastPage() {
    this._expectLastItemLoading();
    return this._dataController.load();
  },
  _updateSelectionAfterDelete(index2) {
    const key = this._getKeyByIndex(index2);
    this._selection.deselect([key]);
  },
  _updateIndicesAfterIndex(index2) {
    const itemElements = this._itemElements();
    for (let i = index2 + 1; i < itemElements.length; i++) {
      renderer_default(itemElements[i]).data(this._itemIndexKey(), i - 1);
    }
  },
  _simulateOptionChange(optionName) {
    const optionValue = this.option(optionName);
    if (optionValue instanceof DataSource) {
      return;
    }
    this._optionChangedAction({
      name: optionName,
      fullName: optionName,
      value: optionValue
    });
  },
  isItemSelected(itemElement) {
    return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement));
  },
  selectItem(itemElement) {
    if ("none" === this.option("selectionMode")) {
      return;
    }
    const itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return;
    }
    const key = this._getKeyByIndex(itemIndex);
    if (this._selection.isItemSelected(key)) {
      return;
    }
    if ("single" === this.option("selectionMode")) {
      return this._selection.setSelection([key]);
    }
    const selectedItemKeys = this.option("selectedItemKeys") || [];
    return this._selection.setSelection([...selectedItemKeys, key], [key]);
  },
  unselectItem(itemElement) {
    const itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return;
    }
    const selectedItemKeys = this._selection.getSelectedItemKeys();
    if (this.option("selectionRequired") && selectedItemKeys.length <= 1) {
      return;
    }
    const key = this._getKeyByIndex(itemIndex);
    if (!this._selection.isItemSelected(key, {
      checkPending: true
    })) {
      return;
    }
    this._selection.deselect([key]);
  },
  _deleteItemElementByIndex(index2) {
    this._updateSelectionAfterDelete(index2);
    this._updateIndicesAfterIndex(index2);
    this._editStrategy.deleteItemAtIndex(index2);
  },
  _afterItemElementDeleted($item, deletedActionArgs) {
    const changingOption = this._dataController.getDataSource() ? "dataSource" : "items";
    this._simulateOptionChange(changingOption);
    this._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
      beforeExecute() {
        $item.remove();
      },
      excludeValidators: ["disabled", "readOnly"]
    });
    this._renderEmptyMessage();
  },
  deleteItem(itemElement) {
    const that = this;
    const deferred = Deferred();
    const $item = this._editStrategy.getItemElement(itemElement);
    const index2 = this._editStrategy.getNormalizedIndex(itemElement);
    const itemResponseWaitClass = this._itemResponseWaitClass();
    if (indexExists(index2)) {
      this._waitDeletingPrepare($item).done(() => {
        $item.addClass(itemResponseWaitClass);
        const deletedActionArgs = that._extendActionArgs($item);
        that._deleteItemFromDS($item).done(() => {
          that._deleteItemElementByIndex(index2);
          that._afterItemElementDeleted($item, deletedActionArgs);
          that._tryRefreshLastPage().done(() => {
            deferred.resolveWith(that);
          });
        }).fail(() => {
          $item.removeClass(itemResponseWaitClass);
          deferred.rejectWith(that);
        });
      }).fail(() => {
        deferred.rejectWith(that);
      });
    } else {
      deferred.rejectWith(that);
    }
    return deferred.promise();
  },
  reorderItem(itemElement, toItemElement) {
    const deferred = Deferred();
    const that = this;
    const strategy4 = this._editStrategy;
    const $movingItem = strategy4.getItemElement(itemElement);
    const $destinationItem = strategy4.getItemElement(toItemElement);
    const movingIndex = strategy4.getNormalizedIndex(itemElement);
    const destinationIndex = strategy4.getNormalizedIndex(toItemElement);
    const changingOption = this._dataController.getDataSource() ? "dataSource" : "items";
    const canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;
    if (canMoveItems) {
      deferred.resolveWith(this);
    } else {
      deferred.rejectWith(this);
    }
    return deferred.promise().done(function() {
      $destinationItem[strategy4.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
      strategy4.moveItemAtIndexToIndex(movingIndex, destinationIndex);
      this._updateIndicesAfterIndex(movingIndex);
      that.option("selectedItems", that._getItemsByKeys(that._selection.getSelectedItemKeys(), that._selection.getSelectedItems()));
      if ("items" === changingOption) {
        that._simulateOptionChange(changingOption);
      }
      that._itemEventHandler($movingItem, "onItemReordered", {
        fromIndex: strategy4.getIndex(movingIndex),
        toIndex: strategy4.getIndex(destinationIndex)
      }, {
        excludeValidators: ["disabled", "readOnly"]
      });
    });
  }
});
var m_collection_widget_edit_default = CollectionWidget2;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.async.js
var AsyncCollectionWidget = m_collection_widget_edit_default.inherit({
  _initMarkup() {
    this._deferredItems = [];
    this.callBase();
  },
  _renderItemContent(args) {
    const renderContentDeferred = Deferred();
    const itemDeferred = Deferred();
    this._deferredItems[args.index] = itemDeferred;
    const $itemContent = this.callBase.call(this, args);
    itemDeferred.done(() => {
      renderContentDeferred.resolve($itemContent);
    });
    return renderContentDeferred.promise();
  },
  _onItemTemplateRendered(itemTemplate, renderArgs) {
    return () => {
      this._deferredItems[renderArgs.index].resolve();
    };
  },
  _postProcessRenderItems: noop2,
  _renderItemsAsync() {
    const d = Deferred();
    when.apply(this, this._deferredItems).done(() => {
      this._postProcessRenderItems();
      d.resolve();
    });
    return d.promise();
  },
  _clean() {
    this.callBase();
    this._deferredItems = [];
  }
});
var m_collection_widget_async_default = AsyncCollectionWidget;

// ../../../../../../node_modules/devextreme/esm/ui/collection/ui.collection_widget.async.js
var ui_collection_widget_async_default = m_collection_widget_async_default;

// ../../../../../../node_modules/devextreme/esm/ui/collection/ui.collection_widget.edit.js
var ui_collection_widget_edit_default = m_collection_widget_edit_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/widget.js
var TypedWidget = ui_widget_default;
var widget_default = TypedWidget;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/edit.js
var TypedCollectionWidget = ui_collection_widget_edit_default;
var edit_default = TypedCollectionWidget;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/async.js
var TypedCollectionWidget2 = ui_collection_widget_async_default;
var async_default = TypedCollectionWidget2;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/m_constants.js
var TOOLBAR_CLASS = "dx-toolbar";

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.base.js
var TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey";
var ToolbarBase = class extends async_default {
  _getSynchronizableOptionsForCreateComponent() {
    return super._getSynchronizableOptionsForCreateComponent().filter((item) => "disabled" !== item);
  }
  _initTemplates() {
    super._initTemplates();
    const template = new BindableTemplate(($container, data2, rawModel) => {
      if (isPlainObject(data2)) {
        const {
          text,
          html,
          widget
        } = data2;
        if (text) {
          $container.text(text).wrapInner("<div>");
        }
        if (html) {
          $container.html(html);
        }
        if ("dxDropDownButton" === widget) {
          data2.options = data2.options ?? {};
          if (!isDefined(data2.options.stylingMode)) {
            data2.options.stylingMode = this.option("useFlatButtons") ? "text" : "contained";
          }
        }
        if ("dxButton" === widget) {
          if (this.option("useFlatButtons")) {
            data2.options = data2.options ?? {};
            data2.options.stylingMode = data2.options.stylingMode ?? "text";
          }
          if (this.option("useDefaultButtons")) {
            data2.options = data2.options ?? {};
            data2.options.type = data2.options.type ?? "default";
          }
        }
      } else {
        $container.text(String(data2));
      }
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: rawModel,
        parent: this
      });
    }, ["text", "html", "widget", "options"], this.option("integrationOptions.watchMethod"));
    this._templateManager.addDefaultTemplates({
      item: template,
      menuItem: template
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      renderAs: "topToolbar",
      grouped: false,
      useFlatButtons: false,
      useDefaultButtons: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => isMaterialBased(),
      options: {
        useFlatButtons: true
      }
    }]);
  }
  _itemContainer() {
    return this._$toolbarItemsContainer.find([".dx-toolbar-before", ".dx-toolbar-center", ".dx-toolbar-after"].join(","));
  }
  _itemClass() {
    return "dx-toolbar-item";
  }
  _itemDataKey() {
    return TOOLBAR_ITEM_DATA_KEY;
  }
  _dimensionChanged(dimension) {
    if (this._disposed) {
      return;
    }
    this._arrangeItems();
    this._applyCompactMode();
  }
  _initMarkup() {
    this._renderToolbar();
    this._renderSections();
    super._initMarkup();
  }
  _render() {
    super._render();
    this._renderItemsAsync();
    this._updateDimensionsInMaterial();
  }
  _postProcessRenderItems() {
    this._arrangeItems();
  }
  _renderToolbar() {
    this.$element().addClass(TOOLBAR_CLASS);
    this._$toolbarItemsContainer = renderer_default("<div>").addClass("dx-toolbar-items-container").appendTo(this.$element());
    this.setAria("role", "toolbar");
  }
  _renderSections() {
    const $container = this._$toolbarItemsContainer;
    each(["before", "center", "after"], (_, section) => {
      const sectionClass = `dx-toolbar-${section}`;
      const $section = $container.find(`.${sectionClass}`);
      if (!$section.length) {
        this[`_$${section}Section`] = renderer_default("<div>").addClass(sectionClass).attr("role", "presentation").appendTo($container);
      }
    });
  }
  _arrangeItems(width) {
    var _this$_$beforeSection, _this$_$afterSection;
    const elementWidth = width ?? getWidth(this.$element());
    this._$centerSection.css({
      margin: "0 auto",
      float: "none"
    });
    const beforeRect = getBoundingRect(null === (_this$_$beforeSection = this._$beforeSection) || void 0 === _this$_$beforeSection ? void 0 : _this$_$beforeSection.get(0));
    const afterRect = getBoundingRect(null === (_this$_$afterSection = this._$afterSection) || void 0 === _this$_$afterSection ? void 0 : _this$_$afterSection.get(0));
    this._alignCenterSection(beforeRect, afterRect, elementWidth);
    const $label = this._$toolbarItemsContainer.find(".dx-toolbar-label").eq(0);
    const $section = $label.parent();
    if (!$label.length) {
      return;
    }
    const labelOffset = beforeRect.width ? beforeRect.width : $label.position().left;
    const widthBeforeSection = $section.hasClass("dx-toolbar-before") ? 0 : labelOffset;
    const widthAfterSection = $section.hasClass("dx-toolbar-after") ? 0 : afterRect.width;
    let elemsAtSectionWidth = 0;
    $section.children().not(".dx-toolbar-label").each((index2, element) => {
      elemsAtSectionWidth += getOuterWidth(element);
    });
    const freeSpace = elementWidth - elemsAtSectionWidth;
    const sectionMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection, 0);
    if ($section.hasClass("dx-toolbar-before")) {
      this._alignSection(this._$beforeSection, sectionMaxWidth);
    } else {
      const labelPaddings = getOuterWidth($label) - getWidth($label);
      $label.css("maxWidth", sectionMaxWidth - labelPaddings);
    }
  }
  _alignCenterSection(beforeRect, afterRect, elementWidth) {
    var _this$_$centerSection;
    this._alignSection(this._$centerSection, elementWidth - beforeRect.width - afterRect.width);
    const isRTL = this.option("rtlEnabled");
    const leftRect = isRTL ? afterRect : beforeRect;
    const rightRect = isRTL ? beforeRect : afterRect;
    const centerRect = getBoundingRect(null === (_this$_$centerSection = this._$centerSection) || void 0 === _this$_$centerSection ? void 0 : _this$_$centerSection.get(0));
    if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {
      this._$centerSection.css({
        marginLeft: leftRect.width,
        marginRight: rightRect.width,
        float: leftRect.width > rightRect.width ? "none" : "right"
      });
    }
  }
  _alignSection($section, maxWidth) {
    const $labels = $section.find(".dx-toolbar-label");
    let labels = $labels.toArray();
    maxWidth -= this._getCurrentLabelsPaddings(labels);
    const currentWidth = this._getCurrentLabelsWidth(labels);
    const difference = Math.abs(currentWidth - maxWidth);
    if (maxWidth < currentWidth) {
      labels = labels.reverse();
      this._alignSectionLabels(labels, difference, false);
    } else {
      this._alignSectionLabels(labels, difference, true);
    }
  }
  _alignSectionLabels(labels, difference, expanding) {
    const getRealLabelWidth = function(label) {
      return getBoundingRect(label).width;
    };
    for (let i = 0; i < labels.length; i++) {
      const $label = renderer_default(labels[i]);
      const currentLabelWidth = Math.ceil(getRealLabelWidth(labels[i]));
      let labelMaxWidth;
      if (expanding) {
        $label.css("maxWidth", "inherit");
      }
      const possibleLabelWidth = Math.ceil(expanding ? getRealLabelWidth(labels[i]) : currentLabelWidth);
      if (possibleLabelWidth < difference) {
        labelMaxWidth = expanding ? possibleLabelWidth : 0;
        difference -= possibleLabelWidth;
      } else {
        labelMaxWidth = expanding ? currentLabelWidth + difference : currentLabelWidth - difference;
        $label.css("maxWidth", labelMaxWidth);
        break;
      }
      $label.css("maxWidth", labelMaxWidth);
    }
  }
  _applyCompactMode() {
    const $element = renderer_default(this.element());
    $element.removeClass("dx-toolbar-compact");
    if (this.option("compactMode") && this._getSummaryItemsSize("width", this._itemElements(), true) > getWidth($element)) {
      $element.addClass("dx-toolbar-compact");
    }
  }
  _getCurrentLabelsWidth(labels) {
    let width = 0;
    labels.forEach((label) => {
      width += getOuterWidth(label);
    });
    return width;
  }
  _getCurrentLabelsPaddings(labels) {
    let padding = 0;
    labels.forEach((label) => {
      padding += getOuterWidth(label) - getWidth(label);
    });
    return padding;
  }
  _renderItem(index2, item, itemContainer, $after) {
    const location = item.location ?? "center";
    const container = itemContainer ?? this[`_$${location}Section`];
    const itemHasText = !!(item.text ?? item.html);
    const itemElement = super._renderItem(index2, item, container, $after);
    itemElement.toggleClass("dx-toolbar-button", !itemHasText).toggleClass("dx-toolbar-label", itemHasText).addClass(item.cssClass);
    return itemElement;
  }
  _renderGroupedItems() {
    each(this.option("items"), (groupIndex, group) => {
      const groupItems = group.items;
      const $container = renderer_default("<div>").addClass("dx-toolbar-group");
      const location = group.location ?? "center";
      if (!groupItems || !groupItems.length) {
        return;
      }
      each(groupItems, (itemIndex, item) => {
        this._renderItem(itemIndex, item, $container, null);
      });
      this._$toolbarItemsContainer.find(`.dx-toolbar-${location}`).append($container);
    });
  }
  _renderItems(items) {
    const grouped = this.option("grouped") && items.length && items[0].items;
    grouped ? this._renderGroupedItems() : super._renderItems(items);
  }
  _getToolbarItems() {
    return this.option("items") ?? [];
  }
  _renderContentImpl() {
    const items = this._getToolbarItems();
    this.$element().toggleClass("dx-toolbar-mini", 0 === items.length);
    if (this._renderedItemsCount) {
      this._renderItems(items.slice(this._renderedItemsCount));
    } else {
      this._renderItems(items);
    }
    this._applyCompactMode();
  }
  _renderEmptyMessage() {
  }
  _clean() {
    this._$toolbarItemsContainer.children().empty();
    this.$element().empty();
    delete this._$beforeSection;
    delete this._$centerSection;
    delete this._$afterSection;
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._arrangeItems();
    }
  }
  _isVisible() {
    return getWidth(this.$element()) > 0 && getHeight(this.$element()) > 0;
  }
  _getIndexByItem(item) {
    return this._getToolbarItems().indexOf(item);
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    super._itemOptionChanged(item, property, value2, prevValue);
    this._arrangeItems();
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "width":
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "renderAs":
      case "useFlatButtons":
      case "useDefaultButtons":
        this._invalidate();
        break;
      case "compactMode":
        this._applyCompactMode();
        break;
      case "grouped":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dispose() {
    super._dispose();
    clearTimeout(this._waitParentAnimationTimeout);
  }
  _updateDimensionsInMaterial() {
    if (isMaterial()) {
      const _waitParentAnimationFinished = () => new Promise((resolve) => {
        const check = () => {
          let readyToResolve = true;
          this.$element().parents().each((_, parent) => {
            if (fx_default.isAnimating(renderer_default(parent))) {
              readyToResolve = false;
              return false;
            }
          });
          if (readyToResolve) {
            resolve();
          }
          return readyToResolve;
        };
        const runCheck = () => {
          clearTimeout(this._waitParentAnimationTimeout);
          this._waitParentAnimationTimeout = setTimeout(() => check() || runCheck(), 15);
        };
        runCheck();
      });
      const _checkWebFontForLabelsLoaded = () => {
        const $labels = this.$element().find(".dx-toolbar-label");
        const promises = [];
        $labels.each((_, label) => {
          const text = renderer_default(label).text();
          const fontWeight = renderer_default(label).css("fontWeight");
          promises.push(waitWebFont(text, fontWeight));
        });
        return Promise.all(promises);
      };
      Promise.all([_waitParentAnimationFinished(), _checkWebFontForLabelsLoaded()]).then(() => {
        this._dimensionChanged();
      });
    }
  }
};
component_registrator_default("dxToolbarBase", ToolbarBase);
var m_toolbar_base_default = ToolbarBase;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_resizable.js
var RESIZABLE = "dxResizable";
var DRAGSTART_START_EVENT_NAME = addNamespace2(DRAG_START_EVENT, RESIZABLE);
var DRAGSTART_EVENT_NAME = addNamespace2(DRAG_EVENT, RESIZABLE);
var DRAGSTART_END_EVENT_NAME = addNamespace2(DRAG_END_EVENT, RESIZABLE);
var SIDE_BORDER_WIDTH_STYLES = {
  left: "borderLeftWidth",
  top: "borderTopWidth",
  right: "borderRightWidth",
  bottom: "borderBottomWidth"
};
var Resizable = dom_component_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      handles: "all",
      step: "1",
      stepPrecision: "simple",
      area: void 0,
      minWidth: 30,
      maxWidth: 1 / 0,
      minHeight: 30,
      maxHeight: 1 / 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      roundStepValue: true,
      keepAspectRatio: true
    });
  },
  _init() {
    this.callBase();
    this.$element().addClass("dx-resizable");
  },
  _initMarkup() {
    this.callBase();
    this._renderHandles();
  },
  _render() {
    this.callBase();
    this._renderActions();
  },
  _renderActions() {
    this._resizeStartAction = this._createActionByOption("onResizeStart");
    this._resizeEndAction = this._createActionByOption("onResizeEnd");
    this._resizeAction = this._createActionByOption("onResize");
  },
  _renderHandles() {
    this._handles = [];
    const handles = this.option("handles");
    if ("none" === handles || !handles) {
      return;
    }
    const directions = "all" === handles ? ["top", "bottom", "left", "right"] : handles.split(" ");
    const activeHandlesMap = {};
    each(directions, (index2, handleName) => {
      activeHandlesMap[handleName] = true;
      this._renderHandle(handleName);
    });
    activeHandlesMap.bottom && activeHandlesMap.right && this._renderHandle("corner-bottom-right");
    activeHandlesMap.bottom && activeHandlesMap.left && this._renderHandle("corner-bottom-left");
    activeHandlesMap.top && activeHandlesMap.right && this._renderHandle("corner-top-right");
    activeHandlesMap.top && activeHandlesMap.left && this._renderHandle("corner-top-left");
    this._attachEventHandlers();
  },
  _renderHandle(handleName) {
    const $handle = renderer_default("<div>").addClass("dx-resizable-handle").addClass(`dx-resizable-handle-${handleName}`).appendTo(this.$element());
    this._handles.push($handle);
  },
  _attachEventHandlers() {
    if (this.option("disabled")) {
      return;
    }
    const handlers = {};
    handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);
    handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);
    handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);
    this._handles.forEach((handleElement) => {
      events_engine_default.on(handleElement, handlers, {
        direction: "both",
        immediate: true
      });
    });
  },
  _detachEventHandlers() {
    this._handles.forEach((handleElement) => {
      events_engine_default.off(handleElement);
    });
  },
  _toggleEventHandlers(shouldAttachEvents) {
    shouldAttachEvents ? this._attachEventHandlers() : this._detachEventHandlers();
  },
  _getElementSize() {
    const $element = this.$element();
    return "border-box" === $element.css("boxSizing") ? {
      width: getOuterWidth($element),
      height: getOuterHeight($element)
    } : {
      width: getWidth($element),
      height: getHeight($element)
    };
  },
  _dragStartHandler(e) {
    const $element = this.$element();
    if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = true;
      return;
    }
    this._toggleResizingClass(true);
    this._movingSides = this._getMovingSides(e);
    this._elementLocation = locate($element);
    this._elementSize = this._getElementSize();
    this._renderDragOffsets(e);
    this._resizeStartAction({
      event: e,
      width: this._elementSize.width,
      height: this._elementSize.height,
      handles: this._movingSides
    });
    e.targetElements = null;
  },
  _toggleResizingClass(value2) {
    this.$element().toggleClass("dx-resizable-resizing", value2);
  },
  _renderDragOffsets(e) {
    const area = this._getArea();
    if (!area) {
      return;
    }
    const $handle = renderer_default(e.target).closest(".dx-resizable-handle");
    const handleWidth = getOuterWidth($handle);
    const handleHeight = getOuterHeight($handle);
    const handleOffset = $handle.offset();
    const areaOffset = area.offset;
    const scrollOffset = this._getAreaScrollOffset();
    e.maxLeftOffset = this._leftMaxOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;
    e.maxRightOffset = this._rightMaxOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;
    e.maxTopOffset = this._topMaxOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;
    e.maxBottomOffset = this._bottomMaxOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY;
  },
  _getBorderWidth($element, direction) {
    if (isWindow($element.get(0))) {
      return 0;
    }
    const borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES[direction]);
    return parseInt(borderWidth) || 0;
  },
  _proportionate(direction, value2) {
    const size = this._elementSize;
    const factor = "x" === direction ? size.width / size.height : size.height / size.width;
    return value2 * factor;
  },
  _getProportionalDelta(_ref) {
    let {
      x,
      y
    } = _ref;
    const proportionalY = this._proportionate("y", x);
    if (proportionalY >= y) {
      return {
        x,
        y: proportionalY
      };
    }
    const proportionalX = this._proportionate("x", y);
    if (proportionalX >= x) {
      return {
        x: proportionalX,
        y
      };
    }
    return {
      x: 0,
      y: 0
    };
  },
  _getDirectionName(axis) {
    const sides = this._movingSides;
    if ("x" === axis) {
      return sides.left ? "left" : "right";
    }
    return sides.top ? "top" : "bottom";
  },
  _fitIntoArea(axis, value2) {
    const directionName = this._getDirectionName(axis);
    return Math.min(value2, this[`_${directionName}MaxOffset`] ?? 1 / 0);
  },
  _fitDeltaProportionally(delta) {
    let fittedDelta = _extends({}, delta);
    const size = this._elementSize;
    const {
      minWidth,
      minHeight,
      maxWidth,
      maxHeight
    } = this.option();
    const getWidth2 = () => size.width + fittedDelta.x;
    const getHeight2 = () => size.height + fittedDelta.y;
    const isInArea = (axis) => fittedDelta[axis] === this._fitIntoArea(axis, fittedDelta[axis]);
    const isFittedX = () => inRange(getWidth2(), minWidth, maxWidth) && isInArea("x");
    const isFittedY = () => inRange(getHeight2(), minHeight, maxHeight) && isInArea("y");
    if (!isFittedX()) {
      const x = this._fitIntoArea("x", fitIntoRange(getWidth2(), minWidth, maxWidth) - size.width);
      fittedDelta = {
        x,
        y: this._proportionate("y", x)
      };
    }
    if (!isFittedY()) {
      const y = this._fitIntoArea("y", fitIntoRange(getHeight2(), minHeight, maxHeight) - size.height);
      fittedDelta = {
        x: this._proportionate("x", y),
        y
      };
    }
    return isFittedX() && isFittedY() ? fittedDelta : {
      x: 0,
      y: 0
    };
  },
  _fitDelta(_ref2) {
    let {
      x,
      y
    } = _ref2;
    const size = this._elementSize;
    const {
      minWidth,
      minHeight,
      maxWidth,
      maxHeight
    } = this.option();
    return {
      x: fitIntoRange(size.width + x, minWidth, maxWidth) - size.width,
      y: fitIntoRange(size.height + y, minHeight, maxHeight) - size.height
    };
  },
  _getDeltaByOffset(offset2) {
    const sides = this._movingSides;
    const shouldKeepAspectRatio = this._isCornerHandler(sides) && this.option("keepAspectRatio");
    let delta = {
      x: offset2.x * (sides.left ? -1 : 1),
      y: offset2.y * (sides.top ? -1 : 1)
    };
    if (shouldKeepAspectRatio) {
      const proportionalDelta = this._getProportionalDelta(delta);
      const fittedProportionalDelta = this._fitDeltaProportionally(proportionalDelta);
      delta = fittedProportionalDelta;
    } else {
      const fittedDelta = this._fitDelta(delta);
      const roundedFittedDelta = this._roundByStep(fittedDelta);
      delta = roundedFittedDelta;
    }
    return delta;
  },
  _updatePosition(delta, _ref3) {
    let {
      width,
      height
    } = _ref3;
    const location = this._elementLocation;
    const sides = this._movingSides;
    const $element = this.$element();
    const elementRect = this._getElementSize();
    const offsetTop = delta.y * (sides.top ? -1 : 1) - ((elementRect.height || height) - height);
    const offsetLeft = delta.x * (sides.left ? -1 : 1) - ((elementRect.width || width) - width);
    move($element, {
      top: location.top + (sides.top ? offsetTop : 0),
      left: location.left + (sides.left ? offsetLeft : 0)
    });
  },
  _dragHandler(e) {
    const offset2 = this._getOffset(e);
    const delta = this._getDeltaByOffset(offset2);
    const dimensions = this._updateDimensions(delta);
    this._updatePosition(delta, dimensions);
    this._triggerResizeAction(e, dimensions);
  },
  _updateDimensions(delta) {
    const isAbsoluteSize = (size2) => "px" === size2.substring(size2.length - 2);
    const isStepPrecisionStrict = "strict" === this.option("stepPrecision");
    const size = this._elementSize;
    const width = size.width + delta.x;
    const height = size.height + delta.y;
    const elementStyle = this.$element().get(0).style;
    const shouldRenderWidth = delta.x || isStepPrecisionStrict || isAbsoluteSize(elementStyle.width);
    const shouldRenderHeight = delta.y || isStepPrecisionStrict || isAbsoluteSize(elementStyle.height);
    if (shouldRenderWidth) {
      this.option({
        width
      });
    }
    if (shouldRenderHeight) {
      this.option({
        height
      });
    }
    return {
      width: shouldRenderWidth ? width : size.width,
      height: shouldRenderHeight ? height : size.height
    };
  },
  _triggerResizeAction(e, _ref4) {
    let {
      width,
      height
    } = _ref4;
    this._resizeAction({
      event: e,
      width: this.option("width") || width,
      height: this.option("height") || height,
      handles: this._movingSides
    });
    triggerResizeEvent(this.$element());
  },
  _isCornerHandler: (sides) => 0 === Object.values(sides).reduce((xor, value2) => xor ^ value2, 0),
  _getOffset(e) {
    const {
      offset: offset2
    } = e;
    const sides = this._movingSides;
    if (!sides.left && !sides.right) {
      offset2.x = 0;
    }
    if (!sides.top && !sides.bottom) {
      offset2.y = 0;
    }
    return offset2;
  },
  _roundByStep(delta) {
    return "strict" === this.option("stepPrecision") ? this._roundStrict(delta) : this._roundNotStrict(delta);
  },
  _getSteps() {
    return pairToObject(this.option("step"), !this.option("roundStepValue"));
  },
  _roundNotStrict(delta) {
    const steps = this._getSteps();
    return {
      x: delta.x - delta.x % steps.h,
      y: delta.y - delta.y % steps.v
    };
  },
  _roundStrict(delta) {
    const sides = this._movingSides;
    const offset2 = {
      x: delta.x * (sides.left ? -1 : 1),
      y: delta.y * (sides.top ? -1 : 1)
    };
    const steps = this._getSteps();
    const location = this._elementLocation;
    const size = this._elementSize;
    const xPos = sides.left ? location.left : location.left + size.width;
    const yPos = sides.top ? location.top : location.top + size.height;
    const newXShift = (xPos + offset2.x) % steps.h;
    const newYShift = (yPos + offset2.y) % steps.v;
    const sign2 = Math.sign || ((x) => {
      x = +x;
      if (0 === x || isNaN(x)) {
        return x;
      }
      return x > 0 ? 1 : -1;
    });
    const separatorOffset = (steps2, offset3) => (1 + 0.2 * sign2(offset3)) % 1 * steps2;
    const isSmallOffset = (offset3, steps2) => Math.abs(offset3) < 0.2 * steps2;
    let newOffsetX = offset2.x - newXShift;
    let newOffsetY = offset2.y - newYShift;
    if (newXShift > separatorOffset(steps.h, offset2.x)) {
      newOffsetX += steps.h;
    }
    if (newYShift > separatorOffset(steps.v, offset2.y)) {
      newOffsetY += steps.v;
    }
    const roundedOffset_x = (sides.left || sides.right) && !isSmallOffset(offset2.x, steps.h) ? newOffsetX : 0, roundedOffset_y = (sides.top || sides.bottom) && !isSmallOffset(offset2.y, steps.v) ? newOffsetY : 0;
    return {
      x: roundedOffset_x * (sides.left ? -1 : 1),
      y: roundedOffset_y * (sides.top ? -1 : 1)
    };
  },
  _getMovingSides(e) {
    const $target = renderer_default(e.target);
    const hasCornerTopLeftClass = $target.hasClass("dx-resizable-handle-corner-top-left");
    const hasCornerTopRightClass = $target.hasClass("dx-resizable-handle-corner-top-right");
    const hasCornerBottomLeftClass = $target.hasClass("dx-resizable-handle-corner-bottom-left");
    const hasCornerBottomRightClass = $target.hasClass("dx-resizable-handle-corner-bottom-right");
    return {
      top: $target.hasClass("dx-resizable-handle-top") || hasCornerTopLeftClass || hasCornerTopRightClass,
      left: $target.hasClass("dx-resizable-handle-left") || hasCornerTopLeftClass || hasCornerBottomLeftClass,
      bottom: $target.hasClass("dx-resizable-handle-bottom") || hasCornerBottomLeftClass || hasCornerBottomRightClass,
      right: $target.hasClass("dx-resizable-handle-right") || hasCornerTopRightClass || hasCornerBottomRightClass
    };
  },
  _getArea() {
    let area = this.option("area");
    if (isFunction(area)) {
      area = area.call(this);
    }
    if (isPlainObject(area)) {
      return this._getAreaFromObject(area);
    }
    return this._getAreaFromElement(area);
  },
  _getAreaScrollOffset() {
    const area = this.option("area");
    const isElement = !isFunction(area) && !isPlainObject(area);
    const scrollOffset = {
      scrollY: 0,
      scrollX: 0
    };
    if (isElement) {
      const areaElement = renderer_default(area)[0];
      if (isWindow(areaElement)) {
        scrollOffset.scrollX = areaElement.pageXOffset;
        scrollOffset.scrollY = areaElement.pageYOffset;
      }
    }
    return scrollOffset;
  },
  _getAreaFromObject(area) {
    const result2 = {
      width: area.right - area.left,
      height: area.bottom - area.top,
      offset: {
        left: area.left,
        top: area.top
      }
    };
    this._correctAreaGeometry(result2);
    return result2;
  },
  _getAreaFromElement(area) {
    const $area = renderer_default(area);
    let result2;
    if ($area.length) {
      result2 = {
        width: getInnerWidth($area),
        height: getInnerHeight($area),
        offset: extend({
          top: 0,
          left: 0
        }, isWindow($area[0]) ? {} : $area.offset())
      };
      this._correctAreaGeometry(result2, $area);
    }
    return result2;
  },
  _correctAreaGeometry(result2, $area) {
    const areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0;
    const areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
    result2.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), "left");
    result2.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), "top");
    result2.width -= getOuterWidth(this.$element()) - getInnerWidth(this.$element());
    result2.height -= getOuterHeight(this.$element()) - getInnerHeight(this.$element());
  },
  _dragEndHandler(e) {
    const $element = this.$element();
    this._resizeEndAction({
      event: e,
      width: getOuterWidth($element),
      height: getOuterHeight($element),
      handles: this._movingSides
    });
    this._toggleResizingClass(false);
  },
  _renderWidth(width) {
    this.option("width", fitIntoRange(width, this.option("minWidth"), this.option("maxWidth")));
  },
  _renderHeight(height) {
    this.option("height", fitIntoRange(height, this.option("minHeight"), this.option("maxHeight")));
  },
  _optionChanged(args) {
    switch (args.name) {
      case "disabled":
        this._toggleEventHandlers(!args.value);
        this.callBase(args);
        break;
      case "handles":
        this._invalidate();
        break;
      case "minWidth":
      case "maxWidth":
        hasWindow() && this._renderWidth(getOuterWidth(this.$element()));
        break;
      case "minHeight":
      case "maxHeight":
        hasWindow() && this._renderHeight(getOuterHeight(this.$element()));
        break;
      case "onResize":
      case "onResizeStart":
      case "onResizeEnd":
        this._renderActions();
        break;
      case "area":
      case "stepPrecision":
      case "step":
      case "roundStepValue":
      case "keepAspectRatio":
        break;
      default:
        this.callBase(args);
    }
  },
  _clean() {
    this.$element().find(".dx-resizable-handle").remove();
  },
  _useTemplates: () => false
});
component_registrator_default(RESIZABLE, Resizable);
var m_resizable_default = Resizable;

// ../../../../../../node_modules/devextreme/esm/ui/resizable.js
var resizable_default = m_resizable_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popup/m_popup_drag.js
var PopupDrag = class {
  constructor(config3) {
    this.init(config3);
  }
  init(_ref) {
    let {
      dragEnabled,
      handle,
      draggableElement,
      positionController
    } = _ref;
    this._positionController = positionController;
    this._draggableElement = draggableElement;
    this._handle = handle;
    this._dragEnabled = dragEnabled;
    this.unsubscribe();
    if (!dragEnabled) {
      return;
    }
    this.subscribe();
  }
  moveDown(e) {
    this._moveTo(5, 0, e);
  }
  moveUp(e) {
    this._moveTo(-5, 0, e);
  }
  moveLeft(e) {
    this._moveTo(0, -5, e);
  }
  moveRight(e) {
    this._moveTo(0, 5, e);
  }
  subscribe() {
    const eventNames = this._getEventNames();
    events_engine_default.on(this._handle, eventNames.startEventName, (e) => {
      this._dragStartHandler(e);
    });
    events_engine_default.on(this._handle, eventNames.updateEventName, (e) => {
      this._dragUpdateHandler(e);
    });
    events_engine_default.on(this._handle, eventNames.endEventName, (e) => {
      this._dragEndHandler(e);
    });
  }
  unsubscribe() {
    const eventNames = this._getEventNames();
    events_engine_default.off(this._handle, eventNames.startEventName);
    events_engine_default.off(this._handle, eventNames.updateEventName);
    events_engine_default.off(this._handle, eventNames.endEventName);
  }
  _getEventNames() {
    const startEventName = addNamespace2(DRAG_START_EVENT, "overlayDrag");
    const updateEventName = addNamespace2(DRAG_EVENT, "overlayDrag");
    const endEventName = addNamespace2(DRAG_END_EVENT, "overlayDrag");
    return {
      startEventName,
      updateEventName,
      endEventName
    };
  }
  _dragStartHandler(e) {
    const allowedOffsets = this._getAllowedOffsets();
    this._prevOffset = {
      x: 0,
      y: 0
    };
    e.targetElements = [];
    e.maxTopOffset = allowedOffsets.top;
    e.maxBottomOffset = allowedOffsets.bottom;
    e.maxLeftOffset = allowedOffsets.left;
    e.maxRightOffset = allowedOffsets.right;
  }
  _dragUpdateHandler(e) {
    const targetOffset = {
      top: e.offset.y - this._prevOffset.y,
      left: e.offset.x - this._prevOffset.x
    };
    this._moveByOffset(targetOffset);
    this._prevOffset = e.offset;
  }
  _dragEndHandler(event) {
    this._positionController.dragHandled();
    this._positionController.detectVisualPositionChange(event);
  }
  _moveTo(top, left, e) {
    if (!this._dragEnabled) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    const offset2 = this._fitOffsetIntoAllowedRange(top, left);
    this._moveByOffset(offset2);
    this._dragEndHandler(e);
  }
  _fitOffsetIntoAllowedRange(top, left) {
    const allowedOffsets = this._getAllowedOffsets();
    return {
      top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
      left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
    };
  }
  _getContainerDimensions() {
    const document2 = dom_adapter_default.getDocument();
    const container = this._positionController.$dragResizeContainer.get(0);
    let containerWidth = getOuterWidth(container);
    let containerHeight = getOuterHeight(container);
    if (isWindow(container)) {
      containerHeight = Math.max(document2.body.clientHeight, containerHeight);
      containerWidth = Math.max(document2.body.clientWidth, containerWidth);
    }
    return {
      width: containerWidth,
      height: containerHeight
    };
  }
  _getContainerPosition() {
    const container = this._positionController.$dragResizeContainer.get(0);
    return isWindow(container) ? {
      top: 0,
      left: 0
    } : getOffset(container);
  }
  _getElementPosition() {
    return getOffset(this._draggableElement);
  }
  _getInnerDelta() {
    const containerDimensions = this._getContainerDimensions();
    const elementDimensions = this._getElementDimensions();
    return {
      x: containerDimensions.width - elementDimensions.width,
      y: containerDimensions.height - elementDimensions.height
    };
  }
  _getOuterDelta() {
    const {
      width,
      height
    } = this._getElementDimensions();
    const {
      outsideDragFactor
    } = this._positionController;
    return {
      x: width * outsideDragFactor,
      y: height * outsideDragFactor
    };
  }
  _getFullDelta() {
    const fullDelta = this._getInnerDelta();
    const outerDelta = this._getOuterDelta();
    return {
      x: fullDelta.x + outerDelta.x,
      y: fullDelta.y + outerDelta.y
    };
  }
  _getElementDimensions() {
    return {
      width: this._draggableElement.offsetWidth,
      height: this._draggableElement.offsetHeight
    };
  }
  _getAllowedOffsets() {
    const fullDelta = this._getFullDelta();
    const isDragAllowed = fullDelta.y >= 0 && fullDelta.x >= 0;
    if (!isDragAllowed) {
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }
    const elementPosition = this._getElementPosition();
    const containerPosition = this._getContainerPosition();
    const outerDelta = this._getOuterDelta();
    return {
      top: elementPosition.top - containerPosition.top + outerDelta.y,
      bottom: -elementPosition.top + containerPosition.top + fullDelta.y,
      left: elementPosition.left - containerPosition.left + outerDelta.x,
      right: -elementPosition.left + containerPosition.left + fullDelta.x
    };
  }
  _moveByOffset(offset2) {
    const currentPosition = locate(this._draggableElement);
    const newPosition = {
      left: currentPosition.left + offset2.left,
      top: currentPosition.top + offset2.top
    };
    move(this._draggableElement, newPosition);
  }
};
var m_popup_drag_default = PopupDrag;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popup/m_popup_overflow_manager.js
var overflowManagerMock = {
  setOverflow: noop2,
  restoreOverflow: noop2
};
var createBodyOverflowManager = () => {
  if (!hasWindow()) {
    return overflowManagerMock;
  }
  const window26 = getWindow();
  const {
    documentElement
  } = dom_adapter_default.getDocument();
  const body = dom_adapter_default.getBody();
  const isIosDevice = "ios" === devices_default.real().platform;
  const prevSettings = {
    overflow: null,
    overflowX: null,
    overflowY: null,
    paddingRight: null,
    position: null,
    top: null,
    left: null
  };
  return {
    setOverflow: isIosDevice ? () => {
      if (isDefined(prevSettings.position) || "fixed" === body.style.position) {
        return;
      }
      const {
        scrollY,
        scrollX
      } = window26;
      prevSettings.position = body.style.position;
      prevSettings.top = body.style.top;
      prevSettings.left = body.style.left;
      body.style.setProperty("position", "fixed");
      body.style.setProperty("top", -scrollY + "px");
      body.style.setProperty("left", -scrollX + "px");
    } : () => {
      (() => {
        const scrollBarWidth = window26.innerWidth - documentElement.clientWidth;
        if (prevSettings.paddingRight || scrollBarWidth <= 0) {
          return;
        }
        const paddingRight = window26.getComputedStyle(body).getPropertyValue("padding-right");
        const computedBodyPaddingRight = parseInt(paddingRight, 10);
        prevSettings.paddingRight = computedBodyPaddingRight;
        body.style.setProperty("padding-right", `${computedBodyPaddingRight + scrollBarWidth}px`);
      })();
      if (prevSettings.overflow || "hidden" === body.style.overflow) {
        return;
      }
      prevSettings.overflow = body.style.overflow;
      prevSettings.overflowX = body.style.overflowX;
      prevSettings.overflowY = body.style.overflowY;
      body.style.setProperty("overflow", "hidden");
    },
    restoreOverflow: isIosDevice ? () => {
      if (!isDefined(prevSettings.position)) {
        return;
      }
      const scrollY = -parseInt(body.style.top, 10);
      const scrollX = -parseInt(body.style.left, 10);
      ["position", "top", "left"].forEach((property) => {
        if (prevSettings[property]) {
          body.style.setProperty(property, prevSettings[property]);
        } else {
          body.style.removeProperty(property);
        }
      });
      window26.scrollTo(scrollX, scrollY);
      prevSettings.position = null;
    } : () => {
      (() => {
        if (!isDefined(prevSettings.paddingRight)) {
          return;
        }
        if (prevSettings.paddingRight) {
          body.style.setProperty("padding-right", `${prevSettings.paddingRight}px`);
        } else {
          body.style.removeProperty("padding-right");
        }
        prevSettings.paddingRight = null;
      })();
      ["overflow", "overflowX", "overflowY"].forEach((property) => {
        if (!isDefined(prevSettings[property])) {
          return;
        }
        const propertyInKebabCase = property.replace(/(X)|(Y)/, (symbol) => `-${symbol.toLowerCase()}`);
        if (prevSettings[property]) {
          body.style.setProperty(propertyInKebabCase, prevSettings[property]);
        } else {
          body.style.removeProperty(propertyInKebabCase);
        }
        prevSettings[property] = null;
      });
    }
  };
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popup/m_popup_position_controller.js
var _excluded14 = ["fullScreen", "forceApplyBindings", "dragOutsideBoundary", "dragAndResizeArea", "outsideDragFactor"];
var window19 = getWindow();
var PopupPositionController = class extends OverlayPositionController {
  constructor(_ref) {
    let {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    } = _ref, args = _objectWithoutPropertiesLoose(_ref, _excluded14);
    super(args);
    this._props = _extends({}, this._props, {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    });
    this._$dragResizeContainer = void 0;
    this._updateDragResizeContainer();
  }
  set fullScreen(fullScreen) {
    this._props.fullScreen = fullScreen;
    if (fullScreen) {
      this._fullScreenEnabled();
    } else {
      this._fullScreenDisabled();
    }
  }
  get $dragResizeContainer() {
    return this._$dragResizeContainer;
  }
  get outsideDragFactor() {
    if (this._props.dragOutsideBoundary) {
      return 1;
    }
    return this._props.outsideDragFactor;
  }
  set dragAndResizeArea(dragAndResizeArea) {
    this._props.dragAndResizeArea = dragAndResizeArea;
    this._updateDragResizeContainer();
  }
  set dragOutsideBoundary(dragOutsideBoundary) {
    this._props.dragOutsideBoundary = dragOutsideBoundary;
    this._updateDragResizeContainer();
  }
  set outsideDragFactor(outsideDragFactor) {
    this._props.outsideDragFactor = outsideDragFactor;
  }
  updateContainer(containerProp) {
    super.updateContainer(containerProp);
    this._updateDragResizeContainer();
  }
  dragHandled() {
    this.restorePositionOnNextRender(false);
  }
  resizeHandled() {
    this.restorePositionOnNextRender(false);
  }
  positionContent() {
    if (this._props.fullScreen) {
      move(this._$content, {
        top: 0,
        left: 0
      });
      this.detectVisualPositionChange();
    } else {
      var _this$_props$forceApp, _this$_props;
      null === (_this$_props$forceApp = (_this$_props = this._props).forceApplyBindings) || void 0 === _this$_props$forceApp || _this$_props$forceApp.call(_this$_props);
      super.positionContent();
    }
  }
  _updateDragResizeContainer() {
    this._$dragResizeContainer = this._getDragResizeContainer();
  }
  _getDragResizeContainer() {
    if (this._props.dragOutsideBoundary) {
      return renderer_default(window19);
    }
    if (this._props.dragAndResizeArea) {
      return renderer_default(this._props.dragAndResizeArea);
    }
    const isContainerDefined = originalViewPort().get(0) || this._props.container;
    return isContainerDefined ? this._$markupContainer : renderer_default(window19);
  }
  _getVisualContainer() {
    if (this._props.fullScreen) {
      return renderer_default(window19);
    }
    return super._getVisualContainer();
  }
  _fullScreenEnabled() {
    this.restorePositionOnNextRender(false);
  }
  _fullScreenDisabled() {
    this.restorePositionOnNextRender(true);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popup/m_popup.js
var window20 = getWindow();
var ALLOWED_TOOLBAR_ITEM_ALIASES = ["cancel", "clear", "done"];
var IS_OLD_SAFARI = browser_default.safari && compare(browser_default.version, [11]) < 0;
var HEIGHT_STRATEGIES = {
  static: "",
  inherit: "dx-popup-inherit-height",
  flex: "dx-popup-flex-height"
};
var getButtonPlace = (name2) => {
  const device = devices_default.current();
  const {
    platform
  } = device;
  let toolbar = "bottom";
  let location = "before";
  if ("ios" === platform) {
    switch (name2) {
      case "cancel":
        toolbar = "top";
        break;
      case "clear":
        toolbar = "top";
        location = "after";
        break;
      case "done":
        location = "after";
    }
  } else if ("android" === platform) {
    switch (name2) {
      case "cancel":
      case "done":
        location = "after";
    }
  }
  return {
    toolbar,
    location
  };
};
var Popup = ui_overlay_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), {
      upArrow: (e) => {
        var _this$_drag;
        null === (_this$_drag = this._drag) || void 0 === _this$_drag || _this$_drag.moveUp(e);
      },
      downArrow: (e) => {
        var _this$_drag2;
        null === (_this$_drag2 = this._drag) || void 0 === _this$_drag2 || _this$_drag2.moveDown(e);
      },
      leftArrow: (e) => {
        var _this$_drag3;
        null === (_this$_drag3 = this._drag) || void 0 === _this$_drag3 || _this$_drag3.moveLeft(e);
      },
      rightArrow: (e) => {
        var _this$_drag4;
        null === (_this$_drag4 = this._drag) || void 0 === _this$_drag4 || _this$_drag4.moveRight(e);
      }
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      fullScreen: false,
      title: "",
      showTitle: true,
      titleTemplate: "title",
      onTitleRendered: null,
      dragOutsideBoundary: false,
      dragEnabled: false,
      dragAndResizeArea: void 0,
      enableBodyScroll: true,
      outsideDragFactor: 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      resizeEnabled: false,
      toolbarItems: [],
      showCloseButton: false,
      bottomTemplate: "bottom",
      useDefaultToolbarButtons: false,
      useFlatToolbarButtons: false,
      autoResizeEnabled: true
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: {
        platform: "ios"
      },
      options: {
        animation: this._iosAnimation
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        animation: this._androidAnimation
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        showCloseButton: true
      }
    }, {
      device: (device) => "desktop" === devices_default.real().deviceType && "generic" === device.platform,
      options: {
        dragEnabled: true
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useFlatToolbarButtons: true
      }
    }, {
      device: () => isMaterial(),
      options: {
        useDefaultToolbarButtons: true,
        showCloseButton: false
      }
    }]);
  },
  _iosAnimation: {
    show: {
      type: "slide",
      duration: 400,
      from: {
        position: {
          my: "top",
          at: "bottom"
        }
      },
      to: {
        position: {
          my: "center",
          at: "center"
        }
      }
    },
    hide: {
      type: "slide",
      duration: 400,
      from: {
        opacity: 1,
        position: {
          my: "center",
          at: "center"
        }
      },
      to: {
        opacity: 1,
        position: {
          my: "top",
          at: "bottom"
        }
      }
    }
  },
  _androidAnimation() {
    return this.option("fullScreen") ? {
      show: {
        type: "slide",
        duration: 300,
        from: {
          top: "30%",
          opacity: 0
        },
        to: {
          top: 0,
          opacity: 1
        }
      },
      hide: {
        type: "slide",
        duration: 300,
        from: {
          top: 0,
          opacity: 1
        },
        to: {
          top: "30%",
          opacity: 0
        }
      }
    } : {
      show: {
        type: "fade",
        duration: 400,
        from: 0,
        to: 1
      },
      hide: {
        type: "fade",
        duration: 400,
        from: 1,
        to: 0
      }
    };
  },
  _init() {
    const popupWrapperClassExternal = this.option("_wrapperClassExternal");
    const popupWrapperClasses = popupWrapperClassExternal ? `dx-popup-wrapper ${popupWrapperClassExternal}` : "dx-popup-wrapper";
    this.callBase();
    this._createBodyOverflowManager();
    this._updateResizeCallbackSkipCondition();
    this.$element().addClass("dx-popup");
    this.$wrapper().addClass(popupWrapperClasses);
    this._$popupContent = this._$content.wrapInner(renderer_default("<div>").addClass("dx-popup-content")).children().eq(0);
    this._toggleContentScrollClass();
    this.$overlayContent().attr("role", "dialog");
  },
  _render() {
    const isFullscreen = this.option("fullScreen");
    this._toggleFullScreenClass(isFullscreen);
    this.callBase();
  },
  _createBodyOverflowManager() {
    this._bodyOverflowManager = createBodyOverflowManager();
  },
  _toggleFullScreenClass(value2) {
    this.$overlayContent().toggleClass("dx-popup-fullscreen", value2).toggleClass("dx-popup-normal", !value2);
  },
  _initTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      title: new EmptyTemplate(),
      bottom: new EmptyTemplate()
    });
  },
  _getActionsList() {
    return this.callBase().concat(["onResizeStart", "onResize", "onResizeEnd"]);
  },
  _contentResizeHandler(entry) {
    if (!this._shouldSkipContentResize(entry)) {
      this._renderGeometry({
        shouldOnlyReposition: true
      });
    }
  },
  _doesShowAnimationChangeDimensions() {
    const animation3 = this.option("animation");
    return ["to", "from"].some((prop) => {
      var _animation$show;
      const config3 = null === animation3 || void 0 === animation3 || null === (_animation$show = animation3.show) || void 0 === _animation$show ? void 0 : _animation$show[prop];
      return isObject(config3) && ("width" in config3 || "height" in config3);
    });
  },
  _updateResizeCallbackSkipCondition() {
    const doesShowAnimationChangeDimensions = this._doesShowAnimationChangeDimensions();
    this._shouldSkipContentResize = (entry) => doesShowAnimationChangeDimensions && this._showAnimationProcessing || this._areContentDimensionsRendered(entry);
  },
  _observeContentResize(shouldObserve) {
    if (!this.option("useResizeObserver")) {
      return;
    }
    const contentElement = this._$content.get(0);
    if (shouldObserve) {
      resize_observer_default.observe(contentElement, (entry) => {
        this._contentResizeHandler(entry);
      });
    } else {
      resize_observer_default.unobserve(contentElement);
    }
  },
  _areContentDimensionsRendered(entry) {
    var _entry$contentBoxSize, _this$_renderedDimens3, _this$_renderedDimens4;
    const contentBox = null === (_entry$contentBoxSize = entry.contentBoxSize) || void 0 === _entry$contentBoxSize ? void 0 : _entry$contentBoxSize[0];
    if (contentBox) {
      var _this$_renderedDimens, _this$_renderedDimens2;
      return parseInt(contentBox.inlineSize, 10) === (null === (_this$_renderedDimens = this._renderedDimensions) || void 0 === _this$_renderedDimens ? void 0 : _this$_renderedDimens.width) && parseInt(contentBox.blockSize, 10) === (null === (_this$_renderedDimens2 = this._renderedDimensions) || void 0 === _this$_renderedDimens2 ? void 0 : _this$_renderedDimens2.height);
    }
    const {
      contentRect
    } = entry;
    return parseInt(contentRect.width, 10) === (null === (_this$_renderedDimens3 = this._renderedDimensions) || void 0 === _this$_renderedDimens3 ? void 0 : _this$_renderedDimens3.width) && parseInt(contentRect.height, 10) === (null === (_this$_renderedDimens4 = this._renderedDimensions) || void 0 === _this$_renderedDimens4 ? void 0 : _this$_renderedDimens4.height);
  },
  _renderContent() {
    this.callBase();
    this._observeContentResize(true);
  },
  _renderContentImpl() {
    this._renderTitle();
    this.callBase();
    this._renderResize();
    this._renderBottom();
  },
  _renderTitle() {
    const items = this._getToolbarItems("top");
    const {
      title,
      showTitle
    } = this.option();
    if (showTitle && !!title) {
      items.unshift({
        location: devices_default.current().ios ? "center" : "before",
        text: title
      });
    }
    if (showTitle || items.length > 0) {
      this._$title && this._$title.remove();
      const $title = renderer_default("<div>").addClass("dx-popup-title").insertBefore(this.$content());
      this._$title = this._renderTemplateByType("titleTemplate", items, $title).addClass("dx-popup-title");
      this._renderDrag();
      this._executeTitleRenderAction(this._$title);
      this._$title.toggleClass("dx-has-close-button", this._hasCloseButton());
    } else if (this._$title) {
      this._$title.detach();
    }
    this._toggleAriaLabel();
  },
  _toggleAriaLabel() {
    var _this$_$title;
    const {
      title,
      showTitle
    } = this.option();
    const shouldSetAriaLabel = showTitle && !!title;
    const titleId = shouldSetAriaLabel ? new guid_default() : null;
    null === (_this$_$title = this._$title) || void 0 === _this$_$title || _this$_$title.find(".dx-toolbar-label").eq(0).attr("id", titleId);
    this.$overlayContent().attr("aria-labelledby", titleId);
  },
  _renderTemplateByType(optionName, data2, $container, additionalToolbarOptions) {
    const {
      rtlEnabled,
      useDefaultToolbarButtons,
      useFlatToolbarButtons,
      disabled
    } = this.option();
    const template = this._getTemplateByOption(optionName);
    const toolbarTemplate = template instanceof EmptyTemplate;
    if (toolbarTemplate) {
      const integrationOptions = extend({}, this.option("integrationOptions"), {
        skipTemplates: ["content", "title"]
      });
      const toolbarOptions = extend(additionalToolbarOptions, {
        items: data2,
        rtlEnabled,
        useDefaultButtons: useDefaultToolbarButtons,
        useFlatButtons: useFlatToolbarButtons,
        disabled,
        integrationOptions
      });
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: {
          widget: this._getToolbarName(),
          options: toolbarOptions
        }
      });
      const $toolbar = $container.children("div");
      $container.replaceWith($toolbar);
      return $toolbar;
    }
    const $result = renderer_default(template.render({
      container: getPublicElement($container)
    }));
    if ($result.hasClass("dx-template-wrapper")) {
      $container.replaceWith($result);
      $container = $result;
    }
    return $container;
  },
  _getToolbarName: () => "dxToolbarBase",
  _renderVisibilityAnimate(visible2) {
    return this.callBase(visible2);
  },
  _hide() {
    this._observeContentResize(false);
    return this.callBase();
  },
  _executeTitleRenderAction($titleElement) {
    this._getTitleRenderAction()({
      titleElement: getPublicElement($titleElement)
    });
  },
  _getTitleRenderAction() {
    return this._titleRenderAction || this._createTitleRenderAction();
  },
  _createTitleRenderAction() {
    return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _getCloseButton() {
    return {
      toolbar: "top",
      location: "after",
      template: this._getCloseButtonRenderer()
    };
  },
  _getCloseButtonRenderer() {
    return (_, __, container) => {
      const $button = renderer_default("<div>").addClass("dx-closebutton");
      this._createComponent($button, button_default, {
        icon: "close",
        onClick: this._createToolbarItemAction(void 0),
        stylingMode: "text",
        integrationOptions: {}
      });
      renderer_default(container).append($button);
    };
  },
  _getToolbarItems(toolbar) {
    const toolbarItems = this.option("toolbarItems");
    const toolbarsItems = [];
    this._toolbarItemClasses = [];
    const currentPlatform = devices_default.current().platform;
    let index2 = 0;
    each(toolbarItems, (_, data2) => {
      const isShortcut = isDefined(data2.shortcut);
      const item = isShortcut ? getButtonPlace(data2.shortcut) : data2;
      if (isShortcut && "ios" === currentPlatform && index2 < 2) {
        item.toolbar = "top";
        index2++;
      }
      item.toolbar = data2.toolbar || item.toolbar || "top";
      if (item && item.toolbar === toolbar) {
        if (isShortcut) {
          extend(item, {
            location: data2.location
          }, this._getToolbarItemByAlias(data2));
        }
        const isLTROrder = "generic" === currentPlatform;
        if ("done" === data2.shortcut && isLTROrder || "cancel" === data2.shortcut && !isLTROrder) {
          toolbarsItems.unshift(item);
        } else {
          toolbarsItems.push(item);
        }
      }
    });
    if ("top" === toolbar && this._hasCloseButton()) {
      toolbarsItems.push(this._getCloseButton());
    }
    return toolbarsItems;
  },
  _hasCloseButton() {
    return this.option("showCloseButton") && this.option("showTitle");
  },
  _getLocalizationKey: (itemType) => "done" === itemType.toLowerCase() ? "OK" : camelize(itemType, true),
  _getToolbarButtonStylingMode(shortcut) {
    if (isFluent()) {
      return "done" === shortcut ? "contained" : "outlined";
    }
    return this.option("useFlatToolbarButtons") ? "text" : "contained";
  },
  _getToolbarButtonType(shortcut) {
    if (isFluent() && "done" === shortcut || this.option("useDefaultToolbarButtons")) {
      return "default";
    }
    return "normal";
  },
  _getToolbarItemByAlias(data2) {
    const that = this;
    const itemType = data2.shortcut;
    if (!ALLOWED_TOOLBAR_ITEM_ALIASES.includes(itemType)) {
      return false;
    }
    const itemConfig = extend({
      text: message_default.format(this._getLocalizationKey(itemType)),
      onClick: this._createToolbarItemAction(data2.onClick),
      integrationOptions: {},
      type: this._getToolbarButtonType(itemType),
      stylingMode: this._getToolbarButtonStylingMode(itemType)
    }, data2.options || {});
    const itemClass = `dx-popup-${itemType}`;
    this._toolbarItemClasses.push(itemClass);
    return {
      template(_, __, container) {
        const $toolbarItem = renderer_default("<div>").addClass(itemClass).appendTo(container);
        that._createComponent($toolbarItem, button_default, itemConfig);
      }
    };
  },
  _createToolbarItemAction(clickAction) {
    return this._createAction(clickAction, {
      afterExecute(e) {
        e.component.hide();
      }
    });
  },
  _renderBottom() {
    const items = this._getToolbarItems("bottom");
    if (items.length) {
      this._$bottom && this._$bottom.remove();
      const $bottom = renderer_default("<div>").addClass("dx-popup-bottom").insertAfter(this.$content());
      this._$bottom = this._renderTemplateByType("bottomTemplate", items, $bottom, {
        compactMode: true
      }).addClass("dx-popup-bottom");
      this._toggleClasses();
    } else {
      this._$bottom && this._$bottom.detach();
    }
  },
  _toggleDisabledState(value2) {
    this.callBase(...arguments);
    this.$content().toggleClass("dx-state-disabled", Boolean(value2));
  },
  _toggleClasses() {
    const aliases = ALLOWED_TOOLBAR_ITEM_ALIASES;
    each(aliases, (_, alias) => {
      const className = `dx-popup-${alias}`;
      if (this._toolbarItemClasses.includes(className)) {
        this.$wrapper().addClass(`${className}-visible`);
        this._$bottom.addClass(className);
      } else {
        this.$wrapper().removeClass(`${className}-visible`);
        this._$bottom.removeClass(className);
      }
    });
  },
  _toggleFocusClass(isFocused, $element) {
    this.callBase(isFocused, $element);
    if (isFocused && !isLastZIndexInStack(this._zIndex)) {
      const zIndex = create(this._zIndexInitValue());
      remove(this._zIndex);
      this._zIndex = zIndex;
      this._$wrapper.css("zIndex", zIndex);
      this._$content.css("zIndex", zIndex);
    }
  },
  _toggleContentScrollClass() {
    const isNativeScrollingEnabled = !this.option("preventScrollEvents");
    this.$content().toggleClass("dx-popup-content-scrollable", isNativeScrollingEnabled);
  },
  _getPositionControllerConfig() {
    const {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    } = this.option();
    return extend({}, this.callBase(), {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    });
  },
  _initPositionController() {
    this._positionController = new PopupPositionController(this._getPositionControllerConfig());
  },
  _getDragTarget() {
    return this.topToolbar();
  },
  _renderGeometry(options2) {
    const {
      visible: visible2,
      useResizeObserver
    } = this.option();
    if (visible2 && hasWindow()) {
      const isAnimated = this._showAnimationProcessing;
      const shouldRepeatAnimation = isAnimated && !(null !== options2 && void 0 !== options2 && options2.forceStopAnimation) && useResizeObserver;
      this._isAnimationPaused = shouldRepeatAnimation || void 0;
      this._stopAnimation();
      if (null !== options2 && void 0 !== options2 && options2.shouldOnlyReposition) {
        this._renderPosition(false);
      } else {
        this._renderGeometryImpl(null === options2 || void 0 === options2 ? void 0 : options2.isDimensionChange);
      }
      if (shouldRepeatAnimation) {
        this._animateShowing();
        this._isAnimationPaused = void 0;
      }
    }
  },
  _cacheDimensions() {
    if (!this.option("useResizeObserver")) {
      return;
    }
    this._renderedDimensions = {
      width: parseInt(getWidth(this._$content), 10),
      height: parseInt(getHeight(this._$content), 10)
    };
  },
  _renderGeometryImpl() {
    let isDimensionChange = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    if (!isDimensionChange) {
      this._resetContentHeight();
    }
    this.callBase();
    this._cacheDimensions();
    this._setContentHeight();
  },
  _resetContentHeight() {
    const height = this._getOptionValue("height");
    if ("auto" === height) {
      this.$content().css({
        height: "auto",
        maxHeight: "none"
      });
    }
  },
  _renderDrag() {
    const $dragTarget = this._getDragTarget();
    const dragEnabled = this.option("dragEnabled");
    if (!$dragTarget) {
      return;
    }
    const config3 = {
      dragEnabled,
      handle: $dragTarget.get(0),
      draggableElement: this._$content.get(0),
      positionController: this._positionController
    };
    if (this._drag) {
      this._drag.init(config3);
    } else {
      this._drag = new m_popup_drag_default(config3);
    }
    this.$overlayContent().toggleClass("dx-popup-draggable", dragEnabled);
  },
  _renderResize() {
    this._resizable = this._createComponent(this._$content, resizable_default, {
      handles: this.option("resizeEnabled") ? "all" : "none",
      onResizeEnd: (e) => {
        this._resizeEndHandler(e);
        this._observeContentResize(true);
      },
      onResize: (e) => {
        this._setContentHeight();
        this._actions.onResize(e);
      },
      onResizeStart: (e) => {
        this._observeContentResize(false);
        this._actions.onResizeStart(e);
      },
      minHeight: 100,
      minWidth: 100,
      area: this._positionController.$dragResizeContainer,
      keepAspectRatio: false
    });
  },
  _resizeEndHandler(e) {
    const width = this._resizable.option("width");
    const height = this._resizable.option("height");
    width && this._setOptionWithoutOptionChange("width", width);
    height && this._setOptionWithoutOptionChange("height", height);
    this._cacheDimensions();
    this._positionController.resizeHandled();
    this._positionController.detectVisualPositionChange(e.event);
    this._actions.onResizeEnd(e);
  },
  _setContentHeight() {
    (this.option("forceApplyBindings") || noop2)();
    const overlayContent = this.$overlayContent().get(0);
    const currentHeightStrategyClass = this._chooseHeightStrategy(overlayContent);
    this.$content().css(this._getHeightCssStyles(currentHeightStrategyClass, overlayContent));
    this._setHeightClasses(this.$overlayContent(), currentHeightStrategyClass);
  },
  _heightStrategyChangeOffset: (currentHeightStrategyClass, popupVerticalPaddings) => currentHeightStrategyClass === HEIGHT_STRATEGIES.flex ? -popupVerticalPaddings : 0,
  _chooseHeightStrategy(overlayContent) {
    const isAutoWidth = "auto" === overlayContent.style.width || "" === overlayContent.style.width;
    let currentHeightStrategyClass = HEIGHT_STRATEGIES.static;
    if (this._isAutoHeight() && this.option("autoResizeEnabled")) {
      if (isAutoWidth || IS_OLD_SAFARI) {
        currentHeightStrategyClass = HEIGHT_STRATEGIES.inherit;
      } else {
        currentHeightStrategyClass = HEIGHT_STRATEGIES.flex;
      }
    }
    return currentHeightStrategyClass;
  },
  _getHeightCssStyles(currentHeightStrategyClass, overlayContent) {
    let cssStyles = {};
    const contentMaxHeight = this._getOptionValue("maxHeight", overlayContent);
    const contentMinHeight = this._getOptionValue("minHeight", overlayContent);
    const popupHeightParts = this._splitPopupHeight();
    const toolbarsAndVerticalOffsetsHeight = popupHeightParts.header + popupHeightParts.footer + popupHeightParts.contentVerticalOffsets + popupHeightParts.popupVerticalOffsets + this._heightStrategyChangeOffset(currentHeightStrategyClass, popupHeightParts.popupVerticalPaddings);
    if (currentHeightStrategyClass === HEIGHT_STRATEGIES.static) {
      if (!this._isAutoHeight() || contentMaxHeight || contentMinHeight) {
        const overlayHeight = this.option("fullScreen") ? Math.min(getBoundingRect(overlayContent).height, getWindow().innerHeight) : getBoundingRect(overlayContent).height;
        const contentHeight = overlayHeight - toolbarsAndVerticalOffsetsHeight;
        cssStyles = {
          height: Math.max(0, contentHeight),
          minHeight: "auto",
          maxHeight: "auto"
        };
      }
    } else {
      const container = renderer_default(this._positionController.$visualContainer).get(0);
      const maxHeightValue = addOffsetToMaxHeight(contentMaxHeight, -toolbarsAndVerticalOffsetsHeight, container);
      const minHeightValue = addOffsetToMinHeight(contentMinHeight, -toolbarsAndVerticalOffsetsHeight, container);
      cssStyles = {
        height: "auto",
        minHeight: minHeightValue,
        maxHeight: maxHeightValue
      };
    }
    return cssStyles;
  },
  _setHeightClasses($container, currentClass) {
    let excessClasses = "";
    for (const name2 in HEIGHT_STRATEGIES) {
      if (HEIGHT_STRATEGIES[name2] !== currentClass) {
        excessClasses += ` ${HEIGHT_STRATEGIES[name2]}`;
      }
    }
    $container.removeClass(excessClasses).addClass(currentClass);
  },
  _isAutoHeight() {
    return "auto" === this.$overlayContent().get(0).style.height;
  },
  _splitPopupHeight() {
    const topToolbar = this.topToolbar();
    const bottomToolbar = this.bottomToolbar();
    return {
      header: getVisibleHeight(topToolbar && topToolbar.get(0)),
      footer: getVisibleHeight(bottomToolbar && bottomToolbar.get(0)),
      contentVerticalOffsets: getVerticalOffsets(this.$overlayContent().get(0), true),
      popupVerticalOffsets: getVerticalOffsets(this.$content().get(0), true),
      popupVerticalPaddings: getVerticalOffsets(this.$content().get(0), false)
    };
  },
  _isAllWindowCovered() {
    return this.callBase() || this.option("fullScreen");
  },
  _renderDimensions() {
    if (this.option("fullScreen")) {
      this.$overlayContent().css({
        width: "100%",
        height: "100%",
        minWidth: "",
        maxWidth: "",
        minHeight: "",
        maxHeight: ""
      });
    } else {
      this.callBase();
    }
    if (hasWindow()) {
      this._renderFullscreenWidthClass();
    }
  },
  _dimensionChanged() {
    this._renderGeometry({
      isDimensionChange: true
    });
  },
  _clean() {
    this.callBase();
    this._observeContentResize(false);
  },
  _dispose() {
    this.callBase();
    this._toggleBodyScroll(true);
  },
  _renderFullscreenWidthClass() {
    this.$overlayContent().toggleClass("dx-popup-fullscreen-width", getOuterWidth(this.$overlayContent()) === getWidth(window20));
  },
  _toggleSafariScrolling() {
    if (!this.option("enableBodyScroll")) {
      return;
    }
    this.callBase();
  },
  _toggleBodyScroll(enabled) {
    if (!this._bodyOverflowManager) {
      return;
    }
    const {
      setOverflow,
      restoreOverflow
    } = this._bodyOverflowManager;
    if (enabled) {
      restoreOverflow();
    } else {
      setOverflow();
    }
  },
  refreshPosition() {
    this._renderPosition();
  },
  _optionChanged(args) {
    var _this$_resizable2;
    const {
      value: value2,
      name: name2
    } = args;
    switch (name2) {
      case "disabled":
        this.callBase(args);
        this._renderTitle();
        this._renderBottom();
        break;
      case "animation":
        this._updateResizeCallbackSkipCondition();
        break;
      case "enableBodyScroll":
        if (this.option("visible")) {
          this._toggleBodyScroll(value2);
        }
        break;
      case "showTitle":
      case "title":
      case "titleTemplate":
        this._renderTitle();
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "bottomTemplate":
        this._renderBottom();
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "container":
        this.callBase(args);
        if (this.option("resizeEnabled")) {
          var _this$_resizable;
          null === (_this$_resizable = this._resizable) || void 0 === _this$_resizable || _this$_resizable.option("area", this._positionController.$dragResizeContainer);
        }
        break;
      case "width":
      case "height":
        this.callBase(args);
        null === (_this$_resizable2 = this._resizable) || void 0 === _this$_resizable2 || _this$_resizable2.option(name2, value2);
        break;
      case "onTitleRendered":
        this._createTitleRenderAction(value2);
        break;
      case "toolbarItems":
      case "useDefaultToolbarButtons":
      case "useFlatToolbarButtons": {
        const shouldRenderGeometry = !args.fullName.match(/^toolbarItems((\[\d+\])(\.(options|visible).*)?)?$/);
        this._renderTitle();
        this._renderBottom();
        if (shouldRenderGeometry) {
          this._renderGeometry();
          triggerResizeEvent(this.$overlayContent());
        }
        break;
      }
      case "dragEnabled":
        this._renderDrag();
        break;
      case "dragAndResizeArea":
        this._positionController.dragAndResizeArea = value2;
        if (this.option("resizeEnabled")) {
          this._resizable.option("area", this._positionController.$dragResizeContainer);
        }
        this._positionController.positionContent();
        break;
      case "dragOutsideBoundary":
        this._positionController.dragOutsideBoundary = value2;
        if (this.option("resizeEnabled")) {
          this._resizable.option("area", this._positionController.$dragResizeContainer);
        }
        break;
      case "outsideDragFactor":
        this._positionController.outsideDragFactor = value2;
        break;
      case "resizeEnabled":
        this._renderResize();
        this._renderGeometry();
        break;
      case "autoResizeEnabled":
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "fullScreen":
        this._positionController.fullScreen = value2;
        this._toggleFullScreenClass(value2);
        this._toggleSafariScrolling();
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "showCloseButton":
        this._renderTitle();
        break;
      case "preventScrollEvents":
        this.callBase(args);
        this._toggleContentScrollClass();
        break;
      default:
        this.callBase(args);
    }
  },
  bottomToolbar() {
    return this._$bottom;
  },
  topToolbar() {
    return this._$title;
  },
  $content() {
    return this._$popupContent;
  },
  content() {
    return getPublicElement(this.$content());
  },
  $overlayContent() {
    return this._$content;
  },
  getFocusableElements() {
    return this.$wrapper().find("[tabindex]").filter((index2, item) => item.getAttribute("tabindex") >= 0);
  }
});
component_registrator_default("dxPopup", Popup);
var m_popup_default = Popup;

// ../../../../../../node_modules/devextreme/esm/ui/popup/ui.popup.js
var ui_popup_default = m_popup_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_button.js
var DROP_DOWN_EDITOR_BUTTON_VISIBLE = "dx-dropdowneditor-button-visible";
var BUTTON_MESSAGE = "dxDropDownEditor-selectLabel";
var DropDownButton = class extends TextEditorButton {
  constructor(name2, editor, options2) {
    super(name2, editor, options2);
    this.currentTemplate = null;
  }
  _attachEvents(instance) {
    const {
      editor
    } = this;
    instance.option("onClick", (e) => {
      var _editor$_shouldCallOp;
      if (null !== (_editor$_shouldCallOp = editor._shouldCallOpenHandler) && void 0 !== _editor$_shouldCallOp && _editor$_shouldCallOp.call(editor)) {
        editor._openHandler(e);
        return;
      }
      !editor.option("openOnFieldClick") && editor._openHandler(e);
    });
    events_engine_default.on(instance.$element(), "mousedown", (e) => {
      if (editor.$element().is(".dx-state-focused")) {
        e.preventDefault();
      }
    });
  }
  _create() {
    const {
      editor
    } = this;
    const $element = renderer_default("<div>");
    const options2 = this._getOptions();
    this._addToContainer($element);
    const instance = editor._createComponent($element, button_default, extend({}, options2, {
      elementAttr: {
        "aria-label": message_default.format(BUTTON_MESSAGE)
      }
    }));
    this._legacyRender(editor.$element(), $element, options2.visible);
    return {
      $element,
      instance
    };
  }
  _getOptions() {
    const {
      editor
    } = this;
    const visible2 = this._isVisible();
    const isReadOnly = editor.option("readOnly");
    const options2 = {
      focusStateEnabled: false,
      hoverStateEnabled: false,
      activeStateEnabled: false,
      useInkRipple: false,
      disabled: isReadOnly,
      visible: visible2
    };
    this._addTemplate(options2);
    return options2;
  }
  _isVisible() {
    const {
      editor
    } = this;
    return super._isVisible() && editor.option("showDropDownButton");
  }
  _legacyRender($editor, $element, isVisible2) {
    $editor.toggleClass(DROP_DOWN_EDITOR_BUTTON_VISIBLE, isVisible2);
    if ($element) {
      $element.removeClass("dx-button").removeClass("dx-button-mode-contained").addClass("dx-dropdowneditor-button");
    }
  }
  _isSameTemplate() {
    return this.editor.option("dropDownButtonTemplate") === this.currentTemplate;
  }
  _addTemplate(options2) {
    if (!this._isSameTemplate()) {
      options2.template = this.editor._getTemplateByOption("dropDownButtonTemplate");
      this.currentTemplate = this.editor.option("dropDownButtonTemplate");
    }
  }
  update() {
    const shouldUpdate = super.update();
    if (shouldUpdate) {
      const {
        editor,
        instance
      } = this;
      const $editor = editor.$element();
      const options2 = this._getOptions();
      null === instance || void 0 === instance || instance.option(options2);
      this._legacyRender($editor, null === instance || void 0 === instance ? void 0 : instance.$element(), options2.visible);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_utils.js
var getElementWidth = function($element) {
  if (hasWindow()) {
    return getOuterWidth($element);
  }
};
var getSizeValue = function(size) {
  if (null === size) {
    size = void 0;
  }
  if ("function" === typeof size) {
    size = size();
  }
  return size;
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_editor.js
var DROP_DOWN_EDITOR_INPUT_WRAPPER = "dx-dropdowneditor-input-wrapper";
var DROP_DOWN_EDITOR_OVERLAY = "dx-dropdowneditor-overlay";
var DROP_DOWN_EDITOR_OVERLAY_FLIPPED = "dx-dropdowneditor-overlay-flipped";
var DROP_DOWN_EDITOR_ACTIVE = "dx-dropdowneditor-active";
var DROP_DOWN_EDITOR_FIELD_CLICKABLE = "dx-dropdowneditor-field-clickable";
var DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER = "dx-dropdowneditor-field-template-wrapper";
var isIOs = "ios" === devices_default.current().platform;
var DropDownEditor = text_box_default2.inherit({
  _supportedKeys() {
    return extend({}, this.callBase(), {
      tab(e) {
        if (!this.option("opened")) {
          return;
        }
        if (!this._popup.getFocusableElements().length) {
          this.close();
          return;
        }
        const $focusableElement = e.shiftKey ? this._getLastPopupElement() : this._getFirstPopupElement();
        if ($focusableElement) {
          events_engine_default.trigger($focusableElement, "focus");
          $focusableElement.select();
        }
        e.preventDefault();
      },
      escape(e) {
        if (this.option("opened")) {
          e.preventDefault();
        }
        this.close();
        return true;
      },
      upArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          if (e.altKey) {
            this.close();
            return false;
          }
        }
        return true;
      },
      downArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          if (e.altKey) {
            this._validatedOpening();
            return false;
          }
        }
        return true;
      },
      enter(e) {
        if (this.option("opened")) {
          e.preventDefault();
          this._valueChangeEventHandler(e);
        }
        return true;
      }
    });
  },
  _getDefaultButtons() {
    return this.callBase().concat([{
      name: "dropDown",
      Ctor: DropDownButton
    }]);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: null,
      onOpened: null,
      onClosed: null,
      opened: false,
      acceptCustomValue: true,
      applyValueMode: "instantly",
      deferRendering: true,
      activeStateEnabled: true,
      dropDownButtonTemplate: "dropDownButton",
      fieldTemplate: null,
      openOnFieldClick: false,
      showDropDownButton: true,
      buttons: void 0,
      dropDownOptions: {
        showTitle: false
      },
      popupPosition: this._getDefaultPopupPosition(),
      onPopupInitialized: null,
      applyButtonText: message_default.format("OK"),
      cancelButtonText: message_default.format("Cancel"),
      buttonsLocation: "default",
      useHiddenSubmitElement: false,
      validationMessagePosition: "auto"
    });
  },
  _useTemplates: () => true,
  _getDefaultPopupPosition(isRtlEnabled) {
    const position3 = getDefaultAlignment(isRtlEnabled);
    return {
      offset: {
        h: 0,
        v: -1
      },
      my: `${position3} top`,
      at: `${position3} bottom`,
      collision: "flip flip"
    };
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device(device) {
        const isGeneric2 = "generic" === device.platform;
        return isGeneric2;
      },
      options: {
        popupPosition: {
          offset: {
            v: 0
          }
        }
      }
    }]);
  },
  _inputWrapper() {
    return this.$element().find(`.${DROP_DOWN_EDITOR_INPUT_WRAPPER}`).first();
  },
  _init() {
    this.callBase();
    this._initVisibilityActions();
    this._initPopupInitializedAction();
    this._updatePopupPosition(this.option("rtlEnabled"));
    this._options.cache("dropDownOptions", this.option("dropDownOptions"));
  },
  _updatePopupPosition(isRtlEnabled) {
    const {
      my,
      at
    } = this._getDefaultPopupPosition(isRtlEnabled);
    const currentPosition = this.option("popupPosition");
    this.option("popupPosition", extend({}, currentPosition, {
      my,
      at
    }));
  },
  _initVisibilityActions() {
    this._openAction = this._createActionByOption("onOpened", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this._closeAction = this._createActionByOption("onClosed", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _initPopupInitializedAction() {
    this._popupInitializedAction = this._createActionByOption("onPopupInitialized", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _initMarkup() {
    this._renderSubmitElement();
    this.callBase();
    this.$element().addClass("dx-dropdowneditor");
    this.setAria("role", this._getAriaRole());
  },
  _render() {
    this.callBase();
    this._renderOpenHandler();
    this._attachFocusOutHandler();
    this._renderOpenedState();
  },
  _renderContentImpl() {
    if (!this.option("deferRendering")) {
      this._createPopup();
    }
  },
  _renderInput() {
    this.callBase();
    this._renderTemplateWrapper();
    this._wrapInput();
    this._setDefaultAria();
  },
  _wrapInput() {
    this._$container = this.$element().wrapInner(renderer_default("<div>").addClass(DROP_DOWN_EDITOR_INPUT_WRAPPER)).children().eq(0);
  },
  _getAriaHasPopup: () => "true",
  _getAriaAutocomplete: () => "none",
  _getAriaRole: () => "combobox",
  _setDefaultAria() {
    this.setAria({
      haspopup: this._getAriaHasPopup(),
      autocomplete: this._getAriaAutocomplete(),
      role: this._getAriaRole()
    });
  },
  _readOnlyPropValue() {
    return !this._isEditable() || this.callBase();
  },
  _cleanFocusState() {
    this.callBase();
    if (this.option("fieldTemplate")) {
      this._detachFocusEvents();
    }
  },
  _getFieldTemplate() {
    return this.option("fieldTemplate") && this._getTemplateByOption("fieldTemplate");
  },
  _renderMask() {
    if (this.option("fieldTemplate")) {
      return;
    }
    this.callBase();
  },
  _renderField() {
    const fieldTemplate = this._getFieldTemplate();
    fieldTemplate && this._renderTemplatedField(fieldTemplate, this._fieldRenderData());
  },
  _renderPlaceholder() {
    const hasFieldTemplate = !!this._getFieldTemplate();
    if (!hasFieldTemplate) {
      this.callBase();
    }
  },
  _renderValue() {
    if (this.option("useHiddenSubmitElement")) {
      this._setSubmitValue();
    }
    const promise = this.callBase();
    promise.always(this._renderField.bind(this));
  },
  _getButtonsContainer() {
    const fieldTemplate = this._getFieldTemplate();
    return fieldTemplate ? this._$container : this._$textEditorContainer;
  },
  _renderTemplateWrapper() {
    const fieldTemplate = this._getFieldTemplate();
    if (!fieldTemplate) {
      return;
    }
    if (!this._$templateWrapper) {
      this._$templateWrapper = renderer_default("<div>").addClass(DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER).prependTo(this.$element());
    }
  },
  _renderTemplatedField(fieldTemplate, data2) {
    const isFocused = focused(this._input());
    this._detachKeyboardEvents();
    this._detachFocusEvents();
    this._$textEditorContainer.remove();
    this._$templateWrapper.empty();
    const $templateWrapper = this._$templateWrapper;
    const currentRenderContext = Symbol("renderContext");
    this._activeRenderContext = currentRenderContext;
    fieldTemplate.render({
      model: data2,
      container: getPublicElement($templateWrapper),
      onRendered: () => {
        if (this._activeRenderContext !== currentRenderContext) {
          return;
        }
        const isRenderedInRoot = !!this.$element().find($templateWrapper).length;
        if (!isRenderedInRoot) {
          return;
        }
        const $input = this._input();
        if (!$input.length) {
          throw ui_errors_default.Error("E1010");
        }
        this._integrateInput();
        isFocused && events_engine_default.trigger($input, "focus");
      }
    });
  },
  _integrateInput() {
    var _this$option;
    const {
      isValid
    } = this.option();
    this._renderFocusState();
    this._refreshValueChangeEvent();
    this._refreshEvents();
    this._refreshEmptinessEvent();
    this._setDefaultAria();
    this._setFieldAria();
    this._toggleValidationClasses(!isValid);
    null === (_this$option = this.option("_onMarkupRendered")) || void 0 === _this$option || _this$option();
  },
  _refreshEmptinessEvent() {
    events_engine_default.off(this._input(), "input blur", this._toggleEmptinessEventHandler);
    this._renderEmptinessEvent();
  },
  _fieldRenderData() {
    return this.option("value");
  },
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      dropDownButton: new FunctionTemplate((options2) => {
        const $icon = renderer_default("<div>").addClass("dx-dropdowneditor-icon");
        renderer_default(options2.container).append($icon);
      })
    });
    this.callBase();
  },
  _renderOpenHandler() {
    const $inputWrapper = this._inputWrapper();
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const openOnFieldClick = this.option("openOnFieldClick");
    events_engine_default.off($inputWrapper, eventName);
    events_engine_default.on($inputWrapper, eventName, this._getInputClickHandler(openOnFieldClick));
    this.$element().toggleClass(DROP_DOWN_EDITOR_FIELD_CLICKABLE, openOnFieldClick);
    if (openOnFieldClick) {
      this._openOnFieldClickAction = this._createAction(this._openHandler.bind(this));
    }
  },
  _attachFocusOutHandler() {
    if (isIOs) {
      this._detachFocusOutEvents();
      events_engine_default.on(this._inputWrapper(), addNamespace2("focusout", this.NAME), (event) => {
        const newTarget = event.relatedTarget;
        if (newTarget && this.option("opened")) {
          const isNewTargetOutside = this._isTargetOutOfComponent(newTarget);
          if (isNewTargetOutside) {
            this.close();
          }
        }
      });
    }
  },
  _isTargetOutOfComponent(newTarget) {
    const popupWrapper = this.content ? renderer_default(this.content()).closest(`.${DROP_DOWN_EDITOR_OVERLAY}`) : this._$popup;
    const isTargetOutsidePopup = 0 === renderer_default(newTarget).closest(`.${DROP_DOWN_EDITOR_OVERLAY}`, popupWrapper).length;
    return isTargetOutsidePopup;
  },
  _detachFocusOutEvents() {
    isIOs && events_engine_default.off(this._inputWrapper(), addNamespace2("focusout", this.NAME));
  },
  _getInputClickHandler(openOnFieldClick) {
    return openOnFieldClick ? (e) => {
      this._executeOpenAction(e);
    } : () => {
      this._focusInput();
    };
  },
  _openHandler() {
    this._toggleOpenState();
  },
  _executeOpenAction(e) {
    this._openOnFieldClickAction({
      event: e
    });
  },
  _keyboardEventBindingTarget() {
    return this._input();
  },
  _focusInput() {
    if (this.option("disabled")) {
      return false;
    }
    if (this.option("focusStateEnabled") && !focused(this._input())) {
      this._resetCaretPosition();
      events_engine_default.trigger(this._input(), "focus");
    }
    return true;
  },
  _resetCaretPosition() {
    let ignoreEditable = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const inputElement = this._input().get(0);
    if (inputElement) {
      const {
        value: value2
      } = inputElement;
      const caretPosition = isDefined(value2) && (ignoreEditable || this._isEditable()) ? value2.length : 0;
      this._caret({
        start: caretPosition,
        end: caretPosition
      }, true);
    }
  },
  _isEditable() {
    return this.option("acceptCustomValue");
  },
  _toggleOpenState(isVisible2) {
    if (!this._focusInput()) {
      return;
    }
    if (!this.option("readOnly")) {
      isVisible2 = arguments.length ? isVisible2 : !this.option("opened");
      this.option("opened", isVisible2);
    }
  },
  _getControlsAria() {
    return this._popup && this._popupContentId;
  },
  _renderOpenedState() {
    const opened = this.option("opened");
    if (opened) {
      this._createPopup();
    }
    this.$element().toggleClass(DROP_DOWN_EDITOR_ACTIVE, opened);
    this._setPopupOption("visible", opened);
    const arias = {
      expanded: opened,
      controls: this._getControlsAria()
    };
    this.setAria(arias);
    this.setAria("owns", opened ? this._popupContentId : void 0, this.$element());
  },
  _createPopup() {
    if (this._$popup) {
      return;
    }
    this._$popup = renderer_default("<div>").addClass(DROP_DOWN_EDITOR_OVERLAY).appendTo(this.$element());
    this._renderPopup();
    this._renderPopupContent();
    this._setPopupAriaLabel();
  },
  _setPopupAriaLabel() {
    const $overlayContent = this._popup.$overlayContent();
    this.setAria("label", "Dropdown", $overlayContent);
  },
  _renderPopupContent: noop2,
  _renderPopup() {
    const popupConfig = extend(this._popupConfig(), this._options.cache("dropDownOptions"));
    delete popupConfig.closeOnOutsideClick;
    this._popup = this._createComponent(this._$popup, ui_popup_default, popupConfig);
    this._popup.on({
      showing: this._popupShowingHandler.bind(this),
      shown: this._popupShownHandler.bind(this),
      hiding: this._popupHidingHandler.bind(this),
      hidden: this._popupHiddenHandler.bind(this),
      contentReady: this._contentReadyHandler.bind(this)
    });
    this._attachPopupKeyHandler();
    this._contentReadyHandler();
    this._setPopupContentId(this._popup.$content());
    this._bindInnerWidgetOptions(this._popup, "dropDownOptions");
  },
  _attachPopupKeyHandler() {
    events_engine_default.on(this._popup.$overlayContent(), addNamespace2("keydown", this.NAME), (e) => this._popupKeyHandler(e));
  },
  _popupKeyHandler(e) {
    switch (normalizeKeyName(e)) {
      case "tab":
        this._popupTabHandler(e);
        break;
      case "escape":
        this._popupEscHandler(e);
    }
  },
  _popupTabHandler(e) {
    const $target = renderer_default(e.target);
    const moveBackward = e.shiftKey && $target.is(this._getFirstPopupElement());
    const moveForward = !e.shiftKey && $target.is(this._getLastPopupElement());
    if (moveForward || moveBackward) {
      events_engine_default.trigger(this.field(), "focus");
      e.preventDefault();
    }
  },
  _popupEscHandler() {
    events_engine_default.trigger(this._input(), "focus");
    this.close();
  },
  _setPopupContentId($popupContent) {
    this._popupContentId = `dx-${new guid_default()}`;
    this.setAria("id", this._popupContentId, $popupContent);
  },
  _contentReadyHandler: noop2,
  _popupConfig() {
    return {
      onInitialized: this._getPopupInitializedHandler(),
      position: extend(this.option("popupPosition"), {
        of: this.$element()
      }),
      showTitle: this.option("dropDownOptions.showTitle"),
      _ignoreFunctionValueDeprecation: true,
      width: () => getElementWidth(this.$element()),
      height: "auto",
      shading: false,
      hideOnParentScroll: true,
      hideOnOutsideClick: (e) => this._closeOutsideDropDownHandler(e),
      animation: {
        show: {
          type: "fade",
          duration: 0,
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          duration: 400,
          from: 1,
          to: 0
        }
      },
      deferRendering: false,
      focusStateEnabled: false,
      showCloseButton: false,
      dragEnabled: false,
      toolbarItems: this._getPopupToolbarItems(),
      onPositioned: this._popupPositionedHandler.bind(this),
      fullScreen: false,
      contentTemplate: null,
      _hideOnParentScrollTarget: this.$element(),
      _wrapperClassExternal: DROP_DOWN_EDITOR_OVERLAY,
      _ignorePreventScrollEventsDeprecation: true
    };
  },
  _popupInitializedHandler: noop2,
  _getPopupInitializedHandler() {
    const onPopupInitialized = this.option("onPopupInitialized");
    return (e) => {
      this._popupInitializedHandler(e);
      if (onPopupInitialized) {
        this._popupInitializedAction({
          popup: e.component
        });
      }
    };
  },
  _dimensionChanged() {
    if (hasWindow() && !this.$element().is(":visible")) {
      this.close();
      return;
    }
    this._updatePopupWidth();
  },
  _updatePopupWidth() {
    const popupWidth = getSizeValue(this.option("dropDownOptions.width"));
    if (void 0 === popupWidth) {
      this._setPopupOption("width", () => getElementWidth(this.$element()));
    }
  },
  _popupPositionedHandler(e) {
    var _e$position;
    const {
      labelMode,
      stylingMode
    } = this.option();
    if (!this._popup) {
      return;
    }
    const $popupOverlayContent = this._popup.$overlayContent();
    const isOverlayFlipped = null === (_e$position = e.position) || void 0 === _e$position || null === (_e$position = _e$position.v) || void 0 === _e$position ? void 0 : _e$position.flip;
    const shouldIndentForLabel = "hidden" !== labelMode && "outside" !== labelMode && "outlined" === stylingMode;
    if (e.position) {
      $popupOverlayContent.toggleClass(DROP_DOWN_EDITOR_OVERLAY_FLIPPED, isOverlayFlipped);
    }
    if (isOverlayFlipped && shouldIndentForLabel && this._label.isVisible()) {
      const $label = this._label.$element();
      move($popupOverlayContent, {
        top: locate($popupOverlayContent).top - parseInt($label.css("fontSize"))
      });
    }
  },
  _popupShowingHandler: noop2,
  _popupHidingHandler() {
    this.option("opened", false);
  },
  _popupShownHandler() {
    var _this$_validationMess;
    this._openAction();
    null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess || _this$_validationMess.option("positionSide", this._getValidationMessagePositionSide());
  },
  _popupHiddenHandler() {
    var _this$_validationMess2;
    this._closeAction();
    null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 || _this$_validationMess2.option("positionSide", this._getValidationMessagePositionSide());
  },
  _getValidationMessagePositionSide() {
    const validationMessagePosition = this.option("validationMessagePosition");
    if ("auto" !== validationMessagePosition) {
      return validationMessagePosition;
    }
    let positionSide = "bottom";
    if (this._popup && this._popup.option("visible")) {
      const {
        top: myTop
      } = position_default.setup(this.$element());
      const {
        top: popupTop
      } = position_default.setup(this._popup.$content());
      positionSide = myTop + this.option("popupPosition").offset.v > popupTop ? "bottom" : "top";
    }
    return positionSide;
  },
  _closeOutsideDropDownHandler(_ref) {
    let {
      target
    } = _ref;
    const $target = renderer_default(target);
    const dropDownButton = this.getButton("dropDown");
    const $dropDownButton = dropDownButton && dropDownButton.$element();
    const isInputClicked = !!$target.closest(this.$element()).length;
    const isDropDownButtonClicked = !!$target.closest($dropDownButton).length;
    const isOutsideClick = !isInputClicked && !isDropDownButtonClicked;
    return isOutsideClick;
  },
  _clean() {
    delete this._openOnFieldClickAction;
    delete this._$templateWrapper;
    if (this._$popup) {
      this._$popup.remove();
      delete this._$popup;
      delete this._popup;
    }
    this.callBase();
  },
  _setPopupOption(optionName, value2) {
    this._setWidgetOption("_popup", arguments);
  },
  _validatedOpening() {
    if (!this.option("readOnly")) {
      this._toggleOpenState(true);
    }
  },
  _getPopupToolbarItems() {
    return "useButtons" === this.option("applyValueMode") ? this._popupToolbarItemsConfig() : [];
  },
  _getFirstPopupElement() {
    return renderer_default(this._popup.getFocusableElements()).first();
  },
  _getLastPopupElement() {
    return renderer_default(this._popup.getFocusableElements()).last();
  },
  _popupToolbarItemsConfig() {
    const buttonsConfig = [{
      shortcut: "done",
      options: {
        onClick: this._applyButtonHandler.bind(this),
        text: this.option("applyButtonText")
      }
    }, {
      shortcut: "cancel",
      options: {
        onClick: this._cancelButtonHandler.bind(this),
        text: this.option("cancelButtonText")
      }
    }];
    return this._applyButtonsLocation(buttonsConfig);
  },
  _applyButtonsLocation(buttonsConfig) {
    const buttonsLocation = this.option("buttonsLocation");
    const resultConfig = buttonsConfig;
    if ("default" !== buttonsLocation) {
      const position3 = splitPair(buttonsLocation);
      each(resultConfig, (_, element) => {
        extend(element, {
          toolbar: position3[0],
          location: position3[1]
        });
      });
    }
    return resultConfig;
  },
  _applyButtonHandler() {
    this.close();
    this.option("focusStateEnabled") && this.focus();
  },
  _cancelButtonHandler() {
    this.close();
    this.option("focusStateEnabled") && this.focus();
  },
  _popupOptionChanged(args) {
    const options2 = ui_widget_default.getOptionsFromContainer(args);
    this._setPopupOption(options2);
    const optionsKeys = Object.keys(options2);
    if (optionsKeys.includes("width") || optionsKeys.includes("height")) {
      this._dimensionChanged();
    }
  },
  _renderSubmitElement() {
    if (this.option("useHiddenSubmitElement")) {
      this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    }
  },
  _setSubmitValue() {
    this._getSubmitElement().val(this.option("value"));
  },
  _getSubmitElement() {
    if (this.option("useHiddenSubmitElement")) {
      return this._$submitElement;
    }
    return this.callBase();
  },
  _dispose() {
    this._detachFocusOutEvents();
    this.callBase();
  },
  _optionChanged(args) {
    var _this$_popup;
    switch (args.name) {
      case "width":
      case "height":
        this.callBase(args);
        null === (_this$_popup = this._popup) || void 0 === _this$_popup || _this$_popup.repaint();
        break;
      case "opened":
        this._renderOpenedState();
        break;
      case "onOpened":
      case "onClosed":
        this._initVisibilityActions();
        break;
      case "onPopupInitialized":
        this._initPopupInitializedAction();
        break;
      case "fieldTemplate":
      case "acceptCustomValue":
      case "openOnFieldClick":
        this._invalidate();
        break;
      case "dropDownButtonTemplate":
      case "showDropDownButton":
        this._updateButtons(["dropDown"]);
        break;
      case "dropDownOptions":
        this._popupOptionChanged(args);
        this._options.cache("dropDownOptions", this.option("dropDownOptions"));
        break;
      case "popupPosition":
        break;
      case "deferRendering":
        if (hasWindow()) {
          this._createPopup();
        }
        break;
      case "applyValueMode":
      case "applyButtonText":
      case "cancelButtonText":
      case "buttonsLocation":
        this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
        break;
      case "useHiddenSubmitElement":
        if (this._$submitElement) {
          this._$submitElement.remove();
          this._$submitElement = void 0;
        }
        this._renderSubmitElement();
        break;
      case "rtlEnabled":
        this._updatePopupPosition(args.value);
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  },
  open() {
    this.option("opened", true);
  },
  close() {
    this.option("opened", false);
  },
  field() {
    return getPublicElement(this._input());
  },
  content() {
    return this._popup ? this._popup.content() : null;
  }
});
component_registrator_default("dxDropDownEditor", DropDownEditor);
var m_drop_down_editor_default = DropDownEditor;

// ../../../../../../node_modules/devextreme/esm/events/swipe.js
var SWIPE_START_EVENT = "dxswipestart";
var SWIPE_EVENT = "dxswipe";
var SWIPE_END_EVENT = "dxswipeend";
var HorizontalStrategy = {
  defaultItemSizeFunc: function() {
    return getWidth(this.getElement());
  },
  getBounds: function() {
    return [this._maxLeftOffset, this._maxRightOffset];
  },
  calcOffsetRatio: function(e) {
    const endEventData = eventData(e);
    return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe: function(e) {
    const endEventData = eventData(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time;
  }
};
var VerticalStrategy = {
  defaultItemSizeFunc: function() {
    return getHeight(this.getElement());
  },
  getBounds: function() {
    return [this._maxTopOffset, this._maxBottomOffset];
  },
  calcOffsetRatio: function(e) {
    const endEventData = eventData(e);
    return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe: function(e) {
    const endEventData = eventData(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time;
  }
};
var STRATEGIES = {
  horizontal: HorizontalStrategy,
  vertical: VerticalStrategy
};
var SwipeEmitter = emitter_gesture_default.inherit({
  TICK_INTERVAL: 300,
  FAST_SWIPE_SPEED_LIMIT: 10,
  ctor: function(element) {
    this.callBase(element);
    this.direction = "horizontal";
    this.elastic = true;
  },
  _getStrategy: function() {
    return STRATEGIES[this.direction];
  },
  _defaultItemSizeFunc: function() {
    return this._getStrategy().defaultItemSizeFunc.call(this);
  },
  _itemSizeFunc: function() {
    return this.itemSizeFunc || this._defaultItemSizeFunc;
  },
  _init: function(e) {
    this._tickData = eventData(e);
  },
  _start: function(e) {
    this._savedEventData = eventData(e);
    e = this._fireEvent("dxswipestart", e);
    if (!e.cancel) {
      this._maxLeftOffset = e.maxLeftOffset;
      this._maxRightOffset = e.maxRightOffset;
      this._maxTopOffset = e.maxTopOffset;
      this._maxBottomOffset = e.maxBottomOffset;
    }
  },
  _move: function(e) {
    const strategy4 = this._getStrategy();
    const moveEventData = eventData(e);
    let offset2 = strategy4.calcOffsetRatio.call(this, e);
    offset2 = this._fitOffset(offset2, this.elastic);
    if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
      this._tickData = moveEventData;
    }
    this._fireEvent("dxswipe", e, {
      offset: offset2
    });
    if (false !== e.cancelable) {
      e.preventDefault();
    }
  },
  _end: function(e) {
    const strategy4 = this._getStrategy();
    const offsetRatio = strategy4.calcOffsetRatio.call(this, e);
    const isFast = strategy4.isFastSwipe.call(this, e);
    let startOffset = offsetRatio;
    let targetOffset = this._calcTargetOffset(offsetRatio, isFast);
    startOffset = this._fitOffset(startOffset, this.elastic);
    targetOffset = this._fitOffset(targetOffset, false);
    this._fireEvent("dxswipeend", e, {
      offset: startOffset,
      targetOffset
    });
  },
  _fitOffset: function(offset2, elastic) {
    const strategy4 = this._getStrategy();
    const bounds = strategy4.getBounds.call(this);
    if (offset2 < -bounds[0]) {
      return elastic ? (-2 * bounds[0] + offset2) / 3 : -bounds[0];
    }
    if (offset2 > bounds[1]) {
      return elastic ? (2 * bounds[1] + offset2) / 3 : bounds[1];
    }
    return offset2;
  },
  _calcTargetOffset: function(offsetRatio, isFast) {
    let result2;
    if (isFast) {
      result2 = Math.ceil(Math.abs(offsetRatio));
      if (offsetRatio < 0) {
        result2 = -result2;
      }
    } else {
      result2 = Math.round(offsetRatio);
    }
    return result2;
  }
});
emitter_registrator_default({
  emitter: SwipeEmitter,
  events: ["dxswipestart", "dxswipe", "dxswipeend"]
});

// ../../../../../../node_modules/devextreme/esm/events/gesture/swipeable.js
var DX_SWIPEABLE = "dxSwipeable";
var ACTION_TO_EVENT_MAP = {
  onStart: SWIPE_START_EVENT,
  onUpdated: SWIPE_EVENT,
  onEnd: SWIPE_END_EVENT,
  onCancel: "dxswipecancel"
};
var Swipeable = dom_component_default.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      elastic: true,
      immediate: false,
      immediateTimeout: 180,
      direction: "horizontal",
      itemSizeFunc: null,
      onStart: null,
      onUpdated: null,
      onEnd: null,
      onCancel: null
    });
  },
  _render: function() {
    this.callBase();
    this.$element().addClass("dx-swipeable");
    this._attachEventHandlers();
  },
  _attachEventHandlers: function() {
    this._detachEventHandlers();
    if (this.option("disabled")) {
      return;
    }
    const NAME = this.NAME;
    this._createEventData();
    each(ACTION_TO_EVENT_MAP, (function(actionName, eventName) {
      const action = this._createActionByOption(actionName, {
        context: this
      });
      eventName = addNamespace2(eventName, NAME);
      events_engine_default.on(this.$element(), eventName, this._eventData, function(e) {
        return action({
          event: e
        });
      });
    }).bind(this));
  },
  _createEventData: function() {
    this._eventData = {
      elastic: this.option("elastic"),
      itemSizeFunc: this.option("itemSizeFunc"),
      direction: this.option("direction"),
      immediate: this.option("immediate"),
      immediateTimeout: this.option("immediateTimeout")
    };
  },
  _detachEventHandlers: function() {
    events_engine_default.off(this.$element(), ".dxSwipeable");
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "disabled":
      case "onStart":
      case "onUpdated":
      case "onEnd":
      case "onCancel":
      case "elastic":
      case "immediate":
      case "itemSizeFunc":
      case "direction":
        this._detachEventHandlers();
        this._attachEventHandlers();
        break;
      case "rtlEnabled":
        break;
      default:
        this.callBase(args);
    }
  },
  _useTemplates: function() {
    return false;
  }
});
getName(Swipeable, DX_SWIPEABLE);
var swipeable_default = Swipeable;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.selection.strategy.js
var CalendarSelectionStrategy = class {
  constructor(component) {
    this.calendar = component;
  }
  dateOption(optionName) {
    return this.calendar._dateOption(optionName);
  }
  dateValue(value2, e) {
    this.calendar._dateValue(value2, e);
  }
  skipNavigate() {
    this.calendar._skipNavigate = true;
  }
  updateAriaSelected(value2, previousValue) {
    this.calendar._updateAriaSelected(value2, previousValue);
    if (value2[0] && this.calendar.option("currentDate").getTime() === value2[0].getTime()) {
      this.calendar._updateAriaId(value2[0]);
    }
  }
  processValueChanged(value2, previousValue) {
    var _value, _previousValue;
    if (isDefined(value2) && !Array.isArray(value2)) {
      value2 = [value2];
    }
    if (isDefined(previousValue) && !Array.isArray(previousValue)) {
      previousValue = [previousValue];
    }
    value2 = (null === (_value = value2) || void 0 === _value ? void 0 : _value.map((item) => this._convertToDate(item))) || [];
    previousValue = (null === (_previousValue = previousValue) || void 0 === _previousValue ? void 0 : _previousValue.map((item) => this._convertToDate(item))) || [];
    this._updateViewsValue(value2);
    this.updateAriaSelected(value2, previousValue);
    if (!this._currentDateChanged) {
      this.calendar._initCurrentDate();
    }
    this._currentDateChanged = false;
  }
  _isDateDisabled(date) {
    const min = this.calendar._dateOption("min");
    const max = this.calendar._dateOption("max");
    const isLessThanMin = isDefined(min) && date < min && !date_default3.sameDate(min, date);
    const isBiggerThanMax = isDefined(max) && date > max && !date_default3.sameDate(max, date);
    return this.calendar._view.isDateDisabled(date) || isLessThanMin || isBiggerThanMax;
  }
  _getLowestDateInArray(dates) {
    if (dates.length) {
      return new Date(Math.min(...dates));
    }
  }
  _convertToDate(value2) {
    return this.calendar._convertToDate(value2);
  }
  _isMaxZoomLevel() {
    return this.calendar._isMaxZoomLevel();
  }
  _updateViewsOption(optionName, optionValue) {
    this.calendar._updateViewsOption(optionName, optionValue);
  }
  _updateViewsValue(value2) {
    this._updateViewsOption("value", value2);
  }
  _updateCurrentDate(value2) {
    this.calendar.option("currentDate", value2 ?? /* @__PURE__ */ new Date());
  }
  _shouldHandleWeekNumberClick() {
    const {
      selectionMode,
      selectWeekOnClick
    } = this.calendar.option();
    return selectWeekOnClick && "single" !== selectionMode;
  }
};
var m_calendar_selection_strategy_default = CalendarSelectionStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.multiple.selection.strategy.js
var CalendarMultiSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "MultiSelection";
  }
  getViewOptions() {
    return {
      value: this.dateOption("value"),
      range: [],
      selectionMode: "multiple",
      onWeekNumberClick: this._shouldHandleWeekNumberClick() ? this._weekNumberClickHandler.bind(this) : null
    };
  }
  selectValue(selectedValue, e) {
    const value2 = [...this.dateOption("value")];
    const alreadySelectedIndex = value2.findIndex((date) => (null === date || void 0 === date ? void 0 : date.toDateString()) === selectedValue.toDateString());
    if (alreadySelectedIndex > -1) {
      value2.splice(alreadySelectedIndex, 1);
    } else {
      value2.push(selectedValue);
    }
    this.skipNavigate();
    this._updateCurrentDate(selectedValue);
    this._currentDateChanged = true;
    this.dateValue(value2, e);
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = this.dateOption("value"));
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  getDefaultCurrentDate() {
    const dates = this.dateOption("value").filter((value2) => value2);
    return this._getLowestDateInArray(dates);
  }
  restoreValue() {
    this.calendar.option("value", []);
  }
  _weekNumberClickHandler(_ref) {
    let {
      rowDates,
      event
    } = _ref;
    const selectedDates = rowDates.filter((date) => !this._isDateDisabled(date));
    this.dateValue(selectedDates, event);
  }
};
var m_calendar_multiple_selection_strategy_default = CalendarMultiSelectionStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.navigator.js
var Navigator = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      onClick: void 0,
      onCaptionClick: void 0,
      type: "normal",
      stylingMode: "outlined",
      text: ""
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => isMaterial(),
      options: {
        type: "default",
        stylingMode: "text"
      }
    }, {
      device: () => isFluent(),
      options: {
        type: "normal",
        stylingMode: "text"
      }
    }]);
  }
  _init() {
    super._init();
    this._initActions();
  }
  _initActions() {
    this._clickAction = this._createActionByOption("onClick");
    this._captionClickAction = this._createActionByOption("onCaptionClick");
  }
  _initMarkup() {
    super._initMarkup();
    renderer_default(this.element()).addClass("dx-calendar-navigator");
    this._renderButtons();
    this._renderCaption();
  }
  _renderButtons() {
    const {
      rtlEnabled,
      type: type2,
      stylingMode,
      focusStateEnabled
    } = this.option();
    this._prevButton = this._createComponent(renderer_default("<div>"), button_default, {
      focusStateEnabled,
      icon: rtlEnabled ? "chevronright" : "chevronleft",
      onClick: (e) => {
        this._clickAction({
          direction: -1,
          event: e
        });
      },
      type: type2,
      stylingMode,
      integrationOptions: {}
    });
    const $prevButton = renderer_default(this._prevButton.element()).addClass("dx-calendar-navigator-previous-view").addClass("dx-calendar-navigator-previous-month");
    this._nextButton = this._createComponent(renderer_default("<div>"), button_default, {
      focusStateEnabled,
      icon: rtlEnabled ? "chevronleft" : "chevronright",
      onClick: (e) => {
        this._clickAction({
          direction: 1,
          event: e
        });
      },
      type: type2,
      stylingMode,
      integrationOptions: {}
    });
    const $nextButton = renderer_default(this._nextButton.element()).addClass("dx-calendar-navigator-next-view").addClass("dx-calendar-navigator-next-month");
    this._caption = this._createComponent(renderer_default("<div>").addClass("dx-calendar-caption-button"), button_default, {
      focusStateEnabled,
      onClick: (e) => {
        this._captionClickAction({
          event: e
        });
      },
      type: type2,
      stylingMode,
      template: (_, content) => {
        const {
          text
        } = this.option();
        const viewCaptionTexts = text.split(" - ");
        viewCaptionTexts.forEach((captionText) => {
          renderer_default(content).append(renderer_default("<span>").addClass("dx-button-text").text(captionText));
        });
      },
      integrationOptions: {}
    });
    const $caption = this._caption.$element();
    this.$element().append($prevButton, $caption, $nextButton);
  }
  _renderCaption() {
    var _this$_caption;
    null === (_this$_caption = this._caption) || void 0 === _this$_caption || _this$_caption.option("text", this.option("text"));
  }
  toggleButton(buttonPrefix, value2) {
    const buttonName = `_${buttonPrefix}Button`;
    const button = this[buttonName];
    if (button) {
      button.option("disabled", value2);
      button.$element().toggleClass("dx-calendar-disabled-navigator-link", value2);
    }
  }
  _optionChanged(args) {
    if ("text" === args.name) {
      this._renderCaption();
    } else {
      super._optionChanged(args);
    }
  }
};
var m_calendar_navigator_default = Navigator;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.range.selection.strategy.js
var CalendarRangeSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "RangeSelection";
  }
  getViewOptions() {
    const value2 = this._getValue();
    const range = this._getDaysInRange(value2[0], value2[1]);
    return {
      value: value2,
      range,
      selectionMode: "range",
      onCellHover: this._cellHoverHandler.bind(this),
      onWeekNumberClick: this._shouldHandleWeekNumberClick() ? this._weekNumberClickHandler.bind(this) : null
    };
  }
  selectValue(selectedValue, e) {
    const [startDate, endDate] = this._getValue();
    this.skipNavigate();
    this._updateCurrentDate(selectedValue);
    this._currentDateChanged = true;
    if (true === this.calendar.option("_allowChangeSelectionOrder")) {
      this.calendar._valueSelected = true;
      if ("startDate" === this.calendar.option("_currentSelection")) {
        if (this.calendar._convertToDate(selectedValue) > this.calendar._convertToDate(endDate)) {
          this.dateValue([selectedValue, null], e);
        } else {
          this.dateValue([selectedValue, endDate], e);
        }
      } else if (this.calendar._convertToDate(selectedValue) >= this.calendar._convertToDate(startDate)) {
        this.dateValue([startDate, selectedValue], e);
      } else {
        this.dateValue([selectedValue, null], e);
      }
    } else if (!startDate || endDate) {
      this.dateValue([selectedValue, null], e);
    } else {
      this.dateValue(startDate < selectedValue ? [startDate, selectedValue] : [selectedValue, startDate], e);
    }
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = this._getValue());
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  processValueChanged(value2, previousValue) {
    super.processValueChanged(value2, previousValue);
    const range = this._getRange();
    this._updateViewsOption("range", range);
  }
  getDefaultCurrentDate() {
    const {
      _allowChangeSelectionOrder,
      _currentSelection
    } = this.calendar.option();
    const value2 = this.dateOption("value");
    if (_allowChangeSelectionOrder) {
      if ("startDate" === _currentSelection && value2[0]) {
        return value2[0];
      }
      if ("endDate" === _currentSelection && value2[1]) {
        return value2[1];
      }
    }
    const dates = value2.filter((value3) => value3);
    return this._getLowestDateInArray(dates);
  }
  restoreValue() {
    this.calendar.option("value", [null, null]);
  }
  _getValue() {
    const value2 = this.dateOption("value");
    if (!value2.length) {
      return value2;
    }
    let [startDate, endDate] = value2;
    if (startDate && endDate && startDate > endDate) {
      [startDate, endDate] = [endDate, startDate];
    }
    return [startDate, endDate];
  }
  _getRange() {
    const [startDate, endDate] = this._getValue();
    return this._getDaysInRange(startDate, endDate);
  }
  _getDaysInRange(startDate, endDate) {
    if (!startDate || !endDate) {
      return [];
    }
    const {
      currentDate,
      viewsCount
    } = this.calendar.option();
    const isAdditionalViewDate = this.calendar._isAdditionalViewDate(currentDate);
    const firstDateInViews = date_default3.getFirstMonthDate(date_default3.addDateInterval(currentDate, "month", isAdditionalViewDate ? -2 : -1));
    const lastDateInViews = date_default3.getLastMonthDate(date_default3.addDateInterval(currentDate, "month", isAdditionalViewDate ? 1 : viewsCount));
    const rangeStartDate = new Date(Math.max(firstDateInViews, startDate));
    const rangeEndDate = new Date(Math.min(lastDateInViews, endDate));
    return [...date_default3.getDatesOfInterval(rangeStartDate, rangeEndDate, 864e5), rangeEndDate];
  }
  _cellHoverHandler(e) {
    const isMaxZoomLevel = this._isMaxZoomLevel();
    const [startDate, endDate] = this._getValue();
    const {
      _allowChangeSelectionOrder,
      _currentSelection
    } = this.calendar.option();
    if (isMaxZoomLevel) {
      const skipHoveredRange = _allowChangeSelectionOrder && "startDate" === _currentSelection;
      if (startDate && !endDate && !skipHoveredRange) {
        if (e.value > startDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(startDate, e.value));
          return;
        }
      } else if (!startDate && endDate && !(_allowChangeSelectionOrder && "endDate" === _currentSelection)) {
        if (e.value < endDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(e.value, endDate));
          return;
        }
      } else if (startDate && endDate) {
        if ("startDate" === _currentSelection && e.value < startDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(e.value, startDate));
          return;
        }
        if ("endDate" === _currentSelection && e.value > endDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(endDate, e.value));
          return;
        }
      }
      this._updateViewsOption("hoveredRange", []);
    }
  }
  _weekNumberClickHandler(_ref) {
    let {
      rowDates,
      event
    } = _ref;
    const selectedDates = rowDates.filter((date) => !this._isDateDisabled(date));
    const value2 = selectedDates.length ? [selectedDates[0], selectedDates[selectedDates.length - 1]] : [null, null];
    this.dateValue(value2, event);
  }
};
var m_calendar_range_selection_strategy_default = CalendarRangeSelectionStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.single.selection.strategy.js
var CalendarSingleSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "SingleSelection";
  }
  getViewOptions() {
    return {
      value: this.dateOption("value"),
      range: [],
      selectionMode: "single"
    };
  }
  selectValue(selectedValue, e) {
    this.skipNavigate();
    this.dateValue(selectedValue, e);
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = [this.dateOption("value")]);
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  getDefaultCurrentDate() {
    return this.dateOption("value");
  }
  restoreValue() {
    this.calendar.option("value", null);
  }
  _updateViewsValue(value2) {
    this._updateViewsOption("value", value2[0]);
  }
};
var m_calendar_single_selection_strategy_default = CalendarSingleSelectionStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.base_view.js
var {
  abstract: abstract6
} = ui_widget_default;
var NOT_WEEK_CELL_SELECTOR = "td:not(.dx-calendar-week-number-cell)";
var CALENDAR_DXCLICK_EVENT_NAME = addNamespace2(CLICK_EVENT_NAME, "dxCalendar");
var CALENDAR_DXHOVERSTART_EVENT_NAME = addNamespace2(HOVERSTART, "dxCalendar");
var CURRENT_DATE_TEXT = {
  month: message_default.format("dxCalendar-currentDay"),
  year: message_default.format("dxCalendar-currentMonth"),
  decade: message_default.format("dxCalendar-currentYear"),
  century: message_default.format("dxCalendar-currentYearRange")
};
var SELECTION_MODE = {
  single: "single",
  multiple: "multiple",
  range: "range"
};
var BaseView = ui_widget_default.inherit({
  _getViewName: () => "base",
  _getDefaultOptions() {
    return extend(this.callBase(), {
      date: /* @__PURE__ */ new Date(),
      focusStateEnabled: false,
      cellTemplate: null,
      disabledDates: null,
      onCellClick: null,
      onCellHover: null,
      onWeekNumberClick: null,
      rowCount: 3,
      colCount: 4,
      allowValueSelection: true,
      _todayDate: () => /* @__PURE__ */ new Date()
    });
  },
  _initMarkup() {
    this.callBase();
    this._renderImpl();
  },
  _renderImpl() {
    this.$element().append(this._createTable());
    this._createDisabledDatesHandler();
    this._renderBody();
    this._renderContouredDate();
    this._renderValue();
    this._renderRange();
    this._renderEvents();
    this._updateTableAriaLabel();
  },
  _getLocalizedWidgetName() {
    const localizedWidgetName = message_default.format("dxCalendar-ariaWidgetName");
    return localizedWidgetName;
  },
  _getSingleModeAriaLabel() {
    const {
      value: value2
    } = this.option();
    const localizedWidgetName = this._getLocalizedWidgetName();
    const formattedDate = date_default2.format(value2, "date");
    const selectedDatesText = message_default.format("dxCalendar-selectedDate", formattedDate);
    const ariaLabel = `${localizedWidgetName}. ${selectedDatesText}`;
    return ariaLabel;
  },
  _getRangeModeAriaLabel() {
    const {
      value: value2
    } = this.option();
    const localizedWidgetName = this._getLocalizedWidgetName();
    const [startDate, endDate] = value2;
    const formattedStartDate = date_default2.format(startDate, "date");
    const formattedEndDate = date_default2.format(endDate, "date");
    const selectedDatesText = startDate && endDate ? message_default.format("dxCalendar-selectedDateRange", formattedStartDate, formattedEndDate) : message_default.format("dxCalendar-selectedDate", formattedStartDate ?? formattedEndDate);
    const ariaLabel = `${localizedWidgetName}. ${selectedDatesText}`;
    return ariaLabel;
  },
  _getMultipleModeAriaLabel() {
    const ariaLabel = this._getLocalizedWidgetName();
    return ariaLabel;
  },
  _getTableAriaLabel() {
    const {
      value: value2,
      selectionMode
    } = this.option();
    const isValueEmpty = !value2 || Array.isArray(value2) && !value2.filter(Boolean).length;
    if (isValueEmpty) {
      return this._getLocalizedWidgetName();
    }
    switch (selectionMode) {
      case SELECTION_MODE.single:
        return this._getSingleModeAriaLabel();
      case SELECTION_MODE.range:
        return this._getRangeModeAriaLabel();
      case SELECTION_MODE.multiple:
        return this._getMultipleModeAriaLabel();
    }
  },
  _updateTableAriaLabel() {
    const label = this._getTableAriaLabel();
    this.setAria({
      label
    }, this._$table);
  },
  _createTable() {
    this._$table = renderer_default("<table>");
    this.setAria({
      role: "grid"
    }, this._$table);
    return this._$table;
  },
  _renderBody() {
    this.$body = renderer_default("<tbody>").appendTo(this._$table);
    const rowData = {
      cellDate: this._getFirstCellData(),
      prevCellDate: null
    };
    for (let rowIndex = 0, rowCount = this.option("rowCount"); rowIndex < rowCount; rowIndex++) {
      rowData.row = this._createRow();
      for (let colIndex = 0, colCount = this.option("colCount"); colIndex < colCount; colIndex++) {
        this._renderCell(rowData, colIndex);
      }
      this._renderWeekNumberCell(rowData);
    }
  },
  _createRow() {
    const row = dom_adapter_default.createElement("tr");
    this.setAria("role", "row", renderer_default(row));
    this.$body.get(0).appendChild(row);
    return row;
  },
  _createCell(cellDate, cellIndex) {
    const cell = dom_adapter_default.createElement("td");
    const $cell = renderer_default(cell);
    cell.className = this._getClassNameByDate(cellDate, cellIndex);
    cell.setAttribute("data-value", date_serialization_default.serializeDate(cellDate, date_default3.getShortDateFormat()));
    data(cell, "dxDateValueKey", cellDate);
    this.setAria({
      role: "gridcell",
      selected: false,
      label: this.getCellAriaLabel(cellDate)
    }, $cell);
    return {
      cell,
      $cell
    };
  },
  _renderCell(params, cellIndex) {
    const {
      cellDate,
      prevCellDate,
      row
    } = params;
    if (prevCellDate) {
      date_default3.fixTimezoneGap(prevCellDate, cellDate);
    }
    params.prevCellDate = cellDate;
    const {
      cell,
      $cell
    } = this._createCell(cellDate, cellIndex);
    const cellTemplate = this.option("cellTemplate");
    renderer_default(row).append(cell);
    if (cellTemplate) {
      cellTemplate.render(this._prepareCellTemplateData(cellDate, cellIndex, $cell));
    } else {
      cell.innerHTML = this._getCellText(cellDate);
    }
    params.cellDate = this._getNextCellData(cellDate);
  },
  _getClassNameByDate(cellDate, cellIndex) {
    let className = "dx-calendar-cell";
    if (this._isTodayCell(cellDate)) {
      className += " dx-calendar-today";
    }
    if (this._isDateOutOfRange(cellDate) || this.isDateDisabled(cellDate)) {
      className += " dx-calendar-empty-cell";
    }
    if (this._isOtherView(cellDate)) {
      className += " dx-calendar-other-view";
    }
    if (this.option("selectionMode") === SELECTION_MODE.range) {
      if (0 === cellIndex) {
        className += " dx-calendar-cell-start-in-row";
      }
      if (cellIndex === this.option("colCount") - 1) {
        className += " dx-calendar-cell-end-in-row";
      }
      if (this._isStartDayOfMonth(cellDate)) {
        className += " dx-calendar-cell-start";
      }
      if (this._isEndDayOfMonth(cellDate)) {
        className += " dx-calendar-cell-end";
      }
    }
    return className;
  },
  _prepareCellTemplateData(cellDate, cellIndex, $cell) {
    const isDateCell = cellDate instanceof Date;
    const text = isDateCell ? this._getCellText(cellDate) : cellDate;
    const date = isDateCell ? cellDate : void 0;
    const view = this._getViewName();
    return {
      model: {
        text,
        date,
        view
      },
      container: getPublicElement($cell),
      index: cellIndex
    };
  },
  _renderEvents() {
    this._createCellClickAction();
    events_engine_default.off(this._$table, CALENDAR_DXCLICK_EVENT_NAME);
    events_engine_default.on(this._$table, CALENDAR_DXCLICK_EVENT_NAME, NOT_WEEK_CELL_SELECTOR, (e) => {
      if (!renderer_default(e.currentTarget).hasClass("dx-calendar-empty-cell")) {
        this._cellClickAction({
          event: e,
          value: renderer_default(e.currentTarget).data("dxDateValueKey")
        });
      }
    });
    const {
      selectionMode
    } = this.option();
    events_engine_default.off(this._$table, CALENDAR_DXHOVERSTART_EVENT_NAME);
    if (selectionMode === SELECTION_MODE.range) {
      this._createCellHoverAction();
      events_engine_default.on(this._$table, CALENDAR_DXHOVERSTART_EVENT_NAME, NOT_WEEK_CELL_SELECTOR, (e) => {
        if (!renderer_default(e.currentTarget).hasClass("dx-calendar-empty-cell")) {
          this._cellHoverAction({
            event: e,
            value: renderer_default(e.currentTarget).data("dxDateValueKey")
          });
        }
      });
    }
    if (selectionMode !== SELECTION_MODE.single) {
      this._createWeekNumberCellClickAction();
      events_engine_default.on(this._$table, CALENDAR_DXCLICK_EVENT_NAME, ".dx-calendar-week-number-cell", (e) => {
        const $row = renderer_default(e.currentTarget).closest("tr");
        const firstDateInRow = $row.find(".dx-calendar-cell").first().data("dxDateValueKey");
        const lastDateInRow = $row.find(".dx-calendar-cell").last().data("dxDateValueKey");
        const rowDates = [...date_default3.getDatesOfInterval(firstDateInRow, lastDateInRow, 864e5), lastDateInRow];
        this._weekNumberCellClickAction({
          event: e,
          rowDates
        });
      });
    }
  },
  _createCellClickAction() {
    this._cellClickAction = this._createActionByOption("onCellClick");
  },
  _createCellHoverAction() {
    this._cellHoverAction = this._createActionByOption("onCellHover");
  },
  _createWeekNumberCellClickAction() {
    this._weekNumberCellClickAction = this._createActionByOption("onWeekNumberClick");
  },
  _createDisabledDatesHandler() {
    const disabledDates = this.option("disabledDates");
    this._disabledDatesHandler = Array.isArray(disabledDates) ? this._getDefaultDisabledDatesHandler(disabledDates) : disabledDates || noop2;
  },
  _getDefaultDisabledDatesHandler: () => noop2,
  _isTodayCell: abstract6,
  _isDateOutOfRange: abstract6,
  isDateDisabled(cellDate) {
    const dateParts = {
      date: cellDate,
      view: this._getViewName()
    };
    return this._disabledDatesHandler(dateParts);
  },
  _isOtherView: abstract6,
  _isStartDayOfMonth: abstract6,
  _isEndDayOfMonth: abstract6,
  _getCellText: abstract6,
  _getFirstCellData: abstract6,
  _getNextCellData: abstract6,
  _renderContouredDate(contouredDate) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    contouredDate = contouredDate || this.option("contouredDate");
    const $oldContouredCell = this._getContouredCell();
    const $newContouredCell = this._getCellByDate(contouredDate);
    $oldContouredCell.removeClass("dx-calendar-contoured-date");
    if (contouredDate) {
      $newContouredCell.addClass("dx-calendar-contoured-date");
    }
  },
  _getContouredCell() {
    return this._$table.find(".dx-calendar-contoured-date");
  },
  _renderValue() {
    if (!this.option("allowValueSelection")) {
      return;
    }
    let value2 = this.option("value");
    if (!Array.isArray(value2)) {
      value2 = [value2];
    }
    this._updateSelectedClass(value2);
  },
  _updateSelectedClass(value2) {
    var _this$_$selectedCells;
    if (this._isRangeMode() && !this._isMonthView()) {
      return;
    }
    null === (_this$_$selectedCells = this._$selectedCells) || void 0 === _this$_$selectedCells || _this$_$selectedCells.forEach(($cell) => {
      $cell.removeClass("dx-calendar-selected-date");
    });
    this._$selectedCells = value2.map((value3) => this._getCellByDate(value3));
    this._$selectedCells.forEach(($cell) => {
      $cell.addClass("dx-calendar-selected-date");
    });
  },
  _renderRange() {
    var _this$_$rangeCells, _this$_$hoveredRangeC, _this$_$rangeStartHov, _this$_$rangeEndHover, _this$_$rangeStartDat, _this$_$rangeEndDateC, _this$_$rangeStartDat2, _this$_$rangeEndDateC2;
    const {
      allowValueSelection,
      value: value2,
      range
    } = this.option();
    if (!allowValueSelection || !this._isRangeMode() || !this._isMonthView()) {
      return;
    }
    null === (_this$_$rangeCells = this._$rangeCells) || void 0 === _this$_$rangeCells || _this$_$rangeCells.forEach(($cell) => {
      $cell.removeClass("dx-calendar-cell-in-range");
    });
    null === (_this$_$hoveredRangeC = this._$hoveredRangeCells) || void 0 === _this$_$hoveredRangeC || _this$_$hoveredRangeC.forEach(($cell) => {
      $cell.removeClass("dx-calendar-cell-range-hover");
    });
    null === (_this$_$rangeStartHov = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov || _this$_$rangeStartHov.removeClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover || _this$_$rangeEndHover.removeClass("dx-calendar-cell-range-hover-end");
    null === (_this$_$rangeStartDat = this._$rangeStartDateCell) || void 0 === _this$_$rangeStartDat || _this$_$rangeStartDat.removeClass("dx-calendar-range-start-date");
    null === (_this$_$rangeEndDateC = this._$rangeEndDateCell) || void 0 === _this$_$rangeEndDateC || _this$_$rangeEndDateC.removeClass("dx-calendar-range-end-date");
    this._$rangeCells = range.map((value3) => this._getCellByDate(value3));
    this._$rangeStartDateCell = this._getCellByDate(value2[0]);
    this._$rangeEndDateCell = this._getCellByDate(value2[1]);
    this._$rangeCells.forEach(($cell) => {
      $cell.addClass("dx-calendar-cell-in-range");
    });
    null === (_this$_$rangeStartDat2 = this._$rangeStartDateCell) || void 0 === _this$_$rangeStartDat2 || _this$_$rangeStartDat2.addClass("dx-calendar-range-start-date");
    null === (_this$_$rangeEndDateC2 = this._$rangeEndDateCell) || void 0 === _this$_$rangeEndDateC2 || _this$_$rangeEndDateC2.addClass("dx-calendar-range-end-date");
  },
  _renderHoveredRange() {
    var _this$_$hoveredRangeC2, _this$_$rangeStartHov2, _this$_$rangeEndHover2, _this$_$rangeStartHov3, _this$_$rangeEndHover3;
    const {
      allowValueSelection,
      hoveredRange
    } = this.option();
    if (!allowValueSelection || !this._isRangeMode() || !this._isMonthView()) {
      return;
    }
    null === (_this$_$hoveredRangeC2 = this._$hoveredRangeCells) || void 0 === _this$_$hoveredRangeC2 || _this$_$hoveredRangeC2.forEach(($cell) => {
      $cell.removeClass("dx-calendar-cell-range-hover");
    });
    null === (_this$_$rangeStartHov2 = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov2 || _this$_$rangeStartHov2.removeClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover2 = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover2 || _this$_$rangeEndHover2.removeClass("dx-calendar-cell-range-hover-end");
    this._$hoveredRangeCells = hoveredRange.map((value2) => this._getCellByDate(value2));
    this._$rangeStartHoverCell = this._getCellByDate(hoveredRange[0]);
    this._$rangeEndHoverCell = this._getCellByDate(hoveredRange[hoveredRange.length - 1]);
    this._$hoveredRangeCells.forEach(($cell) => {
      $cell.addClass("dx-calendar-cell-range-hover");
    });
    null === (_this$_$rangeStartHov3 = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov3 || _this$_$rangeStartHov3.addClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover3 = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover3 || _this$_$rangeEndHover3.addClass("dx-calendar-cell-range-hover-end");
  },
  _isMonthView() {
    return "month" === this.option("zoomLevel");
  },
  _isRangeMode() {
    return this.option("selectionMode") === SELECTION_MODE.range;
  },
  _getCurrentDateFormat: () => null,
  getCellAriaLabel(date) {
    const viewName = this._getViewName();
    const isToday = this._isTodayCell(date);
    const format2 = this._getCurrentDateFormat();
    const dateRangeText = format2 ? date_default2.format(date, format2) : this._getCellText(date);
    const ariaLabel = isToday ? `${dateRangeText}. ${CURRENT_DATE_TEXT[viewName]}` : dateRangeText;
    return ariaLabel;
  },
  _getFirstAvailableDate() {
    let date = this.option("date");
    const min = this.option("min");
    date = date_default3.getViewFirstCellDate(this._getViewName(), date);
    return new Date(min && date < min ? min : date);
  },
  _getCellByDate: abstract6,
  isBoundary: abstract6,
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "value":
        this._renderValue();
        this._updateTableAriaLabel();
        break;
      case "range":
        this._renderRange();
        break;
      case "hoveredRange":
        this._renderHoveredRange();
        break;
      case "contouredDate":
        this._renderContouredDate(value2);
        break;
      case "onCellClick":
        this._createCellClickAction();
        break;
      case "onCellHover":
        this._createCellHoverAction();
        break;
      case "min":
      case "max":
      case "disabledDates":
      case "cellTemplate":
      case "selectionMode":
        this._invalidate();
        break;
      case "_todayDate":
        this._renderBody();
        break;
      default:
        this.callBase(args);
    }
  }
});
var m_calendar_base_view_default = BaseView;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.views.js
var Views = {
  month: m_calendar_base_view_default.inherit({
    _getViewName: () => "month",
    _getCurrentDateFormat: () => "longdate",
    _getDefaultOptions() {
      return extend(this.callBase(), {
        firstDayOfWeek: 0,
        rowCount: 6,
        colCount: 7
      });
    },
    _renderImpl() {
      this.callBase();
      this._renderHeader();
    },
    _renderBody() {
      this.callBase();
      this._$table.find(".dx-calendar-other-view").addClass("dx-calendar-other-month");
    },
    _renderFocusTarget: noop2,
    _renderHeader() {
      const $headerRow = renderer_default("<tr>");
      const $header = renderer_default("<thead>").append($headerRow);
      this._$table.prepend($header);
      for (let colIndex = 0, colCount = this.option("colCount"); colIndex < colCount; colIndex++) {
        this._renderHeaderCell(colIndex, $headerRow);
      }
      if (this.option("showWeekNumbers")) {
        this._renderWeekHeaderCell($headerRow);
      }
    },
    _renderHeaderCell(cellIndex, $headerRow) {
      const {
        firstDayOfWeek
      } = this.option();
      const {
        full: fullCaption,
        abbreviated: abbrCaption
      } = this._getDayCaption(firstDayOfWeek + cellIndex);
      const $cell = renderer_default("<th>").attr({
        scope: "col",
        abbr: fullCaption
      }).text(abbrCaption);
      $headerRow.append($cell);
    },
    _renderWeekHeaderCell($headerRow) {
      const $weekNumberHeaderCell = renderer_default("<th>").attr({
        scope: "col",
        abbr: "WeekNumber",
        class: "dx-week-number-header"
      });
      $headerRow.prepend($weekNumberHeaderCell);
    },
    _renderWeekNumberCell(rowData) {
      const {
        showWeekNumbers,
        cellTemplate,
        selectionMode,
        selectWeekOnClick
      } = this.option();
      if (!showWeekNumbers) {
        return;
      }
      const weekNumber = this._getWeekNumber(rowData.prevCellDate);
      const cell = dom_adapter_default.createElement("td");
      const $cell = renderer_default(cell);
      cell.className = "dx-calendar-week-number-cell";
      if ("single" !== selectionMode && selectWeekOnClick) {
        $cell.addClass("dx-calendar-week-selection");
      }
      if (cellTemplate) {
        cellTemplate.render(this._prepareCellTemplateData(weekNumber, -1, $cell));
      } else {
        cell.innerHTML = weekNumber;
      }
      rowData.row.prepend(cell);
      this.setAria({
        role: "gridcell",
        label: `Week ${weekNumber}`
      }, $cell);
    },
    _getWeekNumber(date) {
      const {
        weekNumberRule,
        firstDayOfWeek
      } = this.option();
      if ("auto" === weekNumberRule) {
        return date_default3.getWeekNumber(date, firstDayOfWeek, 1 === firstDayOfWeek ? "firstFourDays" : "firstDay");
      }
      return date_default3.getWeekNumber(date, firstDayOfWeek, weekNumberRule);
    },
    getNavigatorCaption() {
      return date_default2.format(this.option("date"), "monthandyear");
    },
    _isTodayCell(cellDate) {
      const today = this.option("_todayDate")();
      return date_default3.sameDate(cellDate, today);
    },
    _isDateOutOfRange(cellDate) {
      const minDate = this.option("min");
      const maxDate = this.option("max");
      return !date_default3.dateInRange(cellDate, minDate, maxDate, "date");
    },
    _isOtherView(cellDate) {
      return cellDate.getMonth() !== this.option("date").getMonth();
    },
    _isStartDayOfMonth(cellDate) {
      return date_default3.sameDate(cellDate, date_default3.getFirstMonthDate(this.option("date")));
    },
    _isEndDayOfMonth(cellDate) {
      return date_default3.sameDate(cellDate, date_default3.getLastMonthDate(this.option("date")));
    },
    _getCellText: (cellDate) => date_default2.format(cellDate, "d"),
    _getDayCaption(day) {
      const daysInWeek = this.option("colCount");
      const dayIndex = day % daysInWeek;
      return {
        full: date_default2.getDayNames()[dayIndex],
        abbreviated: date_default2.getDayNames("abbreviated")[dayIndex]
      };
    },
    _getFirstCellData() {
      const {
        firstDayOfWeek
      } = this.option();
      const firstDay = date_default3.getFirstMonthDate(this.option("date"));
      let firstMonthDayOffset = firstDayOfWeek - firstDay.getDay();
      const daysInWeek = this.option("colCount");
      if (firstMonthDayOffset >= 0) {
        firstMonthDayOffset -= daysInWeek;
      }
      firstDay.setDate(firstDay.getDate() + firstMonthDayOffset);
      return firstDay;
    },
    _getNextCellData(date) {
      date = new Date(date);
      date.setDate(date.getDate() + 1);
      return date;
    },
    _getCellByDate(date) {
      return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(date, date_default3.getShortDateFormat())}']`);
    },
    isBoundary(date) {
      return date_default3.sameMonthAndYear(date, this.option("min")) || date_default3.sameMonthAndYear(date, this.option("max"));
    },
    _getDefaultDisabledDatesHandler: (disabledDates) => function(args) {
      const isDisabledDate = disabledDates.some((item) => date_default3.sameDate(item, args.date));
      if (isDisabledDate) {
        return true;
      }
    }
  }),
  year: m_calendar_base_view_default.inherit({
    _getViewName: () => "year",
    _getCurrentDateFormat: () => "monthandyear",
    _isTodayCell(cellDate) {
      const today = this.option("_todayDate")();
      return date_default3.sameMonthAndYear(cellDate, today);
    },
    _isDateOutOfRange(cellDate) {
      return !date_default3.dateInRange(cellDate, date_default3.getFirstMonthDate(this.option("min")), date_default3.getLastMonthDate(this.option("max")));
    },
    _isOtherView: () => false,
    _isStartDayOfMonth: () => false,
    _isEndDayOfMonth: () => false,
    _getCellText: (cellDate) => date_default2.getMonthNames("abbreviated")[cellDate.getMonth()],
    _getFirstCellData() {
      const currentDate = this.option("date");
      const data2 = new Date(currentDate);
      data2.setDate(1);
      data2.setMonth(0);
      return data2;
    },
    _getNextCellData(date) {
      date = new Date(date);
      date.setMonth(date.getMonth() + 1);
      return date;
    },
    _getCellByDate(date) {
      const foundDate = new Date(date);
      foundDate.setDate(1);
      return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default3.getShortDateFormat())}']`);
    },
    getNavigatorCaption() {
      return date_default2.format(this.option("date"), "yyyy");
    },
    isBoundary(date) {
      return date_default3.sameYear(date, this.option("min")) || date_default3.sameYear(date, this.option("max"));
    },
    _renderWeekNumberCell: noop2
  }),
  decade: m_calendar_base_view_default.inherit({
    _getViewName: () => "decade",
    _isTodayCell(cellDate) {
      const today = this.option("_todayDate")();
      return date_default3.sameYear(cellDate, today);
    },
    _isDateOutOfRange(cellDate) {
      const min = this.option("min");
      const max = this.option("max");
      return !date_default3.dateInRange(cellDate.getFullYear(), min && min.getFullYear(), max && max.getFullYear());
    },
    _isOtherView(cellDate) {
      const date = new Date(cellDate);
      date.setMonth(1);
      return !date_default3.sameDecade(date, this.option("date"));
    },
    _isStartDayOfMonth: () => false,
    _isEndDayOfMonth: () => false,
    _getCellText: (cellDate) => date_default2.format(cellDate, "yyyy"),
    _getFirstCellData() {
      const year = date_default3.getFirstYearInDecade(this.option("date")) - 1;
      return date_default3.createDateWithFullYear(year, 0, 1);
    },
    _getNextCellData(date) {
      date = new Date(date);
      date.setFullYear(date.getFullYear() + 1);
      return date;
    },
    getNavigatorCaption() {
      const currentDate = this.option("date");
      const firstYearInDecade = date_default3.getFirstYearInDecade(currentDate);
      const startDate = new Date(currentDate);
      const endDate = new Date(currentDate);
      startDate.setFullYear(firstYearInDecade);
      endDate.setFullYear(firstYearInDecade + 9);
      return `${date_default2.format(startDate, "yyyy")}-${date_default2.format(endDate, "yyyy")}`;
    },
    _isValueOnCurrentView: (currentDate, value2) => date_default3.sameDecade(currentDate, value2),
    _getCellByDate(date) {
      const foundDate = new Date(date);
      foundDate.setDate(1);
      foundDate.setMonth(0);
      return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default3.getShortDateFormat())}']`);
    },
    isBoundary(date) {
      return date_default3.sameDecade(date, this.option("min")) || date_default3.sameDecade(date, this.option("max"));
    },
    _renderWeekNumberCell: noop2
  }),
  century: m_calendar_base_view_default.inherit({
    _getViewName: () => "century",
    _isTodayCell(cellDate) {
      const today = this.option("_todayDate")();
      return date_default3.sameDecade(cellDate, today);
    },
    _isDateOutOfRange(cellDate) {
      const decade = date_default3.getFirstYearInDecade(cellDate);
      const minDecade = date_default3.getFirstYearInDecade(this.option("min"));
      const maxDecade = date_default3.getFirstYearInDecade(this.option("max"));
      return !date_default3.dateInRange(decade, minDecade, maxDecade);
    },
    _isOtherView(cellDate) {
      const date = new Date(cellDate);
      date.setMonth(1);
      return !date_default3.sameCentury(date, this.option("date"));
    },
    _isStartDayOfMonth: () => false,
    _isEndDayOfMonth: () => false,
    _getCellText(cellDate) {
      const startDate = date_default2.format(cellDate, "yyyy");
      const endDate = new Date(cellDate);
      endDate.setFullYear(endDate.getFullYear() + 9);
      return `${startDate} - ${date_default2.format(endDate, "yyyy")}`;
    },
    _getFirstCellData() {
      const decade = date_default3.getFirstDecadeInCentury(this.option("date")) - 10;
      return date_default3.createDateWithFullYear(decade, 0, 1);
    },
    _getNextCellData(date) {
      date = new Date(date);
      date.setFullYear(date.getFullYear() + 10);
      return date;
    },
    _getCellByDate(date) {
      const foundDate = new Date(date);
      foundDate.setDate(1);
      foundDate.setMonth(0);
      foundDate.setFullYear(date_default3.getFirstYearInDecade(foundDate));
      return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default3.getShortDateFormat())}']`);
    },
    getNavigatorCaption() {
      const currentDate = this.option("date");
      const firstDecadeInCentury = date_default3.getFirstDecadeInCentury(currentDate);
      const startDate = new Date(currentDate);
      const endDate = new Date(currentDate);
      startDate.setFullYear(firstDecadeInCentury);
      endDate.setFullYear(firstDecadeInCentury + 99);
      return `${date_default2.format(startDate, "yyyy")}-${date_default2.format(endDate, "yyyy")}`;
    },
    isBoundary(date) {
      return date_default3.sameCentury(date, this.option("min")) || date_default3.sameCentury(date, this.option("max"));
    },
    _renderWeekNumberCell: noop2
  })
};
var m_calendar_views_default = Views;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.js
var CALENDAR_DXHOVEREND_EVENT_NAME = addNamespace2(HOVEREND, "dxCalendar");
var LEVEL_COMPARE_MAP = {
  month: 3,
  year: 2,
  decade: 1,
  century: 0
};
var ZOOM_LEVEL = {
  MONTH: "month",
  YEAR: "year",
  DECADE: "decade",
  CENTURY: "century"
};
var SELECTION_STRATEGIES = {
  SingleSelection: m_calendar_single_selection_strategy_default,
  MultipleSelection: m_calendar_multiple_selection_strategy_default,
  RangeSelection: m_calendar_range_selection_strategy_default
};
var Calendar = editor_default.inherit({
  _activeStateUnit: ".dx-calendar-cell",
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      currentDate: /* @__PURE__ */ new Date(),
      value: null,
      dateSerializationFormat: void 0,
      min: new Date(1e3, 0),
      max: new Date(3e3, 0),
      firstDayOfWeek: void 0,
      viewsCount: 1,
      zoomLevel: ZOOM_LEVEL.MONTH,
      maxZoomLevel: ZOOM_LEVEL.MONTH,
      minZoomLevel: ZOOM_LEVEL.CENTURY,
      selectionMode: "single",
      selectWeekOnClick: true,
      showTodayButton: false,
      showWeekNumbers: false,
      weekNumberRule: "auto",
      cellTemplate: "cell",
      disabledDates: null,
      onCellClick: null,
      onContouredChanged: null,
      skipFocusCheck: false,
      _todayDate: () => /* @__PURE__ */ new Date()
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  },
  _supportedKeys() {
    return extend(this.callBase(), {
      rightArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._waitRenderView(1);
        } else {
          this._moveCurrentDateByOffset(1 * this._getRtlCorrection());
        }
      },
      leftArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._waitRenderView(-1);
        } else {
          this._moveCurrentDateByOffset(-1 * this._getRtlCorrection());
        }
      },
      upArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._navigateUp();
        } else {
          if (fx_default.isAnimating(this._view.$element())) {
            return;
          }
          this._moveCurrentDateByOffset(-1 * this._view.option("colCount"));
        }
      },
      downArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._navigateDown();
        } else {
          if (fx_default.isAnimating(this._view.$element())) {
            return;
          }
          this._moveCurrentDateByOffset(1 * this._view.option("colCount"));
        }
      },
      home(e) {
        e.preventDefault();
        const zoomLevel = this.option("zoomLevel");
        const currentDate = this.option("currentDate");
        const min = this._dateOption("min");
        if (this._view.isDateDisabled(currentDate)) {
          return;
        }
        const date = date_default3.sameView(zoomLevel, currentDate, min) ? min : date_default3.getViewFirstCellDate(zoomLevel, currentDate);
        this._moveToClosestAvailableDate(date);
      },
      end(e) {
        e.preventDefault();
        const zoomLevel = this.option("zoomLevel");
        const currentDate = this.option("currentDate");
        const max = this._dateOption("max");
        if (this._view.isDateDisabled(currentDate)) {
          return;
        }
        const date = date_default3.sameView(zoomLevel, currentDate, max) ? max : date_default3.getViewLastCellDate(zoomLevel, currentDate);
        this._moveToClosestAvailableDate(date);
      },
      pageUp(e) {
        e.preventDefault();
        this._waitRenderView(-1 * this._getRtlCorrection());
      },
      pageDown(e) {
        e.preventDefault();
        this._waitRenderView(1 * this._getRtlCorrection());
      },
      tab: noop2,
      enter: this._enterKeyHandler
    });
  },
  _enterKeyHandler(e) {
    if (!this._isMaxZoomLevel()) {
      this._navigateDown();
    } else if (!this._view.isDateDisabled(this.option("currentDate"))) {
      const value2 = this._updateTimeComponent(this.option("currentDate"));
      this._selectionStrategy.selectValue(value2, e);
    }
  },
  _getSerializationFormat(optionName) {
    const value2 = this.option(optionName || "value");
    if (this.option("dateSerializationFormat")) {
      return this.option("dateSerializationFormat");
    }
    if (isNumeric(value2)) {
      return "number";
    }
    if (!isString(value2)) {
      return;
    }
    return date_serialization_default.getDateSerializationFormat(value2);
  },
  _convertToDate: (value2) => date_serialization_default.deserializeDate(value2),
  _dateValue(value2, event) {
    if (event) {
      if ("keydown" === event.type) {
        const cellElement = this._view._getContouredCell().get(0);
        event.target = cellElement;
      }
      this._saveValueChangeEvent(event);
    }
    this._dateOption("value", value2);
  },
  _dateOption(optionName, optionValue) {
    const isArray2 = "value" === optionName && !this._isSingleMode();
    const value2 = this.option("value");
    if (1 === arguments.length) {
      return isArray2 ? (value2 ?? []).map((value3) => this._convertToDate(value3)) : this._convertToDate(this.option(optionName));
    }
    const serializationFormat = this._getSerializationFormat(optionName);
    const serializedValue = isArray2 ? (null === optionValue || void 0 === optionValue ? void 0 : optionValue.map((value3) => date_serialization_default.serializeDate(value3, serializationFormat))) || [] : date_serialization_default.serializeDate(optionValue, serializationFormat);
    this.option(optionName, serializedValue);
  },
  _isSingleMode() {
    return "single" === this.option("selectionMode");
  },
  _shiftDate(zoomLevel, date, offset2, reverse) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        date.setDate(date.getDate() + offset2 * reverse);
        break;
      case ZOOM_LEVEL.YEAR:
        date.setMonth(date.getMonth() + offset2 * reverse);
        break;
      case ZOOM_LEVEL.DECADE:
        date.setFullYear(date.getFullYear() + offset2 * reverse);
        break;
      case ZOOM_LEVEL.CENTURY:
        date.setFullYear(date.getFullYear() + 10 * offset2 * reverse);
    }
  },
  _moveCurrentDateByOffset(offset2) {
    const baseDate = this.option("currentDate");
    let currentDate = new Date(baseDate);
    const zoomLevel = this.option("zoomLevel");
    this._shiftDate(zoomLevel, currentDate, offset2, 1);
    const maxDate = this._getMaxDate();
    const minDate = this._getMinDate();
    let isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, currentDate, baseDate);
    let isDateForwardInRange = inRange(currentDate, minDate, maxDate) && isDateForwardInNeighborView;
    const dateForward = new Date(currentDate);
    while (isDateForwardInRange) {
      if (!this._view.isDateDisabled(dateForward)) {
        currentDate = dateForward;
        break;
      }
      this._shiftDate(zoomLevel, dateForward, offset2, 1);
      isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, dateForward, baseDate);
      isDateForwardInRange = inRange(dateForward, minDate, maxDate) && isDateForwardInNeighborView;
    }
    if (this._view.isDateDisabled(baseDate) || this._view.isDateDisabled(currentDate)) {
      const direction = offset2 > 0 ? 1 : -1;
      const isViewDisabled = 1 === direction ? this._isNextViewDisabled() : this._isPrevViewDisabled();
      if (!isViewDisabled) {
        this._waitRenderView(direction);
      } else {
        this._moveToClosestAvailableDate(currentDate);
      }
    } else {
      this._skipNavigate = true;
      this.option("currentDate", currentDate);
    }
  },
  _isNextViewDisabled() {
    return this._navigator._nextButton.option("disabled");
  },
  _isPrevViewDisabled() {
    return this._navigator._prevButton.option("disabled");
  },
  _areDatesInSameView(zoomLevel, date1, date2) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        return date1.getMonth() === date2.getMonth();
      case ZOOM_LEVEL.YEAR:
        return date1.getYear() === date2.getYear();
      case ZOOM_LEVEL.DECADE:
        return parseInt(date1.getYear() / 10) === parseInt(date2.getYear() / 10);
      case ZOOM_LEVEL.CENTURY:
        return parseInt(date1.getYear() / 100) === parseInt(date2.getYear() / 100);
    }
  },
  _areDatesInNeighborView(zoomLevel, date1, date2) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        return ((a, b) => {
          const abs3 = Math.abs(a - b);
          return Math.min(abs3, 12 - abs3);
        })(date1.getMonth(), date2.getMonth()) <= 1;
      case ZOOM_LEVEL.YEAR:
        return Math.abs(date1.getYear() - date2.getYear()) <= 1;
      case ZOOM_LEVEL.DECADE:
        return Math.abs(date1.getYear() - date2.getYear()) <= 10;
      case ZOOM_LEVEL.CENTURY:
        return Math.abs(date1.getYear() - date2.getYear()) <= 100;
    }
  },
  _moveToClosestAvailableDate() {
    let baseDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.option("currentDate");
    let currentDate = new Date(baseDate);
    const zoomLevel = this.option("zoomLevel");
    const isCurrentDateAvailable = !this._isDateNotAvailable(currentDate);
    let isDateForwardAvailable = isCurrentDateAvailable;
    let isDateBackwardAvailable = isCurrentDateAvailable;
    let isDateForwardInStartView;
    let isDateBackwardInStartView;
    const dateForward = new Date(currentDate);
    const dateBackward = new Date(currentDate);
    do {
      if (isDateForwardAvailable) {
        currentDate = dateForward;
        break;
      }
      if (isDateBackwardAvailable) {
        currentDate = dateBackward;
        break;
      }
      this._shiftDate(zoomLevel, dateForward, 1, 1);
      this._shiftDate(zoomLevel, dateBackward, 1, -1);
      isDateForwardInStartView = this._areDatesInSameView(zoomLevel, dateForward, baseDate);
      isDateBackwardInStartView = this._areDatesInSameView(zoomLevel, dateBackward, baseDate);
      isDateForwardAvailable = isDateForwardInStartView && !this._isDateNotAvailable(dateForward);
      isDateBackwardAvailable = isDateBackwardInStartView && !this._isDateNotAvailable(dateBackward);
    } while (isDateForwardInStartView || isDateBackwardInStartView);
    this.option("currentDate", currentDate);
  },
  _isDateNotAvailable(date) {
    const maxDate = this._getMaxDate();
    const minDate = this._getMinDate();
    return !inRange(date, minDate, maxDate) || this._view.isDateDisabled(date);
  },
  _init() {
    this.callBase();
    this._initSelectionStrategy();
    this._correctZoomLevel();
    this._initCurrentDate();
    this._initActions();
  },
  _initSelectionStrategy() {
    const strategyName = this._getSelectionStrategyName();
    const strategy4 = SELECTION_STRATEGIES[strategyName];
    if (!this._selectionStrategy || this._selectionStrategy.NAME !== strategyName) {
      this._selectionStrategy = new strategy4(this);
    }
  },
  _refreshSelectionStrategy() {
    this._initSelectionStrategy();
    this._selectionStrategy.restoreValue();
    this._refresh();
  },
  _getSelectionStrategyName() {
    const selectionMode = this.option("selectionMode");
    switch (selectionMode) {
      case "multiple":
        return "MultipleSelection";
      case "range":
        return "RangeSelection";
      default:
        return "SingleSelection";
    }
  },
  _correctZoomLevel() {
    const minZoomLevel = this.option("minZoomLevel");
    const maxZoomLevel = this.option("maxZoomLevel");
    const zoomLevel = this.option("zoomLevel");
    if (LEVEL_COMPARE_MAP[maxZoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
      return;
    }
    if (LEVEL_COMPARE_MAP[zoomLevel] > LEVEL_COMPARE_MAP[maxZoomLevel]) {
      this.option("zoomLevel", maxZoomLevel);
    } else if (LEVEL_COMPARE_MAP[zoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
      this.option("zoomLevel", minZoomLevel);
    }
  },
  _initCurrentDate() {
    const currentDate = this._getNormalizedDate(this._selectionStrategy.getDefaultCurrentDate()) ?? this._getNormalizedDate(this.option("currentDate"));
    this.option("currentDate", currentDate);
  },
  _getNormalizedDate(date) {
    date = date_default3.normalizeDate(date, this._getMinDate(), this._getMaxDate());
    return isDefined(date) ? this._getDate(date) : date;
  },
  _initActions() {
    this._cellClickAction = this._createActionByOption("onCellClick");
    this._onContouredChanged = this._createActionByOption("onContouredChanged");
  },
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      cell: new FunctionTemplate((options2) => {
        const data2 = options2.model;
        renderer_default(options2.container).append(renderer_default("<span>").text(data2 && data2.text || String(data2)));
      })
    });
    this.callBase();
  },
  _updateCurrentDate(date) {
    if (fx_default.isAnimating(this._$viewsWrapper)) {
      fx_default.stop(this._$viewsWrapper, true);
    }
    const min = this._getMinDate();
    const max = this._getMaxDate();
    if (min > max) {
      this.option("currentDate", /* @__PURE__ */ new Date());
      return;
    }
    const normalizedDate = this._getNormalizedDate(date);
    if (date.getTime() !== normalizedDate.getTime()) {
      this.option("currentDate", new Date(normalizedDate));
      return;
    }
    let offset2 = this._getViewsOffset(this._view.option("date"), normalizedDate);
    if (0 !== offset2 && !this._isMaxZoomLevel() && this._isOtherViewCellClicked) {
      offset2 = 0;
    }
    if (this._view && 0 !== offset2 && !this._suppressNavigation) {
      if (this._additionalView) {
        if (offset2 > 2 || offset2 < -1) {
          this._refreshViews();
          this._setViewContoured(normalizedDate);
          this._updateAriaId(normalizedDate);
          this._renderNavigator();
        } else if (1 === offset2 && this._skipNavigate) {
          this._setViewContoured(normalizedDate);
          this._updateAriaId(normalizedDate);
        } else {
          this._navigate(offset2, normalizedDate);
        }
      } else {
        this._navigate(offset2, normalizedDate);
      }
    } else {
      this._renderNavigator();
      this._setViewContoured(normalizedDate);
      this._updateAriaId(normalizedDate);
    }
    this._skipNavigate = false;
  },
  _isAdditionalViewDate(date) {
    if (!this._additionalView) {
      return false;
    }
    return date >= this._additionalView._getFirstAvailableDate();
  },
  _getActiveView(date) {
    return this._isAdditionalViewDate(date) ? this._additionalView : this._view;
  },
  _setViewContoured(date) {
    if (this.option("skipFocusCheck") || renderer_default(this._$viewsWrapper).is(":focus")) {
      var _this$_additionalView;
      this._view.option("contouredDate", null);
      null === (_this$_additionalView = this._additionalView) || void 0 === _this$_additionalView || _this$_additionalView.option("contouredDate", null);
      const view = this._isAdditionalViewDate(date) ? this._additionalView : this._view;
      view.option("contouredDate", date);
    }
  },
  _getMinDate() {
    const _rangeMin = this.option("_rangeMin");
    if (_rangeMin) {
      return _rangeMin;
    }
    if (this.min) {
      return this.min;
    }
    this.min = this._dateOption("min") || new Date(1e3, 0);
    return this.min;
  },
  _getMaxDate() {
    const _rangeMax = this.option("_rangeMax");
    if (_rangeMax) {
      return _rangeMax;
    }
    if (this.max) {
      return this.max;
    }
    this.max = this._dateOption("max") || new Date(3e3, 0);
    return this.max;
  },
  _getViewsOffset(startDate, endDate) {
    const zoomLevel = this.option("zoomLevel");
    if (zoomLevel === ZOOM_LEVEL.MONTH) {
      return this._getMonthsOffset(startDate, endDate);
    }
    let zoomCorrection;
    switch (zoomLevel) {
      case ZOOM_LEVEL.CENTURY:
        zoomCorrection = 100;
        break;
      case ZOOM_LEVEL.DECADE:
        zoomCorrection = 10;
        break;
      default:
        zoomCorrection = 1;
    }
    return parseInt(endDate.getFullYear() / zoomCorrection) - parseInt(startDate.getFullYear() / zoomCorrection);
  },
  _getMonthsOffset(startDate, endDate) {
    const yearOffset = endDate.getFullYear() - startDate.getFullYear();
    const monthOffset = endDate.getMonth() - startDate.getMonth();
    return 12 * yearOffset + monthOffset;
  },
  _waitRenderView(offset2) {
    if (this._alreadyViewRender) {
      return;
    }
    this._alreadyViewRender = true;
    const date = this._getDateByOffset(offset2 * this._getRtlCorrection());
    this._moveToClosestAvailableDate(date);
    this._waitRenderViewTimeout = setTimeout(() => {
      this._alreadyViewRender = false;
    });
  },
  _getRtlCorrection() {
    return this.option("rtlEnabled") ? -1 : 1;
  },
  _getDateByOffset(offset2, date) {
    date = this._getDate(date ?? this.option("currentDate"));
    const currentDay = date.getDate();
    const difference = date_default3.getDifferenceInMonth(this.option("zoomLevel")) * offset2;
    date.setDate(1);
    date.setMonth(date.getMonth() + difference);
    const lastDay = date_default3.getLastMonthDate(date).getDate();
    date.setDate(currentDay > lastDay ? lastDay : currentDay);
    return date;
  },
  _focusTarget() {
    return this._$viewsWrapper;
  },
  _focusEventTarget() {
    return this.$element();
  },
  _initMarkup() {
    this._renderSubmitElement();
    const $element = this.$element();
    $element.addClass("dx-calendar");
    $element.toggleClass("dx-calendar-range", "range" === this.option("selectionMode"));
    this._renderBody();
    $element.append(this.$body);
    this._renderViews();
    this._renderNavigator();
    this.callBase();
    this._renderEvents();
    $element.prepend(this._navigator.$element());
    this._renderSwipeable();
    this._renderFooter();
    this._selectionStrategy.updateAriaSelected();
    this._updateAriaId();
    this._updateNavigatorLabels();
    this.setAria("role", "application");
    this._moveToClosestAvailableDate();
  },
  _render() {
    this.callBase();
    this._setViewContoured(this.option("currentDate"));
  },
  _renderBody() {
    if (!this._$viewsWrapper) {
      this.$body = renderer_default("<div>").addClass("dx-calendar-body");
      this._$viewsWrapper = renderer_default("<div>").addClass("dx-calendar-views-wrapper");
      this.$body.append(this._$viewsWrapper);
    }
  },
  _setAriaReadonly: noop2,
  _getKeyboardListeners() {
    return this.callBase().concat([this._view]);
  },
  _renderViews() {
    this.$element().addClass(`dx-calendar-view-${this.option("zoomLevel")}`);
    const {
      currentDate,
      viewsCount
    } = this.option();
    this.$element().toggleClass("dx-calendar-multiview", viewsCount > 1);
    this._view = this._renderSpecificView(currentDate);
    if (hasWindow()) {
      const beforeDate = this._getDateByOffset(-1, currentDate);
      this._beforeView = this._isViewAvailable(beforeDate) ? this._renderSpecificView(beforeDate) : null;
      const afterDate = this._getDateByOffset(viewsCount, currentDate);
      afterDate.setDate(1);
      this._afterView = this._isViewAvailable(afterDate) ? this._renderSpecificView(afterDate) : null;
    }
    if (viewsCount > 1) {
      this._additionalView = this._renderSpecificView(this._getDateByOffset(1, currentDate));
    }
    this._translateViews();
  },
  _renderSpecificView(date) {
    const {
      zoomLevel
    } = this.option();
    const specificView = m_calendar_views_default[zoomLevel];
    const $view = renderer_default("<div>").appendTo(this._$viewsWrapper);
    const config3 = this._viewConfig(date);
    const view = this._createComponent($view, specificView, config3);
    return view;
  },
  _viewConfig(date) {
    let disabledDates = this.option("disabledDates");
    disabledDates = isFunction(disabledDates) ? this._injectComponent(disabledDates.bind(this)) : disabledDates;
    return _extends({}, this._selectionStrategy.getViewOptions(), {
      date,
      min: this._getMinDate(),
      max: this._getMaxDate(),
      firstDayOfWeek: this.option("firstDayOfWeek") ?? date_default2.firstDayOfWeekIndex(),
      showWeekNumbers: this.option("showWeekNumbers"),
      selectWeekOnClick: this.option("selectWeekOnClick"),
      weekNumberRule: this.option("weekNumberRule"),
      zoomLevel: this.option("zoomLevel"),
      tabIndex: void 0,
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      disabledDates,
      onCellClick: this._cellClickHandler.bind(this),
      cellTemplate: this._getTemplateByOption("cellTemplate"),
      allowValueSelection: this._isMaxZoomLevel(),
      _todayDate: this.option("_todayDate")
    });
  },
  _renderEvents() {
    events_engine_default.off(this._$viewsWrapper, CALENDAR_DXHOVEREND_EVENT_NAME);
    if ("range" === this.option("selectionMode")) {
      events_engine_default.on(this._$viewsWrapper, CALENDAR_DXHOVEREND_EVENT_NAME, null, () => {
        this._updateViewsOption("hoveredRange", []);
      });
    }
  },
  _injectComponent(func) {
    const that = this;
    return function(params) {
      extend(params, {
        component: that
      });
      return func(params);
    };
  },
  _isViewAvailable(date) {
    const zoomLevel = this.option("zoomLevel");
    const min = date_default3.getViewMinBoundaryDate(zoomLevel, this._getMinDate());
    const max = date_default3.getViewMaxBoundaryDate(zoomLevel, this._getMaxDate());
    return date_default3.dateInRange(date, min, max);
  },
  _translateViews() {
    const {
      viewsCount
    } = this.option();
    move(this._view.$element(), {
      left: 0,
      top: 0
    });
    this._moveViewElement(this._beforeView, -1);
    this._moveViewElement(this._afterView, viewsCount);
    this._moveViewElement(this._additionalView, 1);
  },
  _moveViewElement(view, coefficient) {
    view && move(view.$element(), {
      left: this._getViewPosition(coefficient),
      top: 0
    });
  },
  _getViewPosition(coefficient) {
    const rtlCorrection = this.option("rtlEnabled") ? -1 : 1;
    return 100 * coefficient * rtlCorrection + "%";
  },
  _cellClickHandler(e) {
    const zoomLevel = this.option("zoomLevel");
    const nextView = date_default3.getViewDown(zoomLevel);
    const isMaxZoomLevel = this._isMaxZoomLevel();
    if (nextView && !isMaxZoomLevel) {
      this._navigateDown(e.event.currentTarget);
    } else {
      const newValue = this._updateTimeComponent(e.value);
      this._selectionStrategy.selectValue(newValue, e.event);
      this._cellClickAction(e);
    }
  },
  _updateTimeComponent(date) {
    const result2 = new Date(date);
    const currentValue = this._dateOption("value");
    if (currentValue && this._isSingleMode()) {
      result2.setHours(currentValue.getHours());
      result2.setMinutes(currentValue.getMinutes());
      result2.setSeconds(currentValue.getSeconds());
      result2.setMilliseconds(currentValue.getMilliseconds());
    }
    return result2;
  },
  _isMaxZoomLevel() {
    return this.option("zoomLevel") === this.option("maxZoomLevel");
  },
  _navigateDown(cell) {
    const zoomLevel = this.option("zoomLevel");
    if (this._isMaxZoomLevel()) {
      return;
    }
    const nextView = date_default3.getViewDown(zoomLevel);
    if (!nextView) {
      return;
    }
    let newCurrentDate = this._view.option("contouredDate") || this._view.option("date");
    if (cell) {
      newCurrentDate = renderer_default(cell).data("dxDateValueKey");
    }
    this._isOtherViewCellClicked = true;
    this.option("currentDate", newCurrentDate);
    this.option("zoomLevel", nextView);
    this._isOtherViewCellClicked = false;
    this._renderNavigator();
    this._animateShowView();
    this._moveToClosestAvailableDate();
    this._setViewContoured(this._getNormalizedDate(this.option("currentDate")));
  },
  _renderNavigator() {
    if (!this._navigator) {
      this._navigator = new m_calendar_navigator_default(renderer_default("<div>"), this._navigatorConfig());
    }
    this._navigator.option("text", this._getViewsCaption(this._view, this._additionalView));
    this._updateButtonsVisibility();
  },
  _navigatorConfig() {
    const {
      focusStateEnabled,
      rtlEnabled
    } = this.option();
    return {
      text: this._getViewsCaption(this._view, this._additionalView),
      onClick: this._navigatorClickHandler.bind(this),
      onCaptionClick: this._navigateUp.bind(this),
      focusStateEnabled,
      rtlEnabled,
      tabIndex: void 0
    };
  },
  _navigatorClickHandler(e) {
    const {
      currentDate,
      viewsCount
    } = this.option();
    let offset2 = e.direction;
    if (viewsCount > 1) {
      const additionalViewActive = this._isAdditionalViewDate(currentDate);
      const shouldDoubleOffset = additionalViewActive && offset2 < 0 || !additionalViewActive && offset2 > 0;
      if (shouldDoubleOffset) {
        offset2 *= 2;
      }
    }
    const newCurrentDate = this._getDateByOffset(offset2, currentDate);
    this._moveToClosestAvailableDate(newCurrentDate);
  },
  _navigateUp() {
    const zoomLevel = this.option("zoomLevel");
    const nextView = date_default3.getViewUp(zoomLevel);
    if (!nextView || this._isMinZoomLevel(zoomLevel)) {
      return;
    }
    this.option("zoomLevel", nextView);
    this._renderNavigator();
    this._animateShowView();
    this._moveToClosestAvailableDate();
    this._setViewContoured(this._getNormalizedDate(this.option("currentDate")));
  },
  _isMinZoomLevel(zoomLevel) {
    const min = this._getMinDate();
    const max = this._getMaxDate();
    return date_default3.sameView(zoomLevel, min, max) || this.option("minZoomLevel") === zoomLevel;
  },
  _updateButtonsVisibility() {
    this._navigator.toggleButton("next", !isDefined(this._afterView));
    this._navigator.toggleButton("prev", !isDefined(this._beforeView));
  },
  _renderSwipeable() {
    if (!this._swipeable) {
      this._swipeable = this._createComponent(this.$element(), swipeable_default, {
        onStart: this._swipeStartHandler.bind(this),
        onUpdated: this._swipeUpdateHandler.bind(this),
        onEnd: this._swipeEndHandler.bind(this),
        itemSizeFunc: this._viewWidth.bind(this)
      });
    }
  },
  _swipeStartHandler(e) {
    fx_default.stop(this._$viewsWrapper, true);
    const {
      viewsCount
    } = this.option();
    this._toggleGestureCoverCursor("grabbing");
    e.event.maxLeftOffset = this._getRequiredView("next") ? 1 / viewsCount : 0;
    e.event.maxRightOffset = this._getRequiredView("prev") ? 1 / viewsCount : 0;
  },
  _toggleGestureCoverCursor(cursor) {
    renderer_default(".dx-gesture-cover").css("cursor", cursor);
  },
  _getRequiredView(name2) {
    let view;
    const isRtl = this.option("rtlEnabled");
    if ("next" === name2) {
      view = isRtl ? this._beforeView : this._afterView;
    } else if ("prev" === name2) {
      view = isRtl ? this._afterView : this._beforeView;
    }
    return view;
  },
  _swipeUpdateHandler(e) {
    const {
      offset: offset2
    } = e.event;
    move(this._$viewsWrapper, {
      left: offset2 * this._viewWidth(),
      top: 0
    });
    this._updateNavigatorCaption(offset2);
  },
  _swipeEndHandler(e) {
    this._toggleGestureCoverCursor("auto");
    const {
      currentDate,
      rtlEnabled
    } = this.option();
    const {
      targetOffset
    } = e.event;
    const moveOffset = !targetOffset ? 0 : targetOffset / Math.abs(targetOffset);
    const isAdditionalViewActive = this._isAdditionalViewDate(currentDate);
    const shouldDoubleOffset = isAdditionalViewActive && (rtlEnabled ? -1 === moveOffset : 1 === moveOffset);
    if (0 === moveOffset) {
      this._animateWrapper(0, 250);
      return;
    }
    const offset2 = -moveOffset * this._getRtlCorrection() * (shouldDoubleOffset ? 2 : 1);
    let date = this._getDateByOffset(offset2);
    if (this._isDateInInvalidRange(date)) {
      if (moveOffset >= 0) {
        date = new Date(this._getMinDate());
      } else {
        date = new Date(this._getMaxDate());
      }
    }
    this.option("currentDate", date);
  },
  _viewWidth() {
    if (!this._viewWidthValue) {
      this._viewWidthValue = getWidth(this.$element()) / this.option("viewsCount");
    }
    return this._viewWidthValue;
  },
  _updateNavigatorCaption(offset2) {
    offset2 *= this._getRtlCorrection();
    const isMultiView = this.option("viewsCount") > 1;
    let view;
    let additionalView;
    if (offset2 > 0.5 && this._beforeView) {
      view = this._beforeView;
      additionalView = isMultiView && this._view;
    } else if (offset2 < -0.5 && this._afterView) {
      view = isMultiView ? this._additionalView : this._afterView;
      additionalView = isMultiView ? this._afterView : null;
    } else {
      view = this._view;
      additionalView = isMultiView ? this._additionalView : null;
    }
    this._navigator.option("text", this._getViewsCaption(view, additionalView));
  },
  _getViewsCaption(view, additionalView) {
    let caption = view.getNavigatorCaption();
    const {
      viewsCount
    } = this.option();
    if (viewsCount > 1 && additionalView) {
      const additionalViewCaption = additionalView.getNavigatorCaption();
      caption = `${caption} - ${additionalViewCaption}`;
    }
    return caption;
  },
  _isDateInInvalidRange(date) {
    if (this._view.isBoundary(date)) {
      return;
    }
    const min = this._getMinDate();
    const max = this._getMaxDate();
    const normalizedDate = date_default3.normalizeDate(date, min, max);
    return normalizedDate === min || normalizedDate === max;
  },
  _renderFooter() {
    const showTodayButton = this.option("showTodayButton");
    if (showTodayButton) {
      const $todayButton = this._createComponent(renderer_default("<div>"), button_default, {
        focusStateEnabled: this.option("focusStateEnabled"),
        text: message_default.format("dxCalendar-todayButtonText"),
        onClick: (args) => {
          this._toTodayView(args);
        },
        type: isFluent() ? "normal" : "default",
        stylingMode: isFluent() ? "outlined" : "text",
        integrationOptions: {}
      }).$element().addClass("dx-calendar-today-button");
      this._$footer = renderer_default("<div>").addClass("dx-calendar-footer").append($todayButton);
      this.$element().append(this._$footer);
    }
    this.$element().toggleClass("dx-calendar-with-footer", showTodayButton);
  },
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    this._setSubmitValue(this.option("value"));
  },
  _setSubmitValue(value2) {
    const dateValue = this._convertToDate(value2);
    this._getSubmitElement().val(date_serialization_default.serializeDate(dateValue, "yyyy-MM-dd"));
  },
  _getSubmitElement() {
    return this._$submitElement;
  },
  _animateShowView() {
    fx_default.stop(this._view.$element(), true);
    this._popAnimationView(this._view, 0.6, 1, 250);
    if (this.option("viewsCount") > 1) {
      fx_default.stop(this._additionalView.$element(), true);
      this._popAnimationView(this._additionalView, 0.6, 1, 250);
    }
  },
  _popAnimationView: (view, from, to, duration) => fx_default.animate(view.$element(), {
    type: "pop",
    from: {
      scale: from,
      opacity: from
    },
    to: {
      scale: to,
      opacity: to
    },
    duration
  }),
  _navigate(offset2, value2) {
    if (0 !== offset2 && 1 !== Math.abs(offset2) && this._isViewAvailable(value2)) {
      const newView = this._renderSpecificView(value2);
      if (offset2 > 0) {
        this._afterView && this._afterView.$element().remove();
        this._afterView = newView;
      } else {
        this._beforeView && this._beforeView.$element().remove();
        this._beforeView = newView;
      }
      this._translateViews();
    }
    const rtlCorrection = this._getRtlCorrection();
    const offsetSign = offset2 > 0 ? 1 : offset2 < 0 ? -1 : 0;
    const endPosition = -rtlCorrection * offsetSign * this._viewWidth();
    const viewsWrapperPosition = this._$viewsWrapper.position().left;
    if (viewsWrapperPosition !== endPosition) {
      if (this._preventViewChangeAnimation) {
        this._wrapperAnimationEndHandler(offset2, value2);
      } else {
        this._animateWrapper(endPosition, 250).done(this._wrapperAnimationEndHandler.bind(this, offset2, value2));
      }
    }
  },
  _animateWrapper(to, duration) {
    return fx_default.animate(this._$viewsWrapper, {
      type: "slide",
      from: {
        left: this._$viewsWrapper.position().left
      },
      to: {
        left: to
      },
      duration
    });
  },
  _getDate: (value2) => new Date(value2),
  _toTodayView(args) {
    const today = /* @__PURE__ */ new Date();
    if (this._isMaxZoomLevel()) {
      this._selectionStrategy.selectValue(today, args.event);
      return;
    }
    this._preventViewChangeAnimation = true;
    this.option("zoomLevel", this.option("maxZoomLevel"));
    this._selectionStrategy.selectValue(today, args.event);
    this._animateShowView();
    this._preventViewChangeAnimation = false;
  },
  _wrapperAnimationEndHandler(offset2, newDate) {
    this._rearrangeViews(offset2);
    this._translateViews();
    this._resetLocation();
    this._renderNavigator();
    this._setViewContoured(newDate);
    this._updateAriaId(newDate);
    this._selectionStrategy.updateAriaSelected();
  },
  _rearrangeViews(offset2) {
    var _this$viewToRemoveKey;
    if (0 === offset2) {
      return;
    }
    const {
      viewsCount
    } = this.option();
    let viewOffset;
    let viewToCreateKey;
    let viewToRemoveKey;
    let viewBeforeCreateKey;
    let viewAfterRemoveKey;
    if (offset2 < 0) {
      viewOffset = 1;
      viewToCreateKey = "_beforeView";
      viewToRemoveKey = "_afterView";
      viewBeforeCreateKey = "_view";
      viewAfterRemoveKey = 1 === viewsCount ? "_view" : "_additionalView";
    } else {
      viewOffset = -1;
      viewToCreateKey = "_afterView";
      viewToRemoveKey = "_beforeView";
      viewBeforeCreateKey = 1 === viewsCount ? "_view" : "_additionalView";
      viewAfterRemoveKey = "_view";
    }
    if (!this[viewToCreateKey]) {
      return;
    }
    const destinationDate = this[viewToCreateKey].option("date");
    null === (_this$viewToRemoveKey = this[viewToRemoveKey]) || void 0 === _this$viewToRemoveKey || _this$viewToRemoveKey.$element().remove();
    this[viewToRemoveKey] = this._renderSpecificView(this._getDateByOffset(viewOffset * viewsCount, destinationDate));
    this[viewAfterRemoveKey].$element().remove();
    if (1 === viewsCount) {
      this[viewAfterRemoveKey] = this[viewToCreateKey];
    } else {
      this[viewAfterRemoveKey] = this[viewBeforeCreateKey];
      this[viewBeforeCreateKey] = this[viewToCreateKey];
    }
    const dateByOffset = this._getDateByOffset(-viewOffset, destinationDate);
    this[viewToCreateKey] = this._isViewAvailable(dateByOffset) ? this._renderSpecificView(dateByOffset) : null;
  },
  _resetLocation() {
    move(this._$viewsWrapper, {
      left: 0,
      top: 0
    });
  },
  _clean() {
    this.callBase();
    this._clearViewWidthCache();
    delete this._$viewsWrapper;
    delete this._navigator;
    delete this._$footer;
  },
  _clearViewWidthCache() {
    delete this._viewWidthValue;
  },
  _disposeViews() {
    this._view.$element().remove();
    this._beforeView && this._beforeView.$element().remove();
    this._additionalView && this._additionalView.$element().remove();
    this._afterView && this._afterView.$element().remove();
    delete this._view;
    delete this._additionalView;
    delete this._beforeView;
    delete this._afterView;
    delete this._skipNavigate;
  },
  _dispose() {
    clearTimeout(this._waitRenderViewTimeout);
    this.callBase();
  },
  _refreshViews() {
    this._resetActiveState();
    this._disposeViews();
    this._renderViews();
  },
  _visibilityChanged() {
    this._translateViews();
  },
  _shouldSkipFocusEvent(event) {
    const {
      target,
      relatedTarget
    } = event;
    return renderer_default(target).parents(".dx-calendar").length && renderer_default(relatedTarget).parents(".dx-calendar").length;
  },
  _focusInHandler(event) {
    if (renderer_default(event.target).is(this._$viewsWrapper)) {
      this._setViewContoured(this.option("currentDate"));
    }
    if (this._shouldSkipFocusEvent(event)) {
      return;
    }
    this.callBase.apply(this, arguments);
    this._toggleFocusClass(true, this.$element());
  },
  _focusOutHandler(event) {
    if (renderer_default(event.target).is(this._$viewsWrapper)) {
      var _this$_additionalView2;
      this._view.option("contouredDate", null);
      null === (_this$_additionalView2 = this._additionalView) || void 0 === _this$_additionalView2 || _this$_additionalView2.option("contouredDate", null);
    }
    if (this._shouldSkipFocusEvent(event)) {
      return;
    }
    this.callBase.apply(this, arguments);
    this._toggleFocusClass(false, this.$element());
  },
  _updateViewsOption(optionName, newValue) {
    var _this$_additionalView3, _this$_beforeView, _this$_afterView;
    this._view.option(optionName, newValue);
    null === (_this$_additionalView3 = this._additionalView) || void 0 === _this$_additionalView3 || _this$_additionalView3.option(optionName, newValue);
    null === (_this$_beforeView = this._beforeView) || void 0 === _this$_beforeView || _this$_beforeView.option(optionName, newValue);
    null === (_this$_afterView = this._afterView) || void 0 === _this$_afterView || _this$_afterView.option(optionName, newValue);
  },
  _setViewsMinOption(min) {
    this._restoreViewsMinMaxOptions();
    this.option("_rangeMin", this._convertToDate(min));
    this._updateViewsOption("min", this._getMinDate());
  },
  _setViewsMaxOption(max) {
    this._restoreViewsMinMaxOptions();
    this.option("_rangeMax", this._convertToDate(max));
    this._updateViewsOption("max", this._getMaxDate());
  },
  _restoreViewsMinMaxOptions() {
    this._resetActiveState();
    this.option({
      _rangeMin: null,
      _rangeMax: null
    });
    this._updateViewsOption("min", this._getMinDate());
    this._updateViewsOption("max", this._getMaxDate());
  },
  _updateNavigatorLabels() {
    let zoomLevel = this.option("zoomLevel");
    zoomLevel = zoomLevel.charAt(0).toUpperCase() + zoomLevel.slice(1);
    const captionButtonText = this._navigator._caption.option("text");
    const localizedPrevButtonLabel = message_default.format(`dxCalendar-previous${zoomLevel}ButtonLabel`);
    const localizedCaptionLabel = message_default.format(`dxCalendar-caption${zoomLevel}Label`);
    const localizedNextButtonLabel = message_default.format(`dxCalendar-next${zoomLevel}ButtonLabel`);
    this.setAria("label", localizedPrevButtonLabel, this._navigator._prevButton.$element());
    this.setAria("label", `${captionButtonText}. ${localizedCaptionLabel}`, this._navigator._caption.$element());
    this.setAria("label", localizedNextButtonLabel, this._navigator._nextButton.$element());
  },
  _updateAriaSelected(value2, previousValue) {
    previousValue.forEach((item) => {
      this.setAria("selected", false, this._view._getCellByDate(item));
    });
    value2.forEach((item) => {
      this.setAria("selected", true, this._view._getCellByDate(item));
    });
    if (this.option("viewsCount") > 1) {
      previousValue.forEach((item) => {
        this.setAria("selected", false, this._additionalView._getCellByDate(item));
      });
      value2.forEach((item) => {
        this.setAria("selected", true, this._additionalView._getCellByDate(item));
      });
    }
  },
  _updateAriaId(value2) {
    value2 = value2 ?? this.option("currentDate");
    const ariaId = `dx-${new guid_default()}`;
    const view = this._getActiveView(value2);
    const $newCell = view._getCellByDate(value2);
    this.setAria("id", ariaId, $newCell);
    this.setAria("activedescendant", ariaId);
    this._onContouredChanged(ariaId);
  },
  _suppressingNavigation(callback, args) {
    this._suppressNavigation = true;
    callback.apply(this, args);
    delete this._suppressNavigation;
  },
  _optionChanged(args) {
    const {
      value: value2,
      previousValue
    } = args;
    switch (args.name) {
      case "width":
        this.callBase(args);
        this._clearViewWidthCache();
        break;
      case "min":
      case "max":
        this.min = void 0;
        this.max = void 0;
        this._suppressingNavigation(this._updateCurrentDate, [this.option("currentDate")]);
        this._refreshViews();
        this._renderNavigator();
        break;
      case "selectionMode":
        this._refreshSelectionStrategy();
        this._initCurrentDate();
        break;
      case "selectWeekOnClick":
      case "_todayDate":
      case "showWeekNumbers":
      case "weekNumberRule":
        this._refreshViews();
        break;
      case "firstDayOfWeek":
        this._refreshViews();
        this._updateButtonsVisibility();
        break;
      case "focusStateEnabled":
      case "disabledDates":
      case "dateSerializationFormat":
      case "cellTemplate":
      case "showTodayButton":
        this._invalidate();
        break;
      case "currentDate":
        this.setAria("id", void 0, this._view._getCellByDate(previousValue));
        this._updateCurrentDate(value2);
        break;
      case "zoomLevel":
        this.$element().removeClass(`dx-calendar-view-${previousValue}`);
        this._correctZoomLevel();
        this._refreshViews();
        this._renderNavigator();
        this._updateAriaId();
        this._updateNavigatorLabels();
        break;
      case "minZoomLevel":
      case "maxZoomLevel":
        this._correctZoomLevel();
        this._updateButtonsVisibility();
        break;
      case "value":
        this._selectionStrategy.processValueChanged(value2, previousValue);
        this._setSubmitValue(value2);
        this.callBase(args);
        break;
      case "viewsCount":
        this._refreshViews();
        this._renderNavigator();
        break;
      case "onCellClick":
        this._view.option("onCellClick", value2);
        break;
      case "onContouredChanged":
        this._onContouredChanged = this._createActionByOption("onContouredChanged");
        break;
      case "skipFocusCheck":
        break;
      default:
        this.callBase(args);
    }
  },
  getContouredDate() {
    return this._view.option("contouredDate");
  }
});
component_registrator_default("dxCalendar", Calendar);
var m_calendar_default = Calendar;

// ../../../../../../node_modules/devextreme/esm/ui/calendar.js
var calendar_default = m_calendar_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.js
var {
  abstract: abstract7
} = class_default;
var DateBoxStrategy = class_default.inherit({
  ctor(dateBox) {
    this.dateBox = dateBox;
  },
  widgetOption() {
    return this._widget && this._widget.option.apply(this._widget, arguments);
  },
  _renderWidget(element) {
    element = element || renderer_default("<div>");
    this._widget = this._createWidget(element);
    this._widget.$element().appendTo(this._getWidgetContainer());
  },
  _createWidget(element) {
    const widgetName = this._getWidgetName();
    const widgetOptions = this._getWidgetOptions();
    return this.dateBox._createComponent(element, widgetName, widgetOptions);
  },
  _getWidgetOptions: abstract7,
  _getWidgetName: abstract7,
  getDefaultOptions: () => ({
    mode: "text"
  }),
  getDisplayFormat: abstract7,
  supportedKeys: noop2,
  getKeyboardListener: noop2,
  customizeButtons: noop2,
  getParsedText(text, format2) {
    const value2 = date_default2.parse(text, format2);
    return value2 || date_default2.parse(text);
  },
  renderInputMinMax: noop2,
  renderOpenedState() {
    this._updateValue();
  },
  popupConfig: abstract7,
  _dimensionChanged() {
    var _this$_getPopup;
    null === (_this$_getPopup = this._getPopup()) || void 0 === _this$_getPopup || _this$_getPopup.repaint();
  },
  renderPopupContent() {
    const popup = this._getPopup();
    this._renderWidget();
    const $popupContent = popup.$content().parent();
    events_engine_default.off($popupContent, "mousedown");
    events_engine_default.on($popupContent, "mousedown", this._preventFocusOnPopup.bind(this));
  },
  _preventFocusOnPopup(e) {
    e.preventDefault();
  },
  _getWidgetContainer() {
    return this._getPopup().$content();
  },
  _getPopup() {
    return this.dateBox._popup;
  },
  popupShowingHandler: noop2,
  popupHiddenHandler: noop2,
  _updateValue() {
    this._widget && this._widget.option("value", this.dateBoxValue());
  },
  useCurrentDateByDefault: noop2,
  getDefaultDate: () => /* @__PURE__ */ new Date(),
  textChangedHandler: noop2,
  renderValue() {
    if (this.dateBox.option("opened")) {
      this._updateValue();
    }
  },
  getValue() {
    return this._widget.option("value");
  },
  isAdaptivityChanged: () => false,
  dispose() {
    const popup = this._getPopup();
    if (popup) {
      popup.$content().empty();
    }
  },
  dateBoxValue() {
    if (arguments.length) {
      return this.dateBox.dateValue.apply(this.dateBox, arguments);
    }
    return this.dateBox.dateOption.apply(this.dateBox, ["value"]);
  }
});
var m_date_box_strategy_default = DateBoxStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.calendar.js
var CalendarStrategy = m_date_box_strategy_default.inherit({
  NAME: "Calendar",
  getDefaultOptions() {
    return extend(this.callBase(), {
      todayButtonText: message_default.format("dxCalendar-todayButtonText")
    });
  },
  supportedKeys() {
    const homeEndHandler = function(e) {
      if (this.option("opened")) {
        e.preventDefault();
        return true;
      }
      return false;
    };
    return {
      rightArrow() {
        if (this.option("opened")) {
          return true;
        }
      },
      leftArrow() {
        if (this.option("opened")) {
          return true;
        }
      },
      enter: (function(e) {
        if (this.dateBox.option("opened")) {
          e.preventDefault();
          if (this._widget.option("zoomLevel") === this._widget.option("maxZoomLevel")) {
            const viewValue = this._getContouredValue();
            const lastActionElement = this._lastActionElement;
            const shouldCloseDropDown = this._closeDropDownByEnter();
            if (shouldCloseDropDown && viewValue && "calendar" === lastActionElement) {
              this.dateBoxValue(viewValue, e);
            }
            shouldCloseDropDown && this.dateBox.close();
            this.dateBox._valueChangeEventHandler(e);
            return !shouldCloseDropDown;
          }
          return true;
        }
        this.dateBox._valueChangeEventHandler(e);
      }).bind(this),
      home: homeEndHandler,
      end: homeEndHandler
    };
  },
  getDisplayFormat: (displayFormat) => displayFormat || "shortdate",
  _closeDropDownByEnter: () => true,
  _getWidgetName: () => calendar_default,
  _getContouredValue() {
    return this._widget._view.option("contouredDate");
  },
  getKeyboardListener() {
    return this._widget;
  },
  _getWidgetOptions() {
    const disabledDates = this.dateBox.option("disabledDates");
    return extend(this.dateBox.option("calendarOptions"), {
      value: this.dateBoxValue() || null,
      selectionMode: "single",
      dateSerializationFormat: null,
      min: this.dateBox.dateOption("min"),
      max: this.dateBox.dateOption("max"),
      onValueChanged: this._valueChangedHandler.bind(this),
      onCellClick: this._cellClickHandler.bind(this),
      disabledDates: isFunction(disabledDates) ? this._injectComponent(disabledDates.bind(this.dateBox)) : disabledDates,
      onContouredChanged: this._refreshActiveDescendant.bind(this),
      skipFocusCheck: true
    });
  },
  _injectComponent(func) {
    const that = this;
    return function(params) {
      extend(params, {
        component: that.dateBox
      });
      return func(params);
    };
  },
  _refreshActiveDescendant(e) {
    this._lastActionElement = "calendar";
    this.dateBox.setAria("activedescendant", e.actionValue);
  },
  _getTodayButtonConfig() {
    const buttonsLocation = this.dateBox.option("buttonsLocation");
    const isButtonsLocationDefault = "default" === buttonsLocation;
    const position3 = isButtonsLocationDefault ? ["bottom", "center"] : splitPair(buttonsLocation);
    const stylingMode = isMaterial() ? "text" : "outlined";
    return {
      widget: "dxButton",
      toolbar: position3[0],
      location: "after" === position3[1] ? "before" : position3[1],
      options: {
        onClick: (args) => {
          this._widget._toTodayView(args);
        },
        text: this.dateBox.option("todayButtonText"),
        elementAttr: {
          class: "dx-button-today"
        },
        stylingMode
      }
    };
  },
  _isCalendarVisible() {
    const {
      calendarOptions
    } = this.dateBox.option();
    return isEmptyObject(calendarOptions) || false !== calendarOptions.visible;
  },
  _getPopupToolbarItems(toolbarItems) {
    const useButtons = "useButtons" === this.dateBox.option("applyValueMode");
    const shouldRenderTodayButton = useButtons && this._isCalendarVisible();
    if (shouldRenderTodayButton) {
      const todayButton = this._getTodayButtonConfig();
      return [todayButton, ...toolbarItems];
    }
    return toolbarItems;
  },
  popupConfig: (popupConfig) => extend(true, popupConfig, {
    position: {
      collision: "flipfit flip"
    },
    width: "auto"
  }),
  _valueChangedHandler(e) {
    const {
      value: value2
    } = e;
    const prevValue = e.previousValue;
    if (date_default3.sameDate(value2, prevValue) && date_default3.sameHoursAndMinutes(value2, prevValue)) {
      return;
    }
    if ("instantly" === this.dateBox.option("applyValueMode")) {
      this.dateBoxValue(this.getValue(), e.event);
    }
  },
  _updateValue() {
    if (!this._widget) {
      return;
    }
    this._widget.option("value", this.dateBoxValue());
  },
  textChangedHandler() {
    this._lastActionElement = "input";
    if (this.dateBox.option("opened") && this._widget) {
      this._updateValue(true);
    }
  },
  _cellClickHandler(e) {
    const {
      dateBox
    } = this;
    if ("instantly" === dateBox.option("applyValueMode")) {
      dateBox.option("opened", false);
      this.dateBoxValue(this.getValue(), e.event);
    }
  }
});
var m_date_box_strategy_calendar_default = CalendarStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_box.js
var MINSIZE_MAP = {
  row: "minWidth",
  col: "minHeight"
};
var MAXSIZE_MAP = {
  row: "maxWidth",
  col: "maxHeight"
};
var FLEX_JUSTIFY_CONTENT_MAP = {
  start: "flex-start",
  end: "flex-end",
  center: "center",
  "space-between": "space-between",
  "space-around": "space-around"
};
var FLEX_ALIGN_ITEMS_MAP = {
  start: "flex-start",
  end: "flex-end",
  center: "center",
  stretch: "stretch"
};
var FLEX_DIRECTION_MAP = {
  row: "row",
  col: "column"
};
var setFlexProp = (element, prop, value2) => {
  value2 = normalizeStyleProp(prop, value2);
  element.style[styleProp(prop)] = value2;
  if (!hasWindow()) {
    if ("" === value2 || !isDefined(value2)) {
      return;
    }
    const cssName = dasherize(prop);
    const styleExpr = `${cssName}: ${value2};`;
    setStyle(element, styleExpr, false);
  }
};
var BoxItem = class extends m_item_default {
  _renderVisible(value2, oldValue) {
    super._renderVisible(value2);
    if (isDefined(oldValue)) {
      this._options.fireItemStateChangedAction({
        name: "visible",
        state: value2,
        oldState: oldValue
      });
    }
  }
};
var LayoutStrategy = class {
  constructor($element, option) {
    this._$element = $element;
    this._option = option;
  }
  renderBox() {
    this._$element.css({
      display: `${stylePropPrefix("flexDirection")}flex`
    });
    setFlexProp(this._$element.get(0), "flexDirection", FLEX_DIRECTION_MAP[this._option("direction")]);
  }
  renderAlign() {
    this._$element.css({
      justifyContent: this._normalizedAlign()
    });
  }
  _normalizedAlign() {
    const align = this._option("align");
    return align in FLEX_JUSTIFY_CONTENT_MAP ? FLEX_JUSTIFY_CONTENT_MAP[align] : align;
  }
  renderCrossAlign() {
    this._$element.css({
      alignItems: this._normalizedCrossAlign()
    });
  }
  _normalizedCrossAlign() {
    const crossAlign = this._option("crossAlign");
    return crossAlign in FLEX_ALIGN_ITEMS_MAP ? FLEX_ALIGN_ITEMS_MAP[crossAlign] : crossAlign;
  }
  renderItems($items) {
    const flexPropPrefix = stylePropPrefix("flexDirection");
    const direction = this._option("direction");
    each($items, function() {
      const $item = renderer_default(this);
      const item = $item.data("dxBoxItemData");
      $item.css({
        display: `${flexPropPrefix}flex`
      }).css(MAXSIZE_MAP[direction], item.maxSize || "none").css(MINSIZE_MAP[direction], item.minSize || "0");
      setFlexProp($item.get(0), "flexBasis", item.baseSize || 0);
      setFlexProp($item.get(0), "flexGrow", item.ratio);
      setFlexProp($item.get(0), "flexShrink", isDefined(item.shrink) ? item.shrink : 1);
      $item.children().each((_, itemContent) => {
        renderer_default(itemContent).css({
          width: "auto",
          height: "auto",
          display: `${stylePropPrefix("flexDirection")}flex`,
          flexBasis: 0
        });
        setFlexProp(itemContent, "flexGrow", 1);
        setFlexProp(itemContent, "flexDirection", renderer_default(itemContent)[0].style.flexDirection || "column");
      });
    });
  }
};
var Box = class _Box extends ui_collection_widget_edit_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      direction: "row",
      align: "start",
      crossAlign: "stretch",
      activeStateEnabled: false,
      focusStateEnabled: false,
      onItemStateChanged: void 0,
      _queue: void 0
    });
  }
  _itemClass() {
    return "dx-box-item";
  }
  _itemDataKey() {
    return "dxBoxItemData";
  }
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  }
  _init() {
    super._init();
    this.$element().addClass("dx-box-flex");
    this._initLayout();
    this._initBoxQueue();
  }
  _initLayout() {
    this._layout = new LayoutStrategy(this.$element(), this.option.bind(this));
  }
  _initBoxQueue() {
    this._queue = this.option("_queue") || [];
  }
  _queueIsNotEmpty() {
    return this.option("_queue") ? false : !!this._queue.length;
  }
  _pushItemToQueue($item, config3) {
    this._queue.push({
      $item,
      config: config3
    });
  }
  _shiftItemFromQueue() {
    return this._queue.shift();
  }
  _initMarkup() {
    this.$element().addClass("dx-box");
    this._layout.renderBox();
    super._initMarkup();
    this._renderAlign();
    this._renderActions();
  }
  _renderActions() {
    this._onItemStateChanged = this._createActionByOption("onItemStateChanged");
  }
  _renderAlign() {
    this._layout.renderAlign();
    this._layout.renderCrossAlign();
  }
  _renderItems(items) {
    super._renderItems(items);
    while (this._queueIsNotEmpty()) {
      const item = this._shiftItemFromQueue();
      this._createComponent(item.$item, _Box, extend({
        itemTemplate: this.option("itemTemplate"),
        itemHoldTimeout: this.option("itemHoldTimeout"),
        onItemHold: this.option("onItemHold"),
        onItemClick: this.option("onItemClick"),
        onItemContextMenu: this.option("onItemContextMenu"),
        onItemRendered: this.option("onItemRendered"),
        _queue: this._queue
      }, item.config));
    }
    this._layout.renderItems(this._itemElements());
  }
  _renderItemContent(args) {
    const $itemNode = args.itemData && args.itemData.node;
    if ($itemNode) {
      return this._renderItemContentByNode(args, $itemNode);
    }
    return super._renderItemContent(args);
  }
  _postprocessRenderItem(args) {
    const boxConfig = args.itemData.box;
    if (!boxConfig) {
      return;
    }
    this._pushItemToQueue(args.itemContent, boxConfig);
  }
  _createItemByTemplate(itemTemplate, args) {
    if (args.itemData.box) {
      return itemTemplate.source ? itemTemplate.source() : renderer_default();
    }
    return super._createItemByTemplate(itemTemplate, args);
  }
  _itemOptionChanged(item, property, value2, oldValue) {
    if ("visible" === property) {
      this._onItemStateChanged({
        name: property,
        state: value2,
        oldState: false !== oldValue
      });
    }
    super._itemOptionChanged(item, property, value2);
  }
  _optionChanged(args) {
    switch (args.name) {
      case "_queue":
      case "direction":
        this._invalidate();
        break;
      case "align":
        this._layout.renderAlign();
        break;
      case "crossAlign":
        this._layout.renderCrossAlign();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _itemOptions() {
    const options2 = super._itemOptions();
    options2.fireItemStateChangedAction = (e) => {
      this._onItemStateChanged(e);
    };
    return options2;
  }
};
Box.ItemClass = BoxItem;
component_registrator_default("dxBox", Box);
var m_box_default = Box;

// ../../../../../../node_modules/devextreme/esm/ui/box.js
var box_default = m_box_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_utils.js
var DATE_COMPONENTS = ["year", "day", "month", "day"];
var TIME_COMPONENTS = ["hours", "minutes", "seconds", "milliseconds"];
var ONE_DAY = 864e5;
var ONE_YEAR = 31536e6;
var getStringFormat = function(format2) {
  const formatType = typeof format2;
  if ("string" === formatType) {
    return "format";
  }
  if ("object" === formatType && void 0 !== format2.type) {
    return format2.type;
  }
  return null;
};
var dateUtils2 = {
  SUPPORTED_FORMATS: ["date", "time", "datetime"],
  ONE_MINUTE: 6e4,
  ONE_DAY,
  ONE_YEAR,
  MIN_DATEVIEW_DEFAULT_DATE: new Date(1900, 0, 1),
  MAX_DATEVIEW_DEFAULT_DATE: function() {
    const newDate = /* @__PURE__ */ new Date();
    return new Date(newDate.getFullYear() + 50, newDate.getMonth(), newDate.getDate(), 23, 59, 59);
  }(),
  FORMATS_INFO: {
    date: {
      getStandardPattern: () => "yyyy-MM-dd",
      components: DATE_COMPONENTS
    },
    time: {
      getStandardPattern: () => "HH:mm",
      components: TIME_COMPONENTS
    },
    datetime: {
      getStandardPattern() {
        let standardPattern;
        !function() {
          const $input = renderer_default("<input>").attr("type", "datetime");
          $input.val("2000-01-01T01:01Z");
          if ($input.val()) {
            standardPattern = "yyyy-MM-ddTHH:mmZ";
          }
        }();
        if (!standardPattern) {
          standardPattern = "yyyy-MM-ddTHH:mm:ssZ";
        }
        dateUtils2.FORMATS_INFO.datetime.getStandardPattern = function() {
          return standardPattern;
        };
        return standardPattern;
      },
      components: [...DATE_COMPONENTS, ...TIME_COMPONENTS]
    },
    "datetime-local": {
      getStandardPattern: () => "yyyy-MM-ddTHH:mm:ss",
      components: [...DATE_COMPONENTS, "hours", "minutes", "seconds"]
    }
  },
  FORMATS_MAP: {
    date: "shortdate",
    time: "shorttime",
    datetime: "shortdateshorttime"
  },
  SUBMIT_FORMATS_MAP: {
    date: "date",
    time: "time",
    datetime: "datetime-local"
  },
  toStandardDateFormat(date, type2) {
    const pattern = dateUtils2.FORMATS_INFO[type2].getStandardPattern();
    return date_serialization_default.serializeDate(date, pattern);
  },
  fromStandardDateFormat(text) {
    const date = date_serialization_default.dateParser(text);
    return isDate(date) ? date : void 0;
  },
  getMaxMonthDay: (year, month) => new Date(year, month + 1, 0).getDate(),
  mergeDates(oldValue, newValue, format2) {
    if (!newValue) {
      return newValue || null;
    }
    if (!oldValue || isNaN(oldValue.getTime())) {
      const now = /* @__PURE__ */ new Date(null);
      oldValue = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    }
    const result2 = new Date(oldValue.valueOf());
    const formatInfo = dateUtils2.FORMATS_INFO[format2];
    each(formatInfo.components, function() {
      const componentInfo = dateUtils2.DATE_COMPONENTS_INFO[this];
      result2[componentInfo.setter](newValue[componentInfo.getter]());
    });
    return result2;
  },
  getLongestCaptionIndex(captionArray) {
    let longestIndex = 0;
    let longestCaptionLength = 0;
    let i;
    for (i = 0; i < captionArray.length; ++i) {
      if (captionArray[i].length > longestCaptionLength) {
        longestIndex = i;
        longestCaptionLength = captionArray[i].length;
      }
    }
    return longestIndex;
  },
  formatUsesMonthName: (format2) => date_default2.formatUsesMonthName(format2),
  formatUsesDayName: (format2) => date_default2.formatUsesDayName(format2),
  getLongestDate(format2, monthNames, dayNames) {
    const stringFormat = getStringFormat(format2);
    let month = 9;
    if (!stringFormat || dateUtils2.formatUsesMonthName(stringFormat)) {
      month = dateUtils2.getLongestCaptionIndex(monthNames);
    }
    const longestDate = new Date(1888, month, 21, 23, 59, 59, 999);
    if (!stringFormat || dateUtils2.formatUsesDayName(stringFormat)) {
      const date = longestDate.getDate() - longestDate.getDay() + dateUtils2.getLongestCaptionIndex(dayNames);
      longestDate.setDate(date);
    }
    return longestDate;
  },
  normalizeTime(date) {
    date.setSeconds(0);
    date.setMilliseconds(0);
  }
};
dateUtils2.DATE_COMPONENTS_INFO = {
  year: {
    getter: "getFullYear",
    setter: "setFullYear",
    formatter(value2, date) {
      const formatDate = new Date(date.getTime());
      formatDate.setFullYear(value2);
      return date_default2.format(formatDate, "yyyy");
    },
    startValue: void 0,
    endValue: void 0
  },
  day: {
    getter: "getDate",
    setter: "setDate",
    formatter(value2, date) {
      const formatDate = new Date(date.getTime());
      formatDate.setDate(value2);
      return date_default2.format(formatDate, "d");
    },
    startValue: 1,
    endValue: void 0
  },
  month: {
    getter: "getMonth",
    setter: "setMonth",
    formatter: (value2) => date_default2.getMonthNames()[value2],
    startValue: 0,
    endValue: 11
  },
  hours: {
    getter: "getHours",
    setter: "setHours",
    formatter: (value2) => date_default2.format(new Date(0, 0, 0, value2), "hour"),
    startValue: 0,
    endValue: 23
  },
  minutes: {
    getter: "getMinutes",
    setter: "setMinutes",
    formatter: (value2) => date_default2.format(new Date(0, 0, 0, 0, value2), "minute"),
    startValue: 0,
    endValue: 59
  },
  seconds: {
    getter: "getSeconds",
    setter: "setSeconds",
    formatter: (value2) => date_default2.format(new Date(0, 0, 0, 0, 0, value2), "second"),
    startValue: 0,
    endValue: 59
  },
  milliseconds: {
    getter: "getMilliseconds",
    setter: "setMilliseconds",
    formatter: (value2) => date_default2.format(new Date(0, 0, 0, 0, 0, 0, value2), "millisecond"),
    startValue: 0,
    endValue: 999
  }
};
var m_date_utils_default = dateUtils2;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/radio_group/m_radio_button.js
var RadioButton = editor_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), {
      space: function(e) {
        e.preventDefault();
        this._clickAction({
          event: e
        });
      }
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      value: false
    });
  },
  _canValueBeChangedByClick: () => true,
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  },
  _init() {
    this.callBase();
    this.$element().addClass("dx-radiobutton");
  },
  _initMarkup() {
    this.callBase();
    this._renderIcon();
    this._renderCheckedState(this.option("value"));
    this._renderClick();
    this.setAria("role", "radio");
  },
  _renderIcon() {
    this._$icon = renderer_default("<div>").addClass("dx-radiobutton-icon");
    renderer_default("<div>").addClass("dx-radiobutton-icon-dot").appendTo(this._$icon);
    this.$element().append(this._$icon);
  },
  _renderCheckedState(checked) {
    this.$element().toggleClass("dx-radiobutton-checked", checked).find(".dx-radiobutton-icon").toggleClass("dx-radiobutton-icon-checked", checked);
    this.setAria("checked", checked);
  },
  _renderClick() {
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    this._clickAction = this._createAction((args) => {
      this._clickHandler(args.event);
    });
    events_engine_default.off(this.$element(), eventName);
    events_engine_default.on(this.$element(), eventName, (e) => {
      this._clickAction({
        event: e
      });
    });
  },
  _clickHandler(e) {
    this._saveValueChangeEvent(e);
    this.option("value", true);
  },
  _optionChanged(args) {
    if ("value" === args.name) {
      this._renderCheckedState(args.value);
      this.callBase(args);
    } else {
      this.callBase(args);
    }
  }
});
component_registrator_default("dxRadioButton", RadioButton);
var m_radio_button_default = RadioButton;

// ../../../../../../node_modules/devextreme/esm/ui/radio_group/radio_button.js
var radio_button_default = m_radio_button_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator.js
var LIST_EDIT_DECORATOR = "dxListEditDecorator";
var SWIPE_START_EVENT_NAME = addNamespace2(SWIPE_START_EVENT, LIST_EDIT_DECORATOR);
var SWIPE_UPDATE_EVENT_NAME = addNamespace2(SWIPE_EVENT, LIST_EDIT_DECORATOR);
var SWIPE_END_EVENT_NAME = addNamespace2(SWIPE_END_EVENT, LIST_EDIT_DECORATOR);
var EditDecorator = class_default.inherit({
  ctor(list) {
    this._list = list;
    this._init();
  },
  _init: noop2,
  _shouldHandleSwipe: false,
  _attachSwipeEvent(config3) {
    const swipeConfig = {
      itemSizeFunc: (function() {
        if (this._clearSwipeCache) {
          this._itemWidthCache = getWidth(this._list.$element());
          this._clearSwipeCache = false;
        }
        return this._itemWidthCache;
      }).bind(this)
    };
    events_engine_default.on(config3.$itemElement, SWIPE_START_EVENT_NAME, swipeConfig, this._itemSwipeStartHandler.bind(this));
    events_engine_default.on(config3.$itemElement, SWIPE_UPDATE_EVENT_NAME, this._itemSwipeUpdateHandler.bind(this));
    events_engine_default.on(config3.$itemElement, SWIPE_END_EVENT_NAME, this._itemSwipeEndHandler.bind(this));
  },
  _itemSwipeStartHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = true;
      return;
    }
    clearTimeout(this._list._inkRippleTimer);
    this._swipeStartHandler($itemElement, e);
  },
  _itemSwipeUpdateHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    this._swipeUpdateHandler($itemElement, e);
  },
  _itemSwipeEndHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    this._swipeEndHandler($itemElement, e);
    this._clearSwipeCache = true;
  },
  beforeBag: noop2,
  afterBag: noop2,
  _commonOptions() {
    return {
      activeStateEnabled: this._list.option("activeStateEnabled"),
      hoverStateEnabled: this._list.option("hoverStateEnabled"),
      focusStateEnabled: this._list.option("focusStateEnabled")
    };
  },
  modifyElement(config3) {
    if (this._shouldHandleSwipe) {
      this._attachSwipeEvent(config3);
      this._clearSwipeCache = true;
    }
  },
  afterRender: noop2,
  handleClick: noop2,
  handleKeyboardEvents: noop2,
  handleEnterPressing: noop2,
  handleContextMenu: noop2,
  _swipeStartHandler: noop2,
  _swipeUpdateHandler: noop2,
  _swipeEndHandler: noop2,
  visibilityChange: noop2,
  getExcludedSelectors: noop2,
  dispose: noop2
});
var m_list_edit_decorator_default = EditDecorator;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator_registry.js
var registry = {};
function register(option, type2, decoratorClass) {
  const decoratorsRegistry = registry;
  const decoratorConfig = {};
  decoratorConfig[option] = decoratorsRegistry[option] ? decoratorsRegistry[option] : {};
  decoratorConfig[option][type2] = decoratorClass;
  extend(decoratorsRegistry, decoratorConfig);
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator.selection.js
var SELECT_DECORATOR_ENABLED_CLASS = "dx-list-select-decorator-enabled";
var SELECT_CHECKBOX_CONTAINER_CLASS = "dx-list-select-checkbox-container";
var SELECT_CHECKBOX_CLASS = "dx-list-select-checkbox";
var SELECT_RADIO_BUTTON_CONTAINER_CLASS = "dx-list-select-radiobutton-container";
var SELECT_RADIO_BUTTON_CLASS = "dx-list-select-radiobutton";
var CLICK_EVENT_NAME2 = addNamespace2(CLICK_EVENT_NAME, "dxListEditDecorator");
register("selection", "default", m_list_edit_decorator_default.inherit({
  _init() {
    this.callBase.apply(this, arguments);
    const selectionMode = this._list.option("selectionMode");
    this._singleStrategy = "single" === selectionMode;
    this._containerClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CONTAINER_CLASS : SELECT_CHECKBOX_CONTAINER_CLASS;
    this._controlClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CLASS : SELECT_CHECKBOX_CLASS;
    this._controlWidget = this._singleStrategy ? radio_button_default : check_box_default;
    this._list.$element().addClass(SELECT_DECORATOR_ENABLED_CLASS);
  },
  beforeBag(config3) {
    const {
      $itemElement
    } = config3;
    const $container = config3.$container.addClass(this._containerClass);
    const $control = renderer_default("<div>").addClass(this._controlClass).appendTo($container);
    new this._controlWidget($control, extend(this._commonOptions(), {
      value: this._isSelected($itemElement),
      elementAttr: {
        "aria-label": "Check State"
      },
      focusStateEnabled: false,
      hoverStateEnabled: false,
      onValueChanged: (function(e) {
        e.event && this._list._saveSelectionChangeEvent(e.event);
        this._processCheckedState($itemElement, e.value);
        e.event && e.event.stopPropagation();
      }).bind(this)
    }));
  },
  modifyElement(config3) {
    this.callBase.apply(this, arguments);
    const {
      $itemElement
    } = config3;
    const control = this._controlWidget.getInstance($itemElement.find(`.${this._controlClass}`));
    events_engine_default.on($itemElement, "stateChanged", (e, state) => {
      control.option("value", state);
    });
  },
  _updateSelectAllState() {
    if (!this._$selectAll) {
      return;
    }
    this._selectAllCheckBox.option("value", this._list.isSelectAll());
  },
  afterRender() {
    if ("all" !== this._list.option("selectionMode")) {
      return;
    }
    if (!this._$selectAll) {
      this._renderSelectAll();
    } else {
      this._updateSelectAllState();
    }
  },
  handleKeyboardEvents(currentFocusedIndex, moveFocusUp) {
    const moveFocusDown = !moveFocusUp;
    const list = this._list;
    const $selectAll = this._$selectAll;
    const lastItemIndex = list._getLastItemIndex();
    const isFocusOutOfList = moveFocusUp && 0 === currentFocusedIndex || moveFocusDown && currentFocusedIndex === lastItemIndex;
    const hasSelectAllItem = !!$selectAll;
    if (hasSelectAllItem && isFocusOutOfList) {
      list.option("focusedElement", $selectAll);
      list.scrollToItem(list.option("focusedElement"));
      return true;
    }
    return false;
  },
  handleEnterPressing(e) {
    if (this._$selectAll && this._$selectAll.hasClass("dx-state-focused")) {
      e.target = this._$selectAll.get(0);
      this._list._saveSelectionChangeEvent(e);
      this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"));
      return true;
    }
  },
  _renderSelectAll() {
    this._$selectAll = renderer_default("<div>").addClass("dx-list-select-all");
    const downArrowHandler = this._list._supportedKeys().downArrow.bind(this._list);
    const selectAllCheckBoxElement = renderer_default("<div>").addClass("dx-list-select-all-checkbox").appendTo(this._$selectAll);
    this._selectAllCheckBox = this._list._createComponent(selectAllCheckBoxElement, check_box_default, {
      elementAttr: {
        "aria-label": message_default.format("dxList-selectAll")
      },
      focusStateEnabled: false,
      hoverStateEnabled: false
    });
    this._selectAllCheckBox.registerKeyHandler("downArrow", downArrowHandler);
    renderer_default("<div>").addClass("dx-list-select-all-label").text(this._list.option("selectAllText")).appendTo(this._$selectAll);
    this._list.itemsContainer().prepend(this._$selectAll);
    this._updateSelectAllState();
    this._updateSelectAllAriaLabel();
    this._attachSelectAllHandler();
  },
  _attachSelectAllHandler() {
    this._selectAllCheckBox.option("onValueChanged", this._selectAllHandler.bind(this));
    events_engine_default.off(this._$selectAll, CLICK_EVENT_NAME2);
    events_engine_default.on(this._$selectAll, CLICK_EVENT_NAME2, this._selectAllClickHandler.bind(this));
  },
  _updateSelectAllAriaLabel() {
    if (!this._$selectAll) {
      return;
    }
    const {
      value: value2
    } = this._selectAllCheckBox.option();
    const indeterminate = void 0 === value2;
    const checkedText = indeterminate ? "half checked" : value2 ? "checked" : "not checked";
    const label = `${message_default.format("dxList-selectAll")}, ${checkedText}`;
    this._$selectAll.attr({
      "aria-label": label
    });
  },
  _selectAllHandler(e) {
    e.event && e.event.stopPropagation();
    e.event && this._list._saveSelectionChangeEvent(e.event);
    const {
      value: value2
    } = this._selectAllCheckBox.option();
    if (value2) {
      this._selectAllItems();
    } else if (false === value2) {
      this._unselectAllItems();
    }
    this._updateSelectAllAriaLabel();
    this._list._createActionByOption("onSelectAllValueChanged")({
      value: value2
    });
  },
  _checkSelectAllCapability() {
    const list = this._list;
    const dataController = list._dataController;
    if ("allPages" === list.option("selectAllMode") && list.option("grouped") && !dataController.group()) {
      ui_errors_default.log("W1010");
      return false;
    }
    return true;
  },
  _selectAllItems() {
    if (!this._checkSelectAllCapability()) {
      return;
    }
    this._list._selection.selectAll("page" === this._list.option("selectAllMode"));
  },
  _unselectAllItems() {
    if (!this._checkSelectAllCapability()) {
      return;
    }
    this._list._selection.deselectAll("page" === this._list.option("selectAllMode"));
  },
  _selectAllClickHandler(e) {
    this._list._saveSelectionChangeEvent(e);
    this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"));
  },
  _isSelected($itemElement) {
    return this._list.isItemSelected($itemElement);
  },
  _processCheckedState($itemElement, checked) {
    if (checked) {
      this._list.selectItem($itemElement);
    } else {
      this._list.unselectItem($itemElement);
    }
  },
  dispose() {
    this._disposeSelectAll();
    this._list.$element().removeClass(SELECT_DECORATOR_ENABLED_CLASS);
    this.callBase.apply(this, arguments);
  },
  _disposeSelectAll() {
    if (this._$selectAll) {
      this._$selectAll.remove();
      this._$selectAll = null;
    }
  }
}));

// ../../../../../../node_modules/devextreme/esm/__internal/ui/editor/m_data_expression.js
var DataExpressionMixin = extend({}, data_helper_default, {
  _dataExpressionDefaultOptions: () => ({
    items: [],
    dataSource: null,
    itemTemplate: "item",
    value: null,
    valueExpr: "this",
    displayExpr: void 0
  }),
  _initDataExpressions() {
    this._compileValueGetter();
    this._compileDisplayGetter();
    this._initDynamicTemplates();
    this._initDataSource();
    this._itemsToDataSource();
  },
  _itemsToDataSource() {
    if (!this.option("dataSource")) {
      this._dataSource = new DataSource({
        store: new array_store_default(this.option("items")),
        pageSize: 0
      });
      this._initDataController();
    }
  },
  _compileDisplayGetter() {
    this._displayGetter = compileGetter(this._displayGetterExpr());
  },
  _displayGetterExpr() {
    return this.option("displayExpr");
  },
  _compileValueGetter() {
    this._valueGetter = compileGetter(this._valueGetterExpr());
  },
  _valueGetterExpr() {
    return this.option("valueExpr") || "this";
  },
  _loadValue(value2) {
    const deferred = Deferred();
    value2 = this._unwrappedValue(value2);
    if (!isDefined(value2)) {
      return deferred.reject().promise();
    }
    this._loadSingle(this._valueGetterExpr(), value2).done((item) => {
      this._isValueEquals(this._valueGetter(item), value2) ? deferred.resolve(item) : deferred.reject();
    }).fail(() => {
      deferred.reject();
    });
    this._loadValueDeferred = deferred;
    return deferred.promise();
  },
  _rejectValueLoading() {
    var _this$_loadValueDefer;
    null === (_this$_loadValueDefer = this._loadValueDeferred) || void 0 === _this$_loadValueDefer || _this$_loadValueDefer.reject({
      shouldSkipCallback: true
    });
  },
  _getCurrentValue() {
    return this.option("value");
  },
  _unwrappedValue(value2) {
    value2 = value2 ?? this._getCurrentValue();
    if (value2 && this._dataSource && "this" === this._valueGetterExpr()) {
      value2 = this._getItemKey(value2);
    }
    return variable_wrapper_default.unwrap(value2);
  },
  _getItemKey(value2) {
    const key = this._dataSource.key();
    if (Array.isArray(key)) {
      const result2 = {};
      for (let i = 0, n = key.length; i < n; i++) {
        result2[key[i]] = value2[key[i]];
      }
      return result2;
    }
    if (key && "object" === typeof value2) {
      value2 = value2[key];
    }
    return value2;
  },
  _isValueEquals(value1, value2) {
    const dataSourceKey = this._dataSource && this._dataSource.key();
    let result2 = this._compareValues(value1, value2);
    if (!result2 && dataSourceKey && isDefined(value1) && isDefined(value2)) {
      if (Array.isArray(dataSourceKey)) {
        result2 = this._compareByCompositeKey(value1, value2, dataSourceKey);
      } else {
        result2 = this._compareByKey(value1, value2, dataSourceKey);
      }
    }
    return result2;
  },
  _compareByCompositeKey(value1, value2, key) {
    const isObject2 = isObject;
    if (!isObject2(value1) || !isObject2(value2)) {
      return false;
    }
    for (let i = 0, n = key.length; i < n; i++) {
      if (value1[key[i]] !== value2[key[i]]) {
        return false;
      }
    }
    return true;
  },
  _compareByKey(value1, value2, key) {
    const unwrapObservable = variable_wrapper_default.unwrap;
    const valueKey1 = ensureDefined(unwrapObservable(value1[key]), value1);
    const valueKey2 = ensureDefined(unwrapObservable(value2[key]), value2);
    return this._compareValues(valueKey1, valueKey2);
  },
  _compareValues: (value1, value2) => toComparable(value1, true) === toComparable(value2, true),
  _initDynamicTemplates: noop2,
  _setCollectionWidgetItemTemplate() {
    this._initDynamicTemplates();
    this._setCollectionWidgetOption("itemTemplate", this.option("itemTemplate"));
  },
  _getCollectionKeyExpr() {
    const valueExpr = this.option("valueExpr");
    const isValueExprField = isString(valueExpr) && "this" !== valueExpr || isFunction(valueExpr);
    return isValueExprField ? valueExpr : null;
  },
  _dataExpressionOptionChanged(args) {
    switch (args.name) {
      case "items":
        this._itemsToDataSource();
        this._setCollectionWidgetOption("items");
        break;
      case "dataSource":
        this._initDataSource();
        break;
      case "itemTemplate":
        this._setCollectionWidgetItemTemplate();
        break;
      case "valueExpr":
        this._compileValueGetter();
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._initDynamicTemplates();
        this._setCollectionWidgetOption("displayExpr");
    }
  }
});
var m_data_expression_default = DataExpressionMixin;

// ../../../../../../node_modules/devextreme/esm/ui/editor/ui.data_expression.js
var ui_data_expression_default = m_data_expression_default;

// ../../../../../../node_modules/devextreme/esm/core/utils/stubs.js
function stubComponent(componentName) {
  return class {
    constructor() {
      throw new Error(`Module '${componentName}' not found`);
    }
    static getInstance() {
    }
  };
}

// ../../../../../../node_modules/devextreme/esm/ui/widget/ui.search_box_mixin.js
var EditorClass = stubComponent("TextBox");
var ui_search_box_mixin_default = {
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      searchMode: "",
      searchExpr: null,
      searchValue: "",
      searchEnabled: false,
      searchEditorOptions: {}
    });
  },
  _initMarkup: function() {
    this._renderSearch();
    this.callBase();
  },
  _renderSearch: function() {
    const $element = this.$element();
    const searchEnabled = this.option("searchEnabled");
    const searchBoxClassName = this._addWidgetPrefix("search");
    const rootElementClassName = this._addWidgetPrefix("with-search");
    if (!searchEnabled) {
      $element.removeClass(rootElementClassName);
      this._removeSearchBox();
      return;
    }
    const editorOptions = this._getSearchEditorOptions();
    if (this._searchEditor) {
      this._searchEditor.option(editorOptions);
    } else {
      $element.addClass(rootElementClassName);
      this._$searchEditorElement = renderer_default("<div>").addClass(searchBoxClassName).prependTo($element);
      this._searchEditor = this._createComponent(this._$searchEditorElement, EditorClass, editorOptions);
    }
  },
  _removeSearchBox: function() {
    this._$searchEditorElement && this._$searchEditorElement.remove();
    delete this._$searchEditorElement;
    delete this._searchEditor;
  },
  _getSearchEditorOptions: function() {
    const that = this;
    const userEditorOptions = that.option("searchEditorOptions");
    const searchText = message_default.format("Search");
    return extend({
      mode: "search",
      placeholder: searchText,
      tabIndex: that.option("tabIndex"),
      value: that.option("searchValue"),
      valueChangeEvent: "input",
      inputAttr: {
        "aria-label": searchText
      },
      onValueChanged: function(e) {
        const searchTimeout = that.option("searchTimeout");
        that._valueChangeDeferred = new Deferred();
        clearTimeout(that._valueChangeTimeout);
        that._valueChangeDeferred.done((function() {
          this.option("searchValue", e.value);
        }).bind(that));
        if (e.event && "input" === e.event.type && searchTimeout) {
          that._valueChangeTimeout = setTimeout(function() {
            that._valueChangeDeferred.resolve();
          }, searchTimeout);
        } else {
          that._valueChangeDeferred.resolve();
        }
      }
    }, userEditorOptions);
  },
  _getAriaTarget: function() {
    if (this.option("searchEnabled")) {
      return this._itemContainer(true);
    }
    return this.callBase();
  },
  _focusTarget: function() {
    if (this.option("searchEnabled")) {
      return this._itemContainer(true);
    }
    return this.callBase();
  },
  _updateFocusState: function(e, isFocused) {
    if (this.option("searchEnabled")) {
      this._toggleFocusClass(isFocused, this.$element());
    }
    this.callBase(e, isFocused);
  },
  getOperationBySearchMode: function(searchMode) {
    return "equals" === searchMode ? "=" : searchMode;
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "searchEnabled":
      case "searchEditorOptions":
        this._invalidate();
        break;
      case "searchExpr":
      case "searchMode":
      case "searchValue":
        if (!this._dataSource) {
          ui_errors_default.log("W1009");
          return;
        }
        if ("searchMode" === args.name) {
          this._dataSource.searchOperation(this.getOperationBySearchMode(args.value));
        } else {
          this._dataSource[args.name](args.value);
        }
        this._dataSource.load();
        break;
      case "searchTimeout":
        break;
      default:
        this.callBase(args);
    }
  },
  focus: function() {
    if (!this.option("focusedElement") && this.option("searchEnabled")) {
      this._searchEditor && this._searchEditor.focus();
      return;
    }
    this.callBase();
  },
  _cleanAria: function() {
    const $element = this.$element();
    this.setAria({
      role: null,
      activedescendant: null
    }, $element);
    $element.attr("tabIndex", null);
  },
  _clean() {
    this.callBase();
    this._cleanAria();
  },
  _refresh: function() {
    if (this._valueChangeDeferred) {
      this._valueChangeDeferred.resolve();
    }
    this.callBase();
  },
  setEditorClass: function(value2) {
    EditorClass = value2;
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/utils/type_conversion.js
function toNumber(attribute) {
  return attribute ? Number(attribute.replace("px", "")) : 0;
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_element_style.js
function getElementStyle(el) {
  var _getWindow$getCompute, _getWindow;
  return el && hasWindow() ? null === (_getWindow$getCompute = (_getWindow = getWindow()).getComputedStyle) || void 0 === _getWindow$getCompute ? void 0 : _getWindow$getCompute.call(_getWindow, el) : null;
}
function getElementMargin(element, side) {
  const style = getElementStyle(element);
  return style ? toNumber(style[`margin${titleize(side)}`]) : 0;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.live_update.js
var PRIVATE_KEY_FIELD = "__dx_key__";
var m_collection_widget_live_update_default = m_collection_widget_edit_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      repaintChangesOnly: false
    });
  },
  ctor() {
    var _this$_dataController;
    this.callBase.apply(this, arguments);
    this._customizeStoreLoadOptions = (e) => {
      const dataController = this._dataController;
      if (dataController.getDataSource() && !this._dataController.isLoaded()) {
        this._correctionIndex = 0;
      }
      if (this._correctionIndex && e.storeLoadOptions) {
        e.storeLoadOptions.skip += this._correctionIndex;
      }
    };
    null === (_this$_dataController = this._dataController) || void 0 === _this$_dataController || _this$_dataController.on("customizeStoreLoadOptions", this._customizeStoreLoadOptions);
  },
  reload() {
    this._correctionIndex = 0;
  },
  _init() {
    this.callBase();
    this._refreshItemsCache();
    this._correctionIndex = 0;
  },
  _findItemElementByKey(key) {
    let result2 = renderer_default();
    const keyExpr = this.key();
    this.itemElements().each((_, item) => {
      const $item = renderer_default(item);
      const itemData = this._getItemData($item);
      if (keyExpr ? keysEqual(keyExpr, this.keyOf(itemData), key) : this._isItemEquals(itemData, key)) {
        result2 = $item;
        return false;
      }
    });
    return result2;
  },
  _dataSourceChangedHandler(newItems, e) {
    if (null !== e && void 0 !== e && e.changes) {
      this._modifyByChanges(e.changes);
    } else {
      this.callBase(newItems, e);
      this._refreshItemsCache();
    }
  },
  _isItemEquals(item1, item2) {
    if (item1 && item1.__dx_key__) {
      item1 = item1.data;
    }
    try {
      return JSON.stringify(item1) === JSON.stringify(item2);
    } catch (e) {
      return item1 === item2;
    }
  },
  _isItemStrictEquals(item1, item2) {
    return this._isItemEquals(item1, item2);
  },
  _shouldAddNewGroup(changes, items) {
    let result2 = false;
    if (this.option("grouped")) {
      if (!changes.length) {
        result2 = true;
      }
      each(changes, (i, change) => {
        if ("insert" === change.type) {
          result2 = true;
          each(items, (_, item) => {
            if (void 0 !== change.data.key && change.data.key === item.key) {
              result2 = false;
              return false;
            }
          });
        }
      });
    }
    return result2;
  },
  _partialRefresh() {
    if (this.option("repaintChangesOnly")) {
      const keyOf = (data2) => {
        if (data2 && void 0 !== data2.__dx_key__) {
          return data2.__dx_key__;
        }
        return this.keyOf(data2);
      };
      const result2 = findChanges(this._itemsCache, this._editStrategy.itemsGetter(), keyOf, this._isItemStrictEquals.bind(this));
      if (result2 && this._itemsCache.length && !this._shouldAddNewGroup(result2, this._itemsCache)) {
        this._modifyByChanges(result2, true);
        this._renderEmptyMessage();
        return true;
      }
      this._refreshItemsCache();
    }
    return false;
  },
  _refreshItemsCache() {
    if (this.option("repaintChangesOnly")) {
      const items = this._editStrategy.itemsGetter();
      try {
        this._itemsCache = extend(true, [], items);
        if (!this.key()) {
          this._itemsCache = this._itemsCache.map((itemCache, index2) => ({
            [PRIVATE_KEY_FIELD]: items[index2],
            data: itemCache
          }));
        }
      } catch (e) {
        this._itemsCache = extend([], items);
      }
    }
  },
  _dispose() {
    this._dataController.off("customizeStoreLoadOptions", this._customizeStoreLoadOptions);
    this.callBase();
  },
  _updateByChange(keyInfo, items, change, isPartialRefresh) {
    if (isPartialRefresh) {
      this._renderItem(change.index, change.data, null, this._findItemElementByKey(change.key));
    } else {
      const changedItem = items[indexByKey(keyInfo, items, change.key)];
      if (changedItem) {
        update(keyInfo, items, change.key, change.data).done(() => {
          this._renderItem(items.indexOf(changedItem), changedItem, null, this._findItemElementByKey(change.key));
        });
      }
    }
  },
  _insertByChange(keyInfo, items, change, isPartialRefresh) {
    when(isPartialRefresh || insert(keyInfo, items, change.data, change.index)).done(() => {
      this._beforeItemElementInserted(change);
      this._renderItem(change.index ?? items.length, change.data);
      this._afterItemElementInserted();
      this._correctionIndex++;
    });
  },
  _updateSelectionAfterRemoveByChange(removeIndex) {
    const selectedIndex = this.option("selectedIndex");
    if (selectedIndex > removeIndex) {
      this.option("selectedIndex", selectedIndex - 1);
    } else if (selectedIndex === removeIndex && 1 === this.option("selectedItems").length) {
      this.option("selectedItems", []);
    } else {
      this._normalizeSelectedItems();
    }
  },
  _beforeItemElementInserted(change) {
    const selectedIndex = this.option("selectedIndex");
    if (change.index <= selectedIndex) {
      this.option("selectedIndex", selectedIndex + 1);
    }
  },
  _afterItemElementInserted: noop2,
  _removeByChange(keyInfo, items, change, isPartialRefresh) {
    const index2 = isPartialRefresh ? change.index : indexByKey(keyInfo, items, change.key);
    const removedItem = isPartialRefresh ? change.oldItem : items[index2];
    if (removedItem) {
      const $removedItemElement = this._findItemElementByKey(change.key);
      const deletedActionArgs = this._extendActionArgs($removedItemElement);
      this._waitDeletingPrepare($removedItemElement).done(() => {
        if (isPartialRefresh) {
          this._updateIndicesAfterIndex(index2 - 1);
          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
          this._updateSelectionAfterRemoveByChange(index2);
        } else {
          this._deleteItemElementByIndex(index2);
          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
        }
      });
      this._correctionIndex--;
    }
  },
  _modifyByChanges(changes, isPartialRefresh) {
    const items = this._editStrategy.itemsGetter();
    const keyInfo = {
      key: this.key.bind(this),
      keyOf: this.keyOf.bind(this)
    };
    const dataController = this._dataController;
    const paginate = dataController.paginate();
    const group = dataController.group();
    if (paginate || group) {
      changes = changes.filter((item) => "insert" !== item.type || void 0 !== item.index);
    }
    changes.forEach((change) => this[`_${change.type}ByChange`](keyInfo, items, change, isPartialRefresh));
    this._renderedItemsCount = items.length;
    this._refreshItemsCache();
    this._fireContentReadyAction();
  },
  _appendItemToContainer($container, $itemFrame, index2) {
    const nextSiblingElement = $container.children(this._itemSelector()).get(index2);
    dom_adapter_default.insertElement($container.get(0), $itemFrame.get(0), nextSiblingElement);
  },
  _optionChanged(args) {
    switch (args.name) {
      case "items": {
        const isItemsUpdated = this._partialRefresh(args.value);
        if (!isItemsUpdated) {
          this.callBase(args);
        }
        break;
      }
      case "dataSource":
        if (!this.option("repaintChangesOnly") || !args.value) {
          this.option("items", []);
        }
        this.callBase(args);
        break;
      case "repaintChangesOnly":
        break;
      default:
        this.callBase(args);
    }
  }
});

// ../../../../../../node_modules/devextreme/esm/ui/collection/ui.collection_widget.live_update.js
var ui_collection_widget_live_update_default = m_collection_widget_live_update_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_load_panel.js
var LoadPanel = ui_overlay_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), {
      escape: noop2
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      message: message_default.format("Loading"),
      width: 222,
      height: 90,
      animation: null,
      showIndicator: true,
      indicatorSrc: "",
      showPane: true,
      delay: 0,
      templatesRenderAsynchronously: false,
      hideTopOverlayHandler: null,
      focusStateEnabled: false,
      propagateOutsideClick: true,
      preventScrollEvents: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: {
        platform: "generic"
      },
      options: {
        shadingColor: "transparent"
      }
    }, {
      device: () => isMaterial(),
      options: {
        message: "",
        width: 60,
        height: 60,
        maxHeight: 60,
        maxWidth: 60
      }
    }, {
      device: () => isFluent(),
      options: {
        width: "auto",
        height: "auto"
      }
    }]);
  },
  _init() {
    this.callBase.apply(this, arguments);
  },
  _render() {
    this.callBase();
    this.$element().addClass("dx-loadpanel");
    this.$wrapper().addClass("dx-loadpanel-wrapper");
    this._updateWrapperAria();
  },
  _updateWrapperAria() {
    this.$wrapper().removeAttr("aria-label").removeAttr("role");
    const showIndicator = this.option("showIndicator");
    if (!showIndicator) {
      const aria = this._getAriaAttributes();
      this.$wrapper().attr(aria);
    }
  },
  _getAriaAttributes() {
    const {
      message
    } = this.option();
    const label = message || message_default.format("Loading");
    const aria = {
      role: "alert",
      "aria-label": label
    };
    return aria;
  },
  _renderContentImpl() {
    this.callBase();
    this.$content().addClass("dx-loadpanel-content");
    this._$loadPanelContentWrapper = renderer_default("<div>").addClass("dx-loadpanel-content-wrapper");
    this._$loadPanelContentWrapper.appendTo(this.$content());
    this._togglePaneVisible();
    this._cleanPreviousContent();
    this._renderLoadIndicator();
    this._renderMessage();
  },
  _show() {
    const delay = this.option("delay");
    if (!delay) {
      return this.callBase();
    }
    const deferred = Deferred();
    const callBase = this.callBase.bind(this);
    this._clearShowTimeout();
    this._showTimeout = setTimeout(() => {
      callBase().done(() => {
        deferred.resolve();
      });
    }, delay);
    return deferred.promise();
  },
  _hide() {
    this._clearShowTimeout();
    return this.callBase();
  },
  _clearShowTimeout() {
    clearTimeout(this._showTimeout);
  },
  _renderMessage() {
    if (!this._$loadPanelContentWrapper) {
      return;
    }
    const message = this.option("message");
    if (!message) {
      return;
    }
    const $message = renderer_default("<div>").addClass("dx-loadpanel-message").text(message);
    this._$loadPanelContentWrapper.append($message);
  },
  _renderLoadIndicator() {
    if (!this._$loadPanelContentWrapper || !this.option("showIndicator")) {
      return;
    }
    if (!this._$indicator) {
      this._$indicator = renderer_default("<div>").addClass("dx-loadpanel-indicator").appendTo(this._$loadPanelContentWrapper);
    }
    this._createComponent(this._$indicator, load_indicator_default, {
      elementAttr: this._getAriaAttributes(),
      indicatorSrc: this.option("indicatorSrc")
    });
  },
  _cleanPreviousContent() {
    this.$content().find(".dx-loadpanel-message").remove();
    this.$content().find(".dx-loadpanel-indicator").remove();
    delete this._$indicator;
  },
  _togglePaneVisible() {
    this.$content().toggleClass("dx-loadpanel-pane-hidden", !this.option("showPane"));
  },
  _optionChanged(args) {
    switch (args.name) {
      case "delay":
        break;
      case "message":
      case "showIndicator":
        this._cleanPreviousContent();
        this._renderLoadIndicator();
        this._renderMessage();
        this._updateWrapperAria();
        break;
      case "showPane":
        this._togglePaneVisible();
        break;
      case "indicatorSrc":
        this._renderLoadIndicator();
        break;
      default:
        this.callBase(args);
    }
  },
  _dispose() {
    this._clearShowTimeout();
    this.callBase();
  }
});
component_registrator_default("dxLoadPanel", LoadPanel);
var m_load_panel_default = LoadPanel;

// ../../../../../../node_modules/devextreme/esm/ui/load_panel.js
var load_panel_default = m_load_panel_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollbar.js
var SCROLLBAR = "dxScrollbar";
var HOVER_ENABLED_STATE = "dx-scrollbar-hoverable";
var HORIZONTAL = "horizontal";
var SCROLLBAR_VISIBLE = {
  onScroll: "onScroll",
  onHover: "onHover",
  always: "always",
  never: "never"
};
var activeScrollbar = null;
var Scrollbar = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      direction: null,
      visible: false,
      activeStateEnabled: false,
      visibilityMode: SCROLLBAR_VISIBLE.onScroll,
      containerSize: 0,
      contentSize: 0,
      expandable: true,
      scaleRatio: 1
    });
  },
  _init() {
    this.callBase();
    this._isHovered = false;
  },
  _initMarkup() {
    this._renderThumb();
    this.callBase();
  },
  _render() {
    this.callBase();
    this._renderDirection();
    this._update();
    this._attachPointerDownHandler();
    this.option("hoverStateEnabled", this._isHoverMode());
    this.$element().toggleClass(HOVER_ENABLED_STATE, this.option("hoverStateEnabled"));
  },
  _renderThumb() {
    this._$thumb = renderer_default("<div>").addClass("dx-scrollable-scroll");
    renderer_default("<div>").addClass("dx-scrollable-scroll-content").appendTo(this._$thumb);
    this.$element().addClass("dx-scrollable-scrollbar").append(this._$thumb);
  },
  isThumb($element) {
    return !!this.$element().find($element).length;
  },
  _isHoverMode() {
    const visibilityMode = this.option("visibilityMode");
    return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && this.option("expandable");
  },
  _renderDirection() {
    const direction = this.option("direction");
    this.$element().addClass(`dx-scrollbar-${direction}`);
    this._dimension = direction === HORIZONTAL ? "width" : "height";
    this._prop = direction === HORIZONTAL ? "left" : "top";
  },
  _attachPointerDownHandler() {
    events_engine_default.on(this._$thumb, addNamespace2(pointer_default.down, SCROLLBAR), this.feedbackOn.bind(this));
  },
  feedbackOn(e) {
    null === e || void 0 === e || e.preventDefault();
    this.$element().addClass("dx-scrollable-scrollbar-active");
    activeScrollbar = this;
  },
  feedbackOff() {
    this.$element().removeClass("dx-scrollable-scrollbar-active");
    activeScrollbar = null;
  },
  cursorEnter() {
    this._isHovered = true;
    if (this._needScrollbar()) {
      this.option("visible", true);
    }
  },
  cursorLeave() {
    this._isHovered = false;
    this.option("visible", false);
  },
  _renderDimensions() {
    this._$thumb.css({
      width: this.option("width"),
      height: this.option("height")
    });
  },
  _toggleVisibility(visible2) {
    if (this.option("visibilityMode") === SCROLLBAR_VISIBLE.onScroll) {
      this._$thumb.css("opacity");
    }
    visible2 = this._adjustVisibility(visible2);
    this.option().visible = visible2;
    this._$thumb.toggleClass("dx-state-invisible", !visible2);
  },
  _adjustVisibility(visible2) {
    if (this._baseContainerToContentRatio && !this._needScrollbar()) {
      return false;
    }
    switch (this.option("visibilityMode")) {
      case SCROLLBAR_VISIBLE.onScroll:
        break;
      case SCROLLBAR_VISIBLE.onHover:
        visible2 = visible2 || !!this._isHovered;
        break;
      case SCROLLBAR_VISIBLE.never:
        visible2 = false;
        break;
      case SCROLLBAR_VISIBLE.always:
        visible2 = true;
    }
    return visible2;
  },
  moveTo(location) {
    if (this._isHidden()) {
      return;
    }
    if (isPlainObject(location)) {
      location = location[this._prop] || 0;
    }
    const scrollBarLocation = {};
    scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
    move(this._$thumb, scrollBarLocation);
  },
  _calculateScrollBarPosition(location) {
    return -location * this._thumbRatio;
  },
  _update() {
    const containerSize = Math.round(this.option("containerSize"));
    const contentSize = Math.round(this.option("contentSize"));
    let baseContainerSize = Math.round(this.option("baseContainerSize"));
    let baseContentSize = Math.round(this.option("baseContentSize"));
    if (isNaN(baseContainerSize)) {
      baseContainerSize = containerSize;
      baseContentSize = contentSize;
    }
    this._baseContainerToContentRatio = baseContentSize ? baseContainerSize / baseContentSize : baseContainerSize;
    this._realContainerToContentRatio = contentSize ? containerSize / contentSize : containerSize;
    const thumbSize = Math.round(Math.max(Math.round(containerSize * this._realContainerToContentRatio), 15));
    this._thumbRatio = (containerSize - thumbSize) / (this.option("scaleRatio") * (contentSize - containerSize));
    this.option(this._dimension, thumbSize / this.option("scaleRatio"));
    this.$element().css("display", this._needScrollbar() ? "" : "none");
  },
  _isHidden() {
    return this.option("visibilityMode") === SCROLLBAR_VISIBLE.never;
  },
  _needScrollbar() {
    return !this._isHidden() && this._baseContainerToContentRatio < 1;
  },
  containerToContentRatio() {
    return this._realContainerToContentRatio;
  },
  _normalizeSize(size) {
    return isPlainObject(size) ? size[this._dimension] || 0 : size;
  },
  _clean() {
    this.callBase();
    if (this === activeScrollbar) {
      activeScrollbar = null;
    }
    events_engine_default.off(this._$thumb, `.${SCROLLBAR}`);
  },
  _optionChanged(args) {
    if (this._isHidden()) {
      return;
    }
    switch (args.name) {
      case "containerSize":
      case "contentSize":
        this.option()[args.name] = this._normalizeSize(args.value);
        this._update();
        break;
      case "baseContentSize":
      case "baseContainerSize":
      case "scaleRatio":
        this._update();
        break;
      case "visibilityMode":
      case "direction":
        this._invalidate();
        break;
      default:
        this.callBase.apply(this, arguments);
    }
  },
  update: deferRenderer(function() {
    this._adjustVisibility() && this.option("visible", true);
  })
});
ready_callbacks_default.add(() => {
  events_engine_default.subscribeGlobal(dom_adapter_default.getDocument(), addNamespace2(pointer_default.up, SCROLLBAR), () => {
    if (activeScrollbar) {
      activeScrollbar.feedbackOff();
    }
  });
});
var m_scrollbar_default = Scrollbar;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.native.js
var SCROLLABLE_NATIVE = "dxNativeScrollable";
var SCROLLABLE_SCROLLBAR_SIMULATED = "dx-scrollable-scrollbar-simulated";
var SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden";
var VERTICAL = "vertical";
var HORIZONTAL2 = "horizontal";
var NativeStrategy = class_default.inherit({
  ctor(scrollable) {
    this._init(scrollable);
  },
  _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = renderer_default(scrollable.container());
    this._$content = scrollable.$content();
    this._direction = scrollable.option("direction");
    this._useSimulatedScrollbar = scrollable.option("useSimulatedScrollbar");
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
    this._isRtlNativeStrategy = scrollable._isRtlNativeStrategy.bind(scrollable);
  },
  render() {
    const device = devices_default.real();
    const deviceType = device.platform;
    this._$element.addClass("dx-scrollable-native").addClass(`dx-scrollable-native-${deviceType}`).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._isScrollbarVisible());
    if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
      this._renderScrollbars();
    }
  },
  updateRtlPosition(isFirstRender) {
    if (isFirstRender && this.option("rtlEnabled")) {
      if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
        this._moveScrollbars();
      }
    }
  },
  _renderScrollbars() {
    this._scrollbars = {};
    this._hideScrollbarTimeout = 0;
    this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
    this._renderScrollbar(VERTICAL);
    this._renderScrollbar(HORIZONTAL2);
  },
  _renderScrollbar(direction) {
    if (!this._isDirection(direction)) {
      return;
    }
    this._scrollbars[direction] = new m_scrollbar_default(renderer_default("<div>").appendTo(this._$element), {
      direction,
      expandable: this._component.option("scrollByThumb")
    });
  },
  handleInit: noop2,
  handleStart: noop2,
  handleMove(e) {
    if (this._isLocked()) {
      e.cancel = true;
      return;
    }
    if (this._allowedDirection()) {
      e.originalEvent.isScrollingEvent = true;
    }
  },
  handleEnd: noop2,
  handleCancel: noop2,
  handleStop: noop2,
  _eachScrollbar(callback) {
    callback = callback.bind(this);
    each(this._scrollbars || {}, (direction, scrollbar) => {
      callback(scrollbar, direction);
    });
  },
  createActions() {
    this._scrollAction = this._createActionByOption("onScroll");
    this._updateAction = this._createActionByOption("onUpdated");
  },
  _createActionArgs() {
    const {
      left,
      top
    } = this.location();
    return {
      event: this._eventForUserAction,
      scrollOffset: this._getScrollOffset(),
      reachedLeft: this._isRtlNativeStrategy() ? this._isReachedRight(-left) : this._isReachedLeft(left),
      reachedRight: this._isRtlNativeStrategy() ? this._isReachedLeft(-Math.abs(left)) : this._isReachedRight(left),
      reachedTop: this._isDirection(VERTICAL) ? Math.round(top) >= 0 : void 0,
      reachedBottom: this._isDirection(VERTICAL) ? Math.round(Math.abs(top) - this._getMaxOffset().top) >= 0 : void 0
    };
  },
  _getScrollOffset() {
    const {
      top,
      left
    } = this.location();
    return {
      top: -top,
      left: this._normalizeOffsetLeft(-left)
    };
  },
  _normalizeOffsetLeft(scrollLeft) {
    if (this._isRtlNativeStrategy()) {
      return this._getMaxOffset().left + scrollLeft;
    }
    return scrollLeft;
  },
  _isReachedLeft(left) {
    return this._isDirection(HORIZONTAL2) ? Math.round(left) >= 0 : void 0;
  },
  _isReachedRight(left) {
    return this._isDirection(HORIZONTAL2) ? Math.round(Math.abs(left) - this._getMaxOffset().left) >= 0 : void 0;
  },
  _isScrollbarVisible() {
    const {
      showScrollbar
    } = this.option();
    return "never" !== showScrollbar && false !== showScrollbar;
  },
  handleScroll(e) {
    this._eventForUserAction = e;
    this._moveScrollbars();
    this._scrollAction(this._createActionArgs());
  },
  _moveScrollbars() {
    const {
      top,
      left
    } = this._getScrollOffset();
    this._eachScrollbar((scrollbar) => {
      scrollbar.moveTo({
        top: -top,
        left: -left
      });
      scrollbar.option("visible", true);
    });
    this._hideScrollbars();
  },
  _hideScrollbars() {
    clearTimeout(this._hideScrollbarTimeout);
    this._hideScrollbarTimeout = setTimeout(() => {
      this._eachScrollbar((scrollbar) => {
        scrollbar.option("visible", false);
      });
    }, 500);
  },
  location() {
    return {
      left: -this._$container.scrollLeft(),
      top: -this._$container.scrollTop()
    };
  },
  disabledChanged: noop2,
  update() {
    this._update();
    this._updateAction(this._createActionArgs());
  },
  _update() {
    this._updateDimensions();
    this._updateScrollbars();
  },
  _updateDimensions() {
    this._containerSize = {
      height: getHeight(this._$container),
      width: getWidth(this._$container)
    };
    this._componentContentSize = {
      height: getHeight(this._component.$content()),
      width: getWidth(this._component.$content())
    };
    this._contentSize = {
      height: getHeight(this._$content),
      width: getWidth(this._$content)
    };
  },
  _updateScrollbars() {
    this._eachScrollbar(function(scrollbar, direction) {
      const dimension = direction === VERTICAL ? "height" : "width";
      scrollbar.option({
        containerSize: this._containerSize[dimension],
        contentSize: this._componentContentSize[dimension]
      });
      scrollbar.update();
    });
  },
  _allowedDirections() {
    return {
      vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
      horizontal: this._isDirection(HORIZONTAL2) && this._contentSize.width > this._containerSize.width
    };
  },
  dispose() {
    const {
      className
    } = this._$element.get(0);
    const scrollableNativeRegexp = new RegExp("dx-scrollable-native\\S*", "g");
    if (scrollableNativeRegexp.test(className)) {
      this._$element.removeClass(className.match(scrollableNativeRegexp).join(" "));
    }
    events_engine_default.off(this._$element, `.${SCROLLABLE_NATIVE}`);
    events_engine_default.off(this._$container, `.${SCROLLABLE_NATIVE}`);
    this._removeScrollbars();
    clearTimeout(this._hideScrollbarTimeout);
  },
  _removeScrollbars() {
    this._eachScrollbar((scrollbar) => {
      scrollbar.$element().remove();
    });
  },
  scrollBy(distance) {
    const location = this.location();
    this._$container.scrollTop(Math.round(-location.top - distance.top));
    this._$container.scrollLeft(Math.round(-location.left - distance.left));
  },
  validate(e) {
    if (this.option("disabled")) {
      return false;
    }
    if (isDxMouseWheelEvent(e) && this._isScrolledInMaxDirection(e)) {
      return false;
    }
    return !!this._allowedDirection();
  },
  _isScrolledInMaxDirection(e) {
    const container = this._$container.get(0);
    let result2;
    if (e.delta > 0) {
      result2 = e.shiftKey ? !container.scrollLeft : !container.scrollTop;
    } else if (e.shiftKey) {
      result2 = container.scrollLeft >= this._getMaxOffset().left;
    } else {
      result2 = container.scrollTop >= this._getMaxOffset().top;
    }
    return result2;
  },
  getDirection() {
    return this._allowedDirection();
  }
});
var m_scrollable_native_default = NativeStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.native.pull_down.js
var PullDownNativeScrollViewStrategy = m_scrollable_native_default.inherit({
  _init(scrollView) {
    this.callBase(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$refreshingText = scrollView._$refreshingText;
    this._$scrollViewContent = renderer_default(scrollView.content());
    this._$container = renderer_default(scrollView.container());
    this._initCallbacks();
  },
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  },
  render() {
    this.callBase();
    this._renderPullDown();
    this._releaseState();
  },
  _renderPullDown() {
    const $image = renderer_default("<div>").addClass("dx-scrollview-pull-down-image");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    const $text = this._$pullDownText = renderer_default("<div>").addClass("dx-scrollview-pull-down-text");
    this._$pullingDownText = renderer_default("<div>").text(this.option("pullingDownText")).appendTo($text);
    this._$pulledDownText = renderer_default("<div>").text(this.option("pulledDownText")).appendTo($text);
    this._$refreshingText = renderer_default("<div>").text(this.option("refreshingText")).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  },
  _releaseState() {
    this._state = 0;
    this._refreshPullDownText();
  },
  _refreshPullDownText() {
    const that = this;
    const pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: 0
    }, {
      element: this._$pulledDownText,
      visibleState: 1
    }, {
      element: this._$refreshingText,
      visibleState: 2
    }];
    each(pullDownTextItems, (_, item) => {
      const action = that._state === item.visibleState ? "addClass" : "removeClass";
      item.element[action]("dx-scrollview-pull-down-text-visible");
    });
  },
  update() {
    this.callBase();
    this._setTopPocketOffset();
  },
  _updateDimensions() {
    this.callBase();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const contentEl = this._$scrollViewContent.get(0);
    const containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  },
  _allowedDirections() {
    const allowedDirections = this.callBase();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  },
  _setTopPocketOffset() {
    this._$topPocket.css({
      top: -this._topPocketSize
    });
  },
  handleEnd() {
    this.callBase();
    this._complete();
  },
  handleStop() {
    this.callBase();
    this._complete();
  },
  _complete() {
    if (1 === this._state) {
      this._setPullDownOffset(this._topPocketSize);
      clearTimeout(this._pullDownRefreshTimeout);
      this._pullDownRefreshTimeout = setTimeout(() => {
        this._pullDownRefreshing();
      }, 400);
    }
  },
  _setPullDownOffset(offset2) {
    move(this._$topPocket, {
      top: offset2
    });
    move(this._$scrollViewContent, {
      top: offset2
    });
  },
  handleScroll(e) {
    this.callBase(e);
    if (2 === this._state) {
      return;
    }
    const currentLocation = this.location().top;
    const scrollDelta = (this._location || 0) - currentLocation;
    this._location = currentLocation;
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  },
  _isPullDown() {
    return this._pullDownEnabled && this._location >= this._topPocketSize;
  },
  _isReachBottom() {
    return this._reachBottomEnabled && Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  },
  _reachBottom() {
    if (3 === this._state) {
      return;
    }
    this._state = 3;
    this.reachBottomCallbacks.fire();
  },
  _pullDownReady() {
    if (1 === this._state) {
      return;
    }
    this._state = 1;
    this._$pullDown.addClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
  },
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._releaseState();
  },
  _pullDownRefreshing() {
    if (2 === this._state) {
      return;
    }
    this._state = 2;
    this._$pullDown.addClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  },
  pullDownEnable(enabled) {
    if (enabled) {
      this._updateDimensions();
      this._setTopPocketOffset();
    }
    this._pullDownEnabled = enabled;
  },
  reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  },
  pendingRelease() {
    this._state = 1;
  },
  release() {
    const deferred = Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    if (3 === this._state) {
      this._state = 0;
    }
    this._releaseTimeout = setTimeout(() => {
      this._setPullDownOffset(0);
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }, 400);
    return deferred.promise();
  },
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    this.callBase();
  }
});
var m_scroll_view_native_pull_down_default = PullDownNativeScrollViewStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.native.swipe_down.js
var SwipeDownNativeScrollViewStrategy = m_scrollable_native_default.inherit({
  _init(scrollView) {
    this.callBase(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$scrollViewContent = renderer_default(scrollView.content());
    this._$container = renderer_default(scrollView.container());
    this._initCallbacks();
    this._location = 0;
  },
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  },
  render() {
    this.callBase();
    this._renderPullDown();
    this._releaseState();
  },
  _renderPullDown() {
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    this._$icon = renderer_default("<div>").addClass("dx-icon-pulldown");
    this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator));
  },
  _releaseState() {
    this._state = 0;
    this._releasePullDown();
    this._updateDimensions();
  },
  _releasePullDown() {
    this._$pullDown.css({
      opacity: 0
    });
  },
  _updateDimensions() {
    this.callBase();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const contentEl = this._$scrollViewContent.get(0);
    const containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  },
  _allowedDirections() {
    const allowedDirections = this.callBase();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  },
  handleInit(e) {
    this.callBase(e);
    if (0 === this._state && 0 === this._location) {
      this._startClientY = eventData(e.originalEvent).y;
      this._state = 4;
    }
  },
  handleMove(e) {
    this.callBase(e);
    this._deltaY = eventData(e.originalEvent).y - this._startClientY;
    if (4 === this._state) {
      if (this._pullDownEnabled && this._deltaY > 0) {
        this._state = 5;
      } else {
        this._complete();
      }
    }
    if (5 === this._state) {
      e.preventDefault();
      this._movePullDown();
    }
  },
  _movePullDown() {
    const pullDownHeight = this._getPullDownHeight();
    const top = Math.min(3 * pullDownHeight, this._deltaY + this._getPullDownStartPosition());
    const angle = 180 * top / pullDownHeight / 3;
    this._$pullDown.css({
      opacity: 1
    }).toggleClass("dx-scrollview-pull-down-refreshing", top < pullDownHeight);
    move(this._$pullDown, {
      top
    });
    this._$icon.css({
      transform: `rotate(${angle}deg)`
    });
  },
  _isPullDown() {
    return this._pullDownEnabled && 5 === this._state && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition();
  },
  _getPullDownHeight() {
    return Math.round(0.05 * getOuterHeight(this._$element));
  },
  _getPullDownStartPosition() {
    return -Math.round(1.5 * getOuterHeight(this._$pullDown));
  },
  handleEnd() {
    if (this._isPullDown()) {
      this._pullDownRefreshing();
    }
    this._complete();
  },
  handleStop() {
    this._complete();
  },
  _complete() {
    if (4 === this._state || 5 === this._state) {
      this._releaseState();
    }
  },
  handleScroll(e) {
    this.callBase(e);
    if (2 === this._state) {
      return;
    }
    const currentLocation = this.location().top;
    const scrollDelta = this._location - currentLocation;
    this._location = currentLocation;
    if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  },
  _isReachBottom() {
    return this._reachBottomEnabled && Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  },
  _reachBottom() {
    this.reachBottomCallbacks.fire();
  },
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading");
    this._releaseState();
  },
  _pullDownRefreshing() {
    this._state = 2;
    this._pullDownRefreshHandler();
  },
  _pullDownRefreshHandler() {
    this._refreshPullDown();
    this.pullDownCallbacks.fire();
  },
  _refreshPullDown() {
    this._$pullDown.addClass("dx-scrollview-pull-down-loading");
    move(this._$pullDown, {
      top: this._getPullDownHeight()
    });
  },
  pullDownEnable(enabled) {
    this._$topPocket.toggle(enabled);
    this._pullDownEnabled = enabled;
  },
  reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  },
  pendingRelease() {
    this._state = 1;
  },
  release() {
    const deferred = Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    this._releaseTimeout = setTimeout(() => {
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }, 800);
    return deferred.promise();
  },
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    this.callBase();
  }
});
var m_scroll_view_native_swipe_down_default = SwipeDownNativeScrollViewStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_animator.js
var {
  abstract: abstract8
} = class_default;
var Animator = class_default.inherit({
  ctor() {
    this._finished = true;
    this._stopped = false;
    this._proxiedStepCore = this._stepCore.bind(this);
  },
  start() {
    this._stopped = false;
    this._finished = false;
    this._stepCore();
  },
  stop() {
    this._stopped = true;
    cancelAnimationFrame(this._stepAnimationFrame);
  },
  _stepCore() {
    if (this._isStopped()) {
      this._stop();
      return;
    }
    if (this._isFinished()) {
      this._finished = true;
      this._complete();
      return;
    }
    this._step();
    this._stepAnimationFrame = requestAnimationFrame(this._proxiedStepCore);
  },
  _step: abstract8,
  _isFinished: noop2,
  _stop: noop2,
  _complete: noop2,
  _isStopped() {
    return this._stopped;
  },
  inProgress() {
    return !(this._stopped || this._finished);
  }
});
var m_animator_default = Animator;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.simulated.js
var SCROLLABLE_SIMULATED = "dxSimulatedScrollable";
var SCROLLABLE_STRATEGY = "dxScrollableStrategy";
var SCROLLABLE_SIMULATED_CURSOR = `${SCROLLABLE_SIMULATED}Cursor`;
var SCROLLABLE_SIMULATED_KEYBOARD = `${SCROLLABLE_SIMULATED}Keyboard`;
var SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = "dx-scrollable-scrollbars-alwaysvisible";
var VERTICAL2 = "vertical";
var HORIZONTAL3 = "horizontal";
var FRAME_DURATION = Math.round(1e3 / 60);
var BOUNCE_FRAMES = 400 / FRAME_DURATION;
var BOUNCE_ACCELERATION_SUM = (1 - 0.92 ** BOUNCE_FRAMES) / (1 - 0.92);
var KEY_CODES = {
  PAGE_UP: "pageUp",
  PAGE_DOWN: "pageDown",
  END: "end",
  HOME: "home",
  LEFT: "leftArrow",
  UP: "upArrow",
  RIGHT: "rightArrow",
  DOWN: "downArrow",
  TAB: "tab"
};
var InertiaAnimator = m_animator_default.inherit({
  ctor(scroller) {
    this.callBase();
    this.scroller = scroller;
  },
  VELOCITY_LIMIT: 1,
  _isFinished() {
    return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;
  },
  _step() {
    this.scroller._scrollStep(this.scroller._velocity);
    this.scroller._velocity *= this._acceleration();
  },
  _acceleration() {
    return this.scroller._inBounds() ? 0.92 : 0.5;
  },
  _complete() {
    this.scroller._scrollComplete();
  }
});
var BounceAnimator = InertiaAnimator.inherit({
  VELOCITY_LIMIT: 0.2,
  _isFinished() {
    return this.scroller._crossBoundOnNextStep() || this.callBase();
  },
  _acceleration: () => 0.92,
  _complete() {
    this.scroller._move(this.scroller._bounceLocation);
    this.callBase();
  }
});
var Scroller = class_default.inherit({
  ctor(options2) {
    this._initOptions(options2);
    this._initAnimators();
    this._initScrollbar();
  },
  _initOptions(options2) {
    this._location = 0;
    this._topReached = false;
    this._bottomReached = false;
    this._axis = options2.direction === HORIZONTAL3 ? "x" : "y";
    this._prop = options2.direction === HORIZONTAL3 ? "left" : "top";
    this._dimension = options2.direction === HORIZONTAL3 ? "width" : "height";
    this._scrollProp = options2.direction === HORIZONTAL3 ? "scrollLeft" : "scrollTop";
    each(options2, (optionName, optionValue) => {
      this[`_${optionName}`] = optionValue;
    });
  },
  _initAnimators() {
    this._inertiaAnimator = new InertiaAnimator(this);
    this._bounceAnimator = new BounceAnimator(this);
  },
  _initScrollbar() {
    this._scrollbar = new m_scrollbar_default(renderer_default("<div>").appendTo(this._$container), {
      direction: this._direction,
      visible: this._scrollByThumb,
      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
      expandable: this._scrollByThumb
    });
    this._$scrollbar = this._scrollbar.$element();
  },
  _visibilityModeNormalize: (mode) => true === mode ? "onScroll" : false === mode ? "never" : mode,
  _scrollStep(delta) {
    const prevLocation = this._location;
    this._location += delta;
    this._suppressBounce();
    this._move();
    if (Math.abs(prevLocation - this._location) < 1) {
      return;
    }
    events_engine_default.triggerHandler(this._$container, {
      type: "scroll"
    });
  },
  _suppressBounce() {
    if (this._bounceEnabled || this._inBounds(this._location)) {
      return;
    }
    this._velocity = 0;
    this._location = this._boundLocation();
  },
  _boundLocation(location) {
    location = void 0 !== location ? location : this._location;
    return Math.max(Math.min(location, this._maxOffset), this._minOffset);
  },
  _move(location) {
    this._location = void 0 !== location ? location * this._getScaleRatio() : this._location;
    this._moveContent();
    this._moveScrollbar();
  },
  _moveContent() {
    const location = this._location;
    this._$container[this._scrollProp](-location / this._getScaleRatio());
    this._moveContentByTranslator(location);
  },
  _getScaleRatio() {
    if (hasWindow() && !this._scaleRatio) {
      const element = this._$element.get(0);
      const realDimension = this._getRealDimension(element, this._dimension);
      const baseDimension = this._getBaseDimension(element, this._dimension);
      this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100;
    }
    return this._scaleRatio || 1;
  },
  _getRealDimension: (element, dimension) => Math.round(getBoundingRect(element)[dimension]),
  _getBaseDimension(element, dimension) {
    const dimensionName = `offset${titleize(dimension)}`;
    return element[dimensionName];
  },
  _moveContentByTranslator(location) {
    let translateOffset;
    const minOffset = -this._maxScrollPropValue;
    if (location > 0) {
      translateOffset = location;
    } else if (location <= minOffset) {
      translateOffset = location - minOffset;
    } else {
      translateOffset = location % 1;
    }
    if (this._translateOffset === translateOffset) {
      return;
    }
    const targetLocation = {};
    targetLocation[this._prop] = translateOffset;
    this._translateOffset = translateOffset;
    if (0 === translateOffset) {
      resetPosition(this._$content);
      return;
    }
    move(this._$content, targetLocation);
  },
  _moveScrollbar() {
    this._scrollbar.moveTo(this._location);
  },
  _scrollComplete() {
    if (this._inBounds()) {
      this._hideScrollbar();
      if (this._completeDeferred) {
        this._completeDeferred.resolve();
      }
    }
    this._scrollToBounds();
  },
  _scrollToBounds() {
    if (this._inBounds()) {
      return;
    }
    this._bounceAction();
    this._setupBounce();
    this._bounceAnimator.start();
  },
  _setupBounce() {
    const boundLocation = this._bounceLocation = this._boundLocation();
    const bounceDistance = boundLocation - this._location;
    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;
  },
  _inBounds(location) {
    location = void 0 !== location ? location : this._location;
    return this._boundLocation(location) === location;
  },
  _crossBoundOnNextStep() {
    const location = this._location;
    const nextLocation = location + this._velocity;
    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;
  },
  _initHandler(e) {
    this._stopScrolling();
    this._prepareThumbScrolling(e);
  },
  _stopScrolling: deferRenderer(function() {
    this._hideScrollbar();
    this._inertiaAnimator.stop();
    this._bounceAnimator.stop();
  }),
  _prepareThumbScrolling(e) {
    if (isDxMouseWheelEvent(e.originalEvent)) {
      return;
    }
    const $target = renderer_default(e.originalEvent.target);
    const scrollbarClicked = this._isScrollbar($target);
    if (scrollbarClicked) {
      this._moveToMouseLocation(e);
    }
    this._thumbScrolling = scrollbarClicked || this._isThumb($target);
    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
    if (this._thumbScrolling) {
      this._scrollbar.feedbackOn();
    }
  },
  _isThumbScrollingHandler($target) {
    return this._isThumb($target);
  },
  _moveToMouseLocation(e) {
    const mouseLocation = e[`page${this._axis.toUpperCase()}`] - this._$element.offset()[this._prop];
    const location = this._location + mouseLocation / this._containerToContentRatio() - getHeight(this._$container) / 2;
    this._scrollStep(-Math.round(location));
  },
  _startHandler() {
    this._showScrollbar();
  },
  _moveHandler(delta) {
    if (this._crossThumbScrolling) {
      return;
    }
    if (this._thumbScrolling) {
      delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());
    }
    this._scrollBy(delta);
  },
  _scrollBy(delta) {
    delta = delta[this._axis];
    if (!this._inBounds()) {
      delta *= 0.5;
    }
    this._scrollStep(delta);
  },
  _scrollByHandler(delta) {
    this._scrollBy(delta);
    this._scrollComplete();
  },
  _containerToContentRatio() {
    return this._scrollbar.containerToContentRatio();
  },
  _endHandler(velocity) {
    this._completeDeferred = Deferred();
    this._velocity = velocity[this._axis];
    this._inertiaHandler();
    this._resetThumbScrolling();
    return this._completeDeferred.promise();
  },
  _inertiaHandler() {
    this._suppressInertia();
    this._inertiaAnimator.start();
  },
  _suppressInertia() {
    if (!this._inertiaEnabled || this._thumbScrolling) {
      this._velocity = 0;
    }
  },
  _resetThumbScrolling() {
    this._thumbScrolling = false;
    this._crossThumbScrolling = false;
  },
  _stopHandler() {
    if (this._thumbScrolling) {
      this._scrollComplete();
    }
    this._resetThumbScrolling();
    this._scrollToBounds();
  },
  _disposeHandler() {
    this._stopScrolling();
    this._$scrollbar.remove();
  },
  _updateHandler() {
    this._update();
    this._moveToBounds();
  },
  _update() {
    this._stopScrolling();
    return deferUpdate(() => {
      this._resetScaleRatio();
      this._updateLocation();
      this._updateBounds();
      this._updateScrollbar();
      deferRender(() => {
        this._moveScrollbar();
        this._scrollbar.update();
      });
    });
  },
  _resetScaleRatio() {
    this._scaleRatio = null;
  },
  _updateLocation() {
    this._location = (locate(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();
  },
  _updateBounds() {
    this._maxOffset = this._getMaxOffset();
    this._minOffset = this._getMinOffset();
  },
  _getMaxOffset: () => 0,
  _getMinOffset() {
    this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);
    return -this._maxScrollPropValue;
  },
  _updateScrollbar: deferUpdater(function() {
    const containerSize = this._containerSize();
    const contentSize = this._contentSize();
    const baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);
    const baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);
    deferRender(() => {
      this._scrollbar.option({
        containerSize,
        contentSize,
        baseContainerSize,
        baseContentSize,
        scaleRatio: this._getScaleRatio()
      });
    });
  }),
  _moveToBounds: deferRenderer(deferUpdater(deferRenderer(function() {
    const location = this._boundLocation();
    const locationChanged = location !== this._location;
    this._location = location;
    this._move();
    if (locationChanged) {
      this._scrollAction();
    }
  }))),
  _createActionsHandler(actions) {
    this._scrollAction = actions.scroll;
    this._bounceAction = actions.bounce;
  },
  _showScrollbar() {
    this._scrollbar.option("visible", true);
  },
  _hideScrollbar() {
    this._scrollbar.option("visible", false);
  },
  _containerSize() {
    return this._getRealDimension(this._$container.get(0), this._dimension);
  },
  _contentSize() {
    const isOverflowHidden = "hidden" === this._$content.css(`overflow${this._axis.toUpperCase()}`);
    let contentSize = this._getRealDimension(this._$content.get(0), this._dimension);
    if (!isOverflowHidden) {
      const containerScrollSize = this._$content[0][`scroll${titleize(this._dimension)}`] * this._getScaleRatio();
      contentSize = Math.max(containerScrollSize, contentSize);
    }
    return contentSize;
  },
  _validateEvent(e) {
    const $target = renderer_default(e.originalEvent.target);
    return this._isThumb($target) || this._isScrollbar($target);
  },
  _isThumb($element) {
    return this._scrollByThumb && this._scrollbar.isThumb($element);
  },
  _isScrollbar($element) {
    return this._scrollByThumb && $element && $element.is(this._$scrollbar);
  },
  _reachedMin() {
    return Math.round(this._location - this._minOffset) <= 0;
  },
  _reachedMax() {
    return Math.round(this._location - this._maxOffset) >= 0;
  },
  _cursorEnterHandler() {
    this._resetScaleRatio();
    this._updateScrollbar();
    this._scrollbar.cursorEnter();
  },
  _cursorLeaveHandler() {
    this._scrollbar.cursorLeave();
  },
  dispose: noop2
});
var hoveredScrollable;
var activeScrollable;
var SimulatedStrategy = class_default.inherit({
  ctor(scrollable) {
    this._init(scrollable);
  },
  _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = renderer_default(scrollable.container());
    this._$wrapper = scrollable._$wrapper;
    this._$content = scrollable.$content();
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
  },
  render() {
    this._$element.addClass("dx-scrollable-simulated");
    this._createScrollers();
    if (this.option("useKeyboard")) {
      this._$container.prop("tabIndex", 0);
    }
    this._attachKeyboardHandler();
    this._attachCursorHandlers();
  },
  _createScrollers() {
    this._scrollers = {};
    if (this._isDirection(HORIZONTAL3)) {
      this._createScroller(HORIZONTAL3);
    }
    if (this._isDirection(VERTICAL2)) {
      this._createScroller(VERTICAL2);
    }
    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, "always" === this.option("showScrollbar"));
  },
  _createScroller(direction) {
    this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));
  },
  _scrollerOptions(direction) {
    return {
      direction,
      $content: this._$content,
      $container: this._$container,
      $wrapper: this._$wrapper,
      $element: this._$element,
      scrollByThumb: this.option("scrollByThumb"),
      scrollbarVisible: this.option("showScrollbar"),
      bounceEnabled: this.option("bounceEnabled"),
      inertiaEnabled: this.option("inertiaEnabled"),
      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)
    };
  },
  _applyScaleRatio(targetLocation) {
    for (const direction in this._scrollers) {
      const prop = this._getPropByDirection(direction);
      if (isDefined(targetLocation[prop])) {
        const scroller = this._scrollers[direction];
        targetLocation[prop] *= scroller._getScaleRatio();
      }
    }
    return targetLocation;
  },
  _isAnyThumbScrolling($target) {
    let result2 = false;
    this._eventHandler("isThumbScrolling", $target).done((isThumbScrollingVertical, isThumbScrollingHorizontal) => {
      result2 = isThumbScrollingVertical || isThumbScrollingHorizontal;
    });
    return result2;
  },
  handleInit(e) {
    this._suppressDirections(e);
    this._eventForUserAction = e;
    this._eventHandler("init", e);
  },
  _suppressDirections(e) {
    if (isDxMouseWheelEvent(e.originalEvent)) {
      this._prepareDirections(true);
      return;
    }
    this._prepareDirections();
    this._eachScroller(function(scroller, direction) {
      const $target = renderer_default(e.originalEvent.target);
      const isValid = scroller._validateEvent(e) || this.option("scrollByContent") && this._isContent($target);
      this._validDirections[direction] = isValid;
    });
  },
  _isContent($element) {
    return !!$element.closest(this._$element).length;
  },
  _prepareDirections(value2) {
    value2 = value2 || false;
    this._validDirections = {};
    this._validDirections[HORIZONTAL3] = value2;
    this._validDirections[VERTICAL2] = value2;
  },
  _eachScroller(callback) {
    callback = callback.bind(this);
    each(this._scrollers, (direction, scroller) => {
      callback(scroller, direction);
    });
  },
  handleStart(e) {
    this._eventForUserAction = e;
    this._eventHandler("start").done(this._startAction);
  },
  _saveActive() {
    activeScrollable = this;
  },
  _resetActive() {
    if (activeScrollable === this) {
      activeScrollable = null;
    }
  },
  handleMove(e) {
    if (this._isLocked()) {
      e.cancel = true;
      this._resetActive();
      return;
    }
    this._saveActive();
    e.preventDefault && e.preventDefault();
    this._adjustDistance(e, e.delta);
    this._eventForUserAction = e;
    this._eventHandler("move", e.delta);
  },
  _adjustDistance(e, distance) {
    distance.x *= this._validDirections[HORIZONTAL3];
    distance.y *= this._validDirections[VERTICAL2];
    const devicePixelRatio = this._tryGetDevicePixelRatio();
    if (devicePixelRatio && isDxMouseWheelEvent(e.originalEvent)) {
      distance.x = Math.round(distance.x / devicePixelRatio * 100) / 100;
      distance.y = Math.round(distance.y / devicePixelRatio * 100) / 100;
    }
  },
  _tryGetDevicePixelRatio() {
    if (hasWindow()) {
      return getWindow().devicePixelRatio;
    }
  },
  handleEnd(e) {
    this._resetActive();
    this._refreshCursorState(e.originalEvent && e.originalEvent.target);
    this._adjustDistance(e, e.velocity);
    this._eventForUserAction = e;
    return this._eventHandler("end", e.velocity).done(this._endAction);
  },
  handleCancel(e) {
    this._resetActive();
    this._eventForUserAction = e;
    return this._eventHandler("end", {
      x: 0,
      y: 0
    });
  },
  handleStop() {
    this._resetActive();
    this._eventHandler("stop");
  },
  handleScroll() {
    this._updateRtlConfig();
    this._scrollAction();
  },
  _attachKeyboardHandler() {
    events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_KEYBOARD}`);
    if (!this.option("disabled") && this.option("useKeyboard")) {
      events_engine_default.on(this._$element, addNamespace2("keydown", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));
    }
  },
  _keyDownHandler(e) {
    clearTimeout(this._updateHandlerTimeout);
    this._updateHandlerTimeout = setTimeout(() => {
      if (normalizeKeyName(e) === KEY_CODES.TAB) {
        this._eachScroller((scroller) => {
          scroller._updateHandler();
        });
      }
    });
    if (!this._$container.is(dom_adapter_default.getActiveElement(this._$container.get(0)))) {
      return;
    }
    let handled = true;
    switch (normalizeKeyName(e)) {
      case KEY_CODES.DOWN:
        this._scrollByLine({
          y: 1
        });
        break;
      case KEY_CODES.UP:
        this._scrollByLine({
          y: -1
        });
        break;
      case KEY_CODES.RIGHT:
        this._scrollByLine({
          x: 1
        });
        break;
      case KEY_CODES.LEFT:
        this._scrollByLine({
          x: -1
        });
        break;
      case KEY_CODES.PAGE_DOWN:
        this._scrollByPage(1);
        break;
      case KEY_CODES.PAGE_UP:
        this._scrollByPage(-1);
        break;
      case KEY_CODES.HOME:
        this._scrollToHome();
        break;
      case KEY_CODES.END:
        this._scrollToEnd();
        break;
      default:
        handled = false;
    }
    if (handled) {
      e.stopPropagation();
      e.preventDefault();
    }
  },
  _scrollByLine(lines) {
    const devicePixelRatio = this._tryGetDevicePixelRatio();
    let scrollOffset = 40;
    if (devicePixelRatio) {
      scrollOffset = Math.abs(scrollOffset / devicePixelRatio * 100) / 100;
    }
    this.scrollBy({
      top: (lines.y || 0) * -scrollOffset,
      left: (lines.x || 0) * -scrollOffset
    });
  },
  _scrollByPage(page) {
    const prop = this._wheelProp();
    const dimension = this._dimensionByProp(prop);
    const distance = {};
    const getter = "width" === dimension ? getWidth : getHeight;
    distance[prop] = page * -getter(this._$container);
    this.scrollBy(distance);
  },
  _dimensionByProp: (prop) => "left" === prop ? "width" : "height",
  _getPropByDirection: (direction) => direction === HORIZONTAL3 ? "left" : "top",
  _scrollToHome() {
    const prop = this._wheelProp();
    const distance = {};
    distance[prop] = 0;
    this._component.scrollTo(distance);
  },
  _scrollToEnd() {
    const prop = this._wheelProp();
    const dimension = this._dimensionByProp(prop);
    const distance = {};
    const getter = "width" === dimension ? getWidth : getHeight;
    distance[prop] = getter(this._$content) - getter(this._$container);
    this._component.scrollTo(distance);
  },
  createActions() {
    this._startAction = this._createActionHandler("onStart");
    this._endAction = this._createActionHandler("onEnd");
    this._updateAction = this._createActionHandler("onUpdated");
    this._createScrollerActions();
  },
  _createScrollerActions() {
    this._scrollAction = this._createActionHandler("onScroll");
    this._bounceAction = this._createActionHandler("onBounce");
    this._eventHandler("createActions", {
      scroll: this._scrollAction,
      bounce: this._bounceAction
    });
  },
  _createActionHandler(optionName) {
    const actionHandler = this._createActionByOption(optionName);
    return () => {
      actionHandler(extend(this._createActionArgs(), arguments));
    };
  },
  _createActionArgs() {
    const {
      horizontal: scrollerX,
      vertical: scrollerY
    } = this._scrollers;
    const offset2 = this._getScrollOffset();
    this._scrollOffset = {
      top: scrollerY && offset2.top,
      left: scrollerX && offset2.left
    };
    return {
      event: this._eventForUserAction,
      scrollOffset: this._scrollOffset,
      reachedLeft: scrollerX && scrollerX._reachedMax(),
      reachedRight: scrollerX && scrollerX._reachedMin(),
      reachedTop: scrollerY && scrollerY._reachedMax(),
      reachedBottom: scrollerY && scrollerY._reachedMin()
    };
  },
  _getScrollOffset() {
    return {
      top: -this.location().top,
      left: -this.location().left
    };
  },
  _eventHandler(eventName) {
    const args = [].slice.call(arguments).slice(1);
    const deferreds = map(this._scrollers, (scroller) => scroller[`_${eventName}Handler`].apply(scroller, args));
    return when.apply(renderer_default, deferreds).promise();
  },
  location() {
    const location = locate(this._$content);
    location.top -= this._$container.scrollTop();
    location.left -= this._$container.scrollLeft();
    return location;
  },
  disabledChanged() {
    this._attachCursorHandlers();
  },
  _attachCursorHandlers() {
    events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_CURSOR}`);
    if (!this.option("disabled") && this._isHoverMode()) {
      events_engine_default.on(this._$element, addNamespace2("mouseenter", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));
      events_engine_default.on(this._$element, addNamespace2("mouseleave", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));
    }
  },
  _isHoverMode() {
    return "onHover" === this.option("showScrollbar");
  },
  _cursorEnterHandler(e) {
    e = e || {};
    e.originalEvent = e.originalEvent || {};
    if (activeScrollable || e.originalEvent._hoverHandled) {
      return;
    }
    if (hoveredScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    hoveredScrollable = this;
    this._eventHandler("cursorEnter");
    e.originalEvent._hoverHandled = true;
  },
  _cursorLeaveHandler(e) {
    if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {
      return;
    }
    this._eventHandler("cursorLeave");
    hoveredScrollable = null;
    this._refreshCursorState(e && e.relatedTarget);
  },
  _refreshCursorState(target) {
    if (!this._isHoverMode() && (!target || activeScrollable)) {
      return;
    }
    const $target = renderer_default(target);
    const $scrollable = $target.closest(".dx-scrollable-simulated:not(.dx-state-disabled)");
    const targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
    if (hoveredScrollable && hoveredScrollable !== targetScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    if (targetScrollable) {
      targetScrollable._cursorEnterHandler();
    }
  },
  update() {
    const result2 = this._eventHandler("update").done(this._updateAction);
    return when(result2, deferUpdate(() => {
      const allowedDirections = this._allowedDirections();
      deferRender(() => {
        let touchDirection = allowedDirections.vertical ? "pan-x" : "";
        touchDirection = allowedDirections.horizontal ? "pan-y" : touchDirection;
        touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? "none" : touchDirection;
        this._$container.css("touchAction", touchDirection);
      });
      return when().promise();
    }));
  },
  _allowedDirections() {
    const bounceEnabled = this.option("bounceEnabled");
    const verticalScroller = this._scrollers[VERTICAL2];
    const horizontalScroller = this._scrollers[HORIZONTAL3];
    return {
      vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
      horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
    };
  },
  _updateBounds() {
    this._scrollers[HORIZONTAL3] && this._scrollers[HORIZONTAL3]._updateBounds();
  },
  _isHorizontalAndRtlEnabled() {
    return this.option("rtlEnabled") && this.option("direction") !== VERTICAL2;
  },
  updateRtlPosition(needInitializeRtlConfig) {
    if (needInitializeRtlConfig) {
      this._rtlConfig = {
        scrollRight: 0,
        clientWidth: this._$container.get(0).clientWidth,
        windowPixelRatio: this._getWindowDevicePixelRatio()
      };
    }
    this._updateBounds();
    if (this._isHorizontalAndRtlEnabled()) {
      let scrollLeft = this._getMaxOffset().left - this._rtlConfig.scrollRight;
      if (scrollLeft <= 0) {
        scrollLeft = 0;
        this._rtlConfig.scrollRight = this._getMaxOffset().left;
      }
      if (this._getScrollOffset().left !== scrollLeft) {
        this._rtlConfig.skipUpdating = true;
        this._component.scrollTo({
          left: scrollLeft
        });
        this._rtlConfig.skipUpdating = false;
      }
    }
  },
  _updateRtlConfig() {
    if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {
      const {
        clientWidth,
        scrollLeft
      } = this._$container.get(0);
      const windowPixelRatio = this._getWindowDevicePixelRatio();
      if (this._rtlConfig.windowPixelRatio === windowPixelRatio && this._rtlConfig.clientWidth === clientWidth) {
        this._rtlConfig.scrollRight = this._getMaxOffset().left - scrollLeft;
      }
      this._rtlConfig.clientWidth = clientWidth;
      this._rtlConfig.windowPixelRatio = windowPixelRatio;
    }
  },
  _getWindowDevicePixelRatio: () => hasWindow() ? getWindow().devicePixelRatio : 1,
  scrollBy(distance) {
    const verticalScroller = this._scrollers[VERTICAL2];
    const horizontalScroller = this._scrollers[HORIZONTAL3];
    if (verticalScroller) {
      distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;
    }
    if (horizontalScroller) {
      distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;
    }
    this._prepareDirections(true);
    this._startAction();
    this._eventHandler("scrollBy", {
      x: distance.left,
      y: distance.top
    });
    this._endAction();
    this._updateRtlConfig();
  },
  validate(e) {
    if (isDxMouseWheelEvent(e) && isCommandKeyPressed(e)) {
      return false;
    }
    if (this.option("disabled")) {
      return false;
    }
    if (this.option("bounceEnabled")) {
      return true;
    }
    return isDxMouseWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e);
  },
  _validateWheel(e) {
    const scroller = this._scrollers[this._wheelDirection(e)];
    const reachedMin = scroller._reachedMin();
    const reachedMax = scroller._reachedMax();
    const contentGreaterThanContainer = !reachedMin || !reachedMax;
    const locatedNotAtBound = !reachedMin && !reachedMax;
    const scrollFromMin = reachedMin && e.delta > 0;
    const scrollFromMax = reachedMax && e.delta < 0;
    let validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);
    validated = validated || void 0 !== this._validateWheelTimer;
    if (validated) {
      clearTimeout(this._validateWheelTimer);
      this._validateWheelTimer = setTimeout(() => {
        this._validateWheelTimer = void 0;
      }, 500);
    }
    return validated;
  },
  _validateMove(e) {
    if (!this.option("scrollByContent") && !renderer_default(e.target).closest(".dx-scrollable-scrollbar").length) {
      return false;
    }
    return this._allowedDirection();
  },
  getDirection(e) {
    return isDxMouseWheelEvent(e) ? this._wheelDirection(e) : this._allowedDirection();
  },
  _wheelProp() {
    return this._wheelDirection() === HORIZONTAL3 ? "left" : "top";
  },
  _wheelDirection(e) {
    switch (this.option("direction")) {
      case HORIZONTAL3:
        return HORIZONTAL3;
      case VERTICAL2:
        return VERTICAL2;
      default:
        return e && e.shiftKey ? HORIZONTAL3 : VERTICAL2;
    }
  },
  dispose() {
    this._resetActive();
    if (hoveredScrollable === this) {
      hoveredScrollable = null;
    }
    this._eventHandler("dispose");
    this._detachEventHandlers();
    this._$element.removeClass("dx-scrollable-simulated");
    this._eventForUserAction = null;
    clearTimeout(this._validateWheelTimer);
    clearTimeout(this._updateHandlerTimeout);
  },
  _detachEventHandlers() {
    events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_CURSOR}`);
    events_engine_default.off(this._$container, `.${SCROLLABLE_SIMULATED_KEYBOARD}`);
  }
});

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.simulated.js
var math2 = Math;
var ScrollViewScroller = Scroller.inherit({
  ctor() {
    this._topPocketSize = 0;
    this._bottomPocketSize = 0;
    this.callBase.apply(this, arguments);
    this._initCallbacks();
    this._releaseState();
  },
  _releaseState() {
    this._state = 0;
    this._refreshPullDownText();
  },
  _refreshPullDownText() {
    const that = this;
    const pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: 0
    }, {
      element: this._$pulledDownText,
      visibleState: 1
    }, {
      element: this._$refreshingText,
      visibleState: 2
    }];
    each(pullDownTextItems, (_, item) => {
      const action = that._state === item.visibleState ? "addClass" : "removeClass";
      item.element[action]("dx-scrollview-pull-down-text-visible");
    });
  },
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  },
  _updateBounds() {
    const considerPockets = "horizontal" !== this._direction;
    if (considerPockets) {
      this._topPocketSize = this._$topPocket.get(0).clientHeight;
      this._bottomPocketSize = this._$bottomPocket.get(0).clientHeight;
      const containerEl = this._$container.get(0);
      const contentEl = this._$content.get(0);
      this._bottomBoundary = Math.max(contentEl.clientHeight - this._bottomPocketSize - containerEl.clientHeight, 0);
    }
    this.callBase();
  },
  _updateScrollbar() {
    this._scrollbar.option({
      containerSize: this._containerSize(),
      contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize,
      scaleRatio: this._getScaleRatio()
    });
  },
  _moveContent() {
    this.callBase();
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (this._isReachBottom()) {
      this._reachBottomReady();
    } else if (0 !== this._state) {
      this._stateReleased();
    }
  },
  _moveScrollbar() {
    this._scrollbar.moveTo(this._topPocketSize + this._location);
  },
  _isPullDown() {
    return this._pullDownEnabled && this._location >= 0;
  },
  _isReachBottom() {
    const containerEl = this._$container.get(0);
    return this._reachBottomEnabled && Math.round(this._bottomBoundary - Math.ceil(containerEl.scrollTop)) <= 1;
  },
  _scrollComplete() {
    if (this._inBounds() && 1 === this._state) {
      this._pullDownRefreshing();
    } else if (this._inBounds() && 3 === this._state) {
      this._reachBottomLoading();
    } else {
      this.callBase();
    }
  },
  _reachBottomReady() {
    if (3 === this._state) {
      return;
    }
    this._state = 3;
    this._minOffset = this._getMinOffset();
  },
  _getMaxOffset() {
    return -this._topPocketSize;
  },
  _getMinOffset() {
    return math2.min(this.callBase(), -this._topPocketSize);
  },
  _reachBottomLoading() {
    this.reachBottomCallbacks.fire();
  },
  _pullDownReady() {
    if (1 === this._state) {
      return;
    }
    this._state = 1;
    this._maxOffset = 0;
    this._$pullDown.addClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
  },
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._releaseState();
    this._updateBounds();
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this.releaseCallbacks.fire();
  },
  _pullDownRefreshing() {
    if (2 === this._state) {
      return;
    }
    this._state = 2;
    this._$pullDown.addClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  },
  _releaseHandler() {
    if (0 === this._state) {
      this._moveToBounds();
    }
    this._update();
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this._releaseTask = executeAsync(this._release.bind(this));
    return this._releaseTask.promise;
  },
  _release() {
    this._stateReleased();
    this._scrollComplete();
  },
  _reachBottomEnablingHandler(enabled) {
    if (this._reachBottomEnabled === enabled) {
      return;
    }
    this._reachBottomEnabled = enabled;
    this._updateBounds();
  },
  _pullDownEnablingHandler(enabled) {
    if (this._pullDownEnabled === enabled) {
      return;
    }
    this._pullDownEnabled = enabled;
    this._considerTopPocketChange();
    this._updateHandler();
  },
  _considerTopPocketChange() {
    this._location -= getHeight(this._$topPocket) || -this._topPocketSize;
    this._maxOffset = 0;
    this._move();
  },
  _pendingReleaseHandler() {
    this._state = 1;
  },
  dispose() {
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this.callBase();
  }
});
var SimulatedScrollViewStrategy = SimulatedStrategy.inherit({
  _init(scrollView) {
    this.callBase(scrollView);
    this._$pullDown = scrollView._$pullDown;
    this._$topPocket = scrollView._$topPocket;
    this._$bottomPocket = scrollView._$bottomPocket;
    this._initCallbacks();
  },
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  },
  render() {
    this._renderPullDown();
    this.callBase();
  },
  _renderPullDown() {
    const $image = renderer_default("<div>").addClass("dx-scrollview-pull-down-image");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    const $text = this._$pullDownText = renderer_default("<div>").addClass("dx-scrollview-pull-down-text");
    this._$pullingDownText = renderer_default("<div>").text(this.option("pullingDownText")).appendTo($text);
    this._$pulledDownText = renderer_default("<div>").text(this.option("pulledDownText")).appendTo($text);
    this._$refreshingText = renderer_default("<div>").text(this.option("refreshingText")).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  },
  pullDownEnable(enabled) {
    this._eventHandler("pullDownEnabling", enabled);
  },
  reachBottomEnable(enabled) {
    this._eventHandler("reachBottomEnabling", enabled);
  },
  _createScroller(direction) {
    const that = this;
    const scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
    scroller.pullDownCallbacks.add(() => {
      that.pullDownCallbacks.fire();
    });
    scroller.releaseCallbacks.add(() => {
      that.releaseCallbacks.fire();
    });
    scroller.reachBottomCallbacks.add(() => {
      that.reachBottomCallbacks.fire();
    });
  },
  _scrollerOptions(direction) {
    return extend(this.callBase(direction), {
      $topPocket: this._$topPocket,
      $bottomPocket: this._$bottomPocket,
      $pullDown: this._$pullDown,
      $pullDownText: this._$pullDownText,
      $pullingDownText: this._$pullingDownText,
      $pulledDownText: this._$pulledDownText,
      $refreshingText: this._$refreshingText
    });
  },
  pendingRelease() {
    this._eventHandler("pendingRelease");
  },
  release() {
    return this._eventHandler("release").done(this._updateAction);
  },
  location() {
    const location = this.callBase();
    location.top += getHeight(this._$topPocket);
    return location;
  },
  dispose() {
    each(this._scrollers, function() {
      this.dispose();
    });
    this.callBase();
  }
});
var m_scroll_view_simulated_default = SimulatedScrollViewStrategy;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_relative_offset.js
function getRelativeOffset(targetElementClass, sourceElement) {
  const offset2 = {
    left: 0,
    top: 0
  };
  let element = sourceElement;
  while (null !== (_element = element) && void 0 !== _element && _element.offsetParent && !element.classList.contains(targetElementClass)) {
    var _element;
    const parentElement = element.offsetParent;
    const elementRect = element.getBoundingClientRect();
    const parentElementRect = parentElement.getBoundingClientRect();
    offset2.left += elementRect.left - parentElementRect.left;
    offset2.top += elementRect.top - parentElementRect.top;
    element = element.offsetParent;
  }
  return offset2;
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/common/consts.js
var DIRECTION_VERTICAL = "vertical";
var DIRECTION_HORIZONTAL = "horizontal";
var DIRECTION_BOTH = "both";
var SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content";

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_element_location_internal.js
function getElementLocationInternal(targetElement, direction, containerElement, scrollOffset, offset2) {
  const additionalOffset = _extends({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }, offset2);
  const isVertical = direction === DIRECTION_VERTICAL;
  const prop = isVertical ? "top" : "left";
  const inverseProp = isVertical ? "bottom" : "right";
  const dimension = isVertical ? "height" : "width";
  const containerOffsetSize = containerElement[`offset${titleize(dimension)}`];
  const containerClientSize = containerElement[`client${titleize(dimension)}`];
  const containerSize = containerElement.getBoundingClientRect()[dimension];
  const elementSize2 = targetElement.getBoundingClientRect()[dimension];
  let scale = 1;
  if (Math.abs(containerSize - containerOffsetSize) > 1) {
    scale = containerSize / containerOffsetSize;
  }
  const relativeElementOffset = getRelativeOffset(SCROLLABLE_CONTENT_CLASS, targetElement)[prop] / scale;
  const containerScrollOffset = scrollOffset[prop];
  const relativeStartOffset = containerScrollOffset - relativeElementOffset + additionalOffset[prop];
  const relativeEndOffset = containerScrollOffset - relativeElementOffset - elementSize2 / scale + containerClientSize - additionalOffset[inverseProp];
  if (relativeStartOffset <= 0 && relativeEndOffset >= 0) {
    return containerScrollOffset;
  }
  return containerScrollOffset - (Math.abs(relativeStartOffset) > Math.abs(relativeEndOffset) ? relativeEndOffset : relativeStartOffset);
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.device.js
var deviceDependentOptions = function() {
  return [{
    device: () => !nativeScrolling,
    options: {
      useNative: false
    }
  }, {
    device: (device) => !devices_default.isSimulator() && "desktop" === devices_default.real().deviceType && "generic" === device.platform,
    options: {
      bounceEnabled: false,
      scrollByThumb: true,
      scrollByContent: touch,
      showScrollbar: "onHover"
    }
  }];
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.js
var SCROLLABLE = "dxScrollable";
var SCROLLABLE_STRATEGY2 = "dxScrollableStrategy";
var VERTICAL3 = "vertical";
var HORIZONTAL4 = "horizontal";
var BOTH = "both";
var Scrollable = dom_component_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      disabled: false,
      onScroll: null,
      direction: VERTICAL3,
      showScrollbar: "onScroll",
      useNative: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      onUpdated: null,
      onStart: null,
      onEnd: null,
      onBounce: null,
      useSimulatedScrollbar: false,
      useKeyboard: true,
      inertiaEnabled: true,
      updateManually: false,
      _onVisibilityChanged: noop2
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat(deviceDependentOptions(), [{
      device: () => nativeScrolling && "android" === devices_default.real().platform && !browser_default.mozilla,
      options: {
        useSimulatedScrollbar: true
      }
    }]);
  },
  _initOptions(options2) {
    this.callBase(options2);
    if (!("useSimulatedScrollbar" in options2)) {
      this._setUseSimulatedScrollbar();
    }
  },
  _setUseSimulatedScrollbar() {
    if (!this.initialOption("useSimulatedScrollbar")) {
      this.option("useSimulatedScrollbar", !this.option("useNative"));
    }
  },
  _init() {
    this.callBase();
    this._initScrollableMarkup();
    this._locked = false;
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this.update();
      this._updateRtlPosition();
      this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
      delete this._savedScrollOffset;
      this.option("_onVisibilityChanged")(this);
    } else {
      this._savedScrollOffset = this.scrollOffset();
    }
  },
  _initScrollableMarkup() {
    const $element = this.$element().addClass("dx-scrollable");
    const $container = this._$container = renderer_default("<div>").addClass("dx-scrollable-container");
    const $wrapper = this._$wrapper = renderer_default("<div>").addClass("dx-scrollable-wrapper");
    const $content = this._$content = renderer_default("<div>").addClass("dx-scrollable-content");
    $content.append($element.contents()).appendTo($container);
    $container.appendTo($wrapper);
    $wrapper.appendTo($element);
  },
  _dimensionChanged() {
    this.update();
    this._updateRtlPosition();
  },
  _initMarkup() {
    this.callBase();
    this._renderDirection();
  },
  _render() {
    this._renderStrategy();
    this._attachEventHandlers();
    this._renderDisabledState();
    this._createActions();
    this.update();
    this.callBase();
    this._updateRtlPosition(true);
  },
  _updateRtlPosition(needInitializeRtlConfig) {
    this._strategy.updateRtlPosition(needInitializeRtlConfig);
  },
  _getMaxOffset() {
    const {
      scrollWidth,
      clientWidth,
      scrollHeight,
      clientHeight
    } = renderer_default(this.container()).get(0);
    return {
      left: scrollWidth - clientWidth,
      top: scrollHeight - clientHeight
    };
  },
  _attachEventHandlers() {
    const strategy4 = this._strategy;
    const initEventData = {
      getDirection: strategy4.getDirection.bind(strategy4),
      validate: this._validate.bind(this),
      isNative: this.option("useNative"),
      scrollTarget: this._$container
    };
    events_engine_default.off(this._$wrapper, `.${SCROLLABLE}`);
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.init, SCROLLABLE), initEventData, this._initHandler.bind(this));
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.start, SCROLLABLE), strategy4.handleStart.bind(strategy4));
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.move, SCROLLABLE), strategy4.handleMove.bind(strategy4));
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.end, SCROLLABLE), strategy4.handleEnd.bind(strategy4));
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.cancel, SCROLLABLE), strategy4.handleCancel.bind(strategy4));
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.stop, SCROLLABLE), strategy4.handleStop.bind(strategy4));
    events_engine_default.off(this._$container, `.${SCROLLABLE}`);
    events_engine_default.on(this._$container, addNamespace2("scroll", SCROLLABLE), strategy4.handleScroll.bind(strategy4));
  },
  _validate(e) {
    if (this._isLocked()) {
      return false;
    }
    this._updateIfNeed();
    return this._moveIsAllowed(e);
  },
  _moveIsAllowed(e) {
    return this._strategy.validate(e);
  },
  handleMove(e) {
    this._strategy.handleMove(e);
  },
  _prepareDirections(value2) {
    this._strategy._prepareDirections(value2);
  },
  _initHandler() {
    const strategy4 = this._strategy;
    strategy4.handleInit.apply(strategy4, arguments);
  },
  _renderDisabledState() {
    this.$element().toggleClass("dx-scrollable-disabled", this.option("disabled"));
    if (this.option("disabled")) {
      this._lock();
    } else {
      this._unlock();
    }
  },
  _renderDirection() {
    this.$element().removeClass(`dx-scrollable-${HORIZONTAL4}`).removeClass(`dx-scrollable-${VERTICAL3}`).removeClass(`dx-scrollable-${BOTH}`).addClass(`dx-scrollable-${this.option("direction")}`);
  },
  _renderStrategy() {
    this._createStrategy();
    this._strategy.render();
    this.$element().data(SCROLLABLE_STRATEGY2, this._strategy);
  },
  _createStrategy() {
    this._strategy = this.option("useNative") ? new m_scrollable_native_default(this) : new SimulatedStrategy(this);
  },
  _createActions() {
    this._strategy && this._strategy.createActions();
  },
  _clean() {
    this._strategy && this._strategy.dispose();
  },
  _optionChanged(args) {
    switch (args.name) {
      case "onStart":
      case "onEnd":
      case "onUpdated":
      case "onScroll":
      case "onBounce":
        this._createActions();
        break;
      case "direction":
        this._resetInactiveDirection();
        this._invalidate();
        break;
      case "useNative":
        this._setUseSimulatedScrollbar();
        this._invalidate();
        break;
      case "inertiaEnabled":
      case "scrollByThumb":
      case "bounceEnabled":
      case "useKeyboard":
      case "showScrollbar":
      case "useSimulatedScrollbar":
        this._invalidate();
        break;
      case "disabled":
        this._renderDisabledState();
        this._strategy && this._strategy.disabledChanged();
        break;
      case "updateManually":
      case "scrollByContent":
      case "_onVisibilityChanged":
        break;
      case "width":
        this.callBase(args);
        this._updateRtlPosition();
        break;
      default:
        this.callBase(args);
    }
  },
  _resetInactiveDirection() {
    const inactiveProp = this._getInactiveProp();
    if (!inactiveProp || !hasWindow()) {
      return;
    }
    const scrollOffset = this.scrollOffset();
    scrollOffset[inactiveProp] = 0;
    this.scrollTo(scrollOffset);
  },
  _getInactiveProp() {
    const direction = this.option("direction");
    if (direction === VERTICAL3) {
      return "left";
    }
    if (direction === HORIZONTAL4) {
      return "top";
    }
  },
  _location() {
    return this._strategy.location();
  },
  _normalizeLocation(location) {
    if (isPlainObject(location)) {
      const left = ensureDefined(location.left, location.x);
      const top = ensureDefined(location.top, location.y);
      return {
        left: isDefined(left) ? -left : void 0,
        top: isDefined(top) ? -top : void 0
      };
    }
    const direction = this.option("direction");
    return {
      left: direction !== VERTICAL3 ? -location : void 0,
      top: direction !== HORIZONTAL4 ? -location : void 0
    };
  },
  _isLocked() {
    return this._locked;
  },
  _lock() {
    this._locked = true;
  },
  _unlock() {
    if (!this.option("disabled")) {
      this._locked = false;
    }
  },
  _isDirection(direction) {
    const current2 = this.option("direction");
    if (direction === VERTICAL3) {
      return current2 !== HORIZONTAL4;
    }
    if (direction === HORIZONTAL4) {
      return current2 !== VERTICAL3;
    }
    return current2 === direction;
  },
  _updateAllowedDirection() {
    const allowedDirections = this._strategy._allowedDirections();
    if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {
      this._allowedDirectionValue = BOTH;
    } else if (this._isDirection(HORIZONTAL4) && allowedDirections.horizontal) {
      this._allowedDirectionValue = HORIZONTAL4;
    } else if (this._isDirection(VERTICAL3) && allowedDirections.vertical) {
      this._allowedDirectionValue = VERTICAL3;
    } else {
      this._allowedDirectionValue = null;
    }
  },
  _allowedDirection() {
    return this._allowedDirectionValue;
  },
  $content() {
    return this._$content;
  },
  content() {
    return getPublicElement(this._$content);
  },
  container() {
    return getPublicElement(this._$container);
  },
  scrollOffset() {
    return this._strategy._getScrollOffset();
  },
  _isRtlNativeStrategy() {
    const {
      useNative,
      rtlEnabled
    } = this.option();
    return useNative && rtlEnabled;
  },
  scrollTop() {
    return this.scrollOffset().top;
  },
  scrollLeft() {
    return this.scrollOffset().left;
  },
  clientHeight() {
    return getHeight(this._$container);
  },
  scrollHeight() {
    return getOuterHeight(this.$content());
  },
  clientWidth() {
    return getWidth(this._$container);
  },
  scrollWidth() {
    return getOuterWidth(this.$content());
  },
  update() {
    if (!this._strategy) {
      return;
    }
    return when(this._strategy.update()).done(() => {
      this._updateAllowedDirection();
    });
  },
  scrollBy(distance) {
    distance = this._normalizeLocation(distance);
    if (!distance.top && !distance.left) {
      return;
    }
    this._updateIfNeed();
    this._strategy.scrollBy(distance);
  },
  scrollTo(targetLocation) {
    targetLocation = this._normalizeLocation(targetLocation);
    this._updateIfNeed();
    let location = this._location();
    if (!this.option("useNative")) {
      targetLocation = this._strategy._applyScaleRatio(targetLocation);
      location = this._strategy._applyScaleRatio(location);
    }
    if (this._isRtlNativeStrategy()) {
      location.left -= this._getMaxOffset().left;
    }
    const distance = this._normalizeLocation({
      left: location.left - ensureDefined(targetLocation.left, location.left),
      top: location.top - ensureDefined(targetLocation.top, location.top)
    });
    if (!distance.top && !distance.left) {
      return;
    }
    this._strategy.scrollBy(distance);
  },
  scrollToElement(element, offset2) {
    const $element = renderer_default(element);
    const elementInsideContent = this.$content().find(element).length;
    const elementIsInsideContent = $element.parents(".dx-scrollable").length - $element.parents(".dx-scrollable-content").length === 0;
    if (!elementInsideContent || !elementIsInsideContent) {
      return;
    }
    const scrollPosition = {
      top: 0,
      left: 0
    };
    const direction = this.option("direction");
    if (direction !== VERTICAL3) {
      scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL4, offset2);
    }
    if (direction !== HORIZONTAL4) {
      scrollPosition.top = this.getScrollElementPosition($element, VERTICAL3, offset2);
    }
    this.scrollTo(scrollPosition);
  },
  getScrollElementPosition($element, direction, offset2) {
    const scrollOffset = this.scrollOffset();
    return getElementLocationInternal($element.get(0), direction, renderer_default(this.container()).get(0), scrollOffset, offset2);
  },
  _updateIfNeed() {
    if (!this.option("updateManually")) {
      this.update();
    }
  },
  _useTemplates: () => false,
  isRenovated: () => !!Scrollable.IS_RENOVATED_WIDGET
});
component_registrator_default(SCROLLABLE, Scrollable);
var m_scrollable_default = Scrollable;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.js
var SCROLLVIEW_LOADPANEL = "dx-scrollview-loadpanel";
var refreshStrategies = {
  pullDown: m_scroll_view_native_pull_down_default,
  swipeDown: m_scroll_view_native_swipe_down_default,
  simulated: m_scroll_view_simulated_default
};
var isServerSide = !hasWindow();
var scrollViewServerConfig = {
  finishLoading: noop2,
  release: noop2,
  refresh: noop2,
  scrollOffset: () => ({
    top: 0,
    left: 0
  }),
  _optionChanged(args) {
    if ("onUpdated" !== args.name) {
      return this.callBase.apply(this, arguments);
    }
  }
};
var ScrollView = m_scrollable_default.inherit(isServerSide ? scrollViewServerConfig : {
  _getDefaultOptions() {
    return extend(this.callBase(), {
      pullingDownText: message_default.format("dxScrollView-pullingDownText"),
      pulledDownText: message_default.format("dxScrollView-pulledDownText"),
      refreshingText: message_default.format("dxScrollView-refreshingText"),
      reachBottomText: message_default.format("dxScrollView-reachBottomText"),
      onPullDown: null,
      onReachBottom: null,
      refreshStrategy: "pullDown"
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device() {
        const realDevice2 = devices_default.real();
        return "android" === realDevice2.platform;
      },
      options: {
        refreshStrategy: "swipeDown"
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        reachBottomText: ""
      }
    }]);
  },
  _init() {
    this.callBase();
    this._loadingIndicatorEnabled = true;
  },
  _initScrollableMarkup() {
    this.callBase();
    this.$element().addClass("dx-scrollview");
    this._initContent();
    this._initTopPocket();
    this._initBottomPocket();
    this._initLoadPanel();
  },
  _initContent() {
    const $content = renderer_default("<div>").addClass("dx-scrollview-content");
    this._$content.wrapInner($content);
  },
  _initTopPocket() {
    const $topPocket = this._$topPocket = renderer_default("<div>").addClass("dx-scrollview-top-pocket");
    const $pullDown = this._$pullDown = renderer_default("<div>").addClass("dx-scrollview-pull-down");
    $topPocket.append($pullDown);
    this._$content.prepend($topPocket);
  },
  _initBottomPocket() {
    const $bottomPocket = this._$bottomPocket = renderer_default("<div>").addClass("dx-scrollview-bottom-pocket");
    const $reachBottom = this._$reachBottom = renderer_default("<div>").addClass("dx-scrollview-scrollbottom");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-scrollbottom-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    const $text = this._$reachBottomText = renderer_default("<div>").addClass("dx-scrollview-scrollbottom-text");
    this._updateReachBottomText();
    $reachBottom.append($loadContainer.append($loadIndicator)).append($text);
    $bottomPocket.append($reachBottom);
    this._$content.append($bottomPocket);
  },
  _initLoadPanel() {
    const $loadPanelElement = renderer_default("<div>").addClass(SCROLLVIEW_LOADPANEL).appendTo(this.$element());
    const loadPanelOptions = {
      shading: false,
      delay: 400,
      message: this.option("refreshingText"),
      position: {
        of: this.$element()
      }
    };
    this._loadPanel = this._createComponent($loadPanelElement, load_panel_default, loadPanelOptions);
  },
  _updateReachBottomText() {
    this._$reachBottomText.text(this.option("reachBottomText"));
  },
  _createStrategy() {
    const strategyName = this.option("useNative") ? this.option("refreshStrategy") : "simulated";
    const strategyClass = refreshStrategies[strategyName];
    this._strategy = new strategyClass(this);
    this._strategy.pullDownCallbacks.add(this._pullDownHandler.bind(this));
    this._strategy.releaseCallbacks.add(this._releaseHandler.bind(this));
    this._strategy.reachBottomCallbacks.add(this._reachBottomHandler.bind(this));
  },
  _createActions() {
    this.callBase();
    this._pullDownAction = this._createActionByOption("onPullDown");
    this._reachBottomAction = this._createActionByOption("onReachBottom");
    this._tryRefreshPocketState();
  },
  _tryRefreshPocketState() {
    this._pullDownEnable(this.hasActionSubscription("onPullDown"));
    this._reachBottomEnable(this.hasActionSubscription("onReachBottom"));
  },
  on(eventName) {
    const result2 = this.callBase.apply(this, arguments);
    if ("pullDown" === eventName || "reachBottom" === eventName) {
      this._tryRefreshPocketState();
    }
    return result2;
  },
  _pullDownEnable(enabled) {
    if (0 === arguments.length) {
      return this._pullDownEnabled;
    }
    if (this._$pullDown && this._strategy) {
      this._$pullDown.toggle(enabled);
      this._strategy.pullDownEnable(enabled);
      this._pullDownEnabled = enabled;
    }
  },
  _reachBottomEnable(enabled) {
    if (0 === arguments.length) {
      return this._reachBottomEnabled;
    }
    if (this._$reachBottom && this._strategy) {
      this._$reachBottom.toggle(enabled);
      this._strategy.reachBottomEnable(enabled);
      this._reachBottomEnabled = enabled;
    }
  },
  _pullDownHandler() {
    this._loadingIndicator(false);
    this._pullDownLoading();
  },
  _loadingIndicator(value2) {
    if (arguments.length < 1) {
      return this._loadingIndicatorEnabled;
    }
    this._loadingIndicatorEnabled = value2;
  },
  _pullDownLoading() {
    this.startLoading();
    this._pullDownAction();
  },
  _reachBottomHandler() {
    this._loadingIndicator(false);
    this._reachBottomLoading();
  },
  _reachBottomLoading() {
    this.startLoading();
    this._reachBottomAction();
  },
  _releaseHandler() {
    this.finishLoading();
    this._loadingIndicator(true);
  },
  _optionChanged(args) {
    switch (args.name) {
      case "onPullDown":
      case "onReachBottom":
        this._createActions();
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "refreshStrategy":
        this._invalidate();
        break;
      case "reachBottomText":
        this._updateReachBottomText();
        break;
      default:
        this.callBase(args);
    }
  },
  content() {
    return getPublicElement(this._$content.children().eq(1));
  },
  release(preventReachBottom) {
    if (void 0 !== preventReachBottom) {
      this.toggleLoading(!preventReachBottom);
    }
    return this._strategy.release();
  },
  toggleLoading(showOrHide) {
    this._reachBottomEnable(showOrHide);
  },
  refresh() {
    if (!this.hasActionSubscription("onPullDown")) {
      return;
    }
    this._strategy.pendingRelease();
    this._pullDownLoading();
  },
  startLoading() {
    if (this._loadingIndicator() && this.$element().is(":visible")) {
      this._loadPanel.show();
    }
    this._lock();
  },
  finishLoading() {
    this._loadPanel.hide();
    this._unlock();
  },
  _dispose() {
    this._strategy.dispose();
    this.callBase();
    if (this._loadPanel) {
      this._loadPanel.$element().remove();
    }
  }
});
component_registrator_default("dxScrollView", ScrollView);
var m_scroll_view_default = ScrollView;

// ../../../../../../node_modules/devextreme/esm/ui/scroll_view.js
var scroll_view_default = m_scroll_view_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/shared/m_grouped_data_converter_mixin.js
var isCorrectStructure = (data2) => Array.isArray(data2) && data2.every((item) => {
  const hasTwoFields = 2 === Object.keys(item).length;
  const hasCorrectFields = "key" in item && "items" in item;
  return hasTwoFields && hasCorrectFields && Array.isArray(item.items);
});
var m_grouped_data_converter_mixin_default = {
  _getSpecificDataSourceOption() {
    let dataSource = this.option("dataSource");
    let hasSimpleItems = false;
    let data2 = {};
    if (this._getGroupedOption() && isCorrectStructure(dataSource)) {
      data2 = dataSource.reduce((accumulator, item) => {
        const items = item.items.map((innerItem) => {
          if (!isObject(innerItem)) {
            innerItem = {
              text: innerItem
            };
            hasSimpleItems = true;
          }
          if (!("key" in innerItem)) {
            innerItem.key = item.key;
          }
          return innerItem;
        });
        return accumulator.concat(items);
      }, []);
      dataSource = {
        store: {
          type: "array",
          data: data2
        },
        group: {
          selector: "key",
          keepInitialKeyOrder: true
        }
      };
      if (hasSimpleItems) {
        dataSource.searchExpr = "text";
      }
    }
    return dataSource;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_item.js
var ListItem = m_item_default.inherit({
  _renderWatchers() {
    this.callBase();
    this._startWatcher("badge", this._renderBadge.bind(this));
    this._startWatcher("showChevron", this._renderShowChevron.bind(this));
  },
  _renderBadge(badge) {
    this._$element.children(".dx-list-item-badge-container").remove();
    if (!badge) {
      return;
    }
    const $badge = renderer_default("<div>").addClass("dx-list-item-badge-container").append(renderer_default("<div>").addClass("dx-list-item-badge").addClass("dx-badge").text(badge));
    const $chevron = this._$element.children(".dx-list-item-chevron-container").first();
    $chevron.length > 0 ? $badge.insertBefore($chevron) : $badge.appendTo(this._$element);
  },
  _renderShowChevron(showChevron) {
    this._$element.children(".dx-list-item-chevron-container").remove();
    if (!showChevron) {
      return;
    }
    const $chevronContainer = renderer_default("<div>").addClass("dx-list-item-chevron-container");
    const $chevron = renderer_default("<div>").addClass("dx-list-item-chevron");
    $chevronContainer.append($chevron).appendTo(this._$element);
  }
});
var m_item_default2 = ListItem;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.base.js
var LIST_ITEM_SELECTOR = ".dx-list-item";
var SELECT_ALL_ITEM_SELECTOR = ".dx-list-select-all";
var groupItemsGetter = compileGetter("items");
var _scrollView;
var ListBase = ui_collection_widget_live_update_default.inherit({
  _activeStateUnit: [LIST_ITEM_SELECTOR, SELECT_ALL_ITEM_SELECTOR].join(","),
  _supportedKeys() {
    const that = this;
    const moveFocusPerPage = function(direction) {
      let $item = getEdgeVisibleItem(direction);
      const isFocusedItem = $item.is(that.option("focusedElement"));
      if (isFocusedItem) {
        !function($item2, direction2) {
          let resultPosition = $item2.position().top;
          if ("prev" === direction2) {
            resultPosition = $item2.position().top - getHeight(that.$element()) + getOuterHeight($item2);
          }
          that.scrollTo(resultPosition);
        }($item, direction);
        $item = getEdgeVisibleItem(direction);
      }
      that.option("focusedElement", getPublicElement($item));
      that.scrollToItem($item);
    };
    function getEdgeVisibleItem(direction) {
      const scrollTop = that.scrollTop();
      const containerHeight = getHeight(that.$element());
      let $item = renderer_default(that.option("focusedElement"));
      let isItemVisible = true;
      if (!$item.length) {
        return renderer_default();
      }
      while (isItemVisible) {
        const $nextItem = $item[direction]();
        if (!$nextItem.length) {
          break;
        }
        const nextItemLocation = $nextItem.position().top + getOuterHeight($nextItem) / 2;
        isItemVisible = nextItemLocation < containerHeight + scrollTop && nextItemLocation > scrollTop;
        if (isItemVisible) {
          $item = $nextItem;
        }
      }
      return $item;
    }
    return extend(this.callBase(), {
      leftArrow: noop2,
      rightArrow: noop2,
      pageUp() {
        moveFocusPerPage("prev");
        return false;
      },
      pageDown() {
        moveFocusPerPage("next");
        return false;
      }
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      pullRefreshEnabled: false,
      scrollingEnabled: true,
      selectByClick: true,
      showScrollbar: "onScroll",
      useNativeScrolling: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      pullingDownText: message_default.format("dxList-pullingDownText"),
      pulledDownText: message_default.format("dxList-pulledDownText"),
      refreshingText: message_default.format("dxList-refreshingText"),
      pageLoadingText: message_default.format("dxList-pageLoadingText"),
      onScroll: null,
      onPullRefresh: null,
      onPageLoading: null,
      pageLoadMode: "scrollBottom",
      nextButtonText: message_default.format("dxList-nextButtonText"),
      onItemSwipe: null,
      grouped: false,
      onGroupRendered: null,
      collapsibleGroups: false,
      groupTemplate: "group",
      indicateLoading: true,
      activeStateEnabled: true,
      _itemAttributes: {
        role: "option"
      },
      useInkRipple: false,
      wrapItemText: false,
      _swipeEnabled: true,
      showChevronExpr: (data2) => data2 ? data2.showChevron : void 0,
      badgeExpr: (data2) => data2 ? data2.badge : void 0
    });
  },
  _defaultOptionsRules() {
    const themeName = current();
    return this.callBase().concat(deviceDependentOptions(), [{
      device: () => !nativeScrolling,
      options: {
        useNativeScrolling: false
      }
    }, {
      device: (device) => !nativeScrolling && !devices_default.isSimulator() && "desktop" === devices_default.real().deviceType && "generic" === device.platform,
      options: {
        showScrollbar: "onHover",
        pageLoadMode: "nextButton"
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterial(themeName),
      options: {
        useInkRipple: true
      }
    }, {
      device: () => isMaterialBased(themeName),
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        pageLoadingText: ""
      }
    }]);
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._updateLoadingState(true);
    }
  },
  _itemClass: () => "dx-list-item",
  _itemDataKey: () => "dxListItemData",
  _itemContainer() {
    return this._$container;
  },
  _getItemsContainer() {
    return this._$listContainer;
  },
  _cleanItemContainer() {
    this.callBase();
    const listContainer = this._getItemsContainer();
    renderer_default(listContainer).empty();
    listContainer.appendTo(this._$container);
  },
  _saveSelectionChangeEvent(e) {
    this._selectionChangeEventInstance = e;
  },
  _getSelectionChangeEvent() {
    return this._selectionChangeEventInstance;
  },
  _refreshItemElements() {
    if (!this.option("grouped")) {
      this._itemElementsCache = this._getItemsContainer().children(this._itemSelector());
    } else {
      this._itemElementsCache = this._getItemsContainer().children(".dx-list-group").children(".dx-list-group-body").children(this._itemSelector());
    }
  },
  _modifyByChanges() {
    this.callBase.apply(this, arguments);
    this._refreshItemElements();
    this._updateLoadingState(true);
  },
  reorderItem(itemElement, toItemElement) {
    const promise = this.callBase(itemElement, toItemElement);
    return promise.done(function() {
      this._refreshItemElements();
    });
  },
  deleteItem(itemElement) {
    const promise = this.callBase(itemElement);
    return promise.done(function() {
      this._refreshItemElements();
    });
  },
  _itemElements() {
    return this._itemElementsCache;
  },
  _itemSelectHandler(e) {
    if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
      return;
    }
    return this.callBase(e);
  },
  _allowDynamicItemsAppend: () => true,
  _init() {
    this.callBase();
    this._dataController.resetDataSourcePageIndex();
    this._$container = this.$element();
    this._$listContainer = renderer_default("<div>").addClass("dx-list-items");
    this._initScrollView();
    this._feedbackShowTimeout = 70;
    this._createGroupRenderAction();
  },
  _scrollBottomMode() {
    return "scrollBottom" === this.option("pageLoadMode");
  },
  _nextButtonMode() {
    return "nextButton" === this.option("pageLoadMode");
  },
  _dataSourceOptions() {
    const scrollBottom = this._scrollBottomMode();
    const nextButton = this._nextButtonMode();
    return extend(this.callBase(), {
      paginate: ensureDefined(scrollBottom || nextButton, true)
    });
  },
  _getGroupedOption() {
    return this.option("grouped");
  },
  _getGroupContainerByIndex(groupIndex) {
    return this._getItemsContainer().find(".dx-list-group").eq(groupIndex).find(".dx-list-group-body");
  },
  _dataSourceFromUrlLoadMode: () => "raw",
  _initScrollView() {
    const scrollingEnabled = this.option("scrollingEnabled");
    const pullRefreshEnabled = scrollingEnabled && this.option("pullRefreshEnabled");
    const autoPagingEnabled = scrollingEnabled && this._scrollBottomMode() && !!this._dataController.getDataSource();
    this._scrollView = this._createComponent(this.$element(), getScrollView(), {
      height: this.option("height"),
      width: this.option("width"),
      disabled: this.option("disabled") || !scrollingEnabled,
      onScroll: this._scrollHandler.bind(this),
      onPullDown: pullRefreshEnabled ? this._pullDownHandler.bind(this) : null,
      onReachBottom: autoPagingEnabled ? this._scrollBottomHandler.bind(this) : null,
      showScrollbar: this.option("showScrollbar"),
      useNative: this.option("useNativeScrolling"),
      bounceEnabled: this.option("bounceEnabled"),
      scrollByContent: this.option("scrollByContent"),
      scrollByThumb: this.option("scrollByThumb"),
      pullingDownText: this.option("pullingDownText"),
      pulledDownText: this.option("pulledDownText"),
      refreshingText: this.option("refreshingText"),
      reachBottomText: this.option("pageLoadingText"),
      useKeyboard: false
    });
    this._$container = renderer_default(this._scrollView.content());
    this._$listContainer.appendTo(this._$container);
    this._toggleWrapItemText(this.option("wrapItemText"));
    this._createScrollViewActions();
  },
  _toggleWrapItemText(value2) {
    this._$listContainer.toggleClass("dx-wrap-item-text", value2);
  },
  _createScrollViewActions() {
    this._scrollAction = this._createActionByOption("onScroll");
    this._pullRefreshAction = this._createActionByOption("onPullRefresh");
    this._pageLoadingAction = this._createActionByOption("onPageLoading");
  },
  _scrollHandler(e) {
    this._scrollAction && this._scrollAction(e);
  },
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      group: new BindableTemplate(($container, data2) => {
        if (isPlainObject(data2)) {
          if (data2.key) {
            $container.text(data2.key);
          }
        } else {
          $container.text(String(data2));
        }
      }, ["key"], this.option("integrationOptions.watchMethod"))
    });
    this.callBase();
  },
  _prepareDefaultItemTemplate(data2, $container) {
    this.callBase(data2, $container);
    if (data2.icon) {
      const $icon = getImageContainer(data2.icon).addClass("dx-list-item-icon");
      const $iconContainer = renderer_default("<div>").addClass("dx-list-item-icon-container");
      $iconContainer.append($icon);
      $container.prepend($iconContainer);
    }
  },
  _getBindableFields: () => ["text", "html", "icon"],
  _updateLoadingState(tryLoadMore) {
    const dataController = this._dataController;
    const shouldLoadNextPage = this._scrollBottomMode() && tryLoadMore && !dataController.isLoading() && !this._isLastPage();
    if (this._shouldContinueLoading(shouldLoadNextPage)) {
      this._infiniteDataLoading();
    } else {
      this._scrollView.release(!shouldLoadNextPage && !dataController.isLoading());
      this._toggleNextButton(this._shouldRenderNextButton() && !this._isLastPage());
      this._loadIndicationSuppressed(false);
    }
  },
  _shouldRenderNextButton() {
    return this._nextButtonMode() && this._dataController.isLoaded();
  },
  _isDataSourceFirstLoadCompleted(newValue) {
    if (isDefined(newValue)) {
      this._isFirstLoadCompleted = newValue;
    }
    return this._isFirstLoadCompleted;
  },
  _dataSourceLoadingChangedHandler(isLoading) {
    if (this._loadIndicationSuppressed()) {
      return;
    }
    if (isLoading && this.option("indicateLoading")) {
      this._showLoadingIndicatorTimer = setTimeout(() => {
        const isEmpty2 = !this._itemElements().length;
        const shouldIndicateLoading = !isEmpty2 || this._isDataSourceFirstLoadCompleted();
        if (shouldIndicateLoading) {
          var _this$_scrollView;
          null === (_this$_scrollView = this._scrollView) || void 0 === _this$_scrollView || _this$_scrollView.startLoading();
        }
      });
    } else {
      clearTimeout(this._showLoadingIndicatorTimer);
      this._scrollView && this._scrollView.finishLoading();
    }
    if (!isLoading) {
      this._isDataSourceFirstLoadCompleted(false);
    }
  },
  _dataSourceChangedHandler() {
    if (!this._shouldAppendItems() && hasWindow()) {
      this._scrollView && this._scrollView.scrollTo(0);
    }
    this.callBase.apply(this, arguments);
    this._isDataSourceFirstLoadCompleted(true);
  },
  _refreshContent() {
    this._prepareContent();
    this._fireContentReadyAction();
  },
  _hideLoadingIfLoadIndicationOff() {
    if (!this.option("indicateLoading")) {
      this._dataSourceLoadingChangedHandler(false);
    }
  },
  _loadIndicationSuppressed(value2) {
    if (!arguments.length) {
      return this._isLoadIndicationSuppressed;
    }
    this._isLoadIndicationSuppressed = value2;
  },
  _scrollViewIsFull() {
    const scrollView = this._scrollView;
    return !scrollView || getHeight(scrollView.content()) > getHeight(scrollView.container());
  },
  _pullDownHandler(e) {
    this._pullRefreshAction(e);
    const dataController = this._dataController;
    if (dataController.getDataSource() && !dataController.isLoading()) {
      this._clearSelectedItems();
      dataController.pageIndex(0);
      dataController.reload();
    } else {
      this._updateLoadingState();
    }
  },
  _shouldContinueLoading(shouldLoadNextPage) {
    var _this$_scrollView$scr;
    const isBottomReached = getHeight(this._scrollView.content()) - getHeight(this._scrollView.container()) < ((null === (_this$_scrollView$scr = this._scrollView.scrollOffset()) || void 0 === _this$_scrollView$scr ? void 0 : _this$_scrollView$scr.top) ?? 0);
    return shouldLoadNextPage && (!this._scrollViewIsFull() || isBottomReached);
  },
  _infiniteDataLoading() {
    const isElementVisible = this.$element().is(":visible");
    if (isElementVisible) {
      clearTimeout(this._loadNextPageTimer);
      this._loadNextPageTimer = setTimeout(() => {
        this._loadNextPage();
      });
    }
  },
  _scrollBottomHandler(e) {
    this._pageLoadingAction(e);
    const dataController = this._dataController;
    if (!dataController.isLoading() && !this._isLastPage()) {
      this._loadNextPage();
    } else {
      this._updateLoadingState();
    }
  },
  _renderItems(items) {
    if (this.option("grouped")) {
      each(items, this._renderGroup.bind(this));
      this._attachGroupCollapseEvent();
      this._renderEmptyMessage();
      if (isMaterial()) {
        this.attachGroupHeaderInkRippleEvents();
      }
    } else {
      this.callBase.apply(this, arguments);
    }
    this._refreshItemElements();
    this._updateLoadingState(true);
  },
  _attachGroupCollapseEvent() {
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const $element = this.$element();
    const collapsibleGroups = this.option("collapsibleGroups");
    $element.toggleClass("dx-list-collapsible-groups", collapsibleGroups);
    events_engine_default.off($element, eventName, ".dx-list-group-header");
    if (collapsibleGroups) {
      events_engine_default.on($element, eventName, ".dx-list-group-header", (e) => {
        this._createAction((e2) => {
          const $group = renderer_default(e2.event.currentTarget).parent();
          this._collapseGroupHandler($group);
          if (this.option("focusStateEnabled")) {
            this.option("focusedElement", getPublicElement($group.find(".dx-list-item").eq(0)));
          }
        }, {
          validatingTargetName: "element"
        })({
          event: e
        });
      });
    }
  },
  _collapseGroupHandler($group, toggle) {
    const deferred = Deferred();
    if ($group.hasClass("dx-list-group-collapsed") === toggle) {
      return deferred.resolve();
    }
    const $groupBody = $group.children(".dx-list-group-body");
    const startHeight = getOuterHeight($groupBody);
    let endHeight = 0;
    if (0 === startHeight) {
      setHeight($groupBody, "auto");
      endHeight = getOuterHeight($groupBody);
    }
    $group.toggleClass("dx-list-group-collapsed", toggle);
    fx_default.animate($groupBody, {
      type: "custom",
      from: {
        height: startHeight
      },
      to: {
        height: endHeight
      },
      duration: 200,
      complete: (function() {
        this.updateDimensions();
        this._updateLoadingState(true);
        deferred.resolve();
      }).bind(this)
    });
    return deferred.promise();
  },
  _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading();
    if (this._initialized) {
      this._renderEmptyMessage();
      this._updateLoadingState();
    }
  },
  _initMarkup() {
    this._itemElementsCache = renderer_default();
    this.$element().addClass("dx-list");
    this.callBase();
    this.option("useInkRipple") && this._renderInkRipple();
    this.setAria({
      role: "group",
      roledescription: "list"
    }, this.$element());
    this.setAria({
      role: "application"
    }, this._focusTarget());
    this._setListAria();
  },
  _setListAria() {
    const {
      items,
      allowItemDeleting
    } = this.option();
    const label = allowItemDeleting ? message_default.format("dxList-listAriaLabel-deletable") : message_default.format("dxList-listAriaLabel");
    const listArea = null !== items && void 0 !== items && items.length ? {
      role: "listbox",
      label
    } : {
      role: void 0,
      label: void 0
    };
    this.setAria(listArea, this._$listContainer);
  },
  _focusTarget() {
    return this._itemContainer();
  },
  _renderInkRipple() {
    this._inkRipple = render3();
  },
  _toggleActiveState($element, value2, e) {
    this.callBase.apply(this, arguments);
    const that = this;
    if (!this._inkRipple) {
      return;
    }
    const config3 = {
      element: $element,
      event: e
    };
    if (value2) {
      if (isMaterial()) {
        this._inkRippleTimer = setTimeout(() => {
          that._inkRipple.showWave(config3);
        }, 35);
      } else {
        that._inkRipple.showWave(config3);
      }
    } else {
      clearTimeout(this._inkRippleTimer);
      this._inkRipple.hideWave(config3);
    }
  },
  _postprocessRenderItem(args) {
    this._refreshItemElements();
    this.callBase.apply(this, arguments);
    if (this.option("_swipeEnabled")) {
      this._attachSwipeEvent(renderer_default(args.itemElement));
    }
  },
  _attachSwipeEvent($itemElement) {
    const endEventName = addNamespace2(SWIPE_END_EVENT, this.NAME);
    events_engine_default.on($itemElement, endEventName, this._itemSwipeEndHandler.bind(this));
  },
  _itemSwipeEndHandler(e) {
    this._itemDXEventHandler(e, "onItemSwipe", {
      direction: e.offset < 0 ? "left" : "right"
    });
  },
  _nextButtonHandler(e) {
    this._pageLoadingAction(e);
    const dataController = this._dataController;
    if (dataController.getDataSource() && !dataController.isLoading()) {
      this._scrollView.toggleLoading(true);
      this._$nextButton.detach();
      this._loadIndicationSuppressed(true);
      this._loadNextPage();
    }
  },
  _renderGroup(index2, group) {
    const $groupElement = renderer_default("<div>").addClass("dx-list-group").appendTo(this._getItemsContainer());
    const id = `dx-${new guid_default().toString()}`;
    const groupAria = {
      role: "group",
      labelledby: id
    };
    this.setAria(groupAria, $groupElement);
    const $groupHeaderElement = renderer_default("<div>").addClass("dx-list-group-header").attr("id", id).appendTo($groupElement);
    const groupTemplateName = this.option("groupTemplate");
    const groupTemplate = this._getTemplate(group.template || groupTemplateName, group, index2, $groupHeaderElement);
    const renderArgs = {
      index: index2,
      itemData: group,
      container: getPublicElement($groupHeaderElement)
    };
    this._createItemByTemplate(groupTemplate, renderArgs);
    renderer_default("<div>").addClass("dx-list-group-header-indicator").prependTo($groupHeaderElement);
    this._renderingGroupIndex = index2;
    const $groupBody = renderer_default("<div>").addClass("dx-list-group-body").appendTo($groupElement);
    each(groupItemsGetter(group) || [], (itemIndex, item) => {
      this._renderItem({
        group: index2,
        item: itemIndex
      }, item, $groupBody);
    });
    this._groupRenderAction({
      groupElement: getPublicElement($groupElement),
      groupIndex: index2,
      groupData: group
    });
  },
  downInkRippleHandler(e) {
    this._toggleActiveState(renderer_default(e.currentTarget), true, e);
  },
  upInkRippleHandler(e) {
    this._toggleActiveState(renderer_default(e.currentTarget), false);
  },
  attachGroupHeaderInkRippleEvents() {
    const $element = this.$element();
    this._downInkRippleHandler = this._downInkRippleHandler || this.downInkRippleHandler.bind(this);
    this._upInkRippleHandler = this._upInkRippleHandler || this.upInkRippleHandler.bind(this);
    const downArguments = [$element, "dxpointerdown", ".dx-list-group-header", this._downInkRippleHandler];
    const upArguments = [$element, "dxpointerup dxpointerout", ".dx-list-group-header", this._upInkRippleHandler];
    events_engine_default.off(...downArguments);
    events_engine_default.on(...downArguments);
    events_engine_default.off(...upArguments);
    events_engine_default.on(...upArguments);
  },
  _createGroupRenderAction() {
    this._groupRenderAction = this._createActionByOption("onGroupRendered");
  },
  _clean() {
    clearTimeout(this._inkRippleTimer);
    if (this._$nextButton) {
      this._$nextButton.remove();
      this._$nextButton = null;
    }
    this.callBase.apply(this, arguments);
  },
  _dispose() {
    this._isDataSourceFirstLoadCompleted(false);
    clearTimeout(this._holdTimer);
    clearTimeout(this._loadNextPageTimer);
    clearTimeout(this._showLoadingIndicatorTimer);
    this.callBase();
  },
  _toggleDisabledState(value2) {
    this.callBase(value2);
    this._scrollView.option("disabled", value2 || !this.option("scrollingEnabled"));
  },
  _toggleNextButton(value2) {
    const dataController = this._dataController;
    const $nextButton = this._getNextButton();
    this.$element().toggleClass("dx-has-next", value2);
    if (value2 && dataController.isLoaded()) {
      $nextButton.appendTo(this._itemContainer());
    }
    if (!value2) {
      $nextButton.detach();
    }
  },
  _getNextButton() {
    if (!this._$nextButton) {
      this._$nextButton = this._createNextButton();
    }
    return this._$nextButton;
  },
  _createNextButton() {
    const $result = renderer_default("<div>").addClass("dx-list-next-button");
    const $button = renderer_default("<div>").appendTo($result);
    this._createComponent($button, button_default, {
      text: this.option("nextButtonText"),
      onClick: this._nextButtonHandler.bind(this),
      type: isMaterialBased() ? "default" : void 0,
      integrationOptions: {}
    });
    return $result;
  },
  _moveFocus() {
    this.callBase.apply(this, arguments);
    this.scrollToItem(this.option("focusedElement"));
  },
  _refresh() {
    if (!hasWindow()) {
      this.callBase();
    } else {
      const scrollTop = this._scrollView.scrollTop();
      this.callBase();
      scrollTop && this._scrollView.scrollTo(scrollTop);
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "pageLoadMode":
        this._toggleNextButton(args.value);
        this._initScrollView();
        break;
      case "dataSource":
        this.callBase(args);
        this._initScrollView();
        this._isDataSourceFirstLoadCompleted(false);
        break;
      case "items":
        this.callBase(args);
        this._isDataSourceFirstLoadCompleted(false);
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "pageLoadingText":
      case "showScrollbar":
      case "bounceEnabled":
      case "scrollByContent":
      case "scrollByThumb":
      case "useNativeScrolling":
      case "scrollingEnabled":
      case "pullRefreshEnabled":
        this._initScrollView();
        this._updateLoadingState(true);
        break;
      case "nextButtonText":
      case "onItemSwipe":
      case "useInkRipple":
      case "grouped":
      case "collapsibleGroups":
      case "groupTemplate":
      case "showChevronExpr":
      case "badgeExpr":
        this._invalidate();
        break;
      case "onScroll":
      case "onPullRefresh":
      case "onPageLoading":
        this._createScrollViewActions();
        break;
      case "wrapItemText":
        this._toggleWrapItemText(args.value);
        break;
      case "onGroupRendered":
        this._createGroupRenderAction();
        break;
      case "width":
      case "height":
        this.callBase(args);
        this._scrollView.option(args.name, args.value);
        this._scrollView.update();
        break;
      case "indicateLoading":
        this._hideLoadingIfLoadIndicationOff();
        break;
      case "visible":
        this.callBase(args);
        this._scrollView.update();
        break;
      case "rtlEnabled":
        this._initScrollView();
        this.callBase(args);
        break;
      case "_swipeEnabled":
      case "selectByClick":
        break;
      default:
        this.callBase(args);
    }
  },
  _extendActionArgs($itemElement) {
    if (!this.option("grouped")) {
      return this.callBase($itemElement);
    }
    const $group = $itemElement.closest(".dx-list-group");
    const $item = $group.find(".dx-list-item");
    return extend(this.callBase($itemElement), {
      itemIndex: {
        group: $group.index(),
        item: $item.index($itemElement)
      }
    });
  },
  expandGroup(groupIndex) {
    const deferred = Deferred();
    const $group = this._getItemsContainer().find(".dx-list-group").eq(groupIndex);
    this._collapseGroupHandler($group, false).done(() => {
      deferred.resolveWith(this);
    });
    return deferred.promise();
  },
  collapseGroup(groupIndex) {
    const deferred = Deferred();
    const $group = this._getItemsContainer().find(".dx-list-group").eq(groupIndex);
    this._collapseGroupHandler($group, true).done(() => {
      deferred.resolveWith(this);
    });
    return deferred;
  },
  updateDimensions() {
    const that = this;
    const deferred = Deferred();
    if (that._scrollView) {
      that._scrollView.update().done(() => {
        !that._scrollViewIsFull() && that._updateLoadingState(true);
        deferred.resolveWith(that);
      });
    } else {
      deferred.resolveWith(that);
    }
    return deferred.promise();
  },
  reload() {
    this.callBase();
    this.scrollTo(0);
    this._pullDownHandler();
  },
  repaint() {
    this.scrollTo(0);
    this.callBase();
  },
  scrollTop() {
    return this._scrollView.scrollOffset().top;
  },
  clientHeight() {
    return this._scrollView.clientHeight();
  },
  scrollHeight() {
    return this._scrollView.scrollHeight();
  },
  scrollBy(distance) {
    this._scrollView.scrollBy(distance);
  },
  scrollTo(location) {
    this._scrollView.scrollTo(location);
  },
  scrollToItem(itemElement) {
    const $item = this._editStrategy.getItemElement(itemElement);
    const item = null === $item || void 0 === $item ? void 0 : $item.get(0);
    this._scrollView.scrollToElement(item, {
      bottom: getElementMargin(item, "bottom")
    });
  },
  _dimensionChanged() {
    this.updateDimensions();
  }
}).include(m_grouped_data_converter_mixin_default);
ListBase.ItemClass = m_item_default2;
function getScrollView() {
  return _scrollView || scroll_view_default;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.provider.js
var editOptionsRegistry = [];
var registerOption = function(enabledFunc, decoratorTypeFunc, decoratorSubTypeFunc) {
  editOptionsRegistry.push({
    enabled: enabledFunc,
    decoratorType: decoratorTypeFunc,
    decoratorSubType: decoratorSubTypeFunc
  });
};
registerOption(function() {
  return this.option("menuItems").length;
}, () => "menu", function() {
  return this.option("menuMode");
});
registerOption(function() {
  return !this.option("menuItems").length && this.option("allowItemDeleting");
}, function() {
  const mode = this.option("itemDeleteMode");
  return "toggle" === mode || "slideButton" === mode || "swipe" === mode || "static" === mode ? "delete" : "menu";
}, function() {
  let mode = this.option("itemDeleteMode");
  if ("slideItem" === mode) {
    mode = "slide";
  }
  return mode;
});
registerOption(function() {
  return "none" !== this.option("selectionMode") && this.option("showSelectionControls");
}, () => "selection", () => "default");
registerOption(function() {
  return this.option("itemDragging.allowReordering") || this.option("itemDragging.allowDropInsideItem") || this.option("itemDragging.group");
}, () => "reorder", () => "default");
var EditProvider = class_default.inherit({
  ctor(list) {
    this._list = list;
    this._fetchRequiredDecorators();
  },
  dispose() {
    if (this._decorators && this._decorators.length) {
      each(this._decorators, (_, decorator) => {
        decorator.dispose();
      });
    }
  },
  _fetchRequiredDecorators() {
    this._decorators = [];
    each(editOptionsRegistry, (_, option) => {
      const optionEnabled = option.enabled.call(this._list);
      if (optionEnabled) {
        const decoratorType = option.decoratorType.call(this._list);
        const decoratorSubType = option.decoratorSubType.call(this._list);
        const decorator = this._createDecorator(decoratorType, decoratorSubType);
        this._decorators.push(decorator);
      }
    });
  },
  _createDecorator(type2, subType) {
    const decoratorClass = this._findDecorator(type2, subType);
    return new decoratorClass(this._list);
  },
  _findDecorator(type2, subType) {
    var _registry$type;
    const foundDecorator = null === (_registry$type = registry[type2]) || void 0 === _registry$type ? void 0 : _registry$type[subType];
    if (!foundDecorator) {
      throw ui_errors_default.Error("E1012", type2, subType);
    }
    return foundDecorator;
  },
  modifyItemElement(args) {
    const $itemElement = renderer_default(args.itemElement);
    const config3 = {
      $itemElement
    };
    this._prependBeforeBags($itemElement, config3);
    this._appendAfterBags($itemElement, config3);
    this._applyDecorators("modifyElement", config3);
  },
  afterItemsRendered() {
    this._applyDecorators("afterRender");
  },
  _prependBeforeBags($itemElement, config3) {
    const $beforeBags = this._collectDecoratorsMarkup("beforeBag", config3, "dx-list-item-before-bag");
    $itemElement.prepend($beforeBags);
  },
  _appendAfterBags($itemElement, config3) {
    const $afterBags = this._collectDecoratorsMarkup("afterBag", config3, "dx-list-item-after-bag");
    $itemElement.append($afterBags);
  },
  _collectDecoratorsMarkup(method, config3, containerClass) {
    const $collector = renderer_default("<div>");
    each(this._decorators, function() {
      const $container = renderer_default("<div>").addClass(containerClass);
      this[method](extend({
        $container
      }, config3));
      if ($container.children().length) {
        $collector.append($container);
      }
    });
    return $collector.children();
  },
  _applyDecorators(method, config3) {
    each(this._decorators, function() {
      this[method](config3);
    });
  },
  _handlerExists(name2) {
    if (!this._decorators) {
      return false;
    }
    const decorators = this._decorators;
    const {
      length
    } = decorators;
    for (let i = 0; i < length; i++) {
      if (decorators[i][name2] !== noop2) {
        return true;
      }
    }
    return false;
  },
  _eventHandler(name2, $itemElement, e) {
    if (!this._decorators) {
      return false;
    }
    let response = false;
    const decorators = this._decorators;
    const {
      length
    } = decorators;
    for (let i = 0; i < length; i++) {
      response = decorators[i][name2]($itemElement, e);
      if (response) {
        break;
      }
    }
    return response;
  },
  handleClick($itemElement, e) {
    return this._eventHandler("handleClick", $itemElement, e);
  },
  handleKeyboardEvents(currentFocusedIndex, moveFocusUp) {
    return this._eventHandler("handleKeyboardEvents", currentFocusedIndex, moveFocusUp);
  },
  handleEnterPressing(e) {
    return this._eventHandler("handleEnterPressing", e);
  },
  contextMenuHandlerExists() {
    return this._handlerExists("handleContextMenu");
  },
  handleContextMenu($itemElement, e) {
    return this._eventHandler("handleContextMenu", $itemElement, e);
  },
  getExcludedItemSelectors() {
    const excludedSelectors = [];
    this._applyDecorators("getExcludedSelectors", excludedSelectors);
    return excludedSelectors.join(",");
  }
});
var m_list_edit_provider_default = EditProvider;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.strategy.grouped.js
var combineIndex = function(indices) {
  return (indices.group << 20) + indices.item;
};
var splitIndex = function(combinedIndex) {
  return {
    group: combinedIndex >> 20,
    item: 1048575 & combinedIndex
  };
};
var GroupedEditStrategy = m_collection_widget_edit_strategy_plain_default.inherit({
  _groupElements() {
    return this._collectionWidget._itemContainer().find(".dx-list-group");
  },
  _groupItemElements: ($group) => $group.find(".dx-list-item"),
  getIndexByItemData(itemData) {
    const groups = this._collectionWidget.option("items");
    let index2 = false;
    if (!itemData) {
      return false;
    }
    if (itemData.items && itemData.items.length) {
      itemData = itemData.items[0];
    }
    each(groups, (groupIndex, group) => {
      if (!group.items) {
        return false;
      }
      each(group.items, (itemIndex, item) => {
        if (item !== itemData) {
          return true;
        }
        index2 = {
          group: groupIndex,
          item: itemIndex
        };
        return false;
      });
      if (index2) {
        return false;
      }
    });
    return index2;
  },
  getItemDataByIndex(index2) {
    const items = this._collectionWidget.option("items");
    if (isNumeric(index2)) {
      return this.itemsGetter()[index2];
    }
    return index2 && items[index2.group] && items[index2.group].items[index2.item] || null;
  },
  itemsGetter() {
    let resultItems = [];
    const items = this._collectionWidget.option("items");
    for (let i = 0; i < items.length; i++) {
      if (items[i] && items[i].items) {
        resultItems = resultItems.concat(items[i].items);
      } else {
        resultItems.push(items[i]);
      }
    }
    return resultItems;
  },
  deleteItemAtIndex(index2) {
    const indices = splitIndex(index2);
    const itemGroup = this._collectionWidget.option("items")[indices.group].items;
    itemGroup.splice(indices.item, 1);
  },
  getKeysByItems(items) {
    let plainItems = [];
    let i;
    for (i = 0; i < items.length; i++) {
      if (items[i] && items[i].items) {
        plainItems = plainItems.concat(items[i].items);
      } else {
        plainItems.push(items[i]);
      }
    }
    const result2 = [];
    for (i = 0; i < plainItems.length; i++) {
      result2.push(this._collectionWidget.keyOf(plainItems[i]));
    }
    return result2;
  },
  getIndexByKey(key, items) {
    const groups = items || this._collectionWidget.option("items");
    let index2 = -1;
    const that = this;
    each(groups, (groupIndex, group) => {
      if (!group.items) {
        return;
      }
      each(group.items, (itemIndex, item) => {
        const itemKey = that._collectionWidget.keyOf(item);
        if (that._equalKeys(itemKey, key)) {
          index2 = {
            group: groupIndex,
            item: itemIndex
          };
          return false;
        }
      });
      if (-1 !== index2) {
        return false;
      }
    });
    return index2;
  },
  _getGroups(items) {
    const dataController = this._collectionWidget._dataController;
    const group = dataController.group();
    if (group) {
      return store_helper_default.queryByOptions(query_default(items), {
        group
      }).toArray();
    }
    return this._collectionWidget.option("items");
  },
  getItemsByKeys(keys, items) {
    const result2 = [];
    const groups = this._getGroups(items);
    const groupItemByKeyMap = {};
    const getItemMeta = (key) => {
      const index2 = this.getIndexByKey(key, groups);
      const group = index2 && groups[index2.group];
      if (!group) {
        return;
      }
      return {
        groupKey: group.key,
        item: group.items[index2.item]
      };
    };
    each(keys, (_, key) => {
      const itemMeta = getItemMeta(key);
      if (!itemMeta) {
        return;
      }
      const {
        groupKey
      } = itemMeta;
      const {
        item
      } = itemMeta;
      let selectedGroup = groupItemByKeyMap[groupKey];
      if (!selectedGroup) {
        selectedGroup = {
          key: groupKey,
          items: []
        };
        groupItemByKeyMap[groupKey] = selectedGroup;
        result2.push(selectedGroup);
      }
      selectedGroup.items.push(item);
    });
    return result2;
  },
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    const items = this._collectionWidget.option("items");
    const movingIndices = splitIndex(movingIndex);
    const destinationIndices = splitIndex(destinationIndex);
    const movingItemGroup = items[movingIndices.group].items;
    const destinationItemGroup = items[destinationIndices.group].items;
    const movedItemData = movingItemGroup[movingIndices.item];
    movingItemGroup.splice(movingIndices.item, 1);
    destinationItemGroup.splice(destinationIndices.item, 0, movedItemData);
  },
  _isItemIndex: (index2) => index2 && isNumeric(index2.group) && isNumeric(index2.item),
  _getNormalizedItemIndex(itemElement) {
    const $item = renderer_default(itemElement);
    const $group = $item.closest(".dx-list-group");
    if (!$group.length) {
      return -1;
    }
    return combineIndex({
      group: this._groupElements().index($group),
      item: this._groupItemElements($group).index($item)
    });
  },
  _normalizeItemIndex: (index2) => combineIndex(index2),
  _denormalizeItemIndex: (index2) => splitIndex(index2),
  _getItemByNormalizedIndex(index2) {
    const indices = splitIndex(index2);
    const $group = this._groupElements().eq(indices.group);
    return this._groupItemElements($group).eq(indices.item);
  },
  _itemsFromSameParent: (firstIndex, secondIndex) => splitIndex(firstIndex).group === splitIndex(secondIndex).group
});
var m_list_edit_strategy_grouped_default = GroupedEditStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.js
var ListEdit = ListBase.inherit({
  _supportedKeys() {
    const that = this;
    const parent = this.callBase();
    const moveFocusedItem = (e, moveUp) => {
      const editStrategy = this._editStrategy;
      const focusedElement = this.option("focusedElement");
      const focusedItemIndex = editStrategy.getNormalizedIndex(focusedElement);
      const isLastIndexFocused = focusedItemIndex === this._getLastItemIndex();
      if (isLastIndexFocused && this._dataController.isLoading()) {
        return;
      }
      if (e.shiftKey && that.option("itemDragging.allowReordering")) {
        const nextItemIndex = focusedItemIndex + (moveUp ? -1 : 1);
        const $nextItem = editStrategy.getItemElement(nextItemIndex);
        this.reorderItem(focusedElement, $nextItem);
        this.scrollToItem(focusedElement);
        e.preventDefault();
      } else {
        const editProvider = this._editProvider;
        const isInternalMoving = editProvider.handleKeyboardEvents(focusedItemIndex, moveUp);
        if (!isInternalMoving) {
          moveUp ? parent.upArrow(e) : parent.downArrow(e);
        }
      }
    };
    return extend({}, parent, {
      del: (e) => {
        if (that.option("allowItemDeleting")) {
          e.preventDefault();
          that.deleteItem(that.option("focusedElement"));
        }
      },
      upArrow: (e) => moveFocusedItem(e, true),
      downArrow: (e) => moveFocusedItem(e),
      enter: function(e) {
        if (!this._editProvider.handleEnterPressing(e)) {
          parent.enter.apply(this, arguments);
        }
      },
      space: function(e) {
        if (!this._editProvider.handleEnterPressing(e)) {
          parent.space.apply(this, arguments);
        }
      }
    });
  },
  _updateSelection() {
    this._editProvider.afterItemsRendered();
    this.callBase();
  },
  _getLastItemIndex() {
    return this._itemElements().length - 1;
  },
  _refreshItemElements() {
    this.callBase();
    const excludedSelectors = this._editProvider.getExcludedItemSelectors();
    if (excludedSelectors.length) {
      this._itemElementsCache = this._itemElementsCache.not(excludedSelectors);
    }
  },
  _isItemStrictEquals(item1, item2) {
    const privateKey = item1 && item1.__dx_key__;
    if (privateKey && !this.key() && this._selection.isItemSelected(privateKey)) {
      return false;
    }
    return this.callBase(item1, item2);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      showSelectionControls: false,
      selectionMode: "none",
      selectAllMode: "page",
      onSelectAllValueChanged: null,
      selectAllText: message_default.format("dxList-selectAll"),
      menuItems: [],
      menuMode: "context",
      allowItemDeleting: false,
      itemDeleteMode: "static",
      itemDragging: {}
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: (device) => "ios" === device.platform,
      options: {
        menuMode: "slide",
        itemDeleteMode: "slideItem"
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        itemDeleteMode: "swipe"
      }
    }]);
  },
  _init() {
    this.callBase();
    this._initEditProvider();
  },
  _initDataSource() {
    this.callBase();
    if (!this._isPageSelectAll()) {
      this._dataSource && this._dataSource.requireTotalCount(true);
    }
  },
  _isPageSelectAll() {
    return "page" === this.option("selectAllMode");
  },
  _initEditProvider() {
    this._editProvider = new m_list_edit_provider_default(this);
  },
  _disposeEditProvider() {
    if (this._editProvider) {
      this._editProvider.dispose();
    }
  },
  _refreshEditProvider() {
    this._disposeEditProvider();
    this._initEditProvider();
  },
  _initEditStrategy() {
    if (this.option("grouped")) {
      this._editStrategy = new m_list_edit_strategy_grouped_default(this);
    } else {
      this.callBase();
    }
  },
  _initMarkup() {
    this._refreshEditProvider();
    this.callBase();
  },
  _renderItems() {
    this.callBase(...arguments);
    this._editProvider.afterItemsRendered();
  },
  _selectedItemClass: () => "dx-list-item-selected",
  _itemResponseWaitClass: () => "dx-list-item-response-wait",
  _itemClickHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = this._editProvider.handleClick($itemElement, e);
    if (handledByEditProvider) {
      return;
    }
    this._saveSelectionChangeEvent(e);
    this.callBase(...arguments);
  },
  _shouldFireContextMenuEvent() {
    return this.callBase(...arguments) || this._editProvider.contextMenuHandlerExists();
  },
  _itemHoldHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = isTouchEvent(e) && this._editProvider.handleContextMenu($itemElement, e);
    if (handledByEditProvider) {
      e.handledByEditProvider = true;
      return;
    }
    this.callBase(...arguments);
  },
  _getItemContainer(changeData) {
    if (this.option("grouped")) {
      var _this$_editStrategy$g;
      const groupIndex = null === (_this$_editStrategy$g = this._editStrategy.getIndexByItemData(changeData)) || void 0 === _this$_editStrategy$g ? void 0 : _this$_editStrategy$g.group;
      return this._getGroupContainerByIndex(groupIndex);
    }
    return this.callBase(changeData);
  },
  _itemContextMenuHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = !e.handledByEditProvider && this._editProvider.handleContextMenu($itemElement, e);
    if (handledByEditProvider) {
      e.preventDefault();
      return;
    }
    this.callBase(...arguments);
  },
  _postprocessRenderItem(args) {
    this.callBase(...arguments);
    this._editProvider.modifyItemElement(args);
  },
  _clean() {
    this._disposeEditProvider();
    this.callBase();
  },
  focusListItem(index2) {
    const $item = this._editStrategy.getItemElement(index2);
    this.option("focusedElement", $item);
    this.focus();
    this.scrollToItem(this.option("focusedElement"));
  },
  _optionChanged(args) {
    switch (args.name) {
      case "selectAllMode":
        this._initDataSource();
        this._dataController.pageIndex(0);
        this._dataController.load();
        break;
      case "grouped":
        this._clearSelectedItems();
        delete this._renderingGroupIndex;
        this._initEditStrategy();
        this.callBase(args);
        break;
      case "showSelectionControls":
      case "menuItems":
      case "menuMode":
      case "allowItemDeleting":
      case "itemDeleteMode":
      case "itemDragging":
      case "selectAllText":
        this._invalidate();
        break;
      case "onSelectAllValueChanged":
        break;
      default:
        this.callBase(args);
    }
  },
  selectAll() {
    return this._selection.selectAll(this._isPageSelectAll());
  },
  unselectAll() {
    return this._selection.deselectAll(this._isPageSelectAll());
  },
  isSelectAll() {
    return this._selection.getSelectAllState(this._isPageSelectAll());
  },
  getFlatIndexByItemElement(itemElement) {
    return this._itemElements().index(itemElement);
  },
  getItemElementByFlatIndex(flatIndex) {
    const $itemElements = this._itemElements();
    if (flatIndex < 0 || flatIndex >= $itemElements.length) {
      return renderer_default();
    }
    return $itemElements.eq(flatIndex);
  },
  getItemByIndex(index2) {
    return this._editStrategy.getItemDataByIndex(index2);
  },
  deleteItem(itemElement) {
    const editStrategy = this._editStrategy;
    const deletingElementIndex = editStrategy.getNormalizedIndex(itemElement);
    const focusedElement = this.option("focusedElement");
    const focusStateEnabled = this.option("focusStateEnabled");
    const focusedItemIndex = focusedElement ? editStrategy.getNormalizedIndex(focusedElement) : deletingElementIndex;
    const isLastIndexFocused = focusedItemIndex === this._getLastItemIndex();
    const nextFocusedItem = isLastIndexFocused || deletingElementIndex < focusedItemIndex ? focusedItemIndex - 1 : focusedItemIndex;
    const promise = this.callBase(itemElement);
    return promise.done(function() {
      if (focusStateEnabled) {
        this.focusListItem(nextFocusedItem);
      }
    });
  }
});
var m_list_edit_default = ListEdit;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.search.js
var ListSearch = m_list_edit_default.inherit(ui_search_box_mixin_default).inherit({
  _addWidgetPrefix: (className) => `dx-list-${className}`,
  _getCombinedFilter() {
    const dataController = this._dataController;
    const storeLoadOptions = {
      filter: dataController.filter()
    };
    dataController.addSearchFilter(storeLoadOptions);
    const {
      filter
    } = storeLoadOptions;
    return filter;
  },
  _initDataSource() {
    const value2 = this.option("searchValue");
    const expr = this.option("searchExpr");
    const mode = this.option("searchMode");
    this.callBase();
    const dataController = this._dataController;
    value2 && value2.length && dataController.searchValue(value2);
    mode.length && dataController.searchOperation(ui_search_box_mixin_default.getOperationBySearchMode(mode));
    expr && dataController.searchExpr(expr);
  }
});
var m_list_edit_search_default = ListSearch;

// ../../../../../../node_modules/devextreme/esm/ui/list_light.js
component_registrator_default("dxList", m_list_edit_search_default);
var list_light_default = m_list_edit_search_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_list.js
var window21 = getWindow();
var SEARCH_MODES = ["startswith", "contains", "endwith", "notcontains"];
var useCompositionEvents = "android" !== devices_default.real().platform;
var DropDownList = m_drop_down_editor_default.inherit({
  _supportedKeys() {
    const parent = this.callBase();
    return extend({}, parent, {
      tab(e) {
        if (this._allowSelectItemByTab()) {
          this._saveValueChangeEvent(e);
          const $focusedItem = renderer_default(this._list.option("focusedElement"));
          $focusedItem.length && this._setSelectedElement($focusedItem);
        }
        parent.tab.apply(this, arguments);
      },
      space: noop2,
      home: noop2,
      end: noop2
    });
  },
  _allowSelectItemByTab() {
    return this.option("opened") && "instantly" === this.option("applyValueMode");
  },
  _setSelectedElement($element) {
    const value2 = this._valueGetter(this._list._getItemData($element));
    this._setValue(value2);
  },
  _setValue(value2) {
    this.option("value", value2);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), extend(ui_data_expression_default._dataExpressionDefaultOptions(), {
      displayValue: void 0,
      searchEnabled: false,
      searchMode: "contains",
      searchTimeout: 500,
      minSearchLength: 0,
      searchExpr: null,
      valueChangeEvent: "input change keyup",
      selectedItem: null,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      encodeNoDataText: false,
      onSelectionChanged: null,
      onItemClick: noop2,
      showDataBeforeSearch: false,
      grouped: false,
      groupTemplate: "group",
      popupPosition: {
        my: "left top",
        at: "left bottom",
        offset: {
          h: 0,
          v: 0
        },
        collision: "flip"
      },
      wrapItemText: false,
      useItemTextAsTitle: false
    }));
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: {
        platform: "ios"
      },
      options: {
        popupPosition: {
          offset: {
            v: -1
          }
        }
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        buttonsLocation: "bottom center"
      }
    }]);
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      value: true,
      selectedItem: true,
      displayValue: true
    });
  },
  _init() {
    this.callBase();
    this._initDataExpressions();
    this._initActions();
    this._setListDataSource();
    this._validateSearchMode();
    this._clearSelectedItem();
    this._initItems();
  },
  _setListFocusedElementOptionChange() {
    this._list._updateParentActiveDescendant = this._updateActiveDescendant.bind(this);
  },
  _initItems() {
    const {
      items
    } = this.option();
    if (items && !items.length && this._dataSource) {
      this.option().items = this._dataSource.items();
    }
  },
  _initActions() {
    this._initContentReadyAction();
    this._initSelectionChangedAction();
    this._initItemClickAction();
  },
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption("onContentReady", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _initSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _initItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  },
  _initTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      item: new ChildDefaultTemplate("item")
    });
  },
  _isEditable() {
    return this.callBase() || this.option("searchEnabled");
  },
  _saveFocusOnWidget() {
    if (this._list && this._list.initialOption("focusStateEnabled")) {
      this._focusInput();
    }
  },
  _fitIntoRange(value2, start, end) {
    if (value2 > end) {
      return start;
    }
    if (value2 < start) {
      return end;
    }
    return value2;
  },
  _items() {
    const items = this._getPlainItems(!this._list && this._dataSource.items());
    const availableItems = new query_default(items).filter("disabled", "<>", true).toArray();
    return availableItems;
  },
  _calcNextItem(step) {
    const items = this._items();
    const nextIndex = this._fitIntoRange(this._getSelectedIndex() + step, 0, items.length - 1);
    return items[nextIndex];
  },
  _getSelectedIndex() {
    const items = this._items();
    const selectedItem = this.option("selectedItem");
    let result2 = -1;
    each(items, (index2, item) => {
      if (this._isValueEquals(item, selectedItem)) {
        result2 = index2;
        return false;
      }
    });
    return result2;
  },
  _createPopup() {
    this.callBase();
    this._updateCustomBoundaryContainer();
    this._popup.$wrapper().addClass(this._popupWrapperClass());
    const $popupContent = this._popup.$content();
    events_engine_default.off($popupContent, "mouseup");
    events_engine_default.on($popupContent, "mouseup", this._saveFocusOnWidget.bind(this));
  },
  _updateCustomBoundaryContainer() {
    const customContainer = this.option("dropDownOptions.container");
    const $container = customContainer && renderer_default(customContainer);
    if ($container && $container.length && !isWindow($container.get(0))) {
      const $containerWithParents = [].slice.call($container.parents());
      $containerWithParents.unshift($container.get(0));
      each($containerWithParents, (i, parent) => {
        if (parent === renderer_default("body").get(0)) {
          return false;
        }
        if ("hidden" === window21.getComputedStyle(parent).overflowY) {
          this._$customBoundaryContainer = renderer_default(parent);
          return false;
        }
      });
    }
  },
  _popupWrapperClass: () => "dx-dropdownlist-popup-wrapper",
  _renderInputValue() {
    const value2 = this._getCurrentValue();
    this._rejectValueLoading();
    return this._loadInputValue(value2, this._setSelectedItem.bind(this)).always(this.callBase.bind(this, value2));
  },
  _loadInputValue(value2, callback) {
    return this._loadItem(value2).always(callback);
  },
  _getItemFromPlain(value2, cache) {
    let plainItems;
    let selectedItem;
    if (cache && "object" !== typeof value2) {
      if (!cache.itemByValue) {
        cache.itemByValue = {};
        plainItems = this._getPlainItems();
        plainItems.forEach(function(item) {
          cache.itemByValue[this._valueGetter(item)] = item;
        }, this);
      }
      selectedItem = cache.itemByValue[value2];
    }
    if (!selectedItem) {
      plainItems = this._getPlainItems();
      selectedItem = grep(plainItems, (item) => this._isValueEquals(this._valueGetter(item), value2))[0];
    }
    return selectedItem;
  },
  _loadItem(value2, cache) {
    const selectedItem = this._getItemFromPlain(value2, cache);
    return void 0 !== selectedItem ? Deferred().resolve(selectedItem).promise() : this._loadValue(value2);
  },
  _getPlainItems(items) {
    let plainItems = [];
    items = items || this.option("items") || this._dataSource.items() || [];
    for (let i = 0; i < items.length; i++) {
      if (items[i] && items[i].items) {
        plainItems = plainItems.concat(items[i].items);
      } else {
        plainItems.push(items[i]);
      }
    }
    return plainItems;
  },
  _updateActiveDescendant($target) {
    var _this$_list;
    const opened = this.option("opened");
    const listFocusedItemId = null === (_this$_list = this._list) || void 0 === _this$_list ? void 0 : _this$_list.getFocusedItemId();
    const isElementOnDom = renderer_default(`#${listFocusedItemId}`).length > 0;
    const activedescendant = opened && isElementOnDom && listFocusedItemId;
    this.setAria({
      activedescendant: activedescendant || null
    }, $target);
  },
  _setSelectedItem(item) {
    const displayValue = this._displayValue(item);
    this.option("selectedItem", ensureDefined(item, null));
    this.option("displayValue", displayValue);
  },
  _displayValue(item) {
    return this._displayGetter(item);
  },
  _refreshSelected() {
    const cache = {};
    this._listItemElements().each((_, itemElement) => {
      const $itemElement = renderer_default(itemElement);
      const itemValue = this._valueGetter($itemElement.data("dxListItemData"));
      const isItemSelected = this._isSelectedValue(itemValue, cache);
      if (isItemSelected) {
        this._list.selectItem($itemElement);
      } else {
        this._list.unselectItem($itemElement);
      }
    });
  },
  _popupShownHandler() {
    this.callBase();
    this._setFocusPolicy();
  },
  _setFocusPolicy() {
    if (!this.option("focusStateEnabled") || !this._list) {
      return;
    }
    this._list.option("focusedElement", null);
  },
  _isSelectedValue(value2) {
    return this._isValueEquals(value2, this.option("value"));
  },
  _validateSearchMode() {
    const searchMode = this.option("searchMode");
    const normalizedSearchMode = searchMode.toLowerCase();
    if (!SEARCH_MODES.includes(normalizedSearchMode)) {
      throw ui_errors_default.Error("E1019", searchMode);
    }
  },
  _clearSelectedItem() {
    this.option("selectedItem", null);
  },
  _processDataSourceChanging() {
    this._initDataController();
    this._setListOption("_dataController", this._dataController);
    this._setListDataSource();
    this._renderInputValue().fail(() => {
      if (this._isCustomValueAllowed()) {
        return;
      }
      this._clearSelectedItem();
    });
  },
  _isCustomValueAllowed() {
    return this.option("displayCustomValue");
  },
  clear() {
    this.callBase();
    this._clearFilter();
    this._clearSelectedItem();
  },
  _listItemElements() {
    return this._$list ? this._$list.find(".dx-list-item") : renderer_default();
  },
  _popupConfig() {
    return extend(this.callBase(), {
      templatesRenderAsynchronously: false,
      autoResizeEnabled: false,
      maxHeight: this._getMaxHeight.bind(this)
    });
  },
  _renderPopupContent() {
    this.callBase();
    this._renderList();
  },
  _getKeyboardListeners() {
    const canListHaveFocus = this._canListHaveFocus();
    return this.callBase().concat([!canListHaveFocus && this._list]);
  },
  _renderList() {
    this._listId = `dx-${new guid_default()._value}`;
    const $list = renderer_default("<div>").attr("id", this._listId).appendTo(this._popup.$content());
    this._$list = $list;
    this._list = this._createComponent($list, list_light_default, this._listConfig());
    this._refreshList();
    this._renderPreventBlurOnListClick();
    this._setListFocusedElementOptionChange();
  },
  _renderPreventBlurOnListClick() {
    const eventName = addNamespace2("mousedown", "dxDropDownList");
    events_engine_default.off(this._$list, eventName);
    events_engine_default.on(this._$list, eventName, (e) => e.preventDefault());
  },
  _getControlsAria() {
    return this._list && this._listId;
  },
  _renderOpenedState() {
    this.callBase();
    this._list && this._updateActiveDescendant();
    this.setAria("owns", this._popup && this._popupContentId);
  },
  _getAriaHasPopup: () => "listbox",
  _refreshList() {
    if (this._list && this._shouldRefreshDataSource()) {
      this._setListDataSource();
    }
  },
  _shouldRefreshDataSource() {
    const dataSourceProvided = !!this._list.option("dataSource");
    return dataSourceProvided !== this._needPassDataSourceToList();
  },
  _isDesktopDevice: () => "desktop" === devices_default.real().deviceType,
  _listConfig() {
    const options2 = {
      selectionMode: "single",
      _templates: this.option("_templates"),
      templateProvider: this.option("templateProvider"),
      noDataText: this.option("noDataText"),
      encodeNoDataText: this.option("encodeNoDataText"),
      grouped: this.option("grouped"),
      wrapItemText: this.option("wrapItemText"),
      useItemTextAsTitle: this.option("useItemTextAsTitle"),
      onContentReady: this._listContentReadyHandler.bind(this),
      itemTemplate: this.option("itemTemplate"),
      indicateLoading: false,
      keyExpr: this._getCollectionKeyExpr(),
      displayExpr: this._displayGetterExpr(),
      groupTemplate: this.option("groupTemplate"),
      onItemClick: this._listItemClickAction.bind(this),
      dataSource: this._getDataSource(),
      _dataController: this._dataController,
      hoverStateEnabled: this._isDesktopDevice() ? this.option("hoverStateEnabled") : false,
      focusStateEnabled: this._isDesktopDevice() ? this.option("focusStateEnabled") : false
    };
    if (!this._canListHaveFocus()) {
      options2.tabIndex = null;
    }
    return options2;
  },
  _canListHaveFocus: () => false,
  _getDataSource() {
    return this._needPassDataSourceToList() ? this._dataSource : null;
  },
  _dataSourceOptions: () => ({
    paginate: false
  }),
  _getGroupedOption() {
    return this.option("grouped");
  },
  _dataSourceFromUrlLoadMode: () => "raw",
  _listContentReadyHandler() {
    this._list = this._list || this._$list.dxList("instance");
    if (!this.option("deferRendering")) {
      this._refreshSelected();
    }
    this._updatePopupWidth();
    this._updateListDimensions();
    this._contentReadyAction();
  },
  _setListOption(optionName, value2) {
    this._setWidgetOption("_list", arguments);
  },
  _listItemClickAction(e) {
    this._listItemClickHandler(e);
    this._itemClickAction(e);
  },
  _listItemClickHandler: noop2,
  _setListDataSource() {
    if (!this._list) {
      return;
    }
    this._setListOption("dataSource", this._getDataSource());
    if (!this._needPassDataSourceToList()) {
      this._setListOption("items", []);
    }
  },
  _needPassDataSourceToList() {
    return this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded();
  },
  _isMinSearchLengthExceeded() {
    return this._searchValue().toString().length >= this.option("minSearchLength");
  },
  _needClearFilter() {
    return this._canKeepDataSource() ? false : this._needPassDataSourceToList();
  },
  _canKeepDataSource() {
    const isMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
    return this._dataController.isLoaded() && this.option("showDataBeforeSearch") && this.option("minSearchLength") && !isMinSearchLengthExceeded && !this._isLastMinSearchLengthExceeded;
  },
  _searchValue() {
    return this._input().val() || "";
  },
  _getSearchEvent() {
    return addNamespace2("input", `${this.NAME}Search`);
  },
  _getCompositionStartEvent() {
    return addNamespace2("compositionstart", `${this.NAME}CompositionStart`);
  },
  _getCompositionEndEvent() {
    return addNamespace2("compositionend", `${this.NAME}CompositionEnd`);
  },
  _getSetFocusPolicyEvent() {
    return addNamespace2("input", `${this.NAME}FocusPolicy`);
  },
  _renderEvents() {
    this.callBase();
    events_engine_default.on(this._input(), this._getSetFocusPolicyEvent(), () => {
      this._setFocusPolicy();
    });
    if (this._shouldRenderSearchEvent()) {
      events_engine_default.on(this._input(), this._getSearchEvent(), (e) => {
        this._searchHandler(e);
      });
      if (useCompositionEvents) {
        events_engine_default.on(this._input(), this._getCompositionStartEvent(), () => {
          this._isTextCompositionInProgress(true);
        });
        events_engine_default.on(this._input(), this._getCompositionEndEvent(), (e) => {
          this._isTextCompositionInProgress(void 0);
          this._searchHandler(e, this._searchValue());
        });
      }
    }
  },
  _shouldRenderSearchEvent() {
    return this.option("searchEnabled");
  },
  _refreshEvents() {
    events_engine_default.off(this._input(), this._getSearchEvent());
    events_engine_default.off(this._input(), this._getSetFocusPolicyEvent());
    if (useCompositionEvents) {
      events_engine_default.off(this._input(), this._getCompositionStartEvent());
      events_engine_default.off(this._input(), this._getCompositionEndEvent());
    }
    this.callBase();
  },
  _isTextCompositionInProgress(value2) {
    if (arguments.length) {
      this._isTextComposition = value2;
    } else {
      return this._isTextComposition;
    }
  },
  _searchHandler(e, searchValue) {
    if (this._isTextCompositionInProgress()) {
      return;
    }
    if (!this._isMinSearchLengthExceeded()) {
      this._searchCanceled();
      return;
    }
    const searchTimeout = this.option("searchTimeout");
    if (searchTimeout) {
      this._clearSearchTimer();
      this._searchTimer = setTimeout(() => {
        this._searchDataSource(searchValue);
      }, searchTimeout);
    } else {
      this._searchDataSource(searchValue);
    }
  },
  _searchCanceled() {
    this._clearSearchTimer();
    if (this._needClearFilter()) {
      this._filterDataSource(null);
    }
    this._refreshList();
  },
  _searchDataSource() {
    let searchValue = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._searchValue();
    this._filterDataSource(searchValue);
  },
  _filterDataSource(searchValue) {
    this._clearSearchTimer();
    const dataController = this._dataController;
    dataController.searchExpr(this.option("searchExpr") || this._displayGetterExpr());
    dataController.searchOperation(this.option("searchMode"));
    dataController.searchValue(searchValue);
    dataController.load().done(this._dataSourceFiltered.bind(this, searchValue));
  },
  _clearFilter() {
    const dataController = this._dataController;
    dataController.searchValue() && dataController.searchValue(null);
  },
  _dataSourceFiltered() {
    this._isLastMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
    this._refreshList();
    this._refreshPopupVisibility();
  },
  _shouldOpenPopup() {
    return this._hasItemsToShow();
  },
  _refreshPopupVisibility() {
    if (this.option("readOnly") || !this._searchValue()) {
      return;
    }
    const shouldOpenPopup = this._shouldOpenPopup();
    if (shouldOpenPopup && !this._isFocused()) {
      return;
    }
    this.option("opened", shouldOpenPopup);
    if (shouldOpenPopup) {
      this._updatePopupWidth();
      this._updateListDimensions();
    }
  },
  _dataSourceChangedHandler(newItems) {
    if (0 === this._dataController.pageIndex()) {
      this.option().items = newItems;
    } else {
      this.option().items = this.option().items.concat(newItems);
    }
  },
  _hasItemsToShow() {
    const dataController = this._dataController;
    const resultItems = dataController.items() || [];
    const resultAmount = resultItems.length;
    const isMinSearchLengthExceeded = this._needPassDataSourceToList();
    return !!(isMinSearchLengthExceeded && resultAmount);
  },
  _clearSearchTimer() {
    clearTimeout(this._searchTimer);
    delete this._searchTimer;
  },
  _popupShowingHandler() {
    this._updatePopupWidth();
    this._updateListDimensions();
  },
  _dimensionChanged() {
    this.callBase();
    this._updateListDimensions();
  },
  _needPopupRepaint() {
    const dataController = this._dataController;
    const currentPageIndex = dataController.pageIndex();
    const needRepaint = isDefined(this._pageIndex) && currentPageIndex <= this._pageIndex || dataController.isLastPage() && !this._list._scrollViewIsFull();
    this._pageIndex = currentPageIndex;
    return needRepaint;
  },
  _updateListDimensions() {
    if (!this._popup) {
      return;
    }
    if (this._needPopupRepaint()) {
      this._popup.repaint();
    }
    this._list && this._list.updateDimensions();
  },
  _getMaxHeight() {
    const $element = this.$element();
    const $customBoundaryContainer = this._$customBoundaryContainer;
    const offsetTop = $element.offset().top - ($customBoundaryContainer ? $customBoundaryContainer.offset().top : 0);
    const windowHeight = getOuterHeight(window21);
    const containerHeight = $customBoundaryContainer ? Math.min(getOuterHeight($customBoundaryContainer), windowHeight) : windowHeight;
    const maxHeight = Math.max(offsetTop, containerHeight - offsetTop - getOuterHeight($element));
    return Math.min(0.5 * containerHeight, maxHeight);
  },
  _clean() {
    if (this._list) {
      delete this._list;
    }
    delete this._isLastMinSearchLengthExceeded;
    this.callBase();
  },
  _dispose() {
    this._clearSearchTimer();
    this.callBase();
  },
  _setCollectionWidgetOption() {
    this._setListOption.apply(this, arguments);
  },
  _setSubmitValue() {
    const value2 = this.option("value");
    const submitValue = this._shouldUseDisplayValue(value2) ? this._displayGetter(value2) : value2;
    this._getSubmitElement().val(submitValue);
  },
  _shouldUseDisplayValue(value2) {
    return "this" === this.option("valueExpr") && isObject(value2);
  },
  _optionChanged(args) {
    this._dataExpressionOptionChanged(args);
    switch (args.name) {
      case "hoverStateEnabled":
      case "focusStateEnabled":
        this._isDesktopDevice() && this._setListOption(args.name, args.value);
        this.callBase(args);
        break;
      case "items":
        if (!this.option("dataSource")) {
          this._processDataSourceChanging();
        }
        break;
      case "dataSource":
        this._processDataSourceChanging();
        break;
      case "valueExpr":
        this._renderValue();
        this._setListOption("keyExpr", this._getCollectionKeyExpr());
        break;
      case "displayExpr":
        this._renderValue();
        this._setListOption("displayExpr", this._displayGetterExpr());
        break;
      case "searchMode":
        this._validateSearchMode();
        break;
      case "minSearchLength":
        this._refreshList();
        break;
      case "searchEnabled":
      case "showDataBeforeSearch":
      case "searchExpr":
        this._invalidate();
        break;
      case "onContentReady":
        this._initContentReadyAction();
        break;
      case "onSelectionChanged":
        this._initSelectionChangedAction();
        break;
      case "onItemClick":
        this._initItemClickAction();
        break;
      case "grouped":
      case "groupTemplate":
      case "wrapItemText":
      case "noDataText":
      case "encodeNoDataText":
      case "useItemTextAsTitle":
        this._setListOption(args.name);
        break;
      case "displayValue":
        this.option("text", args.value);
        break;
      case "itemTemplate":
      case "searchTimeout":
        break;
      case "selectedItem":
        if (args.previousValue !== args.value) {
          this._selectionChangedAction({
            selectedItem: args.value
          });
        }
        break;
      default:
        this.callBase(args);
    }
  }
}).include(ui_data_expression_default, m_grouped_data_converter_mixin_default);
component_registrator_default("dxDropDownList", DropDownList);
var m_drop_down_list_default = DropDownList;

// ../../../../../../node_modules/devextreme/esm/ui/drop_down_editor/ui.drop_down_list.js
var ui_drop_down_list_default = m_drop_down_list_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_select_box.js
var SelectBox = ui_drop_down_list_default.inherit({
  _supportedKeys() {
    const that = this;
    const parent = this.callBase();
    const clearSelectBox = function(e) {
      const isEditable = this._isEditable();
      if (!isEditable) {
        if (this.option("showClearButton")) {
          e.preventDefault();
          this.clear();
        }
      } else if (this._valueSubstituted()) {
        this._preventFiltering = true;
      }
      this._savedTextRemoveEvent = e;
      this._preventSubstitution = true;
    };
    const searchIfNeeded = function() {
      if (that.option("searchEnabled") && that._valueSubstituted()) {
        that._searchHandler();
      }
    };
    return extend({}, parent, {
      tab() {
        if (this.option("opened") && !this._popup.getFocusableElements().length) {
          this._resetCaretPosition(true);
        }
        parent.tab && parent.tab.apply(this, arguments);
        this._cancelSearchIfNeed();
      },
      upArrow(e) {
        if (parent.upArrow.apply(this, arguments)) {
          if (!this.option("opened")) {
            this._setNextValue(e);
          }
          return true;
        }
        return;
      },
      downArrow(e) {
        if (parent.downArrow.apply(this, arguments)) {
          if (!this.option("opened")) {
            this._setNextValue(e);
          }
          return true;
        }
        return;
      },
      leftArrow() {
        var _parent$leftArrow;
        searchIfNeeded();
        null === (_parent$leftArrow = parent.leftArrow) || void 0 === _parent$leftArrow || _parent$leftArrow.apply(this, arguments);
      },
      rightArrow() {
        searchIfNeeded();
        parent.rightArrow && parent.rightArrow.apply(this, arguments);
      },
      home() {
        searchIfNeeded();
        parent.home && parent.home.apply(this, arguments);
      },
      end() {
        searchIfNeeded();
        parent.end && parent.end.apply(this, arguments);
      },
      escape() {
        const result2 = parent.escape && parent.escape.apply(this, arguments);
        this._cancelEditing();
        return result2 ?? true;
      },
      enter(e) {
        const isOpened = this.option("opened");
        const inputText = this._input().val().trim();
        const isCustomText = inputText && this._list && !this._list.option("focusedElement");
        if (!inputText && isDefined(this.option("value")) && this.option("allowClearing")) {
          this._saveValueChangeEvent(e);
          this.option({
            selectedItem: null,
            value: null
          });
          this.close();
        } else {
          if (this.option("acceptCustomValue")) {
            e.preventDefault();
            if (isCustomText) {
              if (isOpened) {
                this._toggleOpenState();
              }
              this._valueChangeEventHandler(e);
            }
            return isOpened;
          }
          if (parent.enter && parent.enter.apply(this, arguments)) {
            return isOpened;
          }
        }
      },
      space(e) {
        const isOpened = this.option("opened");
        const isSearchEnabled = this.option("searchEnabled");
        const acceptCustomValue = this.option("acceptCustomValue");
        if (!isOpened || isSearchEnabled || acceptCustomValue) {
          return;
        }
        e.preventDefault();
        this._valueChangeEventHandler(e);
        return true;
      },
      backspace: clearSelectBox,
      del: clearSelectBox
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      placeholder: message_default.format("Select"),
      fieldTemplate: null,
      customItemCreateEvent: "change",
      valueChangeEvent: "change",
      acceptCustomValue: false,
      onCustomItemCreating(e) {
        if (!isDefined(e.customItem)) {
          e.customItem = e.text;
        }
      },
      showSelectionControls: false,
      allowClearing: true,
      tooltipEnabled: false,
      openOnFieldClick: true,
      showDropDownButton: true,
      displayCustomValue: false,
      useHiddenSubmitElement: true
    });
  },
  _init() {
    this.callBase();
    this._initCustomItemCreatingAction();
  },
  _initMarkup() {
    this.$element().addClass("dx-selectbox");
    this._renderTooltip();
    this.callBase();
    this._$container.addClass("dx-selectbox-container");
  },
  _createPopup() {
    this.callBase();
    this._popup.$element().addClass("dx-selectbox-popup");
    this._popup.$overlayContent().attr("tabindex", -1);
  },
  _popupWrapperClass() {
    return `${this.callBase()} dx-selectbox-popup-wrapper`;
  },
  _setDeprecatedOptions() {
    this.callBase();
    extend(this._deprecatedOptions, {
      valueChangeEvent: {
        since: "22.2",
        alias: "customItemCreateEvent"
      }
    });
  },
  _cancelEditing() {
    if (!this.option("searchEnabled") && this._list) {
      this._focusListElement(null);
      this._updateField(this.option("selectedItem"));
    }
  },
  _renderOpenedState() {
    this.callBase();
    if (this.option("opened")) {
      this._scrollToSelectedItem();
      this._focusSelectedElement();
    }
  },
  _focusSelectedElement() {
    const searchValue = this._searchValue();
    if (!searchValue) {
      this._focusListElement(null);
      return;
    }
    const {
      items,
      selectedItem
    } = this.option();
    const $listItems = this._list._itemElements();
    const index2 = (null === items || void 0 === items ? void 0 : items.indexOf(selectedItem)) ?? -1;
    const focusedElement = -1 !== index2 && !this._isCustomItemSelected() ? $listItems.eq(index2) : null;
    this._focusListElement(focusedElement);
  },
  _renderFocusedElement() {
    if (!this._list) {
      return;
    }
    const searchValue = this._searchValue();
    if (!searchValue || this.option("acceptCustomValue")) {
      this._focusListElement(null);
      return;
    }
    const $listItems = this._list._itemElements();
    const focusedElement = $listItems.not(".dx-state-disabled").eq(0);
    this._focusListElement(focusedElement);
  },
  _focusListElement(element) {
    this._preventInputValueRender = true;
    this._list.option("focusedElement", getPublicElement(element));
    delete this._preventInputValueRender;
  },
  _scrollToSelectedItem() {
    this._list && this._list.scrollToItem(this._list.option("selectedItem"));
  },
  _listContentReadyHandler() {
    this.callBase();
    const isPaginate = this._dataController.paginate();
    if (isPaginate && this._needPopupRepaint()) {
      return;
    }
    this._scrollToSelectedItem();
  },
  _renderValue() {
    this._renderInputValue();
    this._setSubmitValue();
    return Deferred().resolve();
  },
  _renderInputValue() {
    return this.callBase().always(() => {
      this._renderInputValueAsync();
    });
  },
  _renderInputValueAsync() {
    this._renderTooltip();
    this._renderInputValueImpl().always(() => {
      this._refreshSelected();
    });
  },
  _renderInputValueImpl() {
    this._renderField();
    return Deferred().resolve();
  },
  _setNextItem(step) {
    const item = this._calcNextItem(step);
    const value2 = this._valueGetter(item);
    this._setValue(value2);
  },
  _setNextValue(e) {
    const dataSourceIsLoaded = this._dataController.isLoaded() ? Deferred().resolve() : this._dataController.load();
    dataSourceIsLoaded.done(() => {
      const selectedIndex = this._getSelectedIndex();
      const hasPages = this._dataController.pageSize();
      const isLastPage = this._dataController.isLastPage();
      const isLastItem = selectedIndex === this._items().length - 1;
      this._saveValueChangeEvent(e);
      const step = "downArrow" === normalizeKeyName(e) ? 1 : -1;
      if (hasPages && !isLastPage && isLastItem && step > 0) {
        if (!this._popup) {
          this._createPopup();
        }
        if (!this._dataController.isLoading()) {
          this._list._loadNextPage().done(this._setNextItem.bind(this, step));
        }
      } else {
        this._setNextItem(step);
      }
    });
  },
  _setSelectedItem(item) {
    const isUnknownItem = !this._isCustomValueAllowed() && void 0 === item;
    this.callBase(isUnknownItem ? null : item);
    if (!isUnknownItem && (!this._isEditable() || this._isCustomItemSelected())) {
      this._setListOption("selectedItem", this.option("selectedItem"));
    }
  },
  _isCustomValueAllowed() {
    return this.option("acceptCustomValue") || this.callBase();
  },
  _displayValue(item) {
    item = !isDefined(item) && this._isCustomValueAllowed() ? this.option("value") : item;
    return this.callBase(item);
  },
  _listConfig() {
    const result2 = extend(this.callBase(), {
      pageLoadMode: "scrollBottom",
      onSelectionChanged: this._getSelectionChangeHandler(),
      selectedItem: this.option("selectedItem"),
      onFocusedItemChanged: this._listFocusedItemChangeHandler.bind(this)
    });
    if (this.option("showSelectionControls")) {
      extend(result2, {
        showSelectionControls: true,
        selectByClick: true
      });
    }
    return result2;
  },
  _listFocusedItemChangeHandler(e) {
    if (this._preventInputValueRender) {
      return;
    }
    const list = e.component;
    const focusedElement = renderer_default(list.option("focusedElement"));
    const focusedItem = list._getItemData(focusedElement);
    this._updateField(focusedItem);
  },
  _updateField(item) {
    const fieldTemplate = this._getTemplateByOption("fieldTemplate");
    if (!(fieldTemplate && this.option("fieldTemplate"))) {
      const text = this._displayGetter(item);
      this.option("text", text);
      this._renderDisplayText(text);
      return;
    }
    this._renderField();
  },
  _getSelectionChangeHandler() {
    return this.option("showSelectionControls") ? this._selectionChangeHandler.bind(this) : noop2;
  },
  _selectionChangeHandler(e) {
    each(e.addedItems || [], (_, addedItem) => {
      this._setValue(this._valueGetter(addedItem));
    });
  },
  _getActualSearchValue() {
    return this._dataController.searchValue();
  },
  _isInlineAutocompleteEnabled() {
    return this.option("searchEnabled") && !this.option("acceptCustomValue") && "startswith" === this.option("searchMode");
  },
  _getAriaAutocomplete() {
    const {
      disabled,
      readOnly,
      searchEnabled
    } = this.option();
    const isInputEditable = !(readOnly || disabled);
    const hasAutocomplete = searchEnabled && isInputEditable;
    if (!hasAutocomplete) {
      return "none";
    }
    const isInlineAutocompleteEnabled = this._isInlineAutocompleteEnabled();
    const autocompleteAria = isInlineAutocompleteEnabled ? "both" : "list";
    return autocompleteAria;
  },
  _toggleOpenState(isVisible2) {
    if (this.option("disabled")) {
      return;
    }
    isVisible2 = arguments.length ? isVisible2 : !this.option("opened");
    if (!isVisible2 && !this._shouldClearFilter()) {
      this._restoreInputText(true);
    }
    if (this._wasSearch() && isVisible2) {
      this._wasSearch(false);
      const showDataImmediately = this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded();
      if (showDataImmediately && this._dataController.getDataSource()) {
        if (this._searchTimer) {
          return;
        }
        const searchValue = this._getActualSearchValue();
        searchValue && this._wasSearch(true);
        this._filterDataSource(searchValue || null);
      } else {
        this._setListOption("items", []);
      }
    }
    if (isVisible2) {
      this._scrollToSelectedItem();
    }
    this.callBase(isVisible2);
  },
  _renderTooltip() {
    if (this.option("tooltipEnabled")) {
      this.$element().attr("title", this.option("displayValue"));
    }
  },
  _renderDimensions() {
    this.callBase();
    this._updatePopupWidth();
    this._updateListDimensions();
  },
  _isValueEqualInputText() {
    const initialSelectedItem = this.option("selectedItem");
    if (null === initialSelectedItem) {
      return false;
    }
    const value2 = this._displayGetter(initialSelectedItem);
    const displayValue = value2 ? String(value2) : "";
    const inputText = this._searchValue();
    return displayValue === inputText;
  },
  _popupHidingHandler() {
    if (this._isValueEqualInputText()) {
      this._cancelEditing();
    }
    this.callBase();
  },
  _popupHiddenHandler() {
    this.callBase();
    if (this._shouldCancelSearch()) {
      this._wasSearch(false);
      this._searchCanceled();
      this._shouldCancelSearch(false);
    }
  },
  _restoreInputText(saveEditingValue) {
    if (this.option("readOnly")) {
      return;
    }
    this._loadItemDeferred && this._loadItemDeferred.always(() => {
      const {
        acceptCustomValue,
        text,
        selectedItem: initialSelectedItem
      } = this.option();
      if (acceptCustomValue) {
        if (!saveEditingValue && !this._isValueChanging) {
          this._updateField(initialSelectedItem ?? this._createCustomItem(text));
          this._clearFilter();
        }
        return;
      }
      if (this.option("searchEnabled")) {
        if (!this._searchValue() && this.option("allowClearing")) {
          this._clearTextValue();
          return;
        }
      }
      if (this._isValueEqualInputText()) {
        return;
      }
      this._renderInputValue().always((selectedItem) => {
        const newSelectedItem = ensureDefined(selectedItem, initialSelectedItem);
        this._setSelectedItem(newSelectedItem);
        this._updateField(newSelectedItem);
        this._clearFilter();
      });
    });
  },
  _valueChangeEventIncludesBlur() {
    const valueChangeEvent = this.option(this._getValueChangeEventOptionName());
    return valueChangeEvent.includes("blur");
  },
  _isPreventedFocusOutEvent(e) {
    return this._preventNestedFocusEvent(e) || this._valueChangeEventIncludesBlur();
  },
  _focusOutHandler(e) {
    if (!this._isPreventedFocusOutEvent(e)) {
      const isOverlayTarget = this._isOverlayNestedTarget(e.relatedTarget);
      if (!isOverlayTarget) {
        this._restoreInputText();
        this._clearSearchTimer();
      }
      this._cancelSearchIfNeed(e);
    }
    e.target = this._input().get(0);
    this.callBase(e);
  },
  _cancelSearchIfNeed(e) {
    const {
      searchEnabled
    } = this.option();
    const isOverlayTarget = this._isOverlayNestedTarget(null === e || void 0 === e ? void 0 : e.relatedTarget);
    const shouldCancelSearch = this._wasSearch() && searchEnabled && !isOverlayTarget;
    if (shouldCancelSearch) {
      var _this$_popup;
      const isPopupVisible = null === (_this$_popup = this._popup) || void 0 === _this$_popup ? void 0 : _this$_popup._hideAnimationProcessing;
      this._clearSearchTimer();
      if (isPopupVisible) {
        this._shouldCancelSearch(true);
      } else {
        this._wasSearch(false);
        this._searchCanceled();
      }
    }
  },
  _shouldCancelSearch(value2) {
    if (!arguments.length) {
      return this._shouldCancelSearchValue;
    }
    this._shouldCancelSearchValue = value2;
  },
  _isOverlayNestedTarget: (target) => !!renderer_default(target).closest(".dx-selectbox-popup-wrapper").length,
  _clearTextValue() {
    const selectedItem = this.option("selectedItem");
    const selectedItemText = this._displayGetter(selectedItem);
    const shouldRestoreValue = selectedItem && "" !== selectedItemText;
    if (shouldRestoreValue) {
      if (this._savedTextRemoveEvent) {
        this._saveValueChangeEvent(this._savedTextRemoveEvent);
      }
      this.option("value", null);
    }
    delete this._savedTextRemoveEvent;
  },
  _shouldOpenPopup() {
    return this._needPassDataSourceToList() && this._wasSearch();
  },
  _isFocused() {
    const activeElement = dom_adapter_default.getActiveElement(this.element());
    return this.callBase() && renderer_default(activeElement).closest(this._input()).length > 0;
  },
  _getValueChangeEventOptionName: () => "customItemCreateEvent",
  _renderValueChangeEvent() {
    if (this._isEditable()) {
      this.callBase();
    }
  },
  _fieldRenderData() {
    const $listFocused = this._list && this.option("opened") && renderer_default(this._list.option("focusedElement"));
    if ($listFocused && $listFocused.length) {
      return this._list._getItemData($listFocused);
    }
    return this.option("selectedItem");
  },
  _isSelectedValue(value2) {
    return this._isValueEquals(value2, this.option("value"));
  },
  _shouldCloseOnItemClick() {
    return !(this.option("showSelectionControls") && "single" !== this.option("selectionMode"));
  },
  _listItemClickHandler(e) {
    const previousValue = this._getCurrentValue();
    this._focusListElement(renderer_default(e.itemElement));
    this._saveValueChangeEvent(e.event);
    this._completeSelection(this._valueGetter(e.itemData));
    if (this._shouldCloseOnItemClick()) {
      this.option("opened", false);
    }
    if (this.option("searchEnabled") && previousValue === this._valueGetter(e.itemData)) {
      this._updateField(e.itemData);
    }
    if (this._shouldClearFilter()) {
      this._cancelSearchIfNeed();
    }
  },
  _shouldClearFilter() {
    return this._wasSearch();
  },
  _completeSelection(value2) {
    this._setValue(value2);
  },
  _loadItem(value2, cache) {
    const that = this;
    const deferred = Deferred();
    this.callBase(value2, cache).done((item) => {
      deferred.resolve(item);
    }).fail((args) => {
      if (null !== args && void 0 !== args && args.shouldSkipCallback) {
        return;
      }
      const selectedItem = that.option("selectedItem");
      if (that.option("acceptCustomValue") && value2 === that._valueGetter(selectedItem)) {
        deferred.resolve(selectedItem);
      } else {
        deferred.reject();
      }
    });
    return deferred.promise();
  },
  _loadInputValue(value2, callback) {
    this._loadItemDeferred = this._loadItem(value2).always(callback);
    return this._loadItemDeferred;
  },
  _isCustomItemSelected() {
    const selectedItem = this.option("selectedItem");
    const searchValue = this._searchValue();
    const selectedItemText = this._displayGetter(selectedItem);
    return !selectedItemText || searchValue !== selectedItemText.toString();
  },
  _valueChangeEventHandler(e) {
    if (this.option("acceptCustomValue") && this._isCustomItemSelected() && !this._isValueChanging) {
      this._isValueChanging = true;
      this._customItemAddedHandler(e);
    }
  },
  _initCustomItemCreatingAction() {
    this._customItemCreatingAction = this._createActionByOption("onCustomItemCreating");
  },
  _createCustomItem(text) {
    const params = {
      text
    };
    const actionResult = this._customItemCreatingAction(params);
    const item = ensureDefined(actionResult, params.customItem);
    if (isDefined(actionResult)) {
      errors_default.log("W0015", "onCustomItemCreating", "customItem");
    }
    return item;
  },
  _customItemAddedHandler(e) {
    const searchValue = this._searchValue();
    const item = this._createCustomItem(searchValue);
    this._saveValueChangeEvent(e);
    if (void 0 === item) {
      this._renderValue();
      throw errors_default.Error("E0121");
    }
    if (isPromise(item)) {
      fromPromise(item).done(this._setCustomItem.bind(this)).fail(this._setCustomItem.bind(this, null));
    } else {
      this._setCustomItem(item);
    }
  },
  _setCustomItem(item) {
    if (this._disposed) {
      return;
    }
    item = item || null;
    this.option("selectedItem", item);
    this._cancelSearchIfNeed();
    this._setValue(this._valueGetter(item));
    this._renderDisplayText(this._displayGetter(item));
    this._isValueChanging = false;
  },
  _clearValueHandler(e) {
    this._preventFiltering = true;
    this.callBase(e);
    this._searchCanceled();
    return false;
  },
  _wasSearch(value2) {
    if (!arguments.length) {
      return !!this._wasSearchValue;
    }
    this._wasSearchValue = value2;
    return;
  },
  _searchHandler() {
    if (this._preventFiltering) {
      delete this._preventFiltering;
      return;
    }
    if (this._needPassDataSourceToList()) {
      this._wasSearch(true);
    }
    this.callBase(arguments);
  },
  _dataSourceFiltered(searchValue) {
    this.callBase();
    if (null !== searchValue) {
      this._renderInputSubstitution();
      this._renderFocusedElement();
    }
  },
  _valueSubstituted() {
    const input = this._input().get(0);
    const currentSearchLength = this._searchValue().length;
    const isAllSelected = 0 === input.selectionStart && input.selectionEnd === currentSearchLength;
    const inputHasSelection = input.selectionStart !== input.selectionEnd;
    const isLastSymbolSelected = currentSearchLength === input.selectionEnd;
    return this._wasSearch() && inputHasSelection && !isAllSelected && isLastSymbolSelected && this._shouldSubstitutionBeRendered();
  },
  _shouldSubstitutionBeRendered() {
    return !this._preventSubstitution && this._isInlineAutocompleteEnabled();
  },
  _renderInputSubstitution() {
    if (!this._shouldSubstitutionBeRendered()) {
      delete this._preventSubstitution;
      return;
    }
    const item = this._list && this._getPlainItems(this._list.option("items"))[0];
    if (!item) {
      return;
    }
    const $input = this._input();
    const valueLength = $input.val().length;
    if (0 === valueLength) {
      return;
    }
    const inputElement = $input.get(0);
    const displayValue = this._displayGetter(item).toString();
    inputElement.value = displayValue;
    this._caret({
      start: valueLength,
      end: displayValue.length
    });
  },
  _dispose() {
    this._renderInputValueAsync = noop2;
    delete this._loadItemDeferred;
    this.callBase();
  },
  _optionChanged(args) {
    switch (args.name) {
      case "customItemCreateEvent":
        this._refreshValueChangeEvent();
        this._refreshFocusEvent();
        this._refreshEvents();
        break;
      case "onCustomItemCreating":
        this._initCustomItemCreatingAction();
        break;
      case "tooltipEnabled":
        this._renderTooltip();
        break;
      case "readOnly":
      case "disabled":
      case "searchMode":
        this.callBase(args);
        this._setDefaultAria();
        break;
      case "displayCustomValue":
      case "acceptCustomValue":
      case "showSelectionControls":
        this._invalidate();
        break;
      case "allowClearing":
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxSelectBox", SelectBox);
var m_select_box_default = SelectBox;

// ../../../../../../node_modules/devextreme/esm/ui/select_box.js
var select_box_default = m_select_box_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_time_view.js
var rotateArrow = function($arrow, angle, offset2) {
  cssRotate($arrow, angle, offset2);
};
var cssRotate = function($arrow, angle, offset2) {
  $arrow.css("transform", `rotate(${angle}deg) translate(0,${offset2}px)`);
};
var TimeView = editor_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: new Date(Date.now()),
      use24HourFormat: true,
      _showClock: true,
      _arrowOffset: 5,
      stylingMode: void 0
    });
  },
  _getValue() {
    return this.option("value") || /* @__PURE__ */ new Date();
  },
  _init() {
    this.callBase();
    this.$element().addClass("dx-timeview");
  },
  _render() {
    this.callBase();
    this._renderBox();
    this._updateTime();
  },
  _renderBox() {
    const $box = renderer_default("<div>").appendTo(this.$element());
    const items = [];
    if (this.option("_showClock")) {
      items.push({
        ratio: 1,
        shrink: 0,
        baseSize: "auto",
        template: this._renderClock.bind(this)
      });
    }
    items.push({
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: this._renderField.bind(this)
    });
    this._createComponent($box, box_default, {
      height: "100%",
      width: "100%",
      direction: "col",
      items
    });
  },
  _renderClock(_, __, container) {
    this._$hourArrow = renderer_default("<div>").addClass("dx-timeview-hourarrow");
    this._$minuteArrow = renderer_default("<div>").addClass("dx-timeview-minutearrow");
    const $container = renderer_default(container);
    $container.addClass("dx-timeview-clock").append(this._$hourArrow).append(this._$minuteArrow);
    this.setAria("role", "presentation", $container);
  },
  _updateClock() {
    const time = this._getValue();
    const hourArrowAngle = time.getHours() / 12 * 360 + time.getMinutes() / 60 * 30;
    const minuteArrowAngle = time.getMinutes() / 60 * 360;
    rotateArrow(this._$hourArrow, hourArrowAngle, this.option("_arrowOffset"));
    rotateArrow(this._$minuteArrow, minuteArrowAngle, this.option("_arrowOffset"));
  },
  _getBoxItems(is12HourFormat) {
    const items = [{
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: () => this._hourBox.$element()
    }, {
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: renderer_default("<div>").addClass("dx-timeview-time-separator").text(date_default2.getTimeSeparator())
    }, {
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: () => this._minuteBox.$element()
    }];
    if (is12HourFormat) {
      items.push({
        ratio: 0,
        shrink: 0,
        baseSize: "auto",
        template: () => this._format12.$element()
      });
    }
    return items;
  },
  _renderField() {
    const is12HourFormat = !this.option("use24HourFormat");
    this._createHourBox(is12HourFormat);
    this._createMinuteBox();
    if (is12HourFormat) {
      this._createFormat12Box();
    }
    return this._createComponent(renderer_default("<div>").addClass("dx-timeview-field"), box_default, {
      direction: "row",
      align: "center",
      crossAlign: "center",
      items: this._getBoxItems(is12HourFormat)
    }).$element();
  },
  _createHourBox(is12HourFormat) {
    const editor = this._hourBox = this._createComponent(renderer_default("<div>"), number_box_default, extend({
      min: -1,
      max: is12HourFormat ? 13 : 24,
      value: this._getValue().getHours(),
      onValueChanged: this._onHourBoxValueChanged.bind(this),
      onKeyboardHandled: (opts) => this._keyboardHandler(opts)
    }, this._getNumberBoxConfig()));
    editor.setAria("label", "hours");
  },
  _isPM() {
    return !this.option("use24HourFormat") && 1 === this._format12.option("value");
  },
  _onHourBoxValueChanged(_ref) {
    let {
      value: value2,
      component
    } = _ref;
    const currentValue = this._getValue();
    const newValue = new Date(currentValue);
    let newHours = this._convertMaxHourToMin(value2);
    component.option("value", newHours);
    if (this._isPM()) {
      newHours += 12;
    }
    newValue.setHours(newHours);
    m_date_utils_default.normalizeTime(newValue);
    this.option("value", newValue);
  },
  _convertMaxHourToMin(hours) {
    const maxHoursValue = this.option("use24HourFormat") ? 24 : 12;
    return (maxHoursValue + hours) % maxHoursValue;
  },
  _createMinuteBox() {
    const editor = this._minuteBox = this._createComponent(renderer_default("<div>"), number_box_default, extend({
      min: -1,
      max: 60,
      value: this._getValue().getMinutes(),
      onKeyboardHandled: (opts) => this._keyboardHandler(opts),
      onValueChanged: (_ref2) => {
        let {
          value: value2,
          component
        } = _ref2;
        const newMinutes = (60 + value2) % 60;
        component.option("value", newMinutes);
        const time = new Date(this._getValue());
        time.setMinutes(newMinutes);
        m_date_utils_default.normalizeTime(time);
        this.option("value", time);
      }
    }, this._getNumberBoxConfig()));
    editor.setAria("label", "minutes");
  },
  _createFormat12Box() {
    const periodNames = date_default2.getPeriodNames();
    const editor = this._format12 = this._createComponent(renderer_default("<div>").addClass("dx-timeview-format12"), select_box_default, {
      items: [{
        value: -1,
        text: periodNames[0]
      }, {
        value: 1,
        text: periodNames[1]
      }],
      valueExpr: "value",
      displayExpr: "text",
      onKeyboardHandled: (opts) => this._keyboardHandler(opts),
      onValueChanged: (_ref3) => {
        let {
          value: value2
        } = _ref3;
        const hours = this._getValue().getHours();
        const time = new Date(this._getValue());
        const newHours = (hours + 12 * value2) % 24;
        time.setHours(newHours);
        this.option("value", time);
      },
      value: this._getValue().getHours() >= 12 ? 1 : -1,
      stylingMode: this.option("stylingMode")
    });
    editor.setAria("label", "type");
  },
  _refreshFormat12() {
    if (this.option("use24HourFormat")) {
      return;
    }
    const value2 = this._getValue();
    const hours = value2.getHours();
    const isPM = hours >= 12;
    const newValue = isPM ? 1 : -1;
    this._silentEditorValueUpdate(this._format12, newValue);
  },
  _silentEditorValueUpdate(editor, value2) {
    if (editor) {
      editor._suppressValueChangeAction();
      editor.option("value", value2);
      editor._resumeValueChangeAction();
    }
  },
  _getNumberBoxConfig() {
    return {
      showSpinButtons: true,
      displayValueFormatter: (value2) => (value2 < 10 ? "0" : "") + value2,
      stylingMode: this.option("stylingMode")
    };
  },
  _normalizeHours(hours) {
    return this.option("use24HourFormat") ? hours : hours % 12 || 12;
  },
  _updateField() {
    const hours = this._normalizeHours(this._getValue().getHours());
    this._silentEditorValueUpdate(this._hourBox, hours);
    this._silentEditorValueUpdate(this._minuteBox, this._getValue().getMinutes());
    this._refreshFormat12();
  },
  _updateTime() {
    if (this.option("_showClock")) {
      this._updateClock();
    }
    this._updateField();
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._updateTime();
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "value":
        this._updateTime();
        this.callBase(args);
        break;
      case "_arrowOffset":
        break;
      case "use24HourFormat":
      case "_showClock":
      case "stylingMode":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxTimeView", TimeView);
var m_time_view_default = TimeView;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.calendar_with_time.js
var window22 = getWindow();
var DATEBOX_TIMEVIEW_SIDE_CLASS = "dx-datebox-datetime-time-side";
var CalendarWithTimeStrategy = m_date_box_strategy_calendar_default.inherit({
  NAME: "CalendarWithTime",
  getDefaultOptions() {
    return extend(this.callBase(), {
      applyValueMode: "useButtons",
      buttonsLocation: "bottom after",
      "dropDownOptions.showTitle": false
    });
  },
  _closeDropDownByEnter() {
    return date_default3.sameDate(this._getContouredValue(), this.widgetOption("value"));
  },
  getDisplayFormat: (displayFormat) => displayFormat || "shortdateshorttime",
  _is24HourFormat() {
    return date_default2.is24HourFormat(this.getDisplayFormat(this.dateBox.option("displayFormat")));
  },
  _getContouredValue() {
    const viewDate = this.callBase();
    return this._updateDateTime(viewDate);
  },
  _renderWidget() {
    this.callBase();
    this._timeView = this.dateBox._createComponent(renderer_default("<div>"), m_time_view_default, {
      value: this.dateBoxValue(),
      _showClock: !this._isShrinkView(),
      use24HourFormat: this._is24HourFormat(),
      onValueChanged: this._valueChangedHandler.bind(this),
      stylingMode: this.dateBox.option("stylingMode")
    });
  },
  renderOpenedState() {
    this.callBase();
    const popup = this._getPopup();
    if (popup) {
      popup.$wrapper().toggleClass("dx-datebox-adaptivity-mode", this._isSmallScreen());
    }
    clearTimeout(this._repaintTimer);
    this._repaintTimer = setTimeout(() => {
      this._getPopup() && this._getPopup().repaint();
    }, 0);
  },
  isAdaptivityChanged() {
    const isAdaptiveMode = this._isShrinkView();
    const currentAdaptiveMode = this._currentAdaptiveMode;
    if (isAdaptiveMode !== currentAdaptiveMode) {
      this._currentAdaptiveMode = isAdaptiveMode;
      return void 0 !== currentAdaptiveMode;
    }
    return this.callBase();
  },
  _updateValue(preventDefaultValue) {
    let date = this.dateBoxValue();
    if (!date && !preventDefaultValue) {
      date = /* @__PURE__ */ new Date();
      m_date_utils_default.normalizeTime(date);
    }
    this.callBase();
    if (this._timeView) {
      date && this._timeView.option("value", date);
      this._timeView.option("use24HourFormat", this._is24HourFormat());
    }
  },
  _isSmallScreen: () => getWidth(window22) <= 573,
  _isShrinkView() {
    return !this.dateBox.option("showAnalogClock") || this.dateBox.option("adaptivityEnabled") && this._isSmallScreen();
  },
  _getBoxItems() {
    const items = [{
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      name: "calendar"
    }];
    if (!this._isShrinkView()) {
      items.push({
        ratio: 0,
        shrink: 0,
        baseSize: "auto",
        name: "time"
      });
    }
    return items;
  },
  renderPopupContent() {
    this.callBase();
    this._currentAdaptiveMode = this._isShrinkView();
    const $popupContent = this._getPopup().$content();
    this._box = this.dateBox._createComponent(renderer_default("<div>").appendTo($popupContent), box_default, {
      direction: "row",
      crossAlign: "stretch",
      items: this._getBoxItems(),
      itemTemplate: (function(data2, i, element) {
        const $container = renderer_default("<div>");
        switch (data2.name) {
          case "calendar":
            $container.append(this._widget.$element());
            if (this._isShrinkView()) {
              this._timeView.$element().addClass(DATEBOX_TIMEVIEW_SIDE_CLASS);
              $container.append(this._timeView.$element());
            }
            break;
          case "time":
            $container.append(this._timeView.$element());
            renderer_default(element).addClass(DATEBOX_TIMEVIEW_SIDE_CLASS);
        }
        return $container;
      }).bind(this)
    });
  },
  popupConfig(popupConfig) {
    const calendarPopupConfig = this.callBase(popupConfig);
    return extend(calendarPopupConfig, {
      width: "auto"
    });
  },
  _preventFocusOnPopup(e) {
    if (!renderer_default(e.target).hasClass("dx-texteditor-input")) {
      this.callBase.apply(this, arguments);
      if (!this.dateBox._hasFocusClass()) {
        this.dateBox.focus();
      }
    }
  },
  _updateDateTime(date) {
    const time = this._timeView.option("value");
    date.setHours(time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    return date;
  },
  getValue() {
    let date = this._widget.option("value") ?? this._widget.getContouredDate();
    date = date ? new Date(date) : /* @__PURE__ */ new Date();
    return this._updateDateTime(date);
  },
  dispose() {
    clearTimeout(this._removeMinWidthTimer);
    clearTimeout(this._repaintTimer);
    this.callBase();
  }
});
var m_date_box_strategy_calendar_with_time_default = CalendarWithTimeStrategy;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/scroll_direction.js
var ScrollDirection = class {
  constructor(direction) {
    this.DIRECTION_HORIZONTAL = "horizontal";
    this.DIRECTION_VERTICAL = "vertical";
    this.DIRECTION_BOTH = "both";
    this.direction = direction ?? DIRECTION_VERTICAL;
  }
  get isHorizontal() {
    return this.direction === DIRECTION_HORIZONTAL || this.direction === DIRECTION_BOTH;
  }
  get isVertical() {
    return this.direction === DIRECTION_VERTICAL || this.direction === DIRECTION_BOTH;
  }
  get isBoth() {
    return this.direction === DIRECTION_BOTH;
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/convert_location.js
function convertToLocation(location, direction) {
  if (isPlainObject(location)) {
    const left = ensureDefined(location.left, location.x);
    const top = ensureDefined(location.top, location.y);
    return {
      left: isDefined(left) ? left : void 0,
      top: isDefined(top) ? top : void 0
    };
  }
  const {
    isHorizontal,
    isVertical
  } = new ScrollDirection(direction);
  return {
    left: isHorizontal && isDefined(location) ? location : void 0,
    top: isVertical && isDefined(location) ? location : void 0
  };
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_view_roller.js
var DateViewRoller = class extends m_scrollable_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      showScrollbar: "never",
      useNative: false,
      selectedIndex: 0,
      bounceEnabled: false,
      items: [],
      showOnClick: false,
      onClick: null,
      onSelectedIndexChanged: null,
      scrollByContent: true
    });
  }
  _init() {
    super._init();
    this.option("onVisibilityChange", this._visibilityChangedHandler.bind(this));
    this.option("onEnd", this._endActionHandler.bind(this));
  }
  _render() {
    super._render();
    this._renderSelectedItemFrame();
    this.$element().addClass("dx-dateviewroller");
    this._renderContainerClick();
    this._renderItems();
    this._renderSelectedValue();
    this._renderItemsClick();
    this._renderWheelEvent();
    this._renderSelectedIndexChanged();
  }
  _renderSelectedIndexChanged() {
    this._selectedIndexChanged = this._createActionByOption("onSelectedIndexChanged");
  }
  _renderWheelEvent() {
    events_engine_default.on(renderer_default(this.container()), "dxmousewheel", (e) => {
      this._isWheelScrolled = true;
    });
  }
  _renderContainerClick() {
    if (!this.option("showOnClick")) {
      return;
    }
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const clickAction = this._createActionByOption("onClick");
    events_engine_default.off(renderer_default(this.container()), eventName);
    events_engine_default.on(renderer_default(this.container()), eventName, (e) => {
      clickAction({
        event: e
      });
    });
  }
  _renderItems() {
    const items = this.option("items") || [];
    let $items = renderer_default();
    renderer_default(this.content()).empty();
    items.forEach((item) => {
      $items = $items.add(renderer_default("<div>").addClass("dx-dateview-item").append(item));
    });
    renderer_default(this.content()).append($items);
    this._$items = $items;
    this.update();
  }
  _renderSelectedItemFrame() {
    renderer_default("<div>").addClass("dx-dateview-item-selected-frame").append(renderer_default("<div>").addClass("dx-dateview-item-selected-border")).appendTo(renderer_default(this.container()));
  }
  _renderSelectedValue(selectedIndex) {
    const index2 = this._fitIndex(selectedIndex ?? this.option("selectedIndex"));
    this._moveTo({
      top: this._getItemPosition(index2)
    });
    this._renderActiveStateItem();
  }
  _fitIndex(index2) {
    const items = this.option("items") || [];
    const itemCount = items.length;
    if (index2 >= itemCount) {
      return itemCount - 1;
    }
    if (index2 < 0) {
      return 0;
    }
    return index2;
  }
  _getItemPosition(index2) {
    return Math.round(this._itemHeight() * index2);
  }
  _renderItemsClick() {
    const itemSelector = this._getItemSelector();
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    events_engine_default.off(this.$element(), eventName, itemSelector);
    events_engine_default.on(this.$element(), eventName, itemSelector, this._itemClickHandler.bind(this));
  }
  _getItemSelector() {
    return ".dx-dateview-item";
  }
  _itemClickHandler(e) {
    this.option("selectedIndex", this._itemElementIndex(e.currentTarget));
  }
  _itemElementIndex(itemElement) {
    return this._itemElements().index(itemElement);
  }
  _itemElements() {
    return this.$element().find(this._getItemSelector());
  }
  _renderActiveStateItem() {
    const selectedIndex = this.option("selectedIndex");
    each(this._$items, function(index2) {
      renderer_default(this).toggleClass("dx-dateview-item-selected", selectedIndex === index2);
    });
  }
  _shouldScrollToNeighborItem() {
    return "desktop" === devices_default.real().deviceType && this._isWheelScrolled;
  }
  _moveTo(targetLocation) {
    const {
      top,
      left
    } = convertToLocation(targetLocation);
    const location = this.scrollOffset();
    const delta = {
      x: location.left - left,
      y: location.top - top
    };
    if (this._isVisible() && (delta.x || delta.y)) {
      this._prepareDirections(true);
      if (this._animation && !this._shouldScrollToNeighborItem()) {
        const that = this;
        fx_default.stop(renderer_default(this.content()));
        fx_default.animate(renderer_default(this.content()), {
          duration: 200,
          type: "slide",
          to: {
            top: Math.floor(delta.y)
          },
          complete() {
            resetPosition(renderer_default(that.content()));
            that.handleMove({
              delta
            });
          }
        });
        delete this._animation;
      } else {
        this.handleMove({
          delta
        });
      }
    }
  }
  _validate(e) {
    return this._moveIsAllowed(e);
  }
  _fitSelectedIndexInRange(index2) {
    const itemsCount = this.option("items").length;
    return Math.max(Math.min(index2, itemsCount - 1), 0);
  }
  _isInNullNeighborhood(x) {
    return -0.1 <= x && x <= 0.1;
  }
  _getSelectedIndexAfterScroll(currentSelectedIndex) {
    const locationTop = this.scrollOffset().top;
    const currentSelectedIndexPosition = currentSelectedIndex * this._itemHeight();
    const dy = locationTop - currentSelectedIndexPosition;
    if (this._isInNullNeighborhood(dy)) {
      return currentSelectedIndex;
    }
    const direction = dy > 0 ? 1 : -1;
    const newSelectedIndex = this._fitSelectedIndexInRange(currentSelectedIndex + direction);
    return newSelectedIndex;
  }
  _getNewSelectedIndex(currentSelectedIndex) {
    if (this._shouldScrollToNeighborItem()) {
      return this._getSelectedIndexAfterScroll(currentSelectedIndex);
    }
    this._animation = true;
    const ratio = this.scrollOffset().top / this._itemHeight();
    return Math.round(ratio);
  }
  _endActionHandler() {
    const currentSelectedIndex = this.option("selectedIndex");
    const newSelectedIndex = this._getNewSelectedIndex(currentSelectedIndex);
    if (newSelectedIndex === currentSelectedIndex) {
      this._renderSelectedValue(newSelectedIndex);
    } else {
      this.option("selectedIndex", newSelectedIndex);
    }
    this._isWheelScrolled = false;
  }
  _itemHeight() {
    const $item = this._$items.first();
    return getHeight($item);
  }
  _toggleActive(state) {
    this.$element().toggleClass("dx-state-active", state);
  }
  _isVisible() {
    return renderer_default(this.container()).is(":visible");
  }
  _fireSelectedIndexChanged(value2, previousValue) {
    this._selectedIndexChanged({
      value: value2,
      previousValue,
      event: void 0
    });
  }
  _visibilityChanged(visible2) {
    super._visibilityChanged(visible2);
    this._visibilityChangedHandler(visible2);
  }
  _visibilityChangedHandler(visible2) {
    if (visible2) {
      this._visibilityTimer = setTimeout(() => {
        this._renderSelectedValue(this.option("selectedIndex"));
      });
    }
    this.toggleActiveState(false);
  }
  toggleActiveState(state) {
    this.$element().toggleClass("dx-dateviewroller-current", state);
  }
  _refreshSelectedIndex() {
    const selectedIndex = this.option("selectedIndex");
    const fitIndex = this._fitIndex(selectedIndex);
    if (fitIndex === selectedIndex) {
      this._renderActiveStateItem();
    } else {
      this.option("selectedIndex", fitIndex);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "selectedIndex":
        this._fireSelectedIndexChanged(args.value, args.previousValue);
        this._renderSelectedValue(args.value);
        break;
      case "items":
        this._renderItems();
        this._refreshSelectedIndex();
        break;
      case "onClick":
      case "showOnClick":
        this._renderContainerClick();
        break;
      case "onSelectedIndexChanged":
        this._renderSelectedIndexChanged();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dispose() {
    clearTimeout(this._visibilityTimer);
    super._dispose();
  }
};
component_registrator_default("dxDateViewRoller", DateViewRoller);
var m_date_view_roller_default = DateViewRoller;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_view.js
var TYPE = {
  date: "date",
  datetime: "datetime",
  time: "time"
};
var ROLLER_TYPE = {
  year: "year",
  month: "month",
  day: "day",
  hours: "hours"
};
var DateView = editor_default.inherit({
  _valueOption() {
    const value2 = this.option("value");
    const date = new Date(value2);
    return !value2 || isNaN(date) ? this._getDefaultDate() : date;
  },
  _getDefaultDate() {
    const date = /* @__PURE__ */ new Date();
    if (this.option("type") === TYPE.date) {
      return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }
    return date;
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      minDate: m_date_utils_default.MIN_DATEVIEW_DEFAULT_DATE,
      maxDate: m_date_utils_default.MAX_DATEVIEW_DEFAULT_DATE,
      type: TYPE.date,
      value: /* @__PURE__ */ new Date(),
      applyCompactClass: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: (device) => "desktop" !== device.deviceType,
      options: {
        applyCompactClass: true
      }
    }]);
  },
  _render() {
    this.callBase();
    this.$element().addClass("dx-dateview");
    this._toggleFormatClasses(this.option("type"));
    this._toggleCompactClass();
  },
  _toggleFormatClasses(currentFormat, previousFormat) {
    this.$element().addClass(`dx-dateview-${currentFormat}`);
    previousFormat && this.$element().removeClass(`dx-dateview-${previousFormat}`);
  },
  _toggleCompactClass() {
    this.$element().toggleClass("dx-dateview-compact", this.option("applyCompactClass"));
  },
  _wrapper() {
    return this._$wrapper;
  },
  _renderContentImpl() {
    this._$wrapper = renderer_default("<div>").addClass("dx-dateview-wrapper");
    this._renderRollers();
    this._$wrapper.appendTo(this.$element());
  },
  _renderRollers() {
    if (!this._$rollersContainer) {
      this._$rollersContainer = renderer_default("<div>").addClass("dx-dateview-rollers");
    }
    this._$rollersContainer.empty();
    this._createRollerConfigs();
    this._rollers = {};
    const that = this;
    each(that._rollerConfigs, (name2) => {
      const $roller = renderer_default("<div>").appendTo(that._$rollersContainer).addClass(`dx-dateviewroller-${that._rollerConfigs[name2].type}`);
      that._rollers[that._rollerConfigs[name2].type] = that._createComponent($roller, m_date_view_roller_default, {
        items: that._rollerConfigs[name2].displayItems,
        selectedIndex: that._rollerConfigs[name2].selectedIndex,
        showScrollbar: "never",
        scrollByContent: true,
        onStart(e) {
          const roller = e.component;
          roller._toggleActive(true);
          that._setActiveRoller(that._rollerConfigs[name2], roller.option("selectedIndex"));
        },
        onEnd(e) {
          const roller = e.component;
          roller._toggleActive(false);
        },
        onClick(e) {
          const roller = e.component;
          roller._toggleActive(true);
          that._setActiveRoller(that._rollerConfigs[name2], roller.option("selectedIndex"));
          that._setRollerState(that._rollerConfigs[name2], roller.option("selectedIndex"));
          roller._toggleActive(false);
        },
        onSelectedIndexChanged(e) {
          const roller = e.component;
          that._setRollerState(that._rollerConfigs[name2], roller.option("selectedIndex"));
        }
      });
    });
    that._$rollersContainer.appendTo(that._wrapper());
  },
  _createRollerConfigs(type2) {
    const that = this;
    type2 = type2 || that.option("type");
    that._rollerConfigs = {};
    date_default2.getFormatParts(m_date_utils_default.FORMATS_MAP[type2]).forEach((partName) => {
      that._createRollerConfig(partName);
    });
  },
  _createRollerConfig(componentName) {
    const componentInfo = m_date_utils_default.DATE_COMPONENTS_INFO[componentName];
    const valueRange = this._calculateRollerConfigValueRange(componentName);
    const {
      startValue
    } = valueRange;
    const {
      endValue
    } = valueRange;
    const {
      formatter
    } = componentInfo;
    const curDate = this._getCurrentDate();
    const config3 = {
      type: componentName,
      setValue: componentInfo.setter,
      valueItems: [],
      displayItems: [],
      getIndex: (value2) => value2[componentInfo.getter]() - startValue
    };
    for (let i = startValue; i <= endValue; i++) {
      config3.valueItems.push(i);
      config3.displayItems.push(formatter(i, curDate));
    }
    config3.selectedIndex = config3.getIndex(curDate);
    this._rollerConfigs[componentName] = config3;
  },
  _setActiveRoller(currentRoller) {
    const activeRoller = currentRoller && this._rollers[currentRoller.type];
    each(this._rollers, function() {
      this.toggleActiveState(this === activeRoller);
    });
  },
  _updateRollersPosition() {
    const that = this;
    each(this._rollers, function(type2) {
      const correctIndex = that._rollerConfigs[type2].getIndex(that._getCurrentDate());
      this.option("selectedIndex", correctIndex);
    });
  },
  _setRollerState(roller, selectedIndex) {
    if (selectedIndex !== roller.selectedIndex) {
      const rollerValue = roller.valueItems[selectedIndex];
      const {
        setValue
      } = roller;
      let currentValue = new Date(this._getCurrentDate());
      let currentDate = currentValue.getDate();
      const minDate = this.option("minDate");
      const maxDate = this.option("maxDate");
      if (roller.type === ROLLER_TYPE.month) {
        currentDate = Math.min(currentDate, m_date_utils_default.getMaxMonthDay(currentValue.getFullYear(), rollerValue));
      } else if (roller.type === ROLLER_TYPE.year) {
        currentDate = Math.min(currentDate, m_date_utils_default.getMaxMonthDay(rollerValue, currentValue.getMonth()));
      }
      currentValue.setDate(currentDate);
      currentValue[setValue](rollerValue);
      const normalizedDate = date_default3.normalizeDate(currentValue, minDate, maxDate);
      currentValue = m_date_utils_default.mergeDates(normalizedDate, currentValue, "time");
      currentValue = date_default3.normalizeDate(currentValue, minDate, maxDate);
      this.option("value", currentValue);
      roller.selectedIndex = selectedIndex;
    }
    if (roller.type === ROLLER_TYPE.year) {
      this._refreshRollers();
    }
    if (roller.type === ROLLER_TYPE.month) {
      this._refreshRoller(ROLLER_TYPE.day);
      this._refreshRoller(ROLLER_TYPE.hours);
    }
  },
  _refreshRoller(rollerType) {
    const roller = this._rollers[rollerType];
    if (roller) {
      this._createRollerConfig(rollerType);
      const rollerConfig = this._rollerConfigs[rollerType];
      if (rollerType === ROLLER_TYPE.day || rollerConfig.displayItems.toString() !== roller.option("items").toString()) {
        roller.option({
          items: rollerConfig.displayItems,
          selectedIndex: rollerConfig.selectedIndex
        });
      }
    }
  },
  _getCurrentDate() {
    const curDate = this._valueOption();
    const minDate = this.option("minDate");
    const maxDate = this.option("maxDate");
    return date_default3.normalizeDate(curDate, minDate, maxDate);
  },
  _calculateRollerConfigValueRange(componentName) {
    const curDate = this._getCurrentDate();
    const minDate = this.option("minDate");
    const maxDate = this.option("maxDate");
    const minYear = date_default3.sameYear(curDate, minDate);
    const minMonth = minYear && curDate.getMonth() === minDate.getMonth();
    const maxYear = date_default3.sameYear(curDate, maxDate);
    const maxMonth = maxYear && curDate.getMonth() === maxDate.getMonth();
    const minHour = minMonth && curDate.getDate() === minDate.getDate();
    const maxHour = maxMonth && curDate.getDate() === maxDate.getDate();
    const componentInfo = m_date_utils_default.DATE_COMPONENTS_INFO[componentName];
    let {
      startValue
    } = componentInfo;
    let {
      endValue
    } = componentInfo;
    if (componentName === ROLLER_TYPE.year) {
      startValue = minDate.getFullYear();
      endValue = maxDate.getFullYear();
    }
    if (componentName === ROLLER_TYPE.month) {
      if (minYear) {
        startValue = minDate.getMonth();
      }
      if (maxYear) {
        endValue = maxDate.getMonth();
      }
    }
    if (componentName === ROLLER_TYPE.day) {
      endValue = m_date_utils_default.getMaxMonthDay(curDate.getFullYear(), curDate.getMonth());
      if (minYear && minMonth) {
        startValue = minDate.getDate();
      }
      if (maxYear && maxMonth) {
        endValue = maxDate.getDate();
      }
    }
    if (componentName === ROLLER_TYPE.hours) {
      startValue = minHour ? minDate.getHours() : startValue;
      endValue = maxHour ? maxDate.getHours() : endValue;
    }
    return {
      startValue,
      endValue
    };
  },
  _refreshRollers() {
    this._refreshRoller(ROLLER_TYPE.month);
    this._refreshRoller(ROLLER_TYPE.day);
    this._refreshRoller(ROLLER_TYPE.hours);
  },
  _optionChanged(args) {
    switch (args.name) {
      case "minDate":
      case "maxDate":
      case "type":
        this._renderRollers();
        this._toggleFormatClasses(args.value, args.previousValue);
        break;
      case "visible":
        this.callBase(args);
        if (args.value) {
          this._renderRollers();
        }
        break;
      case "value":
        this.option("value", this._valueOption());
        this._refreshRollers();
        this._updateRollersPosition();
        break;
      default:
        this.callBase(args);
    }
  },
  _clean() {
    this.callBase();
    delete this._$rollersContainer;
  }
});
component_registrator_default("dxDateView", DateView);
var m_date_view_default = DateView;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.date_view.js
var window23 = getWindow();
var DateViewStrategy = m_date_box_strategy_default.inherit({
  NAME: "DateView",
  getDefaultOptions() {
    return extend(this.callBase(), {
      openOnFieldClick: true,
      applyButtonText: message_default.format("OK"),
      "dropDownOptions.showTitle": true
    });
  },
  getDisplayFormat(displayFormat) {
    return displayFormat || m_date_utils_default.FORMATS_MAP[this.dateBox.option("type")];
  },
  popupConfig(config3) {
    return {
      toolbarItems: this.dateBox._popupToolbarItemsConfig(),
      onInitialized: config3.onInitialized,
      defaultOptionsRules: [{
        device: {
          platform: "android"
        },
        options: {
          width: 333,
          height: 331
        }
      }, {
        device(device) {
          const {
            platform
          } = device;
          return "generic" === platform || "ios" === platform;
        },
        options: {
          width: "auto",
          height: "auto"
        }
      }, {
        device(device) {
          const {
            platform
          } = device;
          const {
            phone
          } = device;
          return "generic" === platform && phone;
        },
        options: {
          width: 333,
          maxWidth: "100%",
          maxHeight: "100%",
          height: "auto",
          position: {
            collision: "flipfit flip"
          }
        }
      }, {
        device: {
          platform: "ios",
          phone: true
        },
        options: {
          width: "100%",
          position: {
            my: "bottom",
            at: "bottom",
            of: window23
          }
        }
      }]
    };
  },
  _renderWidget() {
    if (inputType(this.dateBox.option("mode")) && this.dateBox._isNativeType() || this.dateBox.option("readOnly")) {
      if (this._widget) {
        this._widget.$element().remove();
        this._widget = null;
      }
      return;
    }
    const popup = this._getPopup();
    if (this._widget) {
      this._widget.option(this._getWidgetOptions());
    } else {
      const element = renderer_default("<div>").appendTo(popup.$content());
      this._widget = this._createWidget(element);
    }
    this._widget.$element().appendTo(this._getWidgetContainer());
  },
  _getWidgetName: () => m_date_view_default,
  renderOpenedState() {
    this.callBase();
    if (this._widget) {
      this._widget.option("value", this._widget._getCurrentDate());
    }
  },
  _getWidgetOptions() {
    return {
      value: this.dateBoxValue() || /* @__PURE__ */ new Date(),
      type: this.dateBox.option("type"),
      minDate: this.dateBox.dateOption("min") || new Date(1900, 0, 1),
      maxDate: this.dateBox.dateOption("max") || new Date(Date.now() + 50 * m_date_utils_default.ONE_YEAR),
      onDisposing: (function() {
        this._widget = null;
      }).bind(this)
    };
  }
});
var m_date_box_strategy_date_view_default = DateViewStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.list.js
var window24 = getWindow();
var BOUNDARY_VALUES = {
  min: new Date(0, 0, 0, 0, 0),
  max: new Date(0, 0, 0, 23, 59)
};
var ListStrategy = m_date_box_strategy_default.inherit({
  NAME: "List",
  supportedKeys: () => ({
    space: noop2,
    home: noop2,
    end: noop2
  }),
  getDefaultOptions() {
    return extend(this.callBase(), {
      applyValueMode: "instantly"
    });
  },
  getDisplayFormat: (displayFormat) => displayFormat || "shorttime",
  popupConfig: (popupConfig) => popupConfig,
  getValue() {
    const selectedIndex = this._widget.option("selectedIndex");
    if (-1 === selectedIndex) {
      return this.dateBox.option("value");
    }
    const itemData = this._widgetItems[selectedIndex];
    return this._getDateByItemData(itemData);
  },
  useCurrentDateByDefault: () => true,
  getDefaultDate: () => /* @__PURE__ */ new Date(null),
  popupShowingHandler() {
    this.dateBox._dimensionChanged();
  },
  _renderWidget() {
    this.callBase();
    this._refreshItems();
  },
  _getWidgetName: () => list_light_default,
  _getWidgetOptions() {
    return {
      itemTemplate: this._timeListItemTemplate.bind(this),
      onItemClick: this._listItemClickHandler.bind(this),
      tabIndex: -1,
      onFocusedItemChanged: this._refreshActiveDescendant.bind(this),
      selectionMode: "single"
    };
  },
  _refreshActiveDescendant(e) {
    this.dateBox.setAria("activedescendant", "");
    this.dateBox.setAria("activedescendant", e.actionValue);
  },
  _refreshItems() {
    this._widgetItems = this._getTimeListItems();
    this._widget.option("items", this._widgetItems);
  },
  renderOpenedState() {
    if (!this._widget) {
      return;
    }
    this._widget.option("focusedElement", null);
    this._setSelectedItemsByValue();
    if (this._widget.option("templatesRenderAsynchronously")) {
      this._asyncScrollTimeout = setTimeout(this._scrollToSelectedItem.bind(this));
    } else {
      this._scrollToSelectedItem();
    }
  },
  dispose() {
    this.callBase();
    clearTimeout(this._asyncScrollTimeout);
  },
  _updateValue() {
    if (!this._widget) {
      return;
    }
    this._refreshItems();
    this._setSelectedItemsByValue();
    this._scrollToSelectedItem();
  },
  _setSelectedItemsByValue() {
    const value2 = this.dateBoxValue();
    const dateIndex = this._getDateIndex(value2);
    if (-1 === dateIndex) {
      this._widget.option("selectedItems", []);
    } else {
      this._widget.option("selectedIndex", dateIndex);
    }
  },
  _scrollToSelectedItem() {
    this._widget.scrollToItem(this._widget.option("selectedIndex"));
  },
  _getDateIndex(date) {
    let result2 = -1;
    for (let i = 0, n = this._widgetItems.length; i < n; i++) {
      if (this._areDatesEqual(date, this._widgetItems[i])) {
        result2 = i;
        break;
      }
    }
    return result2;
  },
  _areDatesEqual: (first, second) => isDate(first) && isDate(second) && first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes(),
  _getTimeListItems() {
    let min = this.dateBox.dateOption("min") || this._getBoundaryDate("min");
    const max = this.dateBox.dateOption("max") || this._getBoundaryDate("max");
    const value2 = this.dateBox.dateOption("value") || null;
    let delta = max - min;
    const minutes = min.getMinutes() % this.dateBox.option("interval");
    if (delta < 0) {
      return [];
    }
    if (delta > m_date_utils_default.ONE_DAY) {
      delta = m_date_utils_default.ONE_DAY;
    }
    if (value2 - min < m_date_utils_default.ONE_DAY) {
      return this._getRangeItems(min, new Date(min), delta);
    }
    min = this._getBoundaryDate("min");
    min.setMinutes(minutes);
    if (value2 && Math.abs(value2 - max) < m_date_utils_default.ONE_DAY) {
      delta = (60 * max.getHours() + Math.abs(max.getMinutes() - minutes)) * m_date_utils_default.ONE_MINUTE;
    }
    return this._getRangeItems(min, new Date(min), delta);
  },
  _getRangeItems(startValue, currentValue, rangeDuration) {
    const rangeItems = [];
    const interval = this.dateBox.option("interval");
    while (currentValue - startValue <= rangeDuration) {
      rangeItems.push(new Date(currentValue));
      currentValue.setMinutes(currentValue.getMinutes() + interval);
    }
    return rangeItems;
  },
  _getBoundaryDate(boundary) {
    const boundaryValue = BOUNDARY_VALUES[boundary];
    const currentValue = new Date(ensureDefined(this.dateBox.dateOption("value"), 0));
    return new Date(currentValue.getFullYear(), currentValue.getMonth(), currentValue.getDate(), boundaryValue.getHours(), boundaryValue.getMinutes());
  },
  _timeListItemTemplate(itemData) {
    const displayFormat = this.dateBox.option("displayFormat");
    return date_default2.format(itemData, this.getDisplayFormat(displayFormat));
  },
  _listItemClickHandler(e) {
    if ("useButtons" === this.dateBox.option("applyValueMode")) {
      return;
    }
    const date = this._getDateByItemData(e.itemData);
    this.dateBox.option("opened", false);
    this.dateBoxValue(date, e.event);
  },
  _getDateByItemData(itemData) {
    let date = this.dateBox.option("value");
    const hours = itemData.getHours();
    const minutes = itemData.getMinutes();
    const seconds = itemData.getSeconds();
    const year = itemData.getFullYear();
    const month = itemData.getMonth();
    const day = itemData.getDate();
    if (date) {
      if (this.dateBox.option("dateSerializationFormat")) {
        date = date_serialization_default.deserializeDate(date);
      } else {
        date = new Date(date);
      }
      date.setHours(hours);
      date.setMinutes(minutes);
      date.setSeconds(seconds);
      date.setFullYear(year);
      date.setMonth(month);
      date.setDate(day);
    } else {
      date = new Date(year, month, day, hours, minutes, 0, 0);
    }
    return date;
  },
  getKeyboardListener() {
    return this._widget;
  },
  _updatePopupHeight() {
    const dropDownOptionsHeight = getSizeValue(this.dateBox.option("dropDownOptions.height"));
    if (void 0 === dropDownOptionsHeight || "auto" === dropDownOptionsHeight) {
      this.dateBox._setPopupOption("height", "auto");
      const popupHeight = getOuterHeight(this._widget.$element());
      const maxHeight = 0.45 * getHeight(window24);
      this.dateBox._setPopupOption("height", Math.min(popupHeight, maxHeight));
    }
    this.dateBox._timeList && this.dateBox._timeList.updateDimensions();
  },
  getParsedText(text, format2) {
    let value2 = this.callBase(text, format2);
    if (value2) {
      value2 = m_date_utils_default.mergeDates(value2, /* @__PURE__ */ new Date(null), "date");
    }
    return value2;
  }
});
var m_date_box_strategy_list_default = ListStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.native.js
var NativeStrategy2 = m_date_box_strategy_default.inherit({
  NAME: "Native",
  popupConfig: (popupConfig) => extend({}, popupConfig, {
    width: "auto"
  }),
  getParsedText(text) {
    if (!text) {
      return null;
    }
    if ("datetime" === this.dateBox.option("type")) {
      return new Date(text.replace(/-/g, "/").replace("T", " ").split(".")[0]);
    }
    return m_date_utils_default.fromStandardDateFormat(text);
  },
  renderPopupContent: noop2,
  _getWidgetName: noop2,
  _getWidgetOptions: noop2,
  _getDateBoxType() {
    let type2 = this.dateBox.option("type");
    if (!m_date_utils_default.SUPPORTED_FORMATS.includes(type2)) {
      type2 = "date";
    } else if ("datetime" === type2 && !inputType(type2)) {
      type2 = "datetime-local";
    }
    return type2;
  },
  customizeButtons() {
    const dropDownButton = this.dateBox.getButton("dropDown");
    if (devices_default.real().android && dropDownButton) {
      dropDownButton.on("click", () => {
        this.dateBox._input().get(0).click();
      });
    }
  },
  getDefaultOptions() {
    return {
      mode: this._getDateBoxType()
    };
  },
  getDisplayFormat(displayFormat) {
    const type2 = this._getDateBoxType();
    return displayFormat || m_date_utils_default.FORMATS_MAP[type2];
  },
  renderInputMinMax($input) {
    $input.attr({
      min: date_serialization_default.serializeDate(this.dateBox.dateOption("min"), "yyyy-MM-dd"),
      max: date_serialization_default.serializeDate(this.dateBox.dateOption("max"), "yyyy-MM-dd")
    });
  }
});
var m_date_box_strategy_native_default = NativeStrategy2;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.base.js
var window25 = getWindow();
var DX_INVALID_BADGE_CLASS2 = "dx-show-invalid-badge";
var DX_CLEAR_BUTTON_CLASS = "dx-clear-button-area";
var PICKER_TYPE = {
  calendar: "calendar",
  rollers: "rollers",
  list: "list",
  native: "native"
};
var TYPE2 = {
  date: "date",
  datetime: "datetime",
  time: "time"
};
var STRATEGY_NAME = {
  calendar: "Calendar",
  dateView: "DateView",
  native: "Native",
  calendarWithTime: "CalendarWithTime",
  list: "List"
};
var STRATEGY_CLASSES = {
  Calendar: m_date_box_strategy_calendar_default,
  DateView: m_date_box_strategy_date_view_default,
  Native: m_date_box_strategy_native_default,
  CalendarWithTime: m_date_box_strategy_calendar_with_time_default,
  List: m_date_box_strategy_list_default
};
var DateBox = m_drop_down_editor_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), this._strategy.supportedKeys());
  },
  _renderButtonContainers() {
    this.callBase.apply(this, arguments);
    this._strategy.customizeButtons();
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      type: "date",
      showAnalogClock: true,
      value: null,
      dateSerializationFormat: void 0,
      min: void 0,
      max: void 0,
      displayFormat: null,
      interval: 30,
      disabledDates: null,
      pickerType: PICKER_TYPE.calendar,
      invalidDateMessage: message_default.format("dxDateBox-validation-datetime"),
      dateOutOfRangeMessage: message_default.format("validation-range"),
      applyButtonText: message_default.format("OK"),
      adaptivityEnabled: false,
      calendarOptions: {},
      useHiddenSubmitElement: true,
      _showValidationIcon: true
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: {
        platform: "ios"
      },
      options: {
        "dropDownOptions.showTitle": true
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        buttonsLocation: "bottom after"
      }
    }, {
      device() {
        const realDevice2 = devices_default.real();
        const {
          platform
        } = realDevice2;
        return "ios" === platform || "android" === platform;
      },
      options: {
        pickerType: PICKER_TYPE.native
      }
    }, {
      device: {
        platform: "generic",
        deviceType: "desktop"
      },
      options: {
        buttonsLocation: "bottom after"
      }
    }]);
  },
  _initOptions(options2) {
    this._userOptions = extend({}, options2);
    this.callBase(options2);
    this._updatePickerOptions();
  },
  _updatePickerOptions() {
    let pickerType = this.option("pickerType");
    const type2 = this.option("type");
    if (pickerType === PICKER_TYPE.list && (type2 === TYPE2.datetime || type2 === TYPE2.date)) {
      pickerType = PICKER_TYPE.calendar;
    }
    if (type2 === TYPE2.time && pickerType === PICKER_TYPE.calendar) {
      pickerType = PICKER_TYPE.list;
    }
    this._pickerType = pickerType;
    this._setShowDropDownButtonOption();
  },
  _setShowDropDownButtonOption() {
    const {
      platform
    } = devices_default.real();
    const isMozillaOnAndroid = "android" === platform && browser_default.mozilla;
    const isNativePickerType = this._isNativeType();
    let showDropDownButton = "generic" !== platform || !isNativePickerType;
    if (isNativePickerType && isMozillaOnAndroid) {
      showDropDownButton = false;
    }
    this.option({
      showDropDownButton
    });
  },
  _init() {
    this._initStrategy();
    this.option(extend({}, this._strategy.getDefaultOptions(), this._userOptions));
    delete this._userOptions;
    this.callBase();
  },
  _toLowerCaseFirstLetter: (string) => string.charAt(0).toLowerCase() + string.substr(1),
  _initStrategy() {
    const strategyName = this._getStrategyName(this._getFormatType());
    const strategy4 = STRATEGY_CLASSES[strategyName];
    if (!(this._strategy && this._strategy.NAME === strategyName)) {
      this._strategy = new strategy4(this);
    }
  },
  _getFormatType() {
    const currentType = this.option("type");
    const isTime = /h|m|s/g.test(currentType);
    const isDate2 = /d|M|Y/g.test(currentType);
    let type2 = "";
    if (isDate2) {
      type2 += TYPE2.date;
    }
    if (isTime) {
      type2 += TYPE2.time;
    }
    return type2;
  },
  _getStrategyName(type2) {
    const pickerType = this._pickerType;
    if (pickerType === PICKER_TYPE.rollers) {
      return STRATEGY_NAME.dateView;
    }
    if (pickerType === PICKER_TYPE.native) {
      return STRATEGY_NAME.native;
    }
    if (type2 === TYPE2.date) {
      return STRATEGY_NAME.calendar;
    }
    if (type2 === TYPE2.datetime) {
      return STRATEGY_NAME.calendarWithTime;
    }
    return STRATEGY_NAME.list;
  },
  _initMarkup() {
    this.$element().addClass("dx-datebox");
    this.callBase();
    this._refreshFormatClass();
    this._refreshPickerTypeClass();
    this._strategy.renderInputMinMax(this._input());
  },
  _render() {
    this.callBase();
    this._formatValidationIcon();
  },
  _renderDimensions() {
    this.callBase();
    this.$element().toggleClass("dx-auto-width", !this.option("width"));
    this._updatePopupWidth();
    this._updatePopupHeight();
  },
  _dimensionChanged() {
    this.callBase();
    this._updatePopupHeight();
  },
  _updatePopupHeight() {
    if (this._popup) {
      var _this$_strategy$_upda, _this$_strategy;
      null === (_this$_strategy$_upda = (_this$_strategy = this._strategy)._updatePopupHeight) || void 0 === _this$_strategy$_upda || _this$_strategy$_upda.call(_this$_strategy);
    }
  },
  _refreshFormatClass() {
    const $element = this.$element();
    each(TYPE2, (_, item) => {
      $element.removeClass(`dx-datebox-${item}`);
    });
    $element.addClass(`dx-datebox-${this.option("type")}`);
  },
  _refreshPickerTypeClass() {
    const $element = this.$element();
    each(PICKER_TYPE, (_, item) => {
      $element.removeClass(`dx-datebox-${item}`);
    });
    $element.addClass(`dx-datebox-${this._pickerType}`);
  },
  _formatValidationIcon() {
    if (!hasWindow()) {
      return;
    }
    const inputElement = this._input().get(0);
    const isRtlEnabled = this.option("rtlEnabled");
    const clearButtonWidth = this._getClearButtonWidth();
    const longestElementDimensions = this._getLongestElementDimensions();
    const curWidth = parseFloat(window25.getComputedStyle(inputElement).width) - clearButtonWidth;
    const shouldHideValidationIcon = longestElementDimensions.width > curWidth;
    const {
      style
    } = inputElement;
    this.$element().toggleClass(DX_INVALID_BADGE_CLASS2, !shouldHideValidationIcon && this.option("_showValidationIcon"));
    if (shouldHideValidationIcon) {
      if (void 0 === this._storedPadding) {
        this._storedPadding = isRtlEnabled ? longestElementDimensions.leftPadding : longestElementDimensions.rightPadding;
      }
      isRtlEnabled ? style.paddingLeft = 0 : style.paddingRight = 0;
    } else {
      isRtlEnabled ? style.paddingLeft = `${this._storedPadding}px` : style.paddingRight = `${this._storedPadding}px`;
    }
  },
  _getClearButtonWidth() {
    let clearButtonWidth = 0;
    if (this._isClearButtonVisible() && "" === this._input().val()) {
      const clearButtonElement = this.$element().find(`.${DX_CLEAR_BUTTON_CLASS}`).get(0);
      clearButtonWidth = parseFloat(window25.getComputedStyle(clearButtonElement).width);
    }
    return clearButtonWidth;
  },
  _getLongestElementDimensions() {
    const format2 = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const longestValue = date_default2.format(m_date_utils_default.getLongestDate(format2, date_default2.getMonthNames(), date_default2.getDayNames()), format2);
    const $input = this._input();
    const inputElement = $input.get(0);
    const $longestValueElement = createTextElementHiddenCopy($input, longestValue);
    const isPaddingStored = void 0 !== this._storedPadding;
    const storedPadding = !isPaddingStored ? 0 : this._storedPadding;
    $longestValueElement.appendTo(this.$element());
    const elementWidth = parseFloat(window25.getComputedStyle($longestValueElement.get(0)).width);
    const rightPadding = parseFloat(window25.getComputedStyle(inputElement).paddingRight);
    const leftPadding = parseFloat(window25.getComputedStyle(inputElement).paddingLeft);
    const necessaryWidth = elementWidth + leftPadding + rightPadding + storedPadding;
    $longestValueElement.remove();
    return {
      width: necessaryWidth,
      leftPadding,
      rightPadding
    };
  },
  _getKeyboardListeners() {
    return this.callBase().concat([this._strategy && this._strategy.getKeyboardListener()]);
  },
  _renderPopup() {
    this.callBase();
    this._popup.$wrapper().addClass("dx-datebox-wrapper");
    this._renderPopupWrapper();
  },
  _getPopupToolbarItems() {
    var _this$_strategy$_getP, _this$_strategy2;
    const defaultItems = this.callBase();
    return (null === (_this$_strategy$_getP = (_this$_strategy2 = this._strategy)._getPopupToolbarItems) || void 0 === _this$_strategy$_getP ? void 0 : _this$_strategy$_getP.call(_this$_strategy2, defaultItems)) ?? defaultItems;
  },
  _popupConfig() {
    const popupConfig = this.callBase();
    return extend(this._strategy.popupConfig(popupConfig), {
      title: this._getPopupTitle(),
      dragEnabled: false
    });
  },
  _renderPopupWrapper() {
    if (!this._popup) {
      return;
    }
    const $element = this.$element();
    const classPostfixes = extend({}, TYPE2, PICKER_TYPE);
    each(classPostfixes, (_, item) => {
      $element.removeClass(`dx-datebox-wrapper-${item}`);
    });
    this._popup.$wrapper().addClass(`dx-datebox-wrapper-${this.option("type")}`).addClass(`dx-datebox-wrapper-${this._pickerType}`).addClass("dx-dropdowneditor-overlay");
  },
  _renderPopupContent() {
    this.callBase();
    this._strategy.renderPopupContent();
  },
  _popupShowingHandler() {
    this.callBase();
    this._strategy.popupShowingHandler();
  },
  _popupShownHandler() {
    this.callBase();
    this._strategy.renderOpenedState();
  },
  _popupHiddenHandler() {
    this.callBase();
    this._strategy.renderOpenedState();
    this._strategy.popupHiddenHandler();
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._formatValidationIcon();
    }
  },
  _clearValueHandler(e) {
    this.option("text", "");
    this.callBase(e);
  },
  _readOnlyPropValue() {
    if (this._pickerType === PICKER_TYPE.rollers) {
      return true;
    }
    const {
      platform
    } = devices_default.real();
    const isCustomValueDisabled = this._isNativeType() && ("ios" === platform || "android" === platform);
    if (isCustomValueDisabled) {
      return this.option("readOnly");
    }
    return this.callBase();
  },
  _isClearButtonVisible() {
    return this.callBase() && !this._isNativeType();
  },
  _renderValue() {
    const value2 = this.dateOption("value");
    this.option("text", this._getDisplayedText(value2));
    this._strategy.renderValue();
    return this.callBase();
  },
  _setSubmitValue() {
    const value2 = this.dateOption("value");
    const dateSerializationFormat = this.option("dateSerializationFormat");
    const submitFormat = m_date_utils_default.SUBMIT_FORMATS_MAP[this.option("type")];
    const submitValue = dateSerializationFormat ? date_serialization_default.serializeDate(value2, dateSerializationFormat) : m_date_utils_default.toStandardDateFormat(value2, submitFormat);
    this._getSubmitElement().val(submitValue);
  },
  _getDisplayedText(value2) {
    const mode = this.option("mode");
    let displayedText;
    if ("text" === mode) {
      const displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
      displayedText = date_default2.format(value2, displayFormat);
    } else {
      const format2 = this._getFormatByMode(mode);
      if (format2) {
        displayedText = date_default2.format(value2, format2);
      } else {
        displayedText = m_date_utils_default.toStandardDateFormat(value2, mode);
      }
    }
    return displayedText;
  },
  _getFormatByMode: (mode) => inputType(mode) ? null : m_date_utils_default.FORMATS_MAP[mode],
  _valueChangeEventHandler(e) {
    const {
      text,
      type: type2,
      validationError
    } = this.option();
    const currentValue = this.dateOption("value");
    if (text === this._getDisplayedText(currentValue)) {
      this._recallInternalValidation(currentValue, validationError);
      return;
    }
    const parsedDate = this._getParsedDate(text);
    const value2 = currentValue ?? this._getDateByDefault();
    const newValue = m_date_utils_default.mergeDates(value2, parsedDate, type2);
    const date = parsedDate && "time" === type2 ? newValue : parsedDate;
    if (this._applyInternalValidation(date).isValid) {
      const displayedText = this._getDisplayedText(newValue);
      if (value2 && newValue && value2.getTime() === newValue.getTime() && displayedText !== text) {
        this._renderValue();
      } else {
        this.dateValue(newValue, e);
      }
    }
  },
  _recallInternalValidation(value2, validationError) {
    if (!validationError || validationError.editorSpecific) {
      this._applyInternalValidation(value2);
      this._applyCustomValidation(value2);
    }
  },
  _getDateByDefault() {
    return this._strategy.useCurrentDateByDefault() && this._strategy.getDefaultDate();
  },
  _getParsedDate(text) {
    const displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const parsedText = this._strategy.getParsedText(text, displayFormat);
    return parsedText ?? void 0;
  },
  _applyInternalValidation(value2) {
    const text = this.option("text");
    const hasText = !!text && null !== value2;
    const isDate2 = !!value2 && isDate(value2) && !isNaN(value2.getTime());
    const isDateInRange = isDate2 && date_default3.dateInRange(value2, this.dateOption("min"), this.dateOption("max"), this.option("type"));
    const isValid = !hasText && !value2 || isDateInRange;
    let validationMessage = "";
    if (!isDate2) {
      validationMessage = this.option("invalidDateMessage");
    } else if (!isDateInRange) {
      validationMessage = this.option("dateOutOfRangeMessage");
    }
    this._updateInternalValidationState(isValid, validationMessage);
    return {
      isValid,
      isDate: isDate2
    };
  },
  _updateInternalValidationState(isValid, validationMessage) {
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: validationMessage
      }
    });
  },
  _applyCustomValidation(value2) {
    this.validationRequest.fire({
      editor: this,
      value: this._serializeDate(value2)
    });
  },
  _isValueChanged(newValue) {
    const oldValue = this.dateOption("value");
    const oldTime = oldValue && oldValue.getTime();
    const newTime = newValue && newValue.getTime();
    return oldTime !== newTime;
  },
  _isTextChanged(newValue) {
    const oldText = this.option("text");
    const newText = newValue && this._getDisplayedText(newValue) || "";
    return oldText !== newText;
  },
  _renderProps() {
    this.callBase();
    this._input().attr("autocomplete", "off");
  },
  _renderOpenedState() {
    if (!this._isNativeType()) {
      this.callBase();
    }
    if (this._strategy.isAdaptivityChanged()) {
      this._refreshStrategy();
    }
  },
  _getPopupTitle() {
    const placeholder = this.option("placeholder");
    if (placeholder) {
      return placeholder;
    }
    const type2 = this.option("type");
    if (type2 === TYPE2.time) {
      return message_default.format("dxDateBox-simulatedDataPickerTitleTime");
    }
    if (type2 === TYPE2.date || type2 === TYPE2.datetime) {
      return message_default.format("dxDateBox-simulatedDataPickerTitleDate");
    }
    return "";
  },
  _refreshStrategy() {
    this._strategy.dispose();
    this._initStrategy();
    this.option(this._strategy.getDefaultOptions());
    this._refresh();
  },
  _applyButtonHandler(e) {
    const value2 = this._strategy.getValue();
    this.dateValue(value2, e.event);
    this.callBase();
  },
  _dispose() {
    var _this$_strategy3;
    this.callBase();
    null === (_this$_strategy3 = this._strategy) || void 0 === _this$_strategy3 || _this$_strategy3.dispose();
  },
  _isNativeType() {
    return this._pickerType === PICKER_TYPE.native;
  },
  _updatePopupTitle() {
    var _this$_popup;
    null === (_this$_popup = this._popup) || void 0 === _this$_popup || _this$_popup.option("title", this._getPopupTitle());
  },
  _optionChanged(args) {
    switch (args.name) {
      case "showClearButton":
      case "buttons":
      case "isValid":
      case "readOnly":
        this.callBase.apply(this, arguments);
        this._formatValidationIcon();
        break;
      case "pickerType":
        this._updatePickerOptions({
          pickerType: args.value
        });
        this._refreshStrategy();
        this._refreshPickerTypeClass();
        this._invalidate();
        break;
      case "type":
        this._updatePickerOptions({
          format: args.value
        });
        this._refreshStrategy();
        this._refreshFormatClass();
        this._renderPopupWrapper();
        this._formatValidationIcon();
        this._updateValue();
        break;
      case "placeholder":
        this.callBase.apply(this, arguments);
        this._updatePopupTitle();
        break;
      case "min":
      case "max": {
        const isValid = this.option("isValid");
        this._applyInternalValidation(this.dateOption("value"));
        if (!isValid) {
          this._applyCustomValidation(this.dateOption("value"));
        }
        this._invalidate();
        break;
      }
      case "dateSerializationFormat":
      case "interval":
      case "disabledDates":
      case "calendarOptions":
        this._invalidate();
        break;
      case "displayFormat":
        this.option("text", this._getDisplayedText(this.dateOption("value")));
        this._renderInputValue();
        break;
      case "text":
        this._strategy.textChangedHandler(args.value);
        this.callBase.apply(this, arguments);
        break;
      case "showDropDownButton":
        this._formatValidationIcon();
        this.callBase.apply(this, arguments);
        break;
      case "todayButtonText":
        this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
        break;
      case "invalidDateMessage":
      case "dateOutOfRangeMessage":
      case "adaptivityEnabled":
      case "showAnalogClock":
      case "_showValidationIcon":
        break;
      default:
        this.callBase.apply(this, arguments);
    }
  },
  _getSerializationFormat() {
    const value2 = this.option("value");
    if (this.option("dateSerializationFormat") && config_default().forceIsoDateParsing) {
      return this.option("dateSerializationFormat");
    }
    if (isNumeric(value2)) {
      return "number";
    }
    if (!isString(value2)) {
      return;
    }
    return date_serialization_default.getDateSerializationFormat(value2);
  },
  _updateValue(value2) {
    this.callBase();
    this._applyInternalValidation(value2 ?? this.dateOption("value"));
  },
  dateValue(value2, dxEvent) {
    const isValueChanged = this._isValueChanged(value2);
    if (isValueChanged && dxEvent) {
      this._saveValueChangeEvent(dxEvent);
    }
    if (!isValueChanged) {
      if (this._isTextChanged(value2)) {
        this._updateValue(value2);
      } else if ("" === this.option("text")) {
        this._applyCustomValidation(value2);
      }
    }
    return this.dateOption("value", value2);
  },
  dateOption(optionName, value2) {
    if (1 === arguments.length) {
      return date_serialization_default.deserializeDate(this.option(optionName));
    }
    this.option(optionName, this._serializeDate(value2));
  },
  _serializeDate(date) {
    const serializationFormat = this._getSerializationFormat();
    return date_serialization_default.serializeDate(date, serializationFormat);
  },
  _clearValue() {
    const value2 = this.option("value");
    this.callBase();
    if (null === value2) {
      this._applyCustomValidation(null);
    }
  },
  clear() {
    const value2 = this.option("value");
    this.callBase();
    if (null === value2) {
      this._applyInternalValidation(null);
    }
  }
});
var m_date_box_base_default = DateBox;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.mask.parts.js
var monthGetter = (date) => date.getMonth() + 1;
var monthSetter = (date, value2) => {
  const day = date.getDate();
  const monthLimits = getLimits("M", date);
  const newValue = fitIntoRange(parseInt(value2), monthLimits.min, monthLimits.max);
  date.setMonth(newValue - 1, 1);
  const {
    min,
    max
  } = getLimits("dM", date);
  const newDay = fitIntoRange(day, min, max);
  date.setDate(newDay);
};
var PATTERN_GETTERS = {
  a: (date) => date.getHours() < 12 ? 0 : 1,
  E: "getDay",
  y: "getFullYear",
  M: monthGetter,
  L: monthGetter,
  d: "getDate",
  H: "getHours",
  h: "getHours",
  m: "getMinutes",
  s: "getSeconds",
  S: "getMilliseconds",
  x: "getTimezoneOffset"
};
var PATTERN_SETTERS2 = extend({}, getPatternSetters(), {
  a: (date, value2) => {
    const hours = date.getHours();
    const current2 = hours >= 12;
    if (current2 === !!parseInt(value2)) {
      return;
    }
    date.setHours((hours + 12) % 24);
  },
  d: (date, value2) => {
    const lastDayInMonth = getLimits("dM", date).max;
    if (value2 > lastDayInMonth) {
      date.setMonth(date.getMonth() + 1);
    }
    date.setDate(value2);
  },
  h: (date, value2) => {
    const isPM = date.getHours() >= 12;
    date.setHours(+value2 % 12 + (isPM ? 12 : 0));
  },
  M: monthSetter,
  L: monthSetter,
  E: (date, value2) => {
    if (value2 < 0) {
      return;
    }
    date.setDate(date.getDate() - date.getDay() + parseInt(value2));
  },
  y: (date, value2) => {
    const currentYear = date.getFullYear();
    const valueLength = String(value2).length;
    const maxLimitLength = String(getLimits("y", date).max).length;
    const newValue = parseInt(String(currentYear).substr(0, maxLimitLength - valueLength) + value2);
    date.setFullYear(newValue);
  },
  x: (date) => date
});
var getPatternGetter = (patternChar) => PATTERN_GETTERS[patternChar] || (() => patternChar);
var renderDateParts = (text, regExpInfo) => {
  const result2 = regExpInfo.regexp.exec(text);
  let start = 0;
  let end = 0;
  const sections = [];
  for (let i = 1; i < result2.length; i++) {
    start = end;
    end = start + result2[i].length;
    const pattern = regExpInfo.patterns[i - 1].replace(/^'|'$/g, "");
    const getter = getPatternGetter(pattern[0]);
    sections.push({
      index: i - 1,
      isStub: pattern === result2[i],
      caret: {
        start,
        end
      },
      pattern,
      text: result2[i],
      limits: function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return getLimits(pattern[0], ...args);
      },
      setter: PATTERN_SETTERS2[pattern[0]] || noop2,
      getter
    });
  }
  return sections;
};
var getLimits = (pattern, date, forcedPattern) => {
  const limits = {
    y: {
      min: 0,
      max: 9999
    },
    M: {
      min: 1,
      max: 12
    },
    L: {
      min: 1,
      max: 12
    },
    d: {
      min: 1,
      max: 31
    },
    dM: {
      min: 1,
      max: new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate()
    },
    E: {
      min: 0,
      max: 6
    },
    H: {
      min: 0,
      max: 23
    },
    h: {
      min: 1,
      max: 12
    },
    m: {
      min: 0,
      max: 59
    },
    s: {
      min: 0,
      max: 59
    },
    S: {
      min: 0,
      max: 999
    },
    a: {
      min: 0,
      max: 1
    },
    x: {
      min: 0,
      max: 0
    }
  };
  return limits[forcedPattern || pattern] || limits.getAmPm;
};
var getDatePartIndexByPosition = (dateParts, position3) => {
  for (let i = 0; i < dateParts.length; i++) {
    const caretInGroup = dateParts[i].caret.end >= position3;
    if (!dateParts[i].isStub && caretInGroup) {
      return i;
    }
  }
  return null;
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.mask.js
var DateBoxMask = m_date_box_base_default.inherit({
  _supportedKeys(e) {
    const originalHandlers = this.callBase(e);
    const callOriginalHandler = (e2) => {
      const originalHandler = originalHandlers[normalizeKeyName(e2)];
      return originalHandler && originalHandler.apply(this, [e2]);
    };
    const applyHandler = (e2, maskHandler) => {
      if (this._shouldUseOriginalHandler(e2)) {
        return callOriginalHandler.apply(this, [e2]);
      }
      return maskHandler.apply(this, [e2]);
    };
    return extend({}, originalHandlers, {
      del: (e2) => applyHandler(e2, (event) => {
        this._revertPart(1);
        this._isAllSelected() || event.preventDefault();
      }),
      backspace: (e2) => applyHandler(e2, (event) => {
        this._revertPart(-1);
        this._isAllSelected() || event.preventDefault();
      }),
      home: (e2) => applyHandler(e2, (event) => {
        this._selectFirstPart();
        event.preventDefault();
      }),
      end: (e2) => applyHandler(e2, (event) => {
        this._selectLastPart();
        event.preventDefault();
      }),
      escape: (e2) => applyHandler(e2, (event) => {
        this._revertChanges(event);
      }),
      enter: (e2) => applyHandler(e2, () => {
        this._enterHandler();
      }),
      leftArrow: (e2) => applyHandler(e2, (event) => {
        this._selectNextPart(-1);
        event.preventDefault();
      }),
      rightArrow: (e2) => applyHandler(e2, (event) => {
        this._selectNextPart(1);
        event.preventDefault();
      }),
      upArrow: (e2) => applyHandler(e2, (event) => {
        this._upDownArrowHandler(1);
        event.preventDefault();
      }),
      downArrow: (e2) => applyHandler(e2, (event) => {
        this._upDownArrowHandler(-1);
        event.preventDefault();
      })
    });
  },
  _shouldUseOriginalHandler(e) {
    const isNotDeletingInCalendar = this.option("opened") && e && !["backspace", "del"].includes(normalizeKeyName(e));
    return !this._useMaskBehavior() || isNotDeletingInCalendar || e && e.altKey;
  },
  _upDownArrowHandler(step) {
    this._setNewDateIfEmpty();
    const originalValue = this._getActivePartValue(this._initialMaskValue);
    const currentValue = this._getActivePartValue();
    const delta = currentValue - originalValue;
    this._loadMaskValue(this._initialMaskValue);
    this._changePartValue(delta + step, true);
  },
  _changePartValue(step, lockOtherParts) {
    const activePartPattern = this._getActivePartProp("pattern");
    const isAmPmPartActive = /^a{1,5}$/.test(activePartPattern);
    if (isAmPmPartActive) {
      this._toggleAmPm();
    } else {
      this._partIncrease(step, lockOtherParts);
    }
  },
  _toggleAmPm() {
    const currentValue = this._getActivePartProp("text");
    const indexOfCurrentValue = default_date_names_default.getPeriodNames().indexOf(currentValue);
    const newValue = 1 ^ indexOfCurrentValue;
    this._setActivePartValue(newValue);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      useMaskBehavior: false,
      emptyDateValue: new Date(2e3, 0, 1, 0, 0, 0)
    });
  },
  _isSingleCharKey(_ref) {
    let {
      originalEvent,
      alt
    } = _ref;
    const key = originalEvent.data || originalEvent.key;
    return "string" === typeof key && 1 === key.length && !alt && !isCommandKeyPressed(originalEvent);
  },
  _isSingleDigitKey(e) {
    var _e$originalEvent;
    const data2 = null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.data;
    return 1 === (null === data2 || void 0 === data2 ? void 0 : data2.length) && parseInt(data2, 10);
  },
  _useBeforeInputEvent: () => devices_default.real().android,
  _keyInputHandler(e, key) {
    const oldInputValue = this._input().val();
    this._processInputKey(key);
    e.preventDefault();
    const isValueChanged = oldInputValue !== this._input().val();
    isValueChanged && events_engine_default.trigger(this._input(), "input");
  },
  _keyboardHandler(e) {
    let {
      key
    } = e.originalEvent;
    const result2 = this.callBase(e);
    if (!this._useMaskBehavior() || this._useBeforeInputEvent()) {
      return result2;
    }
    if (browser_default.chrome && "Process" === e.key && 0 === e.code.indexOf("Digit")) {
      key = e.code.replace("Digit", "");
      this._processInputKey(key);
      this._maskInputHandler = () => {
        this._renderSelectedPart();
      };
    } else if (this._isSingleCharKey(e)) {
      this._keyInputHandler(e.originalEvent, key);
    }
    return result2;
  },
  _maskBeforeInputHandler(e) {
    this._maskInputHandler = null;
    const {
      inputType: inputType2
    } = e.originalEvent;
    if ("insertCompositionText" === inputType2) {
      this._maskInputHandler = () => {
        this._renderSelectedPart();
      };
    }
    const isBackwardDeletion = "deleteContentBackward" === inputType2;
    const isForwardDeletion = "deleteContentForward" === inputType2;
    if (isBackwardDeletion || isForwardDeletion) {
      const direction = isBackwardDeletion ? -1 : 1;
      this._maskInputHandler = () => {
        this._revertPart();
        this._selectNextPart(direction);
      };
    }
    if (!this._useMaskBehavior() || !this._isSingleCharKey(e)) {
      return;
    }
    const key = e.originalEvent.data;
    this._keyInputHandler(e, key);
    return true;
  },
  _keyPressHandler(e) {
    const {
      originalEvent: event
    } = e;
    if ("insertCompositionText" === (null === event || void 0 === event ? void 0 : event.inputType) && this._isSingleDigitKey(e)) {
      this._processInputKey(event.data);
      this._renderDisplayText(this._getDisplayedText(this._maskValue));
      this._selectNextPart();
    }
    this.callBase(e);
    if (this._maskInputHandler) {
      this._maskInputHandler();
      this._maskInputHandler = null;
    }
  },
  _processInputKey(key) {
    if (this._isAllSelected()) {
      this._activePartIndex = 0;
    }
    this._setNewDateIfEmpty();
    if (isNaN(parseInt(key))) {
      this._searchString(key);
    } else {
      this._searchNumber(key);
    }
  },
  _isAllSelected() {
    const caret3 = this._caret();
    return caret3.end - caret3.start === this.option("text").length;
  },
  _getFormatPattern() {
    if (this._formatPattern) {
      return this._formatPattern;
    }
    const format2 = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const isLDMLPattern = isString(format2) && !date_default2._getPatternByFormat(format2);
    if (isLDMLPattern) {
      this._formatPattern = format2;
    } else {
      this._formatPattern = getFormat2((value2) => date_default2.format(value2, format2));
    }
    return this._formatPattern;
  },
  _setNewDateIfEmpty() {
    if (!this._maskValue) {
      const value2 = "time" === this.option("type") ? /* @__PURE__ */ new Date(null) : /* @__PURE__ */ new Date();
      this._maskValue = value2;
      this._initialMaskValue = value2;
      this._renderDateParts();
    }
  },
  _partLimitsReached(max) {
    const maxLimitLength = String(max).length;
    const formatLength = this._getActivePartProp("pattern").length;
    const isShortFormat = 1 === formatLength;
    const maxSearchLength = isShortFormat ? maxLimitLength : Math.min(formatLength, maxLimitLength);
    const isLengthExceeded = this._searchValue.length === maxSearchLength;
    const isValueOverflowed = parseInt(`${this._searchValue}0`) > max;
    return isLengthExceeded || isValueOverflowed;
  },
  _searchNumber(char) {
    const {
      max
    } = this._getActivePartLimits();
    const maxLimitLength = String(max).length;
    this._searchValue = (this._searchValue + char).substr(-maxLimitLength);
    if (isNaN(this._searchValue)) {
      this._searchValue = char;
    }
    this._setActivePartValue(this._searchValue);
    if (this._partLimitsReached(max)) {
      this._selectNextPart(1);
    }
  },
  _searchString(char) {
    if (!isNaN(parseInt(this._getActivePartProp("text")))) {
      return;
    }
    const limits = this._getActivePartProp("limits")(this._maskValue);
    const startString = this._searchValue + char.toLowerCase();
    const endLimit = limits.max - limits.min;
    for (let i = 0; i <= endLimit; i++) {
      this._loadMaskValue(this._initialMaskValue);
      this._changePartValue(i + 1);
      if (0 === this._getActivePartProp("text").toLowerCase().indexOf(startString)) {
        this._searchValue = startString;
        return;
      }
    }
    this._setNewDateIfEmpty();
    if (this._searchValue) {
      this._clearSearchValue();
      this._searchString(char);
    }
  },
  _clearSearchValue() {
    this._searchValue = "";
  },
  _revertPart(direction) {
    if (!this._isAllSelected()) {
      const actual = this._getActivePartValue(this.option("emptyDateValue"));
      this._setActivePartValue(actual);
      this._selectNextPart(direction);
    }
    this._clearSearchValue();
  },
  _useMaskBehavior() {
    return this.option("useMaskBehavior") && "text" === this.option("mode");
  },
  _prepareRegExpInfo() {
    this._regExpInfo = getRegExpInfo(this._getFormatPattern(), date_default2);
    const {
      regexp
    } = this._regExpInfo;
    const {
      source
    } = regexp;
    const {
      flags
    } = regexp;
    const quantifierRegexp = new RegExp(/(\{[0-9]+,?[0-9]*\})/);
    const convertedSource = source.split(quantifierRegexp).map((sourcePart) => quantifierRegexp.test(sourcePart) ? sourcePart : number_default2.convertDigits(sourcePart, false)).join("");
    this._regExpInfo.regexp = new RegExp(convertedSource, flags);
  },
  _initMaskState() {
    this._activePartIndex = 0;
    this._formatPattern = null;
    this._prepareRegExpInfo();
    this._loadMaskValue();
  },
  _renderMask() {
    this.callBase();
    this._detachMaskEvents();
    this._clearMaskState();
    if (this._useMaskBehavior()) {
      this._attachMaskEvents();
      this._initMaskState();
      this._renderDateParts();
    }
  },
  _renderDateParts() {
    if (!this._useMaskBehavior()) {
      return;
    }
    const text = this.option("text") || this._getDisplayedText(this._maskValue);
    if (text) {
      this._dateParts = renderDateParts(text, this._regExpInfo);
      if (!this._input().is(":hidden")) {
        this._selectNextPart();
      }
    }
  },
  _detachMaskEvents() {
    events_engine_default.off(this._input(), ".dateBoxMask");
  },
  _attachMaskEvents() {
    events_engine_default.on(this._input(), addNamespace2("dxclick", "dateBoxMask"), this._maskClickHandler.bind(this));
    events_engine_default.on(this._input(), addNamespace2("paste", "dateBoxMask"), this._maskPasteHandler.bind(this));
    events_engine_default.on(this._input(), addNamespace2("drop", "dateBoxMask"), () => {
      this._renderSelectedPart();
    });
    events_engine_default.on(this._input(), addNamespace2("compositionend", "dateBoxMask"), this._maskCompositionEndHandler.bind(this));
    if (this._useBeforeInputEvent()) {
      events_engine_default.on(this._input(), addNamespace2("beforeinput", "dateBoxMask"), this._maskBeforeInputHandler.bind(this));
    }
  },
  _renderSelectedPart() {
    this._renderDisplayText(this._getDisplayedText(this._maskValue));
    this._selectNextPart();
  },
  _selectLastPart() {
    if (this.option("text")) {
      this._activePartIndex = this._dateParts.length;
      this._selectNextPart(-1);
    }
  },
  _selectFirstPart() {
    if (this.option("text")) {
      this._activePartIndex = -1;
      this._selectNextPart(1);
    }
  },
  _onMouseWheel(e) {
    if (this._useMaskBehavior()) {
      this._partIncrease(e.delta > 0 ? 1 : -1, e);
    }
  },
  _selectNextPart() {
    let step = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    if (!this.option("text") || this._disposed) {
      return;
    }
    if (step) {
      this._initialMaskValue = new Date(this._maskValue);
    }
    let index2 = fitIntoRange(this._activePartIndex + step, 0, this._dateParts.length - 1);
    if (this._dateParts[index2].isStub) {
      const isBoundaryIndex = 0 === index2 && step < 0 || index2 === this._dateParts.length - 1 && step > 0;
      if (!isBoundaryIndex) {
        this._selectNextPart(step >= 0 ? step + 1 : step - 1);
        return;
      }
      index2 = this._activePartIndex;
    }
    if (this._activePartIndex !== index2) {
      this._clearSearchValue();
    }
    this._activePartIndex = index2;
    this._caret(this._getActivePartProp("caret"));
  },
  _getRealLimitsPattern() {
    if ("d" === this._getActivePartProp("pattern")[0]) {
      return "dM";
    }
  },
  _getActivePartLimits(lockOtherParts) {
    const limitFunction = this._getActivePartProp("limits");
    return limitFunction(this._maskValue, lockOtherParts && this._getRealLimitsPattern());
  },
  _getActivePartValue(dateValue) {
    dateValue = dateValue || this._maskValue;
    const getter = this._getActivePartProp("getter");
    return isFunction(getter) ? getter(dateValue) : dateValue[getter]();
  },
  _addLeadingZeroes(value2) {
    const zeroes = this._searchValue.match(/^0+/);
    const limits = this._getActivePartLimits();
    const maxLimitLength = String(limits.max).length;
    return ((zeroes && zeroes[0] || "") + String(value2)).substr(-maxLimitLength);
  },
  _setActivePartValue(value2, dateValue) {
    dateValue = dateValue || this._maskValue;
    const setter = this._getActivePartProp("setter");
    const limits = this._getActivePartLimits();
    value2 = inRange(value2, limits.min, limits.max) ? value2 : value2 % 10;
    value2 = this._addLeadingZeroes(fitIntoRange(value2, limits.min, limits.max));
    isFunction(setter) ? setter(dateValue, value2) : dateValue[setter](value2);
    this._renderDisplayText(this._getDisplayedText(dateValue));
    this._renderDateParts();
  },
  _getActivePartProp(property) {
    if (!this._dateParts || !this._dateParts[this._activePartIndex]) {
      return;
    }
    return this._dateParts[this._activePartIndex][property];
  },
  _loadMaskValue() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.dateOption("value");
    this._maskValue = value2 && new Date(value2);
    this._initialMaskValue = value2 && new Date(value2);
  },
  _saveMaskValue() {
    const value2 = this._maskValue && new Date(this._maskValue);
    if (value2 && "date" === this.option("type")) {
      value2.setHours(0, 0, 0, 0);
    }
    this._initialMaskValue = new Date(value2);
    this.dateOption("value", value2);
  },
  _revertChanges() {
    this._loadMaskValue();
    this._renderDisplayText(this._getDisplayedText(this._maskValue));
    this._renderDateParts();
  },
  _renderDisplayText(text) {
    this.callBase(text);
    if (this._useMaskBehavior()) {
      this.option("text", text);
    }
  },
  _partIncrease(step, lockOtherParts) {
    this._setNewDateIfEmpty();
    const {
      max,
      min
    } = this._getActivePartLimits(lockOtherParts);
    let newValue = step + this._getActivePartValue();
    if (newValue > max) {
      newValue = this._applyLimits(newValue, {
        limitBase: min,
        limitClosest: max,
        max
      });
    } else if (newValue < min) {
      newValue = this._applyLimits(newValue, {
        limitBase: max,
        limitClosest: min,
        max
      });
    }
    this._setActivePartValue(newValue);
  },
  _applyLimits(newValue, _ref2) {
    let {
      limitBase,
      limitClosest,
      max
    } = _ref2;
    const delta = (newValue - limitClosest) % max;
    return delta ? limitBase + delta - 1 * sign(delta) : limitClosest;
  },
  _maskClickHandler() {
    this._loadMaskValue(this._maskValue);
    if (this.option("text")) {
      this._activePartIndex = getDatePartIndexByPosition(this._dateParts, this._caret().start);
      if (!this._isAllSelected()) {
        if (isDefined(this._activePartIndex)) {
          this._caret(this._getActivePartProp("caret"));
        } else {
          this._selectLastPart();
        }
      }
    }
  },
  _maskCompositionEndHandler(e) {
    this._input().val(this._getDisplayedText(this._maskValue));
    this._selectNextPart();
    this._maskInputHandler = () => {
      this._renderSelectedPart();
    };
  },
  _maskPasteHandler(e) {
    const newText = this._replaceSelectedText(this.option("text"), this._caret(), clipboardText(e));
    const date = date_default2.parse(newText, this._getFormatPattern());
    if (date && this._isDateValid(date)) {
      this._maskValue = date;
      this._renderDisplayText(this._getDisplayedText(this._maskValue));
      this._renderDateParts();
      this._selectNextPart();
    }
    e.preventDefault();
  },
  _isDateValid: (date) => isDate(date) && !isNaN(date),
  _isValueDirty() {
    const value2 = this.dateOption("value");
    return (this._maskValue && this._maskValue.getTime()) !== (value2 && value2.getTime());
  },
  _fireChangeEvent() {
    this._clearSearchValue();
    if (this._isValueDirty()) {
      events_engine_default.trigger(this._input(), "change");
    }
  },
  _enterHandler() {
    this._fireChangeEvent();
    this._selectNextPart(1);
  },
  _focusOutHandler(e) {
    const shouldFireChangeEvent = this._useMaskBehavior() && !e.isDefaultPrevented();
    if (shouldFireChangeEvent) {
      this._fireChangeEvent();
      this.callBase(e);
      this._selectFirstPart(e);
    } else {
      this.callBase(e);
    }
  },
  _valueChangeEventHandler(e) {
    const text = this.option("text");
    if (this._useMaskBehavior()) {
      this._saveValueChangeEvent(e);
      if (!text) {
        this._maskValue = null;
      } else if (null === this._maskValue) {
        this._loadMaskValue(text);
      }
      this._saveMaskValue();
    } else {
      this.callBase(e);
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "useMaskBehavior":
        this._renderMask();
        break;
      case "displayFormat":
      case "mode":
        this.callBase(args);
        this._renderMask();
        break;
      case "value":
        this._loadMaskValue();
        this.callBase(args);
        this._renderDateParts();
        break;
      case "emptyDateValue":
        break;
      default:
        this.callBase(args);
    }
  },
  _clearMaskState() {
    this._clearSearchValue();
    delete this._dateParts;
    delete this._activePartIndex;
    delete this._maskValue;
  },
  clear() {
    this._clearMaskState();
    this._activePartIndex = 0;
    this.callBase();
  },
  _clean() {
    this.callBase();
    this._detachMaskEvents();
    this._clearMaskState();
  }
});
var m_date_box_mask_default = DateBoxMask;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.js
component_registrator_default("dxDateBox", m_date_box_mask_default);
var m_date_box_default = m_date_box_mask_default;

// ../../../../../../node_modules/devextreme/esm/ui/date_box.js
var date_box_default = m_date_box_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_responsive_box.js
var SCREEN_SIZE_CLASS_PREFIX = "dx-responsivebox-screen-";
var ResponsiveBox = ui_collection_widget_edit_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      rows: [],
      cols: [],
      screenByWidth: null,
      singleColumnScreen: "",
      height: "100%",
      width: "100%",
      activeStateEnabled: false,
      focusStateEnabled: false,
      onItemStateChanged: void 0,
      onLayoutChanged: null,
      currentScreenFactor: void 0
    });
  },
  _init() {
    if (!this.option("screenByWidth")) {
      this._options.silent("screenByWidth", defaultScreenFactorFunc);
    }
    this.callBase();
    this._initLayoutChangedAction();
  },
  _initLayoutChangedAction() {
    this._layoutChangedAction = this._createActionByOption("onLayoutChanged", {
      excludeValidators: ["disabled", "readonly"]
    });
  },
  _itemClass: () => "dx-box-item",
  _itemDataKey: () => "dxBoxItemData",
  _initMarkup() {
    this.callBase();
    this.$element().addClass("dx-responsivebox");
  },
  _renderItems() {
    this._setScreenSize();
    this._screenItems = this._itemsByScreen();
    this._prepareGrid();
    this._spreadItems();
    this._layoutItems();
    this._linkNodeToItem();
  },
  _itemOptionChanged(item) {
    const $item = this._findItemElementByItem(item);
    if (!$item.length) {
      return;
    }
    this._refreshItem($item, item);
    this._clearItemNodeTemplates();
    this._update(true);
  },
  _setScreenSize() {
    const currentScreen = this._getCurrentScreen();
    this._removeScreenSizeClass();
    this.$element().addClass(SCREEN_SIZE_CLASS_PREFIX + currentScreen);
    this.option("currentScreenFactor", currentScreen);
  },
  _removeScreenSizeClass() {
    const currentScreenFactor = this.option("currentScreenFactor");
    currentScreenFactor && this.$element().removeClass(SCREEN_SIZE_CLASS_PREFIX + currentScreenFactor);
  },
  _prepareGrid() {
    const grid = this._grid = [];
    this._prepareRowsAndCols();
    each(this._rows, () => {
      const row = [];
      grid.push(row);
      each(this._cols, () => {
        row.push(this._createEmptyCell());
      });
    });
  },
  getSingleColumnRows() {
    const rows = this.option("rows");
    const screenItemsLength = this._screenItems.length;
    if (rows.length) {
      const filteredRows = this._filterByScreen(rows);
      const result2 = [];
      for (let i = 0; i < screenItemsLength; i++) {
        const sizeConfig = this._defaultSizeConfig();
        if (i < filteredRows.length && isDefined(filteredRows[i].shrink)) {
          sizeConfig.shrink = filteredRows[i].shrink;
        }
        result2.push(sizeConfig);
      }
      return result2;
    }
    return this._defaultSizeConfig(screenItemsLength);
  },
  _prepareRowsAndCols() {
    if (this._isSingleColumnScreen()) {
      this._prepareSingleColumnScreenItems();
      this._rows = this.getSingleColumnRows();
      this._cols = this._defaultSizeConfig(1);
    } else {
      this._rows = this._sizesByScreen(this.option("rows"));
      this._cols = this._sizesByScreen(this.option("cols"));
    }
  },
  _isSingleColumnScreen() {
    return this._screenRegExp().test(this.option("singleColumnScreen")) || !this.option("rows").length || !this.option("cols").length;
  },
  _prepareSingleColumnScreenItems() {
    this._screenItems.sort((item1, item2) => item1.location.row - item2.location.row || item1.location.col - item2.location.col);
    each(this._screenItems, (index2, item) => {
      extend(item.location, {
        row: index2,
        col: 0,
        rowspan: 1,
        colspan: 1
      });
    });
  },
  _sizesByScreen(sizeConfigs) {
    return map(this._filterByScreen(sizeConfigs), (sizeConfig) => extend(this._defaultSizeConfig(), sizeConfig));
  },
  _createDefaultSizeConfig: () => ({
    ratio: 1,
    baseSize: 0,
    minSize: 0,
    maxSize: 0
  }),
  _defaultSizeConfig(size) {
    const defaultSizeConfig = this._createDefaultSizeConfig();
    if (!arguments.length) {
      return defaultSizeConfig;
    }
    const result2 = [];
    for (let i = 0; i < size; i++) {
      result2.push(defaultSizeConfig);
    }
    return result2;
  },
  _filterByScreen(items) {
    const screenRegExp = this._screenRegExp();
    return grep(items, (item) => !item.screen || screenRegExp.test(item.screen));
  },
  _screenRegExp() {
    const screen = this._getCurrentScreen();
    return new RegExp(`(^|\\s)${screen}($|\\s)`, "i");
  },
  _getCurrentScreen() {
    const width = this._screenWidth();
    return this.option("screenByWidth")(width);
  },
  _screenWidth: () => hasWindow() ? getWidth(getWindow()) : 1920,
  _createEmptyCell: () => ({
    item: {},
    location: {
      colspan: 1,
      rowspan: 1
    }
  }),
  _spreadItems() {
    each(this._screenItems, (_, itemInfo) => {
      const location = itemInfo.location || {};
      const itemCol = location.col;
      const itemRow = location.row;
      const row = this._grid[itemRow];
      const itemCell = row && row[itemCol];
      this._occupyCells(itemCell, itemInfo);
    });
  },
  _itemsByScreen() {
    return this.option("items").reduce((result2, item) => {
      let locations = item.location || {};
      locations = isPlainObject(locations) ? [locations] : locations;
      this._filterByScreen(locations).forEach((location) => {
        result2.push({
          item,
          location: extend({
            rowspan: 1,
            colspan: 1
          }, location)
        });
      });
      return result2;
    }, []);
  },
  _occupyCells(itemCell, itemInfo) {
    if (!itemCell || this._isItemCellOccupied(itemCell, itemInfo)) {
      return;
    }
    extend(itemCell, itemInfo);
    this._markSpanningCell(itemCell);
  },
  _isItemCellOccupied(itemCell, itemInfo) {
    if (!isEmptyObject(itemCell.item)) {
      return true;
    }
    let result2 = false;
    this._loopOverSpanning(itemInfo.location, (cell) => {
      result2 = result2 || !isEmptyObject(cell.item);
    });
    return result2;
  },
  _loopOverSpanning(location, callback) {
    const rowEnd = location.row + location.rowspan - 1;
    const colEnd = location.col + location.colspan - 1;
    const boundRowEnd = Math.min(rowEnd, this._rows.length - 1);
    const boundColEnd = Math.min(colEnd, this._cols.length - 1);
    location.rowspan -= rowEnd - boundRowEnd;
    location.colspan -= colEnd - boundColEnd;
    for (let rowIndex = location.row; rowIndex <= boundRowEnd; rowIndex++) {
      for (let colIndex = location.col; colIndex <= boundColEnd; colIndex++) {
        if (rowIndex !== location.row || colIndex !== location.col) {
          callback(this._grid[rowIndex][colIndex]);
        }
      }
    }
  },
  _markSpanningCell(itemCell) {
    this._loopOverSpanning(itemCell.location, (cell) => {
      extend(cell, {
        item: itemCell.item,
        spanningCell: itemCell
      });
    });
  },
  _linkNodeToItem() {
    each(this._itemElements(), (_, itemNode) => {
      const $item = renderer_default(itemNode);
      const item = $item.data("dxBoxItemData");
      if (!item.box) {
        item.node = $item.children();
      }
    });
  },
  _layoutItems() {
    const rowsCount = this._grid.length;
    const colsCount = rowsCount && this._grid[0].length;
    if (!rowsCount && !colsCount) {
      return;
    }
    const result2 = this._layoutBlock({
      direction: "col",
      row: {
        start: 0,
        end: rowsCount - 1
      },
      col: {
        start: 0,
        end: colsCount - 1
      }
    });
    const rootBox = this._prepareBoxConfig(result2.box || {
      direction: "row",
      items: [extend(result2, {
        ratio: 1
      })]
    });
    extend(rootBox, this._rootBoxConfig(rootBox.items));
    this._$root = renderer_default("<div>").appendTo(this._itemContainer());
    this._createComponent(this._$root, box_default, rootBox);
  },
  _rootBoxConfig(items) {
    const rootItems = each(items, (index2, item) => {
      this._needApplyAutoBaseSize(item) && extend(item, {
        baseSize: "auto"
      });
    });
    return {
      width: "100%",
      height: "100%",
      items: rootItems,
      itemTemplate: this._getTemplateByOption("itemTemplate"),
      itemHoldTimeout: this.option("itemHoldTimeout"),
      onItemHold: this._createActionByOption("onItemHold"),
      onItemClick: this._createActionByOption("onItemClick"),
      onItemContextMenu: this._createActionByOption("onItemContextMenu"),
      onItemRendered: this._createActionByOption("onItemRendered")
    };
  },
  _needApplyAutoBaseSize: (item) => !item.baseSize && (!item.minSize || "auto" === item.minSize) && (!item.maxSize || "auto" === item.maxSize),
  _prepareBoxConfig(config3) {
    return extend(config3 || {}, {
      crossAlign: "stretch",
      onItemStateChanged: this.option("onItemStateChanged")
    });
  },
  _layoutBlock(options2) {
    if (this._isSingleItem(options2)) {
      return this._itemByCell(options2.row.start, options2.col.start);
    }
    return this._layoutDirection(options2);
  },
  _isSingleItem(options2) {
    const firstCellLocation = this._grid[options2.row.start][options2.col.start].location;
    const isItemRowSpanned = options2.row.end - options2.row.start === firstCellLocation.rowspan - 1;
    const isItemColSpanned = options2.col.end - options2.col.start === firstCellLocation.colspan - 1;
    return isItemRowSpanned && isItemColSpanned;
  },
  _itemByCell(rowIndex, colIndex) {
    const itemCell = this._grid[rowIndex][colIndex];
    return itemCell.spanningCell ? null : itemCell.item;
  },
  _layoutDirection(options2) {
    const items = [];
    const {
      direction
    } = options2;
    const crossDirection = this._crossDirection(direction);
    let block;
    while (block = this._nextBlock(options2)) {
      if (this._isBlockIndivisible(options2.prevBlockOptions, block)) {
        throw ui_errors_default.Error("E1025");
      }
      const item = this._layoutBlock({
        direction: crossDirection,
        row: block.row,
        col: block.col,
        prevBlockOptions: options2
      });
      if (item) {
        extend(item, this._blockSize(block, crossDirection));
        items.push(item);
      }
      options2[crossDirection].start = block[crossDirection].end + 1;
    }
    return {
      box: this._prepareBoxConfig({
        direction,
        items
      })
    };
  },
  _isBlockIndivisible: (options2, block) => options2 && options2.col.start === block.col.start && options2.col.end === block.col.end && options2.row.start === block.row.start && options2.row.end === block.row.end,
  _crossDirection: (direction) => "col" === direction ? "row" : "col",
  _nextBlock(options2) {
    const {
      direction
    } = options2;
    const crossDirection = this._crossDirection(direction);
    const startIndex = options2[direction].start;
    const endIndex = options2[direction].end;
    const crossStartIndex = options2[crossDirection].start;
    if (crossStartIndex > options2[crossDirection].end) {
      return null;
    }
    let crossSpan = 1;
    for (let crossIndex = crossStartIndex; crossIndex < crossStartIndex + crossSpan; crossIndex++) {
      let lineCrossSpan = 1;
      for (let index2 = startIndex; index2 <= endIndex; index2++) {
        const cell = this._cellByDirection(direction, index2, crossIndex);
        lineCrossSpan = Math.max(lineCrossSpan, cell.location[`${crossDirection}span`]);
      }
      const lineCrossEndIndex = crossIndex + lineCrossSpan;
      const crossEndIndex = crossStartIndex + crossSpan;
      if (lineCrossEndIndex > crossEndIndex) {
        crossSpan += lineCrossEndIndex - crossEndIndex;
      }
    }
    const result2 = {};
    result2[direction] = {
      start: startIndex,
      end: endIndex
    };
    result2[crossDirection] = {
      start: crossStartIndex,
      end: crossStartIndex + crossSpan - 1
    };
    return result2;
  },
  _cellByDirection(direction, index2, crossIndex) {
    return "col" === direction ? this._grid[crossIndex][index2] : this._grid[index2][crossIndex];
  },
  _blockSize(block, direction) {
    const defaultMinSize = "row" === direction ? "auto" : 0;
    const sizeConfigs = "row" === direction ? this._rows : this._cols;
    const result2 = extend(this._createDefaultSizeConfig(), {
      ratio: 0
    });
    for (let index2 = block[direction].start; index2 <= block[direction].end; index2++) {
      const sizeConfig = sizeConfigs[index2];
      result2.ratio += sizeConfig.ratio;
      result2.baseSize += sizeConfig.baseSize;
      result2.minSize += sizeConfig.minSize;
      result2.maxSize += sizeConfig.maxSize;
      if (isDefined(sizeConfig.shrink)) {
        result2.shrink = sizeConfig.shrink;
      }
    }
    result2.minSize = result2.minSize ? result2.minSize : defaultMinSize;
    result2.maxSize = result2.maxSize ? result2.maxSize : "auto";
    this._isSingleColumnScreen() && (result2.baseSize = "auto");
    return result2;
  },
  _update(forceRemoveRoot) {
    const $existingRoot = this._$root;
    this._renderItems();
    if ($existingRoot) {
      if (forceRemoveRoot) {
        $existingRoot.remove();
      } else {
        $existingRoot.detach();
        this._saveAssistantRoot($existingRoot);
      }
    }
    this._layoutChangedAction();
  },
  _saveAssistantRoot($root) {
    this._assistantRoots = this._assistantRoots || [];
    this._assistantRoots.push($root);
  },
  _dispose() {
    this._clearItemNodeTemplates();
    this._cleanUnusedRoots();
    this.callBase.apply(this, arguments);
  },
  _cleanUnusedRoots() {
    if (!this._assistantRoots) {
      return;
    }
    each(this._assistantRoots, (_, item) => {
      renderer_default(item).remove();
    });
  },
  _clearItemNodeTemplates() {
    each(this.option("items"), function() {
      delete this.node;
    });
  },
  _attachClickEvent: noop2,
  _optionChanged(args) {
    switch (args.name) {
      case "rows":
      case "cols":
      case "screenByWidth":
      case "singleColumnScreen":
        this._clearItemNodeTemplates();
        this._invalidate();
        break;
      case "width":
      case "height":
        this.callBase(args);
        this._update();
        break;
      case "onLayoutChanged":
        this._initLayoutChangedAction();
        break;
      case "itemTemplate":
        this._clearItemNodeTemplates();
        this.callBase(args);
        break;
      case "currentScreenFactor":
        break;
      default:
        this.callBase(args);
    }
  },
  _dimensionChanged() {
    if (this._getCurrentScreen() !== this.option("currentScreenFactor")) {
      this._update();
    }
  },
  repaint() {
    this._update();
  }
});
component_registrator_default("dxResponsiveBox", ResponsiveBox);
var m_responsive_box_default = ResponsiveBox;

// ../../../../../../node_modules/devextreme/esm/ui/responsive_box.js
var responsive_box_default = m_responsive_box_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/components/m_button_item.js
function renderButtonItem(_ref) {
  let {
    item,
    $parent,
    rootElementCssClassList,
    validationGroup,
    createComponentCallback
  } = _ref;
  const $rootElement = renderer_default("<div>").appendTo($parent).addClass(rootElementCssClassList.join(" ")).addClass("dx-field-button-item").css("textAlign", convertAlignmentToTextAlign(item.horizontalAlignment));
  $parent.css("justifyContent", convertAlignmentToJustifyContent(item.verticalAlignment));
  const $button = renderer_default("<div>").appendTo($rootElement);
  return {
    $rootElement,
    buttonInstance: createComponentCallback($button, "dxButton", extend({
      validationGroup
    }, item.buttonOptions))
  };
}
function convertAlignmentToTextAlign(horizontalAlignment) {
  return isDefined(horizontalAlignment) ? horizontalAlignment : "right";
}
function convertAlignmentToJustifyContent(verticalAlignment) {
  switch (verticalAlignment) {
    case "center":
      return "center";
    case "bottom":
      return "flex-end";
    default:
      return "flex-start";
  }
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/components/m_empty_item.js
function renderEmptyItem(_ref) {
  let {
    $parent,
    rootElementCssClassList
  } = _ref;
  return renderer_default("<div>").addClass("dx-field-empty-item").html("&nbsp;").addClass(rootElementCssClassList.join(" ")).appendTo($parent);
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/validation/m_default_adapter.js
var DefaultAdapter = class_default.inherit({
  ctor(editor, validator) {
    this.editor = editor;
    this.validator = validator;
    this.validationRequestsCallbacks = [];
    const handler = (args) => {
      this.validationRequestsCallbacks.forEach((item) => item(args));
    };
    editor.validationRequest.add(handler);
    editor.on("disposing", () => {
      editor.validationRequest.remove(handler);
    });
  },
  getValue() {
    return this.editor.option("value");
  },
  getCurrentValidationError() {
    return this.editor.option("validationError");
  },
  bypass() {
    return this.editor.option("disabled");
  },
  applyValidationResults(params) {
    this.editor.option({
      validationErrors: params.brokenRules,
      validationStatus: params.status
    });
  },
  reset() {
    this.editor.clear();
  },
  focus() {
    this.editor.focus();
  }
});
var m_default_adapter_default = DefaultAdapter;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_validator.js
var Validator = dom_component_default.inherit({
  _initOptions(options2) {
    this.callBase.apply(this, arguments);
    this.option(m_validation_engine_default.initValidationOptions(options2));
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      validationRules: []
    });
  },
  _init() {
    this.callBase();
    this._initGroupRegistration();
    this.focused = callbacks_default();
    this._initAdapter();
    this._validationInfo = {
      result: null,
      deferred: null,
      skipValidation: false
    };
  },
  _initGroupRegistration() {
    const group = this._findGroup();
    if (!this._groupWasInit) {
      this.on("disposing", (args) => {
        m_validation_engine_default.removeRegisteredValidator(args.component._validationGroup, args.component);
      });
    }
    if (!this._groupWasInit || this._validationGroup !== group) {
      m_validation_engine_default.removeRegisteredValidator(this._validationGroup, this);
      this._groupWasInit = true;
      this._validationGroup = group;
      m_validation_engine_default.registerValidatorInGroup(group, this);
    }
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      validationGroup: true
    });
  },
  _getEditor() {
    const element = this.$element()[0];
    return data(element, "dx-validation-target");
  },
  _initAdapter() {
    const dxStandardEditor = this._getEditor();
    let adapter = this.option("adapter");
    if (!adapter) {
      if (dxStandardEditor) {
        adapter = new m_default_adapter_default(dxStandardEditor, this);
        adapter.validationRequestsCallbacks.push((args) => {
          if (this._validationInfo.skipValidation) {
            return;
          }
          this.validate(args);
        });
        this.option("adapter", adapter);
        return;
      }
      throw ui_errors_default.Error("E0120");
    }
    const callbacks2 = adapter.validationRequestsCallbacks;
    if (callbacks2) {
      callbacks2.push((args) => {
        this.validate(args);
      });
    }
  },
  _toggleRTLDirection(isRtl) {
    var _this$option;
    const rtlEnabled = (null === (_this$option = this.option("adapter")) || void 0 === _this$option || null === (_this$option = _this$option.editor) || void 0 === _this$option ? void 0 : _this$option.option("rtlEnabled")) ?? isRtl;
    this.callBase(rtlEnabled);
  },
  _initMarkup() {
    this.$element().addClass("dx-validator");
    this.callBase();
  },
  _render() {
    this.callBase();
    this._toggleAccessibilityAttributes();
  },
  _toggleAccessibilityAttributes() {
    const dxStandardEditor = this._getEditor();
    if (dxStandardEditor) {
      const rules = this.option("validationRules") || [];
      const isRequired = rules.some((_ref) => {
        let {
          type: type2
        } = _ref;
        return "required" === type2;
      }) || null;
      if (dxStandardEditor.isInitialized()) {
        dxStandardEditor.setAria("required", isRequired);
      }
      dxStandardEditor.option("_onMarkupRendered", () => {
        dxStandardEditor.setAria("required", isRequired);
      });
    }
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._initGroupRegistration();
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "validationGroup":
        this._initGroupRegistration();
        return;
      case "validationRules":
        this._resetValidationRules();
        this._toggleAccessibilityAttributes();
        void 0 !== this.option("isValid") && this.validate();
        return;
      case "adapter":
        this._initAdapter();
        break;
      case "isValid":
      case "validationStatus":
        this.option(m_validation_engine_default.synchronizeValidationOptions(args, this.option()));
        break;
      default:
        this.callBase(args);
    }
  },
  _getValidationRules() {
    if (!this._validationRules) {
      this._validationRules = map(this.option("validationRules"), (rule, index2) => extend({}, rule, {
        validator: this,
        index: index2
      }));
    }
    return this._validationRules;
  },
  _findGroup() {
    const $element = this.$element();
    return this.option("validationGroup") || m_validation_engine_default.findGroup($element, this._modelByElement($element));
  },
  _resetValidationRules() {
    delete this._validationRules;
  },
  validate(args) {
    const adapter = this.option("adapter");
    const name2 = this.option("name");
    const bypass = adapter.bypass && adapter.bypass();
    const value2 = args && void 0 !== args.value ? args.value : adapter.getValue();
    const currentError = adapter.getCurrentValidationError && adapter.getCurrentValidationError();
    const rules = this._getValidationRules();
    const currentResult = this._validationInfo && this._validationInfo.result;
    if (currentResult && "pending" === currentResult.status && currentResult.value === value2) {
      return extend({}, currentResult);
    }
    let result2;
    if (bypass) {
      result2 = {
        isValid: true,
        status: "valid"
      };
    } else if (currentError && currentError.editorSpecific) {
      currentError.validator = this;
      result2 = {
        isValid: false,
        status: "invalid",
        brokenRule: currentError,
        brokenRules: [currentError]
      };
    } else {
      result2 = m_validation_engine_default.validate(value2, rules, name2);
    }
    result2.id = new guid_default().toString();
    this._applyValidationResult(result2, adapter);
    result2.complete && result2.complete.then((res) => {
      if (res.id === this._validationInfo.result.id) {
        this._applyValidationResult(res, adapter);
      }
    });
    return extend({}, this._validationInfo.result);
  },
  reset() {
    const adapter = this.option("adapter");
    const result2 = {
      id: null,
      isValid: true,
      brokenRule: null,
      brokenRules: null,
      pendingRules: null,
      status: "valid",
      complete: null
    };
    this._validationInfo.skipValidation = true;
    adapter.reset();
    this._validationInfo.skipValidation = false;
    this._resetValidationRules();
    this._applyValidationResult(result2, adapter);
  },
  _updateValidationResult(result2) {
    if (!this._validationInfo.result || this._validationInfo.result.id !== result2.id) {
      const complete = this._validationInfo.deferred && this._validationInfo.result.complete;
      this._validationInfo.result = extend({}, result2, {
        complete
      });
    } else {
      for (const prop in result2) {
        if ("id" !== prop && "complete" !== prop) {
          this._validationInfo.result[prop] = result2[prop];
        }
      }
    }
  },
  _applyValidationResult(result2, adapter) {
    const validatedAction = this._createActionByOption("onValidated", {
      excludeValidators: ["readOnly"]
    });
    result2.validator = this;
    this._updateValidationResult(result2);
    adapter.applyValidationResults && adapter.applyValidationResults(this._validationInfo.result);
    this.option({
      validationStatus: this._validationInfo.result.status
    });
    if ("pending" === this._validationInfo.result.status) {
      if (!this._validationInfo.deferred) {
        this._validationInfo.deferred = Deferred();
        this._validationInfo.result.complete = this._validationInfo.deferred.promise();
      }
      this._eventsStrategy.fireEvent("validating", [this._validationInfo.result]);
      return;
    }
    if ("pending" !== this._validationInfo.result.status) {
      validatedAction(result2);
      if (this._validationInfo.deferred) {
        this._validationInfo.deferred.resolve(result2);
        this._validationInfo.deferred = null;
      }
    }
  },
  focus() {
    const adapter = this.option("adapter");
    adapter && adapter.focus && adapter.focus();
  },
  _useTemplates: () => false
});
component_registrator_default("dxValidator", Validator);
var m_validator_default = Validator;

// ../../../../../../node_modules/devextreme/esm/ui/validator.js
var validator_default = m_validator_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/constants.js
var FORM_CLASS = "dx-form";
var FORM_GROUP_CLASS = "dx-form-group";
var FORM_GROUP_CAPTION_CLASS = "dx-form-group-caption";
var FORM_GROUP_CUSTOM_CAPTION_CLASS = "dx-form-group-custom-caption";
var FORM_FIELD_ITEM_COL_CLASS = "dx-col-";
var FIELD_ITEM_CLASS = "dx-field-item";
var LAYOUT_MANAGER_ONE_COLUMN = "dx-layout-manager-one-col";
var FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content";
var FORM_LAYOUT_MANAGER_CLASS = "dx-layout-manager";
var FIELD_ITEM_LABEL_CLASS = "dx-field-item-label";
var FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content";
var SINGLE_COLUMN_ITEM_CONTENT = "dx-single-column-item-content";
var ROOT_SIMPLE_ITEM_CLASS = "dx-root-simple-item";
var FORM_GROUP_CONTENT_CLASS = "dx-form-group-content";
var FIELD_ITEM_CONTENT_HAS_GROUP_CLASS = "dx-field-item-has-group";
var FIELD_ITEM_CONTENT_HAS_TABS_CLASS = "dx-field-item-has-tabs";
var FORM_GROUP_WITH_CAPTION_CLASS = "dx-form-group-with-caption";
var FIELD_ITEM_TAB_CLASS = "dx-field-item-tab";
var GROUP_COL_COUNT_CLASS = "dx-group-colcount-";
var GROUP_COL_COUNT_ATTR = "group-col-count";
var FORM_VALIDATION_SUMMARY = "dx-form-validation-summary";
var FORM_UNDERLINED_CLASS = "dx-form-styling-mode-underlined";
var SIMPLE_ITEM_TYPE = "simple";

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.layout_manager.utils.js
var EDITORS_WITH_ARRAY_VALUE = ["dxTagBox", "dxRangeSlider", "dxDateRangeBox"];
var EDITORS_WITH_SPECIFIC_LABELS = ["dxRangeSlider", "dxSlider"];
var EDITORS_WITHOUT_LABELS = ["dxCalendar", "dxCheckBox", "dxHtmlEditor", "dxRadioGroup", "dxRangeSlider", "dxSlider", "dxSwitch"];
function convertToRenderFieldItemOptions(_ref) {
  let {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    item,
    template,
    labelTemplate,
    name: name2,
    formLabelLocation,
    requiredMessageTemplate,
    validationGroup,
    editorValue,
    canAssignUndefinedValueToEditor,
    editorValidationBoundary,
    editorStylingMode,
    showColonAfterLabel,
    managerLabelLocation,
    itemId,
    managerMarkOptions,
    labelMode,
    onLabelTemplateRendered
  } = _ref;
  const isRequired = isDefined(item.isRequired) ? item.isRequired : !!_hasRequiredRuleInSet(item.validationRules);
  const isSimpleItem = item.itemType === SIMPLE_ITEM_TYPE;
  const helpID = item.helpText ? `dx-${new guid_default()}` : null;
  const labelOptions = _convertToLabelOptions({
    item,
    id: itemId,
    isRequired,
    managerMarkOptions,
    showColonAfterLabel,
    labelLocation: managerLabelLocation,
    formLabelMode: labelMode,
    labelTemplate,
    onLabelTemplateRendered
  });
  const needRenderLabel = labelOptions.visible && (labelOptions.text || labelOptions.labelTemplate && isSimpleItem);
  const {
    location: labelLocation,
    labelID
  } = labelOptions;
  const labelNeedBaselineAlign = "top" !== labelLocation && ["dxTextArea", "dxRadioGroup", "dxCalendar", "dxHtmlEditor"].includes(item.editorType);
  const editorOptions = _convertToEditorOptions({
    editorType: item.editorType,
    editorValue,
    defaultEditorName: item.dataField,
    canAssignUndefinedValueToEditor,
    externalEditorOptions: item.editorOptions,
    editorInputId: itemId,
    editorValidationBoundary,
    editorStylingMode,
    formLabelMode: labelMode,
    labelText: labelOptions.textWithoutColon,
    labelMark: labelOptions.markOptions.showRequiredMark ? String.fromCharCode(160) + labelOptions.markOptions.requiredMark : ""
  });
  const needRenderOptionalMarkAsHelpText = labelOptions.markOptions.showOptionalMark && !labelOptions.visible && "hidden" !== editorOptions.labelMode && !isDefined(item.helpText);
  const helpText = needRenderOptionalMarkAsHelpText ? labelOptions.markOptions.optionalMark : item.helpText;
  return {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    labelOptions,
    labelNeedBaselineAlign,
    labelLocation,
    needRenderLabel,
    item,
    isSimpleItem,
    isRequired,
    template,
    helpID,
    labelID,
    name: name2,
    helpText,
    formLabelLocation,
    requiredMessageTemplate,
    validationGroup,
    editorOptions
  };
}
function getLabelMarkText(_ref2) {
  let {
    showRequiredMark,
    requiredMark,
    showOptionalMark,
    optionalMark
  } = _ref2;
  if (!showRequiredMark && !showOptionalMark) {
    return "";
  }
  return String.fromCharCode(160) + (showRequiredMark ? requiredMark : optionalMark);
}
function convertToLabelMarkOptions(_ref3, isRequired) {
  let {
    showRequiredMark,
    requiredMark,
    showOptionalMark,
    optionalMark
  } = _ref3;
  return {
    showRequiredMark: showRequiredMark && isRequired,
    requiredMark,
    showOptionalMark: showOptionalMark && !isRequired,
    optionalMark
  };
}
function _convertToEditorOptions(_ref4) {
  let {
    editorType,
    defaultEditorName,
    editorValue,
    canAssignUndefinedValueToEditor,
    externalEditorOptions,
    editorInputId,
    editorValidationBoundary,
    editorStylingMode,
    formLabelMode,
    labelText,
    labelMark
  } = _ref4;
  const editorOptionsWithValue = {};
  if (void 0 !== editorValue || canAssignUndefinedValueToEditor) {
    editorOptionsWithValue.value = editorValue;
  }
  if (EDITORS_WITH_ARRAY_VALUE.includes(editorType)) {
    editorOptionsWithValue.value = editorOptionsWithValue.value || [];
  }
  let labelMode = null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.labelMode;
  if (!isDefined(labelMode)) {
    labelMode = "outside" === formLabelMode ? "hidden" : formLabelMode;
  }
  const stylingMode = (null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.stylingMode) || editorStylingMode;
  const useSpecificLabelOptions = EDITORS_WITH_SPECIFIC_LABELS.includes(editorType);
  const result2 = extend(true, editorOptionsWithValue, externalEditorOptions, {
    inputAttr: {
      id: editorInputId
    },
    validationBoundary: editorValidationBoundary,
    stylingMode,
    label: useSpecificLabelOptions ? null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.label : labelText,
    labelMode,
    labelMark
  });
  if (externalEditorOptions) {
    if (result2.dataSource) {
      result2.dataSource = externalEditorOptions.dataSource;
    }
    if (result2.items) {
      result2.items = externalEditorOptions.items;
    }
  }
  if (defaultEditorName && !result2.name) {
    result2.name = defaultEditorName;
  }
  return result2;
}
function _hasRequiredRuleInSet(rules) {
  let hasRequiredRule;
  if (rules && rules.length) {
    each(rules, (index2, rule) => {
      if ("required" === rule.type) {
        hasRequiredRule = true;
        return false;
      }
    });
  }
  return hasRequiredRule;
}
function _convertToLabelOptions(_ref5) {
  let {
    item,
    id,
    isRequired,
    managerMarkOptions,
    showColonAfterLabel,
    labelLocation,
    labelTemplate,
    formLabelMode,
    onLabelTemplateRendered
  } = _ref5;
  const isEditorWithoutLabels = EDITORS_WITHOUT_LABELS.includes(item.editorType);
  const labelOptions = extend({
    showColon: showColonAfterLabel,
    location: labelLocation,
    id,
    visible: "outside" === formLabelMode || isEditorWithoutLabels && "hidden" !== formLabelMode,
    isRequired
  }, item ? item.label : {}, {
    markOptions: convertToLabelMarkOptions(managerMarkOptions, isRequired),
    labelTemplate,
    onLabelTemplateRendered
  });
  if (["dxRadioGroup", "dxCheckBox", "dxLookup", "dxSlider", "dxRangeSlider", "dxSwitch", "dxHtmlEditor", "dxDateRangeBox"].includes(item.editorType)) {
    labelOptions.labelID = `dx-label-${new guid_default()}`;
  }
  if (!labelOptions.text && item.dataField) {
    labelOptions.text = captionize(item.dataField);
  }
  if (labelOptions.text) {
    labelOptions.textWithoutColon = labelOptions.text;
    labelOptions.text += labelOptions.showColon ? ":" : "";
  }
  return labelOptions;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/components/m_label.js
var FIELD_ITEM_REQUIRED_MARK_CLASS = "dx-field-item-required-mark";
var FIELD_ITEM_OPTIONAL_MARK_CLASS = "dx-field-item-optional-mark";
function renderLabel(_ref) {
  let {
    text,
    id,
    location,
    alignment,
    labelID = null,
    markOptions = {},
    labelTemplate,
    labelTemplateData,
    onLabelTemplateRendered
  } = _ref;
  if ((!isDefined(text) || text.length <= 0) && !isDefined(labelTemplate)) {
    return null;
  }
  const $label = renderer_default("<label>").addClass(`${FIELD_ITEM_LABEL_CLASS} dx-field-item-label-location-${location}`).attr("for", id).attr("id", labelID).css("textAlign", alignment);
  const $labelContainer = renderer_default("<span>").addClass(FIELD_ITEM_LABEL_CONTENT_CLASS);
  let $labelContent = renderer_default("<span>").addClass("dx-field-item-label-text").text(text);
  if (labelTemplate) {
    $labelContent = renderer_default("<div>").addClass("dx-field-item-custom-label-content");
    labelTemplateData.text = text;
    labelTemplate.render({
      container: getPublicElement($labelContent),
      model: labelTemplateData,
      onRendered() {
        null === onLabelTemplateRendered || void 0 === onLabelTemplateRendered || onLabelTemplateRendered();
      }
    });
  }
  return $label.append($labelContainer.append($labelContent, _renderLabelMark(markOptions)));
}
function _renderLabelMark(markOptions) {
  const markText = getLabelMarkText(markOptions);
  if ("" === markText) {
    return null;
  }
  return renderer_default("<span>").addClass(markOptions.showRequiredMark ? FIELD_ITEM_REQUIRED_MARK_CLASS : FIELD_ITEM_OPTIONAL_MARK_CLASS).text(markText);
}
function setLabelWidthByMaxLabelWidth($targetContainer, labelsSelector, labelMarkOptions) {
  const FIELD_ITEM_LABEL_CONTENT_CLASS_Selector = `${labelsSelector} > .${FIELD_ITEM_LABEL_CLASS}:not(.dx-field-item-label-location-top) > .${FIELD_ITEM_LABEL_CONTENT_CLASS}`;
  const $FIELD_ITEM_LABEL_CONTENT_CLASS_Items = $targetContainer.find(FIELD_ITEM_LABEL_CONTENT_CLASS_Selector);
  const FIELD_ITEM_LABEL_CONTENT_CLASS_Length = $FIELD_ITEM_LABEL_CONTENT_CLASS_Items.length;
  let labelWidth;
  let i;
  let maxWidth = 0;
  for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
    labelWidth = getLabelWidthByHTML($FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i]);
    if (labelWidth > maxWidth) {
      maxWidth = labelWidth;
    }
  }
  for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
    $FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i].style.width = `${maxWidth}px`;
  }
}
function getLabelWidthByHTML(labelContent) {
  let result2 = 0;
  const itemsCount = labelContent.children.length;
  for (let i = 0; i < itemsCount; i++) {
    const child = labelContent.children[i];
    result2 += child.offsetWidth;
  }
  return result2;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/components/m_field_item.js
var FIELD_ITEM_CONTENT_WRAPPER_CLASS = "dx-field-item-content-wrapper";
var TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var VALIDATION_TARGET_CLASS = "dx-validation-target";
var INVALID_CLASS = "dx-invalid";
function renderFieldItem(_ref) {
  let {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    labelOptions,
    labelNeedBaselineAlign,
    labelLocation,
    needRenderLabel,
    formLabelLocation,
    item,
    editorOptions,
    isSimpleItem,
    isRequired,
    template,
    helpID,
    labelID,
    name: name2,
    helpText,
    requiredMessageTemplate,
    validationGroup
  } = _ref;
  const $rootElement = renderer_default("<div>").addClass(rootElementCssClassList.join(" ")).appendTo($parent);
  $rootElement.addClass(isRequired ? "dx-field-item-required" : "dx-field-item-optional");
  if (isSimpleItem) {
    $rootElement.addClass("dx-flex-layout");
  }
  if (isSimpleItem && labelNeedBaselineAlign) {
    $rootElement.addClass("dx-field-item-label-align");
  }
  const $fieldEditorContainer = renderer_default("<div>");
  $fieldEditorContainer.data("dx-form-item", item);
  $fieldEditorContainer.addClass(FIELD_ITEM_CONTENT_CLASS).addClass("dx-field-item-content-location-" + {
    right: "left",
    left: "right",
    top: "bottom"
  }[formLabelLocation]);
  let $label = null;
  if (needRenderLabel) {
    if (labelOptions.labelTemplate) {
      labelOptions.labelTemplateData = getTemplateData(item, editorOptions, formOrLayoutManager);
    }
    $label = renderLabel(labelOptions);
  }
  if ($label) {
    const {
      editorType
    } = item;
    $rootElement.append($label);
    if ("top" === labelLocation || "left" === labelLocation) {
      $rootElement.append($fieldEditorContainer);
    }
    if ("right" === labelLocation) {
      $rootElement.prepend($fieldEditorContainer);
    }
    if ("top" === labelLocation) {
      $rootElement.addClass("dx-label-v-align");
    } else {
      $rootElement.addClass("dx-label-h-align");
    }
    if ("dxCheckBox" === editorType || "dxSwitch" === editorType) {
      events_engine_default.on($label, CLICK_EVENT_NAME, () => {
        events_engine_default.trigger($fieldEditorContainer.children(), CLICK_EVENT_NAME);
      });
    }
    const toggleControls = ["dxCheckBox", "dxSwitch", "dxRadioGroup"];
    const isToggleControls = toggleControls.includes(editorType);
    const labelAlignment = labelOptions.alignment;
    const isLabelAlignmentLeft = "left" === labelAlignment || !labelAlignment;
    const hasNotTemplate = !template;
    const isLabelOnTop = "top" === labelLocation;
    if (hasNotTemplate && isToggleControls && isLabelOnTop && isLabelAlignmentLeft) {
      $fieldEditorContainer.addClass("dx-toggle-controls-paddings");
    }
  } else {
    $rootElement.append($fieldEditorContainer);
  }
  let widgetInstance;
  if (template) {
    template.render({
      container: getPublicElement($fieldEditorContainer),
      model: getTemplateData(item, editorOptions, formOrLayoutManager),
      onRendered() {
        const $validationTarget2 = getValidationTarget($fieldEditorContainer);
        const validationTargetInstance2 = tryGetValidationTargetInstance($validationTarget2);
        subscribeWrapperInvalidClassToggle(validationTargetInstance2);
      }
    });
  } else {
    const $div = renderer_default("<div>").appendTo($fieldEditorContainer);
    try {
      widgetInstance = createComponentCallback($div, item.editorType, editorOptions);
      widgetInstance.setAria("describedby", helpID);
      if (labelID) {
        widgetInstance.setAria("labelledby", labelID);
      }
      widgetInstance.setAria("required", isRequired);
    } catch (e) {
      ui_errors_default.log("E1035", e.message);
    }
  }
  const $validationTarget = getValidationTarget($fieldEditorContainer);
  const validationTargetInstance = $validationTarget && $validationTarget.data(VALIDATION_TARGET_CLASS);
  if (validationTargetInstance) {
    const isItemHaveCustomLabel = item.label && item.label.text;
    const itemName = isItemHaveCustomLabel ? null : name2;
    const fieldName = isItemHaveCustomLabel ? item.label.text : itemName && captionize(itemName);
    let validationRules;
    if (isSimpleItem) {
      if (item.validationRules) {
        validationRules = item.validationRules;
      } else {
        const requiredMessage = format(requiredMessageTemplate, fieldName || "");
        validationRules = item.isRequired ? [{
          type: "required",
          message: requiredMessage
        }] : null;
      }
    }
    if (Array.isArray(validationRules) && validationRules.length) {
      createComponentCallback($validationTarget, validator_default, {
        validationRules,
        validationGroup,
        dataGetter: () => ({
          formItem: item
        })
      });
    }
    subscribeWrapperInvalidClassToggle(validationTargetInstance);
  }
  if (helpText && isSimpleItem) {
    const $editorParent = $fieldEditorContainer.parent();
    $editorParent.append(renderer_default("<div>").addClass(FIELD_ITEM_CONTENT_WRAPPER_CLASS).append($fieldEditorContainer).append(renderer_default("<div>").addClass("dx-field-item-help-text").attr("id", helpID).text(helpText)));
  }
  return {
    $fieldEditorContainer,
    $rootElement,
    widgetInstance
  };
}
function getValidationTarget($fieldEditorContainer) {
  const $editor = $fieldEditorContainer.children().first();
  return $editor.hasClass(TEMPLATE_WRAPPER_CLASS) ? $editor.children().first() : $editor;
}
function tryGetValidationTargetInstance($validationTarget) {
  var _$validationTarget$pa;
  return (null === $validationTarget || void 0 === $validationTarget ? void 0 : $validationTarget.data(VALIDATION_TARGET_CLASS)) || (null === $validationTarget || void 0 === $validationTarget || null === (_$validationTarget$pa = $validationTarget.parent) || void 0 === _$validationTarget$pa || null === (_$validationTarget$pa = _$validationTarget$pa.call($validationTarget)) || void 0 === _$validationTarget$pa ? void 0 : _$validationTarget$pa.data(VALIDATION_TARGET_CLASS));
}
function subscribeWrapperInvalidClassToggle(validationTargetInstance) {
  if (validationTargetInstance && isMaterialBased()) {
    const wrapperClass = `.${FIELD_ITEM_CONTENT_WRAPPER_CLASS}`;
    const toggleInvalidClass = (_ref2) => {
      let {
        element,
        component
      } = _ref2;
      const {
        isValid,
        validationMessageMode
      } = component.option();
      renderer_default(element).parents(wrapperClass).toggleClass(INVALID_CLASS, false === isValid && (component._isFocused() || "always" === validationMessageMode));
    };
    validationTargetInstance.on("optionChanged", (e) => {
      if ("isValid" !== e.name) {
        return;
      }
      toggleInvalidClass(e);
    });
    validationTargetInstance.on("focusIn", toggleInvalidClass).on("focusOut", toggleInvalidClass).on("enterKey", toggleInvalidClass);
  }
}
function getTemplateData(item, editorOptions, formOrLayoutManager) {
  return {
    dataField: item.dataField,
    editorType: item.editorType,
    editorOptions,
    component: formOrLayoutManager,
    name: item.name
  };
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.items_runtime_info.js
var FormItemsRunTimeInfo = class {
  constructor() {
    this._map = {};
  }
  _findWidgetInstance(condition) {
    let result2;
    each(this._map, (guid2, _ref) => {
      let {
        widgetInstance,
        item
      } = _ref;
      if (condition(item)) {
        result2 = widgetInstance;
        return false;
      }
    });
    return result2;
  }
  _findFieldByCondition(callback, valueExpr) {
    let result2;
    each(this._map, (key, value2) => {
      if (callback(value2)) {
        result2 = "guid" === valueExpr ? key : value2[valueExpr];
        return false;
      }
    });
    return result2;
  }
  clear() {
    this._map = {};
  }
  removeItemsByItems(itemsRunTimeInfo) {
    each(itemsRunTimeInfo.getItems(), (guid2) => this.removeItemByKey(guid2));
  }
  removeItemByKey(key) {
    delete this._map[key];
  }
  add(options2) {
    const key = options2.guid || new guid_default();
    this._map[key] = options2;
    return key;
  }
  addItemsOrExtendFrom(itemsRunTimeInfo) {
    itemsRunTimeInfo.each((key, itemRunTimeInfo) => {
      if (this._map[key]) {
        if (itemRunTimeInfo.widgetInstance) {
          this._map[key].widgetInstance = itemRunTimeInfo.widgetInstance;
        }
        this._map[key].$itemContainer = itemRunTimeInfo.$itemContainer;
      } else {
        this.add({
          item: itemRunTimeInfo.item,
          widgetInstance: itemRunTimeInfo.widgetInstance,
          guid: key,
          $itemContainer: itemRunTimeInfo.$itemContainer
        });
      }
    });
  }
  extendRunTimeItemInfoByKey(key, options2) {
    if (this._map[key]) {
      this._map[key] = extend(this._map[key], options2);
    }
  }
  findWidgetInstanceByItem(item) {
    return this._findWidgetInstance((storedItem) => storedItem === item);
  }
  findGroupOrTabLayoutManagerByPath(targetPath) {
    return this._findFieldByCondition((_ref2) => {
      let {
        path
      } = _ref2;
      return path === targetPath;
    }, "layoutManager");
  }
  findKeyByPath(targetPath) {
    return this._findFieldByCondition((_ref3) => {
      let {
        path
      } = _ref3;
      return path === targetPath;
    }, "guid");
  }
  findWidgetInstanceByName(name2) {
    return this._findWidgetInstance((item) => name2 === item.name);
  }
  findWidgetInstanceByDataField(dataField) {
    return this._findWidgetInstance((item) => dataField === (isString(item) ? item : item.dataField));
  }
  findItemContainerByItem(item) {
    for (const key in this._map) {
      if (this._map[key].item === item) {
        return this._map[key].$itemContainer;
      }
    }
    return null;
  }
  findItemIndexByItem(targetItem) {
    return this._findFieldByCondition((_ref4) => {
      let {
        item
      } = _ref4;
      return item === targetItem;
    }, "itemIndex");
  }
  findPreparedItemByItem(item) {
    return this._findFieldByCondition((_ref5) => {
      let {
        item: currentItem
      } = _ref5;
      return currentItem === item;
    }, "preparedItem");
  }
  getItems() {
    return this._map;
  }
  each(handler) {
    each(this._map, (key, itemRunTimeInfo) => {
      handler(key, itemRunTimeInfo);
    });
  }
  removeItemsByPathStartWith(path) {
    const keys = Object.keys(this._map);
    const filteredKeys = keys.filter((key) => {
      if (this._map[key].path) {
        return this._map[key].path.indexOf(path, 0) > -1;
      }
      return false;
    });
    filteredKeys.forEach((key) => this.removeItemByKey(key));
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.layout_manager.js
var LayoutManager = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      layoutData: {},
      readOnly: false,
      colCount: 1,
      colCountByScreen: void 0,
      labelLocation: "left",
      onFieldDataChanged: null,
      onEditorEnterKey: null,
      customizeItem: null,
      alignItemLabels: true,
      minColWidth: 200,
      showRequiredMark: true,
      screenByWidth: null,
      showOptionalMark: false,
      requiredMark: "*",
      labelMode: "outside",
      optionalMark: message_default.format("dxForm-optionalMark"),
      requiredMessage: message_default.getFormatter("dxForm-requiredMessage")
    });
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      layoutData: true,
      validationGroup: true
    });
  },
  _init() {
    const layoutData = this.option("layoutData");
    this.callBase();
    this._itemWatchers = [];
    this._itemsRunTimeInfo = new FormItemsRunTimeInfo();
    this._updateReferencedOptions(layoutData);
    this._initDataAndItems(layoutData);
  },
  _dispose() {
    this.callBase();
    this._cleanItemWatchers();
  },
  _initDataAndItems(initialData) {
    this._syncDataWithItems();
    this._updateItems(initialData);
  },
  _syncDataWithItems() {
    const layoutData = this.option("layoutData");
    const userItems = this.option("items");
    if (isDefined(userItems)) {
      userItems.forEach((item) => {
        if (item.dataField && void 0 === this._getDataByField(item.dataField)) {
          let value2;
          if (item.editorOptions) {
            value2 = item.editorOptions.value;
          }
          if (isDefined(value2) || item.dataField in layoutData) {
            this._updateFieldValue(item.dataField, value2);
          }
        }
      });
    }
  },
  _getDataByField(dataField) {
    return dataField ? this.option(`layoutData.${dataField}`) : null;
  },
  _isCheckboxUndefinedStateEnabled(_ref) {
    let {
      allowIndeterminateState,
      editorType,
      dataField
    } = _ref;
    if (true === allowIndeterminateState && "dxCheckBox" === editorType) {
      const nameParts = ["layoutData", ...dataField.split(".")];
      const propertyName = nameParts.pop();
      const layoutData = this.option(nameParts.join("."));
      return layoutData && propertyName in layoutData;
    }
    return false;
  },
  _updateFieldValue(dataField, value2) {
    const layoutData = this.option("layoutData");
    let newValue = value2;
    if (!variable_wrapper_default.isWrapped(layoutData[dataField]) && isDefined(dataField)) {
      this.option(`layoutData.${dataField}`, newValue);
    } else if (variable_wrapper_default.isWritableWrapped(layoutData[dataField])) {
      newValue = isFunction(newValue) ? newValue() : newValue;
      layoutData[dataField](newValue);
    }
    this._triggerOnFieldDataChanged({
      dataField,
      value: newValue
    });
  },
  _triggerOnFieldDataChanged(args) {
    this._createActionByOption("onFieldDataChanged")(args);
  },
  _updateItems(layoutData) {
    const that = this;
    const userItems = this.option("items");
    const isUserItemsExist = isDefined(userItems);
    const customizeItem = that.option("customizeItem");
    const items = isUserItemsExist ? userItems : this._generateItemsByData(layoutData);
    if (isDefined(items)) {
      const processedItems = [];
      each(items, (index2, item) => {
        if (that._isAcceptableItem(item)) {
          item = that._processItem(item);
          customizeItem && customizeItem(item);
          if (isObject(item) && false !== variable_wrapper_default.unwrap(item.visible)) {
            processedItems.push(item);
          }
        }
      });
      if (!that._itemWatchers.length || !isUserItemsExist) {
        that._updateItemWatchers(items);
      }
      this._setItems(processedItems);
      this._sortItems();
    }
  },
  _cleanItemWatchers() {
    this._itemWatchers.forEach((dispose) => {
      dispose();
    });
    this._itemWatchers = [];
  },
  _updateItemWatchers(items) {
    const that = this;
    const watch = that._getWatch();
    items.forEach((item) => {
      if (isObject(item) && isDefined(item.visible) && isFunction(watch)) {
        that._itemWatchers.push(watch(() => variable_wrapper_default.unwrap(item.visible), () => {
          that._updateItems(that.option("layoutData"));
          that.repaint();
        }, {
          skipImmediate: true
        }));
      }
    });
  },
  _generateItemsByData(layoutData) {
    const result2 = [];
    if (isDefined(layoutData)) {
      each(layoutData, (dataField) => {
        result2.push({
          dataField
        });
      });
    }
    return result2;
  },
  _isAcceptableItem(item) {
    const itemField = item.dataField || item;
    const itemData = this._getDataByField(itemField);
    return !(isFunction(itemData) && !variable_wrapper_default.isWrapped(itemData));
  },
  _processItem(item) {
    if ("string" === typeof item) {
      item = {
        dataField: item
      };
    }
    if ("object" === typeof item && !item.itemType) {
      item.itemType = SIMPLE_ITEM_TYPE;
    }
    if (!isDefined(item.editorType) && isDefined(item.dataField)) {
      const value2 = this._getDataByField(item.dataField);
      item.editorType = isDefined(value2) ? this._getEditorTypeByDataType(type(value2)) : "dxTextBox";
    }
    if ("dxCheckBox" === item.editorType) {
      item.allowIndeterminateState = item.allowIndeterminateState ?? true;
    }
    return item;
  },
  _getEditorTypeByDataType(dataType) {
    switch (dataType) {
      case "number":
        return "dxNumberBox";
      case "date":
        return "dxDateBox";
      case "boolean":
        return "dxCheckBox";
      default:
        return "dxTextBox";
    }
  },
  _sortItems() {
    normalizeIndexes(this._items, "visibleIndex");
    this._sortIndexes();
  },
  _sortIndexes() {
    this._items.sort((itemA, itemB) => {
      const indexA = itemA.visibleIndex;
      const indexB = itemB.visibleIndex;
      let result2;
      if (indexA > indexB) {
        result2 = 1;
      } else if (indexA < indexB) {
        result2 = -1;
      } else {
        result2 = 0;
      }
      return result2;
    });
  },
  _initMarkup() {
    this._itemsRunTimeInfo.clear();
    this.$element().addClass(FORM_LAYOUT_MANAGER_CLASS);
    this.callBase();
    this._renderResponsiveBox();
  },
  _renderResponsiveBox() {
    const that = this;
    const templatesInfo = [];
    if (that._items && that._items.length) {
      const colCount = that._getColCount();
      const $container = renderer_default("<div>").appendTo(that.$element());
      that._prepareItemsWithMerging(colCount);
      const layoutItems = that._generateLayoutItems();
      that._responsiveBox = that._createComponent($container, responsive_box_default, that._getResponsiveBoxConfig(layoutItems, colCount, templatesInfo));
      if (!hasWindow()) {
        that._renderTemplates(templatesInfo);
      }
    }
  },
  _itemStateChangedHandler(e) {
    this._refresh();
  },
  _renderTemplates(templatesInfo) {
    const that = this;
    let itemsWithLabelTemplateCount = 0;
    templatesInfo.forEach((_ref2) => {
      var _item$label;
      let {
        item
      } = _ref2;
      if (null !== item && void 0 !== item && null !== (_item$label = item.label) && void 0 !== _item$label && _item$label.template) {
        itemsWithLabelTemplateCount++;
      }
    });
    each(templatesInfo, (index2, info) => {
      switch (info.itemType) {
        case "empty":
          renderEmptyItem(info);
          break;
        case "button":
          that._renderButtonItem(info);
          break;
        default:
          that._renderFieldItem(info, itemsWithLabelTemplateCount);
      }
    });
  },
  _getResponsiveBoxConfig(layoutItems, colCount, templatesInfo) {
    const that = this;
    const colCountByScreen = that.option("colCountByScreen");
    const xsColCount = colCountByScreen && colCountByScreen.xs;
    return {
      onItemStateChanged: this._itemStateChangedHandler.bind(this),
      onLayoutChanged() {
        const onLayoutChanged = that.option("onLayoutChanged");
        const isSingleColumnMode = that.isSingleColumnMode();
        if (onLayoutChanged) {
          that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, isSingleColumnMode);
          onLayoutChanged(isSingleColumnMode);
        }
      },
      onContentReady(e) {
        if (hasWindow()) {
          that._renderTemplates(templatesInfo);
        }
        if (that.option("onLayoutChanged")) {
          that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, that.isSingleColumnMode(e.component));
        }
      },
      itemTemplate(e, itemData, itemElement) {
        if (!e.location) {
          return;
        }
        const $itemElement = renderer_default(itemElement);
        const itemRenderedCountInPreviousRows = e.location.row * colCount;
        const item = that._items[e.location.col + itemRenderedCountInPreviousRows];
        if (!item) {
          return;
        }
        const itemCssClassList = [item.cssClass];
        $itemElement.toggleClass(SINGLE_COLUMN_ITEM_CONTENT, that.isSingleColumnMode(this));
        if (0 === e.location.row) {
          itemCssClassList.push("dx-first-row");
        }
        if (0 === e.location.col) {
          itemCssClassList.push("dx-first-col");
        }
        if (item.itemType === SIMPLE_ITEM_TYPE && that.option("isRoot")) {
          $itemElement.addClass(ROOT_SIMPLE_ITEM_CLASS);
        }
        const isLastColumn = e.location.col === colCount - 1 || e.location.col + e.location.colspan === colCount;
        const rowsCount = that._getRowsCount();
        const isLastRow = e.location.row === rowsCount - 1;
        if (isLastColumn) {
          itemCssClassList.push("dx-last-col");
        }
        if (isLastRow) {
          itemCssClassList.push("dx-last-row");
        }
        if ("empty" !== item.itemType) {
          itemCssClassList.push(FIELD_ITEM_CLASS);
          itemCssClassList.push(that.option("cssItemClass"));
          if (isDefined(item.col)) {
            itemCssClassList.push(`dx-col-${item.col}`);
          }
        }
        templatesInfo.push({
          itemType: item.itemType,
          item,
          $parent: $itemElement,
          rootElementCssClassList: itemCssClassList
        });
      },
      cols: that._generateRatio(colCount),
      rows: that._generateRatio(that._getRowsCount(), true),
      dataSource: layoutItems,
      screenByWidth: that.option("screenByWidth"),
      singleColumnScreen: xsColCount ? false : "xs"
    };
  },
  _getColCount() {
    let colCount = this.option("colCount");
    const colCountByScreen = this.option("colCountByScreen");
    if (colCountByScreen) {
      let screenFactor = this.option("form").getTargetScreenFactor();
      if (!screenFactor) {
        screenFactor = hasWindow() ? getCurrentScreenFactor(this.option("screenByWidth")) : "lg";
      }
      colCount = colCountByScreen[screenFactor] || colCount;
    }
    if ("auto" === colCount) {
      if (this._cashedColCount) {
        return this._cashedColCount;
      }
      this._cashedColCount = colCount = this._getMaxColCount();
    }
    return colCount < 1 ? 1 : colCount;
  },
  _getMaxColCount() {
    if (!hasWindow()) {
      return 1;
    }
    const minColWidth = this.option("minColWidth");
    const width = getWidth(this.$element());
    const itemsCount = this._items.length;
    const maxColCount = Math.floor(width / minColWidth) || 1;
    return itemsCount < maxColCount ? itemsCount : maxColCount;
  },
  isCachedColCountObsolete() {
    return this._cashedColCount && this._getMaxColCount() !== this._cashedColCount;
  },
  _prepareItemsWithMerging(colCount) {
    const items = this._items.slice(0);
    let item;
    let itemsMergedByCol;
    let result2 = [];
    let j;
    let i;
    for (i = 0; i < items.length; i++) {
      item = items[i];
      result2.push(item);
      if (this.option("alignItemLabels") || item.alignItemLabels || item.colSpan) {
        item.col = this._getColByIndex(result2.length - 1, colCount);
      }
      if (item.colSpan > 1 && item.col + item.colSpan <= colCount) {
        itemsMergedByCol = [];
        for (j = 0; j < item.colSpan - 1; j++) {
          itemsMergedByCol.push({
            merged: true
          });
        }
        result2 = result2.concat(itemsMergedByCol);
      } else {
        delete item.colSpan;
      }
    }
    this._setItems(result2);
  },
  _getColByIndex: (index2, colCount) => index2 % colCount,
  _setItems(items) {
    this._items = items;
    this._cashedColCount = null;
  },
  _generateLayoutItems() {
    const items = this._items;
    const colCount = this._getColCount();
    const result2 = [];
    let item;
    let i;
    for (i = 0; i < items.length; i++) {
      item = items[i];
      if (!item.merged) {
        const generatedItem = {
          location: {
            row: parseInt(i / colCount),
            col: this._getColByIndex(i, colCount)
          }
        };
        if (isDefined(item.disabled)) {
          generatedItem.disabled = item.disabled;
        }
        if (isDefined(item.visible)) {
          generatedItem.visible = item.visible;
        }
        if (isDefined(item.colSpan)) {
          generatedItem.location.colspan = item.colSpan;
        }
        if (isDefined(item.rowSpan)) {
          generatedItem.location.rowspan = item.rowSpan;
        }
        result2.push(generatedItem);
      }
    }
    return result2;
  },
  _renderEmptyItem($container) {
    renderEmptyItem({
      $container
    });
  },
  _renderButtonItem(_ref3) {
    let {
      item,
      $parent,
      rootElementCssClassList
    } = _ref3;
    const {
      $rootElement,
      buttonInstance
    } = renderButtonItem({
      item,
      $parent,
      rootElementCssClassList,
      validationGroup: this.option("validationGroup"),
      createComponentCallback: this._createComponent.bind(this)
    });
    this._itemsRunTimeInfo.add({
      item,
      widgetInstance: buttonInstance,
      guid: item.guid,
      $itemContainer: $rootElement
    });
  },
  _renderFieldItem(_ref4, itemsWithLabelTemplateCount) {
    var _item$label2, _this$option;
    let {
      item,
      $parent,
      rootElementCssClassList
    } = _ref4;
    const editorValue = this._getDataByField(item.dataField);
    let canAssignUndefinedValueToEditor = false;
    if (void 0 === editorValue) {
      const {
        allowIndeterminateState,
        editorType,
        dataField
      } = item;
      canAssignUndefinedValueToEditor = this._isCheckboxUndefinedStateEnabled({
        allowIndeterminateState,
        editorType,
        dataField
      });
    }
    const name2 = item.dataField || item.name;
    const formOrLayoutManager = this._getFormOrThis();
    const {
      $fieldEditorContainer,
      widgetInstance,
      $rootElement
    } = renderFieldItem(convertToRenderFieldItemOptions({
      $parent,
      rootElementCssClassList,
      item,
      name: name2,
      editorValue,
      canAssignUndefinedValueToEditor,
      formOrLayoutManager: this._getFormOrThis(),
      createComponentCallback: this._createComponent.bind(this),
      formLabelLocation: this.option("labelLocation"),
      requiredMessageTemplate: this.option("requiredMessage"),
      validationGroup: this.option("validationGroup"),
      editorValidationBoundary: this.option("validationBoundary"),
      editorStylingMode: this.option("form") && this.option("form").option("stylingMode"),
      showColonAfterLabel: this.option("showColonAfterLabel"),
      managerLabelLocation: this.option("labelLocation"),
      template: item.template ? this._getTemplate(item.template) : null,
      labelTemplate: null !== (_item$label2 = item.label) && void 0 !== _item$label2 && _item$label2.template ? this._getTemplate(item.label.template) : null,
      itemId: this.option("form") && this.option("form").getItemID(name2),
      managerMarkOptions: this._getMarkOptions(),
      labelMode: this.option("labelMode"),
      onLabelTemplateRendered: () => {
        this._incTemplateRenderedCallCount();
        if (this._shouldAlignLabelsOnTemplateRendered(formOrLayoutManager, itemsWithLabelTemplateCount)) {
          formOrLayoutManager._alignLabels(this, this.isSingleColumnMode(formOrLayoutManager));
        }
      }
    }));
    null === (_this$option = this.option("onFieldItemRendered")) || void 0 === _this$option || _this$option();
    if (widgetInstance && item.dataField) {
      this._bindDataField(widgetInstance, item.dataField, item.editorType, $fieldEditorContainer);
    }
    this._itemsRunTimeInfo.add({
      item,
      widgetInstance,
      guid: item.guid,
      $itemContainer: $rootElement
    });
  },
  _incTemplateRenderedCallCount() {
    this._labelTemplateRenderedCallCount = (this._labelTemplateRenderedCallCount ?? 0) + 1;
  },
  _shouldAlignLabelsOnTemplateRendered(formOrLayoutManager, totalItemsWithLabelTemplate) {
    return formOrLayoutManager.option("templatesRenderAsynchronously") && this._labelTemplateRenderedCallCount === totalItemsWithLabelTemplate;
  },
  _getMarkOptions() {
    return {
      showRequiredMark: this.option("showRequiredMark"),
      requiredMark: this.option("requiredMark"),
      showOptionalMark: this.option("showOptionalMark"),
      optionalMark: this.option("optionalMark")
    };
  },
  _getFormOrThis() {
    return this.option("form") || this;
  },
  _bindDataField(editorInstance, dataField, editorType, $container) {
    const formOrThis = this._getFormOrThis();
    editorInstance.on("enterKey", (args) => {
      formOrThis._createActionByOption("onEditorEnterKey")(extend(args, {
        dataField
      }));
    });
    this._createWatcher(editorInstance, $container, dataField);
    this.linkEditorToDataField(editorInstance, dataField, editorType);
  },
  _createWatcher(editorInstance, $container, dataField) {
    const that = this;
    const watch = that._getWatch();
    if (!isFunction(watch)) {
      return;
    }
    const dispose = watch(() => that._getDataByField(dataField), () => {
      const fieldValue = that._getDataByField(dataField);
      if ("dxTagBox" === editorInstance.NAME) {
        const editorValue = editorInstance.option("value");
        if (fieldValue !== editorValue && function(array1, array2) {
          if (!Array.isArray(array1) || !Array.isArray(array2) || array1.length !== array2.length) {
            return false;
          }
          for (let i = 0; i < array1.length; i++) {
            if (array1[i] !== array2[i]) {
              return false;
            }
          }
          return true;
        }(fieldValue, editorValue)) {
          return;
        }
      }
      editorInstance.option("value", fieldValue);
    }, {
      deep: true,
      skipImmediate: true
    }, {
      createWatcherDataField: dataField
    });
    events_engine_default.on($container, removeEvent, dispose);
  },
  _getWatch() {
    if (!isDefined(this._watch)) {
      const formInstance = this.option("form");
      this._watch = formInstance && formInstance.option("integrationOptions.watchMethod");
    }
    return this._watch;
  },
  _createComponent($editor, type2, editorOptions) {
    const readOnlyState = this.option("readOnly");
    let hasEditorReadOnly = Object.hasOwn(editorOptions, "readOnly");
    const instance = this.callBase($editor, type2, _extends({}, editorOptions, {
      readOnly: !hasEditorReadOnly ? readOnlyState : editorOptions.readOnly
    }));
    let isChangeByForm = false;
    instance.on("optionChanged", (args) => {
      if ("readOnly" === args.name && !isChangeByForm) {
        hasEditorReadOnly = true;
      }
    });
    this.on("optionChanged", (args) => {
      if ("readOnly" === args.name && !hasEditorReadOnly) {
        isChangeByForm = true;
        instance.option(args.name, args.value);
        isChangeByForm = false;
      }
    });
    return instance;
  },
  _generateRatio(count, isAutoSize) {
    const result2 = [];
    let ratio;
    let i;
    for (i = 0; i < count; i++) {
      ratio = {
        ratio: 1
      };
      if (isAutoSize) {
        ratio.baseSize = "auto";
      }
      result2.push(ratio);
    }
    return result2;
  },
  _getRowsCount() {
    return Math.ceil(this._items.length / this._getColCount());
  },
  _updateReferencedOptions(newLayoutData) {
    const layoutData = this.option("layoutData");
    if (isObject(layoutData)) {
      Object.getOwnPropertyNames(layoutData).forEach((property) => delete this._optionsByReference[`layoutData.${property}`]);
    }
    if (isObject(newLayoutData)) {
      Object.getOwnPropertyNames(newLayoutData).forEach((property) => this._optionsByReference[`layoutData.${property}`] = true);
    }
  },
  _clearWidget(instance) {
    this._disableEditorValueChangedHandler = true;
    instance.clear();
    this._disableEditorValueChangedHandler = false;
    instance.option("isValid", true);
  },
  _optionChanged(args) {
    if (0 === args.fullName.search("layoutData.")) {
      return;
    }
    switch (args.name) {
      case "showRequiredMark":
      case "showOptionalMark":
      case "requiredMark":
      case "optionalMark":
        this._cashedRequiredConfig = null;
        this._invalidate();
        break;
      case "layoutData":
        this._updateReferencedOptions(args.value);
        if (this.option("items")) {
          if (!isEmptyObject(args.value)) {
            this._itemsRunTimeInfo.each((_, itemRunTimeInfo) => {
              if (isDefined(itemRunTimeInfo.item)) {
                const {
                  dataField
                } = itemRunTimeInfo.item;
                if (dataField && isDefined(itemRunTimeInfo.widgetInstance)) {
                  const valueGetter = compileGetter(dataField);
                  const dataValue = valueGetter(args.value);
                  const {
                    allowIndeterminateState,
                    editorType
                  } = itemRunTimeInfo.item;
                  if (void 0 !== dataValue || this._isCheckboxUndefinedStateEnabled({
                    allowIndeterminateState,
                    editorType,
                    dataField
                  })) {
                    itemRunTimeInfo.widgetInstance.option("value", dataValue);
                  } else {
                    this._clearWidget(itemRunTimeInfo.widgetInstance);
                  }
                }
              }
            });
          }
        } else {
          this._initDataAndItems(args.value);
          this._invalidate();
        }
        break;
      case "items":
        this._cleanItemWatchers();
        this._initDataAndItems(args.value);
        this._invalidate();
        break;
      case "alignItemLabels":
      case "labelLocation":
      case "labelMode":
      case "requiredMessage":
        this._invalidate();
        break;
      case "customizeItem":
        this._updateItems(this.option("layoutData"));
        this._invalidate();
        break;
      case "colCount":
      case "colCountByScreen":
        this._resetColCount();
        break;
      case "minColWidth":
        if ("auto" === this.option("colCount")) {
          this._resetColCount();
        }
        break;
      case "readOnly":
      case "onFieldDataChanged":
        break;
      case "width":
        this.callBase(args);
        if ("auto" === this.option("colCount")) {
          this._resetColCount();
        }
        break;
      default:
        this.callBase(args);
    }
  },
  _resetColCount() {
    this._cashedColCount = null;
    this._invalidate();
  },
  linkEditorToDataField(editorInstance, dataField) {
    this.on("optionChanged", (args) => {
      if (args.fullName === `layoutData.${dataField}`) {
        editorInstance._setOptionWithoutOptionChange("value", args.value);
      }
    });
    editorInstance.on("valueChanged", (args) => {
      const isValueReferenceType = isObject(args.value) || Array.isArray(args.value);
      if (!this._disableEditorValueChangedHandler && !(isValueReferenceType && args.value === args.previousValue)) {
        this._updateFieldValue(dataField, args.value);
      }
    });
  },
  _dimensionChanged() {
    if ("auto" === this.option("colCount") && this.isCachedColCountObsolete()) {
      this._eventsStrategy.fireEvent("autoColCountChanged");
    }
  },
  updateData(data2, value2) {
    const that = this;
    if (isObject(data2)) {
      each(data2, (dataField, fieldValue) => {
        that._updateFieldValue(dataField, fieldValue);
      });
    } else if ("string" === typeof data2) {
      that._updateFieldValue(data2, value2);
    }
  },
  getEditor(field) {
    return this._itemsRunTimeInfo.findWidgetInstanceByDataField(field) || this._itemsRunTimeInfo.findWidgetInstanceByName(field);
  },
  isSingleColumnMode(component) {
    const responsiveBox = this._responsiveBox || component;
    if (responsiveBox) {
      return responsiveBox.option("currentScreenFactor") === responsiveBox.option("singleColumnScreen");
    }
  },
  getItemsRunTimeInfo() {
    return this._itemsRunTimeInfo;
  }
});
component_registrator_default("dxLayoutManager", LayoutManager);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_validation_summary.js
var ITEM_CLASS2 = "dx-validationsummary-item";
var ITEM_DATA_KEY = "dx-validationsummary-item-data";
var ValidationSummary = ui_collection_widget_edit_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      focusStateEnabled: false,
      noDataText: null
    });
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      validationGroup: true
    });
  },
  _init() {
    this.callBase();
    this._initGroupRegistration();
  },
  _initGroupRegistration() {
    const $element = this.$element();
    const group = this.option("validationGroup") || m_validation_engine_default.findGroup($element, this._modelByElement($element));
    const groupConfig = m_validation_engine_default.addGroup(group, true);
    this._unsubscribeGroup();
    this._groupWasInit = true;
    this._validationGroup = group;
    this.groupSubscription = this._groupValidationHandler.bind(this);
    groupConfig.on("validated", this.groupSubscription);
  },
  _unsubscribeGroup() {
    const groupConfig = m_validation_engine_default.getGroupConfig(this._validationGroup);
    groupConfig && groupConfig.off("validated", this.groupSubscription);
  },
  _getOrderedItems(validators, items) {
    let orderedItems = [];
    each(validators, (_, validator) => {
      const foundItems = grep(items, (item) => {
        if (item.validator === validator) {
          return true;
        }
      });
      if (foundItems.length) {
        orderedItems = orderedItems.concat(foundItems);
      }
    });
    return orderedItems;
  },
  _groupValidationHandler(params) {
    const items = this._getOrderedItems(params.validators, map(params.brokenRules, (rule) => ({
      text: rule.message,
      validator: rule.validator,
      index: rule.index
    })));
    this.validators = params.validators;
    each(this.validators, (_, validator) => {
      if (validator._validationSummary !== this) {
        let handler = this._itemValidationHandler.bind(this);
        const disposingHandler = function() {
          validator.off("validated", handler);
          validator._validationSummary = null;
          handler = null;
        };
        validator.on("validated", handler);
        validator.on("disposing", disposingHandler);
        validator._validationSummary = this;
      }
    });
    this.option("items", items);
  },
  _itemValidationHandler(_ref) {
    let {
      isValid,
      validator,
      brokenRules
    } = _ref;
    let items = this.option("items");
    let itemsChanged = false;
    let itemIndex = 0;
    while (itemIndex < items.length) {
      const item = items[itemIndex];
      if (item.validator === validator) {
        const foundRule = grep(brokenRules || [], (rule) => rule.index === item.index)[0];
        if (isValid || !foundRule) {
          items.splice(itemIndex, 1);
          itemsChanged = true;
          continue;
        }
        if (foundRule.message !== item.text) {
          item.text = foundRule.message;
          itemsChanged = true;
        }
      }
      itemIndex++;
    }
    each(brokenRules, (_, rule) => {
      const foundItem = grep(items, (item) => item.validator === validator && item.index === rule.index)[0];
      if (!foundItem) {
        items.push({
          text: rule.message,
          validator,
          index: rule.index
        });
        itemsChanged = true;
      }
    });
    if (itemsChanged) {
      items = this._getOrderedItems(this.validators, items);
      this.option("items", items);
    }
  },
  _initMarkup() {
    this.$element().addClass("dx-validationsummary");
    this.callBase();
  },
  _optionChanged(args) {
    if ("validationGroup" === args.name) {
      this._initGroupRegistration();
    } else {
      this.callBase(args);
    }
  },
  _itemClass: () => ITEM_CLASS2,
  _itemDataKey: () => ITEM_DATA_KEY,
  _postprocessRenderItem(params) {
    events_engine_default.on(params.itemElement, "click", () => {
      params.itemData.validator && params.itemData.validator.focus && params.itemData.validator.focus();
    });
  },
  _dispose() {
    this.callBase();
    this._unsubscribeGroup();
  },
  refreshValidationGroup() {
    this._initGroupRegistration();
  }
});
component_registrator_default("dxValidationSummary", ValidationSummary);
var m_validation_summary_default = ValidationSummary;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_validation_group.js
var ValidationGroup = class extends dom_component_default {
  _getDefaultOptions() {
    return super._getDefaultOptions();
  }
  _init() {
    super._init();
    m_validation_engine_default.addGroup(this, false);
  }
  _initMarkup() {
    const $element = this.$element();
    $element.addClass("dx-validationgroup");
    $element.find(".dx-validator").each((_, validatorContainer) => {
      m_validator_default.getInstance(renderer_default(validatorContainer))._initGroupRegistration();
    });
    $element.find(".dx-validationsummary").each((_, summaryContainer) => {
      m_validation_summary_default.getInstance(renderer_default(summaryContainer)).refreshValidationGroup();
    });
    super._initMarkup();
  }
  validate() {
    return m_validation_engine_default.validateGroup(this);
  }
  reset() {
    return m_validation_engine_default.resetGroup(this);
  }
  _dispose() {
    m_validation_engine_default.removeGroup(this);
    this.$element().removeClass("dx-validationgroup");
    super._dispose();
  }
  _useTemplates() {
    return false;
  }
};
component_registrator_default("dxValidationGroup", ValidationGroup);

// ../../../../../../node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.js
var ui_scrollable_default = m_scrollable_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/multi_view/m_multi_view.animation.js
var _translator = {
  move($element, position3) {
    move($element, {
      left: position3
    });
  }
};
var animation2 = {
  moveTo($element, position3, duration, completeAction) {
    fx_default.animate($element, {
      type: "slide",
      to: {
        left: position3
      },
      duration,
      complete: completeAction
    });
  },
  complete($element) {
    fx_default.stop($element, true);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_multi_view.js
var toNumber2 = (value2) => +value2;
var position2 = ($element) => locate($element).left;
var MultiView = ui_collection_widget_live_update_default.inherit({
  _activeStateUnit: ".dx-multiview-item",
  _supportedKeys() {
    return extend(this.callBase(), {
      pageUp: noop2,
      pageDown: noop2
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      selectedIndex: 0,
      swipeEnabled: true,
      animationEnabled: true,
      loop: false,
      deferRendering: true,
      loopItemFocus: false,
      selectOnFocus: true,
      selectionMode: "single",
      selectionRequired: true,
      selectByClick: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  },
  _itemClass: () => "dx-multiview-item",
  _itemDataKey: () => "dxMultiViewItemData",
  _itemContainer() {
    return this._$itemContainer;
  },
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  },
  _itemWidth() {
    if (!this._itemWidthValue) {
      this._itemWidthValue = getWidth(this._$wrapper);
    }
    return this._itemWidthValue;
  },
  _clearItemWidthCache() {
    delete this._itemWidthValue;
  },
  _itemsCount() {
    return this.option("items").length;
  },
  _normalizeIndex(index2) {
    const count = this._itemsCount();
    if (index2 < 0) {
      index2 += count;
    }
    if (index2 >= count) {
      index2 -= count;
    }
    return index2;
  },
  _getRTLSignCorrection() {
    return this.option("rtlEnabled") ? -1 : 1;
  },
  _init() {
    this.callBase.apply(this, arguments);
    const $element = this.$element();
    $element.addClass("dx-multiview");
    this._$wrapper = renderer_default("<div>").addClass("dx-multiview-wrapper");
    this._$wrapper.appendTo($element);
    this._$itemContainer = renderer_default("<div>").addClass("dx-multiview-item-container");
    this._$itemContainer.appendTo(this._$wrapper);
    this.option("loopItemFocus", this.option("loop"));
    this._findBoundaryIndices();
    this._initSwipeable();
  },
  _initMarkup() {
    this._deferredItems = [];
    this.callBase();
    const selectedItemIndices = this._getSelectedItemIndices();
    this._updateItemsVisibility(selectedItemIndices[0]);
    this._setElementAria();
    this._setItemsAria();
  },
  _afterItemElementDeleted($item, deletedActionArgs) {
    this.callBase($item, deletedActionArgs);
    if (this._deferredItems) {
      this._deferredItems.splice(deletedActionArgs.itemIndex, 1);
    }
  },
  _beforeItemElementInserted(change) {
    this.callBase.apply(this, arguments);
    if (this._deferredItems) {
      this._deferredItems.splice(change.index, 0, null);
    }
  },
  _executeItemRenderAction(index2, itemData, itemElement) {
    index2 = (this.option("items") || []).indexOf(itemData);
    this.callBase(index2, itemData, itemElement);
  },
  _renderItemContent(args) {
    const renderContentDeferred = Deferred();
    const that = this;
    const {
      callBase
    } = this;
    const deferred = Deferred();
    deferred.done(() => {
      const $itemContent = callBase.call(that, args);
      renderContentDeferred.resolve($itemContent);
    });
    this._deferredItems[args.index] = deferred;
    this.option("deferRendering") || deferred.resolve();
    return renderContentDeferred.promise();
  },
  _render() {
    this.callBase();
    deferRender(() => {
      const selectedItemIndices = this._getSelectedItemIndices();
      this._updateItems(selectedItemIndices[0]);
    });
  },
  _getElementAria: () => ({
    role: "group",
    roledescription: message_default.format("dxMultiView-elementAriaRoleDescription"),
    label: message_default.format("dxMultiView-elementAriaLabel")
  }),
  _setElementAria() {
    const aria = this._getElementAria();
    this.setAria(aria, this.$element());
  },
  _setItemsAria() {
    const $itemElements = this._itemElements();
    const itemsCount = this._itemsCount();
    $itemElements.each((itemIndex, item) => {
      const aria = this._getItemAria({
        itemIndex,
        itemsCount
      });
      this.setAria(aria, renderer_default(item));
    });
  },
  _getItemAria(_ref) {
    let {
      itemIndex,
      itemsCount
    } = _ref;
    const aria = {
      role: "group",
      roledescription: message_default.format("dxMultiView-itemAriaRoleDescription"),
      label: message_default.format("dxMultiView-itemAriaLabel", itemIndex + 1, itemsCount)
    };
    return aria;
  },
  _updateItems(selectedIndex, newIndex) {
    this._updateItemsPosition(selectedIndex, newIndex);
    this._updateItemsVisibility(selectedIndex, newIndex);
  },
  _modifyByChanges() {
    this.callBase.apply(this, arguments);
    const selectedItemIndices = this._getSelectedItemIndices();
    this._updateItemsVisibility(selectedItemIndices[0]);
  },
  _updateItemsPosition(selectedIndex, newIndex) {
    const $itemElements = this._itemElements();
    const positionSign = isDefined(newIndex) ? -this._animationDirection(newIndex, selectedIndex) : void 0;
    const $selectedItem = $itemElements.eq(selectedIndex);
    _translator.move($selectedItem, 0);
    if (isDefined(newIndex)) {
      _translator.move($itemElements.eq(newIndex), 100 * positionSign + "%");
    }
  },
  _updateItemsVisibility(selectedIndex, newIndex) {
    const $itemElements = this._itemElements();
    $itemElements.each((itemIndex, item) => {
      const $item = renderer_default(item);
      const isHidden = itemIndex !== selectedIndex && itemIndex !== newIndex;
      if (!isHidden) {
        this._renderSpecificItem(itemIndex);
      }
      $item.toggleClass("dx-multiview-item-hidden", isHidden);
      this.setAria("hidden", isHidden || void 0, $item);
    });
  },
  _renderSpecificItem(index2) {
    const $item = this._itemElements().eq(index2);
    const hasItemContent = $item.find(this._itemContentClass()).length > 0;
    if (isDefined(index2) && !hasItemContent) {
      this._deferredItems[index2].resolve();
      triggerResizeEvent($item);
    }
  },
  _refreshItem($item, item) {
    this.callBase($item, item);
    this._updateItemsVisibility(this.option("selectedIndex"));
  },
  _setAriaSelectionAttribute: noop2,
  _updateSelection(addedSelection, removedSelection) {
    const newIndex = addedSelection[0];
    const prevIndex = removedSelection[0];
    animation2.complete(this._$itemContainer);
    this._updateItems(prevIndex, newIndex);
    const animationDirection = this._animationDirection(newIndex, prevIndex);
    this._animateItemContainer(animationDirection * this._itemWidth(), () => {
      _translator.move(this._$itemContainer, 0);
      this._updateItems(newIndex);
      getWidth(this._$itemContainer);
    });
  },
  _animateItemContainer(position3, completeCallback) {
    const duration = this.option("animationEnabled") ? 200 : 0;
    animation2.moveTo(this._$itemContainer, position3, duration, completeCallback);
  },
  _animationDirection(newIndex, prevIndex) {
    const containerPosition = position2(this._$itemContainer);
    const indexDifference = (prevIndex - newIndex) * this._getRTLSignCorrection() * this._getItemFocusLoopSignCorrection();
    const isSwipePresent = 0 !== containerPosition;
    const directionSignVariable = isSwipePresent ? containerPosition : indexDifference;
    return sign(directionSignVariable);
  },
  _getSwipeDisabledState() {
    return !this.option("swipeEnabled") || this._itemsCount() <= 1;
  },
  _initSwipeable() {
    this._createComponent(this.$element(), swipeable_default, {
      disabled: this._getSwipeDisabledState(),
      elastic: false,
      itemSizeFunc: this._itemWidth.bind(this),
      onStart: (args) => this._swipeStartHandler(args.event),
      onUpdated: (args) => this._swipeUpdateHandler(args.event),
      onEnd: (args) => this._swipeEndHandler(args.event)
    });
  },
  _findBoundaryIndices() {
    const items = this.option("items");
    let firstIndex;
    let lastIndex;
    items.forEach((item, index2) => {
      const isDisabled = Boolean(null === item || void 0 === item ? void 0 : item.disabled);
      if (!isDisabled) {
        firstIndex ?? (firstIndex = index2);
        lastIndex = index2;
      }
    });
    this._boundaryIndices = {
      firstAvailableIndex: firstIndex ?? 0,
      lastAvailableIndex: lastIndex ?? items.length - 1,
      firstTrueIndex: 0,
      lastTrueIndex: items.length - 1
    };
  },
  _swipeStartHandler(e) {
    animation2.complete(this._$itemContainer);
    const selectedIndex = this.option("selectedIndex");
    const loop = this.option("loop");
    const {
      firstAvailableIndex,
      lastAvailableIndex
    } = this._boundaryIndices;
    const rtl = this.option("rtlEnabled");
    e.maxLeftOffset = toNumber2(loop || (rtl ? selectedIndex > firstAvailableIndex : selectedIndex < lastAvailableIndex));
    e.maxRightOffset = toNumber2(loop || (rtl ? selectedIndex < lastAvailableIndex : selectedIndex > firstAvailableIndex));
    this._swipeDirection = null;
  },
  _swipeUpdateHandler(e) {
    const {
      offset: offset2
    } = e;
    const swipeDirection = sign(offset2) * this._getRTLSignCorrection();
    _translator.move(this._$itemContainer, offset2 * this._itemWidth());
    if (swipeDirection !== this._swipeDirection) {
      this._swipeDirection = swipeDirection;
      const selectedIndex = this.option("selectedIndex");
      const newIndex = this._normalizeIndex(selectedIndex - swipeDirection);
      this._updateItems(selectedIndex, newIndex);
    }
  },
  _findNextAvailableIndex(index2, offset2) {
    const {
      items,
      loop
    } = this.option();
    const {
      firstAvailableIndex,
      lastAvailableIndex,
      firstTrueIndex,
      lastTrueIndex
    } = this._boundaryIndices;
    const isFirstActive = [firstTrueIndex, firstAvailableIndex].includes(index2);
    const isLastActive = [lastTrueIndex, lastAvailableIndex].includes(index2);
    if (loop) {
      if (isFirstActive && offset2 < 0) {
        return lastAvailableIndex;
      }
      if (isLastActive && offset2 > 0) {
        return firstAvailableIndex;
      }
    }
    for (let i = index2 + offset2; i >= firstAvailableIndex && i <= lastAvailableIndex; i += offset2) {
      const isDisabled = Boolean(items[i].disabled);
      if (!isDisabled) {
        return i;
      }
    }
    return index2;
  },
  _swipeEndHandler(e) {
    const targetOffset = e.targetOffset * this._getRTLSignCorrection();
    if (targetOffset) {
      const newSelectedIndex = this._findNextAvailableIndex(this.option("selectedIndex"), -targetOffset);
      this.option("selectedIndex", newSelectedIndex);
      const $selectedElement = this.itemElements().filter(".dx-item-selected");
      this.option("focusStateEnabled") && this.option("focusedElement", getPublicElement($selectedElement));
    } else {
      this._animateItemContainer(0, noop2);
    }
  },
  _getItemFocusLoopSignCorrection() {
    return this._itemFocusLooped ? -1 : 1;
  },
  _moveFocus() {
    this.callBase.apply(this, arguments);
    this._itemFocusLooped = false;
  },
  _prevItem($items) {
    const $result = this.callBase.apply(this, arguments);
    this._itemFocusLooped = $result.is($items.last());
    return $result;
  },
  _nextItem($items) {
    const $result = this.callBase.apply(this, arguments);
    this._itemFocusLooped = $result.is($items.first());
    return $result;
  },
  _dimensionChanged() {
    this._clearItemWidthCache();
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._dimensionChanged();
    }
  },
  _updateSwipeDisabledState() {
    const disabled = this._getSwipeDisabledState();
    swipeable_default.getInstance(this.$element()).option("disabled", disabled);
  },
  _dispose() {
    delete this._boundaryIndices;
    this.callBase();
  },
  _optionChanged(args) {
    const {
      value: value2
    } = args;
    switch (args.name) {
      case "loop":
        this.option("loopItemFocus", value2);
        break;
      case "animationEnabled":
        break;
      case "swipeEnabled":
        this._updateSwipeDisabledState();
        break;
      case "deferRendering":
        this._invalidate();
        break;
      case "items":
        this._updateSwipeDisabledState();
        this._findBoundaryIndices();
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxMultiView", MultiView);
var m_multi_view_default = MultiView;

// ../../../../../../node_modules/devextreme/esm/ui/multi_view.js
var multi_view_default = m_multi_view_default;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_scroll_left_max.js
function getScrollLeftMax(element) {
  return element.scrollWidth - element.clientWidth;
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_scroll_top_max.js
function getScrollTopMax(element) {
  return element.scrollHeight - element.clientHeight;
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_boundary_props.js
function isReachedLeft(scrollOffsetLeft, epsilon) {
  return Math.round(scrollOffsetLeft) <= epsilon;
}
function isReachedRight(element, scrollOffsetLeft, epsilon) {
  return Math.round(getScrollLeftMax(element) - scrollOffsetLeft) <= epsilon;
}
function isReachedTop(scrollOffsetTop, epsilon) {
  return Math.round(scrollOffsetTop) <= epsilon;
}
function isReachedBottom(element, scrollOffsetTop, pocketHeight, epsilon) {
  return Math.round(getScrollTopMax(element) - scrollOffsetTop - pocketHeight) <= epsilon;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tabs/constants.js
var TABS_EXPANDED_CLASS = "dx-tabs-expanded";

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tabs/m_item.js
var TabsItem = m_item_default.inherit({
  _renderWatchers() {
    this.callBase();
    this._startWatcher("badge", this._renderBadge.bind(this));
  },
  _renderBadge(badge) {
    this._$element.children(".dx-badge").remove();
    if (!badge) {
      return;
    }
    const $badge = renderer_default("<div>").addClass("dx-tabs-item-badge").addClass("dx-badge").text(badge);
    this._$element.append($badge);
  }
});
var m_item_default3 = TabsItem;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tabs/m_tabs.js
var TABS_ORIENTATION_CLASS = {
  vertical: "dx-tabs-vertical",
  horizontal: "dx-tabs-horizontal"
};
var INDICATOR_POSITION_CLASS = {
  top: "dx-tab-indicator-position-top",
  right: "dx-tab-indicator-position-right",
  bottom: "dx-tab-indicator-position-bottom",
  left: "dx-tab-indicator-position-left"
};
var TABS_ICON_POSITION_CLASS = {
  top: "dx-tabs-icon-position-top",
  end: "dx-tabs-icon-position-end",
  bottom: "dx-tabs-icon-position-bottom",
  start: "dx-tabs-icon-position-start"
};
var TABS_STYLING_MODE_CLASS = {
  primary: "dx-tabs-styling-mode-primary",
  secondary: "dx-tabs-styling-mode-secondary"
};
var ORIENTATION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var INDICATOR_POSITION = {
  top: "top",
  right: "right",
  bottom: "bottom",
  left: "left"
};
var SCROLLABLE_DIRECTION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var ICON_POSITION = {
  top: "top",
  end: "end",
  bottom: "bottom",
  start: "start"
};
var STYLING_MODE = {
  primary: "primary",
  secondary: "secondary"
};
var Tabs = ui_collection_widget_live_update_default.inherit({
  _activeStateUnit: ".dx-tab",
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      showNavButtons: true,
      scrollByContent: true,
      scrollingEnabled: true,
      selectionMode: "single",
      orientation: ORIENTATION.horizontal,
      iconPosition: ICON_POSITION.start,
      stylingMode: STYLING_MODE.primary,
      activeStateEnabled: true,
      selectionRequired: false,
      selectOnFocus: true,
      loopItemFocus: false,
      useInkRipple: false,
      badgeExpr: (data2) => data2 ? data2.badge : void 0,
      _itemAttributes: {
        role: "tab"
      },
      _indicatorPosition: null
    });
  },
  _defaultOptionsRules() {
    const themeName = current();
    return this.callBase().concat([{
      device: () => "desktop" !== devices_default.real().deviceType,
      options: {
        showNavButtons: false
      }
    }, {
      device: {
        deviceType: "desktop"
      },
      options: {
        scrollByContent: false
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isFluent(themeName),
      options: {
        iconPosition: ICON_POSITION.top,
        stylingMode: STYLING_MODE.secondary
      }
    }, {
      device: () => isMaterial(themeName),
      options: {
        useInkRipple: true,
        selectOnFocus: false,
        iconPosition: ICON_POSITION.top
      }
    }]);
  },
  _init() {
    const {
      orientation,
      stylingMode,
      scrollingEnabled
    } = this.option();
    const indicatorPosition = this._getIndicatorPosition();
    this.callBase();
    this.setAria("role", "tablist");
    this.$element().addClass("dx-tabs");
    this._toggleScrollingEnabledClass(scrollingEnabled);
    this._toggleOrientationClass(orientation);
    this._toggleIndicatorPositionClass(indicatorPosition);
    this._toggleIconPositionClass();
    this._toggleStylingModeClass(stylingMode);
    this._renderWrapper();
    this._renderMultiple();
    this._feedbackHideTimeout = 100;
  },
  _prepareDefaultItemTemplate(data2, $container) {
    const text = isPlainObject(data2) ? null === data2 || void 0 === data2 ? void 0 : data2.text : data2;
    if (isDefined(text)) {
      const $tabTextSpan = renderer_default("<span>").addClass("dx-tab-text-span");
      $tabTextSpan.text(text);
      const $tabTextSpanPseudo = renderer_default("<span>").addClass("dx-tab-text-span-pseudo");
      $tabTextSpanPseudo.text(text);
      $tabTextSpanPseudo.appendTo($tabTextSpan);
      $tabTextSpan.appendTo($container);
    }
    if (isDefined(data2.html)) {
      $container.html(data2.html);
    }
  },
  _initTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data2) => {
        this._prepareDefaultItemTemplate(data2, $container);
        const $iconElement = getImageContainer(data2.icon);
        $iconElement && $iconElement.prependTo($container);
        const $tabItem = renderer_default("<div>").addClass("dx-tab-text");
        $container.wrapInner($tabItem);
      }, ["text", "html", "icon"], this.option("integrationOptions.watchMethod"))
    });
  },
  _createItemByTemplate: function(itemTemplate, renderArgs) {
    const {
      itemData,
      container,
      index: index2
    } = renderArgs;
    this._deferredTemplates[index2] = Deferred();
    return itemTemplate.render({
      model: itemData,
      container,
      index: index2,
      onRendered: () => this._deferredTemplates[index2].resolve()
    });
  },
  _itemClass: () => "dx-tab",
  _selectedItemClass: () => "dx-tab-selected",
  _itemDataKey: () => "dxTabData",
  _initMarkup() {
    this._deferredTemplates = [];
    this.callBase();
    this.option("useInkRipple") && this._renderInkRipple();
    this.$element().addClass("dx-overflow-hidden");
  },
  _render() {
    this.callBase();
    this._deferRenderScrolling();
  },
  _deferRenderScrolling() {
    when.apply(this, this._deferredTemplates).done(() => this._renderScrolling());
  },
  _renderScrolling() {
    const removeClasses = ["dx-tabs-stretched", TABS_EXPANDED_CLASS, "dx-overflow-hidden"];
    this.$element().removeClass(removeClasses.join(" "));
    if (this.option("scrollingEnabled") && this._isItemsSizeExceeded()) {
      if (!this._scrollable) {
        this._renderScrollable();
        this._renderNavButtons();
      }
      const scrollable = this.getScrollable();
      scrollable.update();
      if (this.option("rtlEnabled")) {
        const maxLeftOffset = getScrollLeftMax(renderer_default(this.getScrollable().container()).get(0));
        scrollable.scrollTo({
          left: maxLeftOffset
        });
      }
      this._updateNavButtonsState();
      this._scrollToItem(this.option("selectedItem"));
    }
    if (!(this.option("scrollingEnabled") && this._isItemsSizeExceeded())) {
      this._cleanScrolling();
      if (this._needStretchItems()) {
        this.$element().addClass("dx-tabs-stretched");
      }
      this.$element().removeClass("dx-tabs-nav-buttons").addClass(TABS_EXPANDED_CLASS);
    }
  },
  _isVertical() {
    return this.option("orientation") === ORIENTATION.vertical;
  },
  _isItemsSizeExceeded() {
    const isVertical = this._isVertical();
    const isItemsSizeExceeded = isVertical ? this._isItemsHeightExceeded() : this._isItemsWidthExceeded();
    return isItemsSizeExceeded;
  },
  _isItemsWidthExceeded() {
    const $visibleItems = this._getVisibleItems();
    const tabItemTotalWidth = this._getSummaryItemsSize("width", $visibleItems, true);
    const elementWidth = getWidth(this.$element());
    if ([tabItemTotalWidth, elementWidth].includes(0)) {
      return false;
    }
    const isItemsWidthExceeded = tabItemTotalWidth > elementWidth - 1;
    return isItemsWidthExceeded;
  },
  _isItemsHeightExceeded() {
    const $visibleItems = this._getVisibleItems();
    const itemsHeight = this._getSummaryItemsSize("height", $visibleItems, true);
    const elementHeight = getHeight(this.$element());
    const isItemsHeightExceeded = itemsHeight - 1 > elementHeight;
    return isItemsHeightExceeded;
  },
  _needStretchItems() {
    const $visibleItems = this._getVisibleItems();
    const elementWidth = getWidth(this.$element());
    const itemsWidth = [];
    each($visibleItems, (_, item) => {
      itemsWidth.push(getOuterWidth(item, true));
    });
    const maxTabItemWidth = Math.max.apply(null, itemsWidth);
    const requireWidth = elementWidth / $visibleItems.length;
    const needStretchItems = maxTabItemWidth > requireWidth + 1;
    return needStretchItems;
  },
  _cleanNavButtons() {
    if (!this._leftButton || !this._rightButton) {
      return;
    }
    this._leftButton.$element().remove();
    this._rightButton.$element().remove();
    this._leftButton = null;
    this._rightButton = null;
  },
  _cleanScrolling() {
    if (!this._scrollable) {
      return;
    }
    this._$wrapper.appendTo(this.$element());
    this._scrollable.$element().remove();
    this._scrollable = null;
    this._cleanNavButtons();
  },
  _renderInkRipple() {
    this._inkRipple = render3();
  },
  _getPointerEvent: () => pointer_default.up,
  _toggleActiveState($element, value2, e) {
    this.callBase.apply(this, arguments);
    if (!this._inkRipple) {
      return;
    }
    const config3 = {
      element: $element,
      event: e
    };
    if (value2) {
      this._inkRipple.showWave(config3);
    } else {
      this._inkRipple.hideWave(config3);
    }
  },
  _renderMultiple() {
    if ("multiple" === this.option("selectionMode")) {
      this.option("selectOnFocus", false);
    }
  },
  _renderWrapper() {
    this._$wrapper = renderer_default("<div>").addClass("dx-tabs-wrapper");
    this.$element().append(this._$wrapper);
  },
  _itemContainer() {
    return this._$wrapper;
  },
  _getScrollableDirection() {
    const isVertical = this._isVertical();
    const scrollableDirection = isVertical ? SCROLLABLE_DIRECTION.vertical : SCROLLABLE_DIRECTION.horizontal;
    return scrollableDirection;
  },
  _updateScrollable() {
    if (this.getScrollable()) {
      this._cleanScrolling();
    }
    this._renderScrolling();
  },
  _renderScrollable() {
    const $itemContainer = this.$element().wrapInner(renderer_default("<div>").addClass("dx-tabs-scrollable")).children();
    this._scrollable = this._createComponent($itemContainer, ui_scrollable_default, {
      direction: this._getScrollableDirection(),
      showScrollbar: "never",
      useKeyboard: false,
      useNative: false,
      scrollByContent: this.option("scrollByContent"),
      onScroll: () => {
        this._updateNavButtonsState();
      }
    });
    this.$element().append(this._scrollable.$element());
  },
  _scrollToItem(itemData) {
    if (!this._scrollable) {
      return;
    }
    const $item = this._editStrategy.getItemElement(itemData);
    this._scrollable.scrollToElement($item);
  },
  _renderNavButtons() {
    const {
      showNavButtons,
      rtlEnabled
    } = this.option();
    this.$element().toggleClass("dx-tabs-nav-buttons", showNavButtons);
    if (!showNavButtons) {
      return;
    }
    this._leftButton = this._createNavButton(-30, rtlEnabled ? "chevronnext" : "chevronprev");
    const $leftButton = this._leftButton.$element();
    $leftButton.addClass("dx-tabs-nav-button-left");
    this.$element().prepend($leftButton);
    this._rightButton = this._createNavButton(30, rtlEnabled ? "chevronprev" : "chevronnext");
    const $rightButton = this._rightButton.$element();
    $rightButton.addClass("dx-tabs-nav-button-right");
    this.$element().append($rightButton);
  },
  _updateNavButtonsAriaDisabled() {
    const buttons = [this._leftButton, this._rightButton];
    buttons.forEach((button) => {
      null === button || void 0 === button || button.$element().attr({
        "aria-disabled": null
      });
    });
  },
  _updateNavButtonsState() {
    const isVertical = this._isVertical();
    const scrollable = this.getScrollable();
    if (isVertical) {
      var _this$_leftButton, _this$_rightButton;
      null === (_this$_leftButton = this._leftButton) || void 0 === _this$_leftButton || _this$_leftButton.option("disabled", isReachedTop(scrollable.scrollTop(), 1));
      null === (_this$_rightButton = this._rightButton) || void 0 === _this$_rightButton || _this$_rightButton.option("disabled", isReachedBottom(renderer_default(scrollable.container()).get(0), scrollable.scrollTop(), 0, 1));
    } else {
      var _this$_leftButton2, _this$_rightButton2;
      null === (_this$_leftButton2 = this._leftButton) || void 0 === _this$_leftButton2 || _this$_leftButton2.option("disabled", isReachedLeft(scrollable.scrollLeft(), 1));
      null === (_this$_rightButton2 = this._rightButton) || void 0 === _this$_rightButton2 || _this$_rightButton2.option("disabled", isReachedRight(renderer_default(scrollable.container()).get(0), scrollable.scrollLeft(), 1));
    }
    this._updateNavButtonsAriaDisabled();
  },
  _updateScrollPosition(offset2, duration) {
    this._scrollable.update();
    this._scrollable.scrollBy(offset2 / duration);
  },
  _createNavButton(offset2, icon) {
    const holdAction = this._createAction(() => {
      this._holdInterval = setInterval(() => {
        this._updateScrollPosition(offset2, 5);
      }, 5);
    });
    const holdEventName = addNamespace2(hold_default.name, "dxNavButton");
    const pointerUpEventName = addNamespace2(pointer_default.up, "dxNavButton");
    const pointerOutEventName = addNamespace2(pointer_default.out, "dxNavButton");
    const navButton = this._createComponent(renderer_default("<div>").addClass("dx-tabs-nav-button"), button_default, {
      focusStateEnabled: false,
      icon,
      integrationOptions: {},
      elementAttr: {
        role: null,
        "aria-label": null,
        "aria-disabled": null
      },
      onClick: () => {
        this._updateScrollPosition(offset2, 1);
      }
    });
    const $navButton = navButton.$element();
    events_engine_default.on($navButton, holdEventName, {
      timeout: 300
    }, (e) => {
      holdAction({
        event: e
      });
    });
    events_engine_default.on($navButton, pointerUpEventName, () => {
      this._clearInterval();
    });
    events_engine_default.on($navButton, pointerOutEventName, () => {
      this._clearInterval();
    });
    return navButton;
  },
  _clearInterval() {
    if (this._holdInterval) {
      clearInterval(this._holdInterval);
    }
  },
  _updateSelection(addedSelection) {
    this._scrollable && this._scrollable.scrollToElement(this.itemElements().eq(addedSelection[0]));
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._dimensionChanged();
    }
  },
  _dimensionChanged() {
    this._renderScrolling();
  },
  _itemSelectHandler(e) {
    if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
      return;
    }
    this.callBase(e);
  },
  _clean() {
    this._deferredTemplates = [];
    this._cleanScrolling();
    this.callBase();
  },
  _toggleTabsVerticalClass(value2) {
    this.$element().toggleClass(TABS_ORIENTATION_CLASS.vertical, value2);
  },
  _toggleTabsHorizontalClass(value2) {
    this.$element().toggleClass(TABS_ORIENTATION_CLASS.horizontal, value2);
  },
  _getIndicatorPositionClass: (indicatorPosition) => INDICATOR_POSITION_CLASS[indicatorPosition],
  _getIndicatorPosition() {
    const {
      _indicatorPosition,
      rtlEnabled
    } = this.option();
    if (_indicatorPosition) {
      return _indicatorPosition;
    }
    const isVertical = this._isVertical();
    if (rtlEnabled) {
      return isVertical ? INDICATOR_POSITION.left : INDICATOR_POSITION.bottom;
    }
    return isVertical ? INDICATOR_POSITION.right : INDICATOR_POSITION.bottom;
  },
  _toggleIndicatorPositionClass(indicatorPosition) {
    const newClass = this._getIndicatorPositionClass(indicatorPosition);
    this._toggleElementClasses(INDICATOR_POSITION_CLASS, newClass);
  },
  _toggleScrollingEnabledClass(scrollingEnabled) {
    this.$element().toggleClass("dx-tabs-scrolling-enabled", Boolean(scrollingEnabled));
  },
  _toggleOrientationClass(orientation) {
    const isVertical = orientation === ORIENTATION.vertical;
    this._toggleTabsVerticalClass(isVertical);
    this._toggleTabsHorizontalClass(!isVertical);
  },
  _getTabsIconPositionClass() {
    const position3 = this.option("iconPosition");
    switch (position3) {
      case ICON_POSITION.top:
        return TABS_ICON_POSITION_CLASS.top;
      case ICON_POSITION.end:
        return TABS_ICON_POSITION_CLASS.end;
      case ICON_POSITION.bottom:
        return TABS_ICON_POSITION_CLASS.bottom;
      default:
        return TABS_ICON_POSITION_CLASS.start;
    }
  },
  _toggleIconPositionClass() {
    const newClass = this._getTabsIconPositionClass();
    this._toggleElementClasses(TABS_ICON_POSITION_CLASS, newClass);
  },
  _toggleStylingModeClass(value2) {
    const newClass = TABS_STYLING_MODE_CLASS[value2] ?? TABS_STYLING_MODE_CLASS.primary;
    this._toggleElementClasses(TABS_STYLING_MODE_CLASS, newClass);
  },
  _toggleElementClasses(classMap, newClass) {
    for (const key in classMap) {
      this.$element().removeClass(classMap[key]);
    }
    this.$element().addClass(newClass);
  },
  _toggleFocusedDisabledNextClass(currentIndex, isNextDisabled) {
    this._itemElements().eq(currentIndex).toggleClass("dx-focused-disabled-next-tab", isNextDisabled);
  },
  _toggleFocusedDisabledPrevClass(currentIndex, isPrevDisabled) {
    this._itemElements().eq(currentIndex).toggleClass("dx-focused-disabled-prev-tab", isPrevDisabled);
  },
  _toggleFocusedDisabledClasses(value2) {
    const {
      selectedIndex: currentIndex
    } = this.option();
    this._itemElements().removeClass("dx-focused-disabled-next-tab").removeClass("dx-focused-disabled-prev-tab");
    const prevItemIndex = currentIndex - 1;
    const nextItemIndex = currentIndex + 1;
    const nextFocusedIndex = renderer_default(value2).index();
    const isNextDisabled = this._itemElements().eq(nextItemIndex).hasClass("dx-state-disabled");
    const isPrevDisabled = this._itemElements().eq(prevItemIndex).hasClass("dx-state-disabled");
    const shouldNextClassBeSetted = isNextDisabled && nextFocusedIndex === nextItemIndex;
    const shouldPrevClassBeSetted = isPrevDisabled && nextFocusedIndex === prevItemIndex;
    this._toggleFocusedDisabledNextClass(currentIndex, shouldNextClassBeSetted);
    this._toggleFocusedDisabledPrevClass(currentIndex, shouldPrevClassBeSetted);
  },
  _updateFocusedElement() {
    const {
      focusStateEnabled,
      selectedIndex
    } = this.option();
    const itemElements = this._itemElements();
    if (focusStateEnabled && itemElements.length) {
      const selectedItem = itemElements.get(selectedIndex);
      this.option({
        focusedElement: selectedItem
      });
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "useInkRipple":
      case "scrollingEnabled":
        this._toggleScrollingEnabledClass(args.value);
        this._invalidate();
        break;
      case "showNavButtons":
      case "badgeExpr":
        this._invalidate();
        break;
      case "scrollByContent":
        this._scrollable && this._scrollable.option(args.name, args.value);
        break;
      case "width":
      case "height":
        this.callBase(args);
        this._dimensionChanged();
        break;
      case "selectionMode":
        this._renderMultiple();
        this.callBase(args);
        break;
      case "focusedElement":
        this._toggleFocusedDisabledClasses(args.value);
        this.callBase(args);
        this._scrollToItem(args.value);
        break;
      case "rtlEnabled": {
        this.callBase(args);
        const indicatorPosition = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(indicatorPosition);
        break;
      }
      case "orientation": {
        this._toggleOrientationClass(args.value);
        const indicatorPosition = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(indicatorPosition);
        if (hasWindow()) {
          this._updateScrollable();
        }
        break;
      }
      case "iconPosition":
        this._toggleIconPositionClass();
        if (hasWindow()) {
          this._dimensionChanged();
        }
        break;
      case "stylingMode":
        this._toggleStylingModeClass(args.value);
        if (hasWindow()) {
          this._dimensionChanged();
        }
        break;
      case "_indicatorPosition":
        this._toggleIndicatorPositionClass(args.value);
        break;
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
        this.callBase(args);
        this._updateFocusedElement();
        break;
      default:
        this.callBase(args);
    }
  },
  _afterItemElementInserted() {
    this.callBase();
    this._deferRenderScrolling();
  },
  _afterItemElementDeleted($item, deletedActionArgs) {
    this.callBase($item, deletedActionArgs);
    this._renderScrolling();
  },
  getScrollable() {
    return this._scrollable;
  }
});
Tabs.ItemClass = m_item_default3;
component_registrator_default("dxTabs", Tabs);
var m_tabs_default = Tabs;

// ../../../../../../node_modules/devextreme/esm/ui/tabs.js
var tabs_default = m_tabs_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tab_panel/m_item.js
var TabPanelItem = class extends m_item_default {
  _renderWatchers() {
    this._startWatcher("badge", noop2);
    return super._renderWatchers();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tab_panel/m_tab_panel.js
var TABPANEL_TABS_POSITION_CLASS = {
  top: "dx-tabpanel-tabs-position-top",
  right: "dx-tabpanel-tabs-position-right",
  bottom: "dx-tabpanel-tabs-position-bottom",
  left: "dx-tabpanel-tabs-position-left"
};
var TABS_POSITION = {
  top: "top",
  right: "right",
  bottom: "bottom",
  left: "left"
};
var TABS_INDICATOR_POSITION_BY_TABS_POSITION = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var TABS_ORIENTATION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var ICON_POSITION2 = {
  top: "top",
  end: "end",
  bottom: "bottom",
  start: "start"
};
var STYLING_MODE2 = {
  primary: "primary",
  secondary: "secondary"
};
var TabPanel = multi_view_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      itemTitleTemplate: "title",
      hoverStateEnabled: true,
      showNavButtons: false,
      scrollByContent: true,
      scrollingEnabled: true,
      tabsPosition: TABS_POSITION.top,
      iconPosition: ICON_POSITION2.start,
      stylingMode: STYLING_MODE2.primary,
      onTitleClick: null,
      onTitleHold: null,
      onTitleRendered: null,
      badgeExpr: (data2) => data2 ? data2.badge : void 0,
      _tabsIndicatorPosition: null
    });
  },
  _defaultOptionsRules() {
    const themeName = current();
    return this.callBase().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => !touch,
      options: {
        swipeEnabled: false
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        animationEnabled: false
      }
    }, {
      device: () => isFluent(themeName),
      options: {
        stylingMode: STYLING_MODE2.secondary
      }
    }, {
      device: () => isMaterialBased(themeName),
      options: {
        iconPosition: ICON_POSITION2.top
      }
    }]);
  },
  _init() {
    this.callBase();
    this.$element().addClass("dx-tabpanel");
    this._toggleTabPanelTabsPositionClass();
  },
  _getElementAria: () => ({
    role: "tabpanel"
  }),
  _getItemAria: () => ({
    role: "tabpanel"
  }),
  _initMarkup() {
    this.callBase();
    this._createTitleActions();
    this._renderLayout();
  },
  _prepareTabsItemTemplate(data2, $container) {
    const $iconElement = getImageContainer(null === data2 || void 0 === data2 ? void 0 : data2.icon);
    if ($iconElement) {
      $container.append($iconElement);
    }
    const title = isPlainObject(data2) ? null === data2 || void 0 === data2 ? void 0 : data2.title : data2;
    if (isDefined(title) && !isPlainObject(title)) {
      const $tabTextSpan = renderer_default("<span>").addClass("dx-tab-text-span");
      $tabTextSpan.append(dom_adapter_default.createTextNode(title));
      const $tabTextSpanPseudo = renderer_default("<span>").addClass("dx-tab-text-span-pseudo");
      $tabTextSpanPseudo.append(dom_adapter_default.createTextNode(title));
      $tabTextSpanPseudo.appendTo($tabTextSpan);
      $tabTextSpan.appendTo($container);
    }
  },
  _initTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      title: new BindableTemplate(($container, data2) => {
        this._prepareTabsItemTemplate(data2, $container);
        const $tabItem = renderer_default("<div>").addClass("dx-tab-text");
        $container.wrapInner($tabItem);
      }, ["title", "icon"], this.option("integrationOptions.watchMethod"))
    });
  },
  _createTitleActions() {
    this._createTitleClickAction();
    this._createTitleHoldAction();
    this._createTitleRenderedAction();
  },
  _createTitleClickAction() {
    this._titleClickAction = this._createActionByOption("onTitleClick");
  },
  _createTitleHoldAction() {
    this._titleHoldAction = this._createActionByOption("onTitleHold");
  },
  _createTitleRenderedAction() {
    this._titleRenderedAction = this._createActionByOption("onTitleRendered");
  },
  _renderLayout() {
    if (this._tabs) {
      return;
    }
    const $element = this.$element();
    this._$tabContainer = renderer_default("<div>").addClass("dx-tabpanel-tabs").appendTo($element);
    const $tabs = renderer_default("<div>").appendTo(this._$tabContainer);
    this._tabs = this._createComponent($tabs, tabs_default, this._tabConfig());
    this._$container = renderer_default("<div>").addClass("dx-tabpanel-container").appendTo($element);
    this._$container.append(this._$wrapper);
  },
  _refreshActiveDescendant() {
    if (!this._tabs) {
      return;
    }
    const tabs = this._tabs;
    const tabItems = tabs.itemElements();
    const $activeTab = renderer_default(tabItems[tabs.option("selectedIndex")]);
    const id = this.getFocusedItemId();
    this.setAria("controls", void 0, renderer_default(tabItems));
    this.setAria("controls", id, $activeTab);
  },
  _getTabsIndicatorPosition() {
    const {
      _tabsIndicatorPosition,
      tabsPosition
    } = this.option();
    return _tabsIndicatorPosition ?? TABS_INDICATOR_POSITION_BY_TABS_POSITION[tabsPosition];
  },
  _tabConfig() {
    const tabsIndicatorPosition = this._getTabsIndicatorPosition();
    return {
      selectOnFocus: true,
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      repaintChangesOnly: this.option("repaintChangesOnly"),
      tabIndex: this.option("tabIndex"),
      selectedIndex: this.option("selectedIndex"),
      badgeExpr: this.option("badgeExpr"),
      onItemClick: this._titleClickAction.bind(this),
      onItemHold: this._titleHoldAction.bind(this),
      itemHoldTimeout: this.option("itemHoldTimeout"),
      onSelectionChanged: (function(e) {
        this.option("selectedIndex", e.component.option("selectedIndex"));
        this._refreshActiveDescendant();
      }).bind(this),
      onItemRendered: this._titleRenderedAction.bind(this),
      itemTemplate: this._getTemplateByOption("itemTitleTemplate"),
      items: this.option("items"),
      noDataText: null,
      scrollingEnabled: this.option("scrollingEnabled"),
      scrollByContent: this.option("scrollByContent"),
      showNavButtons: this.option("showNavButtons"),
      itemTemplateProperty: "tabTemplate",
      loopItemFocus: this.option("loop"),
      selectionRequired: true,
      onOptionChanged: (function(args) {
        if ("focusedElement" === args.name) {
          if (args.value) {
            const $value = renderer_default(args.value);
            const $newItem = this._itemElements().eq($value.index());
            this.option("focusedElement", getPublicElement($newItem));
          } else {
            this.option("focusedElement", args.value);
          }
        }
      }).bind(this),
      onFocusIn: (function(args) {
        this._focusInHandler(args.event);
      }).bind(this),
      onFocusOut: (function(args) {
        if (!this._isFocusOutHandlerExecuting) {
          this._focusOutHandler(args.event);
        }
      }).bind(this),
      orientation: this._getTabsOrientation(),
      iconPosition: this.option("iconPosition"),
      stylingMode: this.option("stylingMode"),
      _itemAttributes: {
        class: "dx-tabpanel-tab"
      },
      _indicatorPosition: tabsIndicatorPosition
    };
  },
  _renderFocusTarget() {
    this._focusTarget().attr("tabIndex", -1);
  },
  _getTabsOrientation() {
    const {
      tabsPosition
    } = this.option();
    if ([TABS_POSITION.right, TABS_POSITION.left].includes(tabsPosition)) {
      return TABS_ORIENTATION.vertical;
    }
    return TABS_ORIENTATION.horizontal;
  },
  _getTabPanelTabsPositionClass() {
    const position3 = this.option("tabsPosition");
    switch (position3) {
      case TABS_POSITION.right:
        return TABPANEL_TABS_POSITION_CLASS.right;
      case TABS_POSITION.bottom:
        return TABPANEL_TABS_POSITION_CLASS.bottom;
      case TABS_POSITION.left:
        return TABPANEL_TABS_POSITION_CLASS.left;
      case TABS_POSITION.top:
      default:
        return TABPANEL_TABS_POSITION_CLASS.top;
    }
  },
  _toggleTabPanelTabsPositionClass() {
    for (const key in TABPANEL_TABS_POSITION_CLASS) {
      this.$element().removeClass(TABPANEL_TABS_POSITION_CLASS[key]);
    }
    const newClass = this._getTabPanelTabsPositionClass();
    this.$element().addClass(newClass);
  },
  _updateTabsOrientation() {
    const orientation = this._getTabsOrientation();
    this._setTabsOption("orientation", orientation);
  },
  _toggleWrapperFocusedClass(isFocused) {
    this._toggleFocusClass(isFocused, this._$wrapper);
  },
  _toggleDisabledFocusedClass(isFocused) {
    this._focusTarget().toggleClass("dx-disabled-focused-tab", isFocused);
  },
  _updateFocusState(e, isFocused) {
    this.callBase(e, isFocused);
    const isTabsTarget = e.target === this._tabs._focusTarget().get(0);
    const isMultiViewTarget = e.target === this._focusTarget().get(0);
    if (isTabsTarget) {
      this._toggleFocusClass(isFocused, this._focusTarget());
    }
    if (isTabsTarget || isMultiViewTarget) {
      const isDisabled = this._isDisabled(this.option("focusedElement"));
      this._toggleWrapperFocusedClass(isFocused && !isDisabled);
      this._toggleDisabledFocusedClass(isFocused && isDisabled);
    }
    if (isMultiViewTarget) {
      this._toggleFocusClass(isFocused, this._tabs.option("focusedElement"));
    }
  },
  _focusOutHandler(e) {
    this._isFocusOutHandlerExecuting = true;
    this.callBase.apply(this, arguments);
    this._tabs._focusOutHandler(e);
    this._isFocusOutHandlerExecuting = false;
  },
  _setTabsOption(name2, value2) {
    if (this._tabs) {
      this._tabs.option(name2, value2);
    }
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._tabs._dimensionChanged();
    }
  },
  registerKeyHandler(key, handler) {
    this.callBase(key, handler);
    if (this._tabs) {
      this._tabs.registerKeyHandler(key, handler);
    }
  },
  repaint() {
    this.callBase();
    this._tabs.repaint();
  },
  _updateTabsIndicatorPosition() {
    const value2 = this._getTabsIndicatorPosition();
    this._setTabsOption("_indicatorPosition", value2);
  },
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      fullName
    } = args;
    switch (name2) {
      case "dataSource":
      default:
        this.callBase(args);
        break;
      case "items":
        this._setTabsOption(name2, this.option(name2));
        if (!this.option("repaintChangesOnly")) {
          this._tabs.repaint();
        }
        this.callBase(args);
        break;
      case "width":
        this.callBase(args);
        this._tabs.repaint();
        break;
      case "selectedIndex":
      case "selectedItem":
        this._setTabsOption(fullName, value2);
        this.callBase(args);
        if (true === this.option("focusStateEnabled")) {
          const selectedIndex = this.option("selectedIndex");
          const selectedTabContent = this._itemElements().eq(selectedIndex);
          this.option("focusedElement", getPublicElement(selectedTabContent));
        }
        break;
      case "itemHoldTimeout":
      case "focusStateEnabled":
      case "hoverStateEnabled":
        this._setTabsOption(fullName, value2);
        this.callBase(args);
        break;
      case "scrollingEnabled":
      case "scrollByContent":
      case "showNavButtons":
        this._setTabsOption(fullName, value2);
        break;
      case "focusedElement": {
        const id = value2 ? renderer_default(value2).index() : value2;
        const newItem = value2 ? this._tabs._itemElements().eq(id) : value2;
        this._setTabsOption("focusedElement", getPublicElement(newItem));
        if (value2) {
          const isDisabled = this._isDisabled(value2);
          this._toggleWrapperFocusedClass(!isDisabled);
          this._toggleDisabledFocusedClass(isDisabled);
        }
        this.callBase(args);
        break;
      }
      case "itemTitleTemplate":
        this._setTabsOption("itemTemplate", this._getTemplateByOption("itemTitleTemplate"));
        break;
      case "onTitleClick":
        this._createTitleClickAction();
        this._setTabsOption("onItemClick", this._titleClickAction.bind(this));
        break;
      case "onTitleHold":
        this._createTitleHoldAction();
        this._setTabsOption("onItemHold", this._titleHoldAction.bind(this));
        break;
      case "onTitleRendered":
        this._createTitleRenderedAction();
        this._setTabsOption("onItemRendered", this._titleRenderedAction.bind(this));
        break;
      case "loop":
        this._setTabsOption("loopItemFocus", value2);
        break;
      case "badgeExpr":
        this._invalidate();
        break;
      case "tabsPosition":
        this._toggleTabPanelTabsPositionClass();
        this._updateTabsIndicatorPosition();
        this._updateTabsOrientation();
        break;
      case "iconPosition":
        this._setTabsOption("iconPosition", value2);
        break;
      case "stylingMode":
        this._setTabsOption("stylingMode", value2);
        break;
      case "_tabsIndicatorPosition":
        this._setTabsOption("_indicatorPosition", value2);
    }
  }
});
TabPanel.ItemClass = TabPanelItem;
component_registrator_default("dxTabPanel", TabPanel);
var m_tab_panel_default = TabPanel;

// ../../../../../../node_modules/devextreme/esm/ui/tab_panel.js
var tab_panel_default = m_tab_panel_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.item_option_action.js
var ItemOptionAction = class {
  constructor(options2) {
    this._options = options2;
    this._itemsRunTimeInfo = this._options.itemsRunTimeInfo;
  }
  findInstance() {
    return this._itemsRunTimeInfo.findWidgetInstanceByItem(this._options.item);
  }
  findItemContainer() {
    return this._itemsRunTimeInfo.findItemContainerByItem(this._options.item);
  }
  findPreparedItem() {
    return this._itemsRunTimeInfo.findPreparedItemByItem(this._options.item);
  }
  tryExecute() {
    class_default.abstract();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.utils.js
var createItemPathByIndex = (index2, isTabs) => `${isTabs ? "tabs" : "items"}[${index2}]`;
var concatPaths = (path1, path2) => {
  if (isDefined(path1) && isDefined(path2)) {
    return `${path1}.${path2}`;
  }
  return path1 || path2;
};
var getTextWithoutSpaces = (text) => text ? text.replace(/\s/g, "") : void 0;
var isEqualToDataFieldOrNameOrTitleOrCaption = (item, fieldName) => {
  if (item) {
    return item.dataField === fieldName || item.name === fieldName || getTextWithoutSpaces(item.title) === fieldName || "group" === item.itemType && getTextWithoutSpaces(item.caption) === fieldName;
  }
  return false;
};
var getFullOptionName = (path, optionName) => `${path}.${optionName}`;
var getOptionNameFromFullName = (fullName) => {
  const parts = fullName.split(".");
  return parts[parts.length - 1].replace(/\[\d+]/, "");
};
var tryGetTabPath = (fullPath) => {
  const pathParts = fullPath.split(".");
  const resultPathParts = [...pathParts];
  for (let i = pathParts.length - 1; i >= 0; i--) {
    if (isFullPathContainsTabs(pathParts[i])) {
      return resultPathParts.join(".");
    }
    resultPathParts.splice(i, 1);
  }
  return "";
};
var isFullPathContainsTabs = (fullPath) => fullPath.indexOf("tabs") > -1;
var getItemPath = (items, item, isTabs) => {
  const index2 = items.indexOf(item);
  if (index2 > -1) {
    return createItemPathByIndex(index2, isTabs);
  }
  for (let i = 0; i < items.length; i++) {
    const targetItem = items[i];
    const tabOrGroupItems = targetItem.tabs || targetItem.items;
    if (tabOrGroupItems) {
      const itemPath = getItemPath(tabOrGroupItems, item, targetItem.tabs);
      if (itemPath) {
        return concatPaths(createItemPathByIndex(i, isTabs), itemPath);
      }
    }
  }
};
function convertToLayoutManagerOptions(_ref) {
  let {
    form,
    $formElement,
    formOptions,
    items,
    validationGroup,
    extendedLayoutManagerOptions,
    onFieldDataChanged,
    onContentReady,
    onDisposing,
    onFieldItemRendered
  } = _ref;
  const baseOptions = {
    form,
    items,
    $formElement,
    validationGroup,
    onFieldDataChanged,
    onContentReady,
    onDisposing,
    onFieldItemRendered,
    validationBoundary: formOptions.scrollingEnabled ? $formElement : void 0,
    scrollingEnabled: formOptions.scrollingEnabled,
    showRequiredMark: formOptions.showRequiredMark,
    showOptionalMark: formOptions.showOptionalMark,
    requiredMark: formOptions.requiredMark,
    optionalMark: formOptions.optionalMark,
    requiredMessage: formOptions.requiredMessage,
    screenByWidth: formOptions.screenByWidth,
    layoutData: formOptions.formData,
    labelLocation: formOptions.labelLocation,
    customizeItem: formOptions.customizeItem,
    minColWidth: formOptions.minColWidth,
    showColonAfterLabel: formOptions.showColonAfterLabel,
    onEditorEnterKey: formOptions.onEditorEnterKey,
    labelMode: formOptions.labelMode
  };
  const result2 = extend(baseOptions, {
    isRoot: extendedLayoutManagerOptions.isRoot,
    colCount: extendedLayoutManagerOptions.colCount,
    alignItemLabels: extendedLayoutManagerOptions.alignItemLabels,
    cssItemClass: extendedLayoutManagerOptions.cssItemClass,
    colCountByScreen: extendedLayoutManagerOptions.colCountByScreen,
    onLayoutChanged: extendedLayoutManagerOptions.onLayoutChanged,
    width: extendedLayoutManagerOptions.width
  });
  return result2;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.item_options_actions.js
var WidgetOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const {
      value: value2
    } = this._options;
    const instance = this.findInstance();
    if (instance) {
      instance.option(value2);
      return true;
    }
    return false;
  }
};
var TabOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const tabPanel = this.findInstance();
    if (tabPanel) {
      const {
        optionName,
        item,
        value: value2
      } = this._options;
      const itemIndex = this._itemsRunTimeInfo.findItemIndexByItem(item);
      if (itemIndex >= 0) {
        tabPanel.option(getFullOptionName(`items[${itemIndex}]`, optionName), value2);
        return true;
      }
    }
    return false;
  }
};
var SimpleItemTemplateChangedAction = class extends ItemOptionAction {
  tryExecute() {
    return false;
  }
};
var GroupItemTemplateChangedAction = class extends ItemOptionAction {
  tryExecute() {
    const preparedItem = this.findPreparedItem();
    if (null != preparedItem && preparedItem._prepareGroupItemTemplate && preparedItem._renderGroupContentTemplate) {
      preparedItem._prepareGroupItemTemplate(this._options.item.template);
      preparedItem._renderGroupContentTemplate();
      return true;
    }
    return false;
  }
};
var TabsOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const tabPanel = this.findInstance();
    if (tabPanel) {
      const {
        value: value2
      } = this._options;
      tabPanel.option("dataSource", value2);
      return true;
    }
    return false;
  }
};
var ValidationRulesItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const {
      item
    } = this._options;
    const instance = this.findInstance();
    const validator = instance && data(instance.$element()[0], "dxValidator");
    if (validator && item) {
      const filterRequired = (item2) => "required" === item2.type;
      const oldContainsRequired = (validator.option("validationRules") || []).some(filterRequired);
      const newContainsRequired = (item.validationRules || []).some(filterRequired);
      if (!oldContainsRequired && !newContainsRequired || oldContainsRequired && newContainsRequired) {
        validator.option("validationRules", item.validationRules);
        return true;
      }
    }
    return false;
  }
};
var CssClassItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const $itemContainer = this.findItemContainer();
    const {
      previousValue,
      value: value2
    } = this._options;
    if ($itemContainer) {
      $itemContainer.removeClass(previousValue).addClass(value2);
      return true;
    }
    return false;
  }
};
var tryCreateItemOptionAction = (optionName, itemActionOptions) => {
  switch (optionName) {
    case "editorOptions":
    case "buttonOptions":
      return new WidgetOptionItemOptionAction(itemActionOptions);
    case "validationRules":
      return new ValidationRulesItemOptionAction(itemActionOptions);
    case "cssClass":
      return new CssClassItemOptionAction(itemActionOptions);
    case "badge":
    case "disabled":
    case "icon":
    case "tabTemplate":
    case "title":
      return new TabOptionItemOptionAction(extend(itemActionOptions, {
        optionName
      }));
    case "tabs":
      return new TabsOptionItemOptionAction(itemActionOptions);
    case "template": {
      var _itemActionOptions$it, _itemActionOptions$it2;
      const itemType = (null === itemActionOptions || void 0 === itemActionOptions || null === (_itemActionOptions$it = itemActionOptions.item) || void 0 === _itemActionOptions$it ? void 0 : _itemActionOptions$it.itemType) ?? (null === (_itemActionOptions$it2 = itemActionOptions.itemsRunTimeInfo.findPreparedItemByItem(null === itemActionOptions || void 0 === itemActionOptions ? void 0 : itemActionOptions.item)) || void 0 === _itemActionOptions$it2 ? void 0 : _itemActionOptions$it2.itemType);
      if ("simple" === itemType) {
        return new SimpleItemTemplateChangedAction(itemActionOptions);
      }
      if ("group" === itemType) {
        return new GroupItemTemplateChangedAction(itemActionOptions);
      }
      return new TabOptionItemOptionAction(extend(itemActionOptions, {
        optionName
      }));
    }
    default:
      return null;
  }
};
var m_form_item_options_actions_default = tryCreateItemOptionAction;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.js
var ITEM_OPTIONS_FOR_VALIDATION_UPDATING = ["items", "isRequired", "validationRules", "visible"];
var Form = ui_widget_default.inherit({
  _init() {
    this.callBase();
    this._dirtyFields = /* @__PURE__ */ new Set();
    this._cachedColCountOptions = [];
    this._itemsRunTimeInfo = new FormItemsRunTimeInfo();
    this._groupsColCount = [];
    this._attachSyncSubscriptions();
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      formID: `dx-${new guid_default()}`,
      formData: {},
      colCount: 1,
      screenByWidth: defaultScreenFactorFunc,
      colCountByScreen: void 0,
      labelLocation: "left",
      readOnly: false,
      onFieldDataChanged: null,
      customizeItem: null,
      onEditorEnterKey: null,
      minColWidth: 200,
      alignItemLabels: true,
      alignItemLabelsInAllGroups: true,
      alignRootItemLabels: true,
      showColonAfterLabel: true,
      showRequiredMark: true,
      showOptionalMark: false,
      requiredMark: "*",
      optionalMark: message_default.format("dxForm-optionalMark"),
      requiredMessage: message_default.getFormatter("dxForm-requiredMessage"),
      showValidationSummary: false,
      items: void 0,
      scrollingEnabled: false,
      validationGroup: void 0,
      stylingMode: config_default().editorStylingMode,
      labelMode: "outside",
      isDirty: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => isMaterialBased(),
      options: {
        labelLocation: "top"
      }
    }, {
      device: () => isMaterial(),
      options: {
        showColonAfterLabel: false
      }
    }]);
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      formData: true,
      validationGroup: true
    });
  },
  _getGroupColCount: ($element) => parseInt($element.attr(GROUP_COL_COUNT_ATTR)),
  _applyLabelsWidthByCol($container, index2) {
    let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    let labelMarkOptions = arguments.length > 3 ? arguments[3] : void 0;
    const fieldItemClass = options2.inOneColumn ? FIELD_ITEM_CLASS : FORM_FIELD_ITEM_COL_CLASS + index2;
    const cssExcludeTabbedSelector = options2.excludeTabbed ? `:not(.${FIELD_ITEM_TAB_CLASS})` : "";
    setLabelWidthByMaxLabelWidth($container, `.${fieldItemClass}${cssExcludeTabbedSelector}`, labelMarkOptions);
  },
  _applyLabelsWidth($container, excludeTabbed, inOneColumn, colCount, labelMarkOptions) {
    colCount = inOneColumn ? 1 : colCount || this._getGroupColCount($container);
    const applyLabelsOptions = {
      excludeTabbed,
      inOneColumn
    };
    let i;
    for (i = 0; i < colCount; i++) {
      this._applyLabelsWidthByCol($container, i, applyLabelsOptions, labelMarkOptions);
    }
  },
  _getGroupElementsInColumn($container, columnIndex, colCount) {
    const cssColCountSelector = isDefined(colCount) ? `.${GROUP_COL_COUNT_CLASS}${colCount}` : "";
    const groupSelector = `.${FORM_FIELD_ITEM_COL_CLASS}${columnIndex} > .${FIELD_ITEM_CONTENT_CLASS} > .${FORM_GROUP_CLASS}${cssColCountSelector}`;
    return $container.find(groupSelector);
  },
  _applyLabelsWidthWithGroups($container, colCount, excludeTabbed, labelMarkOptions) {
    if (true === this.option("alignRootItemLabels")) {
      const $rootSimpleItems = $container.find(`.${ROOT_SIMPLE_ITEM_CLASS}`);
      for (let colIndex = 0; colIndex < colCount; colIndex++) {
        this._applyLabelsWidthByCol($rootSimpleItems, colIndex, excludeTabbed, labelMarkOptions);
      }
    }
    const alignItemLabelsInAllGroups = this.option("alignItemLabelsInAllGroups");
    if (alignItemLabelsInAllGroups) {
      this._applyLabelsWidthWithNestedGroups($container, colCount, excludeTabbed, labelMarkOptions);
    } else {
      const $groups = this.$element().find(`.${FORM_GROUP_CLASS}`);
      let i;
      for (i = 0; i < $groups.length; i++) {
        this._applyLabelsWidth($groups.eq(i), excludeTabbed, void 0, void 0, labelMarkOptions);
      }
    }
  },
  _applyLabelsWidthWithNestedGroups($container, colCount, excludeTabbed, labelMarkOptions) {
    const applyLabelsOptions = {
      excludeTabbed
    };
    let colIndex;
    let groupsColIndex;
    let groupColIndex;
    let $groupsByCol;
    for (colIndex = 0; colIndex < colCount; colIndex++) {
      $groupsByCol = this._getGroupElementsInColumn($container, colIndex);
      this._applyLabelsWidthByCol($groupsByCol, 0, applyLabelsOptions, labelMarkOptions);
      for (groupsColIndex = 0; groupsColIndex < this._groupsColCount.length; groupsColIndex++) {
        $groupsByCol = this._getGroupElementsInColumn($container, colIndex, this._groupsColCount[groupsColIndex]);
        const groupColCount = this._getGroupColCount($groupsByCol);
        for (groupColIndex = 1; groupColIndex < groupColCount; groupColIndex++) {
          this._applyLabelsWidthByCol($groupsByCol, groupColIndex, applyLabelsOptions, labelMarkOptions);
        }
      }
    }
  },
  _labelLocation() {
    return this.option("labelLocation");
  },
  _alignLabelsInColumn(_ref) {
    let {
      layoutManager,
      inOneColumn,
      $container,
      excludeTabbed,
      items
    } = _ref;
    if (!hasWindow() || "top" === this._labelLocation()) {
      return;
    }
    const labelMarkOptions = convertToLabelMarkOptions(layoutManager._getMarkOptions());
    if (inOneColumn) {
      this._applyLabelsWidth($container, excludeTabbed, true, void 0, labelMarkOptions);
    } else if (this._checkGrouping(items)) {
      this._applyLabelsWidthWithGroups($container, layoutManager._getColCount(), excludeTabbed, labelMarkOptions);
    } else {
      this._applyLabelsWidth($container, excludeTabbed, false, layoutManager._getColCount(), labelMarkOptions);
    }
  },
  _prepareFormData() {
    if (!isDefined(this.option("formData"))) {
      this.option("formData", {});
    }
  },
  _setStylingModeClass() {
    if ("underlined" === this.option("stylingMode")) {
      this.$element().addClass(FORM_UNDERLINED_CLASS);
    }
  },
  _initMarkup() {
    validation_engine_default.addGroup(this._getValidationGroup(), false);
    this._clearCachedInstances();
    this._prepareFormData();
    this.$element().addClass(FORM_CLASS);
    this._setStylingModeClass();
    this.callBase();
    this.setAria("role", "form", this.$element());
    if (this.option("scrollingEnabled")) {
      this._renderScrollable();
    }
    this._renderLayout();
    this._renderValidationSummary();
    this._lastMarkupScreenFactor = this._targetScreenFactor || this._getCurrentScreenFactor();
    this._attachResizeObserverSubscription();
  },
  _attachResizeObserverSubscription() {
    if (hasWindow()) {
      const formRootElement = this.$element().get(0);
      resize_observer_default.unobserve(formRootElement);
      resize_observer_default.observe(formRootElement, () => {
        this._resizeHandler();
      });
    }
  },
  _resizeHandler() {
    if (this._cachedLayoutManagers.length) {
      each(this._cachedLayoutManagers, (_, layoutManager) => {
        var _layoutManager$option;
        null === (_layoutManager$option = layoutManager.option("onLayoutChanged")) || void 0 === _layoutManager$option || _layoutManager$option(layoutManager.isSingleColumnMode());
      });
    }
  },
  _getCurrentScreenFactor() {
    return hasWindow() ? getCurrentScreenFactor(this.option("screenByWidth")) : "lg";
  },
  _clearCachedInstances() {
    this._itemsRunTimeInfo.clear();
    this._cachedLayoutManagers = [];
  },
  _alignLabels(layoutManager, inOneColumn) {
    this._alignLabelsInColumn({
      $container: this.$element(),
      layoutManager,
      excludeTabbed: true,
      items: this.option("items"),
      inOneColumn
    });
    triggerResizeEvent(this.$element().find(`.${TOOLBAR_CLASS}`));
  },
  _clean() {
    this._clearValidationSummary();
    this.callBase();
    this._groupsColCount = [];
    this._cachedColCountOptions = [];
    this._lastMarkupScreenFactor = void 0;
    resize_observer_default.unobserve(this.$element().get(0));
  },
  _renderScrollable() {
    const useNativeScrolling = this.option("useNativeScrolling");
    this._scrollable = new ui_scrollable_default(this.$element(), {
      useNative: !!useNativeScrolling,
      useSimulatedScrollbar: !useNativeScrolling,
      useKeyboard: false,
      direction: "both",
      bounceEnabled: false
    });
  },
  _getContent() {
    return this.option("scrollingEnabled") ? renderer_default(this._scrollable.content()) : this.$element();
  },
  _clearValidationSummary() {
    var _this$_$validationSum;
    null === (_this$_$validationSum = this._$validationSummary) || void 0 === _this$_$validationSum || _this$_$validationSum.remove();
    this._$validationSummary = void 0;
    this._validationSummary = void 0;
  },
  _renderValidationSummary() {
    this._clearValidationSummary();
    if (this.option("showValidationSummary")) {
      this._$validationSummary = renderer_default("<div>").addClass(FORM_VALIDATION_SUMMARY).appendTo(this._getContent());
      this._validationSummary = this._$validationSummary.dxValidationSummary({
        validationGroup: this._getValidationGroup()
      }).dxValidationSummary("instance");
    }
  },
  _prepareItems(items, parentIsTabbedItem, currentPath, isTabs) {
    if (items) {
      const result2 = [];
      for (let i = 0; i < items.length; i++) {
        let item = items[i];
        const path = concatPaths(currentPath, createItemPathByIndex(i, isTabs));
        const itemRunTimeInfo = {
          item,
          itemIndex: i,
          path
        };
        const guid2 = this._itemsRunTimeInfo.add(itemRunTimeInfo);
        if (isString(item)) {
          item = {
            dataField: item
          };
        }
        if (isObject(item)) {
          const preparedItem = _extends({}, item);
          itemRunTimeInfo.preparedItem = preparedItem;
          preparedItem.guid = guid2;
          this._tryPrepareGroupItemCaption(preparedItem);
          this._tryPrepareGroupItem(preparedItem);
          this._tryPrepareTabbedItem(preparedItem, path);
          this._tryPrepareItemTemplate(preparedItem);
          if (parentIsTabbedItem) {
            preparedItem.cssItemClass = FIELD_ITEM_TAB_CLASS;
          }
          if (preparedItem.items) {
            preparedItem.items = this._prepareItems(preparedItem.items, parentIsTabbedItem, path);
          }
          result2.push(preparedItem);
        } else {
          result2.push(item);
        }
      }
      return result2;
    }
  },
  _tryPrepareGroupItemCaption(item) {
    if ("group" === item.itemType) {
      item._prepareGroupCaptionTemplate = (captionTemplate) => {
        if (item.captionTemplate) {
          item.groupCaptionTemplate = this._getTemplate(captionTemplate);
        }
        item.captionTemplate = this._itemGroupTemplate.bind(this, item);
      };
      item._prepareGroupCaptionTemplate(item.captionTemplate);
    }
  },
  _tryPrepareGroupItem(item) {
    if ("group" === item.itemType) {
      item.alignItemLabels = ensureDefined(item.alignItemLabels, true);
      item._prepareGroupItemTemplate = (itemTemplate) => {
        if (item.template) {
          item.groupContentTemplate = this._getTemplate(itemTemplate);
        }
        item.template = this._itemGroupTemplate.bind(this, item);
      };
      item._prepareGroupItemTemplate(item.template);
    }
  },
  _tryPrepareTabbedItem(item, path) {
    if ("tabbed" === item.itemType) {
      item.template = this._itemTabbedTemplate.bind(this, item);
      item.tabs = this._prepareItems(item.tabs, true, path, true);
    }
  },
  _tryPrepareItemTemplate(item) {
    if (item.template) {
      item.template = this._getTemplate(item.template);
    }
  },
  _checkGrouping(items) {
    if (items) {
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if ("group" === item.itemType) {
          return true;
        }
      }
    }
  },
  _renderLayout() {
    const that = this;
    let items = that.option("items");
    const $content = that._getContent();
    items = that._prepareItems(items);
    that._rootLayoutManager = that._renderLayoutManager($content, this._createLayoutManagerOptions(items, {
      isRoot: true,
      colCount: that.option("colCount"),
      alignItemLabels: that.option("alignItemLabels"),
      screenByWidth: this.option("screenByWidth"),
      colCountByScreen: this.option("colCountByScreen"),
      onLayoutChanged(inOneColumn) {
        that._alignLabels.bind(that)(that._rootLayoutManager, inOneColumn);
      },
      onContentReady(e) {
        that._alignLabels(e.component, e.component.isSingleColumnMode());
      }
    }));
  },
  _tryGetItemsForTemplate: (item) => item.items || [],
  _itemTabbedTemplate(item, e, $container) {
    const $tabPanel = renderer_default("<div>").appendTo($container);
    const tabPanelOptions = extend({}, item.tabPanelOptions, {
      dataSource: item.tabs,
      onItemRendered: (args) => {
        var _item$tabPanelOptions, _item$tabPanelOptions2;
        null === (_item$tabPanelOptions = item.tabPanelOptions) || void 0 === _item$tabPanelOptions || null === (_item$tabPanelOptions2 = _item$tabPanelOptions.onItemRendered) || void 0 === _item$tabPanelOptions2 || _item$tabPanelOptions2.call(_item$tabPanelOptions, args);
        triggerShownEvent(args.itemElement);
      },
      itemTemplate: (itemData, e2, container) => {
        const $container2 = renderer_default(container);
        const alignItemLabels = ensureDefined(itemData.alignItemLabels, true);
        const layoutManager = this._renderLayoutManager($container2, this._createLayoutManagerOptions(this._tryGetItemsForTemplate(itemData), {
          colCount: itemData.colCount,
          alignItemLabels,
          screenByWidth: this.option("screenByWidth"),
          colCountByScreen: itemData.colCountByScreen,
          cssItemClass: itemData.cssItemClass,
          onLayoutChanged: (inOneColumn) => {
            this._alignLabelsInColumn({
              $container: $container2,
              layoutManager,
              items: itemData.items,
              inOneColumn
            });
          }
        }));
        if (this._itemsRunTimeInfo) {
          this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(itemData.guid, {
            layoutManager
          });
        }
        if (alignItemLabels) {
          this._alignLabelsInColumn({
            $container: $container2,
            layoutManager,
            items: itemData.items,
            inOneColumn: layoutManager.isSingleColumnMode()
          });
        }
      }
    });
    const tryUpdateTabPanelInstance = (items, instance) => {
      if (Array.isArray(items)) {
        items.forEach((item2) => this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(item2.guid, {
          widgetInstance: instance
        }));
      }
    };
    const tabPanel = this._createComponent($tabPanel, tab_panel_default, tabPanelOptions);
    renderer_default($container).parent().addClass(FIELD_ITEM_CONTENT_HAS_TABS_CLASS);
    tabPanel.on("optionChanged", (e2) => {
      if ("dataSource" === e2.fullName) {
        tryUpdateTabPanelInstance(e2.value, e2.component);
      }
    });
    tryUpdateTabPanelInstance([{
      guid: item.guid
    }, ...item.tabs ?? []], tabPanel);
  },
  _itemGroupCaptionTemplate(item, $group, id) {
    if (item.groupCaptionTemplate) {
      const $captionTemplate = renderer_default("<div>").addClass(FORM_GROUP_CUSTOM_CAPTION_CLASS).attr("id", id).appendTo($group);
      item._renderGroupCaptionTemplate = () => {
        const data2 = {
          component: this,
          caption: item.caption,
          name: item.name
        };
        item.groupCaptionTemplate.render({
          model: data2,
          container: getPublicElement($captionTemplate)
        });
      };
      item._renderGroupCaptionTemplate();
      return;
    }
    if (item.caption) {
      renderer_default("<span>").addClass(FORM_GROUP_CAPTION_CLASS).text(item.caption).attr("id", id).appendTo($group);
    }
  },
  _itemGroupContentTemplate(item, $group) {
    const $groupContent = renderer_default("<div>").addClass(FORM_GROUP_CONTENT_CLASS).appendTo($group);
    if (item.groupContentTemplate) {
      item._renderGroupContentTemplate = () => {
        $groupContent.empty();
        const data2 = {
          formData: this.option("formData"),
          component: this
        };
        item.groupContentTemplate.render({
          model: data2,
          container: getPublicElement($groupContent)
        });
      };
      item._renderGroupContentTemplate();
    } else {
      const layoutManager = this._renderLayoutManager($groupContent, this._createLayoutManagerOptions(this._tryGetItemsForTemplate(item), {
        colCount: item.colCount,
        colCountByScreen: item.colCountByScreen,
        alignItemLabels: item.alignItemLabels,
        cssItemClass: item.cssItemClass
      }));
      this._itemsRunTimeInfo && this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(item.guid, {
        layoutManager
      });
      const colCount = layoutManager._getColCount();
      if (!this._groupsColCount.includes(colCount)) {
        this._groupsColCount.push(colCount);
      }
      $group.addClass(GROUP_COL_COUNT_CLASS + colCount);
      $group.attr(GROUP_COL_COUNT_ATTR, colCount);
    }
  },
  _itemGroupTemplate(item, options2, $container) {
    const {
      id
    } = options2.editorOptions.inputAttr;
    const $group = renderer_default("<div>").toggleClass(FORM_GROUP_WITH_CAPTION_CLASS, isDefined(item.caption) && item.caption.length).addClass(FORM_GROUP_CLASS).appendTo($container);
    const groupAria = {
      role: "group",
      labelledby: id
    };
    this.setAria(groupAria, $group);
    renderer_default($container).parent().addClass(FIELD_ITEM_CONTENT_HAS_GROUP_CLASS);
    this._itemGroupCaptionTemplate(item, $group, id);
    this._itemGroupContentTemplate(item, $group);
  },
  _createLayoutManagerOptions(items, extendedLayoutManagerOptions) {
    return convertToLayoutManagerOptions({
      form: this,
      formOptions: this.option(),
      $formElement: this.$element(),
      items,
      validationGroup: this._getValidationGroup(),
      extendedLayoutManagerOptions,
      onFieldDataChanged: (args) => {
        if (!this._isDataUpdating) {
          this._triggerOnFieldDataChanged(args);
        }
      },
      onContentReady: (args) => {
        this._itemsRunTimeInfo.addItemsOrExtendFrom(args.component._itemsRunTimeInfo);
        extendedLayoutManagerOptions.onContentReady && extendedLayoutManagerOptions.onContentReady(args);
      },
      onDisposing: (_ref2) => {
        let {
          component
        } = _ref2;
        const nestedItemsRunTimeInfo = component.getItemsRunTimeInfo();
        this._itemsRunTimeInfo.removeItemsByItems(nestedItemsRunTimeInfo);
      },
      onFieldItemRendered: () => {
        var _this$_validationSumm;
        null === (_this$_validationSumm = this._validationSummary) || void 0 === _this$_validationSumm || _this$_validationSumm.refreshValidationGroup();
      }
    });
  },
  _renderLayoutManager($parent, layoutManagerOptions) {
    const baseColCountByScreen = {
      lg: layoutManagerOptions.colCount,
      md: layoutManagerOptions.colCount,
      sm: layoutManagerOptions.colCount,
      xs: 1
    };
    this._cachedColCountOptions.push({
      colCountByScreen: extend(baseColCountByScreen, layoutManagerOptions.colCountByScreen)
    });
    const $element = renderer_default("<div>");
    $element.appendTo($parent);
    const instance = this._createComponent($element, "dxLayoutManager", layoutManagerOptions);
    instance.on("autoColCountChanged", () => {
      this._clearAutoColCountChangedTimeout();
      this.autoColCountChangedTimeoutId = setTimeout(() => !this._disposed && this._refresh(), 0);
    });
    this._cachedLayoutManagers.push(instance);
    return instance;
  },
  _getValidationGroup() {
    return this.option("validationGroup") || this;
  },
  _createComponent($element, type2, config3) {
    config3 = config3 || {};
    this._extendConfig(config3, {
      readOnly: this.option("readOnly")
    });
    return this.callBase($element, type2, config3);
  },
  _attachSyncSubscriptions() {
    const that = this;
    that.on("optionChanged", (args) => {
      const optionFullName = args.fullName;
      if ("formData" === optionFullName) {
        if (!isDefined(args.value)) {
          that._options.silent("formData", args.value = {});
        }
        that._triggerOnFieldDataChangedByDataSet(args.value);
      }
      if (that._cachedLayoutManagers.length) {
        each(that._cachedLayoutManagers, (index2, layoutManager) => {
          if ("formData" === optionFullName) {
            that._isDataUpdating = true;
            layoutManager.option("layoutData", args.value);
            that._isDataUpdating = false;
          }
          if ("readOnly" === args.name || "disabled" === args.name) {
            layoutManager.option(optionFullName, args.value);
          }
        });
      }
    });
  },
  _optionChanged(args) {
    const splitFullName = args.fullName.split(".");
    if (splitFullName.length > 1 && -1 !== splitFullName[0].search("items") && this._itemsOptionChangedHandler(args)) {
      return;
    }
    if (splitFullName.length > 1 && -1 !== splitFullName[0].search("formData") && this._formDataOptionChangedHandler(args)) {
      return;
    }
    this._defaultOptionChangedHandler(args);
  },
  _defaultOptionChangedHandler(args) {
    switch (args.name) {
      case "formData":
        if (!this.option("items")) {
          this._invalidate();
        } else if (isEmptyObject(args.value)) {
          this._clear();
        }
        break;
      case "onFieldDataChanged":
      case "alignRootItemLabels":
      case "readOnly":
      case "isDirty":
        break;
      case "items":
      case "colCount":
      case "onEditorEnterKey":
      case "labelLocation":
      case "labelMode":
      case "alignItemLabels":
      case "showColonAfterLabel":
      case "customizeItem":
      case "alignItemLabelsInAllGroups":
      case "showRequiredMark":
      case "showOptionalMark":
      case "requiredMark":
      case "optionalMark":
      case "requiredMessage":
      case "scrollingEnabled":
      case "formID":
      case "colCountByScreen":
      case "screenByWidth":
      case "stylingMode":
        this._invalidate();
        break;
      case "showValidationSummary":
        this._renderValidationSummary();
        break;
      case "minColWidth":
        if ("auto" === this.option("colCount")) {
          this._invalidate();
        }
        break;
      case "width":
        this.callBase(args);
        this._rootLayoutManager.option(args.name, args.value);
        this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
        break;
      case "validationGroup":
        validation_engine_default.removeGroup(args.previousValue || this);
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  },
  _itemsOptionChangedHandler(args) {
    const nameParts = args.fullName.split(".");
    const {
      value: value2
    } = args;
    const itemPath = this._getItemPath(nameParts);
    const item = this.option(itemPath);
    const optionNameWithoutPath = args.fullName.replace(`${itemPath}.`, "");
    const simpleOptionName = optionNameWithoutPath.split(".")[0].replace(/\[\d+]/, "");
    const itemAction = this._tryCreateItemOptionAction(simpleOptionName, item, item[simpleOptionName], args.previousValue, itemPath);
    let result2 = this._tryExecuteItemOptionAction(itemAction) || this._tryChangeLayoutManagerItemOption(args.fullName, value2);
    if (!result2 && item) {
      this._changeItemOption(item, optionNameWithoutPath, value2);
      const items = this._generateItemsFromData(this.option("items"));
      this.option("items", items);
      result2 = true;
    }
    return result2;
  },
  _formDataOptionChangedHandler(args) {
    const nameParts = args.fullName.split(".");
    const {
      value: value2
    } = args;
    const dataField = nameParts.slice(1).join(".");
    const editor = this.getEditor(dataField);
    if (editor) {
      editor.option("value", value2);
    } else {
      this._triggerOnFieldDataChanged({
        dataField,
        value: value2
      });
    }
    return true;
  },
  _tryCreateItemOptionAction(optionName, item, value2, previousValue, itemPath) {
    if ("tabs" === optionName) {
      this._itemsRunTimeInfo.removeItemsByPathStartWith(`${itemPath}.tabs`);
      value2 = this._prepareItems(value2, true, itemPath, true);
    }
    return m_form_item_options_actions_default(optionName, {
      item,
      value: value2,
      previousValue,
      itemsRunTimeInfo: this._itemsRunTimeInfo
    });
  },
  _tryExecuteItemOptionAction: (action) => action && action.tryExecute(),
  _updateValidationGroupAndSummaryIfNeeded(fullName) {
    const optionName = getOptionNameFromFullName(fullName);
    if (ITEM_OPTIONS_FOR_VALIDATION_UPDATING.includes(optionName)) {
      validation_engine_default.addGroup(this._getValidationGroup(), false);
      if (this.option("showValidationSummary")) {
        var _this$_validationSumm2;
        null === (_this$_validationSumm2 = this._validationSummary) || void 0 === _this$_validationSumm2 || _this$_validationSumm2.refreshValidationGroup();
      }
    }
  },
  _setLayoutManagerItemOption(layoutManager, optionName, value2, path) {
    if (this._updateLockCount > 0) {
      !layoutManager._updateLockCount && layoutManager.beginUpdate();
      const key = this._itemsRunTimeInfo.findKeyByPath(path);
      this.postponedOperations.add(key, () => {
        !layoutManager._disposed && layoutManager.endUpdate();
        return Deferred().resolve();
      });
    }
    const contentReadyHandler = (e) => {
      e.component.off("contentReady", contentReadyHandler);
      if (isFullPathContainsTabs(path)) {
        const tabPath = tryGetTabPath(path);
        const tabLayoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(tabPath);
        if (tabLayoutManager) {
          this._alignLabelsInColumn({
            items: tabLayoutManager.option("items"),
            layoutManager: tabLayoutManager,
            $container: tabLayoutManager.$element(),
            inOneColumn: tabLayoutManager.isSingleColumnMode()
          });
        }
      } else {
        this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
      }
    };
    layoutManager.on("contentReady", contentReadyHandler);
    layoutManager.option(optionName, value2);
    this._updateValidationGroupAndSummaryIfNeeded(optionName);
  },
  _tryChangeLayoutManagerItemOption(fullName, value2) {
    const nameParts = fullName.split(".");
    const optionName = getOptionNameFromFullName(fullName);
    if ("items" === optionName && nameParts.length > 1) {
      const itemPath = this._getItemPath(nameParts);
      const layoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(itemPath);
      if (layoutManager) {
        this._itemsRunTimeInfo.removeItemsByItems(layoutManager.getItemsRunTimeInfo());
        const items = this._prepareItems(value2, false, itemPath);
        this._setLayoutManagerItemOption(layoutManager, optionName, items, itemPath);
        return true;
      }
    } else if (nameParts.length > 2) {
      const endPartIndex = nameParts.length - 2;
      const itemPath = this._getItemPath(nameParts.slice(0, endPartIndex));
      const layoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(itemPath);
      if (layoutManager) {
        const fullOptionName = getFullOptionName(nameParts[endPartIndex], optionName);
        if ("editorType" === optionName) {
          if (layoutManager.option(fullOptionName) !== value2) {
            return false;
          }
        }
        if ("visible" === optionName) {
          const formItems = this.option(getFullOptionName(itemPath, "items"));
          if (formItems && formItems.length) {
            const layoutManagerItems = layoutManager.option("items");
            formItems.forEach((item, index2) => {
              const layoutItem = layoutManagerItems[index2];
              layoutItem.visibleIndex = item.visibleIndex;
            });
          }
        }
        this._setLayoutManagerItemOption(layoutManager, fullOptionName, value2, itemPath);
        return true;
      }
    }
    return false;
  },
  _tryChangeLayoutManagerItemOptions(itemPath, options2) {
    let result2;
    this.beginUpdate();
    each(options2, (optionName, optionValue) => {
      result2 = this._tryChangeLayoutManagerItemOption(getFullOptionName(itemPath, optionName), optionValue);
      if (!result2) {
        return false;
      }
    });
    this.endUpdate();
    return result2;
  },
  _getItemPath(nameParts) {
    let itemPath = nameParts[0];
    let i;
    for (i = 1; i < nameParts.length; i++) {
      if (-1 !== nameParts[i].search(/items\[\d+]|tabs\[\d+]/)) {
        itemPath += `.${nameParts[i]}`;
      } else {
        break;
      }
    }
    return itemPath;
  },
  _triggerOnFieldDataChanged(args) {
    this._updateIsDirty(args.dataField);
    this._createActionByOption("onFieldDataChanged")(args);
  },
  _triggerOnFieldDataChangedByDataSet(data2) {
    if (data2 && isObject(data2)) {
      Object.keys(data2).forEach((key) => {
        this._triggerOnFieldDataChanged({
          dataField: key,
          value: data2[key]
        });
      });
    }
  },
  _updateFieldValue(dataField, value2) {
    if (isDefined(this.option("formData"))) {
      const editor = this.getEditor(dataField);
      this.option(`formData.${dataField}`, value2);
      if (editor) {
        const editorValue = editor.option("value");
        if (editorValue !== value2) {
          editor.option("value", value2);
        }
      }
    }
  },
  _generateItemsFromData(items) {
    const formData = this.option("formData");
    const result2 = [];
    if (!items && isDefined(formData)) {
      each(formData, (dataField) => {
        result2.push({
          dataField
        });
      });
    }
    if (items) {
      each(items, (index2, item) => {
        if (isObject(item)) {
          result2.push(item);
        } else {
          result2.push({
            dataField: item
          });
        }
      });
    }
    return result2;
  },
  _getItemByField(field, items) {
    const that = this;
    const fieldParts = isObject(field) ? field : that._getFieldParts(field);
    const {
      fieldName
    } = fieldParts;
    const {
      fieldPath
    } = fieldParts;
    let resultItem;
    if (items.length) {
      each(items, (index2, item) => {
        const {
          itemType
        } = item;
        if (fieldPath.length) {
          const path = fieldPath.slice();
          item = that._getItemByFieldPath(path, fieldName, item);
        } else if ("group" === itemType && !(item.caption || item.name) || "tabbed" === itemType && !item.name) {
          const subItemsField = that._getSubItemField(itemType);
          item.items = that._generateItemsFromData(item.items);
          item = that._getItemByField({
            fieldName,
            fieldPath
          }, item[subItemsField]);
        }
        if (isEqualToDataFieldOrNameOrTitleOrCaption(item, fieldName)) {
          resultItem = item;
          return false;
        }
      });
    }
    return resultItem;
  },
  _getFieldParts(field) {
    let fieldName = field;
    let separatorIndex = fieldName.indexOf(".");
    const resultPath = [];
    while (-1 !== separatorIndex) {
      resultPath.push(fieldName.substr(0, separatorIndex));
      fieldName = fieldName.substr(separatorIndex + 1);
      separatorIndex = fieldName.indexOf(".");
    }
    return {
      fieldName,
      fieldPath: resultPath.reverse()
    };
  },
  _getItemByFieldPath(path, fieldName, item) {
    const that = this;
    const {
      itemType
    } = item;
    const subItemsField = that._getSubItemField(itemType);
    const isItemWithSubItems = "group" === itemType || "tabbed" === itemType || item.title;
    let result2;
    do {
      if (isItemWithSubItems) {
        const name2 = item.name || item.caption || item.title;
        const isGroupWithName = isDefined(name2);
        const nameWithoutSpaces = getTextWithoutSpaces(name2);
        let pathNode;
        item[subItemsField] = that._generateItemsFromData(item[subItemsField]);
        if (isGroupWithName) {
          pathNode = path.pop();
        }
        if (!path.length) {
          result2 = that._getItemByField(fieldName, item[subItemsField]);
          if (result2) {
            break;
          }
        }
        if (!isGroupWithName || isGroupWithName && nameWithoutSpaces === pathNode) {
          if (path.length) {
            result2 = that._searchItemInEverySubItem(path, fieldName, item[subItemsField]);
          }
        }
      } else {
        break;
      }
    } while (path.length && !isDefined(result2));
    return result2;
  },
  _getSubItemField: (itemType) => "tabbed" === itemType ? "tabs" : "items",
  _searchItemInEverySubItem(path, fieldName, items) {
    const that = this;
    let result2;
    each(items, (index2, groupItem) => {
      result2 = that._getItemByFieldPath(path.slice(), fieldName, groupItem);
      if (result2) {
        return false;
      }
    });
    if (!result2) {
      result2 = false;
    }
    return result2;
  },
  _changeItemOption(item, option, value2) {
    if (isObject(item)) {
      item[option] = value2;
    }
  },
  _dimensionChanged() {
    const currentScreenFactor = this._getCurrentScreenFactor();
    if (this._lastMarkupScreenFactor !== currentScreenFactor) {
      if (this._isColCountChanged(this._lastMarkupScreenFactor, currentScreenFactor)) {
        this._targetScreenFactor = currentScreenFactor;
        this._refresh();
        this._targetScreenFactor = void 0;
      }
      this._lastMarkupScreenFactor = currentScreenFactor;
    }
  },
  _isColCountChanged(oldScreenSize, newScreenSize) {
    let isChanged = false;
    each(this._cachedColCountOptions, (index2, item) => {
      if (item.colCountByScreen[oldScreenSize] !== item.colCountByScreen[newScreenSize]) {
        isChanged = true;
        return false;
      }
    });
    return isChanged;
  },
  _refresh() {
    events_engine_default.trigger(this.$element().find(".dx-state-focused > :not(.dx-dropdowneditor-input-wrapper) input, .dx-state-focused textarea"), "change");
    this.callBase();
  },
  _updateIsDirty(dataField) {
    const editor = this.getEditor(dataField);
    if (!editor) {
      return;
    }
    if (editor.option("isDirty")) {
      this._dirtyFields.add(dataField);
    } else {
      this._dirtyFields.delete(dataField);
    }
    this.option("isDirty", !!this._dirtyFields.size);
  },
  updateRunTimeInfoForEachEditor(editorAction) {
    this._itemsRunTimeInfo.each((_, itemRunTimeInfo) => {
      const {
        widgetInstance
      } = itemRunTimeInfo;
      if (isDefined(widgetInstance) && editor_default.isEditor(widgetInstance)) {
        editorAction(widgetInstance);
      }
    });
  },
  _clear() {
    this.updateRunTimeInfoForEachEditor((editor) => {
      editor.clear();
      editor.option("isValid", true);
    });
    validation_engine_default.resetGroup(this._getValidationGroup());
  },
  _updateData(data2, value2, isComplexData) {
    const that = this;
    const _data = isComplexData ? value2 : data2;
    if (isObject(_data)) {
      each(_data, (dataField, fieldValue) => {
        that._updateData(isComplexData ? `${data2}.${dataField}` : dataField, fieldValue, isObject(fieldValue));
      });
    } else if (isString(data2)) {
      that._updateFieldValue(data2, value2);
    }
  },
  registerKeyHandler(key, handler) {
    this.callBase(key, handler);
    this._itemsRunTimeInfo.each((_, itemRunTimeInfo) => {
      if (isDefined(itemRunTimeInfo.widgetInstance)) {
        itemRunTimeInfo.widgetInstance.registerKeyHandler(key, handler);
      }
    });
  },
  _focusTarget() {
    return this.$element().find(`.${FIELD_ITEM_CONTENT_CLASS} [tabindex]`).first();
  },
  _visibilityChanged() {
    this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
  },
  _clearAutoColCountChangedTimeout() {
    if (this.autoColCountChangedTimeoutId) {
      clearTimeout(this.autoColCountChangedTimeoutId);
      this.autoColCountChangedTimeoutId = void 0;
    }
  },
  _dispose() {
    this._clearAutoColCountChangedTimeout();
    validation_engine_default.removeGroup(this._getValidationGroup());
    this.callBase();
  },
  clear() {
    this._clear();
  },
  resetValues() {
    this._clear();
  },
  reset(editorsData) {
    this.updateRunTimeInfoForEachEditor((editor) => {
      const editorName = editor.option("name");
      if (editorsData && editorName in editorsData) {
        editor.reset(editorsData[editorName]);
      } else {
        editor.reset();
      }
    });
    this._renderValidationSummary();
  },
  updateData(data2, value2) {
    this._updateData(data2, value2);
  },
  getEditor(dataField) {
    return this._itemsRunTimeInfo.findWidgetInstanceByDataField(dataField) || this._itemsRunTimeInfo.findWidgetInstanceByName(dataField);
  },
  getButton(name2) {
    return this._itemsRunTimeInfo.findWidgetInstanceByName(name2);
  },
  updateDimensions() {
    const that = this;
    const deferred = Deferred();
    if (that._scrollable) {
      that._scrollable.update().done(() => {
        deferred.resolveWith(that);
      });
    } else {
      deferred.resolveWith(that);
    }
    return deferred.promise();
  },
  itemOption(id, option, value2) {
    const items = this._generateItemsFromData(this.option("items"));
    const item = this._getItemByField(id, items);
    const path = getItemPath(items, item);
    if (!item) {
      return;
    }
    switch (arguments.length) {
      case 1:
        return item;
      case 3: {
        const itemAction = this._tryCreateItemOptionAction(option, item, value2, item[option], path);
        this._changeItemOption(item, option, value2);
        const fullName = getFullOptionName(path, option);
        if (!this._tryExecuteItemOptionAction(itemAction) && !this._tryChangeLayoutManagerItemOption(fullName, value2)) {
          this.option("items", items);
        }
        break;
      }
      default:
        if (isObject(option)) {
          if (!this._tryChangeLayoutManagerItemOptions(path, option)) {
            let allowUpdateItems;
            each(option, (optionName, optionValue) => {
              const itemAction = this._tryCreateItemOptionAction(optionName, item, optionValue, item[optionName], path);
              this._changeItemOption(item, optionName, optionValue);
              if (!allowUpdateItems && !this._tryExecuteItemOptionAction(itemAction)) {
                allowUpdateItems = true;
              }
            });
            allowUpdateItems && this.option("items", items);
          }
        }
    }
  },
  validate() {
    return validation_engine_default.validateGroup(this._getValidationGroup());
  },
  getItemID(name2) {
    return `dx_${this.option("formID")}_${name2 || new guid_default()}`;
  },
  getTargetScreenFactor() {
    return this._targetScreenFactor;
  }
});
component_registrator_default("dxForm", Form);
var m_form_default = Form;

// ../../../../../../node_modules/devextreme/esm/ui/form/ui.form.js
var ui_form_default = m_form_default;

// ../../../../../../node_modules/devextreme/esm/ui/form.js
var form_default = ui_form_default;

// ../../../../../../node_modules/devextreme-vue/esm/core/strategy/vue2/index.js
var vue2_exports = {};
__export(vue2_exports, {
  createComponent: () => createComponent,
  createConfigurationComponent: () => createConfigurationComponent,
  createExtensionComponent: () => createExtensionComponent
});
function createComponent() {
  throw new Error("Since v23.2, devextreme-vue no longer supports Vue 2. See: https://supportcenter.devexpress.com/ticket/details/T1186771");
}
function createConfigurationComponent() {
}
function createExtensionComponent() {
}

// ../../../../../../node_modules/devextreme-vue/esm/core/strategy/vue3/index.js
var vue3_exports = {};
__export(vue3_exports, {
  createComponent: () => createComponent2,
  createConfigurationComponent: () => createConfigurationComponent2,
  createExtensionComponent: () => createExtensionComponent2
});

// ../../../../../../node_modules/devextreme/esm/events/index.js
var on = events_engine_default.on;
var one = events_engine_default.one;
var off = events_engine_default.off;
var trigger = events_engine_default.trigger;
var triggerHandler = events_engine_default.triggerHandler;
var Event = events_engine_default.Event;

// ../../../../../../node_modules/devextreme-vue/esm/core/helpers.js
function getTemplatePropName(props, templateName) {
  for (const propName in props) {
    if (props[propName] === templateName) {
      return propName;
    }
  }
  return templateName;
}
function uppercaseFirst(value2) {
  return value2[0].toUpperCase() + value2.substr(1);
}
function lowercaseFirst(value2) {
  return value2[0].toLowerCase() + value2.substr(1);
}
function camelize2(value2) {
  return lowercaseFirst(value2.split("-").map((v) => uppercaseFirst(v)).join(""));
}
function toComparable2(value2) {
  return value2 instanceof Date ? value2.getTime() : value2;
}
function isEqual(value1, value2) {
  if (toComparable2(value1) === toComparable2(value2)) {
    return true;
  }
  if (Array.isArray(value1) && Array.isArray(value2)) {
    return value1.length === 0 && value2.length === 0;
  }
  return false;
}
function forEachChildNode(el, callback) {
  Array.prototype.slice.call(el.childNodes).forEach(callback);
}
function allKeysAreEqual(obj1, obj2) {
  const obj1Keys = Object.keys(obj1);
  if (obj1Keys.length !== Object.keys(obj2).length) {
    return false;
  }
  for (const key of obj1Keys) {
    if (!obj2.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}
function getOptionValue(options2, optionPath) {
  let value2 = options2;
  optionPath.split(".").forEach((p2) => {
    const optionInfo = getOptionInfo(p2);
    if (value2) {
      value2 = optionInfo.isCollection ? value2[optionInfo.name] && value2[optionInfo.name][optionInfo.index] : value2[optionInfo.name];
    }
  });
  return value2;
}
function getOptionInfo(name2) {
  const parts = name2.split("[");
  if (parts.length === 1) {
    return {
      isCollection: false,
      name: name2,
      fullName: name2
    };
  }
  return {
    isCollection: true,
    name: parts[0],
    fullName: name2,
    index: Number(parts[1].slice(0, -1))
  };
}

// ../../../../../../node_modules/devextreme-vue/esm/core/children-processing.js
function pullAllChildren(directChildren, allChildren, config3) {
  if (!directChildren || directChildren.length === 0) {
    return;
  }
  pullConfigComponents(directChildren, allChildren, config3);
}
function isFragment(node) {
  const { patchFlag } = node;
  return patchFlag === 128 || patchFlag === 256 || patchFlag === 64 || patchFlag === -2;
}
function pullConfigComponents(children, nodes, ownerConfig) {
  children.forEach((node) => {
    if (isFragment(node) && Array.isArray(node.children)) {
      pullConfigComponents(node.children, nodes, ownerConfig);
    }
    if (!isFragment(node)) {
      nodes.push(node);
    }
    if (!node) {
      return;
    }
    const componentInfo = getComponentInfo(node);
    if (!componentInfo || !componentInfo.$_optionName) {
      return;
    }
    const componentChildren = configurationChildren(node);
    const initialValues = {
      ...componentInfo.$_predefinedProps,
      ...getNormalizedProps(node.props || {})
    };
    const config3 = ownerConfig.createNested(componentInfo.$_optionName, initialValues, componentInfo.$_isCollectionItem, componentInfo.$_expectedChildren);
    node.$_config = config3;
    node.$_innerChanges = {};
    if (componentChildren) {
      pullConfigComponents(componentChildren, nodes, config3);
    }
  });
}

// ../../../../../../node_modules/devextreme-vue/esm/core/vue-helper.js
var VMODEL_NAME = "modelValue";
function getChildren(component) {
  if (!hasChildren(component) || !component.$_config) {
    return [];
  }
  const children = component.$.subTree && component.$.subTree.children;
  if (!Array.isArray(children)) {
    return [];
  }
  return children.filter((child) => {
    if (!isFragment(child)) {
      return child;
    }
  });
}
function getComponentInfo(component) {
  return getConfigurationOptions(component);
}
function getNormalizedProps(props) {
  const result2 = {};
  for (const propName in props) {
    if (props.hasOwnProperty(propName)) {
      result2[camelize2(propName)] = props[propName];
    }
  }
  return result2;
}
function configurationChildren(component) {
  if (!component.children || !component.children.default) {
    return [];
  }
  return findConfigurationComponents(component.children.default());
}
function configurationDefaultTemplate(node) {
  if (!node.children || node.children === "object" || !node.children.default) {
    return;
  }
  return hasInlineTemplate(node.children.default()) ? node.children.default : void 0;
}
function configurationTemplate(node) {
  return configurationDefaultTemplate(node);
}
function declaredTemplates(component) {
  return component.$slots;
}
function defaultSlots(component) {
  const templates = declaredTemplates(component);
  if (!templates.default) {
    return [];
  }
  return templates.default();
}
function mount2(options2, parent, el) {
  const template = createApp(options2);
  template.provide("eventBus", parent.eventBus);
  setAppContext(template, parent);
  return template.mount(el);
}
function getComponentProps(component) {
  const props = component.$.vnode.props || {};
  return getNormalizedProps(props);
}
function getNodeOptions(component) {
  if (component.$) {
    return component.$.vnode;
  }
  return component;
}
function getNodeTypeOfComponent(component) {
  return component.$.vnode.type;
}
function getVModelValue(options2) {
  return options2[VMODEL_NAME];
}
function setCompatOptions(component) {
  component.compatConfig = {
    MODE: 3
  };
}
function setVModel(config3) {
  const eventName = `update:${VMODEL_NAME}`;
  config3.model.prop = VMODEL_NAME;
  config3.model.event = eventName;
  config3.props.modelValue = {};
  config3.emits = { ...config3.emits, [`${eventName}`]: null };
}
function setCustomPluginsData(appContext, parentAppContext) {
  for (const prop in parentAppContext) {
    if (!appContext.hasOwnProperty(prop) && parentAppContext.hasOwnProperty(prop)) {
      appContext[prop] = parentAppContext[prop];
    }
  }
}
function setAppContext(template, parent) {
  template._context.components = Object.assign(parent.$.appContext.components, template._context.components);
  Object.setPrototypeOf(template._context.provides, Object.getPrototypeOf(parent.$.provides));
  Object.assign(template._context.provides, parent.$.appContext.provides);
  template._context.config = parent.$.appContext.config;
  template._context.directives = parent.$.appContext.directives;
  template._context.mixins = parent.$.appContext.mixins;
  setCustomPluginsData(template._context.app, parent.$.appContext.app);
}
function findConfigurationComponents(children) {
  return children.filter((child) => {
    if (isFragment(child)) {
      return findConfigurationComponents(child.children || []);
    }
    const childType = child.type;
    if (childType && typeof childType === "object" && childType.$_optionName) {
      delete child.$_config;
      delete child.$_innerChanges;
      return child;
    }
  });
}
function hasInlineTemplate(children) {
  let hasTemplate3 = false;
  children.forEach((child) => {
    if (!isConfiguration(child) && !isFragment(child) && !isComment(child)) {
      hasTemplate3 = true;
    }
  });
  return hasTemplate3;
}
function isComment(node) {
  return node.type === Comment || node.type.toString() === "Symbol()" && !node.children;
}
function isConfiguration(child) {
  return child.type && typeof child.type === "object" && child.type.$_optionName;
}
function getConfigurationOptions(node) {
  return node.type;
}
function hasChildren(component) {
  return component.$.vnode && component.$.vnode.children && component.$.vnode.children.default;
}

// ../../../../../../node_modules/devextreme-vue/esm/core/config.js
var config2 = {
  deepWatch: false
};
function getOption(optionName) {
  return config2[optionName];
}

// ../../../../../../node_modules/devextreme-vue/esm/core/configuration.js
var Configuration = class _Configuration {
  constructor(updateFunc, name2, initialValues, expectedChildren, isCollectionItem, collectionItemIndex, ownerConfig) {
    this._updateFunc = updateFunc;
    this._name = name2;
    this._initialValues = initialValues || {};
    this._nestedConfigurations = [];
    this._isCollectionItem = !!isCollectionItem;
    this._collectionItemIndex = collectionItemIndex;
    this._expectedChildren = expectedChildren || {};
    this._ownerConfig = ownerConfig;
    this._componentChanges = [];
    this.updateValue = this.updateValue.bind(this);
  }
  get name() {
    return this._name;
  }
  get fullName() {
    return this._name && this._isCollectionItem ? `${this._name}[${this._collectionItemIndex}]` : this._name;
  }
  get componentsCountChanged() {
    return this._componentChanges;
  }
  cleanComponentsCountChanged() {
    this._componentChanges = [];
  }
  get fullPath() {
    return this._ownerConfig && this._ownerConfig.fullPath ? `${this._ownerConfig.fullPath}.${this.fullName}` : this.fullName;
  }
  get ownerConfig() {
    return this._ownerConfig;
  }
  get options() {
    return this._options;
  }
  get initialValues() {
    return this._initialValues;
  }
  get expectedChildren() {
    return this._expectedChildren;
  }
  get nested() {
    return this._nestedConfigurations;
  }
  get prevNestedOptions() {
    return this._prevNestedConfigOptions;
  }
  get collectionItemIndex() {
    return this._collectionItemIndex;
  }
  get isCollectionItem() {
    return this._isCollectionItem;
  }
  get updateFunc() {
    return this._updateFunc;
  }
  init(options2) {
    this._options = options2 || [];
  }
  set emitOptionChanged(handler) {
    this._emitOptionChanged = handler;
  }
  setPrevNestedOptions(value2) {
    this._prevNestedConfigOptions = value2;
  }
  onOptionChanged(args) {
    if (isEqual(args.value, args.previousValue)) {
      return;
    }
    this._onOptionChanged(args.fullName.split("."), args);
  }
  cleanNested() {
    this._nestedConfigurations = [];
  }
  createNested(name2, initialValues, isCollectionItem, expectedChildren) {
    const expected = this._expectedChildren[name2];
    let actualName = name2;
    let actualIsCollectionItem = isCollectionItem;
    if (expected) {
      actualIsCollectionItem = expected.isCollectionItem;
      if (expected.optionName) {
        actualName = expected.optionName;
      }
    }
    let collectionItemIndex = -1;
    if (actualIsCollectionItem && actualName) {
      collectionItemIndex = this._nestedConfigurations.filter((c) => c._name && c._name === actualName).length;
    }
    const configuration = new _Configuration(this._updateFunc, actualName, initialValues, expectedChildren, actualIsCollectionItem, collectionItemIndex, this);
    this._nestedConfigurations.push(configuration);
    return configuration;
  }
  updateValue(nestedName, value2) {
    const fullName = [this.fullPath, nestedName].filter((n) => n).join(".");
    this._updateFunc(fullName, value2);
  }
  getNestedOptionValues() {
    const values = {};
    this._nestedConfigurations.forEach((o) => {
      if (!o._name) {
        return;
      }
      const nestedValue = { ...o.initialValues, ...o.getNestedOptionValues() };
      if (!nestedValue) {
        return;
      }
      if (!o._isCollectionItem) {
        values[o._name] = nestedValue;
      } else {
        let arr = values[o._name];
        if (!arr || !Array.isArray(arr)) {
          arr = [];
          values[o._name] = arr;
        }
        arr.push(nestedValue);
      }
    });
    return values;
  }
  getOptionsToWatch() {
    const blackList = {};
    this._nestedConfigurations.forEach((c) => c._name && (blackList[c._name] = true));
    return this._options.filter((o) => !blackList[o]);
  }
  _onOptionChanged(optionRelPath, args) {
    if (optionRelPath.length === 0) {
      return;
    }
    const optionInfo = getOptionInfo(optionRelPath[0]);
    if (optionInfo.isCollection || optionRelPath.length > 1) {
      const nestedConfig = this._getNestedConfig(optionInfo.fullName);
      if (nestedConfig) {
        nestedConfig._onOptionChanged(optionRelPath.slice(1), args);
        return;
      }
      this._tryEmitOptionChanged(optionInfo.name, args.component.option(this.fullPath ? `${this.fullPath}.${optionInfo.name}` : optionInfo.name));
    } else {
      this._tryEmitOptionChanged(optionInfo.name, args.value);
    }
  }
  _getNestedConfig(fullName) {
    for (const nestedConfig of this._nestedConfigurations) {
      if (nestedConfig.fullName === fullName) {
        return nestedConfig;
      }
    }
    return void 0;
  }
  _tryEmitOptionChanged(name2, value2) {
    if (this._emitOptionChanged) {
      this._emitOptionChanged(name2, value2);
    }
  }
};
function bindOptionWatchers(config3, vueInstance, innerChanges) {
  const targets = config3 && config3.getOptionsToWatch();
  if (targets) {
    targets.forEach((optionName) => {
      vueInstance.$watch(optionName, (value2) => {
        const rawValue = toRaw(value2);
        if (!innerChanges.hasOwnProperty(optionName) || innerChanges[optionName] !== rawValue) {
          config3.updateValue(optionName, value2);
        }
        delete innerChanges[optionName];
      }, { deep: getOption("deepWatch") });
    });
  }
}
function hasProp(vueInstance, propName) {
  const { props } = vueInstance.$options;
  return props && props.hasOwnProperty(propName);
}
function hasVModelValue(options2, props, vnode) {
  var _a;
  return options2.model && props.hasOwnProperty(VMODEL_NAME) && ((_a = vnode == null ? void 0 : vnode.props) == null ? void 0 : _a.hasOwnProperty(VMODEL_NAME));
}
function setEmitOptionChangedFunc(config3, vueInstance, innerChanges) {
  config3.emitOptionChanged = (name2, value2) => {
    var _a;
    const props = vueInstance.$props;
    const vnode = (_a = vueInstance == null ? void 0 : vueInstance.$) == null ? void 0 : _a.vnode;
    if (hasProp(vueInstance, name2) && !isEqual(value2, props[name2]) && vueInstance.$emit) {
      innerChanges[name2] = toRaw(value2);
      const eventName = name2 === "value" && hasVModelValue(vueInstance.$options, props, vnode) ? `update:${VMODEL_NAME}` : `update:${name2}`;
      vueInstance.$emit(eventName, value2);
    }
  };
}
var configuration_default = Configuration;

// ../../../../../../node_modules/devextreme-vue/esm/core/configuration-component.js
function getConfig(vueInstance) {
  const componentOptions = getNodeOptions(vueInstance);
  if (!componentOptions) {
    return;
  }
  return componentOptions.$_config || vueInstance.$_config;
}
function getInnerChanges(vueInstance) {
  const componentOptions = getNodeOptions(vueInstance);
  if (!componentOptions) {
    return;
  }
  return componentOptions.$_innerChanges || vueInstance.$_innerChanges;
}
function initOptionChangedFunc(config3, props, vueInstance, innerChanges) {
  if (!config3) {
    return;
  }
  config3.init(Object.keys(props));
  if (vueInstance) {
    setEmitOptionChangedFunc(config3, vueInstance, innerChanges);
  }
}
function getComponentInfo2({ name: name2, isCollectionItem, ownerConfig }, removed) {
  const parentPath = ownerConfig && ownerConfig.fullPath;
  const optionPath = name2 && parentPath ? `${parentPath}.${name2}` : name2 || "";
  return {
    optionPath,
    isCollection: isCollectionItem,
    removed
  };
}
function initDxConfiguration() {
  return defineComponent({
    beforeMount() {
      const thisComponent = this;
      const config3 = getConfig(thisComponent);
      const innerChanges = getInnerChanges(thisComponent);
      initOptionChangedFunc(config3, getNodeTypeOfComponent(thisComponent).props, thisComponent, innerChanges);
      bindOptionWatchers(config3, this, innerChanges);
    },
    mounted() {
      if (this.$parent.$_instance) {
        this.$parent.$_config.componentsCountChanged.push(getComponentInfo2(getConfig(this)));
      }
    },
    beforeUnmount() {
      const config3 = getConfig(this);
      if (config3) {
        this.$parent.$_config.componentsCountChanged.push(getComponentInfo2(config3, true));
      }
    },
    render() {
      return null;
    }
  });
}

// ../../../../../../node_modules/devextreme-vue/esm/core/constants.js
var DX_TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var DX_REMOVE_EVENT = "dxremove";

// ../../../../../../node_modules/devextreme-vue/esm/core/templates-discovering.js
var TEMPLATE_PROP = "template";
function asConfigurable(component) {
  const componentOptions = component;
  if (!componentOptions) {
    return;
  }
  if (!componentOptions.$_config || !componentOptions.$_config.name) {
    return void 0;
  }
  return componentOptions;
}
function hasTemplate2(component) {
  return TEMPLATE_PROP in component.type.props && configurationTemplate(component);
}
function discover(component) {
  const templates = {};
  const namedTeplates = declaredTemplates(component);
  for (const slotName in namedTeplates) {
    if (slotName === "default" && component.$slots.default) {
      continue;
    }
    const slot = namedTeplates[slotName];
    if (!slot) {
      continue;
    }
    templates[slotName] = slot;
  }
  const componentChildren = getChildren(component);
  for (const childComponent of componentChildren) {
    const configurable = asConfigurable(childComponent);
    if (!configurable) {
      continue;
    }
    const defaultSlot = configurationDefaultTemplate(childComponent);
    if (!defaultSlot || !hasTemplate2(childComponent)) {
      continue;
    }
    const templateName = `${configurable.$_config.fullPath}.${TEMPLATE_PROP}`;
    templates[templateName] = defaultSlot;
  }
  return templates;
}
function clearConfiguration(content) {
  const newContent = [];
  content.forEach((item) => {
    const configurable = getConfigurationOptions(item);
    if (!configurable || !configurable.$_optionName) {
      newContent.push(item);
    }
  });
  return newContent;
}
function mountTemplate(getSlot, parent, data2, name2, placeholder) {
  return mount2({
    name: name2,
    inject: ["eventBus"],
    created() {
      this.eventBus.add(this.$_updatedHandler);
    },
    mounted() {
      data2.onRendered();
    },
    unmounted() {
      this.eventBus.remove(this.$_updatedHandler);
    },
    methods: {
      $_updatedHandler() {
        this.$forceUpdate();
      }
    },
    render: () => {
      const content = clearConfiguration(getSlot()(data2));
      if (!content) {
        return h("div");
      }
      return content.length > 1 ? content : content[0];
    }
  }, parent, placeholder);
}

// ../../../../../../node_modules/devextreme-vue/esm/core/templates-manager.js
var TemplatesManager = class {
  constructor(component) {
    this._slots = {};
    this._templates = {};
    this._isDirty = false;
    this._component = component;
    this.discover();
  }
  discover() {
    this._slots = {
      ...discover(this._component)
    };
    if (!allKeysAreEqual(this._templates, this._slots)) {
      this._prepareTemplates();
    }
  }
  get templates() {
    return this._templates;
  }
  get isDirty() {
    return this._isDirty;
  }
  resetDirtyFlag() {
    this._isDirty = false;
  }
  _prepareTemplates() {
    this._templates = {};
    for (const name2 of Object.keys(this._slots)) {
      this._templates[name2] = this.createDxTemplate(name2);
    }
    this._isDirty = true;
  }
  createDxTemplate(name2) {
    return {
      render: (data2) => {
        const rendered = ((onRendered, counter = 0) => () => {
          if (counter === 1 && onRendered) {
            onRendered();
          }
          counter++;
        })(data2.onRendered);
        const scopeData = { data: data2.model, index: data2.index, onRendered: rendered };
        const placeholder = document.createElement("div");
        const container = data2.container.get ? data2.container.get(0) : data2.container;
        container.appendChild(placeholder);
        const mountedTemplate = mountTemplate(() => this._slots[name2], this._component, scopeData, name2, placeholder);
        const element = mountedTemplate.$el;
        container.removeChild(placeholder);
        while (placeholder.firstChild) {
          container.appendChild(placeholder.firstChild);
        }
        dom_adapter_default.setClass(element, DX_TEMPLATE_WRAPPER_CLASS, true);
        if (element.nodeType === Node.TEXT_NODE) {
          const removalListener = document.createElement(container.nodeName === "TABLE" ? "tbody" : "span");
          removalListener.style.display = "none";
          container.appendChild(removalListener);
          one(removalListener, DX_REMOVE_EVENT, mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate));
        } else {
          one(element, DX_REMOVE_EVENT, mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate));
        }
        rendered();
        return element;
      }
    };
  }
};

// ../../../../../../node_modules/devextreme-vue/esm/core/component.js
var includeAttrs = ["id", "class", "style"];
config_default({
  buyNowLink: "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeVue.aspx"
});
function getAttrs(attrs, dxClasses) {
  const attributes = {};
  includeAttrs.forEach((attr) => {
    const attrValue = attrs[attr];
    if (attrValue) {
      attributes[attr] = attr === "class" && dxClasses.length ? `${attrValue} ${dxClasses.join(" ")}` : attrValue;
    }
  });
  return attributes;
}
function initBaseComponent() {
  return defineComponent({
    inheritAttrs: false,
    data() {
      return {
        eventBus: callbacks_default()
      };
    },
    provide() {
      return {
        eventBus: this.eventBus
      };
    },
    render() {
      const thisComponent = this;
      const children = [];
      const dxClasses = pickOutDxClasses(this.$el) || [];
      if (thisComponent.$_config.cleanNested) {
        thisComponent.$_config.cleanNested();
      }
      pullAllChildren(defaultSlots(this), children, thisComponent.$_config);
      this.$_processChildren(children);
      return h("div", {
        ...getAttrs(this.$attrs, dxClasses)
      }, children);
    },
    beforeUpdate() {
      const thisComponent = this;
      thisComponent.$_config.setPrevNestedOptions(thisComponent.$_config.getNestedOptionValues());
    },
    updated() {
      const thisComponent = this;
      const nodes = cleanWidgetNode(this.$el);
      getChildren(thisComponent).forEach((child) => {
        var _a;
        initOptionChangedFunc(child.$_config, child.type.props || {}, (_a = child == null ? void 0 : child.component) == null ? void 0 : _a.proxy, child.$_innerChanges);
      });
      thisComponent.$_templatesManager.discover();
      thisComponent.$_instance.beginUpdate();
      this.$_applyConfigurationChanges();
      if (thisComponent.$_templatesManager.isDirty) {
        thisComponent.$_instance.option("integrationOptions.templates", thisComponent.$_templatesManager.templates);
        const { props } = thisComponent.$.vnode;
        for (const name2 of Object.keys(thisComponent.$_templatesManager.templates)) {
          thisComponent.$_instance.option(getTemplatePropName(props, name2), name2);
        }
        thisComponent.$_templatesManager.resetDirtyFlag();
      }
      for (const name2 of Object.keys(thisComponent.$_pendingOptions)) {
        thisComponent.$_instance.option(name2, thisComponent.$_pendingOptions[name2]);
      }
      thisComponent.$_pendingOptions = {};
      thisComponent.$_instance.endUpdate();
      restoreNodes(this.$el, nodes);
      this.eventBus.fire();
    },
    beforeUnmount() {
      const thisComponent = this;
      const instance = thisComponent.$_instance;
      if (instance) {
        triggerHandler(this.$el, DX_REMOVE_EVENT);
        instance.dispose();
      }
    },
    created() {
      const thisComponent = this;
      const props = getComponentProps(this);
      thisComponent.$_config = new configuration_default((n, v) => {
        if (Array.isArray(v)) {
          thisComponent.$_instance.option(n, v);
        } else {
          thisComponent.$_pendingOptions[n === VMODEL_NAME ? "value" : n] = v;
        }
      }, null, props && { ...props }, thisComponent.$_expectedChildren);
      thisComponent.$_innerChanges = {};
      thisComponent.$_config.init(this.$props && Object.keys(this.$props));
    },
    methods: {
      $_applyConfigurationChanges() {
        const thisComponent = this;
        thisComponent.$_config.componentsCountChanged.forEach(({ optionPath, isCollection, removed }) => {
          const options2 = thisComponent.$_config.getNestedOptionValues();
          if (!isCollection && removed) {
            thisComponent.$_instance.resetOption(optionPath);
          } else {
            thisComponent.$_instance.option(optionPath, getOptionValue(options2, optionPath));
          }
        });
        thisComponent.$_config.cleanComponentsCountChanged();
      },
      $_createWidget(element) {
        const thisComponent = this;
        thisComponent.$_pendingOptions = {};
        thisComponent.$_templatesManager = new TemplatesManager(this);
        const widgetConfig = thisComponent.$_config;
        if (widgetConfig.initialValues.hasOwnProperty(VMODEL_NAME)) {
          widgetConfig.initialValues.value = getVModelValue(widgetConfig.initialValues);
        }
        const options2 = {
          templatesRenderAsynchronously: thisComponent.$_hasAsyncTemplate,
          ...getComponentProps(thisComponent),
          ...widgetConfig.initialValues,
          ...widgetConfig.getNestedOptionValues(),
          ...this.$_getIntegrationOptions()
        };
        const instance = new thisComponent.$_WidgetClass(element, options2);
        thisComponent.$_instance = instance;
        instance.on("optionChanged", (args) => widgetConfig.onOptionChanged(args));
        setEmitOptionChangedFunc(widgetConfig, thisComponent, thisComponent.$_innerChanges);
        bindOptionWatchers(widgetConfig, thisComponent, thisComponent.$_innerChanges);
        this.$_createEmitters(instance);
      },
      $_getIntegrationOptions() {
        const thisComponent = this;
        const result2 = {
          integrationOptions: {
            watchMethod: this.$_getWatchMethod()
          },
          ...this.$_getExtraIntegrationOptions()
        };
        if (thisComponent.$_templatesManager.isDirty) {
          const { templates } = thisComponent.$_templatesManager;
          result2.integrationOptions.templates = templates;
          const { props } = thisComponent.$.vnode;
          for (const name2 of Object.keys(templates)) {
            result2[getTemplatePropName(props, name2)] = name2;
          }
          thisComponent.$_templatesManager.resetDirtyFlag();
        }
        return result2;
      },
      $_getWatchMethod() {
        return (valueGetter, valueChangeCallback, options2) => {
          options2 = options2 || {};
          if (!options2.skipImmediate) {
            valueChangeCallback(valueGetter());
          }
          return this.$watch(() => valueGetter(), (newValue, oldValue) => {
            if (toComparable2(oldValue) !== toComparable2(newValue) || options2.deep) {
              valueChangeCallback(newValue);
            }
          }, {
            deep: options2.deep
          });
        };
      },
      $_getExtraIntegrationOptions() {
        return {};
      },
      $_processChildren(_children) {
      },
      $_createEmitters(instance) {
        if (this.$attrs) {
          Object.keys(this.$attrs).forEach((listenerName) => {
            const eventName = camelize2(listenerName);
            instance.on(eventName, (e) => {
              this.$emit(listenerName, e);
            });
          });
        }
      }
    }
  });
}
function cleanWidgetNode(node) {
  const removedNodes = [];
  forEachChildNode(node, (childNode) => {
    const parent = childNode.parentNode;
    const isExtension = childNode.hasAttribute && childNode.hasAttribute("isExtension");
    if ((childNode.nodeName === "#comment" || isExtension) && parent) {
      removedNodes.push(childNode);
      parent.removeChild(childNode);
    }
  });
  return removedNodes;
}
function pickOutDxClasses(el) {
  return el && Array.from(el.classList).filter((item) => item.startsWith("dx-"));
}
function restoreNodes(el, nodes) {
  nodes.forEach((node) => {
    el.appendChild(node);
  });
}
function initDxComponent() {
  return defineComponent({
    extends: initBaseComponent(),
    methods: {
      $_getExtraIntegrationOptions() {
        return {
          onInitializing() {
            this.beginUpdate();
          }
        };
      },
      $_processChildren(children) {
        children.forEach((childNode) => {
          if (!childNode || typeof childNode !== "object") {
            return;
          }
          childNode.$_hasOwner = true;
        });
      }
    },
    mounted() {
      const nodes = cleanWidgetNode(this.$el);
      const thisComponent = this;
      this.$_createWidget(this.$el);
      thisComponent.$_instance.endUpdate();
      restoreNodes(this.$el, nodes);
      if (this.$slots && this.$slots.default) {
        getChildren(thisComponent).forEach((child) => {
          const childExtenton = child;
          if (childExtenton && childExtenton.$_isExtension) {
            childExtenton.$_attachTo(this.$el);
          }
        });
      }
    }
  });
}

// ../../../../../../node_modules/devextreme-vue/esm/core/extension-component.js
function initDxExtensionComponent() {
  return defineComponent({
    extends: initBaseComponent(),
    mounted() {
      this.$el.setAttribute("isExtension", "true");
      const nodeOptions = getNodeOptions(this);
      nodeOptions.$_isExtension = true;
      nodeOptions.$_attachTo = this.attachTo.bind(this);
      if (nodeOptions && nodeOptions.$_hasOwner) {
        return;
      }
      this.attachTo(this.$el);
    },
    methods: {
      attachTo(element) {
        this.$_createWidget(element);
      }
    }
  });
}

// ../../../../../../node_modules/devextreme-vue/esm/core/strategy/vue3/index.js
function createComponent2(config3) {
  config3.extends = initDxComponent();
  setCompatOptions(config3);
  if (config3.model) {
    setVModel(config3);
  }
  return defineComponent(config3);
}
function createConfigurationComponent2(config3) {
  config3.extends = initDxConfiguration();
  setCompatOptions(config3);
  return defineComponent(config3);
}
function createExtensionComponent2(config3) {
  config3.extends = initDxExtensionComponent();
  setCompatOptions(config3);
  return defineComponent(config3);
}

// ../../../../../../node_modules/devextreme-vue/esm/core/version.js
function getVueVersion() {
  const currentVersion = version;
  return currentVersion ? Number(currentVersion.split(".")[0]) : 2;
}
function isVue3() {
  return getVueVersion() === 3;
}

// ../../../../../../node_modules/devextreme-vue/esm/core/index.js
var strategy3 = isVue3() ? vue3_exports : vue2_exports;
var { createComponent: createComponent3 } = strategy3;
var { createConfigurationComponent: createConfigurationComponent3 } = strategy3;
var { createExtensionComponent: createExtensionComponent3 } = strategy3;

export {
  _extends,
  isDefined,
  isFunction,
  isString,
  isNumeric,
  isObject,
  isEmptyObject,
  isPlainObject,
  isWindow,
  isRenderer,
  isPromise,
  isDeferred,
  extend,
  map,
  each,
  quadToObject,
  errors_default,
  config_default,
  guid_default,
  callbacks_default,
  fromPromise,
  Deferred,
  when,
  deepExtendArraySafe,
  getPathParts,
  compileGetter,
  compileSetter,
  ensureDefined,
  deferRender,
  splitPair,
  normalizeKey,
  pairToObject,
  noop2 as noop,
  grep,
  equalByValue,
  dom_adapter_default,
  hasWindow,
  getWindow,
  events_engine_default,
  data,
  dasherize,
  camelize,
  getElementBoxParams,
  parseHeight,
  getVerticalOffsets,
  getWidth,
  setWidth,
  getHeight,
  setHeight,
  getOuterWidth,
  setOuterWidth,
  getOuterHeight,
  setOuterHeight,
  renderer_default,
  component_registrator_default,
  isMouseEvent,
  isDxMouseWheelEvent,
  isFakeClickEvent,
  eventData,
  needSkipEvent,
  normalizeKeyName,
  addNamespace2 as addNamespace,
  isCommandKeyPressed,
  message_default,
  value,
  devices_default,
  touch,
  pointer_default,
  resetActiveElement,
  createTextElementHiddenCopy,
  replaceWith,
  isElementInDom,
  sign,
  fitIntoRange,
  roundFloatPart,
  getBoundingRect,
  getPublicElement,
  locate,
  move,
  resetPosition,
  position_default,
  fx_default,
  triggerResizeEvent,
  EmptyTemplate,
  wrapToArray,
  getIntersection,
  removeDuplicates,
  DRAG_START_EVENT,
  DRAG_EVENT,
  DRAG_END_EVENT,
  DRAG_ENTER_EVENT,
  DRAG_LEAVE_EVENT,
  DROP_EVENT,
  keyboard_processor_default,
  ui_errors_default,
  Action,
  FunctionTemplate,
  ChildDefaultTemplate,
  _objectWithoutPropertiesLoose,
  dom_component_default,
  CLICK_EVENT_NAME,
  lock,
  ui_widget_default,
  OverlayPositionController,
  ui_overlay_default,
  editor_default,
  current,
  isMaterialBased,
  isMaterial,
  isFluent,
  isCompact,
  findDOMfromVNode,
  createVNode,
  createComponentVNode,
  createFragment,
  normalizeProps,
  createRef,
  BaseInfernoComponent,
  InfernoComponent,
  InfernoWrapperComponent,
  InfernoEffect,
  createReRenderEffect,
  normalizeStyles,
  inferno_renderer_default,
  getImageContainer,
  emitter_gesture_scroll_default,
  button_default,
  m_utils_caret_default,
  text_box_default2 as text_box_default,
  DBLCLICK_EVENT_NAME,
  number_box_default,
  date_default2 as date_default,
  date_default3 as date_default2,
  date_serialization_default,
  BindableTemplate,
  query_default,
  array_store_default,
  normalizeLoadResult,
  normalizeDataSourceOptions,
  DataSource,
  SelectionFilterCreator,
  data_helper_default,
  name,
  ui_collection_widget_edit_default,
  widget_default,
  edit_default,
  m_toolbar_base_default,
  resizable_default,
  ui_popup_default,
  getElementWidth,
  getSizeValue,
  swipeable_default,
  calendar_default,
  ui_data_expression_default,
  load_panel_default,
  m_animator_default,
  ListBase,
  m_list_edit_default,
  list_light_default,
  select_box_default,
  date_box_default,
  ui_scrollable_default,
  form_default,
  createComponent3 as createComponent,
  createConfigurationComponent3 as createConfigurationComponent
};
/*! Bundled license information:

devextreme-vue/esm/core/strategy/vue2/index.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/helpers.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/children-processing.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/vue-helper.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/config.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/configuration.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/configuration-component.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/constants.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/templates-discovering.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/templates-manager.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/component.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/extension-component.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/strategy/vue3/index.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/version.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/index.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)
*/
//# sourceMappingURL=chunk-4PZ2IOIR.js.map
