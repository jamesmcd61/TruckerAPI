import {
  Action,
  BaseInfernoComponent,
  BindableTemplate,
  CLICK_EVENT_NAME,
  ChildDefaultTemplate,
  DBLCLICK_EVENT_NAME,
  DRAG_END_EVENT,
  DRAG_ENTER_EVENT,
  DRAG_EVENT,
  DRAG_LEAVE_EVENT,
  DRAG_START_EVENT,
  DROP_EVENT,
  DataSource,
  Deferred,
  EmptyTemplate,
  FunctionTemplate,
  InfernoComponent,
  InfernoEffect,
  InfernoWrapperComponent,
  ListBase,
  OverlayPositionController,
  SelectionFilterCreator,
  _extends,
  _objectWithoutPropertiesLoose,
  addNamespace,
  array_store_default,
  button_default,
  calendar_default,
  callbacks_default,
  camelize,
  compileGetter,
  compileSetter,
  component_registrator_default,
  config_default,
  createComponent,
  createComponentVNode,
  createConfigurationComponent,
  createFragment,
  createReRenderEffect,
  createRef,
  createTextElementHiddenCopy,
  createVNode,
  current,
  dasherize,
  data,
  data_helper_default,
  date_box_default,
  date_default,
  date_default2,
  date_serialization_default,
  deepExtendArraySafe,
  deferRender,
  devices_default,
  dom_adapter_default,
  dom_component_default,
  each,
  edit_default,
  editor_default,
  emitter_gesture_scroll_default,
  ensureDefined,
  equalByValue,
  errors_default,
  eventData,
  events_engine_default,
  extend,
  findDOMfromVNode,
  fitIntoRange,
  form_default,
  fromPromise,
  fx_default,
  getBoundingRect,
  getElementBoxParams,
  getElementWidth,
  getHeight,
  getImageContainer,
  getIntersection,
  getOuterHeight,
  getOuterWidth,
  getPathParts,
  getPublicElement,
  getSizeValue,
  getVerticalOffsets,
  getWidth,
  getWindow,
  grep,
  guid_default,
  hasWindow,
  inferno_renderer_default,
  isCommandKeyPressed,
  isCompact,
  isDeferred,
  isDefined,
  isDxMouseWheelEvent,
  isElementInDom,
  isEmptyObject,
  isFakeClickEvent,
  isFluent,
  isFunction,
  isMaterial,
  isMaterialBased,
  isMouseEvent,
  isNumeric,
  isObject,
  isPlainObject,
  isPromise,
  isRenderer,
  isString,
  isWindow,
  keyboard_processor_default,
  list_light_default,
  load_panel_default,
  locate,
  lock,
  m_animator_default,
  m_list_edit_default,
  m_toolbar_base_default,
  m_utils_caret_default,
  map,
  message_default,
  move,
  name,
  needSkipEvent,
  noop,
  normalizeDataSourceOptions,
  normalizeKey,
  normalizeKeyName,
  normalizeLoadResult,
  normalizeProps,
  normalizeStyles,
  number_box_default,
  pairToObject,
  parseHeight,
  pointer_default,
  position_default,
  quadToObject,
  query_default,
  removeDuplicates,
  renderer_default,
  replaceWith,
  resetActiveElement,
  resetPosition,
  resizable_default,
  roundFloatPart,
  select_box_default,
  setHeight,
  setOuterHeight,
  setOuterWidth,
  setWidth,
  sign,
  splitPair,
  swipeable_default,
  text_box_default,
  touch,
  triggerResizeEvent,
  ui_collection_widget_edit_default,
  ui_data_expression_default,
  ui_errors_default,
  ui_overlay_default,
  ui_popup_default,
  ui_scrollable_default,
  ui_widget_default,
  value,
  when,
  widget_default,
  wrapToArray
} from "./chunk-4PZ2IOIR.js";
import "./chunk-IYPBRSHA.js";
import "./chunk-IER6VNQZ.js";

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_dialog.js
var window = getWindow();
var DEFAULT_BUTTON = {
  text: "OK",
  onClick: () => true
};
var custom = function(options) {
  const deferred = Deferred();
  options = options || {};
  const $element = renderer_default("<div>").addClass("dx-dialog").appendTo(value());
  const isMessageDefined = "message" in options;
  const isMessageHtmlDefined = "messageHtml" in options;
  if (isMessageDefined) {
    ui_errors_default.log("W1013");
  }
  const messageHtml = String(isMessageHtmlDefined ? options.messageHtml : options.message);
  const messageId = options.title ? null : new guid_default();
  const $message = renderer_default("<div>").addClass("dx-dialog-message").html(messageHtml).attr("id", messageId);
  const popupToolbarItems = [];
  const popupInstance = new ui_popup_default($element, extend({
    title: options.title ?? "",
    showTitle: ensureDefined(options.showTitle, true),
    dragEnabled: ensureDefined(options.dragEnabled, true),
    height: "auto",
    width: options.width,
    showCloseButton: options.showCloseButton || false,
    ignoreChildEvents: false,
    container: $element,
    visualContainer: window,
    dragAndResizeArea: window,
    onContentReady(args) {
      args.component.$content().addClass("dx-dialog-content").append($message);
      if (messageId) {
        args.component.$overlayContent().attr("aria-labelledby", messageId);
      }
    },
    onShowing(e) {
      e.component.bottomToolbar().addClass("dx-dialog-buttons").find(".dx-button").addClass("dx-dialog-button");
      resetActiveElement();
    },
    onShown(e) {
      const $firstButton = e.component.bottomToolbar().find(".dx-button").first();
      events_engine_default.trigger($firstButton, "focus");
    },
    onHiding() {
      deferred.reject();
    },
    onHidden(_ref) {
      let {
        element
      } = _ref;
      renderer_default(element).remove();
    },
    animation: {
      show: {
        type: "pop",
        duration: 400
      },
      hide: {
        type: "pop",
        duration: 400,
        to: {
          opacity: 0,
          scale: 0
        },
        from: {
          opacity: 1,
          scale: 1
        }
      }
    },
    rtlEnabled: config_default().rtlEnabled,
    position: {
      boundaryOffset: {
        h: 10,
        v: 0
      }
    }
  }, options.popupOptions));
  const buttonOptions = options.buttons || [DEFAULT_BUTTON];
  buttonOptions.forEach((options2) => {
    const action = new Action(options2.onClick, {
      context: popupInstance
    });
    popupToolbarItems.push({
      toolbar: "bottom",
      location: devices_default.current().android ? "after" : "center",
      widget: "dxButton",
      options: _extends({}, options2, {
        onClick() {
          const result = action.execute(...arguments);
          hide3(result);
        }
      })
    });
  });
  popupInstance.option("toolbarItems", popupToolbarItems);
  popupInstance.$wrapper().addClass("dx-dialog-wrapper");
  if (options.position) {
    popupInstance.option("position", options.position);
  }
  popupInstance.$wrapper().addClass("dx-dialog-root");
  function hide3(value2) {
    deferred.resolve(value2);
    popupInstance.hide();
  }
  return {
    show: function() {
      if ("phone" === devices_default.real().deviceType) {
        const isPortrait = getHeight(window) > getWidth(window);
        const width = isPortrait ? "90%" : "60%";
        popupInstance.option({
          width
        });
      }
      popupInstance.show();
      return deferred.promise();
    },
    hide: hide3
  };
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/utils/date.js
var addOffsets = (date, offsets) => {
  const newDateMs = offsets.reduce((result, offset) => result + offset, date.getTime());
  return new Date(newDateMs);
};
var dateUtilsTs = {
  addOffsets
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/timezone_calculator/const.js
var PathTimeZoneConversion;
!function(PathTimeZoneConversion2) {
  PathTimeZoneConversion2.fromSourceToAppointment = "toAppointment";
  PathTimeZoneConversion2.fromAppointmentToSource = "fromAppointment";
  PathTimeZoneConversion2.fromSourceToGrid = "toGrid";
  PathTimeZoneConversion2.fromGridToSource = "fromGrid";
}(PathTimeZoneConversion || (PathTimeZoneConversion = {}));

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/timezone_calculator/calculator.js
var toMs = date_default2.dateToMilliseconds;
var TimeZoneCalculator = class {
  constructor(options) {
    this.options = options;
  }
  createDate(sourceDate, info) {
    const date = new Date(sourceDate);
    switch (info.path) {
      case PathTimeZoneConversion.fromSourceToAppointment:
        return this.getConvertedDate(date, info.appointmentTimeZone, true, false);
      case PathTimeZoneConversion.fromAppointmentToSource:
        return this.getConvertedDate(date, info.appointmentTimeZone, true, true);
      case PathTimeZoneConversion.fromSourceToGrid:
        return this.getConvertedDate(date, info.appointmentTimeZone, false, false);
      case PathTimeZoneConversion.fromGridToSource:
        return this.getConvertedDate(date, info.appointmentTimeZone, false, true);
      default:
        throw new Error("not specified pathTimeZoneConversion");
    }
  }
  getOffsets(date, appointmentTimezone) {
    const clientOffset = -this.getClientOffset(date) / date_default2.dateToMilliseconds("hour");
    const commonOffset = this.getCommonOffset(date);
    const appointmentOffset = this.getAppointmentOffset(date, appointmentTimezone);
    return {
      client: clientOffset,
      common: !isDefined(commonOffset) ? clientOffset : commonOffset,
      appointment: "number" !== typeof appointmentOffset ? clientOffset : appointmentOffset
    };
  }
  getConvertedDateByOffsets(date, clientOffset, targetOffset, isBack) {
    const direction = isBack ? -1 : 1;
    const resultDate = new Date(date);
    return dateUtilsTs.addOffsets(resultDate, [direction * (toMs("hour") * targetOffset), -direction * (toMs("hour") * clientOffset)]);
  }
  getOriginStartDateOffsetInMs(date, timezone, isUTCDate) {
    const offsetInHours = this.getOffsetInHours(date, timezone, isUTCDate);
    return 36e5 * offsetInHours;
  }
  getOffsetInHours(date, timezone, isUTCDate) {
    const {
      client,
      appointment,
      common: common2
    } = this.getOffsets(date, timezone);
    if (!!timezone && isUTCDate) {
      return appointment - client;
    }
    if (!!timezone && !isUTCDate) {
      return appointment - common2;
    }
    if (!timezone && isUTCDate) {
      return common2 - client;
    }
    return 0;
  }
  getClientOffset(date) {
    return this.options.getClientOffset(date);
  }
  getCommonOffset(date) {
    return this.options.tryGetCommonOffset(date);
  }
  getAppointmentOffset(date, appointmentTimezone) {
    return this.options.tryGetAppointmentOffset(date, appointmentTimezone);
  }
  getConvertedDate(date, appointmentTimezone, useAppointmentTimeZone, isBack) {
    const newDate = new Date(date.getTime());
    const offsets = this.getOffsets(newDate, appointmentTimezone);
    if (useAppointmentTimeZone && !!appointmentTimezone) {
      return this.getConvertedDateByOffsets(date, offsets.client, offsets.appointment, isBack);
    }
    return this.getConvertedDateByOffsets(date, offsets.client, offsets.common, isBack);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_date_adapter.js
var toMs2 = date_default2.dateToMilliseconds;
var DateAdapterCore = class {
  constructor(source) {
    this._source = new Date(source.getTime ? source.getTime() : source);
  }
  get source() {
    return this._source;
  }
  result() {
    return this._source;
  }
  getTimezoneOffset() {
    let format = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    const value2 = this._source.getTimezoneOffset();
    if ("minute" === format) {
      return value2 * toMs2("minute");
    }
    return value2;
  }
  getTime() {
    return this._source.getTime();
  }
  setTime(value2) {
    this._source.setTime(value2);
    return this;
  }
  addTime(value2) {
    this._source.setTime(this._source.getTime() + value2);
    return this;
  }
  setMinutes(value2) {
    this._source.setMinutes(value2);
    return this;
  }
  addMinutes(value2) {
    this._source.setMinutes(this._source.getMinutes() + value2);
    return this;
  }
  subtractMinutes(value2) {
    this._source.setMinutes(this._source.getMinutes() - value2);
    return this;
  }
};
var DateAdapter = (date) => new DateAdapterCore(date);
var m_date_adapter_default = DateAdapter;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/timezones/m_utils_timezones_data.js
var getConvertedUntils = (value2) => value2.split("|").map((until) => {
  if ("Infinity" === until) {
    return null;
  }
  return 1e3 * parseInt(until, 36);
});
var parseTimezone = (timeZoneConfig) => {
  const {
    offsets
  } = timeZoneConfig;
  const {
    offsetIndices
  } = timeZoneConfig;
  const {
    untils
  } = timeZoneConfig;
  const offsetList = offsets.split("|").map((value2) => parseInt(value2));
  const offsetIndexList = offsetIndices.split("").map((value2) => parseInt(value2));
  const dateList = getConvertedUntils(untils).map((accumulator = 0, (value2) => accumulator += value2));
  var accumulator;
  return {
    offsetList,
    offsetIndexList,
    dateList
  };
};
var TimeZoneCache = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  tryGet(id) {
    if (!this.map.get(id)) {
      const config = timeZoneDataUtils.getTimezoneById(id);
      if (!config) {
        return false;
      }
      const timeZoneInfo = parseTimezone(config);
      this.map.set(id, timeZoneInfo);
    }
    return this.map.get(id);
  }
};
var tzCache = new TimeZoneCache();
var timeZoneDataUtils = {
  _tzCache: tzCache,
  getTimeZonesOld: () => config_default().timezones ?? [],
  formatOffset(offset) {
    const hours = Math.floor(offset);
    const minutesInDecimal = offset - hours;
    const signString = sign(offset) >= 0 ? "+" : "-";
    const hoursString = `0${Math.abs(hours)}`.slice(-2);
    const minutesString = minutesInDecimal > 0 ? ":" + 60 * minutesInDecimal : ":00";
    return signString + hoursString + minutesString;
  },
  formatId: (id) => id.split("/").join(" - ").split("_").join(" "),
  getTimezoneById(id) {
    if (!id) {
      return;
    }
    const tzList = this.getTimeZonesOld();
    for (let i = 0; i < tzList.length; i++) {
      const currentId = tzList[i].id;
      if (currentId === id) {
        return tzList[i];
      }
    }
    return;
  },
  getTimeZoneOffsetById(id, timestamp) {
    const timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getUtcOffset(timeZoneInfo, timestamp) : void 0;
  },
  getTimeZoneDeclarationTuple(id, year) {
    const timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getTimeZoneDeclarationTupleCore(timeZoneInfo, year) : [];
  },
  getTimeZoneDeclarationTupleCore(timeZoneInfo, year) {
    const {
      offsetList
    } = timeZoneInfo;
    const {
      offsetIndexList
    } = timeZoneInfo;
    const {
      dateList
    } = timeZoneInfo;
    const tupleResult = [];
    for (let i = 0; i < dateList.length; i++) {
      const currentDate = dateList[i];
      const currentYear = new Date(currentDate).getFullYear();
      if (currentYear === year) {
        const offset = offsetList[offsetIndexList[i + 1]];
        tupleResult.push({
          date: currentDate,
          offset: -offset / 60
        });
      }
      if (currentYear > year) {
        break;
      }
    }
    return tupleResult;
  },
  getUtcOffset(timeZoneInfo, dateTimeStamp) {
    const {
      offsetList
    } = timeZoneInfo;
    const {
      offsetIndexList
    } = timeZoneInfo;
    const {
      dateList
    } = timeZoneInfo;
    const lastIntervalStartIndex = dateList.length - 1 - 1;
    let index = lastIntervalStartIndex;
    while (index >= 0 && dateTimeStamp < dateList[index]) {
      index--;
    }
    const offset = offsetList[offsetIndexList[index + 1]];
    return -offset / 60 || offset;
  }
};
var m_utils_timezones_data_default = timeZoneDataUtils;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/timezones/timezone_list.js
var timezone_list_default = {
  value: ["Etc/GMT+12", "Etc/GMT+11", "Pacific/Midway", "Pacific/Niue", "Pacific/Pago_Pago", "Pacific/Samoa", "US/Samoa", "Etc/GMT+10", "HST", "Pacific/Honolulu", "Pacific/Johnston", "Pacific/Rarotonga", "Pacific/Tahiti", "US/Hawaii", "Pacific/Marquesas", "America/Adak", "America/Atka", "Etc/GMT+9", "Pacific/Gambier", "US/Aleutian", "America/Anchorage", "America/Juneau", "America/Metlakatla", "America/Nome", "America/Sitka", "America/Yakutat", "Etc/GMT+8", "Pacific/Pitcairn", "US/Alaska", "America/Creston", "America/Dawson_Creek", "America/Dawson", "America/Ensenada", "America/Fort_Nelson", "America/Hermosillo", "America/Los_Angeles", "America/Phoenix", "America/Santa_Isabel", "America/Tijuana", "America/Vancouver", "America/Whitehorse", "Canada/Pacific", "Canada/Yukon", "Etc/GMT+7", "Mexico/BajaNorte", "MST", "PST8PDT", "US/Arizona", "US/Pacific", "America/Belize", "America/Boise", "America/Cambridge_Bay", "America/Chihuahua", "America/Costa_Rica", "America/Denver", "America/Edmonton", "America/El_Salvador", "America/Guatemala", "America/Inuvik", "America/Managua", "America/Mazatlan", "America/Monterrey", "America/Ojinaga", "America/Regina", "America/Shiprock", "America/Swift_Current", "America/Tegucigalpa", "America/Yellowknife", "Canada/Mountain", "Canada/Saskatchewan", "Chile/EasterIsland", "Etc/GMT+6", "Mexico/BajaSur", "MST7MDT", "Navajo", "Pacific/Easter", "Pacific/Galapagos", "US/Mountain", "America/Atikokan", "America/Bahia_Banderas", "America/Bogota", "America/Cancun", "America/Cayman", "America/Chicago", "America/Coral_Harbour", "America/Eirunepe", "America/Guayaquil", "America/Indiana/Knox", "America/Indiana/Tell_City", "America/Jamaica", "America/Knox_IN", "America/Lima", "America/Matamoros", "America/Menominee", "America/Merida", "America/Mexico_City", "America/North_Dakota/Beulah", "America/North_Dakota/Center", "America/North_Dakota/New_Salem", "America/Panama", "America/Porto_Acre", "America/Rainy_River", "America/Rankin_Inlet", "America/Resolute", "America/Rio_Branco", "America/Winnipeg", "Brazil/Acre", "Canada/Central", "CST6CDT", "EST", "Etc/GMT+5", "Jamaica", "Mexico/General", "US/Central", "US/Indiana-Starke", "America/Anguilla", "America/Antigua", "America/Aruba", "America/Asuncion", "America/Barbados", "America/Blanc-Sablon", "America/Boa_Vista", "America/Campo_Grande", "America/Caracas", "America/Cuiaba", "America/Curacao", "America/Detroit", "America/Dominica", "America/Fort_Wayne", "America/Grand_Turk", "America/Grenada", "America/Guadeloupe", "America/Guyana", "America/Havana", "America/Indiana/Indianapolis", "America/Indiana/Marengo", "America/Indiana/Petersburg", "America/Indiana/Vevay", "America/Indiana/Vincennes", "America/Indiana/Winamac", "America/Indianapolis", "America/Iqaluit", "America/Kentucky/Louisville", "America/Kentucky/Monticello", "America/Kralendijk", "America/La_Paz", "America/Louisville", "America/Lower_Princes", "America/Manaus", "America/Marigot", "America/Martinique", "America/Montreal", "America/Montserrat", "America/Nassau", "America/New_York", "America/Nipigon", "America/Pangnirtung", "America/Port_of_Spain", "America/Port-au-Prince", "America/Porto_Velho", "America/Puerto_Rico", "America/Santiago", "America/Santo_Domingo", "America/St_Barthelemy", "America/St_Kitts", "America/St_Lucia", "America/St_Thomas", "America/St_Vincent", "America/Thunder_Bay", "America/Toronto", "America/Tortola", "America/Virgin", "Brazil/West", "Canada/Eastern", "Chile/Continental", "Cuba", "EST5EDT", "Etc/GMT+4", "US/East-Indiana", "US/Eastern", "US/Michigan", "America/Araguaina", "America/Argentina/Buenos_Aires", "America/Argentina/Catamarca", "America/Argentina/ComodRivadavia", "America/Argentina/Cordoba", "America/Argentina/Jujuy", "America/Argentina/La_Rioja", "America/Argentina/Mendoza", "America/Argentina/Rio_Gallegos", "America/Argentina/Salta", "America/Argentina/San_Juan", "America/Argentina/San_Luis", "America/Argentina/Tucuman", "America/Argentina/Ushuaia", "America/Bahia", "America/Belem", "America/Buenos_Aires", "America/Catamarca", "America/Cayenne", "America/Cordoba", "America/Fortaleza", "America/Glace_Bay", "America/Goose_Bay", "America/Halifax", "America/Jujuy", "America/Maceio", "America/Mendoza", "America/Moncton", "America/Montevideo", "America/Paramaribo", "America/Punta_Arenas", "America/Recife", "America/Rosario", "America/Santarem", "America/Sao_Paulo", "America/Thule", "Antarctica/Palmer", "Antarctica/Rothera", "Atlantic/Bermuda", "Atlantic/Stanley", "Brazil/East", "Canada/Atlantic", "Etc/GMT+3", "America/St_Johns", "Canada/Newfoundland", "America/Godthab", "America/Miquelon", "America/Noronha", "America/Nuuk", "Atlantic/South_Georgia", "Brazil/DeNoronha", "Etc/GMT+2", "Atlantic/Cape_Verde", "Etc/GMT+1", "Africa/Abidjan", "Africa/Accra", "Africa/Bamako", "Africa/Banjul", "Africa/Bissau", "Africa/Conakry", "Africa/Dakar", "Africa/Freetown", "Africa/Lome", "Africa/Monrovia", "Africa/Nouakchott", "Africa/Ouagadougou", "Africa/Sao_Tome", "Africa/Timbuktu", "America/Danmarkshavn", "America/Scoresbysund", "Atlantic/Azores", "Atlantic/Reykjavik", "Atlantic/St_Helena", "Etc/GMT-0", "Etc/GMT", "Etc/GMT+0", "Etc/GMT0", "Etc/Greenwich", "Etc/UCT", "Etc/Universal", "Etc/UTC", "Etc/Zulu", "GMT-0", "GMT", "GMT+0", "GMT0", "Greenwich", "Iceland", "UCT", "Universal", "UTC", "Zulu", "Africa/Algiers", "Africa/Bangui", "Africa/Brazzaville", "Africa/Casablanca", "Africa/Douala", "Africa/El_Aaiun", "Africa/Kinshasa", "Africa/Lagos", "Africa/Libreville", "Africa/Luanda", "Africa/Malabo", "Africa/Ndjamena", "Africa/Niamey", "Africa/Porto-Novo", "Africa/Tunis", "Atlantic/Canary", "Atlantic/Faeroe", "Atlantic/Faroe", "Atlantic/Madeira", "Eire", "Etc/GMT-1", "Europe/Belfast", "Europe/Dublin", "Europe/Guernsey", "Europe/Isle_of_Man", "Europe/Jersey", "Europe/Lisbon", "Europe/London", "GB-Eire", "GB", "Portugal", "WET", "Africa/Blantyre", "Africa/Bujumbura", "Africa/Cairo", "Africa/Ceuta", "Africa/Gaborone", "Africa/Harare", "Africa/Johannesburg", "Africa/Khartoum", "Africa/Kigali", "Africa/Lubumbashi", "Africa/Lusaka", "Africa/Maputo", "Africa/Maseru", "Africa/Mbabane", "Africa/Tripoli", "Africa/Windhoek", "Antarctica/Troll", "Arctic/Longyearbyen", "Atlantic/Jan_Mayen", "CET", "Egypt", "Etc/GMT-2", "Europe/Amsterdam", "Europe/Andorra", "Europe/Belgrade", "Europe/Berlin", "Europe/Bratislava", "Europe/Brussels", "Europe/Budapest", "Europe/Busingen", "Europe/Copenhagen", "Europe/Gibraltar", "Europe/Kaliningrad", "Europe/Ljubljana", "Europe/Luxembourg", "Europe/Madrid", "Europe/Malta", "Europe/Monaco", "Europe/Oslo", "Europe/Paris", "Europe/Podgorica", "Europe/Prague", "Europe/Rome", "Europe/San_Marino", "Europe/Sarajevo", "Europe/Skopje", "Europe/Stockholm", "Europe/Tirane", "Europe/Vaduz", "Europe/Vatican", "Europe/Vienna", "Europe/Warsaw", "Europe/Zagreb", "Europe/Zurich", "Libya", "MET", "Poland", "Africa/Addis_Ababa", "Africa/Asmara", "Africa/Asmera", "Africa/Dar_es_Salaam", "Africa/Djibouti", "Africa/Juba", "Africa/Kampala", "Africa/Mogadishu", "Africa/Nairobi", "Antarctica/Syowa", "Asia/Aden", "Asia/Amman", "Asia/Baghdad", "Asia/Bahrain", "Asia/Beirut", "Asia/Damascus", "Asia/Famagusta", "Asia/Gaza", "Asia/Hebron", "Asia/Istanbul", "Asia/Jerusalem", "Asia/Kuwait", "Asia/Nicosia", "Asia/Qatar", "Asia/Riyadh", "Asia/Tel_Aviv", "EET", "Etc/GMT-3", "Europe/Athens", "Europe/Bucharest", "Europe/Chisinau", "Europe/Helsinki", "Europe/Istanbul", "Europe/Kiev", "Europe/Kirov", "Europe/Mariehamn", "Europe/Minsk", "Europe/Moscow", "Europe/Nicosia", "Europe/Riga", "Europe/Simferopol", "Europe/Sofia", "Europe/Tallinn", "Europe/Tiraspol", "Europe/Uzhgorod", "Europe/Vilnius", "Europe/Zaporozhye", "Indian/Antananarivo", "Indian/Comoro", "Indian/Mayotte", "Israel", "Turkey", "W-SU", "Asia/Baku", "Asia/Dubai", "Asia/Muscat", "Asia/Tbilisi", "Asia/Yerevan", "Etc/GMT-4", "Europe/Astrakhan", "Europe/Samara", "Europe/Saratov", "Europe/Ulyanovsk", "Europe/Volgograd", "Indian/Mahe", "Indian/Mauritius", "Indian/Reunion", "Asia/Kabul", "Asia/Tehran", "Iran", "Antarctica/Mawson", "Asia/Aqtau", "Asia/Aqtobe", "Asia/Ashgabat", "Asia/Ashkhabad", "Asia/Atyrau", "Asia/Dushanbe", "Asia/Karachi", "Asia/Oral", "Asia/Qyzylorda", "Asia/Samarkand", "Asia/Tashkent", "Asia/Yekaterinburg", "Etc/GMT-5", "Indian/Kerguelen", "Indian/Maldives", "Asia/Calcutta", "Asia/Colombo", "Asia/Kolkata", "Asia/Kathmandu", "Asia/Katmandu", "Antarctica/Vostok", "Asia/Almaty", "Asia/Bishkek", "Asia/Dacca", "Asia/Dhaka", "Asia/Kashgar", "Asia/Omsk", "Asia/Qostanay", "Asia/Thimbu", "Asia/Thimphu", "Asia/Urumqi", "Etc/GMT-6", "Indian/Chagos", "Asia/Rangoon", "Asia/Yangon", "Indian/Cocos", "Antarctica/Davis", "Asia/Bangkok", "Asia/Barnaul", "Asia/Ho_Chi_Minh", "Asia/Hovd", "Asia/Jakarta", "Asia/Krasnoyarsk", "Asia/Novokuznetsk", "Asia/Novosibirsk", "Asia/Phnom_Penh", "Asia/Pontianak", "Asia/Saigon", "Asia/Tomsk", "Asia/Vientiane", "Etc/GMT-7", "Indian/Christmas", "Antarctica/Casey", "Asia/Brunei", "Asia/Choibalsan", "Asia/Chongqing", "Asia/Chungking", "Asia/Harbin", "Asia/Hong_Kong", "Asia/Irkutsk", "Asia/Kuala_Lumpur", "Asia/Kuching", "Asia/Macao", "Asia/Macau", "Asia/Makassar", "Asia/Manila", "Asia/Shanghai", "Asia/Singapore", "Asia/Taipei", "Asia/Ujung_Pandang", "Asia/Ulaanbaatar", "Asia/Ulan_Bator", "Australia/Perth", "Australia/West", "Etc/GMT-8", "Hongkong", "PRC", "ROC", "Singapore", "Australia/Eucla", "Asia/Chita", "Asia/Dili", "Asia/Jayapura", "Asia/Khandyga", "Asia/Pyongyang", "Asia/Seoul", "Asia/Tokyo", "Asia/Yakutsk", "Etc/GMT-9", "Japan", "Pacific/Palau", "ROK", "Australia/Adelaide", "Australia/Broken_Hill", "Australia/Darwin", "Australia/North", "Australia/South", "Australia/Yancowinna", "Antarctica/DumontDUrville", "Asia/Ust-Nera", "Asia/Vladivostok", "Australia/ACT", "Australia/Brisbane", "Australia/Canberra", "Australia/Currie", "Australia/Hobart", "Australia/Lindeman", "Australia/Melbourne", "Australia/NSW", "Australia/Queensland", "Australia/Sydney", "Australia/Tasmania", "Australia/Victoria", "Etc/GMT-10", "Pacific/Chuuk", "Pacific/Guam", "Pacific/Port_Moresby", "Pacific/Saipan", "Pacific/Truk", "Pacific/Yap", "Australia/LHI", "Australia/Lord_Howe", "Antarctica/Macquarie", "Asia/Magadan", "Asia/Sakhalin", "Asia/Srednekolymsk", "Etc/GMT-11", "Pacific/Bougainville", "Pacific/Efate", "Pacific/Guadalcanal", "Pacific/Kosrae", "Pacific/Norfolk", "Pacific/Noumea", "Pacific/Pohnpei", "Pacific/Ponape", "Antarctica/McMurdo", "Antarctica/South_Pole", "Asia/Anadyr", "Asia/Kamchatka", "Etc/GMT-12", "Kwajalein", "NZ", "Pacific/Auckland", "Pacific/Fiji", "Pacific/Funafuti", "Pacific/Kwajalein", "Pacific/Majuro", "Pacific/Nauru", "Pacific/Tarawa", "Pacific/Wake", "Pacific/Wallis", "NZ-CHAT", "Pacific/Chatham", "Etc/GMT-13", "Pacific/Apia", "Pacific/Enderbury", "Pacific/Fakaofo", "Pacific/Tongatapu", "Etc/GMT-14", "Pacific/Kiritimati"]
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_utils_time_zone.js
var toMs3 = date_default2.dateToMilliseconds;
var GMT = "GMT";
var offsetFormatRegexp = /^GMT(?:[+-]\d{2}:\d{2})?$/;
var createUTCDateWithLocalOffset = (date) => {
  if (!date) {
    return null;
  }
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
};
var createDateFromUTCWithLocalOffset = (date) => {
  const result = m_date_adapter_default(date);
  const timezoneOffsetBeforeInMin = result.getTimezoneOffset();
  result.addTime(result.getTimezoneOffset("minute"));
  result.subtractMinutes(timezoneOffsetBeforeInMin - result.getTimezoneOffset());
  return result.source;
};
var getTimeZones = function() {
  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  return timezone_list_default.value.map((tz) => ({
    offset: calculateTimezoneByValue(tz, date),
    title: getTimezoneTitle(tz, date),
    id: tz
  }));
};
var createUTCDate = (date) => new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes()));
var getTimezoneOffsetChangeInMinutes = (startDate, endDate, updatedStartDate, updatedEndDate) => getDaylightOffset(updatedStartDate, updatedEndDate) - getDaylightOffset(startDate, endDate);
var getTimezoneOffsetChangeInMs = (startDate, endDate, updatedStartDate, updatedEndDate) => getTimezoneOffsetChangeInMinutes(startDate, endDate, updatedStartDate, updatedEndDate) * toMs3("minute");
var getDaylightOffset = (startDate, endDate) => new Date(startDate).getTimezoneOffset() - new Date(endDate).getTimezoneOffset();
var getDaylightOffsetInMs = (startDate, endDate) => getDaylightOffset(startDate, endDate) * toMs3("minute");
var isValidDate = (date) => date instanceof Date && !isNaN(date.valueOf());
var calculateTimezoneByValueOld = function(timezone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  const customTimezones = m_utils_timezones_data_default.getTimeZonesOld();
  if (0 === customTimezones.length) {
    return;
  }
  const dateUtc = createUTCDate(date);
  return m_utils_timezones_data_default.getTimeZoneOffsetById(timezone, dateUtc.getTime());
};
var calculateTimezoneByValueCore = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  const offset = getStringOffset(timeZone, date);
  if (void 0 === offset) {
    return;
  }
  if (offset === GMT) {
    return 0;
  }
  const isMinus = "-" === offset.substring(3, 4);
  const hours = offset.substring(4, 6);
  const minutes = offset.substring(7, 9);
  const result = parseInt(hours, 10) + parseInt(minutes, 10) / 60;
  return isMinus ? -result : result;
};
var calculateTimezoneByValue = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (!timeZone) {
    return;
  }
  const isValidTimezone = timezone_list_default.value.includes(timeZone);
  if (!isValidTimezone) {
    errors_default.log("W0009", timeZone);
    return;
  }
  if (!isValidDate(date)) {
    return;
  }
  let result = calculateTimezoneByValueOld(timeZone, date);
  if (void 0 === result) {
    result = calculateTimezoneByValueCore(timeZone, date);
  }
  return result;
};
var getStringOffset = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  let result = "";
  try {
    var _dateTimeFormat$forma;
    const dateTimeFormat = new Intl.DateTimeFormat("en-US", {
      timeZone,
      timeZoneName: "longOffset"
    });
    result = (null === (_dateTimeFormat$forma = dateTimeFormat.formatToParts(date).find((_ref) => {
      let {
        type
      } = _ref;
      return "timeZoneName" === type;
    })) || void 0 === _dateTimeFormat$forma ? void 0 : _dateTimeFormat$forma.value) ?? "";
  } catch (e) {
    errors_default.log("W0009", timeZone);
    return;
  }
  const isSupportedFormat = offsetFormatRegexp.test(result);
  if (!isSupportedFormat) {
    errors_default.log("W0009", timeZone);
    return;
  }
  return result;
};
var getOffsetNamePart = (offset) => {
  if (offset === GMT) {
    return `${offset} +00:00`;
  }
  return offset.replace(GMT, `${GMT} `);
};
var getTimezoneTitle = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (!isValidDate(date)) {
    return "";
  }
  const tzNamePart = timeZone.replace(/\//g, " - ").replace(/_/g, " ");
  const offset = getStringOffset(timeZone, date);
  if (void 0 === offset) {
    return;
  }
  const offsetNamePart = getOffsetNamePart(offset);
  return `(${offsetNamePart}) ${tzNamePart}`;
};
var _getDaylightOffsetByTimezone = (startDate, endDate, timeZone) => {
  const startDayOffset = calculateTimezoneByValue(timeZone, startDate);
  const endDayOffset = calculateTimezoneByValue(timeZone, endDate);
  if (void 0 === startDayOffset || void 0 === endDayOffset) {
    return 0;
  }
  return startDayOffset - endDayOffset;
};
var getCorrectedDateByDaylightOffsets = (convertedOriginalStartDate, convertedDate, date, timeZone, startDateTimezone) => {
  const daylightOffsetByCommonTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, timeZone);
  const daylightOffsetByAppointmentTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, startDateTimezone);
  const diff = daylightOffsetByCommonTimezone - daylightOffsetByAppointmentTimezone;
  return new Date(date.getTime() - diff * toMs3("hour"));
};
var correctRecurrenceExceptionByTimezone = function(exception, exceptionByStartDate, timeZone, startDateTimeZone) {
  let isBackConversion = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let timezoneOffset = (exception.getTimezoneOffset() - exceptionByStartDate.getTimezoneOffset()) / 60;
  if (startDateTimeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, startDateTimeZone);
  } else if (timeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, timeZone);
  }
  return new Date(exception.getTime() + (isBackConversion ? -1 : 1) * timezoneOffset * toMs3("hour"));
};
var isTimezoneChangeInDate = (date) => {
  const startDayDate = new Date(new Date(date).setHours(0, 0, 0, 0));
  const endDayDate = new Date(new Date(date).setHours(23, 59, 59, 0));
  return startDayDate.getTimezoneOffset() - endDayDate.getTimezoneOffset() !== 0;
};
var getDateWithoutTimezoneChange = (date) => {
  const clonedDate = new Date(date);
  if (isTimezoneChangeInDate(clonedDate)) {
    const result = new Date(clonedDate);
    return new Date(result.setDate(result.getDate() + 1));
  }
  return clonedDate;
};
var isSameAppointmentDates = (startDate, endDate) => {
  endDate = new Date(endDate.getTime() - 1);
  return date_default2.sameDate(startDate, endDate);
};
var getClientTimezoneOffset = function() {
  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  return 6e4 * date.getTimezoneOffset();
};
var getDiffBetweenClientTimezoneOffsets = function() {
  let firstDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  let secondDate = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  return getClientTimezoneOffset(firstDate) - getClientTimezoneOffset(secondDate);
};
var isEqualLocalTimeZone = function(timeZoneName) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (Intl) {
    const localTimeZoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
    if (localTimeZoneName === timeZoneName) {
      return true;
    }
  }
  return isEqualLocalTimeZoneByDeclaration(timeZoneName, date);
};
var hasDSTInLocalTimeZone = () => {
  const [startDate, endDate] = getExtremeDates();
  return startDate.getTimezoneOffset() !== endDate.getTimezoneOffset();
};
var getOffset = (date) => -date.getTimezoneOffset() / 60;
var getDateAndMoveHourBack = (dateStamp) => new Date(dateStamp - toMs3("hour"));
var isEqualLocalTimeZoneByDeclarationOld = (timeZoneName, date) => {
  const year = date.getFullYear();
  const configTuple = m_utils_timezones_data_default.getTimeZoneDeclarationTuple(timeZoneName, year);
  const [summerTime, winterTime] = configTuple;
  const noDSTInTargetTimeZone = configTuple.length < 2;
  if (noDSTInTargetTimeZone) {
    const targetTimeZoneOffset = m_utils_timezones_data_default.getTimeZoneOffsetById(timeZoneName, date);
    const localTimeZoneOffset = getOffset(date);
    if (targetTimeZoneOffset !== localTimeZoneOffset) {
      return false;
    }
    return !hasDSTInLocalTimeZone();
  }
  const localSummerOffset = getOffset(new Date(summerTime.date));
  const localWinterOffset = getOffset(new Date(winterTime.date));
  if (localSummerOffset !== summerTime.offset) {
    return false;
  }
  if (localSummerOffset === getOffset(getDateAndMoveHourBack(summerTime.date))) {
    return false;
  }
  if (localWinterOffset !== winterTime.offset) {
    return false;
  }
  if (localWinterOffset === getOffset(getDateAndMoveHourBack(winterTime.date))) {
    return false;
  }
  return true;
};
var isEqualLocalTimeZoneByDeclaration = (timeZoneName, date) => {
  const customTimezones = m_utils_timezones_data_default.getTimeZonesOld();
  const targetTimezoneData = customTimezones.filter((tz) => tz.id === timeZoneName);
  if (1 === targetTimezoneData.length) {
    return isEqualLocalTimeZoneByDeclarationOld(timeZoneName, date);
  }
  return false;
};
var getExtremeDates = () => {
  const nowDate = new Date(Date.now());
  const startDate = /* @__PURE__ */ new Date();
  const endDate = /* @__PURE__ */ new Date();
  startDate.setFullYear(nowDate.getFullYear(), 0, 1);
  endDate.setFullYear(nowDate.getFullYear(), 6, 1);
  return [startDate, endDate];
};
var setOffsetsToDate = (targetDate, offsetsArray) => {
  const newDateMs = offsetsArray.reduce((result, offset) => result + offset, targetDate.getTime());
  return new Date(newDateMs);
};
var addOffsetsWithoutDST = function(date) {
  for (var _len = arguments.length, offsets = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    offsets[_key - 1] = arguments[_key];
  }
  const newDate = dateUtilsTs.addOffsets(date, offsets);
  const daylightShift = getDaylightOffsetInMs(date, newDate);
  if (!daylightShift) {
    return newDate;
  }
  const correctLocalDate = dateUtilsTs.addOffsets(newDate, [-daylightShift]);
  const daylightSecondShift = getDaylightOffsetInMs(newDate, correctLocalDate);
  return !daylightSecondShift ? correctLocalDate : newDate;
};
var utils = {
  getDaylightOffset,
  getDaylightOffsetInMs,
  getTimezoneOffsetChangeInMinutes,
  getTimezoneOffsetChangeInMs,
  calculateTimezoneByValue,
  getCorrectedDateByDaylightOffsets,
  isSameAppointmentDates,
  correctRecurrenceExceptionByTimezone,
  getClientTimezoneOffset,
  getDiffBetweenClientTimezoneOffsets,
  createUTCDateWithLocalOffset,
  createDateFromUTCWithLocalOffset,
  createUTCDate,
  isTimezoneChangeInDate,
  getDateWithoutTimezoneChange,
  hasDSTInLocalTimeZone,
  isEqualLocalTimeZone,
  isEqualLocalTimeZoneByDeclaration,
  getTimeZones,
  setOffsetsToDate,
  addOffsetsWithoutDST
};
var m_utils_time_zone_default = utils;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/timezone_calculator/utils.js
var createTimeZoneCalculator = (currentTimeZone) => new TimeZoneCalculator({
  getClientOffset: (date) => m_utils_time_zone_default.getClientTimezoneOffset(date),
  tryGetCommonOffset: (date) => m_utils_time_zone_default.calculateTimezoneByValue(currentTimeZone, date),
  tryGetAppointmentOffset: (date, appointmentTimezone) => m_utils_time_zone_default.calculateTimezoneByValue(appointmentTimezone, date)
});

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/themes.js
var getThemeType = () => {
  const theme = current();
  return {
    isCompact: isCompact(theme),
    isMaterial: isMaterial(theme),
    isFluent: isFluent(theme),
    isMaterialBased: isMaterialBased(theme)
  };
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_classes.js
var FIXED_CONTAINER_CLASS = "dx-scheduler-fixed-appointments";
var REDUCED_APPOINTMENT_CLASS = "dx-scheduler-appointment-reduced";
var REDUCED_APPOINTMENT_ICON = "dx-scheduler-appointment-reduced-icon";
var RECURRENCE_APPOINTMENT_CLASS = "dx-scheduler-appointment-recurrence";
var EMPTY_APPOINTMENT_CLASS = "dx-scheduler-appointment-empty";
var ALL_DAY_APPOINTMENT_CLASS = "dx-scheduler-all-day-appointment";
var REDUCED_APPOINTMENT_PARTS_CLASSES = {
  head: "dx-scheduler-appointment-head",
  body: "dx-scheduler-appointment-body",
  tail: "dx-scheduler-appointment-tail"
};
var DIRECTION_APPOINTMENT_CLASSES = {
  horizontal: "dx-scheduler-appointment-horizontal",
  vertical: "dx-scheduler-appointment-vertical"
};
var APPOINTMENT_DRAG_SOURCE_CLASS = "dx-scheduler-appointment-drag-source";
var APPOINTMENT_ITEM_CLASS = "dx-scheduler-appointment";
var APPOINTMENT_CONTENT_CLASSES = {
  APPOINTMENT_CONTENT_DETAILS: "dx-scheduler-appointment-content-details",
  RECURRING_ICON: "dx-scheduler-appointment-recurrence-icon",
  APPOINTMENT_TITLE: "dx-scheduler-appointment-title",
  APPOINTMENT_DATE: "dx-scheduler-appointment-content-date",
  ALL_DAY_CONTENT: "dx-scheduler-appointment-content-allday",
  ITEM: "dx-scheduler-appointment",
  STRIP: "dx-scheduler-appointment-strip",
  AGENDA_MARKER: "dx-scheduler-agenda-appointment-marker",
  AGENDA_RESOURCE_LIST: "dx-scheduler-appointment-resource-list",
  AGENDA_RESOURCE_LIST_ITEM: "dx-scheduler-appointment-resource-item",
  AGENDA_RESOURCE_LIST_ITEM_VALUE: "dx-scheduler-appointment-resource-item-value"
};
var AGENDA_LAST_IN_DATE_APPOINTMENT_CLASS = "dx-scheduler-last-in-date-agenda-appointment";
var APPOINTMENT_HAS_RESOURCE_COLOR_CLASS = "dx-scheduler-appointment-has-resource-color";
var HEADER_CURRENT_TIME_CELL_CLASS = "dx-scheduler-header-panel-current-time-cell";
var VIRTUAL_CELL_CLASS = "dx-scheduler-virtual-cell";
var TIME_PANEL_CLASS = "dx-scheduler-time-panel";
var DATE_TABLE_CLASS = "dx-scheduler-date-table";
var DATE_TABLE_ROW_CLASS = "dx-scheduler-date-table-row";
var GROUP_ROW_CLASS = "dx-scheduler-group-row";
var GROUP_HEADER_CONTENT_CLASS = "dx-scheduler-group-header-content";
var LAST_GROUP_CELL_CLASS = "dx-scheduler-last-group-cell";
var FIRST_GROUP_CELL_CLASS = "dx-scheduler-first-group-cell";
var VERTICAL_GROUP_COUNT_CLASSES = ["dx-scheduler-group-column-count-one", "dx-scheduler-group-column-count-two", "dx-scheduler-group-column-count-three"];

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_constants.js
var LIST_ITEM_DATA_KEY = "dxListItemData";
var LIST_ITEM_CLASS = "dx-list-item";
var APPOINTMENT_SETTINGS_KEY = "dxAppointmentSettings";
var HORIZONTAL_GROUP_ORIENTATION = "horizontal";
var VIEWS = {
  DAY: "day",
  WEEK: "week",
  WORK_WEEK: "workWeek",
  MONTH: "month",
  TIMELINE_DAY: "timelineDay",
  TIMELINE_WEEK: "timelineWeek",
  TIMELINE_WORK_WEEK: "timelineWorkWeek",
  TIMELINE_MONTH: "timelineMonth",
  AGENDA: "agenda"
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/const.js
var VERTICAL_GROUP_ORIENTATION = "vertical";
var HORIZONTAL_GROUP_ORIENTATION2 = "horizontal";
var TIMELINE_VIEWS = {
  timelineDay: true,
  timelineWeek: true,
  timelineWorkWeek: true,
  timelineMonth: true
};
var VIEW_TYPES = ["day", "week", "workWeek", "month", "timelineDay", "timelineWeek", "timelineWorkWeek", "timelineMonth", "agenda"];

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/base.js
var toMs4 = date_default2.dateToMilliseconds;
var getDurationInHours = (startDate, endDate) => Math.floor((endDate.getTime() - startDate.getTime()) / toMs4("hour"));
var getDatesWithoutTime = (min, max) => {
  const newMin = date_default2.trimTime(min);
  const newMax = date_default2.trimTime(max);
  newMax.setDate(newMax.getDate() + 1);
  return [newMin, newMax];
};
var getAppointmentRenderingStrategyName = (viewType) => {
  const {
    renderingStrategy
  } = {
    day: {
      renderingStrategy: "vertical"
    },
    week: {
      renderingStrategy: "week"
    },
    workWeek: {
      renderingStrategy: "week"
    },
    month: {
      renderingStrategy: "horizontalMonth"
    },
    timelineDay: {
      renderingStrategy: "horizontal"
    },
    timelineWeek: {
      renderingStrategy: "horizontal"
    },
    timelineWorkWeek: {
      renderingStrategy: "horizontal"
    },
    timelineMonth: {
      renderingStrategy: "horizontalMonthLine"
    },
    agenda: {
      renderingStrategy: "agenda"
    }
  }[viewType];
  return renderingStrategy;
};
var getAppointmentTakesAllDay = (appointmentAdapter, allDayPanelMode) => {
  const {
    startDate,
    endDate,
    allDay
  } = appointmentAdapter;
  switch (allDayPanelMode) {
    case "hidden":
      return false;
    case "allDay":
      return allDay;
    default:
      if (allDay) {
        return true;
      }
      if (!isDefined(endDate)) {
        return false;
      }
      return getDurationInHours(startDate, endDate) >= 24;
  }
};
var getAppointmentKey = (geometry) => {
  const {
    left,
    top,
    width,
    height
  } = geometry;
  return `${left}-${top}-${width}-${height}`;
};
var hasResourceValue = (resourceValues, itemValue) => isDefined(resourceValues.find((value2) => equalByValue(value2, itemValue)));
var getOverflowIndicatorColor = (color, colors) => !colors.length || 0 === colors.filter((item) => item !== color).length ? color : void 0;
var getVerticalGroupCountClass = (groups) => {
  switch (null === groups || void 0 === groups ? void 0 : groups.length) {
    case 1:
      return VERTICAL_GROUP_COUNT_CLASSES[0];
    case 2:
      return VERTICAL_GROUP_COUNT_CLASSES[1];
    case 3:
      return VERTICAL_GROUP_COUNT_CLASSES[2];
    default:
      return;
  }
};
var setOptionHour = (date, optionHour) => {
  const nextDate = new Date(date);
  if (!isDefined(optionHour)) {
    return nextDate;
  }
  nextDate.setHours(optionHour, optionHour % 1 * 60, 0, 0);
  return nextDate;
};
var calculateDayDuration = (startDayHour, endDayHour) => endDayHour - startDayHour;
var getStartViewDateTimeOffset = (startViewDate, startDayHour) => {
  const validStartDayHour = Math.floor(startDayHour);
  const isDSTChange = m_utils_time_zone_default.isTimezoneChangeInDate(startViewDate);
  if (isDSTChange && validStartDayHour !== startViewDate.getHours()) {
    return date_default2.dateToMilliseconds("hour");
  }
  return 0;
};
var getValidCellDateForLocalTimeFormat = (date, _ref) => {
  let {
    startViewDate,
    startDayHour,
    cellIndexShift,
    viewOffset
  } = _ref;
  const originDate = dateUtilsTs.addOffsets(date, [-viewOffset]);
  const localTimeZoneChangedInOriginDate = m_utils_time_zone_default.isTimezoneChangeInDate(originDate);
  if (!localTimeZoneChangedInOriginDate) {
    return date;
  }
  const startViewDateWithoutDST = new Date(new Date(startViewDate).setDate(startViewDate.getDate() + 2));
  const startViewDateOffset = getStartViewDateTimeOffset(startViewDate, startDayHour);
  return dateUtilsTs.addOffsets(startViewDateWithoutDST, [viewOffset, cellIndexShift, -startViewDateOffset]);
};
var getTotalCellCountByCompleteData = (completeData) => completeData[completeData.length - 1].length;
var getDisplayedCellCount = (displayedCellCount, completeData) => displayedCellCount ?? getTotalCellCountByCompleteData(completeData);
var getHeaderCellText = (headerIndex, date, headerCellTextFormat, getDateForHeaderText2, additionalOptions) => {
  const validDate = getDateForHeaderText2(headerIndex, date, additionalOptions);
  return date_default.format(validDate, headerCellTextFormat);
};
var isVerticalGroupingApplied = (groups, groupOrientation) => groupOrientation === VERTICAL_GROUP_ORIENTATION && !!groups.length;
var getGroupCount = (groups) => {
  let result = 0;
  for (let i = 0, len = groups.length; i < len; i += 1) {
    if (!i) {
      result = groups[i].items.length;
    } else {
      result *= groups[i].items.length;
    }
  }
  return result;
};
var getHorizontalGroupCount = (groups, groupOrientation) => {
  const groupCount = getGroupCount(groups) || 1;
  const isVerticalGrouping = isVerticalGroupingApplied(groups, groupOrientation);
  return isVerticalGrouping ? 1 : groupCount;
};
var isTimelineView = (viewType) => !!TIMELINE_VIEWS[viewType];
var isDateAndTimeView = (viewType) => viewType !== VIEWS.TIMELINE_MONTH && viewType !== VIEWS.MONTH;
var isHorizontalView = (viewType) => {
  switch (viewType) {
    case VIEWS.TIMELINE_DAY:
    case VIEWS.TIMELINE_WEEK:
    case VIEWS.TIMELINE_WORK_WEEK:
    case VIEWS.TIMELINE_MONTH:
    case VIEWS.MONTH:
      return true;
    default:
      return false;
  }
};
var isDateInRange = (date, startDate, endDate, diff) => diff > 0 ? date_default2.dateInRange(date, startDate, new Date(endDate.getTime() - 1)) : date_default2.dateInRange(date, endDate, startDate, "date");
var isFirstCellInMonthWithIntervalCount = (cellDate, intervalCount) => 1 === cellDate.getDate() && intervalCount > 1;
var getViewStartByOptions = (startDate, currentDate, intervalDuration, startViewDate) => {
  if (!startDate) {
    return new Date(currentDate);
  }
  let currentStartDate = date_default2.trimTime(startViewDate);
  const diff = currentStartDate.getTime() <= currentDate.getTime() ? 1 : -1;
  let endDate = new Date(currentStartDate.getTime() + intervalDuration * diff);
  while (!isDateInRange(currentDate, currentStartDate, endDate, diff)) {
    currentStartDate = endDate;
    endDate = new Date(currentStartDate.getTime() + intervalDuration * diff);
  }
  return diff > 0 ? currentStartDate : endDate;
};
var calculateIsGroupedAllDayPanel = (groups, groupOrientation, isAllDayPanelVisible) => isVerticalGroupingApplied(groups, groupOrientation) && isAllDayPanelVisible;
var calculateViewStartDate = (startDateOption) => startDateOption;
var getCellDuration = (viewType, startDayHour, endDayHour, hoursInterval) => {
  switch (viewType) {
    case "month":
      return 36e5 * calculateDayDuration(startDayHour, endDayHour);
    case "timelineMonth":
      return date_default2.dateToMilliseconds("day");
    default:
      return 36e5 * hoursInterval;
  }
};
var calculateCellIndex = (rowIndex, columnIndex, rowCount) => columnIndex * rowCount + rowIndex;
var getTotalRowCountByCompleteData = (completeData) => completeData.length;
var getDisplayedRowCount = (displayedRowCount, completeData) => displayedRowCount ?? getTotalRowCountByCompleteData(completeData);
var getStartViewDateWithoutDST = (startViewDate, startDayHour) => {
  const newStartViewDate = m_utils_time_zone_default.getDateWithoutTimezoneChange(startViewDate);
  newStartViewDate.setHours(startDayHour);
  return newStartViewDate;
};
var getIsGroupedAllDayPanel = (hasAllDayRow, isVerticalGrouping) => hasAllDayRow && isVerticalGrouping;
var getKeyByGroup = (groupIndex, isVerticalGrouping) => {
  if (isVerticalGrouping && !!groupIndex) {
    return groupIndex.toString();
  }
  return "0";
};
var getToday = (indicatorTime, timeZoneCalculator) => {
  const todayDate = indicatorTime ?? /* @__PURE__ */ new Date();
  return (null === timeZoneCalculator || void 0 === timeZoneCalculator ? void 0 : timeZoneCalculator.createDate(todayDate, {
    path: "toGrid"
  })) || todayDate;
};
var getCalculatedFirstDayOfWeek = (firstDayOfWeekOption) => isDefined(firstDayOfWeekOption) ? firstDayOfWeekOption : date_default.firstDayOfWeekIndex();
var isHorizontalGroupingApplied = (groups, groupOrientation) => groupOrientation === HORIZONTAL_GROUP_ORIENTATION2 && !!groups.length;
var isGroupingByDate = (groups, groupOrientation, groupByDate) => {
  const isHorizontalGrouping = isHorizontalGroupingApplied(groups, groupOrientation);
  return groupByDate && isHorizontalGrouping;
};
var getSkippedHoursInRange = (startDate, endDate, allDay, viewDataProvider) => {
  const isAllDay = allDay && !viewDataProvider.viewType.includes("timeline");
  let result = 0;
  const currentDate = new Date(startDate);
  currentDate.setDate(currentDate.getDate() + 1);
  currentDate.setHours(0, 0, 0, 0);
  const endDateWithStartHour = new Date(endDate);
  endDateWithStartHour.setHours(0, 0, 0, 0);
  const {
    startDayHour,
    endDayHour
  } = viewDataProvider.getViewOptions();
  const dayHours = isAllDay ? 24 : endDayHour - startDayHour;
  while (currentDate < endDateWithStartHour) {
    if (viewDataProvider.isSkippedDate(currentDate)) {
      result += dayHours;
    }
    currentDate.setDate(currentDate.getDate() + 1);
  }
  const startDateHours = startDate.getHours();
  const endDateHours = endDate.getHours() + endDate.getTime() % 36e5 / 36e5;
  if (viewDataProvider.isSkippedDate(startDate)) {
    if (isAllDay) {
      result += 24;
    } else if (startDateHours < startDayHour) {
      result += dayHours;
    } else if (startDateHours < endDayHour) {
      result += endDayHour - startDateHours;
    }
  }
  if (viewDataProvider.isSkippedDate(endDate)) {
    if (isAllDay) {
      result += 24;
    } else if (endDateHours > endDayHour) {
      result += dayHours;
    } else if (endDateHours > startDayHour) {
      result += endDateHours - startDayHour;
    }
  }
  return result;
};
var isDataOnWeekend = (date) => {
  const day = date.getDay();
  return 6 === day || 0 === day;
};
var getWeekendsCount = (days3) => 2 * Math.floor(days3 / 7);
var extendGroupItemsForGroupingByDate = (groupRenderItems, columnCountPerGroup) => [...new Array(columnCountPerGroup)].reduce((currentGroupItems, _, index) => groupRenderItems.map((groupsRow, rowIndex) => {
  const currentRow = currentGroupItems[rowIndex] || [];
  return [...currentRow, ...groupsRow.map((item, columnIndex) => _extends({}, item, {
    key: `${item.key}_group_by_date_${index}`,
    isFirstGroupCell: 0 === columnIndex,
    isLastGroupCell: columnIndex === groupsRow.length - 1
  }))];
}), []);
var getGroupPanelData = (groups, columnCountPerGroup, groupByDate, baseColSpan) => {
  let repeatCount = 1;
  let groupPanelItems = groups.map((group) => {
    const result = [];
    const {
      name: resourceName,
      items,
      data: data2
    } = group;
    for (let iterator = 0; iterator < repeatCount; iterator += 1) {
      result.push(...items.map((_ref2, index) => {
        let {
          id,
          text,
          color
        } = _ref2;
        return {
          id,
          text,
          color,
          key: `${iterator}_${resourceName}_${id}`,
          resourceName,
          data: null === data2 || void 0 === data2 ? void 0 : data2[index]
        };
      }));
    }
    repeatCount *= items.length;
    return result;
  });
  if (groupByDate) {
    groupPanelItems = extendGroupItemsForGroupingByDate(groupPanelItems, columnCountPerGroup);
  }
  return {
    groupPanelItems,
    baseColSpan
  };
};
var splitNumber = (value2, splitValue) => Array.from({
  length: Math.ceil(value2 / splitValue)
}, (_, index) => Math.min(value2 - splitValue * index, splitValue));

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/agenda.js
var calculateStartViewDate = (currentDate, startDayHour) => {
  const validCurrentDate = new Date(currentDate);
  return setOptionHour(validCurrentDate, startDayHour);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/day.js
var calculateStartViewDate2 = (currentDate, startDayHour, startDate, intervalDuration) => {
  const firstViewDate = getViewStartByOptions(startDate, currentDate, intervalDuration, startDate);
  return setOptionHour(firstViewDate, startDayHour);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/month.js
var calculateCellIndex2 = (rowIndex, columnIndex, _, columnCount) => rowIndex * columnCount + columnIndex;
var getViewStartByOptions2 = (startDate, currentDate, intervalCount, startViewDate) => {
  if (!startDate) {
    return new Date(currentDate);
  }
  let currentStartDate = new Date(startViewDate);
  const validStartViewDate = new Date(startViewDate);
  const diff = currentStartDate.getTime() <= currentDate.getTime() ? 1 : -1;
  let endDate = new Date(new Date(validStartViewDate.setMonth(validStartViewDate.getMonth() + diff * intervalCount)));
  while (!isDateInRange(currentDate, currentStartDate, endDate, diff)) {
    currentStartDate = new Date(endDate);
    if (diff > 0) {
      currentStartDate.setDate(1);
    }
    endDate = new Date(new Date(endDate.setMonth(endDate.getMonth() + diff * intervalCount)));
  }
  return diff > 0 ? currentStartDate : endDate;
};
var getCellText = (date, intervalCount) => {
  if (isFirstCellInMonthWithIntervalCount(date, intervalCount)) {
    const monthName = date_default.getMonthNames("abbreviated")[date.getMonth()];
    return [monthName, date_default.format(date, "day")].join(" ");
  }
  return date_default.format(date, "dd");
};
var calculateStartViewDate3 = (currentDate, startDayHour, startDate, intervalCount, firstDayOfWeekOption) => {
  const viewStart = getViewStartByOptions2(startDate, currentDate, intervalCount, date_default2.getFirstMonthDate(startDate));
  const firstMonthDate = date_default2.getFirstMonthDate(viewStart);
  const firstDayOfWeek = getCalculatedFirstDayOfWeek(firstDayOfWeekOption);
  const firstViewDate = date_default2.getFirstWeekDate(firstMonthDate, firstDayOfWeek);
  return setOptionHour(firstViewDate, startDayHour);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/render.js
var addToStyles = (options, style) => {
  const nextStyle = style ?? {};
  const result = _extends({}, nextStyle);
  options.forEach((_ref) => {
    let {
      attr,
      value: value2
    } = _ref;
    result[attr] = value2 || nextStyle[attr];
  });
  return result;
};
var addWidthToStyle = (value2, style) => {
  const width = value2 ? `${value2}px` : "";
  return addToStyles([{
    attr: "width",
    value: width
  }], style);
};
var addHeightToStyle = (value2, style) => {
  const height = value2 ? `${value2}px` : "";
  return addToStyles([{
    attr: "height",
    value: height
  }], style);
};
var combineClasses = (classesMap) => Object.keys(classesMap).filter((cssClass) => !!cssClass && classesMap[cssClass]).join(" ");
var getGroupCellClasses = function() {
  let isFirstGroupCell = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
  let isLastGroupCell = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
  let className = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
  return combineClasses({
    "dx-scheduler-first-group-cell": isFirstGroupCell,
    "dx-scheduler-last-group-cell": isLastGroupCell,
    [className]: true
  });
};
var getCellSizeHorizontalClass = (viewType, crossScrollingEnabled) => {
  switch (viewType) {
    case "day":
    case "week":
    case "workWeek":
    case "month":
      return crossScrollingEnabled ? "dx-scheduler-cell-sizes-horizontal" : "";
    default:
      return "dx-scheduler-cell-sizes-horizontal";
  }
};
var getCellSizeVerticalClass = (isAllDayCell) => !isAllDayCell ? "dx-scheduler-cell-sizes-vertical" : "";

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/timeline_month.js
var calculateStartViewDate4 = (currentDate, startDayHour, startDate, intervalCount) => {
  const firstViewDate = date_default2.getFirstMonthDate(getViewStartByOptions2(startDate, currentDate, intervalCount, date_default2.getFirstMonthDate(startDate)));
  return setOptionHour(firstViewDate, startDayHour);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/timeline_week.js
var getDateForHeaderText = (index, date, _ref) => {
  let {
    startDayHour,
    startViewDate,
    cellCountInDay,
    interval,
    viewOffset
  } = _ref;
  return getValidCellDateForLocalTimeFormat(date, {
    startViewDate,
    startDayHour,
    cellIndexShift: index % cellCountInDay * interval,
    viewOffset
  });
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/views.js
var getCurrentView = (currentView, views) => {
  let currentViewProps = views.find((view) => {
    const names = isObject(view) ? [view.name, view.type] : [view];
    if (names.includes(currentView)) {
      return true;
    }
    return false;
  });
  if (void 0 === currentViewProps) {
    if (VIEW_TYPES.includes(currentView)) {
      currentViewProps = currentView;
    } else {
      [currentViewProps] = views;
    }
  }
  return currentViewProps;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/week.js
var getTimePanelCellText = (rowIndex, date, startViewDate, cellDuration, startDayHour, viewOffset) => {
  if (rowIndex % 2 !== 0) {
    return "";
  }
  const validTimeDate = getValidCellDateForLocalTimeFormat(date, {
    startViewDate,
    startDayHour,
    cellIndexShift: Math.round(cellDuration) * rowIndex,
    viewOffset
  });
  return date_default.format(validTimeDate, "shorttime");
};
var getIntervalDuration = (intervalCount) => 7 * date_default2.dateToMilliseconds("day") * intervalCount;
var getValidStartDate = (startDate, firstDayOfWeek) => startDate ? date_default2.getFirstWeekDate(startDate, firstDayOfWeek) : void 0;
var calculateStartViewDate5 = (currentDate, startDayHour, startDate, intervalDuration, firstDayOfWeekOption) => {
  const firstDayOfWeek = getCalculatedFirstDayOfWeek(firstDayOfWeekOption);
  const viewStart = getViewStartByOptions(startDate, currentDate, intervalDuration, getValidStartDate(startDate, firstDayOfWeek));
  const firstViewDate = date_default2.getFirstWeekDate(viewStart, firstDayOfWeek);
  return setOptionHour(firstViewDate, startDayHour);
};
var calculateViewStartDate2 = (startDateOption, firstDayOfWeek) => {
  const validFirstDayOfWeek = firstDayOfWeek ?? date_default.firstDayOfWeekIndex();
  return date_default2.getFirstWeekDate(startDateOption, validFirstDayOfWeek);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/work_week.js
var calculateStartViewDate6 = (currentDate, startDayHour, startDate, intervalDuration, firstDayOfWeek) => {
  const viewStart = getViewStartByOptions(startDate, currentDate, intervalDuration, getValidStartDate(startDate, firstDayOfWeek));
  const firstViewDate = date_default2.getFirstWeekDate(viewStart, firstDayOfWeek);
  if (isDataOnWeekend(firstViewDate)) {
    const currentDay = firstViewDate.getDay();
    const distance = (8 - currentDay) % 7;
    firstViewDate.setDate(firstViewDate.getDate() + distance);
  }
  return setOptionHour(firstViewDate, startDayHour);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_expression_utils.js
var ExpressionUtils = {
  getField: (dataAccessors, field, obj) => {
    if (!isDefined(dataAccessors.getter[field])) {
      return;
    }
    return dataAccessors.getter[field](obj);
  },
  setField: (dataAccessors, field, obj, value2) => {
    if (!isDefined(dataAccessors.setter[field])) {
      return;
    }
    dataAccessors.setter[field](obj, value2);
    return obj;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/data_provider/m_utils.js
var toMs5 = date_default2.dateToMilliseconds;
var FULL_DATE_FORMAT = "yyyyMMddTHHmmss";
var compareDateWithStartDayHour = (startDate, endDate, startDayHour, allDay, severalDays) => {
  const startTime = date_default2.dateTimeFromDecimal(startDayHour);
  const result = startDate.getHours() >= startTime.hours && startDate.getMinutes() >= startTime.minutes || endDate.getHours() === startTime.hours && endDate.getMinutes() > startTime.minutes || endDate.getHours() > startTime.hours || severalDays || allDay;
  return result;
};
var compareDateWithEndDayHour = (options) => {
  const {
    startDate,
    endDate,
    startDayHour,
    endDayHour,
    viewStartDayHour,
    viewEndDayHour,
    allDay,
    severalDays,
    min,
    max,
    checkIntersectViewport
  } = options;
  const hiddenInterval = (24 - viewEndDayHour + viewStartDayHour) * toMs5("hour");
  const apptDuration = endDate.getTime() - startDate.getTime();
  const delta = (hiddenInterval - apptDuration) / toMs5("hour");
  const apptStartHour = startDate.getHours();
  const apptStartMinutes = startDate.getMinutes();
  let result;
  const endTime = date_default2.dateTimeFromDecimal(endDayHour);
  const startTime = date_default2.dateTimeFromDecimal(startDayHour);
  const apptIntersectViewport = startDate < max && endDate > min;
  result = checkIntersectViewport && apptIntersectViewport || apptStartHour < endTime.hours || apptStartHour === endTime.hours && apptStartMinutes < endTime.minutes || allDay && startDate <= max || severalDays && apptIntersectViewport && (apptStartHour < endTime.hours || 60 * endDate.getHours() + endDate.getMinutes() > 60 * startTime.hours);
  if (apptDuration < hiddenInterval) {
    if (apptStartHour > endTime.hours && apptStartMinutes > endTime.minutes && delta <= apptStartHour - endDayHour) {
      result = false;
    }
  }
  return result;
};
var getAppointmentTakesSeveralDays = (adapter) => !date_default2.sameDate(adapter.startDate, adapter.endDate);
var _isEndDateWrong = (startDate, endDate) => !endDate || isNaN(endDate.getTime()) || startDate.getTime() > endDate.getTime();
var _appointmentPartInInterval = (startDate, endDate, startDayHour, endDayHour) => {
  const apptStartDayHour = startDate.getHours();
  const apptEndDayHour = endDate.getHours();
  return apptStartDayHour <= startDayHour && apptEndDayHour <= endDayHour && apptEndDayHour >= startDayHour || apptEndDayHour >= endDayHour && apptStartDayHour <= endDayHour && apptStartDayHour >= startDayHour;
};
var getRecurrenceException = (appointmentAdapter, timeZoneCalculator, timeZone) => {
  const {
    recurrenceException
  } = appointmentAdapter;
  if (recurrenceException) {
    const exceptions = recurrenceException.split(",");
    for (let i = 0; i < exceptions.length; i++) {
      exceptions[i] = _convertRecurrenceException(exceptions[i], appointmentAdapter.startDate, timeZoneCalculator, timeZone);
    }
    return exceptions.join();
  }
  return recurrenceException;
};
var _convertRecurrenceException = (exceptionString, startDate, timeZoneCalculator, timeZone) => {
  exceptionString = exceptionString.replace(/\s/g, "");
  const getConvertedToTimeZone = (date) => timeZoneCalculator.createDate(date, {
    path: "toGrid"
  });
  const exceptionDate = date_serialization_default.deserializeDate(exceptionString);
  const convertedStartDate = getConvertedToTimeZone(startDate);
  let convertedExceptionDate = getConvertedToTimeZone(exceptionDate);
  convertedExceptionDate = m_utils_time_zone_default.correctRecurrenceExceptionByTimezone(convertedExceptionDate, convertedStartDate, timeZone);
  exceptionString = date_serialization_default.serializeDate(convertedExceptionDate, FULL_DATE_FORMAT);
  return exceptionString;
};
var replaceWrongEndDate = (rawAppointment, startDate, endDate, appointmentDuration, dataAccessors) => {
  if (_isEndDateWrong(startDate, endDate)) {
    const isAllDay = ExpressionUtils.getField(dataAccessors, "allDay", rawAppointment);
    const calculatedEndDate = ((isAllDay2, startDate2) => {
      if (isAllDay2) {
        return date_default2.setToDayEnd(new Date(startDate2));
      }
      return new Date(startDate2.getTime() + appointmentDuration * toMs5("minute"));
    })(isAllDay, startDate);
    dataAccessors.setter.endDate(rawAppointment, calculatedEndDate);
  }
};
var sortAppointmentsByStartDate = (appointments, dataAccessors) => {
  appointments.sort((a, b) => {
    const firstDate = new Date(ExpressionUtils.getField(dataAccessors, "startDate", a.settings || a));
    const secondDate = new Date(ExpressionUtils.getField(dataAccessors, "startDate", b.settings || b));
    return Math.sign(firstDate.getTime() - secondDate.getTime());
  });
};

// ../../../../../../node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = (
  /** @class */
  function() {
    function Weekday2(weekday, n) {
      if (n === 0)
        throw new Error("Can't create weekday with n == 0");
      this.weekday = weekday;
      this.n = n;
    }
    Weekday2.fromStr = function(str) {
      return new Weekday2(ALL_WEEKDAYS.indexOf(str));
    };
    Weekday2.prototype.nth = function(n) {
      return this.n === n ? this : new Weekday2(this.weekday, n);
    };
    Weekday2.prototype.equals = function(other) {
      return this.weekday === other.weekday && this.n === other.n;
    };
    Weekday2.prototype.toString = function() {
      var s = ALL_WEEKDAYS[this.weekday];
      if (this.n)
        s = (this.n > 0 ? "+" : "") + String(this.n) + s;
      return s;
    };
    Weekday2.prototype.getJsWeekday = function() {
      return this.weekday === 6 ? 0 : this.weekday + 1;
    };
    return Weekday2;
  }()
);

// ../../../../../../node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value2) {
  return value2 !== null && value2 !== void 0;
};
var isNumber = function(value2) {
  return typeof value2 === "number";
};
var isWeekdayStr = function(value2) {
  return typeof value2 === "string" && ALL_WEEKDAYS.includes(value2);
};
var isArray = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i = start; i < end; i++)
    rang.push(i);
  return rang;
};
var repeat = function(value2, times) {
  var i = 0;
  var array = [];
  if (isArray(value2)) {
    for (; i < times; i++)
      array[i] = [].concat(value2);
  } else {
    for (; i < times; i++)
      array[i] = value2;
  }
  return array;
};
var toArray = function(item) {
  if (isArray(item)) {
    return item;
  }
  return [item];
};
function padStart(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};
var divmod = function(a, b) {
  return { div: Math.floor(a / b), mod: pymod(a, b) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// ../../../../../../node_modules/rrule/dist/esm/dateutil.js
var datetime = function(y, m, d, h, i, s) {
  if (h === void 0) {
    h = 0;
  }
  if (i === void 0) {
    i = 0;
  }
  if (s === void 0) {
    s = 0;
  }
  return new Date(Date.UTC(y, m - 1, d, h, i, s));
};
var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var ONE_DAY = 1e3 * 60 * 60 * 24;
var MAXYEAR = 9999;
var ORDINAL_BASE = datetime(1970, 1, 1);
var PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
var isLeapYear = function(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var isDate = function(value2) {
  return value2 instanceof Date;
};
var isValidDate2 = function(value2) {
  return isDate(value2) && !isNaN(value2.getTime());
};
var daysBetween = function(date1, date2) {
  var date1ms = date1.getTime();
  var date2ms = date2.getTime();
  var differencems = date1ms - date2ms;
  return Math.round(differencems / ONE_DAY);
};
var toOrdinal = function(date) {
  return daysBetween(date, ORDINAL_BASE);
};
var fromOrdinal = function(ordinal) {
  return new Date(ORDINAL_BASE.getTime() + ordinal * ONE_DAY);
};
var getMonthDays = function(date) {
  var month = date.getUTCMonth();
  return month === 1 && isLeapYear(date.getUTCFullYear()) ? 29 : MONTH_DAYS[month];
};
var getWeekday = function(date) {
  return PY_WEEKDAYS[date.getUTCDay()];
};
var monthRange = function(year, month) {
  var date = datetime(year, month + 1, 1);
  return [getWeekday(date), getMonthDays(date)];
};
var combine = function(date, time) {
  time = time || date;
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
};
var clone = function(date) {
  var dolly = new Date(date.getTime());
  return dolly;
};
var cloneDates = function(dates) {
  var clones = [];
  for (var i = 0; i < dates.length; i++) {
    clones.push(clone(dates[i]));
  }
  return clones;
};
var sort = function(dates) {
  dates.sort(function(a, b) {
    return a.getTime() - b.getTime();
  });
};
var timeToUntilString = function(time, utc) {
  if (utc === void 0) {
    utc = true;
  }
  var date = new Date(time);
  return [
    padStart(date.getUTCFullYear().toString(), 4, "0"),
    padStart(date.getUTCMonth() + 1, 2, "0"),
    padStart(date.getUTCDate(), 2, "0"),
    "T",
    padStart(date.getUTCHours(), 2, "0"),
    padStart(date.getUTCMinutes(), 2, "0"),
    padStart(date.getUTCSeconds(), 2, "0"),
    utc ? "Z" : ""
  ].join("");
};
var untilStringToDate = function(until) {
  var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
  var bits = re.exec(until);
  if (!bits)
    throw new Error("Invalid UNTIL value: ".concat(until));
  return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
};
var dateTZtoISO8601 = function(date, timeZone) {
  var dateStr = date.toLocaleString("sv-SE", { timeZone });
  return dateStr.replace(" ", "T") + "Z";
};
var dateInTimeZone = function(date, timeZone) {
  var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  var dateInLocalTZ = new Date(dateTZtoISO8601(date, localTimeZone));
  var dateInTargetTZ = new Date(dateTZtoISO8601(date, timeZone !== null && timeZone !== void 0 ? timeZone : "UTC"));
  var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
  return new Date(date.getTime() - tzOffset);
};

// ../../../../../../node_modules/rrule/dist/esm/iterresult.js
var IterResult = (
  /** @class */
  function() {
    function IterResult2(method, args) {
      this.minDate = null;
      this.maxDate = null;
      this._result = [];
      this.total = 0;
      this.method = method;
      this.args = args;
      if (method === "between") {
        this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
        this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
      } else if (method === "before") {
        this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
      } else if (method === "after") {
        this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
      }
    }
    IterResult2.prototype.accept = function(date) {
      ++this.total;
      var tooEarly = this.minDate && date < this.minDate;
      var tooLate = this.maxDate && date > this.maxDate;
      if (this.method === "between") {
        if (tooEarly)
          return true;
        if (tooLate)
          return false;
      } else if (this.method === "before") {
        if (tooLate)
          return false;
      } else if (this.method === "after") {
        if (tooEarly)
          return true;
        this.add(date);
        return false;
      }
      return this.add(date);
    };
    IterResult2.prototype.add = function(date) {
      this._result.push(date);
      return true;
    };
    IterResult2.prototype.getValue = function() {
      var res = this._result;
      switch (this.method) {
        case "all":
        case "between":
          return res;
        case "before":
        case "after":
        default:
          return res.length ? res[res.length - 1] : null;
      }
    };
    IterResult2.prototype.clone = function() {
      return new IterResult2(this.method, this.args);
    };
    return IterResult2;
  }()
);
var iterresult_default = IterResult;

// ../../../../../../node_modules/rrule/node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// ../../../../../../node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = (
  /** @class */
  function(_super) {
    __extends(CallbackIterResult2, _super);
    function CallbackIterResult2(method, args, iterator) {
      var _this = _super.call(this, method, args) || this;
      _this.iterator = iterator;
      return _this;
    }
    CallbackIterResult2.prototype.add = function(date) {
      if (this.iterator(date, this._result.length)) {
        this._result.push(date);
        return true;
      }
      return false;
    };
    return CallbackIterResult2;
  }(iterresult_default)
);
var callbackiterresult_default = CallbackIterResult;

// ../../../../../../node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// ../../../../../../node_modules/rrule/dist/esm/nlp/totext.js
var contains = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = (
  /** @class */
  function() {
    function ToText2(rrule, gettext, language, dateFormatter) {
      if (gettext === void 0) {
        gettext = defaultGetText;
      }
      if (language === void 0) {
        language = i18n_default;
      }
      if (dateFormatter === void 0) {
        dateFormatter = defaultDateFormatter;
      }
      this.text = [];
      this.language = language || i18n_default;
      this.gettext = gettext;
      this.dateFormatter = dateFormatter;
      this.rrule = rrule;
      this.options = rrule.options;
      this.origOptions = rrule.origOptions;
      if (this.origOptions.bymonthday) {
        var bymonthday = [].concat(this.options.bymonthday);
        var bynmonthday = [].concat(this.options.bynmonthday);
        bymonthday.sort(function(a, b) {
          return a - b;
        });
        bynmonthday.sort(function(a, b) {
          return b - a;
        });
        this.bymonthday = bymonthday.concat(bynmonthday);
        if (!this.bymonthday.length)
          this.bymonthday = null;
      }
      if (isPresent(this.origOptions.byweekday)) {
        var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
        var days3 = String(byweekday);
        this.byweekday = {
          allWeeks: byweekday.filter(function(weekday) {
            return !weekday.n;
          }),
          someWeeks: byweekday.filter(function(weekday) {
            return Boolean(weekday.n);
          }),
          isWeekdays: days3.indexOf("MO") !== -1 && days3.indexOf("TU") !== -1 && days3.indexOf("WE") !== -1 && days3.indexOf("TH") !== -1 && days3.indexOf("FR") !== -1 && days3.indexOf("SA") === -1 && days3.indexOf("SU") === -1,
          isEveryDay: days3.indexOf("MO") !== -1 && days3.indexOf("TU") !== -1 && days3.indexOf("WE") !== -1 && days3.indexOf("TH") !== -1 && days3.indexOf("FR") !== -1 && days3.indexOf("SA") !== -1 && days3.indexOf("SU") !== -1
        };
        var sortWeekDays = function(a, b) {
          return a.weekday - b.weekday;
        };
        this.byweekday.allWeeks.sort(sortWeekDays);
        this.byweekday.someWeeks.sort(sortWeekDays);
        if (!this.byweekday.allWeeks.length)
          this.byweekday.allWeeks = null;
        if (!this.byweekday.someWeeks.length)
          this.byweekday.someWeeks = null;
      } else {
        this.byweekday = null;
      }
    }
    ToText2.isFullyConvertible = function(rrule) {
      var canConvert = true;
      if (!(rrule.options.freq in ToText2.IMPLEMENTED))
        return false;
      if (rrule.origOptions.until && rrule.origOptions.count)
        return false;
      for (var key in rrule.origOptions) {
        if (contains(["dtstart", "tzid", "wkst", "freq"], key))
          return true;
        if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
          return false;
      }
      return canConvert;
    };
    ToText2.prototype.isFullyConvertible = function() {
      return ToText2.isFullyConvertible(this.rrule);
    };
    ToText2.prototype.toString = function() {
      var gettext = this.gettext;
      if (!(this.options.freq in ToText2.IMPLEMENTED)) {
        return gettext("RRule error: Unable to fully convert this rrule to text");
      }
      this.text = [gettext("every")];
      this[RRule.FREQUENCIES[this.options.freq]]();
      if (this.options.until) {
        this.add(gettext("until"));
        var until = this.options.until;
        this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
      } else if (this.options.count) {
        this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
      }
      if (!this.isFullyConvertible())
        this.add(gettext("(~ approximate)"));
      return this.text.join("");
    };
    ToText2.prototype.HOURLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
    };
    ToText2.prototype.MINUTELY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
    };
    ToText2.prototype.DAILY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      }
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      } else if (this.origOptions.byhour) {
        this._byhour();
      }
    };
    ToText2.prototype.WEEKLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
      }
      if (this.byweekday && this.byweekday.isWeekdays) {
        if (this.options.interval === 1) {
          this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
        } else {
          this.add(gettext("on")).add(gettext("weekdays"));
        }
      } else if (this.byweekday && this.byweekday.isEveryDay) {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      } else {
        if (this.options.interval === 1)
          this.add(gettext("week"));
        if (this.origOptions.bymonth) {
          this.add(gettext("in"));
          this._bymonth();
        }
        if (this.bymonthday) {
          this._bymonthday();
        } else if (this.byweekday) {
          this._byweekday();
        }
        if (this.origOptions.byhour) {
          this._byhour();
        }
      }
    };
    ToText2.prototype.MONTHLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString()).add(gettext("months"));
          if (this.plural(this.options.interval))
            this.add(gettext("in"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(gettext("weekdays"));
      } else if (this.byweekday) {
        this._byweekday();
      }
    };
    ToText2.prototype.YEARLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
          this.add(gettext("years"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
      if (this.options.byyearday) {
        this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
      }
      if (this.options.byweekno) {
        this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
      }
    };
    ToText2.prototype._bymonthday = function() {
      var gettext = this.gettext;
      if (this.byweekday && this.byweekday.allWeeks) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
      } else {
        this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
      }
    };
    ToText2.prototype._byweekday = function() {
      var gettext = this.gettext;
      if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
      }
      if (this.byweekday.someWeeks) {
        if (this.byweekday.allWeeks)
          this.add(gettext("and"));
        this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
      }
    };
    ToText2.prototype._byhour = function() {
      var gettext = this.gettext;
      this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
    };
    ToText2.prototype._bymonth = function() {
      this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
    };
    ToText2.prototype.nth = function(n) {
      n = parseInt(n.toString(), 10);
      var nth;
      var gettext = this.gettext;
      if (n === -1)
        return gettext("last");
      var npos = Math.abs(n);
      switch (npos) {
        case 1:
        case 21:
        case 31:
          nth = npos + gettext("st");
          break;
        case 2:
        case 22:
          nth = npos + gettext("nd");
          break;
        case 3:
        case 23:
          nth = npos + gettext("rd");
          break;
        default:
          nth = npos + gettext("th");
      }
      return n < 0 ? nth + " " + gettext("last") : nth;
    };
    ToText2.prototype.monthtext = function(m) {
      return this.language.monthNames[m - 1];
    };
    ToText2.prototype.weekdaytext = function(wday) {
      var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
      return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
    };
    ToText2.prototype.plural = function(n) {
      return n % 100 !== 1;
    };
    ToText2.prototype.add = function(s) {
      this.text.push(" ");
      this.text.push(s);
      return this;
    };
    ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
      var _this = this;
      if (delim === void 0) {
        delim = ",";
      }
      if (!isArray(arr)) {
        arr = [arr];
      }
      var delimJoin = function(array, delimiter, finalDelimiter) {
        var list = "";
        for (var i = 0; i < array.length; i++) {
          if (i !== 0) {
            if (i === array.length - 1) {
              list += " " + finalDelimiter + " ";
            } else {
              list += delimiter + " ";
            }
          }
          list += array[i];
        }
        return list;
      };
      callback = callback || function(o) {
        return o.toString();
      };
      var realCallback = function(arg) {
        return callback && callback.call(_this, arg);
      };
      if (finalDelim) {
        return delimJoin(arr.map(realCallback), delim, finalDelim);
      } else {
        return arr.map(realCallback).join(delim + " ");
      }
    };
    return ToText2;
  }()
);
var totext_default = ToText;

// ../../../../../../node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = (
  /** @class */
  function() {
    function Parser2(rules) {
      this.done = true;
      this.rules = rules;
    }
    Parser2.prototype.start = function(text) {
      this.text = text;
      this.done = false;
      return this.nextSymbol();
    };
    Parser2.prototype.isDone = function() {
      return this.done && this.symbol === null;
    };
    Parser2.prototype.nextSymbol = function() {
      var best;
      var bestSymbol;
      this.symbol = null;
      this.value = null;
      do {
        if (this.done)
          return false;
        var rule = void 0;
        best = null;
        for (var name_1 in this.rules) {
          rule = this.rules[name_1];
          var match = rule.exec(this.text);
          if (match) {
            if (best === null || match[0].length > best[0].length) {
              best = match;
              bestSymbol = name_1;
            }
          }
        }
        if (best != null) {
          this.text = this.text.substr(best[0].length);
          if (this.text === "")
            this.done = true;
        }
        if (best == null) {
          this.done = true;
          this.symbol = null;
          this.value = null;
          return;
        }
      } while (bestSymbol === "SKIP");
      this.symbol = bestSymbol;
      this.value = best;
      return true;
    };
    Parser2.prototype.accept = function(name2) {
      if (this.symbol === name2) {
        if (this.value) {
          var v = this.value;
          this.nextSymbol();
          return v;
        }
        this.nextSymbol();
        return true;
      }
      return false;
    };
    Parser2.prototype.acceptNumber = function() {
      return this.accept("number");
    };
    Parser2.prototype.expect = function(name2) {
      if (this.accept(name2))
        return true;
      throw new Error("expected " + name2 + " but found " + this.symbol);
    };
    return Parser2;
  }()
);
function parseText(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text))
    return null;
  S();
  return options;
  function S() {
    ttr.expect("every");
    var n = ttr.acceptNumber();
    if (n)
      options.interval = parseInt(n[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        AT();
        F();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          AT();
          F();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        AT();
        MDAYs();
        F();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m = decodeM();
          if (!m) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m);
          ttr.nextSymbol();
        }
        ON();
        F();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n[0], 10)];
        while (ttr.accept("comma")) {
          n = ttr.acceptNumber();
          if (!n) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n[0], 10));
        }
      } else if (m) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n = ttr.acceptNumber();
      if (!n) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n[0], 10)];
      while (ttr.accept("comma")) {
        n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v = parseInt(ttr.value[1], 10);
        if (v < -366 || v > 366)
          throw new Error("Nth out of range: " + v);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v : v;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// ../../../../../../node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// ../../../../../../node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// ../../../../../../node_modules/rrule/dist/esm/datetime.js
var Time = (
  /** @class */
  function() {
    function Time2(hour, minute, second, millisecond) {
      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.millisecond = millisecond || 0;
    }
    Time2.prototype.getHours = function() {
      return this.hour;
    };
    Time2.prototype.getMinutes = function() {
      return this.minute;
    };
    Time2.prototype.getSeconds = function() {
      return this.second;
    };
    Time2.prototype.getMilliseconds = function() {
      return this.millisecond;
    };
    Time2.prototype.getTime = function() {
      return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
    };
    return Time2;
  }()
);
var DateTime = (
  /** @class */
  function(_super) {
    __extends(DateTime2, _super);
    function DateTime2(year, month, day, hour, minute, second, millisecond) {
      var _this = _super.call(this, hour, minute, second, millisecond) || this;
      _this.year = year;
      _this.month = month;
      _this.day = day;
      return _this;
    }
    DateTime2.fromDate = function(date) {
      return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
    };
    DateTime2.prototype.getWeekday = function() {
      return getWeekday(new Date(this.getTime()));
    };
    DateTime2.prototype.getTime = function() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
    };
    DateTime2.prototype.getDay = function() {
      return this.day;
    };
    DateTime2.prototype.getMonth = function() {
      return this.month;
    };
    DateTime2.prototype.getYear = function() {
      return this.year;
    };
    DateTime2.prototype.addYears = function(years) {
      this.year += years;
    };
    DateTime2.prototype.addMonths = function(months) {
      this.month += months;
      if (this.month > 12) {
        var yearDiv = Math.floor(this.month / 12);
        var monthMod = pymod(this.month, 12);
        this.month = monthMod;
        this.year += yearDiv;
        if (this.month === 0) {
          this.month = 12;
          --this.year;
        }
      }
    };
    DateTime2.prototype.addWeekly = function(days3, wkst) {
      if (wkst > this.getWeekday()) {
        this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days3 * 7;
      } else {
        this.day += -(this.getWeekday() - wkst) + days3 * 7;
      }
      this.fixDay();
    };
    DateTime2.prototype.addDaily = function(days3) {
      this.day += days3;
      this.fixDay();
    };
    DateTime2.prototype.addHours = function(hours, filtered, byhour) {
      if (filtered) {
        this.hour += Math.floor((23 - this.hour) / hours) * hours;
      }
      for (; ; ) {
        this.hour += hours;
        var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
        if (dayDiv) {
          this.hour = hourMod;
          this.addDaily(dayDiv);
        }
        if (empty(byhour) || includes(byhour, this.hour))
          break;
      }
    };
    DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
      if (filtered) {
        this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
      }
      for (; ; ) {
        this.minute += minutes;
        var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
        if (hourDiv) {
          this.minute = minuteMod;
          this.addHours(hourDiv, false, byhour);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
          break;
        }
      }
    };
    DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
      if (filtered) {
        this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
      }
      for (; ; ) {
        this.second += seconds;
        var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
        if (minuteDiv) {
          this.second = secondMod;
          this.addMinutes(minuteDiv, false, byhour, byminute);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
          break;
        }
      }
    };
    DateTime2.prototype.fixDay = function() {
      if (this.day <= 28) {
        return;
      }
      var daysinmonth = monthRange(this.year, this.month - 1)[1];
      if (this.day <= daysinmonth) {
        return;
      }
      while (this.day > daysinmonth) {
        this.day -= daysinmonth;
        ++this.month;
        if (this.month === 13) {
          this.month = 1;
          ++this.year;
          if (this.year > MAXYEAR) {
            return;
          }
        }
        daysinmonth = monthRange(this.year, this.month - 1)[1];
      }
    };
    DateTime2.prototype.add = function(options, filtered) {
      var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
      switch (freq) {
        case Frequency.YEARLY:
          return this.addYears(interval);
        case Frequency.MONTHLY:
          return this.addMonths(interval);
        case Frequency.WEEKLY:
          return this.addWeekly(interval, wkst);
        case Frequency.DAILY:
          return this.addDaily(interval);
        case Frequency.HOURLY:
          return this.addHours(interval, filtered, byhour);
        case Frequency.MINUTELY:
          return this.addMinutes(interval, filtered, byhour, byminute);
        case Frequency.SECONDLY:
          return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
      }
    };
    return DateTime2;
  }(Time)
);

// ../../../../../../node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys = Object.keys(options);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (isDate(options[key]) && !isValidDate2(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options);
}
function parseOptions(options) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date((/* @__PURE__ */ new Date()).setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i = 0; i < opts.bysetpos.length; i++) {
      var v = opts.bysetpos[i];
      if (v === 0 || !(v >= -366 && v <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i = 0; i < opts.bymonthday.length; i++) {
      var v = opts.bymonthday[i];
      if (v > 0) {
        bymonthday.push(v);
      } else if (v < 0) {
        bynmonthday.push(v);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i = 0; i < opts.byweekday.length; i++) {
      var wday = opts.byweekday[i];
      if (isNumber(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// ../../../../../../node_modules/rrule/dist/esm/parsestring.js
function parseString(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x) {
    return x !== null;
  });
  return __assign(__assign({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr) {
    var _a = attr.split("="), key = _a[0], value2 = _a[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value2.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value2.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value2);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday(value2);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = untilStringToDate(value2);
        break;
      case "BYEASTER":
        options.byeaster = Number(value2);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value2) {
  if (value2.indexOf(",") !== -1) {
    var values = value2.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value2);
}
function parseIndividualNumber(value2) {
  if (/^[+-]?\d+$/.test(value2)) {
    return Number(value2);
  }
  return value2;
}
function parseWeekday(value2) {
  var days3 = value2.split(",");
  return days3.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n);
  });
}

// ../../../../../../node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = (
  /** @class */
  function() {
    function DateWithZone2(date, tzid) {
      if (isNaN(date.getTime())) {
        throw new RangeError("Invalid date passed to DateWithZone");
      }
      this.date = date;
      this.tzid = tzid;
    }
    Object.defineProperty(DateWithZone2.prototype, "isUTC", {
      get: function() {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: false,
      configurable: true
    });
    DateWithZone2.prototype.toString = function() {
      var datestr = timeToUntilString(this.date.getTime(), this.isUTC);
      if (!this.isUTC) {
        return ";TZID=".concat(this.tzid, ":").concat(datestr);
      }
      return ":".concat(datestr);
    };
    DateWithZone2.prototype.getTime = function() {
      return this.date.getTime();
    };
    DateWithZone2.prototype.rezonedDate = function() {
      if (this.isUTC) {
        return this.date;
      }
      return dateInTimeZone(this.date, this.tzid);
    };
    return DateWithZone2;
  }()
);

// ../../../../../../node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i = 0; i < keys.length; i++) {
    if (keys[i] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys[i]))
      continue;
    var key = keys[i].toUpperCase();
    var value2 = options[keys[i]];
    var outValue = "";
    if (!isPresent(value2) || isArray(value2) && !value2.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber(value2)) {
          outValue = new Weekday(value2).toString();
        } else {
          outValue = value2.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value2).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value2, options.tzid);
        break;
      case "UNTIL":
        outValue = timeToUntilString(value2, !options.tzid);
        break;
      default:
        if (isArray(value2)) {
          var strValues = [];
          for (var j = 0; j < value2.length; j++) {
            strValues[j] = String(value2[j]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value2);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a) {
    var key2 = _a[0], value3 = _a[1];
    return "".concat(key2, "=").concat(value3.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x) {
    return !!x;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// ../../../../../../node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i) {
      return date.getTime() === right[i].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = (
  /** @class */
  function() {
    function Cache3() {
      this.all = false;
      this.before = [];
      this.after = [];
      this.between = [];
    }
    Cache3.prototype._cacheAdd = function(what, value2, args) {
      if (value2) {
        value2 = value2 instanceof Date ? clone(value2) : cloneDates(value2);
      }
      if (what === "all") {
        this.all = value2;
      } else {
        args._value = value2;
        this[what].push(args);
      }
    };
    Cache3.prototype._cacheGet = function(what, args) {
      var cached = false;
      var argsKeys = args ? Object.keys(args) : [];
      var findCacheDiff = function(item2) {
        for (var i2 = 0; i2 < argsKeys.length; i2++) {
          var key = argsKeys[i2];
          if (!argsMatch(args[key], item2[key])) {
            return true;
          }
        }
        return false;
      };
      var cachedObject = this[what];
      if (what === "all") {
        cached = this.all;
      } else if (isArray(cachedObject)) {
        for (var i = 0; i < cachedObject.length; i++) {
          var item = cachedObject[i];
          if (argsKeys.length && findCacheDiff(item))
            continue;
          cached = item._value;
          break;
        }
      }
      if (!cached && this.all) {
        var iterResult = new iterresult_default(what, args);
        for (var i = 0; i < this.all.length; i++) {
          if (!iterResult.accept(this.all[i]))
            break;
        }
        cached = iterResult.getValue();
        this._cacheAdd(what, cached, args);
      }
      return isArray(cached) ? cloneDates(cached) : cached instanceof Date ? clone(cached) : cached;
    };
    return Cache3;
  }()
);

// ../../../../../../node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i = 0; i < 55; i++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// ../../../../../../node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = datetime(year, 1, 1);
  var yearlen = isLeapYear(year) ? 366 : 365;
  var nextyearlen = isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = toOrdinal(firstyday);
  var yearweekday = getWeekday(firstyday);
  var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j = 0; j < options.byweekno.length; j++) {
    var n = options.byweekno[j];
    if (n < 0) {
      n += numweeks + 1;
    }
    if (!(n > 0 && n <= numweeks)) {
      continue;
    }
    var i = void 0;
    if (n > 1) {
      i = no1wkst + (n - 1) * 7;
      if (no1wkst !== firstwkst) {
        i -= 7 - firstwkst;
      }
    } else {
      i = no1wkst;
    }
    for (var k = 0; k < 7; k++) {
      result.wnomask[i] = 1;
      i++;
      if (result.wdaymask[i] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i -= 7 - firstwkst;
    if (i < yearlen) {
      for (var j = 0; j < 7; j++) {
        result.wnomask[i] = 1;
        i += 1;
        if (result.wdaymask[i] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = getWeekday(datetime(year - 1, 1, 1));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i = 0; i < no1wkst; i++)
        result.wnomask[i] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = isLeapYear(year) ? 366 : 365;
  var firstyday = datetime(year, 1, 1);
  var wday = getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// ../../../../../../node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j = 0; j < options.bymonth.length; j++) {
        month = options.bymonth[j];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j = 0; j < ranges.length; j++) {
    var rang = ranges[j];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k = 0; k < options.bynweekday.length; k++) {
      var i = void 0;
      var _a = options.bynweekday[k], wday = _a[0], n = _a[1];
      if (n < 0) {
        i = last + (n + 1) * 7;
        i -= pymod(wdaymask[i] - wday, 7);
      } else {
        i = first + (n - 1) * 7;
        i += pymod(7 - wdaymask[i] + wday, 7);
      }
      if (first <= i && i <= last)
        result.nwdaymask[i] = 1;
    }
  }
  return result;
}

// ../../../../../../node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var a = y % 19;
  var b = Math.floor(y / 100);
  var c = y % 100;
  var d = Math.floor(b / 4);
  var e = b % 4;
  var f = Math.floor((b + 8) / 25);
  var g = Math.floor((b - f + 1) / 3);
  var h = Math.floor(19 * a + b - d - g + 15) % 30;
  var i = Math.floor(c / 4);
  var k = c % 4;
  var l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7;
  var m = Math.floor((a + 11 * h + 22 * l) / 451);
  var month = Math.floor((h + l - 7 * m + 114) / 31);
  var day = (h + l - 7 * m + 114) % 31 + 1;
  var date = Date.UTC(y, month - 1, day + offset);
  var yearStart = Date.UTC(y, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// ../../../../../../node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = (
  /** @class */
  function() {
    function Iterinfo2(options) {
      this.options = options;
    }
    Iterinfo2.prototype.rebuild = function(year, month) {
      var options = this.options;
      if (year !== this.lastyear) {
        this.yearinfo = rebuildYear(year, options);
      }
      if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
        var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
        this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
      }
      if (isPresent(options.byeaster)) {
        this.eastermask = easter(year, options.byeaster);
      }
    };
    Object.defineProperty(Iterinfo2.prototype, "lastyear", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearlen", {
      get: function() {
        return this.yearinfo.yearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
      get: function() {
        return this.yearinfo.yearordinal;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mrange", {
      get: function() {
        return this.yearinfo.mrange;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
      get: function() {
        return this.yearinfo.wdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mmask", {
      get: function() {
        return this.yearinfo.mmask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wnomask", {
      get: function() {
        return this.yearinfo.wnomask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
      get: function() {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
      get: function() {
        return this.yearinfo.nextyearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
      get: function() {
        return this.yearinfo.mdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
      get: function() {
        return this.yearinfo.nmdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Iterinfo2.prototype.ydayset = function() {
      return [range(this.yearlen), 0, this.yearlen];
    };
    Iterinfo2.prototype.mdayset = function(_, month) {
      var start = this.mrange[month - 1];
      var end = this.mrange[month];
      var set = repeat(null, this.yearlen);
      for (var i = start; i < end; i++)
        set[i] = i;
      return [set, start, end];
    };
    Iterinfo2.prototype.wdayset = function(year, month, day) {
      var set = repeat(null, this.yearlen + 7);
      var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      var start = i;
      for (var j = 0; j < 7; j++) {
        set[i] = i;
        ++i;
        if (this.wdaymask[i] === this.options.wkst)
          break;
      }
      return [set, start, i];
    };
    Iterinfo2.prototype.ddayset = function(year, month, day) {
      var set = repeat(null, this.yearlen);
      var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      set[i] = i;
      return [set, i, i + 1];
    };
    Iterinfo2.prototype.htimeset = function(hour, _, second, millisecond) {
      var _this = this;
      var set = [];
      this.options.byminute.forEach(function(minute) {
        set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.mtimeset = function(hour, minute, _, millisecond) {
      var set = this.options.bysecond.map(function(second) {
        return new Time(hour, minute, second, millisecond);
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
      return [new Time(hour, minute, second, millisecond)];
    };
    Iterinfo2.prototype.getdayset = function(freq) {
      switch (freq) {
        case Frequency.YEARLY:
          return this.ydayset.bind(this);
        case Frequency.MONTHLY:
          return this.mdayset.bind(this);
        case Frequency.WEEKLY:
          return this.wdayset.bind(this);
        case Frequency.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    };
    Iterinfo2.prototype.gettimeset = function(freq) {
      switch (freq) {
        case Frequency.HOURLY:
          return this.htimeset.bind(this);
        case Frequency.MINUTELY:
          return this.mtimeset.bind(this);
        case Frequency.SECONDLY:
          return this.stimeset.bind(this);
      }
    };
    return Iterinfo2;
  }()
);
var iterinfo_default = Iterinfo;

// ../../../../../../node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j = 0; j < bysetpos.length; j++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k = start; k < end; k++) {
      var val = dayset[k];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i = void 0;
    if (daypos < 0) {
      i = tmp.slice(daypos)[0];
    } else {
      i = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = fromOrdinal(ii.yearordinal + i);
    var res = combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  sort(poslist);
  return poslist;
}

// ../../../../../../node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j = 0; j < poslist.length; j++) {
        var res = poslist[j];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j = start; j < end; j++) {
        var currentDay = dayset[j];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = fromOrdinal(ii.yearordinal + currentDay);
        for (var k = 0; k < timeset.length; k++) {
          var time = timeset[k];
          var res = combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// ../../../../../../node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = (
  /** @class */
  function() {
    function RRule2(options, noCache) {
      if (options === void 0) {
        options = {};
      }
      if (noCache === void 0) {
        noCache = false;
      }
      this._cache = noCache ? null : new Cache();
      this.origOptions = initializeOptions(options);
      var parsedOptions = parseOptions(options).parsedOptions;
      this.options = parsedOptions;
    }
    RRule2.parseText = function(text, language) {
      return parseText(text, language);
    };
    RRule2.fromText = function(text, language) {
      return fromText(text, language);
    };
    RRule2.fromString = function(str) {
      return new RRule2(RRule2.parseString(str) || void 0);
    };
    RRule2.prototype._iter = function(iterResult) {
      return iter(iterResult, this.options);
    };
    RRule2.prototype._cacheGet = function(what, args) {
      if (!this._cache)
        return false;
      return this._cache._cacheGet(what, args);
    };
    RRule2.prototype._cacheAdd = function(what, value2, args) {
      if (!this._cache)
        return;
      return this._cache._cacheAdd(what, value2, args);
    };
    RRule2.prototype.all = function(iterator) {
      if (iterator) {
        return this._iter(new callbackiterresult_default("all", {}, iterator));
      }
      var result = this._cacheGet("all");
      if (result === false) {
        result = this._iter(new iterresult_default("all", {}));
        this._cacheAdd("all", result);
      }
      return result;
    };
    RRule2.prototype.between = function(after, before, inc, iterator) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(after) || !isValidDate2(before)) {
        throw new Error("Invalid date passed in to RRule.between");
      }
      var args = {
        before,
        after,
        inc
      };
      if (iterator) {
        return this._iter(new callbackiterresult_default("between", args, iterator));
      }
      var result = this._cacheGet("between", args);
      if (result === false) {
        result = this._iter(new iterresult_default("between", args));
        this._cacheAdd("between", result, args);
      }
      return result;
    };
    RRule2.prototype.before = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.before");
      }
      var args = { dt, inc };
      var result = this._cacheGet("before", args);
      if (result === false) {
        result = this._iter(new iterresult_default("before", args));
        this._cacheAdd("before", result, args);
      }
      return result;
    };
    RRule2.prototype.after = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.after");
      }
      var args = { dt, inc };
      var result = this._cacheGet("after", args);
      if (result === false) {
        result = this._iter(new iterresult_default("after", args));
        this._cacheAdd("after", result, args);
      }
      return result;
    };
    RRule2.prototype.count = function() {
      return this.all().length;
    };
    RRule2.prototype.toString = function() {
      return optionsToString(this.origOptions);
    };
    RRule2.prototype.toText = function(gettext, language, dateFormatter) {
      return toText(this, gettext, language, dateFormatter);
    };
    RRule2.prototype.isFullyConvertibleToText = function() {
      return isFullyConvertible(this);
    };
    RRule2.prototype.clone = function() {
      return new RRule2(this.origOptions);
    };
    RRule2.FREQUENCIES = [
      "YEARLY",
      "MONTHLY",
      "WEEKLY",
      "DAILY",
      "HOURLY",
      "MINUTELY",
      "SECONDLY"
    ];
    RRule2.YEARLY = Frequency.YEARLY;
    RRule2.MONTHLY = Frequency.MONTHLY;
    RRule2.WEEKLY = Frequency.WEEKLY;
    RRule2.DAILY = Frequency.DAILY;
    RRule2.HOURLY = Frequency.HOURLY;
    RRule2.MINUTELY = Frequency.MINUTELY;
    RRule2.SECONDLY = Frequency.SECONDLY;
    RRule2.MO = Days.MO;
    RRule2.TU = Days.TU;
    RRule2.WE = Days.WE;
    RRule2.TH = Days.TH;
    RRule2.FR = Days.FR;
    RRule2.SA = Days.SA;
    RRule2.SU = Days.SU;
    RRule2.parseString = parseString;
    RRule2.optionsToString = optionsToString;
    return RRule2;
  }()
);

// ../../../../../../node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i = 0; i < _rdate.length; i++) {
    var zonedDate = new DateWithZone(_rdate[i], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// ../../../../../../node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s, options.unfold);
  lines.forEach(function(line) {
    var _a;
    if (!line)
      return;
    var _b = breakDownLine(line), name2 = _b.name, parms = _b.parms, value2 = _b.value;
    switch (name2.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString(line));
        break;
      case "RDATE":
        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value2, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString(value2));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value2, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name2);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s, options) {
  var _a = parseInput(s, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS2), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a = split(line, ":", 1), name2 = _a[0], value2 = _a[1];
  return {
    name: name2,
    value: value2
  };
}
function breakDownLine(line) {
  var _a = extractName(line), name2 = _a.name, value2 = _a.value;
  var parms = name2.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value: value2
  };
}
function splitIntoLines(s, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s = s && s.trim();
  if (!s)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s.split(/\s/);
  }
  var lines = s.split("\n");
  var i = 0;
  while (i < lines.length) {
    var line = lines[i] = lines[i].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i, 1);
    } else if (i > 0 && line[0] === " ") {
      lines[i - 1] += line.slice(1);
      lines.splice(i, 1);
    } else {
      i += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return untilStringToDate(datestr);
  });
}

// ../../../../../../node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i = 0; i < _this._rrule.length; i++) {
      var field_1 = _this._rrule[i].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = (
  /** @class */
  function(_super) {
    __extends(RRuleSet2, _super);
    function RRuleSet2(noCache) {
      if (noCache === void 0) {
        noCache = false;
      }
      var _this = _super.call(this, {}, noCache) || this;
      _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
      _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
      _this._rrule = [];
      _this._rdate = [];
      _this._exrule = [];
      _this._exdate = [];
      return _this;
    }
    RRuleSet2.prototype._iter = function(iterResult) {
      return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
    };
    RRuleSet2.prototype.rrule = function(rrule) {
      _addRule(rrule, this._rrule);
    };
    RRuleSet2.prototype.exrule = function(rrule) {
      _addRule(rrule, this._exrule);
    };
    RRuleSet2.prototype.rdate = function(date) {
      _addDate(date, this._rdate);
    };
    RRuleSet2.prototype.exdate = function(date) {
      _addDate(date, this._exdate);
    };
    RRuleSet2.prototype.rrules = function() {
      return this._rrule.map(function(e) {
        return rrulestr(e.toString());
      });
    };
    RRuleSet2.prototype.exrules = function() {
      return this._exrule.map(function(e) {
        return rrulestr(e.toString());
      });
    };
    RRuleSet2.prototype.rdates = function() {
      return this._rdate.map(function(e) {
        return new Date(e.getTime());
      });
    };
    RRuleSet2.prototype.exdates = function() {
      return this._exdate.map(function(e) {
        return new Date(e.getTime());
      });
    };
    RRuleSet2.prototype.valueOf = function() {
      var result = [];
      if (!this._rrule.length && this._dtstart) {
        result = result.concat(optionsToString({ dtstart: this._dtstart }));
      }
      this._rrule.forEach(function(rrule) {
        result = result.concat(rrule.toString().split("\n"));
      });
      this._exrule.forEach(function(exrule) {
        result = result.concat(exrule.toString().split("\n").map(function(line) {
          return line.replace(/^RRULE:/, "EXRULE:");
        }).filter(function(line) {
          return !/^DTSTART/.test(line);
        }));
      });
      if (this._rdate.length) {
        result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
      }
      if (this._exdate.length) {
        result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
      }
      return result;
    };
    RRuleSet2.prototype.toString = function() {
      return this.valueOf().join("\n");
    };
    RRuleSet2.prototype.clone = function() {
      var rrs = new RRuleSet2(!!this._cache);
      this._rrule.forEach(function(rule) {
        return rrs.rrule(rule.clone());
      });
      this._exrule.forEach(function(rule) {
        return rrs.exrule(rule.clone());
      });
      this._rdate.forEach(function(date) {
        return rrs.rdate(new Date(date.getTime()));
      });
      this._exdate.forEach(function(date) {
        return rrs.exdate(new Date(date.getTime()));
      });
      return rrs;
    };
    return RRuleSet2;
  }(RRule)
);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_recurrence.js
var toMs6 = date_default2.dateToMilliseconds;
var ruleNames = ["freq", "interval", "byday", "byweekno", "byyearday", "bymonth", "bymonthday", "count", "until", "byhour", "byminute", "bysecond", "bysetpos", "wkst"];
var freqNames = ["DAILY", "WEEKLY", "MONTHLY", "YEARLY", "SECONDLY", "MINUTELY", "HOURLY"];
var days = {
  SU: 0,
  MO: 1,
  TU: 2,
  WE: 3,
  TH: 4,
  FR: 5,
  SA: 6
};
var loggedWarnings = [];
var RRULE_BROKEN_TIMEZONES = ["Etc/GMT-13", "MIT", "Pacific/Apia", "Pacific/Enderbury", "Pacific/Tongatapu", "Etc/GMT-14", "Pacific/Kiritimati"];
var recurrence = null;
function getRecurrenceProcessor() {
  if (!recurrence) {
    recurrence = new RecurrenceProcessor();
  }
  return recurrence;
}
var RecurrenceProcessor = class {
  constructor() {
    this.rRule = null;
    this.rRuleSet = null;
    this.validator = new RecurrenceValidator();
  }
  generateDates(options) {
    const recurrenceRule = this.evalRecurrenceRule(options.rule);
    const {
      rule
    } = recurrenceRule;
    if (!recurrenceRule.isValid || !rule.freq) {
      return [];
    }
    const rruleIntervalParams = this._createRruleIntervalParams(options);
    this._initializeRRule(options, rruleIntervalParams.startIntervalDate, rule.until);
    return this.rRuleSet.between(rruleIntervalParams.minViewDate, rruleIntervalParams.maxViewDate, true).filter((date) => date.getTime() + rruleIntervalParams.appointmentDuration >= rruleIntervalParams.minViewTime).map((date) => this._convertRruleResult(rruleIntervalParams, options, date));
  }
  _createRruleIntervalParams(options) {
    const {
      start,
      min,
      max,
      appointmentTimezoneOffset
    } = options;
    const clientOffsets_startDate = m_utils_time_zone_default.getClientTimezoneOffset(start), clientOffsets_minViewDate = m_utils_time_zone_default.getClientTimezoneOffset(min), clientOffsets_maxViewDate = m_utils_time_zone_default.getClientTimezoneOffset(max);
    const duration = options.end ? options.end.getTime() - options.start.getTime() : 0;
    const startIntervalDate = m_utils_time_zone_default.setOffsetsToDate(options.start, [-clientOffsets_startDate, appointmentTimezoneOffset]);
    const minViewTime = options.min.getTime() - clientOffsets_minViewDate + appointmentTimezoneOffset;
    const minViewDate = new Date(minViewTime - duration);
    const maxViewDate = m_utils_time_zone_default.setOffsetsToDate(options.max, [-clientOffsets_maxViewDate, appointmentTimezoneOffset]);
    const startDateDSTDifferenceMs = m_utils_time_zone_default.getDiffBetweenClientTimezoneOffsets(options.start, startIntervalDate);
    const switchToSummerTime = startDateDSTDifferenceMs < 0;
    return {
      startIntervalDate,
      minViewTime,
      minViewDate,
      maxViewDate,
      startIntervalDateDSTShift: switchToSummerTime ? 0 : startDateDSTDifferenceMs,
      appointmentDuration: duration
    };
  }
  _convertRruleResult(rruleIntervalParams, options, rruleDate) {
    const convertedBackDate = m_utils_time_zone_default.setOffsetsToDate(rruleDate, [...this._getLocalMachineOffset(rruleDate), -options.appointmentTimezoneOffset, rruleIntervalParams.startIntervalDateDSTShift]);
    const convertedDateDSTShift = m_utils_time_zone_default.getDiffBetweenClientTimezoneOffsets(convertedBackDate, rruleDate);
    const switchToSummerTime = convertedDateDSTShift < 0;
    const resultDate = m_utils_time_zone_default.setOffsetsToDate(convertedBackDate, [convertedDateDSTShift]);
    const resultDateDSTShift = m_utils_time_zone_default.getDiffBetweenClientTimezoneOffsets(resultDate, convertedBackDate);
    if (resultDateDSTShift && switchToSummerTime) {
      return new Date(resultDate.getTime() + resultDateDSTShift);
    }
    return resultDate;
  }
  _getLocalMachineOffset(rruleDate) {
    const machineTimezoneOffset = m_utils_time_zone_default.getClientTimezoneOffset(rruleDate);
    const machineTimezoneName = date_default2.getMachineTimezoneName();
    const result = [machineTimezoneOffset];
    const isTimezoneOffsetInBrokenRange = machineTimezoneOffset / 36e5 <= -13;
    const isTimezoneNameInBrokenNames = !machineTimezoneName || RRULE_BROKEN_TIMEZONES.some((timezone) => machineTimezoneName.includes(timezone));
    if (isTimezoneOffsetInBrokenRange && isTimezoneNameInBrokenNames) {
      result.push(-864e5);
    }
    return result;
  }
  hasRecurrence(options) {
    return !!this.generateDates(options).length;
  }
  evalRecurrenceRule(rule) {
    const result = {
      rule: {},
      isValid: false
    };
    if (rule) {
      result.rule = this._parseRecurrenceRule(rule);
      result.isValid = this.validator.validateRRule(result.rule, rule);
    }
    return result;
  }
  isValidRecurrenceRule(rule) {
    return this.evalRecurrenceRule(rule).isValid;
  }
  daysFromByDayRule(rule) {
    let result = [];
    if (rule.byday) {
      if (Array.isArray(rule.byday)) {
        result = rule.byday;
      } else {
        result = rule.byday.split(",");
      }
    }
    return result.map((item) => {
      const match = item.match(/[A-Za-z]+/);
      return !!match && match[0];
    }).filter((item) => !!item);
  }
  getAsciiStringByDate(date) {
    const currentOffset = date.getTimezoneOffset() * toMs6("minute");
    const offsetDate = new Date(date.getTime() + currentOffset);
    return `${offsetDate.getFullYear() + `0${offsetDate.getMonth() + 1}`.slice(-2) + `0${offsetDate.getDate()}`.slice(-2)}T${`0${offsetDate.getHours()}`.slice(-2)}${`0${offsetDate.getMinutes()}`.slice(-2)}${`0${offsetDate.getSeconds()}`.slice(-2)}Z`;
  }
  getRecurrenceString(object) {
    if (!object || !object.freq) {
      return;
    }
    let result = "";
    for (const field in object) {
      let value2 = object[field];
      if ("interval" === field && value2 < 2) {
        continue;
      }
      if ("until" === field) {
        value2 = this.getAsciiStringByDate(value2);
      }
      result += `${field}=${value2};`;
    }
    result = result.substring(0, result.length - 1);
    return result.toUpperCase();
  }
  _parseExceptionToRawArray(value2) {
    return value2.match(/(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2}))?(Z)?/);
  }
  getDateByAsciiString(exceptionText) {
    if ("string" !== typeof exceptionText) {
      return exceptionText;
    }
    const result = this._parseExceptionToRawArray(exceptionText);
    if (!result) {
      return null;
    }
    const [year, month, date, hours, minutes, seconds, isUtc] = this._createDateTuple(result);
    if (isUtc) {
      return new Date(Date.UTC(year, month, date, hours, minutes, seconds));
    }
    return new Date(year, month, date, hours, minutes, seconds);
  }
  _dispose() {
    if (this.rRuleSet) {
      delete this.rRuleSet;
      this.rRuleSet = null;
    }
    if (this.rRule) {
      delete this.rRule;
      this.rRule = null;
    }
  }
  _getTimeZoneOffset() {
    return (/* @__PURE__ */ new Date()).getTimezoneOffset();
  }
  _initializeRRule(options, startDateUtc, until) {
    const ruleOptions = RRule.parseString(options.rule);
    const {
      firstDayOfWeek
    } = options;
    ruleOptions.dtstart = startDateUtc;
    if (!ruleOptions.wkst && firstDayOfWeek) {
      const weekDayNumbers = [6, 0, 1, 2, 3, 4, 5];
      ruleOptions.wkst = weekDayNumbers[firstDayOfWeek];
    }
    if (until) {
      ruleOptions.until = m_utils_time_zone_default.setOffsetsToDate(until, [-m_utils_time_zone_default.getClientTimezoneOffset(until), options.appointmentTimezoneOffset]);
    }
    this._createRRule(ruleOptions);
    if (options.exception) {
      const exceptionStrings = options.exception;
      const exceptionDates = exceptionStrings.split(",").map((rule) => this.getDateByAsciiString(rule));
      exceptionDates.forEach((date) => {
        if (options.getPostProcessedException) {
          date = options.getPostProcessedException(date);
        }
        const utcDate = m_utils_time_zone_default.setOffsetsToDate(date, [-m_utils_time_zone_default.getClientTimezoneOffset(date), options.appointmentTimezoneOffset]);
        this.rRuleSet.exdate(utcDate);
      });
    }
  }
  _createRRule(ruleOptions) {
    this._dispose();
    this.rRuleSet = new RRuleSet();
    this.rRule = new RRule(ruleOptions);
    this.rRuleSet.rrule(this.rRule);
  }
  _parseRecurrenceRule(recurrence2) {
    const ruleObject = {};
    const ruleParts = recurrence2.split(";");
    for (let i = 0, len = ruleParts.length; i < len; i++) {
      const rule = ruleParts[i].split("=");
      const ruleName = rule[0].toLowerCase();
      const ruleValue = rule[1];
      ruleObject[ruleName] = ruleValue;
    }
    const count = parseInt(ruleObject.count);
    if (!isNaN(count)) {
      ruleObject.count = count;
    }
    if (ruleObject.interval) {
      const interval = parseInt(ruleObject.interval);
      if (!isNaN(interval)) {
        ruleObject.interval = interval;
      }
    } else {
      ruleObject.interval = 1;
    }
    if (ruleObject.freq && ruleObject.until) {
      ruleObject.until = this.getDateByAsciiString(ruleObject.until);
    }
    return ruleObject;
  }
  _createDateTuple(parseResult) {
    const isUtc = void 0 !== parseResult[8];
    parseResult.shift();
    if (void 0 === parseResult[3]) {
      parseResult.splice(3);
    } else {
      parseResult.splice(3, 1);
      parseResult.splice(6);
    }
    parseResult[1]--;
    parseResult.unshift(null);
    return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc];
  }
};
var RecurrenceValidator = class {
  validateRRule(rule, recurrence2) {
    if (this._brokenRuleNameExists(rule) || !freqNames.includes(rule.freq) || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {
      this._logBrokenRule(recurrence2);
      return false;
    }
    return true;
  }
  _wrongUntilRule(rule) {
    let wrongUntil = false;
    const {
      until
    } = rule;
    if (void 0 !== until && !(until instanceof Date)) {
      wrongUntil = true;
    }
    return wrongUntil;
  }
  _wrongCountRule(rule) {
    let wrongCount = false;
    const {
      count
    } = rule;
    if (count && "string" === typeof count) {
      wrongCount = true;
    }
    return wrongCount;
  }
  _wrongByMonthDayRule(rule) {
    let wrongByMonthDay = false;
    const byMonthDay = rule.bymonthday;
    if (byMonthDay && isNaN(parseInt(byMonthDay))) {
      wrongByMonthDay = true;
    }
    return wrongByMonthDay;
  }
  _wrongByMonth(rule) {
    let wrongByMonth = false;
    const byMonth = rule.bymonth;
    if (byMonth && isNaN(parseInt(byMonth))) {
      wrongByMonth = true;
    }
    return wrongByMonth;
  }
  _wrongIntervalRule(rule) {
    let wrongInterval = false;
    const {
      interval
    } = rule;
    if (interval && "string" === typeof interval) {
      wrongInterval = true;
    }
    return wrongInterval;
  }
  _wrongDayOfWeek(rule) {
    const byDay = rule.byday;
    const daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);
    let brokenDaysExist = false;
    if ("" === byDay) {
      brokenDaysExist = true;
    }
    each(daysByRule, (_, day) => {
      if (!Object.prototype.hasOwnProperty.call(days, day)) {
        brokenDaysExist = true;
        return false;
      }
      return;
    });
    return brokenDaysExist;
  }
  _brokenRuleNameExists(rule) {
    let brokenRuleExists = false;
    each(rule, (ruleName) => {
      if (!ruleNames.includes(ruleName)) {
        brokenRuleExists = true;
        return false;
      }
      return;
    });
    return brokenRuleExists;
  }
  _logBrokenRule(recurrence2) {
    if (!loggedWarnings.includes(recurrence2)) {
      errors_default.log("W0006", recurrence2);
      loggedWarnings.push(recurrence2);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_appointment_adapter.js
var PROPERTY_NAMES = {
  startDate: "startDate",
  endDate: "endDate",
  allDay: "allDay",
  text: "text",
  description: "description",
  startDateTimeZone: "startDateTimeZone",
  endDateTimeZone: "endDateTimeZone",
  recurrenceRule: "recurrenceRule",
  recurrenceException: "recurrenceException",
  disabled: "disabled"
};
var AppointmentAdapter = class _AppointmentAdapter {
  constructor(rawAppointment, dataAccessors, timeZoneCalculator, options) {
    this.rawAppointment = rawAppointment;
    this.dataAccessors = dataAccessors;
    this.timeZoneCalculator = timeZoneCalculator;
    this.options = options;
  }
  get duration() {
    return this.endDate ? this.endDate - this.startDate : 0;
  }
  get startDate() {
    const result = this.getField(PROPERTY_NAMES.startDate);
    return void 0 === result ? result : new Date(result);
  }
  set startDate(value2) {
    this.setField(PROPERTY_NAMES.startDate, value2);
  }
  get endDate() {
    const result = this.getField(PROPERTY_NAMES.endDate);
    return void 0 === result ? result : new Date(result);
  }
  set endDate(value2) {
    this.setField(PROPERTY_NAMES.endDate, value2);
  }
  get allDay() {
    return this.getField(PROPERTY_NAMES.allDay);
  }
  set allDay(value2) {
    this.setField(PROPERTY_NAMES.allDay, value2);
  }
  get text() {
    return this.getField(PROPERTY_NAMES.text);
  }
  set text(value2) {
    this.setField(PROPERTY_NAMES.text, value2);
  }
  get description() {
    return this.getField(PROPERTY_NAMES.description);
  }
  set description(value2) {
    this.setField(PROPERTY_NAMES.description, value2);
  }
  get startDateTimeZone() {
    return this.getField(PROPERTY_NAMES.startDateTimeZone);
  }
  get endDateTimeZone() {
    return this.getField(PROPERTY_NAMES.endDateTimeZone);
  }
  get recurrenceRule() {
    return this.getField(PROPERTY_NAMES.recurrenceRule);
  }
  set recurrenceRule(value2) {
    this.setField(PROPERTY_NAMES.recurrenceRule, value2);
  }
  get recurrenceException() {
    return this.getField(PROPERTY_NAMES.recurrenceException);
  }
  set recurrenceException(value2) {
    this.setField(PROPERTY_NAMES.recurrenceException, value2);
  }
  get disabled() {
    return !!this.getField(PROPERTY_NAMES.disabled);
  }
  get isRecurrent() {
    return getRecurrenceProcessor().isValidRecurrenceRule(this.recurrenceRule);
  }
  getField(property) {
    return ExpressionUtils.getField(this.dataAccessors, property, this.rawAppointment);
  }
  setField(property, value2) {
    return ExpressionUtils.setField(this.dataAccessors, property, this.rawAppointment, value2);
  }
  calculateStartDate(pathTimeZoneConversion) {
    if (!this.startDate || isNaN(this.startDate.getTime())) {
      throw ui_errors_default.Error("E1032", this.text);
    }
    return this.calculateDate(this.startDate, this.startDateTimeZone, pathTimeZoneConversion);
  }
  calculateEndDate(pathTimeZoneConversion) {
    return this.calculateDate(this.endDate, this.endDateTimeZone, pathTimeZoneConversion);
  }
  calculateDate(date, appointmentTimeZone, pathTimeZoneConversion) {
    if (!date) {
      return;
    }
    return this.timeZoneCalculator.createDate(date, {
      appointmentTimeZone,
      path: pathTimeZoneConversion
    });
  }
  clone() {
    let options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    const result = new _AppointmentAdapter(deepExtendArraySafe({}, this.rawAppointment), this.dataAccessors, this.timeZoneCalculator, options);
    if (null !== options && void 0 !== options && options.pathTimeZone) {
      result.startDate = result.calculateStartDate(options.pathTimeZone);
      result.endDate = result.calculateEndDate(options.pathTimeZone);
    }
    return result;
  }
  source() {
    let serializeDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    if (serializeDate) {
      const clonedAdapter = this.clone();
      clonedAdapter.startDate = this.startDate;
      clonedAdapter.endDate = this.endDate;
      return clonedAdapter.source();
    }
    return extend({}, this.rawAppointment);
  }
};
var createAppointmentAdapter = (rawAppointment, dataAccessors, timeZoneCalculator, options) => new AppointmentAdapter(rawAppointment, dataAccessors, timeZoneCalculator, options);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/data.js
var getPreparedDataItems = (dataItems, dataAccessors, cellDurationInMinutes, timeZoneCalculator) => {
  const result = [];
  null === dataItems || void 0 === dataItems || dataItems.forEach((rawAppointment) => {
    var _recurrenceRule$match;
    const startDate = new Date(dataAccessors.getter.startDate(rawAppointment));
    const endDate = new Date(dataAccessors.getter.endDate(rawAppointment));
    replaceWrongEndDate(rawAppointment, startDate, endDate, cellDurationInMinutes, dataAccessors);
    const adapter = createAppointmentAdapter(rawAppointment, dataAccessors, timeZoneCalculator);
    const comparableStartDate = adapter.startDate && adapter.calculateStartDate("toGrid");
    const comparableEndDate = adapter.endDate && adapter.calculateEndDate("toGrid");
    const regex = new RegExp("freq", "gi");
    const recurrenceRule = adapter.recurrenceRule;
    const hasRecurrenceRule = !!(null !== recurrenceRule && void 0 !== recurrenceRule && null !== (_recurrenceRule$match = recurrenceRule.match(regex)) && void 0 !== _recurrenceRule$match && _recurrenceRule$match.length);
    const visible = isDefined(rawAppointment.visible) ? !!rawAppointment.visible : true;
    if (comparableStartDate && comparableEndDate) {
      result.push({
        allDay: !!adapter.allDay,
        startDate: comparableStartDate,
        startDateTimeZone: rawAppointment.startDateTimeZone,
        endDate: comparableEndDate,
        endDateTimeZone: rawAppointment.endDateTimeZone,
        recurrenceRule: adapter.recurrenceRule,
        recurrenceException: adapter.recurrenceException,
        hasRecurrenceRule,
        visible,
        rawAppointment
      });
    }
  });
  return result;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/exclude_from_recurrence.js
var FULL_DATE_FORMAT2 = "yyyyMMddTHHmmss";
var UTC_FULL_DATE_FORMAT = `${FULL_DATE_FORMAT2}Z`;
var getSerializedDate = (date, startDate, isAllDay) => {
  if (isAllDay) {
    date.setHours(startDate.getHours(), startDate.getMinutes(), startDate.getSeconds(), startDate.getMilliseconds());
  }
  return date_serialization_default.serializeDate(date, UTC_FULL_DATE_FORMAT);
};
var createRecurrenceException = (appointmentAdapter, exceptionDate) => {
  const result = [];
  if (appointmentAdapter.recurrenceException) {
    result.push(appointmentAdapter.recurrenceException);
  }
  result.push(getSerializedDate(exceptionDate, appointmentAdapter.startDate, appointmentAdapter.allDay));
  return result.join();
};
var excludeFromRecurrence = (appointment, exceptionDate, dataAccessors, timeZoneCalculator) => {
  const appointmentAdapter = createAppointmentAdapter(_extends({}, appointment), dataAccessors, timeZoneCalculator);
  appointmentAdapter.recurrenceException = createRecurrenceException(appointmentAdapter, exceptionDate);
  return appointmentAdapter;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/format_weekday.js
var formatWeekday = (date) => date_default.getDayNames("abbreviated")[date.getDay()];
var formatWeekdayAndDay = (date) => `${formatWeekday(date)} ${date_default.format(date, "day")}`;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/index.js
var agendaUtils = {
  calculateStartViewDate
};
var dayUtils = {
  calculateStartViewDate: calculateStartViewDate2
};
var weekUtils = {
  getIntervalDuration,
  getTimePanelCellText,
  calculateStartViewDate: calculateStartViewDate5,
  calculateViewStartDate: calculateViewStartDate2
};
var workWeekUtils = {
  calculateStartViewDate: calculateStartViewDate6
};
var monthUtils = {
  getViewStartByOptions: getViewStartByOptions2,
  getCellText,
  calculateCellIndex: calculateCellIndex2,
  calculateStartViewDate: calculateStartViewDate3
};
var timelineWeekUtils = {
  getDateForHeaderText
};
var timelineMonthUtils = {
  calculateStartViewDate: calculateStartViewDate4
};
var viewsUtils = {
  getCurrentView
};
var renderUtils = {
  addToStyles,
  addWidthToStyle,
  addHeightToStyle,
  getGroupCellClasses,
  combineClasses,
  getCellSizeHorizontalClass,
  getCellSizeVerticalClass
};
var themeUtils = {
  getThemeType
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/editor.js
var TypedEditor = editor_default;
var editor_default2 = TypedEditor;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/radio_group/m_radio_collection.js
var RadioCollection = class extends edit_default {
  _focusTarget() {
    return renderer_default(this.element()).parent();
  }
  _nullValueSelectionSupported() {
    return true;
  }
  _getDefaultOptions() {
    const defaultOptions = super._getDefaultOptions();
    return extend(defaultOptions, ui_data_expression_default._dataExpressionDefaultOptions(), {
      _itemAttributes: {
        role: "radio"
      }
    });
  }
  _initMarkup() {
    super._initMarkup();
    deferRender(() => {
      this._itemElements().addClass("dx-radiobutton");
    });
  }
  _keyboardEventBindingTarget() {
    return this._focusTarget();
  }
  _postprocessRenderItem(args) {
    const {
      itemData: {
        html
      },
      itemElement
    } = args;
    if (!html) {
      const $radio = renderer_default("<div>").addClass("dx-radiobutton-icon");
      renderer_default("<div>").addClass("dx-radiobutton-icon-dot").appendTo($radio);
      const $radioContainer = renderer_default("<div>").append($radio).addClass("dx-radio-value-container");
      renderer_default(itemElement).prepend($radioContainer);
    }
    super._postprocessRenderItem(args);
  }
  _processSelectableItem($itemElement, isSelected) {
    super._processSelectableItem($itemElement, isSelected);
    $itemElement.toggleClass("dx-radiobutton-checked", isSelected).find(".dx-radiobutton-icon").first().toggleClass("dx-radiobutton-icon-checked", isSelected);
    this.setAria("checked", isSelected, $itemElement);
  }
  _refreshContent() {
    this._prepareContent();
    this._renderContent();
  }
  _supportedKeys() {
    const parent = super._supportedKeys();
    return extend({}, parent, {
      enter(e) {
        e.preventDefault();
        return parent.enter.apply(this, arguments);
      },
      space(e) {
        e.preventDefault();
        return parent.space.apply(this, arguments);
      }
    });
  }
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  }
  _setAriaSelectionAttribute() {
  }
};
var m_radio_collection_default = RadioCollection;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/radio_group/m_radio_group.js
var RadioGroup = class extends editor_default2 {
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _defaultOptionsRules() {
    const defaultOptionsRules = super._defaultOptionsRules();
    return defaultOptionsRules.concat([{
      device: {
        tablet: true
      },
      options: {
        layout: "horizontal"
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  }
  _fireContentReadyAction(force) {
    force && super._fireContentReadyAction();
  }
  _focusTarget() {
    return this.$element();
  }
  _getAriaTarget() {
    return this.$element();
  }
  _getDefaultOptions() {
    const defaultOptions = super._getDefaultOptions();
    return extend(defaultOptions, extend(ui_data_expression_default._dataExpressionDefaultOptions(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      layout: "vertical"
    }));
  }
  _getItemValue(item) {
    return this._valueGetter ? this._valueGetter(item) : item.text;
  }
  _getSubmitElement() {
    return this._$submitElement;
  }
  _init() {
    super._init();
    this._activeStateUnit = ".dx-radiobutton";
    this._feedbackHideTimeout = 100;
    this._initDataExpressions();
  }
  _initMarkup() {
    renderer_default(this.element()).addClass("dx-radiogroup");
    this._renderSubmitElement();
    this.setAria("role", "radiogroup");
    this._renderRadios();
    this._renderLayout();
    super._initMarkup();
  }
  _itemClickHandler(_ref) {
    let {
      itemElement,
      event,
      itemData
    } = _ref;
    if (this.itemElements().is(itemElement)) {
      const newValue = this._getItemValue(itemData);
      if (newValue !== this.option("value")) {
        this._saveValueChangeEvent(event);
        this.option("value", newValue);
      }
    }
  }
  _getSelectedItemKeys() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.option("value");
    const isNullSelectable = "this" !== this.option("valueExpr");
    const shouldSelectValue = isNullSelectable && null === value2 || isDefined(value2);
    return shouldSelectValue ? [value2] : [];
  }
  _setSelection(currentValue) {
    const value2 = this._unwrappedValue(currentValue);
    this._setCollectionWidgetOption("selectedItemKeys", this._getSelectedItemKeys(value2));
  }
  _renderValidationState() {
    var _this$_validationMess;
    super._renderValidationState();
    null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess || _this$_validationMess.$content().attr("role", "alert");
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    this._dataExpressionOptionChanged(args);
    switch (name2) {
      case "dataSource":
        this._invalidate();
        break;
      case "focusStateEnabled":
      case "accessKey":
      case "tabIndex":
        this._setCollectionWidgetOption(name2, value2);
        break;
      case "disabled":
        super._optionChanged(args);
        this._setCollectionWidgetOption(name2, value2);
        break;
      case "valueExpr":
        this._setCollectionWidgetOption("keyExpr", this._getCollectionKeyExpr());
        break;
      case "value":
        this._setSelection(value2);
        this._setSubmitValue(value2);
        super._optionChanged(args);
        break;
      case "items":
        this._setSelection(this.option("value"));
        break;
      case "itemTemplate":
      case "displayExpr":
        break;
      case "layout":
        this._renderLayout();
        this._updateItemsSize();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _render() {
    super._render();
    this._updateItemsSize();
  }
  _renderLayout() {
    const layout = this.option("layout");
    const $element = renderer_default(this.element());
    $element.toggleClass("dx-radiogroup-vertical", "vertical" === layout);
    $element.toggleClass("dx-radiogroup-horizontal", "horizontal" === layout);
  }
  _renderRadios() {
    this._areRadiosCreated = Deferred();
    const $radios = renderer_default("<div>").appendTo(this.$element());
    const {
      displayExpr,
      accessKey,
      focusStateEnabled,
      itemTemplate,
      tabIndex
    } = this.option();
    this._createComponent($radios, m_radio_collection_default, {
      onInitialized: (_ref2) => {
        let {
          component
        } = _ref2;
        this._radios = component;
      },
      onContentReady: (e) => {
        this._fireContentReadyAction(true);
      },
      onItemClick: this._itemClickHandler.bind(this),
      displayExpr,
      accessKey,
      dataSource: this._dataSource,
      focusStateEnabled,
      itemTemplate,
      keyExpr: this._getCollectionKeyExpr(),
      noDataText: "",
      scrollingEnabled: false,
      selectByClick: false,
      selectionMode: "single",
      selectedItemKeys: this._getSelectedItemKeys(),
      tabIndex
    });
    this._areRadiosCreated.resolve();
  }
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    this._setSubmitValue();
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      value: true
    });
  }
  _setSubmitValue(value2) {
    value2 = value2 ?? this.option("value");
    const submitValue = "this" === this.option("valueExpr") ? this._displayGetter(value2) : value2;
    this._$submitElement.val(submitValue);
  }
  _setCollectionWidgetOption(name2, value2) {
    this._areRadiosCreated.done(this._setWidgetOption.bind(this, "_radios", arguments));
  }
  _updateItemsSize() {
    if ("horizontal" === this.option("layout")) {
      var _this$itemElements;
      null === (_this$itemElements = this.itemElements()) || void 0 === _this$itemElements || _this$itemElements.css("height", "auto");
    } else {
      var _this$itemElements2;
      const itemsCount = this.option("items").length;
      null === (_this$itemElements2 = this.itemElements()) || void 0 === _this$itemElements2 || _this$itemElements2.css("height", 100 / itemsCount + "%");
    }
  }
  focus() {
    var _this$_radios;
    null === (_this$_radios = this._radios) || void 0 === _this$_radios || _this$_radios.focus();
  }
  itemElements() {
    var _this$_radios2;
    return null === (_this$_radios2 = this._radios) || void 0 === _this$_radios2 ? void 0 : _this$_radios2._itemElements();
  }
};
RadioGroup.include(ui_data_expression_default);
component_registrator_default("dxRadioGroup", RadioGroup);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_button_group.js
var BUTTON_GROUP_ITEM_HAS_WIDTH = "dx-buttongroup-item-has-width";
var BUTTON_GROUP_STYLING_MODE_CLASS = {
  contained: "dx-buttongroup-mode-contained",
  outlined: "dx-buttongroup-mode-outlined",
  text: "dx-buttongroup-mode-text"
};
var ButtonCollection = ui_collection_widget_edit_default.inherit({
  _initTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data2, model) => {
        this._prepareItemStyles($container);
        const template = this.option("buttonTemplate");
        this._createComponent($container, button_default, extend({}, model, data2, this._getBasicButtonOptions(), {
          _templateData: this._hasCustomTemplate(template) ? model : {},
          template: model.template || template
        }));
      }, ["text", "type", "icon", "disabled", "visible", "hint"], this.option("integrationOptions.watchMethod"))
    });
  },
  _getBasicButtonOptions() {
    return {
      focusStateEnabled: false,
      onClick: null,
      hoverStateEnabled: this.option("hoverStateEnabled"),
      activeStateEnabled: this.option("activeStateEnabled"),
      stylingMode: this.option("stylingMode")
    };
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      itemTemplateProperty: null
    });
  },
  _hasCustomTemplate(template) {
    return isFunction(template) || this.option("integrationOptions.templates")[template];
  },
  _selectedItemClass: () => "dx-item-selected dx-state-selected",
  _prepareItemStyles($item) {
    const itemIndex = $item.data("dxItemIndex");
    0 === itemIndex && $item.addClass("dx-buttongroup-first-item");
    const items = this.option("items");
    items && itemIndex === items.length - 1 && $item.addClass("dx-buttongroup-last-item");
    $item.addClass("dx-shape-standard");
  },
  _renderItemContent(args) {
    args.container = renderer_default(args.container).parent();
    return this.callBase(args);
  },
  _setAriaSelectionAttribute($target, value2) {
    this.setAria("pressed", value2, $target);
  },
  _renderItemContentByNode(args, $node) {
    args.container = renderer_default(args.container.children().first());
    return this.callBase(args, $node);
  },
  _focusTarget() {
    return this.$element().parent();
  },
  _keyboardEventBindingTarget() {
    return this._focusTarget();
  },
  _refreshContent() {
    this._prepareContent();
    this._renderContent();
  },
  _itemClass: () => "dx-buttongroup-item",
  _itemSelectHandler(e) {
    if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
      return;
    }
    this.callBase(e);
  }
});
var ButtonGroup = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      focusStateEnabled: true,
      selectionMode: "single",
      selectedItems: [],
      selectedItemKeys: [],
      stylingMode: "contained",
      keyExpr: "text",
      items: [],
      buttonTemplate: "content",
      onSelectionChanged: null,
      onItemClick: null
    });
  },
  _init() {
    this.callBase();
    this._createItemClickAction();
  },
  _createItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  },
  _initMarkup() {
    this.setAria("role", "group");
    this.$element().addClass("dx-buttongroup");
    this._renderStylingMode();
    this._renderButtons();
    this._syncSelectionOptions();
    this.callBase();
  },
  _renderStylingMode() {
    const {
      stylingMode
    } = this.option();
    for (const key in BUTTON_GROUP_STYLING_MODE_CLASS) {
      this.$element().removeClass(BUTTON_GROUP_STYLING_MODE_CLASS[key]);
    }
    this.$element().addClass(BUTTON_GROUP_STYLING_MODE_CLASS[stylingMode] ?? BUTTON_GROUP_STYLING_MODE_CLASS.contained);
  },
  _fireSelectionChangeEvent(addedItems, removedItems) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems,
      removedItems
    });
  },
  _renderButtons() {
    const $buttons = renderer_default("<div>").addClass("dx-buttongroup-wrapper").appendTo(this.$element());
    const selectedItems = this.option("selectedItems");
    const options = {
      selectionMode: this.option("selectionMode"),
      items: this.option("items"),
      keyExpr: this.option("keyExpr"),
      buttonTemplate: this.option("buttonTemplate"),
      scrollingEnabled: false,
      selectedItemKeys: this.option("selectedItemKeys"),
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      activeStateEnabled: this.option("activeStateEnabled"),
      stylingMode: this.option("stylingMode"),
      accessKey: this.option("accessKey"),
      tabIndex: this.option("tabIndex"),
      noDataText: "",
      selectionRequired: false,
      onItemRendered: (e) => {
        const width = this.option("width");
        isDefined(width) && renderer_default(e.itemElement).addClass(BUTTON_GROUP_ITEM_HAS_WIDTH);
      },
      onSelectionChanged: (e) => {
        this._syncSelectionOptions();
        this._fireSelectionChangeEvent(e.addedItems, e.removedItems);
      },
      onItemClick: (e) => {
        this._itemClickAction(e);
      }
    };
    if (isDefined(selectedItems) && selectedItems.length) {
      options.selectedItems = selectedItems;
    }
    this._buttonsCollection = this._createComponent($buttons, ButtonCollection, options);
  },
  _syncSelectionOptions() {
    this._setOptionWithoutOptionChange("selectedItems", this._buttonsCollection.option("selectedItems"));
    this._setOptionWithoutOptionChange("selectedItemKeys", this._buttonsCollection.option("selectedItemKeys"));
  },
  _optionChanged(args) {
    switch (args.name) {
      case "stylingMode":
      case "selectionMode":
      case "keyExpr":
      case "buttonTemplate":
      case "items":
      case "activeStateEnabled":
      case "focusStateEnabled":
      case "hoverStateEnabled":
      case "tabIndex":
        this._invalidate();
        break;
      case "selectedItemKeys":
      case "selectedItems":
        this._buttonsCollection.option(args.name, args.value);
        break;
      case "onItemClick":
        this._createItemClickAction();
        break;
      case "onSelectionChanged":
        break;
      case "width":
        this.callBase(args);
        this._buttonsCollection.itemElements().toggleClass(BUTTON_GROUP_ITEM_HAS_WIDTH, !!args.value);
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxButtonGroup", ButtonGroup);
var m_button_group_default = ButtonGroup;

// ../../../../../../node_modules/devextreme/esm/ui/button_group.js
var button_group_default = m_button_group_default;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_recurrence_editor.js
var RECURRENCE_EDITOR = "dx-recurrence-editor";
var RECURRENCE_EDITOR_CONTAINER = "dx-recurrence-editor-container";
var REPEAT_END_EDITOR = "dx-recurrence-repeat-end";
var REPEAT_END_TYPE_EDITOR = "dx-recurrence-radiogroup-repeat-type";
var REPEAT_COUNT_EDITOR = "dx-recurrence-numberbox-repeat-count";
var REPEAT_UNTIL_DATE_EDITOR = "dx-recurrence-datebox-until-date";
var RECURRENCE_BUTTON_GROUP = "dx-recurrence-button-group";
var FREQUENCY_EDITOR = "dx-recurrence-selectbox-freq";
var INTERVAL_EDITOR = "dx-recurrence-numberbox-interval";
var REPEAT_ON_EDITOR = "dx-recurrence-repeat-on";
var DAY_OF_MONTH = "dx-recurrence-numberbox-day-of-month";
var MONTH_OF_YEAR = "dx-recurrence-selectbox-month-of-year";
var frequenciesMessages = [{
  recurrence: "dxScheduler-recurrenceHourly",
  value: "hourly"
}, {
  recurrence: "dxScheduler-recurrenceDaily",
  value: "daily"
}, {
  recurrence: "dxScheduler-recurrenceWeekly",
  value: "weekly"
}, {
  recurrence: "dxScheduler-recurrenceMonthly",
  value: "monthly"
}, {
  recurrence: "dxScheduler-recurrenceYearly",
  value: "yearly"
}];
var frequencies = frequenciesMessages.map((item) => ({
  text: () => message_default.format(item.recurrence),
  value: item.value
}));
var repeatEndTypes = [{
  type: "never"
}, {
  type: "until"
}, {
  type: "count"
}];
var days2 = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var getStylingModeFunc = () => isFluent(current()) ? "filled" : void 0;
var RecurrenceRule = class {
  constructor(rule) {
    this._recurrenceProcessor = getRecurrenceProcessor();
    this._recurrenceProcessor = getRecurrenceProcessor();
    this._recurrenceRule = this._recurrenceProcessor.evalRecurrenceRule(rule).rule;
  }
  makeRules(string) {
    this._recurrenceRule = this._recurrenceProcessor.evalRecurrenceRule(string).rule;
  }
  makeRule(field, value2) {
    if (!value2 || Array.isArray(value2) && !value2.length) {
      delete this._recurrenceRule[field];
      return;
    }
    if (isDefined(field)) {
      if ("until" === field) {
        delete this._recurrenceRule.count;
      }
      if ("count" === field) {
        delete this._recurrenceRule.until;
      }
      this._recurrenceRule[field] = value2;
    }
  }
  getRepeatEndRule() {
    const rules = this._recurrenceRule;
    if ("count" in rules) {
      return "count";
    }
    if ("until" in rules) {
      return "until";
    }
    return "never";
  }
  getRecurrenceString() {
    return this._recurrenceProcessor.getRecurrenceString(this._recurrenceRule);
  }
  getRules() {
    return this._recurrenceRule;
  }
  getDaysFromByDayRule() {
    return this._recurrenceProcessor.daysFromByDayRule(this._recurrenceRule);
  }
};
var RecurrenceEditor = class extends editor_default {
  _getDefaultOptions() {
    const defaultOptions = super._getDefaultOptions();
    return extend(defaultOptions, {
      value: null,
      startDate: /* @__PURE__ */ new Date(),
      firstDayOfWeek: void 0
    });
  }
  _getFirstDayOfWeek() {
    const firstDayOfWeek = this.option("firstDayOfWeek");
    return isDefined(firstDayOfWeek) ? firstDayOfWeek : date_default.firstDayOfWeekIndex();
  }
  _createComponent(element, name2) {
    let config = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    this._extendConfig(config, {
      readOnly: this.option("readOnly")
    });
    return super._createComponent(element, name2, config);
  }
  _init() {
    super._init();
    this._recurrenceRule = new RecurrenceRule(this.option("value"));
  }
  _render() {
    super._render();
    this.$element().addClass(RECURRENCE_EDITOR);
    this._$container = renderer_default("<div>").addClass(RECURRENCE_EDITOR_CONTAINER).appendTo(this.$element());
    this._prepareEditors();
    this._renderEditors(this._$container);
  }
  getEditorByField(fieldName) {
    let editor = this.getRecurrenceForm().getEditor(fieldName);
    if (!isDefined(editor)) {
      switch (fieldName) {
        case "byday":
          editor = this._weekEditor;
          break;
        case "count":
          editor = this._repeatCountEditor;
          break;
        case "until":
          editor = this._repeatUntilDate;
      }
    }
    return editor;
  }
  _prepareEditors() {
    const freq = (this._recurrenceRule.getRules().freq || frequenciesMessages[1].value).toLowerCase();
    this._editors = [this._createFreqEditor(freq), this._createIntervalEditor(freq), this._createRepeatOnLabel(freq), {
      itemType: "group",
      cssClass: REPEAT_ON_EDITOR,
      colCount: 2,
      colCountByScreen: {
        xs: 2
      },
      items: this._createRepeatOnEditor(freq)
    }, {
      itemType: "group",
      items: this._createRepeatEndEditor()
    }];
    return this._editors;
  }
  _createFreqEditor(freq) {
    return {
      dataField: "freq",
      name: "FREQ",
      editorType: "dxSelectBox",
      cssClass: FREQUENCY_EDITOR,
      editorOptions: {
        stylingMode: getStylingModeFunc(),
        items: frequencies,
        value: freq,
        field: "freq",
        valueExpr: "value",
        displayExpr: "text",
        layout: "horizontal",
        elementAttr: {
          class: FREQUENCY_EDITOR
        },
        onValueChanged: (args) => this._valueChangedHandler(args)
      },
      label: {
        text: message_default.format("dxScheduler-editorLabelRecurrence")
      }
    };
  }
  _createIntervalEditor(freq) {
    const interval = this._recurrenceRule.getRules().interval || 1;
    return {
      itemType: "group",
      colCount: 2,
      cssClass: `${INTERVAL_EDITOR}-wrapper`,
      colCountByScreen: {
        xs: 2
      },
      items: [{
        dataField: "interval",
        editorType: "dxNumberBox",
        editorOptions: {
          stylingMode: getStylingModeFunc(),
          format: "#",
          width: 70,
          min: 1,
          field: "interval",
          value: interval,
          showSpinButtons: true,
          useLargeSpinButtons: false,
          elementAttr: {
            class: INTERVAL_EDITOR
          },
          onValueChanged: (args) => this._valueChangedHandler(args)
        },
        label: {
          text: message_default.format("dxScheduler-recurrenceRepeatEvery")
        }
      }, {
        name: "intervalLabel",
        cssClass: `${INTERVAL_EDITOR}-label`,
        template: () => message_default.format(`dxScheduler-recurrenceRepeat${freq.charAt(0).toUpperCase()}${freq.substr(1).toLowerCase()}`)
      }]
    };
  }
  _createRepeatOnLabel(freq) {
    return {
      itemType: "group",
      cssClass: `${REPEAT_ON_EDITOR}-label`,
      items: [{
        name: "repeatOnLabel",
        colSpan: 2,
        template: () => message_default.format("dxScheduler-recurrenceRepeatOn"),
        visible: freq && "daily" !== freq && "hourly" !== freq
      }]
    };
  }
  _createRepeatOnEditor(freq) {
    return [this._createByDayEditor(freq), this._createByMonthEditor(freq), this._createByMonthDayEditor(freq)];
  }
  _createByDayEditor(freq) {
    return {
      dataField: "byday",
      colSpan: 2,
      template: (_, itemElement) => {
        const firstDayOfWeek = this._getFirstDayOfWeek();
        const byDay = this._daysOfWeekByRules();
        const localDaysNames = date_default.getDayNames("abbreviated");
        const dayNames = days2.slice(firstDayOfWeek).concat(days2.slice(0, firstDayOfWeek));
        const itemsButtonGroup = localDaysNames.slice(firstDayOfWeek).concat(localDaysNames.slice(0, firstDayOfWeek)).map((item, index) => ({
          text: item,
          key: dayNames[index]
        }));
        this._$repeatOnWeek = renderer_default("<div>").addClass(RECURRENCE_BUTTON_GROUP).appendTo(itemElement);
        this._weekEditor = this._createComponent(this._$repeatOnWeek, button_group_default, {
          items: itemsButtonGroup,
          field: "byday",
          selectionMode: "multiple",
          selectedItemKeys: byDay,
          keyExpr: "key",
          onSelectionChanged: (e) => {
            const selectedItemKeys = e.component.option("selectedItemKeys");
            const selectedKeys = null !== selectedItemKeys && void 0 !== selectedItemKeys && selectedItemKeys.length ? selectedItemKeys : this._getDefaultByDayValue();
            this._recurrenceRule.makeRule("byday", selectedKeys);
            this._changeEditorValue();
          }
        });
      },
      visible: "weekly" === freq,
      label: {
        visible: false
      }
    };
  }
  _createByMonthEditor(freq) {
    const monthsName = date_default.getMonthNames("wide");
    const months = [...Array(12)].map((_, i) => ({
      value: `${i + 1}`,
      text: monthsName[i]
    }));
    return {
      dataField: "bymonth",
      editorType: "dxSelectBox",
      editorOptions: {
        stylingMode: getStylingModeFunc(),
        field: "bymonth",
        items: months,
        value: this._monthOfYearByRules(),
        width: 120,
        displayExpr: "text",
        valueExpr: "value",
        elementAttr: {
          class: MONTH_OF_YEAR
        },
        onValueChanged: (args) => this._valueChangedHandler(args)
      },
      visible: "yearly" === freq,
      label: {
        visible: false
      }
    };
  }
  _createByMonthDayEditor(freq) {
    return {
      dataField: "bymonthday",
      editorType: "dxNumberBox",
      editorOptions: {
        stylingMode: getStylingModeFunc(),
        min: 1,
        max: 31,
        format: "#",
        width: 70,
        field: "bymonthday",
        showSpinButtons: true,
        useLargeSpinButtons: false,
        value: this._dayOfMonthByRules(),
        elementAttr: {
          class: DAY_OF_MONTH
        },
        onValueChanged: (args) => this._valueChangedHandler(args)
      },
      visible: "monthly" === freq || "yearly" === freq,
      label: {
        visible: false
      }
    };
  }
  _createRepeatEndEditor() {
    const repeatType = this._recurrenceRule.getRepeatEndRule();
    return [{
      dataField: "repeatEnd",
      editorType: "dxRadioGroup",
      editorOptions: {
        items: repeatEndTypes,
        value: repeatType,
        valueExpr: "type",
        field: "repeatEnd",
        itemTemplate: (itemData) => {
          if ("count" === itemData.type) {
            return this._renderRepeatCountEditor();
          }
          if ("until" === itemData.type) {
            return this._renderRepeatUntilEditor();
          }
          return this._renderDefaultRepeatEnd();
        },
        layout: "vertical",
        elementAttr: {
          class: REPEAT_END_TYPE_EDITOR
        },
        onValueChanged: (args) => this._repeatEndValueChangedHandler(args)
      },
      label: {
        text: message_default.format("dxScheduler-recurrenceEnd")
      }
    }];
  }
  _renderEditors($container) {
    this._recurrenceForm = this._createComponent($container, form_default, {
      items: this._editors,
      showValidationSummary: false,
      scrollingEnabled: true,
      showColonAfterLabel: false,
      labelLocation: "top"
    });
    this._disableRepeatEndParts();
  }
  _setAriaDescribedBy(editor, $label) {
    const labelId = `label-${new guid_default()}`;
    editor.setAria("describedby", labelId);
    editor.setAria("id", labelId, $label);
  }
  getRecurrenceForm() {
    return this._recurrenceForm;
  }
  changeValueByVisibility(value2) {
    if (value2) {
      if (!this.option("value")) {
        this._handleDefaults();
      }
    } else {
      this._recurrenceRule.makeRules("");
      this.option("value", "");
    }
  }
  _handleDefaults() {
    this._recurrenceRule.makeRule("freq", frequenciesMessages[1].value);
    this._changeEditorValue();
  }
  _changeEditorValue() {
    this.option("value", this._recurrenceRule.getRecurrenceString() || "");
  }
  _daysOfWeekByRules() {
    let daysByRule = this._recurrenceRule.getDaysFromByDayRule();
    if (!daysByRule.length) {
      daysByRule = this._getDefaultByDayValue();
    }
    return daysByRule;
  }
  _getDefaultByDayValue() {
    const startDate = this.option("startDate");
    const startDay = startDate.getDay();
    return [days2[startDay]];
  }
  _dayOfMonthByRules() {
    let dayByRule = this._recurrenceRule.getRules().bymonthday;
    if (!dayByRule) {
      dayByRule = this.option("startDate").getDate();
    }
    return dayByRule;
  }
  _monthOfYearByRules() {
    let monthByRule = this._recurrenceRule.getRules().bymonth;
    if (!monthByRule) {
      monthByRule = this.option("startDate").getMonth() + 1;
    }
    return String(monthByRule);
  }
  _renderDefaultRepeatEnd() {
    const $editorTemplate = renderer_default("<div>").addClass(REPEAT_END_EDITOR + "-wrapper");
    renderer_default("<div>").text(message_default.format("dxScheduler-recurrenceNever")).addClass(REPEAT_END_EDITOR + "-label").appendTo($editorTemplate);
    return $editorTemplate;
  }
  _repeatEndValueChangedHandler(args) {
    const {
      value: value2
    } = args;
    this._disableRepeatEndParts(value2);
    if ("until" === value2) {
      this._recurrenceRule.makeRule(value2, this._getUntilValue());
    }
    if ("count" === value2) {
      this._recurrenceRule.makeRule(value2, this._repeatCountEditor.option("value"));
    }
    if ("never" === value2) {
      this._recurrenceRule.makeRule("count", "");
      this._recurrenceRule.makeRule("until", "");
    }
    this._changeEditorValue();
  }
  _disableRepeatEndParts() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._recurrenceRule.getRepeatEndRule();
    if ("until" === value2) {
      this._repeatCountEditor.option("disabled", true);
      this._repeatUntilDate.option("disabled", false);
    }
    if ("count" === value2) {
      this._repeatCountEditor.option("disabled", false);
      this._repeatUntilDate.option("disabled", true);
    }
    if ("never" === value2) {
      this._repeatCountEditor.option("disabled", true);
      this._repeatUntilDate.option("disabled", true);
    }
  }
  _renderRepeatCountEditor() {
    const repeatCount = this._recurrenceRule.getRules().count || 1;
    const $editorWrapper = renderer_default("<div>").addClass(REPEAT_END_EDITOR + "-wrapper");
    renderer_default("<div>").text(message_default.format("dxScheduler-recurrenceAfter")).addClass(REPEAT_END_EDITOR + "-label").appendTo($editorWrapper);
    this._$repeatCountEditor = renderer_default("<div>").addClass(REPEAT_COUNT_EDITOR).appendTo($editorWrapper);
    renderer_default("<div>").text(message_default.format("dxScheduler-recurrenceRepeatCount")).addClass(REPEAT_END_EDITOR + "-label").appendTo($editorWrapper);
    this._repeatCountEditor = this._createComponent(this._$repeatCountEditor, number_box_default, {
      stylingMode: getStylingModeFunc(),
      field: "count",
      format: "#",
      width: 70,
      min: 1,
      showSpinButtons: true,
      useLargeSpinButtons: false,
      value: repeatCount,
      onValueChanged: this._repeatCountValueChangeHandler.bind(this)
    });
    return $editorWrapper;
  }
  _repeatCountValueChangeHandler(args) {
    if ("count" === this._recurrenceRule.getRepeatEndRule()) {
      const {
        value: value2
      } = args;
      this._recurrenceRule.makeRule("count", value2);
      this._changeEditorValue();
    }
  }
  _formatUntilDate(date) {
    if (this._recurrenceRule.getRules().until && date_default2.sameDate(this._recurrenceRule.getRules().until, date)) {
      return date;
    }
    return date_default2.setToDayEnd(date);
  }
  _renderRepeatUntilEditor() {
    const repeatUntil = this._getUntilValue();
    const $editorWrapper = renderer_default("<div>").addClass(REPEAT_END_EDITOR + "-wrapper");
    renderer_default("<div>").text(message_default.format("dxScheduler-recurrenceOn")).addClass(REPEAT_END_EDITOR + "-label").appendTo($editorWrapper);
    this._$repeatDateEditor = renderer_default("<div>").addClass(REPEAT_UNTIL_DATE_EDITOR).appendTo($editorWrapper);
    this._repeatUntilDate = this._createComponent(this._$repeatDateEditor, date_box_default, {
      stylingMode: getStylingModeFunc(),
      field: "until",
      value: repeatUntil,
      type: "date",
      onValueChanged: this._repeatUntilValueChangeHandler.bind(this),
      calendarOptions: {
        firstDayOfWeek: this._getFirstDayOfWeek()
      },
      useMaskBehavior: true
    });
    return $editorWrapper;
  }
  _repeatUntilValueChangeHandler(args) {
    if ("until" === this._recurrenceRule.getRepeatEndRule()) {
      const dateInTimeZone2 = this._formatUntilDate(new Date(args.value));
      const getStartDateTimeZone = this.option("getStartDateTimeZone");
      const appointmentTimeZone = getStartDateTimeZone();
      const path = appointmentTimeZone ? PathTimeZoneConversion.fromAppointmentToSource : PathTimeZoneConversion.fromGridToSource;
      const dateInLocaleTimeZone = this.option("timeZoneCalculator").createDate(dateInTimeZone2, {
        path,
        appointmentTimeZone
      });
      this._recurrenceRule.makeRule("until", dateInLocaleTimeZone);
      this._changeEditorValue();
    }
  }
  _valueChangedHandler(args) {
    const {
      value: value2,
      previousValue
    } = args;
    const field = args.component.option("field");
    if (!this.option("visible")) {
      this.option("value", "");
    } else {
      this._recurrenceRule.makeRule(field, value2);
      if ("freq" === field) {
        this._makeRepeatOnRule(value2);
        this._changeRepeatOnVisibility(value2, previousValue);
      }
      this._changeEditorValue();
    }
  }
  _makeRepeatOnRule(value2) {
    if ("daily" === value2 || "hourly" === value2) {
      this._recurrenceRule.makeRule("byday", "");
      this._recurrenceRule.makeRule("bymonth", "");
      this._recurrenceRule.makeRule("bymonthday", "");
    }
    if ("weekly" === value2) {
      this._recurrenceRule.makeRule("byday", this._daysOfWeekByRules());
      this._recurrenceRule.makeRule("bymonth", "");
      this._recurrenceRule.makeRule("bymonthday", "");
    }
    if ("monthly" === value2) {
      this._recurrenceRule.makeRule("bymonthday", this._dayOfMonthByRules());
      this._recurrenceRule.makeRule("bymonth", "");
      this._recurrenceRule.makeRule("byday", "");
    }
    if ("yearly" === value2) {
      this._recurrenceRule.makeRule("bymonthday", this._dayOfMonthByRules());
      this._recurrenceRule.makeRule("bymonth", this._monthOfYearByRules());
      this._recurrenceRule.makeRule("byday", "");
    }
  }
  _optionChanged(args) {
    var _this$_recurrenceForm, _this$_repeatCountEdi, _this$_weekEditor, _this$_repeatUntilDat;
    switch (args.name) {
      case "readOnly":
        null === (_this$_recurrenceForm = this._recurrenceForm) || void 0 === _this$_recurrenceForm || _this$_recurrenceForm.option("readOnly", args.value);
        null === (_this$_repeatCountEdi = this._repeatCountEditor) || void 0 === _this$_repeatCountEdi || _this$_repeatCountEdi.option("readOnly", args.value);
        null === (_this$_weekEditor = this._weekEditor) || void 0 === _this$_weekEditor || _this$_weekEditor.option("readOnly", args.value);
        null === (_this$_repeatUntilDat = this._repeatUntilDate) || void 0 === _this$_repeatUntilDat || _this$_repeatUntilDat.option("readOnly", args.value);
        super._optionChanged(args);
        break;
      case "value":
        this._recurrenceRule.makeRules(args.value);
        this._changeRepeatIntervalLabel();
        this._disableRepeatEndParts();
        this._changeEditorsValue(this._recurrenceRule.getRules());
        super._optionChanged(args);
        break;
      case "startDate":
        this._makeRepeatOnRule(this._recurrenceRule.getRules().freq);
        if (isDefined(this._recurrenceRule.getRecurrenceString())) {
          this._changeEditorValue();
        }
        break;
      case "firstDayOfWeek":
        if (this._weekEditor) {
          const localDaysNames = date_default.getDayNames("abbreviated");
          const dayNames = days2.slice(args.value).concat(days2.slice(0, args.value));
          const itemsButtonGroup = localDaysNames.slice(args.value).concat(localDaysNames.slice(0, args.value)).map((item, index) => ({
            text: item,
            key: dayNames[index]
          }));
          this._weekEditor.option("items", itemsButtonGroup);
        }
        if (this._$repeatDateEditor) {
          this._repeatUntilDate.option("calendarOptions.firstDayOfWeek", this._getFirstDayOfWeek());
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
  _changeRepeatOnVisibility(freq, previousFreq) {
    if (freq !== previousFreq) {
      this._recurrenceForm.itemOption("byday", "visible", false);
      this._recurrenceForm.itemOption("bymonthday", "visible", false);
      this._recurrenceForm.itemOption("bymonth", "visible", false);
      this._recurrenceForm.itemOption("repeatOnLabel", "visible", freq && "daily" !== freq && "hourly" !== freq);
      if ("weekly" === freq) {
        this._recurrenceForm.itemOption("byday", "visible", true);
      }
      if ("monthly" === freq) {
        this._recurrenceForm.itemOption("bymonthday", "visible", true);
      }
      if ("yearly" === freq) {
        this._recurrenceForm.itemOption("bymonthday", "visible", true);
        this._recurrenceForm.itemOption("bymonth", "visible", true);
      }
    }
  }
  _changeRepeatIntervalLabel() {
    const {
      freq
    } = this._recurrenceRule.getRules();
    freq && this._recurrenceForm.itemOption("intervalLabel", "template", message_default.format(`dxScheduler-recurrenceRepeat${freq.charAt(0).toUpperCase()}${freq.substr(1).toLowerCase()}`));
  }
  _changeEditorsValue(rules) {
    this._recurrenceForm.getEditor("freq").option("value", (rules.freq || frequenciesMessages[1].value).toLowerCase());
    this._changeDayOfWeekValue();
    this._changeDayOfMonthValue();
    this._changeMonthOfYearValue();
    this._changeIntervalValue(rules.interval);
    this._changeRepeatCountValue();
    this._changeRepeatEndValue();
    this._changeRepeatUntilValue();
  }
  _changeIntervalValue(value2) {
    this._recurrenceForm.getEditor("interval").option("value", value2 || 1);
  }
  _changeRepeatEndValue() {
    const repeatType = this._recurrenceRule.getRepeatEndRule();
    this._recurrenceForm.getEditor("repeatEnd").option("value", repeatType);
  }
  _changeDayOfWeekValue() {
    const isEditorVisible = this._recurrenceForm.itemOption("byday").visible;
    if (isEditorVisible) {
      const days3 = this._daysOfWeekByRules();
      this.getEditorByField("byday").option("selectedItemKeys", days3);
    }
  }
  _changeDayOfMonthValue() {
    const isEditorVisible = this._recurrenceForm.itemOption("bymonthday").visible;
    if (isEditorVisible) {
      const day = this._dayOfMonthByRules();
      this._recurrenceForm.getEditor("bymonthday").option("value", day);
    }
  }
  _changeMonthOfYearValue() {
    const isEditorVisible = this._recurrenceForm.itemOption("bymonth").visible;
    if (isEditorVisible) {
      const month = this._monthOfYearByRules();
      this._recurrenceForm.getEditor("bymonth").option("value", month);
    }
  }
  _changeRepeatCountValue() {
    const count = this._recurrenceRule.getRules().count || 1;
    this._repeatCountEditor.option("value", count);
  }
  _changeRepeatUntilValue() {
    this._repeatUntilDate.option("value", this._getUntilValue());
  }
  _getUntilValue() {
    const untilDate = this._recurrenceRule.getRules().until;
    if (!untilDate) {
      return this._formatUntilDate(/* @__PURE__ */ new Date());
    }
    const getStartDateTimeZone = this.option("getStartDateTimeZone");
    const appointmentTimeZone = getStartDateTimeZone();
    const path = appointmentTimeZone ? PathTimeZoneConversion.fromSourceToAppointment : PathTimeZoneConversion.fromSourceToGrid;
    return this.option("timeZoneCalculator").createDate(untilDate, {
      path,
      appointmentTimeZone
    });
  }
  toggle() {
    this._freqEditor.focus();
  }
  setAria() {
    if (this._switchEditor) {
      this._switchEditor.setAria(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1]);
    }
  }
};
component_registrator_default("dxRecurrenceEditor", RecurrenceEditor);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_utils.scroll.js
var allowScroll = function(container, delta, shiftKey) {
  const $container = renderer_default(container);
  const scrollTopPos = shiftKey ? $container.scrollLeft() : $container.scrollTop();
  const prop = shiftKey ? "Width" : "Height";
  const scrollSize = $container.prop(`scroll${prop}`);
  const clientSize = $container.prop(`client${prop}`);
  const scrollBottomPos = scrollSize - clientSize - scrollTopPos | 0;
  if (0 === scrollTopPos && 0 === scrollBottomPos) {
    return false;
  }
  const isScrollFromTop = 0 === scrollTopPos && delta >= 0;
  const isScrollFromBottom = 0 === scrollBottomPos && delta <= 0;
  const isScrollFromMiddle = scrollTopPos > 0 && scrollBottomPos > 0;
  if (isScrollFromTop || isScrollFromBottom || isScrollFromMiddle) {
    return true;
  }
};
var prepareScrollData = function(container, validateTarget) {
  const $container = renderer_default(container);
  return {
    validate(e) {
      if (isDxMouseWheelEvent(e) && (eventTarget = e.target, validateTarget ? renderer_default(eventTarget).is(container) : true)) {
        if (allowScroll($container, -e.delta, e.shiftKey)) {
          e._needSkipEvent = true;
          return true;
        }
        return false;
      }
      var eventTarget;
    }
  };
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_text_area.js
var TextArea = text_box_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      spellcheck: true,
      minHeight: void 0,
      maxHeight: void 0,
      autoResizeEnabled: false
    });
  },
  _initMarkup() {
    this.$element().addClass("dx-textarea");
    this.callBase();
    this.setAria("multiline", "true");
  },
  _renderContentImpl() {
    this._updateInputHeight();
    this.callBase();
  },
  _renderInput() {
    this.callBase();
    this._renderScrollHandler();
  },
  _createInput() {
    const $input = renderer_default("<textarea>");
    this._applyInputAttributes($input, this.option("inputAttr"));
    this._updateInputAutoResizeAppearance($input);
    return $input;
  },
  _setInputMinHeight: noop,
  _renderScrollHandler() {
    this._eventY = 0;
    const $input = this._input();
    const initScrollData = prepareScrollData($input, true);
    events_engine_default.on($input, addNamespace(emitter_gesture_scroll_default.init, this.NAME), initScrollData, noop);
    events_engine_default.on($input, addNamespace(pointer_default.down, this.NAME), this._pointerDownHandler.bind(this));
    events_engine_default.on($input, addNamespace(pointer_default.move, this.NAME), this._pointerMoveHandler.bind(this));
  },
  _pointerDownHandler(e) {
    this._eventY = eventData(e).y;
  },
  _pointerMoveHandler(e) {
    const currentEventY = eventData(e).y;
    const delta = this._eventY - currentEventY;
    if (allowScroll(this._input(), delta)) {
      e.isScrollingEvent = true;
      e.stopPropagation();
    }
    this._eventY = currentEventY;
  },
  _renderDimensions() {
    const $element = this.$element();
    const element = $element.get(0);
    const width = this._getOptionValue("width", element);
    const height = this._getOptionValue("height", element);
    const minHeight = this.option("minHeight");
    const maxHeight = this.option("maxHeight");
    $element.css({
      minHeight: void 0 !== minHeight ? minHeight : "",
      maxHeight: void 0 !== maxHeight ? maxHeight : "",
      width,
      height
    });
  },
  _resetDimensions() {
    this.$element().css({
      height: "",
      minHeight: "",
      maxHeight: ""
    });
  },
  _renderEvents() {
    if (this.option("autoResizeEnabled")) {
      events_engine_default.on(this._input(), addNamespace("input paste", this.NAME), this._updateInputHeight.bind(this));
    }
    this.callBase();
  },
  _refreshEvents() {
    events_engine_default.off(this._input(), addNamespace("input paste", this.NAME));
    this.callBase();
  },
  _getHeightDifference($input) {
    return getVerticalOffsets(this._$element.get(0), false) + getVerticalOffsets(this._$textEditorContainer.get(0), false) + getVerticalOffsets(this._$textEditorInputContainer.get(0), true) + getElementBoxParams("height", getWindow().getComputedStyle($input.get(0))).margin;
  },
  _updateInputHeight() {
    if (!hasWindow()) {
      return;
    }
    const $input = this._input();
    const height = this.option("height");
    const autoHeightResizing = void 0 === height && this.option("autoResizeEnabled");
    const shouldCalculateInputHeight = autoHeightResizing || void 0 === height && this.option("minHeight");
    if (!shouldCalculateInputHeight) {
      $input.css("height", "");
      return;
    }
    this._resetDimensions();
    this._$element.css("height", getOuterHeight(this._$element));
    $input.css("height", 0);
    const heightDifference = this._getHeightDifference($input);
    this._renderDimensions();
    const minHeight = this._getBoundaryHeight("minHeight");
    const maxHeight = this._getBoundaryHeight("maxHeight");
    let inputHeight = $input[0].scrollHeight;
    if (void 0 !== minHeight) {
      inputHeight = Math.max(inputHeight, minHeight - heightDifference);
    }
    if (void 0 !== maxHeight) {
      const adjustedMaxHeight = maxHeight - heightDifference;
      const needScroll = inputHeight > adjustedMaxHeight;
      inputHeight = Math.min(inputHeight, adjustedMaxHeight);
      this._updateInputAutoResizeAppearance($input, !needScroll);
    }
    $input.css("height", inputHeight);
    if (autoHeightResizing) {
      this._$element.css("height", "auto");
    }
  },
  _getBoundaryHeight(optionName) {
    const boundaryValue = this.option(optionName);
    if (isDefined(boundaryValue)) {
      return "number" === typeof boundaryValue ? boundaryValue : parseHeight(boundaryValue, this.$element().get(0).parentElement, this._$element.get(0));
    }
  },
  _renderInputType: noop,
  _visibilityChanged(visible) {
    if (visible) {
      this._updateInputHeight();
    }
  },
  _updateInputAutoResizeAppearance($input, isAutoResizeEnabled) {
    if ($input) {
      const autoResizeEnabled = ensureDefined(isAutoResizeEnabled, this.option("autoResizeEnabled"));
      $input.toggleClass("dx-texteditor-input-auto-resize", autoResizeEnabled);
    }
  },
  _dimensionChanged() {
    if (this.option("visible")) {
      this._updateInputHeight();
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "autoResizeEnabled":
        this._updateInputAutoResizeAppearance(this._input(), args.value);
        this._refreshEvents();
        this._updateInputHeight();
        break;
      case "value":
      case "height":
        this.callBase(args);
        this._updateInputHeight();
        break;
      case "minHeight":
      case "maxHeight":
        this._renderDimensions();
        this._updateInputHeight();
        break;
      case "visible":
        this.callBase(args);
        args.value && this._updateInputHeight();
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxTextArea", TextArea);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_tag_box.js
function xor(a, b) {
  return (a || b) && !(a && b);
}
var TagBox = select_box_default.inherit({
  _supportedKeys() {
    const parent = this.callBase();
    const sendToList = (options) => this._list._keyboardHandler(options);
    const rtlEnabled = this.option("rtlEnabled");
    return extend({}, parent, {
      backspace(e) {
        if (!this._isCaretAtTheStart()) {
          return;
        }
        this._processKeyboardEvent(e);
        this._isTagRemoved = true;
        const $tagToDelete = this._$focusedTag || this._tagElements().last();
        if (this._$focusedTag) {
          this._moveTagFocus("prev", true);
        }
        if (0 === $tagToDelete.length) {
          return;
        }
        this._preserveFocusedTag = true;
        this._removeTagElement($tagToDelete);
        delete this._preserveFocusedTag;
      },
      upArrow: (e, opts) => e.altKey || !this._list ? parent.upArrow.call(this, e) : sendToList(opts),
      downArrow: (e, opts) => e.altKey || !this._list ? parent.downArrow.call(this, e) : sendToList(opts),
      del(e) {
        if (!this._$focusedTag || !this._isCaretAtTheStart()) {
          return;
        }
        this._processKeyboardEvent(e);
        this._isTagRemoved = true;
        const $tagToDelete = this._$focusedTag;
        this._moveTagFocus("next", true);
        this._preserveFocusedTag = true;
        this._removeTagElement($tagToDelete);
        delete this._preserveFocusedTag;
      },
      enter(e, options) {
        const isListItemFocused = this._list && null !== this._list.option("focusedElement");
        const isCustomItem = this.option("acceptCustomValue") && !isListItemFocused;
        if (isCustomItem) {
          e.preventDefault();
          "" !== this._searchValue() && this._customItemAddedHandler(e);
          return;
        }
        if (this.option("opened")) {
          this._saveValueChangeEvent(e);
          sendToList(options);
          e.preventDefault();
        }
      },
      space(e, options) {
        const isOpened = this.option("opened");
        const isInputActive = this._shouldRenderSearchEvent();
        if (isOpened && !isInputActive) {
          this._saveValueChangeEvent(e);
          sendToList(options);
          e.preventDefault();
        }
      },
      leftArrow(e) {
        if (!this._isCaretAtTheStart() || this._isEmpty() || this._isEditable() && rtlEnabled && !this._$focusedTag) {
          return;
        }
        e.preventDefault();
        const direction = rtlEnabled ? "next" : "prev";
        this._moveTagFocus(direction);
        !this.option("multiline") && this._scrollContainer(direction);
      },
      rightArrow(e) {
        if (!this._isCaretAtTheStart() || this._isEmpty() || this._isEditable() && !rtlEnabled && !this._$focusedTag) {
          return;
        }
        e.preventDefault();
        const direction = rtlEnabled ? "prev" : "next";
        this._moveTagFocus(direction);
        !this.option("multiline") && this._scrollContainer(direction);
      }
    });
  },
  _processKeyboardEvent(e) {
    e.preventDefault();
    e.stopPropagation();
    this._saveValueChangeEvent(e);
  },
  _isEmpty() {
    return 0 === this._getValue().length;
  },
  _updateTagsContainer($element) {
    this._$tagsContainer = $element.addClass("dx-tag-container");
  },
  _allowSelectItemByTab: () => false,
  _isCaretAtTheStart() {
    const position = m_utils_caret_default(this._input());
    return 0 === (null === position || void 0 === position ? void 0 : position.start) && 0 === position.end;
  },
  _updateInputAriaActiveDescendant(id) {
    this.setAria("activedescendant", id, this._input());
  },
  _moveTagFocus(direction, clearOnBoundary) {
    if (!this._$focusedTag) {
      const tagElements = this._tagElements();
      this._$focusedTag = "next" === direction ? tagElements.first() : tagElements.last();
      this._toggleFocusClass(true, this._$focusedTag);
      this._updateInputAriaActiveDescendant(this._$focusedTag.attr("id"));
      return;
    }
    const $nextFocusedTag = this._$focusedTag[direction](".dx-tag");
    if ($nextFocusedTag.length > 0) {
      this._replaceFocusedTag($nextFocusedTag);
      this._updateInputAriaActiveDescendant($nextFocusedTag.attr("id"));
    } else if (clearOnBoundary || "next" === direction && this._isEditable()) {
      this._clearTagFocus();
      this._updateInputAriaActiveDescendant();
    }
  },
  _replaceFocusedTag($nextFocusedTag) {
    this._toggleFocusClass(false, this._$focusedTag);
    this._$focusedTag = $nextFocusedTag;
    this._toggleFocusClass(true, this._$focusedTag);
  },
  _clearTagFocus() {
    if (!this._$focusedTag) {
      return;
    }
    this._toggleFocusClass(false, this._$focusedTag);
    this._updateInputAriaActiveDescendant();
    delete this._$focusedTag;
  },
  _focusClassTarget($element) {
    if ($element && $element.length && $element[0] !== this._focusTarget()[0]) {
      return $element;
    }
    return this.callBase();
  },
  _getLabelContainer() {
    return this._$tagsContainer;
  },
  _getFieldElement() {
    return this._input();
  },
  _scrollContainer(direction) {
    if (this.option("multiline") || !hasWindow()) {
      return;
    }
    if (!this._$tagsContainer) {
      return;
    }
    const scrollPosition = this._getScrollPosition(direction);
    this._$tagsContainer.scrollLeft(scrollPosition);
  },
  _getScrollPosition(direction) {
    if ("start" === direction || "end" === direction) {
      return this._getBorderPosition(direction);
    }
    return this._$focusedTag ? this._getFocusedTagPosition(direction) : this._getBorderPosition("end");
  },
  _getBorderPosition(direction) {
    const rtlEnabled = this.option("rtlEnabled");
    const isScrollLeft = xor("end" === direction, rtlEnabled);
    const scrollSign = rtlEnabled ? -1 : 1;
    return xor(isScrollLeft, !rtlEnabled) ? 0 : scrollSign * (this._$tagsContainer.get(0).scrollWidth - getOuterWidth(this._$tagsContainer));
  },
  _getFocusedTagPosition(direction) {
    const rtlEnabled = this.option("rtlEnabled");
    const isScrollLeft = xor("next" === direction, rtlEnabled);
    let {
      left: scrollOffset
    } = this._$focusedTag.position();
    let scrollLeft = this._$tagsContainer.scrollLeft();
    if (isScrollLeft) {
      scrollOffset += getOuterWidth(this._$focusedTag, true) - getOuterWidth(this._$tagsContainer);
    }
    if (xor(isScrollLeft, scrollOffset < 0)) {
      scrollLeft += scrollOffset;
    }
    return scrollLeft;
  },
  _setNextValue: noop,
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: [],
      showDropDownButton: false,
      maxFilterQueryLength: 1500,
      tagTemplate: "tag",
      selectAllText: message_default.format("dxList-selectAll"),
      hideSelectedItems: false,
      selectedItems: [],
      selectAllMode: "page",
      onSelectAllValueChanged: null,
      maxDisplayedTags: void 0,
      showMultiTagOnly: true,
      onMultiTagPreparing: null,
      multiline: true,
      useSubmitBehavior: true
    });
  },
  _init() {
    this.callBase();
    this._selectedItems = [];
    this._initSelectAllValueChangedAction();
  },
  _initActions() {
    this.callBase();
    this._initMultiTagPreparingAction();
  },
  _initMultiTagPreparingAction() {
    this._multiTagPreparingAction = this._createActionByOption("onMultiTagPreparing", {
      beforeExecute: (e) => {
        this._multiTagPreparingHandler(e.args[0]);
      },
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _multiTagPreparingHandler(args) {
    const {
      length: selectedCount
    } = this._getValue();
    if (!this.option("showMultiTagOnly")) {
      args.text = message_default.getFormatter("dxTagBox-moreSelected")(selectedCount - this.option("maxDisplayedTags") + 1);
    } else {
      args.text = message_default.getFormatter("dxTagBox-selected")(selectedCount);
    }
  },
  _initDynamicTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      tag: new BindableTemplate(($container, data2) => {
        const $tagContent = renderer_default("<div>").addClass("dx-tag-content");
        renderer_default("<span>").text(data2.text ?? data2).appendTo($tagContent);
        renderer_default("<div>").addClass("dx-tag-remove-button").appendTo($tagContent);
        $container.append($tagContent);
      }, ["text"], this.option("integrationOptions.watchMethod"), {
        text: this._displayGetter
      })
    });
  },
  _toggleSubmitElement(enabled) {
    if (enabled) {
      this._renderSubmitElement();
      this._setSubmitValue();
    } else {
      this._$submitElement && this._$submitElement.remove();
      delete this._$submitElement;
    }
  },
  _renderSubmitElement() {
    if (!this.option("useSubmitBehavior")) {
      return;
    }
    this._$submitElement = renderer_default("<select>").attr({
      multiple: "multiple",
      "aria-label": "Selected items"
    }).css("display", "none").appendTo(this.$element());
  },
  _setSubmitValue() {
    if (!this.option("useSubmitBehavior")) {
      return;
    }
    const value2 = this._getValue();
    const $options = [];
    for (let i = 0, n = value2.length; i < n; i++) {
      const useDisplayText = this._shouldUseDisplayValue(value2[i]);
      $options.push(renderer_default("<option>").val(useDisplayText ? this._displayGetter(value2[i]) : value2[i]).attr("selected", "selected"));
    }
    this._getSubmitElement().empty().append($options);
  },
  _initMarkup() {
    this._tagElementsCache = renderer_default();
    const isSingleLineMode = !this.option("multiline");
    this.$element().addClass("dx-tagbox").toggleClass("dx-tagbox-only-select", !(this.option("searchEnabled") || this.option("acceptCustomValue"))).toggleClass("dx-tagbox-single-line", isSingleLineMode);
    this.setAria({
      role: "application",
      roledescription: "tagbox"
    }, this.$element());
    this._initTagTemplate();
    this.callBase();
  },
  _getNewLabelId(actualId, newId, shouldRemove) {
    if (!actualId) {
      return newId;
    }
    if (shouldRemove) {
      if (actualId === newId) {
        return;
      }
      return actualId.split(" ").filter((id) => id !== newId).join(" ");
    }
    return `${actualId} ${newId}`;
  },
  _updateElementAria(id, shouldRemove) {
    const shouldClearLabel = !id;
    if (shouldClearLabel) {
      this.setAria("labelledby", void 0, this.$element());
      return;
    }
    const labelId = this.$element().attr("aria-labelledby");
    const newLabelId = this._getNewLabelId(labelId, id, shouldRemove);
    this.setAria("labelledby", newLabelId, this.$element());
  },
  _render() {
    this.callBase();
    this._renderTagRemoveAction();
    this._renderSingleLineScroll();
    this._scrollContainer("start");
  },
  _initTagTemplate() {
    this._tagTemplate = this._getTemplateByOption("tagTemplate");
  },
  _renderField() {
    const isDefaultFieldTemplate = !isDefined(this.option("fieldTemplate"));
    this.$element().toggleClass("dx-tagbox-default-template", isDefaultFieldTemplate).toggleClass("dx-tagbox-custom-template", !isDefaultFieldTemplate);
    this.callBase();
  },
  _renderTagRemoveAction() {
    const tagRemoveAction = this._createAction(this._removeTagHandler.bind(this));
    const eventName = addNamespace(CLICK_EVENT_NAME, "dxTagBoxTagRemove");
    events_engine_default.off(this._$tagsContainer, eventName);
    events_engine_default.on(this._$tagsContainer, eventName, ".dx-tag-remove-button", (event) => {
      tagRemoveAction({
        event
      });
    });
  },
  _renderSingleLineScroll() {
    const mouseWheelEvent = addNamespace("dxmousewheel", this.NAME);
    const $element = this.$element();
    const isMultiline = this.option("multiline");
    events_engine_default.off($element, mouseWheelEvent);
    if ("desktop" !== devices_default.real().deviceType) {
      this._$tagsContainer && this._$tagsContainer.css("overflowX", isMultiline ? "" : "auto");
      return;
    }
    if (isMultiline) {
      return;
    }
    events_engine_default.on($element, mouseWheelEvent, this._tagContainerMouseWheelHandler.bind(this));
  },
  _tagContainerMouseWheelHandler(e) {
    const scrollLeft = this._$tagsContainer.scrollLeft();
    const delta = -0.3 * e.delta;
    if (!isCommandKeyPressed(e) && allowScroll(this._$tagsContainer, delta, true)) {
      this._$tagsContainer.scrollLeft(scrollLeft + delta);
      return false;
    }
    return;
  },
  _renderEvents() {
    this.callBase();
    const input = this._input();
    const namespace = addNamespace("keydown", this.NAME);
    events_engine_default.on(input, namespace, (e) => {
      const keyName = normalizeKeyName(e);
      if (!this._isControlKey(keyName) && this._isEditable()) {
        this._clearTagFocus();
      }
    });
  },
  _popupWrapperClass() {
    return `${this.callBase()} dx-tagbox-popup-wrapper`;
  },
  _renderInput() {
    this.callBase();
    this._renderPreventBlurOnInputClick();
  },
  _renderPreventBlurOnInputClick() {
    const eventName = addNamespace("mousedown", "dxTagBox");
    events_engine_default.off(this._inputWrapper(), eventName);
    events_engine_default.on(this._inputWrapper(), eventName, (e) => {
      if (e.target !== this._input()[0] && this._isFocused()) {
        e.preventDefault();
      }
    });
  },
  _renderInputValueImpl() {
    return this._renderMultiSelect();
  },
  _loadInputValue: () => when(),
  _clearTextValue() {
    this._input().val("");
    this._toggleEmptinessEventHandler();
    this.option("text", "");
  },
  _focusInHandler(e) {
    if (!this._preventNestedFocusEvent(e)) {
      this._scrollContainer("end");
    }
    this.callBase(e);
  },
  _renderInputValue() {
    this.option("displayValue", this._searchValue());
    return this.callBase();
  },
  _restoreInputText(saveEditingValue) {
    if (!saveEditingValue) {
      this._clearTextValue();
    }
  },
  _focusOutHandler(e) {
    if (!this._preventNestedFocusEvent(e)) {
      this._clearTagFocus();
      this._scrollContainer("start");
    }
    this.callBase(e);
  },
  _initSelectAllValueChangedAction() {
    this._selectAllValueChangeAction = this._createActionByOption("onSelectAllValueChanged");
  },
  _renderList() {
    this.callBase();
    this._setListDataSourceFilter();
  },
  _canListHaveFocus() {
    return "useButtons" === this.option("applyValueMode");
  },
  _listConfig() {
    const selectionMode = this.option("showSelectionControls") ? "all" : "multiple";
    return extend(this.callBase(), {
      maxFilterLengthInRequest: this.option("maxFilterQueryLength"),
      selectionMode,
      selectAllText: this.option("selectAllText"),
      onSelectAllValueChanged: (_ref) => {
        let {
          value: value2
        } = _ref;
        this._selectAllValueChangeAction({
          value: value2
        });
      },
      selectAllMode: this.option("selectAllMode"),
      selectedItems: this._selectedItems,
      onFocusedItemChanged: null
    });
  },
  _renderMultiSelect() {
    const d = Deferred();
    this._updateTagsContainer(this._$textEditorInputContainer);
    this._renderInputSize();
    this._renderTags().done(() => {
      this._popup && this._popup.refreshPosition();
      d.resolve();
    }).fail(d.reject);
    return d.promise();
  },
  _listItemClickHandler(e) {
    !this.option("showSelectionControls") && this._clearTextValue();
    if ("useButtons" === this.option("applyValueMode")) {
      return;
    }
    this.callBase(e);
    this._saveValueChangeEvent(void 0);
  },
  _shouldClearFilter() {
    const shouldClearFilter = this.callBase();
    const showSelectionControls = this.option("showSelectionControls");
    return !showSelectionControls && shouldClearFilter;
  },
  _renderInputSize() {
    const $input = this._input();
    const value2 = $input.val();
    const isEmptyInput = isString(value2) && value2;
    let width = "";
    let size;
    const canTypeText = this.option("searchEnabled") || this.option("acceptCustomValue");
    if (isEmptyInput && canTypeText) {
      const $calculationElement = createTextElementHiddenCopy($input, value2, {
        includePaddings: true
      });
      $calculationElement.insertAfter($input);
      width = getOuterWidth($calculationElement) + 5;
      $calculationElement.remove();
    } else if (!value2) {
      size = 1;
    }
    $input.css("width", width);
    $input.attr("size", size ?? "");
  },
  _renderInputSubstitution() {
    this.callBase();
    this._updateWidgetHeight();
  },
  _getValue() {
    return this.option("value") || [];
  },
  _multiTagRequired() {
    const values = this._getValue();
    const maxDisplayedTags = this.option("maxDisplayedTags");
    return isDefined(maxDisplayedTags) && values.length > maxDisplayedTags;
  },
  _renderMultiTag($input) {
    const tagId = `dx-${new guid_default()}`;
    const $tag = renderer_default("<div>").attr("id", tagId).addClass("dx-tag").addClass("dx-tagbox-multi-tag");
    const args = {
      multiTagElement: getPublicElement($tag),
      selectedItems: this.option("selectedItems")
    };
    this._multiTagPreparingAction(args);
    if (args.cancel) {
      return false;
    }
    $tag.data("dxTagData", args.text);
    $tag.insertBefore($input);
    this._tagTemplate.render({
      model: args.text,
      container: getPublicElement($tag)
    });
    const tagText = args.text;
    this._setTagAria($tag, tagText);
    this._updateElementAria(tagId);
    return $tag;
  },
  _getFilter(creator) {
    const dataSourceFilter = this._dataController.filter();
    const filterExpr = creator.getCombinedFilter(this.option("valueExpr"), dataSourceFilter);
    const filterQueryLength = encodeURI(JSON.stringify(filterExpr)).length;
    const maxFilterQueryLength = this.option("maxFilterQueryLength");
    if (filterQueryLength <= maxFilterQueryLength) {
      return filterExpr;
    }
    ui_errors_default.log("W1019", maxFilterQueryLength);
  },
  _getFilteredItems(values) {
    var _this$_loadFilteredIt, _this$_list;
    null === (_this$_loadFilteredIt = this._loadFilteredItemsPromise) || void 0 === _this$_loadFilteredIt || _this$_loadFilteredIt.reject();
    const creator = new SelectionFilterCreator(values);
    const listSelectedItems = null === (_this$_list = this._list) || void 0 === _this$_list ? void 0 : _this$_list.option("selectedItems");
    const isListItemsLoaded = !!listSelectedItems && this._list._dataController.isLoaded();
    const selectedItems = listSelectedItems || this.option("selectedItems");
    const clientFilterFunction = creator.getLocalFilter(this._valueGetter);
    const filteredItems = selectedItems.filter(clientFilterFunction);
    const selectedItemsAlreadyLoaded = filteredItems.length === values.length;
    const d = Deferred();
    const dataController = this._dataController;
    if ((!this._isDataSourceChanged || isListItemsLoaded) && selectedItemsAlreadyLoaded) {
      return d.resolve(filteredItems).promise();
    }
    const {
      customQueryParams,
      expand,
      select
    } = dataController.loadOptions();
    const filter = this._getFilter(creator);
    dataController.loadFromStore({
      filter,
      customQueryParams,
      expand,
      select
    }).done((data2, extra) => {
      this._isDataSourceChanged = false;
      if (this._disposed) {
        d.reject();
        return;
      }
      const {
        data: items
      } = normalizeLoadResult(data2, extra);
      const mappedItems = dataController.applyMapFunction(items);
      d.resolve(mappedItems.filter(clientFilterFunction));
    }).fail(d.reject);
    this._loadFilteredItemsPromise = d;
    return d.promise();
  },
  _createTagsData(values, filteredItems) {
    const items = [];
    const cache = {};
    const isValueExprSpecified = "this" === this._valueGetterExpr();
    const filteredValues = {};
    filteredItems.forEach((filteredItem) => {
      const filteredItemValue = isValueExprSpecified ? JSON.stringify(filteredItem) : this._valueGetter(filteredItem);
      filteredValues[filteredItemValue] = filteredItem;
    });
    const loadItemPromises = [];
    values.forEach((value2, index) => {
      const currentItem = filteredValues[isValueExprSpecified ? JSON.stringify(value2) : value2];
      if (isValueExprSpecified && !isDefined(currentItem)) {
        loadItemPromises.push(this._loadItem(value2, cache).always((item) => {
          const newItem = this._createTagData(item, value2);
          items.splice(index, 0, newItem);
        }));
      } else {
        const newItem = this._createTagData(currentItem, value2);
        items.splice(index, 0, newItem);
      }
    });
    const d = Deferred();
    when.apply(this, loadItemPromises).always(() => {
      d.resolve(items);
    });
    return d.promise();
  },
  _createTagData(item, value2) {
    if (isDefined(item)) {
      this._selectedItems.push(item);
      return item;
    }
    const selectedItem = this.option("selectedItem");
    const customItem = this._valueGetter(selectedItem) === value2 ? selectedItem : value2;
    return customItem;
  },
  _isGroupedData() {
    return this.option("grouped") && !this._dataController.group();
  },
  _getItemsByValues(values) {
    const resultItems = [];
    values.forEach((value2) => {
      const item = this._getItemFromPlain(value2);
      if (isDefined(item)) {
        resultItems.push(item);
      }
    });
    return resultItems;
  },
  _getFilteredGroupedItems(values) {
    const selectedItems = Deferred();
    if (this._filteredGroupedItemsLoadPromise) {
      this._dataController.cancel(this._filteredGroupedItemsLoadPromise.operationId);
    }
    if (!this._dataController.items().length) {
      this._filteredGroupedItemsLoadPromise = this._dataController.load().done(() => {
        selectedItems.resolve(this._getItemsByValues(values));
      }).fail(() => {
        selectedItems.resolve([]);
      }).always(() => {
        this._filteredGroupedItemsLoadPromise = void 0;
      });
    } else {
      selectedItems.resolve(this._getItemsByValues(values));
    }
    return selectedItems.promise();
  },
  _loadTagsData() {
    const values = this._getValue();
    const tagData = Deferred();
    this._selectedItems = [];
    const filteredItemsPromise = this._isGroupedData() ? this._getFilteredGroupedItems(values) : this._getFilteredItems(values);
    filteredItemsPromise.done((filteredItems) => {
      const items = this._createTagsData(values, filteredItems);
      items.always((data2) => {
        tagData.resolve(data2);
      });
    }).fail(tagData.reject.bind(this));
    return tagData.promise();
  },
  _renderTags() {
    const d = Deferred();
    let isPlainDataUsed = false;
    if (this._shouldGetItemsFromPlain(this._valuesToUpdate)) {
      this._selectedItems = this._getItemsFromPlain(this._valuesToUpdate);
      if (this._selectedItems.length === this._valuesToUpdate.length) {
        this._renderTagsImpl(this._selectedItems);
        isPlainDataUsed = true;
        d.resolve();
      }
    }
    if (!isPlainDataUsed) {
      this._loadTagsData().done((items) => {
        if (this._disposed) {
          d.reject();
          return;
        }
        this._renderTagsImpl(items);
        d.resolve();
      }).fail(d.reject);
    }
    return d.promise();
  },
  _renderTagsImpl(items) {
    this._renderTagsCore(items);
    this._renderEmptyState();
    if (!this._preserveFocusedTag) {
      this._clearTagFocus();
    }
  },
  _shouldGetItemsFromPlain(values) {
    return values && this._dataController.isLoaded() && values.length <= this._getPlainItems().length;
  },
  _getItemsFromPlain(values) {
    let selectedItems = this._getSelectedItemsFromList(values);
    const needFilterPlainItems = 0 === selectedItems.length && values.length > 0 || selectedItems.length < values.length;
    if (needFilterPlainItems) {
      const plainItems = this._getPlainItems();
      selectedItems = this._filterSelectedItems(plainItems, values);
    }
    return selectedItems;
  },
  _getSelectedItemsFromList(values) {
    var _this$_list2;
    const listSelectedItems = null === (_this$_list2 = this._list) || void 0 === _this$_list2 ? void 0 : _this$_list2.option("selectedItems");
    let selectedItems = [];
    if (values.length === (null === listSelectedItems || void 0 === listSelectedItems ? void 0 : listSelectedItems.length)) {
      selectedItems = this._filterSelectedItems(listSelectedItems, values);
    }
    return selectedItems;
  },
  _filterSelectedItems(plainItems, values) {
    const selectedItems = plainItems.filter((dataItem) => {
      let currentValue;
      for (let i = 0; i < values.length; i++) {
        currentValue = values[i];
        if (isObject(currentValue)) {
          if (this._isValueEquals(dataItem, currentValue)) {
            return true;
          }
        } else if (this._isValueEquals(this._valueGetter(dataItem), currentValue)) {
          return true;
        }
      }
      return false;
    }, this);
    return selectedItems;
  },
  _integrateInput() {
    this._isInputReady.resolve();
    this.callBase();
    const tagsContainer = this.$element().find(".dx-texteditor-input-container");
    this._updateTagsContainer(tagsContainer);
    this._renderTagRemoveAction();
  },
  _renderTagsCore(items) {
    var _this$_isInputReady;
    null === (_this$_isInputReady = this._isInputReady) || void 0 === _this$_isInputReady || _this$_isInputReady.reject();
    this._isInputReady = Deferred();
    this._renderField();
    this.option("selectedItems", this._selectedItems.slice());
    this._cleanTags();
    if (this._input().length > 0) {
      this._isInputReady.resolve();
    }
    when(this._isInputReady).done(() => {
      this._renderTagsElements(items);
    });
  },
  _renderTagsElements(items) {
    const $multiTag = this._multiTagRequired() && this._renderMultiTag(this._input());
    const showMultiTagOnly = this.option("showMultiTagOnly");
    const maxDisplayedTags = this.option("maxDisplayedTags");
    items.forEach((item, index) => {
      if ($multiTag && showMultiTagOnly || $multiTag && !showMultiTagOnly && index - maxDisplayedTags >= -1) {
        return false;
      }
      this._renderTag(item, $multiTag || this._input());
      return;
    });
    if (this._isFocused()) {
      this._scrollContainer("end");
    }
    this._refreshTagElements();
  },
  _cleanTags() {
    if (this._multiTagRequired()) {
      this._tagElements().remove();
    } else {
      const $tags = this._tagElements();
      const values = this._getValue();
      each($tags, (_, tag) => {
        const $tag = renderer_default(tag);
        const tagData = $tag.data("dxTagData");
        if (!(null !== values && void 0 !== values && values.includes(tagData))) {
          $tag.remove();
        }
      });
    }
    this._updateElementAria();
  },
  _renderEmptyState() {
    const isEmpty = !(this._getValue().length || this._selectedItems.length || this._searchValue());
    this._toggleEmptiness(isEmpty);
    this._renderDisplayText();
  },
  _renderDisplayText() {
    this._renderInputSize();
  },
  _refreshTagElements() {
    this._tagElementsCache = this.$element().find(".dx-tag");
  },
  _tagElements() {
    return this._tagElementsCache;
  },
  _applyTagTemplate(item, $tag) {
    this._tagTemplate.render({
      model: item,
      container: getPublicElement($tag)
    });
  },
  _renderTag(item, $input) {
    const value2 = this._valueGetter(item);
    if (!isDefined(value2)) {
      return;
    }
    let $tag = this._getTag(value2);
    const displayValue = this._displayGetter(item);
    const itemModel = this._getItemModel(item, displayValue);
    if ($tag) {
      if (isDefined(displayValue)) {
        $tag.empty();
        this._applyTagTemplate(itemModel, $tag);
      }
      $tag.removeClass("dx-tag-custom");
      this._updateElementAria($tag.attr("id"));
    } else {
      const tagId = `dx-${new guid_default()}`;
      $tag = this._createTag(value2, $input, tagId);
      this._setTagAria($tag, isDefined(displayValue) ? displayValue : value2);
      if (isDefined(item)) {
        this._applyTagTemplate(itemModel, $tag);
      } else {
        $tag.addClass("dx-tag-custom");
        this._applyTagTemplate(value2, $tag);
      }
      this._updateElementAria(tagId);
    }
  },
  _setTagAria($tag, tagText) {
    const aria = {
      role: "button",
      label: tagText,
      roledescription: message_default.format("dxTagBox-tagRoleDescription")
    };
    this.setAria(aria, $tag);
  },
  _getItemModel(item, displayValue) {
    if (isObject(item) && isDefined(displayValue)) {
      return item;
    }
    return ensureDefined(displayValue, "");
  },
  _getTag(value2) {
    const $tags = this._tagElements();
    const tagsLength = $tags.length;
    let result = false;
    for (let i = 0; i < tagsLength; i++) {
      const $tag = $tags[i];
      const tagData = data($tag, "dxTagData");
      if (value2 === tagData || equalByValue(value2, tagData)) {
        result = renderer_default($tag);
        break;
      }
    }
    return result;
  },
  _createTag: (value2, $input, tagId) => renderer_default("<div>").attr("id", tagId).addClass("dx-tag").data("dxTagData", value2).insertBefore($input),
  _toggleEmptinessEventHandler() {
    this._toggleEmptiness(!this._getValue().length && !this._searchValue().length);
  },
  _customItemAddedHandler(e) {
    this.callBase(e);
    this._clearTextValue();
  },
  _removeTagHandler(args) {
    const e = args.event;
    e.stopPropagation();
    this._saveValueChangeEvent(e);
    const $tag = renderer_default(e.target).closest(".dx-tag");
    this._removeTagElement($tag);
  },
  _removeTagElement($tag) {
    if ($tag.hasClass("dx-tagbox-multi-tag")) {
      if (!this.option("showMultiTagOnly")) {
        this.option("value", this._getValue().slice(0, this.option("maxDisplayedTags")));
      } else {
        this.clear();
      }
      return;
    }
    const itemValue = $tag.data("dxTagData");
    const itemId = $tag.attr("id");
    this._removeTagWithUpdate(itemValue);
    this._updateElementAria(itemId, true);
    this._refreshTagElements();
  },
  _updateField: noop,
  _removeTagWithUpdate(itemValue) {
    const value2 = this._getValue().slice();
    this._removeTag(value2, itemValue);
    this.option("value", value2);
    this.option("selectedItem", null);
    if (0 === value2.length) {
      this._clearTagFocus();
    }
  },
  _getCurrentValue() {
    return this._lastValue();
  },
  _selectionChangeHandler(e) {
    if ("useButtons" === this.option("applyValueMode")) {
      return;
    }
    const value2 = this._getValue().slice();
    each(e.removedItems || [], (_, removedItem) => {
      this._removeTag(value2, this._valueGetter(removedItem));
    });
    each(e.addedItems || [], (_, addedItem) => {
      this._addTag(value2, this._valueGetter(addedItem));
    });
    this._updateWidgetHeight();
    if (!equalByValue(this._list.option("selectedItemKeys"), this.option("value"))) {
      const listSelectionChangeEvent = this._list._getSelectionChangeEvent();
      listSelectionChangeEvent && this._saveValueChangeEvent(listSelectionChangeEvent);
      this.option("value", value2);
    }
    this._list._saveSelectionChangeEvent(void 0);
  },
  _removeTag(value2, item) {
    const index = this._valueIndex(item, value2);
    if (index >= 0) {
      value2.splice(index, 1);
    }
  },
  _addTag(value2, item) {
    const index = this._valueIndex(item);
    if (index < 0) {
      value2.push(item);
    }
  },
  _fieldRenderData() {
    return this._selectedItems.slice();
  },
  _completeSelection(value2) {
    if (!this.option("showSelectionControls")) {
      this._setValue(value2);
    }
  },
  _setValue(value2) {
    var _this$_list3;
    if (null === value2) {
      return;
    }
    const useButtons = "useButtons" === this.option("applyValueMode");
    const valueIndex = this._valueIndex(value2);
    const values = (useButtons ? (null === (_this$_list3 = this._list) || void 0 === _this$_list3 ? void 0 : _this$_list3.option("selectedItemKeys")) || [] : this._getValue()).slice();
    if (valueIndex >= 0) {
      values.splice(valueIndex, 1);
    } else {
      values.push(value2);
    }
    if (useButtons) {
      var _this$_list4;
      null === (_this$_list4 = this._list) || void 0 === _this$_list4 || _this$_list4.option("selectedItemKeys", values);
    } else {
      this.option("value", values);
    }
  },
  _isSelectedValue(value2, cache) {
    return this._valueIndex(value2, null, cache) > -1;
  },
  _valueIndex(value2, values, cache) {
    let result = -1;
    if (cache && "object" !== typeof value2) {
      if (!cache.indexByValues) {
        cache.indexByValues = {};
        values = values || this._getValue();
        values.forEach((value3, index) => {
          cache.indexByValues[value3] = index;
        });
      }
      if (value2 in cache.indexByValues) {
        return cache.indexByValues[value2];
      }
    }
    values = values || this._getValue();
    each(values, (index, selectedValue) => {
      if (this._isValueEquals(value2, selectedValue)) {
        result = index;
        return false;
      }
      return;
    });
    return result;
  },
  _lastValue() {
    const values = this._getValue();
    const lastValue = values[values.length - 1];
    return lastValue ?? null;
  },
  _shouldRenderSearchEvent() {
    return this.option("searchEnabled") || this.option("acceptCustomValue");
  },
  _searchHandler(e) {
    if (this.option("searchEnabled") && !!e && !this._isTagRemoved) {
      this.callBase(arguments);
      this._setListDataSourceFilter();
    }
    this._updateWidgetHeight();
    delete this._isTagRemoved;
  },
  _updateWidgetHeight() {
    const element = this.$element();
    const originalHeight = getHeight(element);
    this._renderInputSize();
    const currentHeight = getHeight(element);
    if (this._popup && this.option("opened") && this._isEditable() && currentHeight !== originalHeight) {
      this._popup.repaint();
    }
  },
  _refreshSelected() {
    var _this$_list5;
    (null === (_this$_list5 = this._list) || void 0 === _this$_list5 ? void 0 : _this$_list5.getDataSource()) && this._list.option("selectedItems", this._selectedItems);
  },
  _resetListDataSourceFilter() {
    const dataController = this._dataController;
    delete this._userFilter;
    dataController.filter(null);
    dataController.reload();
  },
  _setListDataSourceFilter() {
    if (!this.option("hideSelectedItems") || !this._list) {
      return;
    }
    const dataController = this._dataController;
    const valueGetterExpr = this._valueGetterExpr();
    if (isString(valueGetterExpr) && "this" !== valueGetterExpr) {
      const filter = this._dataSourceFilterExpr();
      if (void 0 === this._userFilter) {
        this._userFilter = dataController.filter() || null;
      }
      this._userFilter && filter.push(this._userFilter);
      filter.length ? dataController.filter(filter) : dataController.filter(null);
    } else {
      dataController.filter(this._dataSourceFilterFunction.bind(this));
    }
    dataController.load();
  },
  _dataSourceFilterExpr() {
    const filter = [];
    this._getValue().forEach((value2) => filter.push(["!", [this._valueGetterExpr(), value2]]));
    return filter;
  },
  _dataSourceFilterFunction(itemData) {
    const itemValue = this._valueGetter(itemData);
    let result = true;
    each(this._getValue(), (index, value2) => {
      if (this._isValueEquals(value2, itemValue)) {
        result = false;
        return false;
      }
      return;
    });
    return result;
  },
  _dataSourceChangedHandler() {
    this._isDataSourceChanged = true;
    this.callBase.apply(this, arguments);
  },
  _applyButtonHandler(args) {
    this._saveValueChangeEvent(args.event);
    this.option("value", this._getSortedListValues());
    this._clearTextValue();
    this.callBase();
    this._cancelSearchIfNeed();
  },
  _getSortedListValues() {
    const listValues = this._getListValues();
    const currentValue = this.option("value") || [];
    const existedItems = listValues.length ? getIntersection(currentValue, listValues) : [];
    const newItems = existedItems.length ? removeDuplicates(listValues, currentValue) : listValues;
    return existedItems.concat(newItems);
  },
  _getListValues() {
    if (!this._list) {
      return [];
    }
    return this._getPlainItems(this._list.option("selectedItems")).map((item) => this._valueGetter(item));
  },
  _setListDataSource() {
    const currentValue = this._getValue();
    this.callBase();
    if (currentValue !== this.option("value")) {
      this.option("value", currentValue);
    }
    this._refreshSelected();
  },
  _renderOpenedState() {
    this.callBase();
    if ("useButtons" === this.option("applyValueMode") && !this.option("opened")) {
      this._refreshSelected();
    }
  },
  clear() {
    this._restoreInputText();
    const defaultValue = this._getDefaultOptions().value;
    const currentValue = this.option("value");
    if (defaultValue && 0 === defaultValue.length && currentValue && defaultValue.length === currentValue.length) {
      return;
    }
    this.callBase();
  },
  _clean() {
    this.callBase();
    delete this._defaultTagTemplate;
    delete this._valuesToUpdate;
    delete this._tagTemplate;
  },
  _getSelectedItemsDifference(newItems, previousItems) {
    if (!newItems.length) {
      return {
        addedItems: [],
        removedItems: previousItems.slice()
      };
    }
    if (!previousItems.length) {
      return {
        addedItems: newItems.slice(),
        removedItems: []
      };
    }
    const previousItemsValuesMap = previousItems.reduce((map2, item) => {
      const value2 = this._valueGetter(item);
      map2[value2] = item;
      return map2;
    }, {});
    const addedItems = [];
    newItems.forEach((item) => {
      const value2 = this._valueGetter(item);
      if (!previousItemsValuesMap[value2]) {
        addedItems.push(item);
      }
      delete previousItemsValuesMap[value2];
    });
    return {
      addedItems,
      removedItems: Object.values(previousItemsValuesMap)
    };
  },
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "onSelectAllValueChanged":
        this._initSelectAllValueChangedAction();
        break;
      case "onMultiTagPreparing":
        this._initMultiTagPreparingAction();
        this._renderTags();
        break;
      case "hideSelectedItems":
        if (value2) {
          this._setListDataSourceFilter();
        } else {
          this._resetListDataSourceFilter();
        }
        break;
      case "useSubmitBehavior":
        this._toggleSubmitElement(value2);
        break;
      case "displayExpr":
        this.callBase(args);
        this._initTemplates();
        this._invalidate();
        break;
      case "tagTemplate":
        this._initTagTemplate();
        this._invalidate();
        break;
      case "selectAllText":
        this._setListOption("selectAllText", this.option("selectAllText"));
        break;
      case "readOnly":
      case "disabled":
        this.callBase(args);
        !value2 && this._refreshEvents();
        break;
      case "value":
        this._valuesToUpdate = value2;
        this.callBase(args);
        this._valuesToUpdate = void 0;
        this._setListDataSourceFilter();
        break;
      case "maxDisplayedTags":
      case "showMultiTagOnly":
        this._renderTags();
        break;
      case "selectAllMode":
        this._setListOption(name2, value2);
        break;
      case "selectedItem":
      case "maxFilterQueryLength":
        break;
      case "selectedItems":
        this._selectionChangedAction(this._getSelectedItemsDifference(value2, previousValue));
        break;
      case "multiline":
        this.$element().toggleClass("dx-tagbox-single-line", !value2);
        this._renderSingleLineScroll();
        break;
      default:
        this.callBase(args);
    }
  },
  _getActualSearchValue() {
    return this.callBase() || this._searchValue();
  },
  _popupHidingHandler() {
    this.callBase();
    this._clearFilter();
  }
});
component_registrator_default("dxTagBox", TagBox);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_switch.js
var Switch = editor_default.inherit({
  _supportedKeys() {
    const isRTL = this.option("rtlEnabled");
    const click = function(e) {
      e.preventDefault();
      this._clickAction({
        event: e
      });
    };
    const move2 = function(value2, e) {
      e.preventDefault();
      e.stopPropagation();
      this._saveValueChangeEvent(e);
      this._animateValue(value2);
    };
    return extend(this.callBase(), {
      space: click,
      enter: click,
      leftArrow: move2.bind(this, !!isRTL),
      rightArrow: move2.bind(this, !isRTL)
    });
  },
  _useTemplates: () => false,
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      switchedOnText: message_default.format("dxSwitch-switchedOnText"),
      switchedOffText: message_default.format("dxSwitch-switchedOffText"),
      value: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  },
  _feedbackHideTimeout: 0,
  _animating: false,
  _initMarkup() {
    this._renderContainers();
    this.$element().addClass("dx-switch").append(this._$switchWrapper);
    this._renderSubmitElement();
    this._renderClick();
    this.setAria("role", "switch");
    this._renderSwipeable();
    this.callBase();
    this._renderSwitchInner();
    this._renderLabels();
    this._renderValue();
  },
  _getInnerOffset(value2, offset) {
    const ratio = (offset - this._offsetDirection() * Number(!value2)) / 2;
    return 100 * ratio + "%";
  },
  _getHandleOffset(value2, offset) {
    if (this.option("rtlEnabled")) {
      value2 = !value2;
    }
    if (value2) {
      const calcValue = 100 * -offset - 100;
      return `${calcValue}%`;
    }
    return 100 * -offset + "%";
  },
  _renderSwitchInner() {
    this._$switchInner = renderer_default("<div>").addClass("dx-switch-inner").appendTo(this._$switchContainer);
    this._$handle = renderer_default("<div>").addClass("dx-switch-handle").appendTo(this._$switchInner);
  },
  _renderLabels() {
    this._$labelOn = renderer_default("<div>").addClass("dx-switch-on").prependTo(this._$switchInner);
    this._$labelOff = renderer_default("<div>").addClass("dx-switch-off").appendTo(this._$switchInner);
    this._setLabelsText();
  },
  _renderContainers() {
    this._$switchContainer = renderer_default("<div>").addClass("dx-switch-container");
    this._$switchWrapper = renderer_default("<div>").addClass("dx-switch-wrapper").append(this._$switchContainer);
  },
  _renderSwipeable() {
    this._createComponent(this.$element(), swipeable_default, {
      elastic: false,
      immediate: true,
      onStart: this._swipeStartHandler.bind(this),
      onUpdated: this._swipeUpdateHandler.bind(this),
      onEnd: this._swipeEndHandler.bind(this),
      itemSizeFunc: this._getItemSizeFunc.bind(this)
    });
  },
  _getItemSizeFunc() {
    return getOuterWidth(this._$switchContainer, true) - getBoundingRect(this._$handle.get(0)).width;
  },
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
  },
  _getSubmitElement() {
    return this._$submitElement;
  },
  _offsetDirection() {
    return this.option("rtlEnabled") ? -1 : 1;
  },
  _renderPosition(state, swipeOffset) {
    const innerOffset = this._getInnerOffset(state, swipeOffset);
    const handleOffset = this._getHandleOffset(state, swipeOffset);
    this._$switchInner.css("transform", ` translateX(${innerOffset})`);
    this._$handle.css("transform", ` translateX(${handleOffset})`);
  },
  _validateValue() {
    const check = this.option("value");
    if ("boolean" !== typeof check) {
      this._options.silent("value", !!check);
    }
  },
  _renderClick() {
    const eventName = addNamespace(CLICK_EVENT_NAME, this.NAME);
    const $element = this.$element();
    this._clickAction = this._createAction(this._clickHandler.bind(this));
    events_engine_default.off($element, eventName);
    events_engine_default.on($element, eventName, (e) => {
      this._clickAction({
        event: e
      });
    });
  },
  _clickHandler(args) {
    const e = args.event;
    this._saveValueChangeEvent(e);
    if (this._animating || this._swiping) {
      return;
    }
    this._animateValue(!this.option("value"));
  },
  _animateValue(value2) {
    const startValue = this.option("value");
    const endValue = value2;
    if (startValue === endValue) {
      return;
    }
    this._animating = true;
    const fromInnerOffset = this._getInnerOffset(startValue, 0);
    const toInnerOffset = this._getInnerOffset(endValue, 0);
    const fromHandleOffset = this._getHandleOffset(startValue, 0);
    const toHandleOffset = this._getHandleOffset(endValue, 0);
    const that = this;
    const fromInnerConfig = {};
    const toInnerConfig = {};
    const fromHandleConfig = {};
    const toHandlerConfig = {};
    fromInnerConfig.transform = ` translateX(${fromInnerOffset})`;
    toInnerConfig.transform = ` translateX(${toInnerOffset})`;
    fromHandleConfig.transform = ` translateX(${fromHandleOffset})`;
    toHandlerConfig.transform = ` translateX(${toHandleOffset})`;
    this.$element().toggleClass("dx-switch-on-value", endValue);
    fx_default.animate(this._$handle, {
      from: fromHandleConfig,
      to: toHandlerConfig,
      duration: 100
    });
    fx_default.animate(this._$switchInner, {
      from: fromInnerConfig,
      to: toInnerConfig,
      duration: 100,
      complete() {
        that._animating = false;
        that.option("value", endValue);
      }
    });
  },
  _swipeStartHandler(e) {
    const state = this.option("value");
    const rtlEnabled = this.option("rtlEnabled");
    const maxOffOffset = rtlEnabled ? 0 : 1;
    const maxOnOffset = rtlEnabled ? 1 : 0;
    e.event.maxLeftOffset = state ? maxOffOffset : maxOnOffset;
    e.event.maxRightOffset = state ? maxOnOffset : maxOffOffset;
    this._swiping = true;
    this._feedbackDeferred = Deferred();
    lock(this._feedbackDeferred);
    this._toggleActiveState(this.$element(), this.option("activeStateEnabled"));
  },
  _swipeUpdateHandler(e) {
    this._renderPosition(this.option("value"), e.event.offset);
  },
  _swipeEndHandler(e) {
    const that = this;
    const offsetDirection = this._offsetDirection();
    const toInnerConfig = {};
    const toHandleConfig = {};
    const innerOffset = this._getInnerOffset(that.option("value"), e.event.targetOffset);
    const handleOffset = this._getHandleOffset(that.option("value"), e.event.targetOffset);
    toInnerConfig.transform = ` translateX(${innerOffset})`;
    toHandleConfig.transform = ` translateX(${handleOffset})`;
    fx_default.animate(this._$handle, {
      to: toHandleConfig,
      duration: 100
    });
    fx_default.animate(this._$switchInner, {
      to: toInnerConfig,
      duration: 100,
      complete() {
        that._swiping = false;
        const pos = that.option("value") + offsetDirection * e.event.targetOffset;
        that._saveValueChangeEvent(e.event);
        that.option("value", Boolean(pos));
        that._feedbackDeferred.resolve();
        that._toggleActiveState(that.$element(), false);
      }
    });
  },
  _renderValue() {
    this._validateValue();
    const value2 = this.option("value");
    this._renderPosition(value2, 0);
    this.$element().toggleClass("dx-switch-on-value", value2);
    this._getSubmitElement().val(value2);
    this.setAria({
      checked: value2,
      label: value2 ? this.option("switchedOnText") : this.option("switchedOffText")
    });
  },
  _setLabelsText() {
    this._$labelOn && this._$labelOn.text(this.option("switchedOnText"));
    this._$labelOff && this._$labelOff.text(this.option("switchedOffText"));
  },
  _visibilityChanged(visible) {
    if (visible) {
      this.repaint();
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "width":
        delete this._marginBound;
        this._refresh();
        break;
      case "switchedOnText":
      case "switchedOffText":
        this._setLabelsText();
        break;
      case "value":
        this._renderValue();
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxSwitch", Switch);

// ../../../../../../node_modules/devextreme/esm/data/data_source.js
var data_source_default = DataSource;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/semaphore/index.js
var Semaphore = class {
  constructor() {
    this.counter = 0;
  }
  isFree() {
    return 0 === this.counter;
  }
  take() {
    this.counter += 1;
  }
  release() {
    this.counter -= 1;
    if (this.counter < 0) {
      this.counter = 0;
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointment_popup/m_form.js
var APPOINTMENT_FORM_GROUP_NAMES = {
  Main: "mainGroup",
  Recurrence: "recurrenceGroup"
};
var E2E_TEST_CLASSES = {
  form: "e2e-dx-scheduler-form",
  textEditor: "e2e-dx-scheduler-form-text",
  descriptionEditor: "e2e-dx-scheduler-form-description",
  startDateEditor: "e2e-dx-scheduler-form-start-date",
  endDateEditor: "e2e-dx-scheduler-form-end-date",
  startDateTimeZoneEditor: "e2e-dx-scheduler-form-start-date-timezone",
  endDateTimeZoneEditor: "e2e-dx-scheduler-form-end-date-timezone",
  allDaySwitch: "e2e-dx-scheduler-form-all-day-switch",
  recurrenceSwitch: "e2e-dx-scheduler-form-recurrence-switch"
};
var getStylingModeFunc2 = () => isFluent(current()) ? "filled" : void 0;
var getStartDateWithStartHour = (startDate, startDayHour) => new Date(new Date(startDate).setHours(startDayHour));
var validateAppointmentFormDate = (editor, value2, previousValue) => {
  const isCurrentDateCorrect = null === value2 || !!value2;
  const isPreviousDateCorrect = null === previousValue || !!previousValue;
  if (!isCurrentDateCorrect && isPreviousDateCorrect) {
    editor.option("value", previousValue);
  }
};
var updateRecurrenceItemVisibility = (recurrenceRuleExpr, value2, form) => {
  var _form$getEditor;
  form.itemOption(APPOINTMENT_FORM_GROUP_NAMES.Recurrence, "visible", value2);
  null === (_form$getEditor = form.getEditor(recurrenceRuleExpr)) || void 0 === _form$getEditor || _form$getEditor.changeValueByVisibility(value2);
};
var AppointmentForm = class {
  constructor(scheduler) {
    this.scheduler = scheduler;
    this.form = null;
    this.semaphore = new Semaphore();
  }
  get dxForm() {
    return this.form;
  }
  set readOnly(value2) {
    this.form.option("readOnly", value2);
    const {
      recurrenceRuleExpr
    } = this.scheduler.getDataAccessors().expr;
    const recurrenceEditor = this.form.getEditor(recurrenceRuleExpr);
    null === recurrenceEditor || void 0 === recurrenceEditor || recurrenceEditor.option("readOnly", value2);
  }
  get formData() {
    return this.form.option("formData");
  }
  set formData(value2) {
    this.form.option("formData", value2);
  }
  create(triggerResize, changeSize, formData) {
    const {
      allowTimeZoneEditing
    } = this.scheduler.getEditingConfig();
    const dataAccessors = this.scheduler.getDataAccessors();
    const {
      expr
    } = dataAccessors;
    const isRecurrence = !!ExpressionUtils.getField(dataAccessors, "recurrenceRule", formData);
    const colSpan = isRecurrence ? 1 : 2;
    const mainItems = [...this._createMainItems(expr, triggerResize, changeSize, allowTimeZoneEditing), ...this.scheduler.createResourceEditorModel()];
    changeSize(isRecurrence);
    const items = [{
      itemType: "group",
      name: APPOINTMENT_FORM_GROUP_NAMES.Main,
      colCountByScreen: {
        lg: 2,
        xs: 1
      },
      colSpan,
      items: mainItems
    }, {
      itemType: "group",
      name: APPOINTMENT_FORM_GROUP_NAMES.Recurrence,
      visible: isRecurrence,
      colSpan,
      items: this._createRecurrenceEditor(expr)
    }];
    const element = renderer_default("<div>");
    this.scheduler.createComponent(element, form_default, {
      items,
      showValidationSummary: true,
      scrollingEnabled: true,
      colCount: "auto",
      colCountByScreen: {
        lg: 2,
        xs: 1
      },
      formData,
      showColonAfterLabel: false,
      labelLocation: "top",
      onInitialized: (e) => {
        this.form = e.component;
      },
      customizeItem: (e) => {
        if (this.form && "group" === e.itemType) {
          const dataExprs = this.scheduler.getDataAccessors().expr;
          const startDate = new Date(this.formData[dataExprs.startDateExpr]);
          const endDate = new Date(this.formData[dataExprs.endDateExpr]);
          const startTimeZoneEditor = e.items.find((i) => i.dataField === dataExprs.startDateTimeZoneExpr);
          const endTimeZoneEditor = e.items.find((i) => i.dataField === dataExprs.endDateTimeZoneExpr);
          if (startTimeZoneEditor) {
            startTimeZoneEditor.editorOptions.dataSource = this.createTimeZoneDataSource(startDate);
          }
          if (endTimeZoneEditor) {
            endTimeZoneEditor.editorOptions.dataSource = this.createTimeZoneDataSource(endDate);
          }
        }
      },
      screenByWidth: (width) => width < 600 || "desktop" !== devices_default.current().deviceType ? "xs" : "lg",
      elementAttr: {
        class: E2E_TEST_CLASSES.form
      }
    });
  }
  createTimeZoneDataSource(date) {
    return new data_source_default({
      store: m_utils_time_zone_default.getTimeZones(date),
      paginate: true,
      pageSize: 10
    });
  }
  _createAppointmentAdapter(rawAppointment) {
    return createAppointmentAdapter(rawAppointment, this.scheduler.getDataAccessors());
  }
  _dateBoxValueChanged(args, dateExpr, isNeedCorrect) {
    validateAppointmentFormDate(args.component, args.value, args.previousValue);
    const value2 = date_serialization_default.deserializeDate(args.value);
    const previousValue = date_serialization_default.deserializeDate(args.previousValue);
    const dateEditor = this.form.getEditor(dateExpr);
    const dateValue = date_serialization_default.deserializeDate(dateEditor.option("value"));
    if (this.semaphore.isFree() && dateValue && value2 && isNeedCorrect(dateValue, value2)) {
      const duration = previousValue ? dateValue.getTime() - previousValue.getTime() : 0;
      dateEditor.option("value", new Date(value2.getTime() + duration));
    }
  }
  _createTimezoneEditor(timeZoneExpr, secondTimeZoneExpr, visibleIndex, colSpan, isMainTimeZone, cssClass) {
    let visible = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : false;
    const noTzTitle = message_default.format("dxScheduler-noTimezoneTitle");
    return {
      name: this.normalizeEditorName(timeZoneExpr),
      dataField: timeZoneExpr,
      editorType: "dxSelectBox",
      visibleIndex,
      colSpan,
      cssClass,
      label: {
        text: " "
      },
      editorOptions: {
        displayExpr: "title",
        valueExpr: "id",
        placeholder: noTzTitle,
        searchEnabled: true,
        onValueChanged: (args) => {
          const {
            form
          } = this;
          const secondTimezoneEditor = form.getEditor(secondTimeZoneExpr);
          if (isMainTimeZone) {
            secondTimezoneEditor.option("value", args.value);
          }
        }
      },
      visible
    };
  }
  _createDateBoxItems(dataExprs, allowTimeZoneEditing) {
    const colSpan = allowTimeZoneEditing ? 2 : 1;
    const firstDayOfWeek = this.scheduler.getFirstDayOfWeek();
    return [this.createDateBoxEditor(dataExprs.startDateExpr, colSpan, firstDayOfWeek, "dxScheduler-editorLabelStartDate", E2E_TEST_CLASSES.startDateEditor, (args) => {
      this._dateBoxValueChanged(args, dataExprs.endDateExpr, (endValue, startValue) => endValue < startValue);
    }), this._createTimezoneEditor(dataExprs.startDateTimeZoneExpr, dataExprs.endDateTimeZoneExpr, 1, colSpan, true, E2E_TEST_CLASSES.startDateTimeZoneEditor, allowTimeZoneEditing), this.createDateBoxEditor(dataExprs.endDateExpr, colSpan, firstDayOfWeek, "dxScheduler-editorLabelEndDate", E2E_TEST_CLASSES.endDateEditor, (args) => {
      this._dateBoxValueChanged(args, dataExprs.startDateExpr, (startValue, endValue) => endValue < startValue);
    }), this._createTimezoneEditor(dataExprs.endDateTimeZoneExpr, dataExprs.startDateTimeZoneExpr, 3, colSpan, false, E2E_TEST_CLASSES.endDateTimeZoneEditor, allowTimeZoneEditing)];
  }
  _changeFormItemDateType(name2, groupName, isAllDay) {
    const editorPath = this.getEditorPath(name2, groupName);
    const itemEditorOptions = this.form.itemOption(editorPath).editorOptions;
    const type = isAllDay ? "date" : "datetime";
    const newEditorOption = _extends({}, itemEditorOptions, {
      type
    });
    this.form.itemOption(editorPath, "editorOptions", newEditorOption);
  }
  _createMainItems(dataExprs, triggerResize, changeSize, allowTimeZoneEditing) {
    return [{
      name: this.normalizeEditorName(dataExprs.textExpr),
      dataField: dataExprs.textExpr,
      cssClass: E2E_TEST_CLASSES.textEditor,
      editorType: "dxTextBox",
      colSpan: 2,
      label: {
        text: message_default.format("dxScheduler-editorLabelTitle")
      },
      editorOptions: {
        stylingMode: getStylingModeFunc2()
      }
    }, {
      itemType: "group",
      colSpan: 2,
      colCountByScreen: {
        lg: 2,
        xs: 1
      },
      items: this._createDateBoxItems(dataExprs, allowTimeZoneEditing)
    }, {
      itemType: "group",
      colSpan: 2,
      colCountByScreen: {
        lg: 2,
        xs: 2
      },
      items: [{
        name: this.normalizeEditorName(dataExprs.allDayExpr),
        dataField: dataExprs.allDayExpr,
        cssClass: `dx-appointment-form-switch ${E2E_TEST_CLASSES.allDaySwitch}`,
        editorType: "dxSwitch",
        label: {
          text: message_default.format("dxScheduler-allDay"),
          location: "right"
        },
        editorOptions: {
          onValueChanged: (args) => {
            const {
              value: value2
            } = args;
            const startDateEditor = this.form.getEditor(dataExprs.startDateExpr);
            const endDateEditor = this.form.getEditor(dataExprs.endDateExpr);
            const startDate = date_serialization_default.deserializeDate(startDateEditor.option("value"));
            if (this.semaphore.isFree() && startDate) {
              if (value2) {
                const allDayStartDate = date_default2.trimTime(startDate);
                startDateEditor.option("value", new Date(allDayStartDate));
                endDateEditor.option("value", new Date(allDayStartDate));
              } else {
                const startDateWithStartHour = getStartDateWithStartHour(startDate, this.scheduler.getStartDayHour());
                const endDate = this.scheduler.getCalculatedEndDate(startDateWithStartHour);
                startDateEditor.option("value", startDateWithStartHour);
                endDateEditor.option("value", endDate);
              }
            }
            this._changeFormItemDateType(dataExprs.startDateExpr, "Main", value2);
            this._changeFormItemDateType(dataExprs.endDateExpr, "Main", value2);
          }
        }
      }, {
        editorType: "dxSwitch",
        dataField: "repeat",
        cssClass: `dx-appointment-form-switch ${E2E_TEST_CLASSES.recurrenceSwitch}`,
        name: "visibilityChanged",
        label: {
          text: message_default.format("dxScheduler-editorLabelRecurrence"),
          location: "right"
        },
        editorOptions: {
          onValueChanged: (args) => {
            const {
              form
            } = this;
            const colSpan = args.value ? 1 : 2;
            form.itemOption(APPOINTMENT_FORM_GROUP_NAMES.Main, "colSpan", colSpan);
            form.itemOption(APPOINTMENT_FORM_GROUP_NAMES.Recurrence, "colSpan", colSpan);
            updateRecurrenceItemVisibility(dataExprs.recurrenceRuleExpr, args.value, form);
            changeSize(args.value);
            triggerResize();
          }
        }
      }]
    }, {
      itemType: "empty",
      colSpan: 2
    }, {
      name: this.normalizeEditorName(dataExprs.descriptionExpr),
      dataField: dataExprs.descriptionExpr,
      cssClass: E2E_TEST_CLASSES.descriptionEditor,
      editorType: "dxTextArea",
      colSpan: 2,
      label: {
        text: message_default.format("dxScheduler-editorLabelDescription")
      },
      editorOptions: {
        stylingMode: getStylingModeFunc2()
      }
    }, {
      itemType: "empty",
      colSpan: 2
    }];
  }
  _createRecurrenceEditor(dataExprs) {
    return [{
      name: this.normalizeEditorName(dataExprs.recurrenceRuleExpr),
      dataField: dataExprs.recurrenceRuleExpr,
      editorType: "dxRecurrenceEditor",
      editorOptions: {
        firstDayOfWeek: this.scheduler.getFirstDayOfWeek(),
        timeZoneCalculator: this.scheduler.getTimeZoneCalculator(),
        getStartDateTimeZone: () => this._createAppointmentAdapter(this.formData).startDateTimeZone
      },
      label: {
        text: " ",
        visible: false
      }
    }];
  }
  setEditorsType(allDay) {
    const {
      startDateExpr,
      endDateExpr
    } = this.scheduler.getDataAccessors().expr;
    const startDateItemPath = this.getEditorPath(startDateExpr, "Main");
    const endDateItemPath = this.getEditorPath(endDateExpr, "Main");
    const startDateFormItem = this.form.itemOption(startDateItemPath);
    const endDateFormItem = this.form.itemOption(endDateItemPath);
    if (startDateFormItem && endDateFormItem) {
      const startDateEditorOptions = startDateFormItem.editorOptions;
      const endDateEditorOptions = endDateFormItem.editorOptions;
      startDateEditorOptions.type = endDateEditorOptions.type = allDay ? "date" : "datetime";
      this.form.itemOption(startDateItemPath, "editorOptions", startDateEditorOptions);
      this.form.itemOption(endDateItemPath, "editorOptions", endDateEditorOptions);
    }
  }
  updateRecurrenceEditorStartDate(date, expression) {
    const options = {
      startDate: date
    };
    this.setEditorOptions(expression, "Recurrence", options);
  }
  setEditorOptions(name2, groupName, options) {
    const editorPath = this.getEditorPath(name2, groupName);
    const editor = this.form.itemOption(editorPath);
    editor && this.form.itemOption(editorPath, "editorOptions", extend({}, editor.editorOptions, options));
  }
  setTimeZoneEditorDataSource(date, name2) {
    const dataSource = this.createTimeZoneDataSource(date);
    this.setEditorOptions(name2, "Main", {
      dataSource
    });
  }
  updateFormData(formData) {
    this.semaphore.take();
    this.form.option("formData", formData);
    const dataAccessors = this.scheduler.getDataAccessors();
    const {
      expr
    } = dataAccessors;
    const rawStartDate = ExpressionUtils.getField(dataAccessors, "startDate", formData);
    const rawEndDate = ExpressionUtils.getField(dataAccessors, "endDate", formData);
    const allDay = ExpressionUtils.getField(dataAccessors, "allDay", formData);
    const startDate = new Date(rawStartDate);
    const endDate = new Date(rawEndDate);
    this.setTimeZoneEditorDataSource(startDate, expr.startDateTimeZoneExpr);
    this.setTimeZoneEditorDataSource(endDate, expr.endDateTimeZoneExpr);
    this.updateRecurrenceEditorStartDate(startDate, expr.recurrenceRuleExpr);
    this.setEditorsType(allDay);
    this.semaphore.release();
  }
  createDateBoxEditor(dataField, colSpan, firstDayOfWeek, label, cssClass, onValueChanged) {
    return {
      editorType: "dxDateBox",
      name: this.normalizeEditorName(dataField),
      dataField,
      colSpan,
      cssClass,
      label: {
        text: message_default.format(label)
      },
      validationRules: [{
        type: "required"
      }],
      editorOptions: {
        stylingMode: getStylingModeFunc2(),
        width: "100%",
        calendarOptions: {
          firstDayOfWeek
        },
        onValueChanged,
        useMaskBehavior: true
      }
    };
  }
  getEditorPath(name2, groupName) {
    const normalizedName = this.normalizeEditorName(name2);
    return `${APPOINTMENT_FORM_GROUP_NAMES[groupName]}.${normalizedName}`;
  }
  normalizeEditorName(name2) {
    return name2 ? name2.replace(/\./g, "_") : name2;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/appointment_popup/config.js
var POPUP_WIDTH = {
  DEFAULT: 485,
  RECURRENCE: 970,
  FULLSCREEN: 1e3,
  MOBILE: {
    DEFAULT: 350,
    FULLSCREEN: 500
  }
};
var isMobile = () => "desktop" !== devices_default.current().deviceType;
var isIOSPlatform = () => "ios" === devices_default.current().platform;
var TOOLBAR_LOCATION = {
  AFTER: "after",
  BEFORE: "before"
};
var getButtonsConfig = () => ({
  doneButton: {
    shortcut: "done",
    options: {
      text: message_default.format("Done")
    },
    location: TOOLBAR_LOCATION.AFTER
  },
  cancelButton: {
    shortcut: "cancel",
    location: isIOSPlatform() ? TOOLBAR_LOCATION.BEFORE : TOOLBAR_LOCATION.AFTER
  }
});
var getPopupToolbarItems = (allowUpdating, doneClick) => {
  const result = [];
  const buttonsConfig = getButtonsConfig();
  if (allowUpdating) {
    result.push(_extends({}, buttonsConfig.doneButton, {
      onClick: doneClick
    }));
  }
  result.push(buttonsConfig.cancelButton);
  return result;
};
var isPopupFullScreenNeeded = () => {
  const window3 = getWindow();
  const width = window3 && getWidth(window3);
  if (width) {
    return isMobile() ? width < POPUP_WIDTH.MOBILE.FULLSCREEN : width < POPUP_WIDTH.FULLSCREEN;
  }
  return false;
};
var getMaxWidth = (isRecurrence) => {
  if (isMobile()) {
    return POPUP_WIDTH.MOBILE.DEFAULT;
  }
  return isRecurrence ? POPUP_WIDTH.RECURRENCE : POPUP_WIDTH.DEFAULT;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_loading.js
var loading = null;
var createLoadPanel = function(options) {
  return new load_panel_default(renderer_default("<div>").appendTo(options && options.container || value()), options);
};
var removeLoadPanel = function() {
  if (!loading) {
    return;
  }
  loading.$element().remove();
  loading = null;
};
function show(options) {
  removeLoadPanel();
  loading = createLoadPanel(options);
  return loading.show();
}
function hide() {
  if (!loading) {
    return new Deferred().resolve();
  }
  return loading.hide().done(removeLoadPanel).promise();
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/resources/m_utils.js
var getValueExpr = (resource) => resource.valueExpr || "id";
var getDisplayExpr = (resource) => resource.displayExpr || "text";
var getFieldExpr = (resource) => resource.fieldExpr || resource.field;
var getWrappedDataSource = (dataSource) => {
  if (dataSource instanceof DataSource) {
    return dataSource;
  }
  const result = _extends({}, normalizeDataSourceOptions(dataSource), {
    pageSize: 0
  });
  if (!Array.isArray(dataSource)) {
    result.filter = dataSource.filter;
  }
  return new DataSource(result);
};
var createResourcesTree = (groups) => {
  let leafIndex = 0;
  const make = (group, groupIndex, result, parent) => {
    result = result || [];
    for (let itemIndex = 0; itemIndex < group.items.length; itemIndex++) {
      var _group$data;
      const currentGroupItem = group.items[itemIndex];
      const resultItem = {
        name: group.name,
        value: currentGroupItem.id,
        title: currentGroupItem.text,
        data: null === (_group$data = group.data) || void 0 === _group$data ? void 0 : _group$data[itemIndex],
        children: [],
        parent: parent || null
      };
      const nextGroupIndex = groupIndex + 1;
      if (groups[nextGroupIndex]) {
        make(groups[nextGroupIndex], nextGroupIndex, resultItem.children, resultItem);
      }
      if (!resultItem.children.length) {
        resultItem.leafIndex = leafIndex;
        leafIndex++;
      }
      result.push(resultItem);
    }
    return result;
  };
  return make(groups[0], 0);
};
var getPathToLeaf = (leafIndex, groups) => {
  const tree = createResourcesTree(groups);
  const findLeafByIndex = (data2, index) => {
    for (let i = 0; i < data2.length; i++) {
      if (data2[i].leafIndex === index) {
        return data2[i];
      }
      const leaf2 = findLeafByIndex(data2[i].children, index);
      if (leaf2) {
        return leaf2;
      }
    }
  };
  const makeBranch = (leaf2, result) => {
    result = result || [];
    result.push(leaf2.value);
    if (leaf2.parent) {
      makeBranch(leaf2.parent, result);
    }
    return result;
  };
  const leaf = findLeafByIndex(tree, leafIndex);
  return makeBranch(leaf).reverse();
};
var getCellGroups = (groupIndex, groups) => {
  const result = [];
  if (getGroupCount(groups)) {
    if (groupIndex < 0) {
      return;
    }
    const path = getPathToLeaf(groupIndex, groups);
    for (let i = 0; i < groups.length; i++) {
      result.push({
        name: groups[i].name,
        id: path[i]
      });
    }
  }
  return result;
};
var getGroupsObjectFromGroupsArray = (groupsArray) => groupsArray.reduce((currentGroups, _ref) => {
  let {
    name: name2,
    id
  } = _ref;
  return _extends({}, currentGroups, {
    [name2]: id
  });
}, {});
var getAllGroups = (groups) => {
  const groupCount = getGroupCount(groups);
  return [...new Array(groupCount)].map((_, groupIndex) => {
    const groupsArray = getCellGroups(groupIndex, groups);
    return getGroupsObjectFromGroupsArray(groupsArray);
  });
};
var getResourceByField = (fieldName, loadedResources) => {
  for (let i = 0; i < loadedResources.length; i++) {
    const resource = loadedResources[i];
    if (resource.name === fieldName) {
      return resource.data;
    }
  }
  return [];
};
var createResourceEditorModel = (resources, loadedResources) => resources.map((resource) => {
  const dataField = getFieldExpr(resource);
  const dataSource = getResourceByField(dataField, loadedResources);
  return {
    editorOptions: {
      dataSource: dataSource.length ? dataSource : getWrappedDataSource(resource.dataSource),
      displayExpr: getDisplayExpr(resource),
      valueExpr: getValueExpr(resource),
      stylingMode: isFluent(current()) ? "filled" : "outlined"
    },
    dataField,
    editorType: resource.allowMultiple ? "dxTagBox" : "dxSelectBox",
    label: {
      text: resource.label || dataField
    }
  };
});
var isResourceMultiple = (resources, resourceField) => {
  const resource = resources.find((resource2) => {
    const field = getFieldExpr(resource2);
    return field === resourceField;
  });
  return !!(null !== resource && void 0 !== resource && resource.allowMultiple);
};
var filterResources = (resources, fields) => resources.filter((resource) => {
  const field = getFieldExpr(resource);
  return fields.indexOf(field) > -1;
});
var getPaintedResources = (resources, groups) => {
  const newGroups = groups || [];
  const result = resources.find((resource) => resource.useColorAsDefault);
  if (result) {
    return result;
  }
  const newResources = newGroups.length ? filterResources(resources, newGroups) : resources;
  return newResources[newResources.length - 1];
};
var getOrLoadResourceItem = (resources, resourceLoaderMap, field, value2) => {
  const result = new Deferred();
  resources.filter((resource) => getFieldExpr(resource) === field && isDefined(resource.dataSource)).forEach((resource) => {
    const wrappedDataSource = getWrappedDataSource(resource.dataSource);
    const valueExpr = getValueExpr(resource);
    if (!resourceLoaderMap.has(field)) {
      resourceLoaderMap.set(field, wrappedDataSource.load());
    }
    resourceLoaderMap.get(field).done((data2) => {
      const getter = compileGetter(valueExpr);
      const filteredData = data2.filter((resource2) => equalByValue(getter(resource2), value2));
      result.resolve(filteredData[0]);
    }).fail(() => {
      resourceLoaderMap.delete(field);
      result.reject();
    });
  });
  return result.promise();
};
var getDataAccessors = (dataAccessors, fieldName, type) => {
  const actions = dataAccessors[type];
  return actions[fieldName];
};
var groupAppointmentsByResources = function(config, appointments) {
  let groups = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
  let result = {
    0: appointments
  };
  if (groups.length && config.loadedResources.length) {
    result = groupAppointmentsByResourcesCore(config, appointments, config.loadedResources);
  }
  let totalResourceCount = 0;
  config.loadedResources.forEach((resource, index) => {
    if (!index) {
      totalResourceCount = resource.items.length;
    } else {
      totalResourceCount *= resource.items.length;
    }
  });
  for (let index = 0; index < totalResourceCount; index++) {
    const key = index.toString();
    if (result[key]) {
      continue;
    }
    result[key] = [];
  }
  return result;
};
var groupAppointmentsByResourcesCore = (config, appointments, resources) => {
  const tree = createResourcesTree(resources);
  const result = {};
  appointments.forEach((appointment) => {
    const treeLeaves = getResourceTreeLeaves((field, action) => getDataAccessors(config.dataAccessors, field, action), tree, appointment);
    for (let i = 0; i < treeLeaves.length; i++) {
      if (!result[treeLeaves[i]]) {
        result[treeLeaves[i]] = [];
      }
      result[treeLeaves[i]].push(deepExtendArraySafe({}, appointment, true));
    }
  });
  return result;
};
var getResourceTreeLeaves = (getDataAccessors2, tree, rawAppointment, result) => {
  result = result || [];
  for (let i = 0; i < tree.length; i++) {
    if (!hasGroupItem(getDataAccessors2, rawAppointment, tree[i].name, tree[i].value)) {
      continue;
    }
    if (isDefined(tree[i].leafIndex)) {
      result.push(tree[i].leafIndex);
    }
    if (tree[i].children) {
      getResourceTreeLeaves(getDataAccessors2, tree[i].children, rawAppointment, result);
    }
  }
  return result;
};
var hasGroupItem = (getDataAccessors2, rawAppointment, groupName, itemValue) => {
  const resourceValue = getDataAccessors2(groupName, "getter")(rawAppointment);
  return hasResourceValue(wrapToArray(resourceValue), itemValue);
};
var createReducedResourcesTree = (loadedResources, getDataAccessors2, appointments) => {
  const tree = createResourcesTree(loadedResources);
  return reduceResourcesTree(getDataAccessors2, tree, appointments);
};
var reduceResourcesTree = (getDataAccessors2, tree, existingAppointments, _result) => {
  _result = _result ? _result.children : [];
  tree.forEach((node, index) => {
    let ok = false;
    const resourceName = node.name;
    const resourceValue = node.value;
    const resourceTitle = node.title;
    const resourceData = node.data;
    const resourceGetter = getDataAccessors2(resourceName, "getter");
    existingAppointments.forEach((appointment) => {
      if (!ok) {
        const resourceFromAppointment = resourceGetter(appointment);
        if (Array.isArray(resourceFromAppointment)) {
          if (resourceFromAppointment.includes(resourceValue)) {
            _result.push({
              name: resourceName,
              value: resourceValue,
              title: resourceTitle,
              data: resourceData,
              children: []
            });
            ok = true;
          }
        } else if (resourceFromAppointment === resourceValue) {
          _result.push({
            name: resourceName,
            value: resourceValue,
            title: resourceTitle,
            data: resourceData,
            children: []
          });
          ok = true;
        }
      }
    });
    if (ok && node.children && node.children.length) {
      reduceResourcesTree(getDataAccessors2, node.children, existingAppointments, _result[index]);
    }
  });
  return _result;
};
var getResourcesDataByGroups = (loadedResources, resources, groups) => {
  if (!groups || !groups.length) {
    return loadedResources;
  }
  const fieldNames = {};
  const currentResourcesData = [];
  groups.forEach((group) => {
    each(group, (name2, value2) => {
      fieldNames[name2] = value2;
    });
  });
  const resourceData = loadedResources.filter((_ref2) => {
    let {
      name: name2
    } = _ref2;
    return isDefined(fieldNames[name2]);
  });
  resourceData.forEach((data2) => currentResourcesData.push(extend({}, data2)));
  currentResourcesData.forEach((currentResource) => {
    const {
      items,
      data: data2,
      name: resourceName
    } = currentResource;
    const resource = filterResources(resources, [resourceName])[0] || {};
    const valueExpr = getValueExpr(resource);
    const filteredItems = [];
    const filteredData = [];
    groups.filter((group) => isDefined(group[resourceName])).forEach((group) => {
      each(group, (name2, value2) => {
        if (!filteredItems.filter((item) => item.id === value2 && item[valueExpr] === name2).length) {
          const currentItems = items.filter((item) => item.id === value2);
          const currentData = data2.filter((item) => item[valueExpr] === value2);
          filteredItems.push(...currentItems);
          filteredData.push(...currentData);
        }
      });
    });
    currentResource.items = filteredItems;
    currentResource.data = filteredData;
  });
  return currentResourcesData;
};
var setResourceToAppointment = (resources, dataAccessors, appointment, groups) => {
  const resourcesSetter = dataAccessors.setter;
  for (const name2 in groups) {
    const resourceData = groups[name2];
    const value2 = isResourceMultiple(resources, name2) ? wrapToArray(resourceData) : resourceData;
    resourcesSetter[name2](appointment, value2);
  }
};
var getResourceColor = (resources, resourceLoaderMap, field, value2) => {
  const result = new Deferred();
  const resource = filterResources(resources, [field])[0] || {};
  const colorExpr = resource.colorExpr || "color";
  const colorGetter = compileGetter(colorExpr);
  getOrLoadResourceItem(resources, resourceLoaderMap, field, value2).done((resource2) => result.resolve(colorGetter(resource2))).fail(() => result.reject());
  return result.promise();
};
var getAppointmentColor = (resourceConfig, appointmentConfig) => {
  const {
    resources,
    dataAccessors,
    loadedResources,
    resourceLoaderMap
  } = resourceConfig;
  const {
    groupIndex,
    groups,
    itemData
  } = appointmentConfig;
  const paintedResources = getPaintedResources(resources || [], groups);
  if (paintedResources) {
    const field = getFieldExpr(paintedResources);
    const cellGroups = getCellGroups(groupIndex, loadedResources);
    const resourcesDataAccessors = getDataAccessors(dataAccessors, field, "getter");
    const resourceValues = wrapToArray(resourcesDataAccessors(itemData));
    let groupId = resourceValues[0];
    for (let i = 0; i < cellGroups.length; i++) {
      if (cellGroups[i].name === field) {
        groupId = cellGroups[i].id;
        break;
      }
    }
    return getResourceColor(resources, resourceLoaderMap, field, groupId);
  }
  return new Deferred().resolve().promise();
};
var createExpressions = function() {
  let resources = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  const result = {
    getter: {},
    setter: {}
  };
  resources.forEach((resource) => {
    const field = getFieldExpr(resource);
    result.getter[field] = compileGetter(field);
    result.setter[field] = compileSetter(field);
  });
  return result;
};
var getTransformedResourceData = (resource, data2) => {
  const valueGetter = compileGetter(getValueExpr(resource));
  const displayGetter = compileGetter(getDisplayExpr(resource));
  return data2.map((item) => {
    const result = {
      id: valueGetter(item),
      text: displayGetter(item)
    };
    if (item.color) {
      result.color = item.color;
    }
    return result;
  });
};
var loadResources = (groups, resources, resourceLoaderMap) => {
  const result = new Deferred();
  const deferreds = [];
  const newGroups = groups || [];
  const newResources = resources || [];
  let loadedResources = [];
  filterResources(newResources, newGroups).forEach((resource) => {
    const deferred = new Deferred();
    const name2 = getFieldExpr(resource);
    deferreds.push(deferred);
    const dataSourcePromise = getWrappedDataSource(resource.dataSource).load();
    resourceLoaderMap.set(name2, dataSourcePromise);
    dataSourcePromise.done((data2) => {
      const items = getTransformedResourceData(resource, data2);
      deferred.resolve({
        name: name2,
        items,
        data: data2
      });
    }).fail(() => deferred.reject());
  });
  if (!deferreds.length) {
    return result.resolve(loadedResources);
  }
  when.apply(null, deferreds).done(function() {
    for (var _len = arguments.length, resources2 = new Array(_len), _key = 0; _key < _len; _key++) {
      resources2[_key] = arguments[_key];
    }
    const hasEmpty = resources2.some((r) => 0 === r.items.length);
    loadedResources = hasEmpty ? [] : resources2;
    result.resolve(loadedResources);
  }).fail(() => result.reject());
  return result.promise();
};
var getNormalizedResources = (rawAppointment, dataAccessors, resources) => {
  const result = {};
  each(dataAccessors.resources.getter, (fieldName) => {
    const value2 = dataAccessors.resources.getter[fieldName](rawAppointment);
    if (isDefined(value2)) {
      const isMultiple = isResourceMultiple(resources, fieldName);
      const resourceValue = isMultiple ? wrapToArray(value2) : value2;
      result[fieldName] = resourceValue;
    }
  });
  return result;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointment_popup/m_popup.js
var toMs7 = date_default2.dateToMilliseconds;
var APPOINTMENT_POPUP_CLASS = "dx-scheduler-appointment-popup";
var DAY_IN_MS = toMs7("day");
var POPUP_CONFIG = {
  height: "auto",
  maxHeight: "100%",
  showCloseButton: false,
  showTitle: false,
  preventScrollEvents: false,
  enableBodyScroll: false,
  defaultOptionsRules: [{
    device: () => devices_default.current().android,
    options: {
      showTitle: false
    }
  }],
  _ignorePreventScrollEventsDeprecation: true
};
var ACTION_TO_APPOINTMENT = {
  CREATE: 0,
  UPDATE: 1,
  EXCLUDE_FROM_SERIES: 2
};
var AppointmentPopup = class {
  constructor(scheduler, form) {
    this.scheduler = scheduler;
    this.form = form;
    this.popup = null;
    this.state = {
      action: null,
      lastEditData: null,
      saveChangesLocker: false,
      appointment: {
        data: null
      }
    };
  }
  get visible() {
    return this.popup ? this.popup.option("visible") : false;
  }
  show(appointment, config) {
    this.state.appointment.data = appointment;
    this.state.action = config.action;
    this.state.excludeInfo = config.excludeInfo;
    if (!this.popup) {
      const popupConfig = this._createPopupConfig();
      this.popup = this._createPopup(popupConfig);
    }
    this.popup.option("toolbarItems", getPopupToolbarItems(config.isToolbarVisible, (e) => this._doneButtonClickHandler(e)));
    this.popup.show();
  }
  hide() {
    this.popup.hide();
  }
  dispose() {
    var _this$popup;
    null === (_this$popup = this.popup) || void 0 === _this$popup || _this$popup.$element().remove();
  }
  _createPopup(options) {
    const popupElement = renderer_default("<div>").addClass(APPOINTMENT_POPUP_CLASS).appendTo(this.scheduler.getElement());
    return this.scheduler.createComponent(popupElement, ui_popup_default, options);
  }
  _createPopupConfig() {
    return _extends({}, POPUP_CONFIG, {
      onHiding: () => this.scheduler.focus(),
      contentTemplate: () => this._createPopupContent(),
      onShowing: (e) => this._onShowing(e),
      wrapperAttr: {
        class: APPOINTMENT_POPUP_CLASS
      }
    });
  }
  _onShowing(e) {
    this._updateForm();
    const arg = {
      form: this.form.dxForm,
      popup: this.popup,
      appointmentData: this.state.appointment.data,
      cancel: false
    };
    this.scheduler.getAppointmentFormOpening()(arg);
    this.scheduler.processActionResult(arg, (canceled) => {
      if (canceled) {
        e.cancel = true;
      } else {
        this.updatePopupFullScreenMode();
      }
    });
  }
  _createPopupContent() {
    this._createForm();
    return this.form.dxForm.$element();
  }
  _createFormData(rawAppointment) {
    const appointment = this._createAppointmentAdapter(rawAppointment);
    const dataAccessors = this.scheduler.getDataAccessors();
    const resources = this.scheduler.getResources();
    const normalizedResources = getNormalizedResources(rawAppointment, dataAccessors, resources);
    return _extends({}, rawAppointment, normalizedResources, {
      repeat: !!appointment.recurrenceRule
    });
  }
  _createForm() {
    const rawAppointment = this.state.appointment.data;
    const formData = this._createFormData(rawAppointment);
    this.form.create(this.triggerResize.bind(this), this.changeSize.bind(this), formData);
  }
  _isReadOnly(rawAppointment) {
    const appointment = this._createAppointmentAdapter(rawAppointment);
    if (rawAppointment && appointment.disabled) {
      return true;
    }
    if (this.state.action === ACTION_TO_APPOINTMENT.CREATE) {
      return false;
    }
    return !this.scheduler.getEditingConfig().allowUpdating;
  }
  _createAppointmentAdapter(rawAppointment) {
    return createAppointmentAdapter(rawAppointment, this.scheduler.getDataAccessors(), this.scheduler.getTimeZoneCalculator());
  }
  _updateForm() {
    const {
      data: data2
    } = this.state.appointment;
    const appointment = this._createAppointmentAdapter(this._createFormData(data2));
    if (appointment.startDate) {
      appointment.startDate = appointment.calculateStartDate("toAppointment");
    }
    if (appointment.endDate) {
      appointment.endDate = appointment.calculateEndDate("toAppointment");
    }
    const formData = appointment.clone().source();
    this.form.readOnly = this._isReadOnly(formData);
    this.form.updateFormData(formData);
  }
  triggerResize() {
    if (this.popup) {
      triggerResizeEvent(this.popup.$element());
    }
  }
  changeSize(isRecurrence) {
    if (this.popup) {
      const isFullScreen = isPopupFullScreenNeeded();
      const maxWidth = isFullScreen ? "100%" : getMaxWidth(isRecurrence);
      this.popup.option("fullScreen", isFullScreen);
      this.popup.option("maxWidth", maxWidth);
    }
  }
  updatePopupFullScreenMode() {
    if (this.form.dxForm && this.visible) {
      const {
        formData
      } = this.form;
      const dataAccessors = this.scheduler.getDataAccessors();
      const isRecurrence = ExpressionUtils.getField(dataAccessors, "recurrenceRule", formData);
      this.changeSize(isRecurrence);
    }
  }
  saveChangesAsync(isShowLoadPanel) {
    const deferred = new Deferred();
    const validation = this.form.dxForm.validate();
    isShowLoadPanel && this._showLoadPanel();
    when(validation && validation.complete || validation).done((validation2) => {
      if (validation2 && !validation2.isValid) {
        hide();
        deferred.resolve(false);
        return;
      }
      const {
        repeat: repeat2
      } = this.form.formData;
      const adapter = this._createAppointmentAdapter(this.form.formData);
      const clonedAdapter = adapter.clone({
        pathTimeZone: "fromAppointment"
      });
      const shouldClearRecurrenceRule = !repeat2 && !!clonedAdapter.recurrenceRule;
      this._addMissingDSTTime(adapter, clonedAdapter);
      if (shouldClearRecurrenceRule) {
        clonedAdapter.recurrenceRule = "";
      }
      const appointment = clonedAdapter.source();
      delete appointment.repeat;
      switch (this.state.action) {
        case ACTION_TO_APPOINTMENT.CREATE:
          this.scheduler.addAppointment(appointment).done(deferred.resolve);
          break;
        case ACTION_TO_APPOINTMENT.UPDATE:
          this.scheduler.updateAppointment(this.state.appointment.data, appointment).done(deferred.resolve);
          break;
        case ACTION_TO_APPOINTMENT.EXCLUDE_FROM_SERIES:
          this.scheduler.updateAppointment(this.state.excludeInfo.sourceAppointment, this.state.excludeInfo.updatedAppointment);
          this.scheduler.addAppointment(appointment).done(deferred.resolve);
      }
      deferred.done(() => {
        hide();
        this.state.lastEditData = appointment;
      });
    });
    return deferred.promise();
  }
  _doneButtonClickHandler(e) {
    e.cancel = true;
    this.saveEditDataAsync();
  }
  saveEditDataAsync() {
    const deferred = new Deferred();
    if (this._tryLockSaveChanges()) {
      when(this.saveChangesAsync(true)).done(() => {
        if (this.state.lastEditData) {
          const adapter = this._createAppointmentAdapter(this.state.lastEditData);
          const {
            startDate,
            endDate,
            allDay
          } = adapter;
          const startTime = startDate.getTime();
          const endTime = endDate.getTime();
          const inAllDayRow = allDay || endTime - startTime >= DAY_IN_MS;
          const dataAccessors = this.scheduler.getDataAccessors();
          const resourceList = this.scheduler.getResources();
          const normalizedResources = getNormalizedResources(this.state.lastEditData, dataAccessors, resourceList);
          this.scheduler.updateScrollPosition(startDate, normalizedResources, inAllDayRow);
          this.state.lastEditData = null;
        }
        this._unlockSaveChanges();
        deferred.resolve();
      });
    }
    return deferred.promise();
  }
  _showLoadPanel() {
    const container = this.popup.$overlayContent();
    show({
      container,
      position: {
        of: container
      }
    });
  }
  _tryLockSaveChanges() {
    if (false === this.state.saveChangesLocker) {
      this.state.saveChangesLocker = true;
      return true;
    }
    return false;
  }
  _unlockSaveChanges() {
    this.state.saveChangesLocker = false;
  }
  _addMissingDSTTime(formAppointmentAdapter, clonedAppointmentAdapter) {
    const timeZoneCalculator = this.scheduler.getTimeZoneCalculator();
    clonedAppointmentAdapter.startDate = this._addMissingDSTShiftToDate(timeZoneCalculator, formAppointmentAdapter.startDate, clonedAppointmentAdapter.startDate);
    if (clonedAppointmentAdapter.endDate) {
      clonedAppointmentAdapter.endDate = this._addMissingDSTShiftToDate(timeZoneCalculator, formAppointmentAdapter.endDate, clonedAppointmentAdapter.endDate);
    }
  }
  _addMissingDSTShiftToDate(timeZoneCalculator, originFormDate, clonedDate) {
    var _timeZoneCalculator$g, _timeZoneCalculator$g2;
    const originTimezoneShift = null === (_timeZoneCalculator$g = timeZoneCalculator.getOffsets(originFormDate)) || void 0 === _timeZoneCalculator$g ? void 0 : _timeZoneCalculator$g.common;
    const clonedTimezoneShift = null === (_timeZoneCalculator$g2 = timeZoneCalculator.getOffsets(clonedDate)) || void 0 === _timeZoneCalculator$g2 ? void 0 : _timeZoneCalculator$g2.common;
    const shiftDifference = originTimezoneShift - clonedTimezoneShift;
    return shiftDifference ? new Date(clonedDate.getTime() + shiftDifference * toMs7("hour")) : clonedDate;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/filterting/remote.js
var FilterPosition = {
  dateFilter: 0,
  userFilter: 1
};
var RemoteFilterCombiner = class {
  constructor(options) {
    this.options = options;
  }
  get dataAccessors() {
    return this.options.dataAccessors;
  }
  get dataSourceFilter() {
    return this.options.dataSourceFilter;
  }
  get dateSerializationFormat() {
    return this.options.dateSerializationFormat;
  }
  get forceIsoDateParsing() {
    return isDefined(this.options.forceIsoDateParsing) ? this.options.forceIsoDateParsing : true;
  }
  makeDateFilter(min, max) {
    const {
      startDateExpr,
      endDateExpr,
      recurrenceRuleExpr
    } = this.dataAccessors.expr;
    const dateFilter = [
      [
        [endDateExpr, ">=", min],
        [startDateExpr, "<", max]
      ],
      "or",
      [recurrenceRuleExpr, "startswith", "freq"],
      "or",
      [
        [endDateExpr, min],
        [startDateExpr, min]
      ]
    ];
    if (!recurrenceRuleExpr) {
      dateFilter.splice(1, 2);
    }
    return dateFilter;
  }
  combineFilters(dateFilter, userFilter) {
    const combinedFilter = [];
    if (dateFilter) {
      combinedFilter.push(dateFilter);
    }
    if (userFilter) {
      combinedFilter.push(userFilter);
    }
    return this.serializeRemoteFilter(combinedFilter);
  }
  serializeRemoteFilter(combinedFilter) {
    if (!Array.isArray(combinedFilter)) {
      return combinedFilter;
    }
    const {
      startDateExpr,
      endDateExpr
    } = this.dataAccessors.expr;
    const filter = extend([], combinedFilter);
    if (isString(filter[0])) {
      if (this.forceIsoDateParsing && filter.length > 1) {
        if (filter[0] === startDateExpr || filter[0] === endDateExpr) {
          const lastFilterValue = filter[filter.length - 1];
          filter[filter.length - 1] = date_serialization_default.serializeDate(new Date(lastFilterValue), this.dateSerializationFormat);
        }
      }
    }
    for (let i = 0; i < filter.length; i += 1) {
      filter[i] = this.serializeRemoteFilter(filter[i]);
    }
    return filter;
  }
  getUserFilter(dateFilter) {
    if (!this.dataSourceFilter || equalByValue(this.dataSourceFilter, dateFilter)) {
      return;
    }
    const containsDateFilter = this.dataSourceFilter.length > 0 && equalByValue(this.dataSourceFilter[FilterPosition.dateFilter], dateFilter);
    const userFilter = containsDateFilter ? this.dataSourceFilter[FilterPosition.userFilter] : this.dataSourceFilter;
    return userFilter;
  }
  combine(min, max) {
    const [trimMin, trimMax] = getDatesWithoutTime(min, max);
    const dateFilter = this.makeDateFilter(trimMin, trimMax);
    const userFilter = this.getUserFilter(dateFilter);
    const combinedFilter = this.combineFilters(dateFilter, userFilter);
    return combinedFilter;
  }
};
var combineRemoteFilter = (options) => new RemoteFilterCombiner(options).combine(options.min, options.max);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/data_provider/m_appointment_data_source.js
var STORE_EVENTS = {
  updating: "updating",
  push: "push"
};
var AppointmentDataSource = class {
  constructor(dataSource) {
    this.setDataSource(dataSource);
    this._updatedAppointmentKeys = [];
  }
  get keyName() {
    const store = this._dataSource.store();
    return store.key();
  }
  get isDataSourceInit() {
    return !!this._dataSource;
  }
  _getStoreKey(target) {
    const store = this._dataSource.store();
    return store.keyOf(target);
  }
  setDataSource(dataSource) {
    this._dataSource = dataSource;
    this.cleanState();
    this._initStoreChangeHandlers();
  }
  _initStoreChangeHandlers() {
    const dataSource = this._dataSource;
    const store = null === dataSource || void 0 === dataSource ? void 0 : dataSource.store();
    if (store) {
      store.on(STORE_EVENTS.updating, (key) => {
        const keyName = store.key();
        if (keyName) {
          this._updatedAppointmentKeys.push({
            key: keyName,
            value: key
          });
        } else {
          this._updatedAppointment = key;
        }
      });
      store.on(STORE_EVENTS.push, (pushItems) => {
        const items = dataSource.items();
        const keyName = store.key();
        pushItems.forEach((pushItem) => {
          const itemExists = 0 !== items.filter((item) => item[keyName] === pushItem.key).length;
          if (itemExists) {
            this._updatedAppointmentKeys.push({
              key: keyName,
              value: pushItem.key
            });
          } else {
            const {
              data: data2
            } = pushItem;
            data2 && items.push(data2);
          }
        });
        dataSource.load();
      });
    }
  }
  getUpdatedAppointment() {
    return this._updatedAppointment;
  }
  getUpdatedAppointmentKeys() {
    return this._updatedAppointmentKeys;
  }
  cleanState() {
    this._updatedAppointment = null;
    this._updatedAppointmentKeys = [];
  }
  add(rawAppointment) {
    return this._dataSource.store().insert(rawAppointment).done(() => this._dataSource.load());
  }
  update(target, data2) {
    const key = this._getStoreKey(target);
    const d = new Deferred();
    this._dataSource.store().update(key, data2).done((result) => this._dataSource.load().done(() => d.resolve(result)).fail(d.reject)).fail(d.reject);
    return d.promise();
  }
  remove(rawAppointment) {
    const key = this._getStoreKey(rawAppointment);
    return this._dataSource.store().remove(key).done(() => this._dataSource.load());
  }
  destroy() {
    var _this$_dataSource;
    const store = null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.store();
    if (store) {
      store.off(STORE_EVENTS.updating);
      store.off(STORE_EVENTS.push);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/data_provider/m_appointment_filter.js
var toMs8 = date_default2.dateToMilliseconds;
var FilterStrategies = {
  virtual: "virtual",
  standard: "standard"
};
var AppointmentFilterBaseStrategy = class {
  constructor(options) {
    this.options = options;
    this.dataAccessors = this.options.dataAccessors;
    this._init();
  }
  get strategyName() {
    return FilterStrategies.standard;
  }
  get timeZoneCalculator() {
    return this.options.timeZoneCalculator;
  }
  get viewStartDayHour() {
    return this.options.startDayHour;
  }
  get viewEndDayHour() {
    return this.options.endDayHour;
  }
  get timezone() {
    return this.options.timezone;
  }
  get firstDayOfWeek() {
    return this.options.firstDayOfWeek;
  }
  get showAllDayPanel() {
    return this.options.showAllDayPanel;
  }
  get loadedResources() {
    return this._resolveOption("loadedResources");
  }
  get supportAllDayRow() {
    return this._resolveOption("supportAllDayRow");
  }
  get viewType() {
    return this._resolveOption("viewType");
  }
  get viewDirection() {
    return this._resolveOption("viewDirection");
  }
  get dateRange() {
    return this._resolveOption("dateRange");
  }
  get groupCount() {
    return this._resolveOption("groupCount");
  }
  get viewDataProvider() {
    return this._resolveOption("viewDataProvider");
  }
  get allDayPanelMode() {
    return this._resolveOption("allDayPanelMode");
  }
  _resolveOption(name2) {
    const result = this.options[name2];
    return "function" === typeof result ? result() : result;
  }
  _init() {
    this.setDataAccessors(this.dataAccessors);
  }
  filter(preparedItems) {
    const [min, max] = this.dateRange;
    const {
      viewOffset
    } = this.options;
    const allDay = !this.showAllDayPanel && this.supportAllDayRow ? false : void 0;
    return this.filterLoadedAppointments({
      startDayHour: this.viewStartDayHour,
      endDayHour: this.viewEndDayHour,
      viewOffset,
      viewStartDayHour: this.viewStartDayHour,
      viewEndDayHour: this.viewEndDayHour,
      min,
      max,
      resources: this.loadedResources,
      allDay,
      supportMultiDayAppointments: isTimelineView(this.viewType),
      firstDayOfWeek: this.firstDayOfWeek
    }, preparedItems);
  }
  hasAllDayAppointments(filteredItems, preparedItems) {
    const adapters = filteredItems.map((item) => createAppointmentAdapter(item, this.dataAccessors, this.timeZoneCalculator));
    let result = false;
    each(adapters, (_, item) => {
      if (getAppointmentTakesAllDay(item, this.allDayPanelMode)) {
        result = true;
        return false;
      }
    });
    return result;
  }
  setDataAccessors(dataAccessors) {
    this.dataAccessors = dataAccessors;
  }
  _createAllDayAppointmentFilter() {
    return [
      [(appointment) => getAppointmentTakesAllDay(appointment, this.allDayPanelMode)]
    ];
  }
  _createCombinedFilter(filterOptions) {
    const min = new Date(filterOptions.min);
    const max = new Date(filterOptions.max);
    const {
      startDayHour,
      endDayHour,
      viewOffset,
      viewStartDayHour,
      viewEndDayHour,
      resources,
      firstDayOfWeek,
      checkIntersectViewport,
      supportMultiDayAppointments
    } = filterOptions;
    const [trimMin, trimMax] = getDatesWithoutTime(min, max);
    const useRecurrence = isDefined(this.dataAccessors.getter.recurrenceRule);
    return [
      [(appointment) => {
        const appointmentVisible = appointment.visible ?? true;
        if (!appointmentVisible) {
          return false;
        }
        const {
          allDay: isAllDay,
          hasRecurrenceRule
        } = appointment;
        const startDate = dateUtilsTs.addOffsets(appointment.startDate, [-viewOffset]);
        const endDate = dateUtilsTs.addOffsets(appointment.endDate, [-viewOffset]);
        const appointmentTakesAllDay = getAppointmentTakesAllDay(appointment, this.allDayPanelMode);
        if (!hasRecurrenceRule) {
          if (!(endDate >= trimMin && startDate < trimMax || date_default2.sameDate(endDate, trimMin) && date_default2.sameDate(startDate, trimMin))) {
            return false;
          }
        }
        const appointmentTakesSeveralDays = getAppointmentTakesSeveralDays(appointment);
        const isLongAppointment = appointmentTakesSeveralDays || appointmentTakesAllDay;
        if (null !== resources && void 0 !== resources && resources.length && !this._filterAppointmentByResources(appointment.rawAppointment, resources)) {
          return false;
        }
        if (appointmentTakesAllDay && false === filterOptions.allDay) {
          return false;
        }
        if (hasRecurrenceRule) {
          const recurrenceException = getRecurrenceException(appointment, this.timeZoneCalculator, this.timezone);
          if (!this._filterAppointmentByRRule(_extends({}, appointment, {
            recurrenceException,
            allDay: appointmentTakesAllDay
          }), min, max, startDayHour, endDayHour, firstDayOfWeek)) {
            return false;
          }
        }
        if (!isAllDay && supportMultiDayAppointments && isLongAppointment) {
          if (endDate < min && (!useRecurrence || useRecurrence && !hasRecurrenceRule)) {
            return false;
          }
        }
        if (!isAllDay && isDefined(startDayHour) && (!useRecurrence || !filterOptions.isVirtualScrolling)) {
          if (!compareDateWithStartDayHour(startDate, endDate, startDayHour, appointmentTakesAllDay, appointmentTakesSeveralDays)) {
            return false;
          }
        }
        if (!isAllDay && isDefined(endDayHour)) {
          if (!compareDateWithEndDayHour({
            startDate,
            endDate,
            startDayHour,
            endDayHour,
            viewOffset,
            viewStartDayHour,
            viewEndDayHour,
            allDay: appointmentTakesAllDay,
            severalDays: appointmentTakesSeveralDays,
            min,
            max,
            checkIntersectViewport
          })) {
            return false;
          }
        }
        if (!isAllDay && (!isLongAppointment || supportMultiDayAppointments)) {
          if (endDate < min && useRecurrence && !hasRecurrenceRule) {
            return false;
          }
        }
        return true;
      }]
    ];
  }
  _createAppointmentFilter(filterOptions) {
    return this._createCombinedFilter(filterOptions);
  }
  _filterAppointmentByResources(appointment, resources) {
    const checkAppointmentResourceValues = (resourceName, resourceIndex) => {
      const resourceGetter = this.dataAccessors.resources.getter[resourceName];
      let resource;
      if (isFunction(resourceGetter)) {
        resource = resourceGetter(appointment);
      }
      const appointmentResourceValues = wrapToArray(resource);
      const resourceData = map(resources[resourceIndex].items, (_ref) => {
        let {
          id
        } = _ref;
        return id;
      });
      for (let i = 0; i < appointmentResourceValues.length; i++) {
        if (hasResourceValue(resourceData, appointmentResourceValues[i])) {
          return true;
        }
      }
      return false;
    };
    let result = false;
    for (let i = 0; i < resources.length; i++) {
      const resourceName = resources[i].name;
      result = checkAppointmentResourceValues(resourceName, i);
      if (!result) {
        return false;
      }
    }
    return result;
  }
  _filterAppointmentByRRule(appointment, min, max, startDayHour, endDayHour, firstDayOfWeek) {
    const {
      recurrenceRule
    } = appointment;
    const {
      recurrenceException
    } = appointment;
    const {
      allDay
    } = appointment;
    let result = true;
    const appointmentStartDate = appointment.startDate;
    const appointmentEndDate = appointment.endDate;
    const recurrenceProcessor = getRecurrenceProcessor();
    if (allDay || _appointmentPartInInterval(appointmentStartDate, appointmentEndDate, startDayHour, endDayHour)) {
      const [trimMin, trimMax] = getDatesWithoutTime(min, max);
      min = trimMin;
      max = new Date(trimMax.getTime() - toMs8("minute"));
    }
    if (recurrenceRule && !recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {
      result = appointmentEndDate > min && appointmentStartDate <= max;
    }
    if (result && recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {
      const {
        viewOffset
      } = this.options;
      result = recurrenceProcessor.hasRecurrence({
        rule: recurrenceRule,
        exception: recurrenceException,
        start: appointmentStartDate,
        end: appointmentEndDate,
        min: dateUtilsTs.addOffsets(min, [viewOffset]),
        max: dateUtilsTs.addOffsets(max, [viewOffset]),
        firstDayOfWeek,
        appointmentTimezoneOffset: this.timeZoneCalculator.getOriginStartDateOffsetInMs(appointmentStartDate, appointment.startDateTimeZone, false)
      });
    }
    return result;
  }
  filterLoadedAppointments(filterOptions, preparedItems) {
    const filteredItems = this.filterPreparedItems(filterOptions, preparedItems);
    return filteredItems.map((_ref2) => {
      let {
        rawAppointment
      } = _ref2;
      return rawAppointment;
    });
  }
  filterPreparedItems(filterOptions, preparedItems) {
    const combinedFilter = this._createAppointmentFilter(filterOptions);
    return query_default(preparedItems).filter(combinedFilter).toArray();
  }
  filterAllDayAppointments(preparedItems) {
    const combinedFilter = this._createAllDayAppointmentFilter();
    return query_default(preparedItems).filter(combinedFilter).toArray().map((_ref3) => {
      let {
        rawAppointment
      } = _ref3;
      return rawAppointment;
    });
  }
};
var AppointmentFilterVirtualStrategy = class extends AppointmentFilterBaseStrategy {
  get strategyName() {
    return FilterStrategies.virtual;
  }
  get resources() {
    return this.options.resources;
  }
  filter(preparedItems) {
    const {
      viewOffset
    } = this.options;
    const hourMs = toMs8("hour");
    const isCalculateStartAndEndDayHour = isDateAndTimeView(this.viewType);
    const checkIntersectViewport = isCalculateStartAndEndDayHour && "horizontal" === this.viewDirection;
    const isAllDayWorkspace = !this.supportAllDayRow;
    const showAllDayAppointments = this.showAllDayPanel || isAllDayWorkspace;
    const endViewDate = this.viewDataProvider.getLastViewDateByEndDayHour(this.viewEndDayHour);
    const shiftedEndViewDate = dateUtilsTs.addOffsets(endViewDate, [viewOffset]);
    const filterOptions = [];
    const groupsInfo = this.viewDataProvider.getCompletedGroupsInfo();
    groupsInfo.forEach((item) => {
      const {
        groupIndex
      } = item;
      const groupStartDate = item.startDate;
      const groupEndDate = new Date(Math.min(item.endDate.getTime(), shiftedEndViewDate.getTime()));
      const startDayHour = isCalculateStartAndEndDayHour ? groupStartDate.getHours() : this.viewStartDayHour;
      const endDayHour = isCalculateStartAndEndDayHour ? startDayHour + groupStartDate.getMinutes() / 60 + (groupEndDate.getTime() - groupStartDate.getTime()) / hourMs : this.viewEndDayHour;
      const resources = this._getPrerenderFilterResources(groupIndex);
      const hasAllDayPanel = this.viewDataProvider.hasGroupAllDayPanel(groupIndex);
      const supportAllDayAppointment = isAllDayWorkspace || !!showAllDayAppointments && hasAllDayPanel;
      filterOptions.push({
        isVirtualScrolling: true,
        startDayHour,
        endDayHour,
        viewOffset,
        viewStartDayHour: this.viewStartDayHour,
        viewEndDayHour: this.viewEndDayHour,
        min: dateUtilsTs.addOffsets(groupStartDate, [-viewOffset]),
        max: dateUtilsTs.addOffsets(groupEndDate, [-viewOffset]),
        supportMultiDayAppointments: isTimelineView(this.viewType),
        allDay: supportAllDayAppointment,
        resources,
        firstDayOfWeek: this.firstDayOfWeek,
        checkIntersectViewport
      });
    });
    return this.filterLoadedAppointments({
      filterOptions,
      groupCount: this.groupCount
    }, preparedItems);
  }
  filterPreparedItems(_ref4, preparedItems) {
    let {
      filterOptions,
      groupCount
    } = _ref4;
    const combinedFilters = [];
    let itemsToFilter = preparedItems;
    const needPreFilter = groupCount > 0;
    if (needPreFilter) {
      itemsToFilter = itemsToFilter.filter((_ref5) => {
        let {
          rawAppointment
        } = _ref5;
        for (let i = 0; i < filterOptions.length; ++i) {
          const {
            resources
          } = filterOptions[i];
          if (this._filterAppointmentByResources(rawAppointment, resources)) {
            return true;
          }
        }
      });
    }
    filterOptions.forEach((option) => {
      combinedFilters.length && combinedFilters.push("or");
      const filter = this._createAppointmentFilter(option);
      combinedFilters.push(filter);
    });
    return query_default(itemsToFilter).filter(combinedFilters).toArray();
  }
  hasAllDayAppointments(filteredItems, preparedItems) {
    return this.filterAllDayAppointments(preparedItems).length > 0;
  }
  _getPrerenderFilterResources(groupIndex) {
    const cellGroup = this.viewDataProvider.getCellsGroup(groupIndex);
    return getResourcesDataByGroups(this.loadedResources, this.resources, [cellGroup]);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/data_provider/m_appointment_data_provider.js
var FilterStrategies2 = {
  virtual: "virtual",
  standard: "standard"
};
var AppointmentDataProvider = class {
  constructor(options) {
    this.options = options;
    this.dataSource = this.options.dataSource;
    this.dataAccessors = this.options.dataAccessors;
    this.timeZoneCalculator = this.options.timeZoneCalculator;
    this.appointmentDataSource = new AppointmentDataSource(this.dataSource);
    this.initFilterStrategy();
  }
  get keyName() {
    return this.appointmentDataSource.keyName;
  }
  get isDataSourceInit() {
    return !!this.dataSource;
  }
  get filterStrategyName() {
    return this.options.getIsVirtualScrolling() ? FilterStrategies2.virtual : FilterStrategies2.standard;
  }
  getFilterStrategy() {
    if (!this.filterStrategy || this.filterStrategy.strategyName !== this.filterStrategyName) {
      this.initFilterStrategy();
    }
    return this.filterStrategy;
  }
  initFilterStrategy() {
    const filterOptions = {
      resources: this.options.resources,
      dataAccessors: this.dataAccessors,
      startDayHour: this.options.startDayHour,
      endDayHour: this.options.endDayHour,
      viewOffset: this.options.viewOffset,
      showAllDayPanel: this.options.showAllDayPanel,
      timeZoneCalculator: this.options.timeZoneCalculator,
      loadedResources: this.options.getLoadedResources,
      supportAllDayRow: this.options.getSupportAllDayRow,
      viewType: this.options.getViewType,
      viewDirection: this.options.getViewDirection,
      dateRange: this.options.getDateRange,
      groupCount: this.options.getGroupCount,
      viewDataProvider: this.options.getViewDataProvider,
      allDayPanelMode: this.options.allDayPanelMode
    };
    this.filterStrategy = this.filterStrategyName === FilterStrategies2.virtual ? new AppointmentFilterVirtualStrategy(filterOptions) : new AppointmentFilterBaseStrategy(filterOptions);
  }
  setDataSource(dataSource) {
    this.dataSource = dataSource;
    this.initFilterStrategy();
    this.appointmentDataSource.setDataSource(this.dataSource);
  }
  updateDataAccessors(dataAccessors) {
    this.dataAccessors = dataAccessors;
    this.initFilterStrategy();
  }
  filter(preparedItems) {
    return this.getFilterStrategy().filter(preparedItems);
  }
  filterByDate(min, max, remoteFiltering, dateSerializationFormat) {
    if (!this.dataSource || !remoteFiltering) {
      return;
    }
    const dataSourceFilter = this.dataSource.filter();
    const filter = combineRemoteFilter({
      dataSourceFilter,
      dataAccessors: this.dataAccessors,
      min,
      max,
      dateSerializationFormat,
      forceIsoDateParsing: config_default().forceIsoDateParsing
    });
    this.dataSource.filter(filter);
  }
  hasAllDayAppointments(filteredItems, preparedItems) {
    return this.getFilterStrategy().hasAllDayAppointments(filteredItems, preparedItems);
  }
  filterLoadedAppointments(filterOption, preparedItems) {
    return this.getFilterStrategy().filterLoadedAppointments(filterOption, preparedItems);
  }
  calculateAppointmentEndDate(isAllDay, startDate) {
    return this.getFilterStrategy().calculateAppointmentEndDate(isAllDay, startDate);
  }
  cleanState() {
    this.appointmentDataSource.cleanState();
  }
  getUpdatedAppointment() {
    return this.appointmentDataSource._updatedAppointment;
  }
  getUpdatedAppointmentKeys() {
    return this.appointmentDataSource._updatedAppointmentKeys;
  }
  add(rawAppointment) {
    return this.appointmentDataSource.add(rawAppointment);
  }
  update(target, rawAppointment) {
    return this.appointmentDataSource.update(target, rawAppointment);
  }
  remove(rawAppointment) {
    return this.appointmentDataSource.remove(rawAppointment);
  }
  destroy() {
    this.appointmentDataSource.destroy();
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/ui/resizable/utils.js
var borderWidthStyles = {
  left: "borderLeftWidth",
  top: "borderTopWidth",
  right: "borderRightWidth",
  bottom: "borderBottomWidth"
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popover/m_popover_position_controller.js
var _excluded = ["shading", "target", "$arrow"];
var WEIGHT_OF_SIDES = {
  left: -1,
  top: -1,
  center: 0,
  right: 1,
  bottom: 1
};
var POPOVER_POSITION_ALIASES = {
  top: {
    my: "bottom center",
    at: "top center",
    collision: "fit flip"
  },
  bottom: {
    my: "top center",
    at: "bottom center",
    collision: "fit flip"
  },
  right: {
    my: "left center",
    at: "right center",
    collision: "flip fit"
  },
  left: {
    my: "right center",
    at: "left center",
    collision: "flip fit"
  }
};
var POPOVER_DEFAULT_BOUNDARY_OFFSET = {
  h: 10,
  v: 10
};
var PopoverPositionController = class extends OverlayPositionController {
  constructor(_ref) {
    let {
      shading,
      target,
      $arrow
    } = _ref, args = _objectWithoutPropertiesLoose(_ref, _excluded);
    super(args);
    this._props = _extends({}, this._props, {
      shading,
      target
    });
    this._$arrow = $arrow;
    this._positionSide = void 0;
    this.updatePosition(this._props.position);
  }
  positionWrapper() {
    if (this._props.shading) {
      this._$wrapper.css({
        top: 0,
        left: 0
      });
    }
  }
  updateTarget(target) {
    this._props.target = target;
    this.updatePosition(this._props.position);
  }
  _renderBoundaryOffset() {
  }
  _getContainerPosition() {
    const offset = pairToObject(this._position.offset || "");
    let {
      h: hOffset,
      v: vOffset
    } = offset;
    const isVerticalSide = this._isVerticalSide();
    const isHorizontalSide = this._isHorizontalSide();
    if (isVerticalSide || isHorizontalSide) {
      const isPopoverInside = this._isPopoverInside();
      const sign2 = (isPopoverInside ? -1 : 1) * WEIGHT_OF_SIDES[this._positionSide];
      const arrowSize = isVerticalSide ? getHeight(this._$arrow) : getWidth(this._$arrow);
      const arrowSizeCorrection = this._getContentBorderWidth(this._positionSide);
      const arrowOffset = sign2 * (arrowSize - arrowSizeCorrection);
      isVerticalSide ? vOffset += arrowOffset : hOffset += arrowOffset;
    }
    return extend({}, this._position, {
      offset: `${hOffset} ${vOffset}`
    });
  }
  _getContentBorderWidth(side) {
    const borderWidth = this._$content.css(borderWidthStyles[side]);
    return parseInt(borderWidth) || 0;
  }
  _isPopoverInside() {
    const my = position_default.setup.normalizeAlign(this._position.my);
    const at = position_default.setup.normalizeAlign(this._position.at);
    return my.h === at.h && my.v === at.v;
  }
  _isVerticalSide() {
    let side = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._positionSide;
    return "top" === side || "bottom" === side;
  }
  _isHorizontalSide() {
    let side = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._positionSide;
    return "left" === side || "right" === side;
  }
  _getDisplaySide(position) {
    const my = position_default.setup.normalizeAlign(position.my);
    const at = position_default.setup.normalizeAlign(position.at);
    const weightSign = WEIGHT_OF_SIDES[my.h] === WEIGHT_OF_SIDES[at.h] && WEIGHT_OF_SIDES[my.v] === WEIGHT_OF_SIDES[at.v] ? -1 : 1;
    const horizontalWeight = Math.abs(WEIGHT_OF_SIDES[my.h] - weightSign * WEIGHT_OF_SIDES[at.h]);
    const verticalWeight = Math.abs(WEIGHT_OF_SIDES[my.v] - weightSign * WEIGHT_OF_SIDES[at.v]);
    return horizontalWeight > verticalWeight ? at.h : at.v;
  }
  _normalizePosition(positionProp) {
    const defaultPositionConfig = {
      of: this._props.target,
      boundaryOffset: POPOVER_DEFAULT_BOUNDARY_OFFSET
    };
    let resultPosition;
    if (isDefined(positionProp)) {
      resultPosition = extend(true, {}, defaultPositionConfig, this._positionToObject(positionProp));
    } else {
      resultPosition = defaultPositionConfig;
    }
    this._positionSide = this._getDisplaySide(resultPosition);
    return resultPosition;
  }
  _positionToObject(positionProp) {
    if (isString(positionProp)) {
      return extend({}, POPOVER_POSITION_ALIASES[positionProp]);
    }
    return positionProp;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popover/m_popover.js
var POSITION_FLIP_MAP = {
  left: "right",
  top: "bottom",
  right: "left",
  bottom: "top",
  center: "center"
};
var getEventNameByOption = function(optionValue) {
  return isObject(optionValue) ? optionValue.name : optionValue;
};
var getEventName = function(that, optionName) {
  const optionValue = that.option(optionName);
  return getEventNameByOption(optionValue);
};
var getEventDelay = function(that, optionName) {
  const optionValue = that.option(optionName);
  return isObject(optionValue) && optionValue.delay;
};
var attachEvent = function(that, name2) {
  const {
    target,
    shading,
    disabled,
    hideEvent
  } = that.option();
  const isSelector = isString(target);
  const shouldIgnoreHideEvent = shading && "hide" === name2;
  const event = shouldIgnoreHideEvent ? null : getEventName(that, `${name2}Event`);
  if (shouldIgnoreHideEvent && hideEvent) {
    ui_errors_default.log("W1020");
  }
  if (!event || disabled) {
    return;
  }
  const eventName = addNamespace(event, that.NAME);
  const action = that._createAction((function() {
    const delay = getEventDelay(that, `${name2}Event`);
    this._clearEventsTimeouts();
    if (delay) {
      this._timeouts[name2] = setTimeout(() => {
        that[name2]();
      }, delay);
    } else {
      that[name2]();
    }
  }).bind(that), {
    validatingTargetName: "target"
  });
  const handler = function(e) {
    action({
      event: e,
      target: renderer_default(e.currentTarget)
    });
  };
  const EVENT_HANDLER_NAME = `_${name2}EventHandler`;
  if (isSelector) {
    that[EVENT_HANDLER_NAME] = handler;
    events_engine_default.on(dom_adapter_default.getDocument(), eventName, target, handler);
  } else {
    const targetElement = getPublicElement(renderer_default(target));
    that[EVENT_HANDLER_NAME] = void 0;
    events_engine_default.on(targetElement, eventName, handler);
  }
};
var detachEvent = function(that, target, name2, event) {
  let eventName = event || getEventName(that, `${name2}Event`);
  if (!eventName) {
    return;
  }
  eventName = addNamespace(eventName, that.NAME);
  const EVENT_HANDLER_NAME = `_${name2}EventHandler`;
  if (that[EVENT_HANDLER_NAME]) {
    events_engine_default.off(dom_adapter_default.getDocument(), eventName, target, that[EVENT_HANDLER_NAME]);
  } else {
    events_engine_default.off(getPublicElement(renderer_default(target)), eventName);
  }
};
var Popover = ui_popup_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      target: void 0,
      shading: false,
      position: extend({}, POPOVER_POSITION_ALIASES.bottom),
      hideOnOutsideClick: true,
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          from: 1,
          to: 0
        }
      },
      showTitle: false,
      width: "auto",
      height: "auto",
      dragEnabled: false,
      resizeEnabled: false,
      fullScreen: false,
      hideOnParentScroll: true,
      arrowPosition: "",
      arrowOffset: 0,
      _fixWrapperPosition: true
    });
  },
  _defaultOptionsRules: () => [{
    device: {
      platform: "ios"
    },
    options: {
      arrowPosition: {
        boundaryOffset: {
          h: 20,
          v: -10
        },
        collision: "fit"
      }
    }
  }, {
    device: () => !hasWindow(),
    options: {
      animation: null
    }
  }, {
    device: () => isMaterialBased(),
    options: {
      useFlatToolbarButtons: true
    }
  }, {
    device: () => isMaterial(),
    options: {
      useDefaultToolbarButtons: true,
      showCloseButton: false
    }
  }],
  _init() {
    var _this$option;
    this.callBase();
    this._renderArrow();
    this._timeouts = {};
    this.$element().addClass("dx-popover");
    this.$wrapper().addClass("dx-popover-wrapper");
    const isInteractive = null === (_this$option = this.option("toolbarItems")) || void 0 === _this$option ? void 0 : _this$option.length;
    this.setAria("role", isInteractive ? "dialog" : "tooltip");
  },
  _render() {
    this.callBase.apply(this, arguments);
    this._detachEvents(this.option("target"));
    this._attachEvents();
  },
  _detachEvents(target) {
    detachEvent(this, target, "show");
    detachEvent(this, target, "hide");
  },
  _attachEvents() {
    attachEvent(this, "show");
    attachEvent(this, "hide");
  },
  _renderArrow() {
    this._$arrow = renderer_default("<div>").addClass("dx-popover-arrow").prependTo(this.$overlayContent());
  },
  _documentDownHandler(e) {
    if (this._isOutsideClick(e)) {
      return this.callBase(e);
    }
    return true;
  },
  _isOutsideClick(e) {
    return !renderer_default(e.target).closest(this.option("target")).length;
  },
  _animate(animation) {
    if (animation && animation.to && "object" === typeof animation.to) {
      extend(animation.to, {
        position: this._getContainerPosition()
      });
    }
    this.callBase.apply(this, arguments);
  },
  _stopAnimation() {
    this.callBase.apply(this, arguments);
  },
  _renderTitle() {
    this.$wrapper().toggleClass("dx-popover-without-title", !this.option("showTitle"));
    this.callBase();
  },
  _renderPosition() {
    let shouldUpdateDimensions = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;
    this.callBase();
    this._renderOverlayPosition(shouldUpdateDimensions);
    this._actions.onPositioned();
  },
  _renderOverlayPosition(shouldUpdateDimensions) {
    this._resetOverlayPosition(shouldUpdateDimensions);
    this._updateContentSize(shouldUpdateDimensions);
    const contentPosition = this._getContainerPosition();
    const resultLocation = position_default.setup(this.$overlayContent(), contentPosition);
    const positionSide = this._getSideByLocation(resultLocation);
    this._togglePositionClass(`dx-position-${positionSide}`);
    this._toggleFlippedClass(resultLocation.h.flip, resultLocation.v.flip);
    const isArrowVisible = this._isHorizontalSide() || this._isVerticalSide();
    if (isArrowVisible) {
      this._renderArrowPosition(positionSide);
    }
  },
  _resetOverlayPosition(shouldUpdateDimensions) {
    this._setContentHeight(shouldUpdateDimensions);
    this._togglePositionClass(`dx-position-${this._positionController._positionSide}`);
    move(this.$overlayContent(), {
      left: 0,
      top: 0
    });
    this._$arrow.css({
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    });
  },
  _updateContentSize(shouldUpdateDimensions) {
    if (!this.$content() || !shouldUpdateDimensions) {
      return;
    }
    const containerLocation = position_default.calculate(this.$overlayContent(), this._getContainerPosition());
    if (containerLocation.h.oversize > 0 && this._isHorizontalSide() && !containerLocation.h.fit) {
      const newContainerWidth = getWidth(this.$overlayContent()) - containerLocation.h.oversize;
      setWidth(this.$overlayContent(), newContainerWidth);
    }
    if (containerLocation.v.oversize > 0 && this._isVerticalSide() && !containerLocation.v.fit) {
      const newOverlayContentHeight = getHeight(this.$overlayContent()) - containerLocation.v.oversize;
      const newPopupContentHeight = getHeight(this.$content()) - containerLocation.v.oversize;
      setHeight(this.$overlayContent(), newOverlayContentHeight);
      setHeight(this.$content(), newPopupContentHeight);
    }
  },
  _getContainerPosition() {
    return this._positionController._getContainerPosition();
  },
  _getHideOnParentScrollTarget() {
    return renderer_default(this._positionController._position.of || this.callBase());
  },
  _getSideByLocation(location) {
    const isFlippedByVertical = location.v.flip;
    const isFlippedByHorizontal = location.h.flip;
    return this._isVerticalSide() && isFlippedByVertical || this._isHorizontalSide() && isFlippedByHorizontal || this._isPopoverInside() ? POSITION_FLIP_MAP[this._positionController._positionSide] : this._positionController._positionSide;
  },
  _togglePositionClass(positionClass) {
    this.$wrapper().removeClass("dx-position-left dx-position-right dx-position-top dx-position-bottom").addClass(positionClass);
  },
  _toggleFlippedClass(isFlippedHorizontal, isFlippedVertical) {
    this.$wrapper().toggleClass("dx-popover-flipped-horizontal", isFlippedHorizontal).toggleClass("dx-popover-flipped-vertical", isFlippedVertical);
  },
  _renderArrowPosition(side) {
    const arrowRect = getBoundingRect(this._$arrow.get(0));
    const arrowFlip = -(this._isVerticalSide(side) ? arrowRect.height : arrowRect.width);
    this._$arrow.css(POSITION_FLIP_MAP[side], arrowFlip);
    const axis = this._isVerticalSide(side) ? "left" : "top";
    const sizeProperty = this._isVerticalSide(side) ? "width" : "height";
    const $target = renderer_default(this._positionController._position.of);
    const targetOffset = position_default.offset($target) || {
      top: 0,
      left: 0
    };
    const contentOffset = position_default.offset(this.$overlayContent());
    const arrowSize = arrowRect[sizeProperty];
    const contentLocation = contentOffset[axis];
    const contentSize = getBoundingRect(this.$overlayContent().get(0))[sizeProperty];
    const targetLocation = targetOffset[axis];
    const targetElement = $target.get(0);
    const targetSize = targetElement && !targetElement.preventDefault ? getBoundingRect(targetElement)[sizeProperty] : 0;
    const min = Math.max(contentLocation, targetLocation);
    const max = Math.min(contentLocation + contentSize, targetLocation + targetSize);
    let arrowLocation;
    if ("start" === this.option("arrowPosition")) {
      arrowLocation = min - contentLocation;
    } else if ("end" === this.option("arrowPosition")) {
      arrowLocation = max - contentLocation - arrowSize;
    } else {
      arrowLocation = (min + max) / 2 - contentLocation - arrowSize / 2;
    }
    const borderWidth = this._positionController._getContentBorderWidth(side);
    const finalArrowLocation = fitIntoRange(arrowLocation - borderWidth + this.option("arrowOffset"), borderWidth, contentSize - arrowSize - 2 * borderWidth);
    this._$arrow.css(axis, finalArrowLocation);
  },
  _isPopoverInside() {
    return this._positionController._isPopoverInside();
  },
  _setContentHeight(fullUpdate) {
    if (fullUpdate) {
      this.callBase();
    }
  },
  _getPositionControllerConfig() {
    const {
      shading,
      target
    } = this.option();
    return extend({}, this.callBase(), {
      target,
      shading,
      $arrow: this._$arrow
    });
  },
  _initPositionController() {
    this._positionController = new PopoverPositionController(this._getPositionControllerConfig());
  },
  _renderWrapperDimensions() {
    if (this.option("shading")) {
      this.$wrapper().css({
        width: "100%",
        height: "100%"
      });
    }
  },
  _isVerticalSide(side) {
    return this._positionController._isVerticalSide(side);
  },
  _isHorizontalSide(side) {
    return this._positionController._isHorizontalSide(side);
  },
  _clearEventTimeout(name2) {
    clearTimeout(this._timeouts[name2]);
  },
  _clearEventsTimeouts() {
    this._clearEventTimeout("show");
    this._clearEventTimeout("hide");
  },
  _clean() {
    this._detachEvents(this.option("target"));
    this.callBase.apply(this, arguments);
  },
  _optionChanged(args) {
    switch (args.name) {
      case "arrowPosition":
      case "arrowOffset":
        this._renderGeometry();
        break;
      case "fullScreen":
        if (args.value) {
          this.option("fullScreen", false);
        }
        break;
      case "target":
        args.previousValue && this._detachEvents(args.previousValue);
        this._positionController.updateTarget(args.value);
        this._invalidate();
        break;
      case "showEvent":
      case "hideEvent": {
        const name2 = args.name.substring(0, 4);
        const event = getEventNameByOption(args.previousValue);
        this.hide();
        detachEvent(this, this.option("target"), name2, event);
        attachEvent(this, name2);
        break;
      }
      case "visible":
        this._clearEventTimeout(args.value ? "show" : "hide");
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  },
  show(target) {
    if (target) {
      this.option("target", target);
    }
    return this.callBase();
  }
});
component_registrator_default("dxPopover", Popover);
var m_popover_default = Popover;

// ../../../../../../node_modules/devextreme/esm/ui/popover/ui.popover.js
var ui_popover_default = m_popover_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_tooltip.js
var Tooltip = ui_popover_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      toolbarItems: [],
      showCloseButton: false,
      enableBodyScroll: true,
      showTitle: false,
      title: null,
      titleTemplate: null,
      onTitleRendered: null,
      bottomTemplate: null,
      preventScrollEvents: false,
      propagateOutsideClick: true
    });
  },
  _render() {
    this.$element().addClass("dx-tooltip");
    this.$wrapper().addClass("dx-tooltip-wrapper");
    this.callBase();
  },
  _renderContent() {
    this.callBase();
    this._toggleAriaAttributes();
  },
  _toggleAriaDescription(showing) {
    const $target = renderer_default(this.option("target"));
    const label = showing ? this._contentId : void 0;
    if (!isWindow($target.get(0))) {
      this.setAria("describedby", label, $target);
    }
  },
  _toggleAriaAttributes() {
    this._contentId = `dx-${new guid_default()}`;
    this.$overlayContent().attr({
      id: this._contentId
    });
    this._toggleAriaDescription(true);
  }
});
component_registrator_default("dxTooltip", Tooltip);
var m_tooltip_default = Tooltip;

// ../../../../../../node_modules/devextreme/esm/ui/tooltip.js
var tooltip_default = m_tooltip_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tooltip/m_tooltip.js
var tooltip = null;
var removeTooltipElement = null;
var createTooltip = function(options) {
  options = extend({
    position: "top"
  }, options);
  const {
    content
  } = options;
  delete options.content;
  const $tooltip = renderer_default("<div>").html(content).appendTo(value());
  removeTooltipElement = function() {
    $tooltip.remove();
  };
  tooltip = new tooltip_default($tooltip, options);
};
var removeTooltip = function() {
  if (!tooltip) {
    return;
  }
  removeTooltipElement();
  tooltip = null;
};
function show2(options) {
  removeTooltip();
  createTooltip(options);
  return tooltip.show();
}
function hide2() {
  if (!tooltip) {
    return Deferred().resolve();
  }
  return tooltip.hide().done(removeTooltip).promise();
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_appointment.js
var REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME = addNamespace(pointer_default.enter, "dxSchedulerAppointment");
var REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME = addNamespace(pointer_default.leave, "dxSchedulerAppointment");
var Appointment = class extends dom_component_default {
  get coloredElement() {
    return this.$element();
  }
  get rawAppointment() {
    return this.option("data");
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      data: {},
      groupIndex: -1,
      groups: [],
      geometry: {
        top: 0,
        left: 0,
        width: 0,
        height: 0
      },
      allowDrag: true,
      allowResize: true,
      reduced: null,
      isCompact: false,
      direction: "vertical",
      resizableConfig: {
        keepAspectRatio: false
      },
      cellHeight: 0,
      cellWidth: 0,
      isDragSource: false
    });
  }
  notifyObserver(subject, args) {
    const observer = this.option("observer");
    if (observer) {
      observer.fire(subject, args);
    }
  }
  invoke(funcName) {
    const observer = this.option("observer");
    if (observer) {
      return observer.fire.apply(observer, arguments);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "data":
      case "groupIndex":
      case "geometry":
      case "allowDrag":
      case "allowResize":
      case "reduced":
      case "sortedIndex":
      case "isCompact":
      case "direction":
      case "resizableConfig":
      case "cellHeight":
      case "cellWidth":
        this._invalidate();
        break;
      case "isDragSource":
        this._renderDragSourceClass();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _getHorizontalResizingRule() {
    const reducedHandles = {
      head: this.option("rtlEnabled") ? "right" : "left",
      body: "",
      tail: this.option("rtlEnabled") ? "left" : "right"
    };
    const getResizableStep = this.option("getResizableStep");
    const step = getResizableStep ? getResizableStep() : 0;
    return {
      handles: this.option("reduced") ? reducedHandles[this.option("reduced")] : "left right",
      minHeight: 0,
      minWidth: this.invoke("getCellWidth"),
      step,
      roundStepValue: false
    };
  }
  _getVerticalResizingRule() {
    const height = Math.round(this.invoke("getCellHeight"));
    return {
      handles: "top bottom",
      minWidth: 0,
      minHeight: height,
      step: height,
      roundStepValue: true
    };
  }
  _render() {
    super._render();
    this._renderAppointmentGeometry();
    this._renderEmptyClass();
    this._renderReducedAppointment();
    this._renderAllDayClass();
    this._renderDragSourceClass();
    this._renderDirection();
    this.$element().data("dxAppointmentStartDate", this.option("startDate"));
    const text = ExpressionUtils.getField(this.option("dataAccessors"), "text", this.rawAppointment);
    this.$element().attr("title", text);
    this.$element().attr("role", "button");
    this._renderRecurrenceClass();
    this._renderResizable();
    this._setResourceColor();
  }
  _setResourceColor() {
    const appointmentConfig = {
      itemData: this.rawAppointment,
      groupIndex: this.option("groupIndex"),
      groups: this.option("groups")
    };
    const deferredColor = this.option("getAppointmentColor")(appointmentConfig);
    deferredColor.done((color) => {
      if (color) {
        this.coloredElement.css("backgroundColor", color);
        this.coloredElement.addClass(APPOINTMENT_HAS_RESOURCE_COLOR_CLASS);
      }
    });
  }
  _renderAppointmentGeometry() {
    const geometry = this.option("geometry");
    const $element = this.$element();
    move($element, {
      top: geometry.top,
      left: geometry.left
    });
    $element.css({
      width: geometry.width < 0 ? 0 : geometry.width,
      height: geometry.height < 0 ? 0 : geometry.height
    });
  }
  _renderEmptyClass() {
    const geometry = this.option("geometry");
    if (geometry.empty || this.option("isCompact")) {
      this.$element().addClass(EMPTY_APPOINTMENT_CLASS);
    }
  }
  _renderReducedAppointment() {
    const reducedPart = this.option("reduced");
    if (!reducedPart) {
      return;
    }
    this.$element().toggleClass(REDUCED_APPOINTMENT_CLASS, true).toggleClass(REDUCED_APPOINTMENT_PARTS_CLASSES[reducedPart], true);
    this._renderAppointmentReducedIcon();
  }
  _renderAppointmentReducedIcon() {
    const $icon = renderer_default("<div>").addClass(REDUCED_APPOINTMENT_ICON).appendTo(this.$element());
    const endDate = this._getEndDate();
    const tooltipLabel = message_default.format("dxScheduler-editorLabelEndDate");
    const tooltipText = [tooltipLabel, ": ", date_default.format(endDate, "monthAndDay"), ", ", date_default.format(endDate, "year")].join("");
    events_engine_default.off($icon, REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME);
    events_engine_default.on($icon, REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME, () => {
      show2({
        target: $icon,
        content: tooltipText
      });
    });
    events_engine_default.off($icon, REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME);
    events_engine_default.on($icon, REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME, () => {
      hide2();
    });
  }
  _getEndDate() {
    const result = ExpressionUtils.getField(this.option("dataAccessors"), "endDate", this.rawAppointment);
    if (result) {
      return new Date(result);
    }
    return result;
  }
  _renderAllDayClass() {
    this.$element().toggleClass(ALL_DAY_APPOINTMENT_CLASS, !!this.option("allDay"));
  }
  _renderDragSourceClass() {
    this.$element().toggleClass(APPOINTMENT_DRAG_SOURCE_CLASS, !!this.option("isDragSource"));
  }
  _renderRecurrenceClass() {
    const rule = ExpressionUtils.getField(this.option("dataAccessors"), "recurrenceRule", this.rawAppointment);
    if (getRecurrenceProcessor().isValidRecurrenceRule(rule)) {
      this.$element().addClass(RECURRENCE_APPOINTMENT_CLASS);
    }
  }
  _renderDirection() {
    this.$element().addClass(DIRECTION_APPOINTMENT_CLASSES[this.option("direction")]);
  }
  _createResizingConfig() {
    const config = "vertical" === this.option("direction") ? this._getVerticalResizingRule() : this._getHorizontalResizingRule();
    if (!this.invoke("isGroupedByDate")) {
      config.stepPrecision = "strict";
    }
    return config;
  }
  _renderResizable() {
    if (this.option("allowResize")) {
      this._createComponent(this.$element(), resizable_default, extend(this._createResizingConfig(), this.option("resizableConfig")));
    }
  }
  _useTemplates() {
    return false;
  }
};
component_registrator_default("dxSchedulerAppointment", Appointment);
var AgendaAppointment = class extends Appointment {
  get coloredElement() {
    return this.$element().find(`.${APPOINTMENT_CONTENT_CLASSES.AGENDA_MARKER}`);
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      createPlainResourceListAsync: new Deferred()
    });
  }
  _renderResourceList(container, list) {
    list.forEach((item) => {
      const itemContainer = renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.AGENDA_RESOURCE_LIST_ITEM).appendTo(container);
      renderer_default("<div>").text(`${item.label}:`).appendTo(itemContainer);
      renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.AGENDA_RESOURCE_LIST_ITEM_VALUE).text(item.values.join(", ")).appendTo(itemContainer);
    });
  }
  _render() {
    super._render();
    const createPlainResourceListAsync = this.option("createPlainResourceListAsync");
    createPlainResourceListAsync(this.rawAppointment).done((list) => {
      const parent = this.$element().find(`.${APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_CONTENT_DETAILS}`);
      const container = renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.AGENDA_RESOURCE_LIST).appendTo(parent);
      this._renderResourceList(container, list);
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_appointment_layout.js
var allDayText = ` ${message_default.format("dxScheduler-allDay")}: `;
var createAppointmentLayout = (formatText, config) => {
  const result = renderer_default(dom_adapter_default.createDocumentFragment());
  renderer_default("<div>").text(formatText.text).addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_TITLE).appendTo(result);
  if (config.html) {
    result.html(config.html);
  }
  const $contentDetails = renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_CONTENT_DETAILS).appendTo(result);
  renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_DATE).text(formatText.formatDate).appendTo($contentDetails);
  config.isRecurrence && renderer_default("<span>").addClass(`${APPOINTMENT_CONTENT_CLASSES.RECURRING_ICON} dx-icon-repeat`).appendTo(result);
  config.isAllDay && renderer_default("<div>").text(allDayText).addClass(APPOINTMENT_CONTENT_CLASSES.ALL_DAY_CONTENT).prependTo($contentDetails);
  return result;
};
var createAgendaAppointmentLayout = (formatText, config) => {
  const result = renderer_default(dom_adapter_default.createDocumentFragment());
  const leftLayoutContainer = renderer_default("<div>").addClass("dx-scheduler-agenda-appointment-left-layout").appendTo(result);
  const rightLayoutContainer = renderer_default("<div>").addClass("dx-scheduler-agenda-appointment-right-layout").appendTo(result);
  const marker = renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.AGENDA_MARKER).appendTo(leftLayoutContainer);
  config.isRecurrence && renderer_default("<span>").addClass(`${APPOINTMENT_CONTENT_CLASSES.RECURRING_ICON} dx-icon-repeat`).appendTo(marker);
  renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_TITLE).text(formatText.text).appendTo(rightLayoutContainer);
  const additionalContainer = renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_CONTENT_DETAILS).appendTo(rightLayoutContainer);
  renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_DATE).text(formatText.formatDate).appendTo(additionalContainer);
  if (config.isAllDay) {
    renderer_default("<div>").text(allDayText).addClass(APPOINTMENT_CONTENT_CLASSES.ALL_DAY_CONTENT).prependTo(additionalContainer);
  }
  return result;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/resizing/m_core.js
var getAppointmentLeftCell = (options) => {
  const {
    cellHeight,
    cellWidth,
    viewDataProvider,
    relativeAppointmentRect,
    appointmentSettings,
    rtlEnabled
  } = options;
  const cellRowIndex = Math.floor(relativeAppointmentRect.top / cellHeight);
  const cellColumnIndex = Math.round(relativeAppointmentRect.left / cellWidth);
  const leftCell = viewDataProvider.getCellData(cellRowIndex, cellColumnIndex, appointmentSettings.allDay, rtlEnabled);
  return leftCell;
};
var getDateRangeHorizontal = (options) => {
  const {
    cellWidth,
    cellCountInRow,
    relativeAppointmentRect,
    viewDataProvider,
    appointmentSettings,
    handles
  } = options;
  const appointmentFirstCell = getAppointmentLeftCell(options);
  const appointmentCellsAmount = Math.round(relativeAppointmentRect.width / cellWidth);
  const appointmentLastCellIndex = appointmentFirstCell.index + (appointmentCellsAmount - 1);
  const {
    sourceAppointment
  } = appointmentSettings.info;
  const {
    allDay
  } = appointmentSettings.info.appointment;
  if (handles.left) {
    return {
      startDate: appointmentFirstCell.startDate,
      endDate: appointmentFirstCell.startDate > sourceAppointment.endDate ? appointmentFirstCell.startDate : sourceAppointment.endDate
    };
  }
  const appointmentRowIndex = Math.floor(appointmentLastCellIndex / cellCountInRow);
  const appointmentColumnIndex = appointmentLastCellIndex % cellCountInRow;
  const appointmentLastCell = viewDataProvider.getCellData(appointmentRowIndex, appointmentColumnIndex, allDay);
  const endDate = !options.considerTime ? appointmentLastCell.endDate : appointmentLastCell.startDate;
  return {
    startDate: endDate < sourceAppointment.startDate ? endDate : sourceAppointment.startDate,
    endDate
  };
};
var getDateRangeHorizontalRTL = (options) => {
  const {
    viewDataProvider,
    cellCountInRow,
    appointmentSettings,
    handles,
    cellWidth,
    relativeAppointmentRect
  } = options;
  const appointmentLastCell = getAppointmentLeftCell(options);
  const {
    sourceAppointment
  } = appointmentSettings.info;
  const {
    allDay
  } = appointmentSettings.info.appointment;
  if (handles.right) {
    const appointmentLastCellIndex = appointmentLastCell.index;
    const appointmentCellsAmount = Math.round(relativeAppointmentRect.width / cellWidth);
    const appointmentFirstCellIndex = appointmentLastCellIndex - appointmentCellsAmount + 1;
    const appointmentRowIndex = Math.floor(appointmentLastCellIndex / cellCountInRow);
    const appointmentFirstCell = viewDataProvider.getCellData(appointmentRowIndex, appointmentFirstCellIndex, allDay, true);
    return {
      startDate: appointmentFirstCell.startDate,
      endDate: appointmentFirstCell.startDate > sourceAppointment.endDate ? appointmentFirstCell.startDate : sourceAppointment.endDate
    };
  }
  const endDate = !options.considerTime ? appointmentLastCell.endDate : appointmentLastCell.startDate;
  return {
    startDate: endDate < sourceAppointment.startDate ? endDate : sourceAppointment.startDate,
    endDate
  };
};
var getRelativeAppointmentRect = (appointmentRect, parentAppointmentRect) => {
  const left = appointmentRect.left - parentAppointmentRect.left;
  const top = appointmentRect.top - parentAppointmentRect.top;
  const width = left < 0 ? appointmentRect.width + left : appointmentRect.width;
  const height = top < 0 ? appointmentRect.height + top : appointmentRect.height;
  return {
    left: Math.max(0, left),
    top: Math.max(0, top),
    width,
    height
  };
};
var getAppointmentCellsInfo = (options) => {
  const {
    appointmentSettings,
    isVerticalGroupedWorkSpace,
    DOMMetaData
  } = options;
  const DOMMetaTable = appointmentSettings.allDay && !isVerticalGroupedWorkSpace ? [DOMMetaData.allDayPanelCellsMeta] : DOMMetaData.dateTableCellsMeta;
  const {
    positionByMap
  } = appointmentSettings;
  const {
    height: cellHeight,
    width: cellWidth
  } = DOMMetaTable[positionByMap.rowIndex][positionByMap.columnIndex];
  const cellCountInRow = DOMMetaTable[positionByMap.rowIndex].length;
  return {
    cellWidth,
    cellHeight,
    cellCountInRow
  };
};
var getAppointmentDateRange = (options) => {
  const {
    appointmentSettings
  } = options;
  const relativeAppointmentRect = getRelativeAppointmentRect(options.appointmentRect, options.parentAppointmentRect);
  const cellInfo = getAppointmentCellsInfo(options);
  const considerTime = !options.isDateAndTimeView || appointmentSettings.allDay;
  const extendedOptions = _extends({}, options, cellInfo, {
    considerTime,
    relativeAppointmentRect
  });
  return !options.rtlEnabled ? getDateRangeHorizontal(extendedOptions) : getDateRangeHorizontalRTL(extendedOptions);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_appointment_collection.js
var COMPONENT_CLASS = "dx-scheduler-scrollable-appointments";
var DBLCLICK_EVENT_NAME2 = addNamespace(DBLCLICK_EVENT_NAME, "dxSchedulerAppointment");
var toMs9 = date_default2.dateToMilliseconds;
var SchedulerAppointments = class extends ui_collection_widget_edit_default {
  get isAgendaView() {
    return this.invoke("isCurrentViewAgenda");
  }
  get isVirtualScrolling() {
    return this.invoke("isVirtualScrolling");
  }
  get appointmentDataProvider() {
    return this.option("getAppointmentDataProvider")();
  }
  constructor(element, options) {
    super(element, options);
    this._virtualAppointments = {};
  }
  option(optionName, value2) {
    return super.option(...arguments);
  }
  notifyObserver(subject, args) {
    const observer = this.option("observer");
    if (observer) {
      observer.fire(subject, args);
    }
  }
  invoke(funcName) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    const observer = this.option("observer");
    if (observer) {
      return observer.fire.apply(observer, arguments);
    }
  }
  _dispose() {
    clearTimeout(this._appointmentClickTimeout);
    super._dispose();
  }
  _supportedKeys() {
    const parent = super._supportedKeys();
    const currentAppointment = this._$currentAppointment;
    return extend(parent, {
      escape: (function() {
        if (this.resizeOccur) {
          var _currentAppointment$d, _currentAppointment$d2, _currentAppointment$d3;
          this.moveAppointmentBack();
          this.resizeOccur = false;
          null === (_currentAppointment$d = currentAppointment.dxResizable("instance")) || void 0 === _currentAppointment$d || _currentAppointment$d._detachEventHandlers();
          null === (_currentAppointment$d2 = currentAppointment.dxResizable("instance")) || void 0 === _currentAppointment$d2 || _currentAppointment$d2._attachEventHandlers();
          null === (_currentAppointment$d3 = currentAppointment.dxResizable("instance")) || void 0 === _currentAppointment$d3 || _currentAppointment$d3._toggleResizingClass(false);
        }
      }).bind(this),
      del: (function(e) {
        if (this.option("allowDelete")) {
          e.preventDefault();
          const data2 = this._getItemData(e.target);
          this.notifyObserver("onDeleteButtonPress", {
            data: data2,
            target: e.target
          });
        }
      }).bind(this),
      tab: function(e) {
        const appointments = this._getAccessAppointments();
        const focusedAppointment = appointments.filter(".dx-state-focused");
        let index = focusedAppointment.data(APPOINTMENT_SETTINGS_KEY).sortedIndex;
        const lastIndex = appointments.length - 1;
        if (index > 0 && e.shiftKey || index < lastIndex && !e.shiftKey) {
          e.preventDefault();
          e.shiftKey ? index-- : index++;
          const $nextAppointment = this._getAppointmentByIndex(index);
          this._resetTabIndex($nextAppointment);
          events_engine_default.trigger($nextAppointment, "focus");
        }
      }
    });
  }
  _getAppointmentByIndex(sortedIndex) {
    const appointments = this._getAccessAppointments();
    return appointments.filter((_, $item) => data($item, APPOINTMENT_SETTINGS_KEY).sortedIndex === sortedIndex).eq(0);
  }
  _getAccessAppointments() {
    return this._itemElements().filter(":visible").not(".dx-state-disabled");
  }
  _resetTabIndex($appointment) {
    this._focusTarget().attr("tabIndex", -1);
    $appointment.attr("tabIndex", this.option("tabIndex"));
  }
  _moveFocus() {
  }
  _focusTarget() {
    return this._itemElements();
  }
  _renderFocusTarget() {
    const $appointment = this._getAppointmentByIndex(0);
    this._resetTabIndex($appointment);
  }
  _focusInHandler(e) {
    super._focusInHandler(e);
    this._$currentAppointment = renderer_default(e.target);
    this.option("focusedElement", getPublicElement(renderer_default(e.target)));
  }
  _focusOutHandler(e) {
    const $appointment = this._getAppointmentByIndex(0);
    this.option("focusedElement", getPublicElement($appointment));
    super._focusOutHandler(e);
  }
  _eventBindingTarget() {
    return this._itemContainer();
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      noDataText: null,
      activeStateEnabled: true,
      hoverStateEnabled: true,
      tabIndex: 0,
      fixedContainer: null,
      allDayContainer: null,
      allowDrag: true,
      allowResize: true,
      allowAllDayResize: true,
      onAppointmentDblClick: null,
      _collectorOffset: 0,
      groups: [],
      resources: []
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case "items":
        this._cleanFocusState();
        this._clearDropDownItems();
        this._clearDropDownItemsElements();
        this._repaintAppointments(args.value);
        this._renderDropDownAppointments();
        this._attachAppointmentsEvents();
        break;
      case "fixedContainer":
      case "allDayContainer":
      case "onAppointmentDblClick":
      case "allowDelete":
        break;
      case "allowDrag":
      case "allowResize":
      case "allowAllDayResize":
        this._invalidate();
        break;
      case "focusedElement":
        this._resetTabIndex(renderer_default(args.value));
        super._optionChanged(args);
        break;
      case "focusStateEnabled":
        this._clearDropDownItemsElements();
        this._renderDropDownAppointments();
        super._optionChanged(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
  _isAllDayAppointment(appointment) {
    return appointment.settings.length && appointment.settings[0].allDay || false;
  }
  _isRepaintAppointment(appointment) {
    return !isDefined(appointment.needRepaint) || true === appointment.needRepaint;
  }
  _isRepaintAll(appointments) {
    if (this.isAgendaView) {
      return true;
    }
    for (let i = 0; i < appointments.length; i++) {
      if (!this._isRepaintAppointment(appointments[i])) {
        return false;
      }
    }
    return true;
  }
  _applyFragment(fragment, allDay) {
    if (fragment.children().length > 0) {
      this._getAppointmentContainer(allDay).append(fragment);
    }
  }
  _onEachAppointment(appointment, index, container, isRepaintAll) {
    const repaintAppointment = () => {
      appointment.needRepaint = false;
      this._clearItem(appointment);
      this._renderItem(index, appointment, container);
    };
    if (true === (null === appointment || void 0 === appointment ? void 0 : appointment.needRemove)) {
      this._clearItem(appointment);
    } else if (isRepaintAll || this._isRepaintAppointment(appointment)) {
      repaintAppointment();
    }
  }
  _repaintAppointments(appointments) {
    this._renderByFragments(($commonFragment, $allDayFragment) => {
      const isRepaintAll = this._isRepaintAll(appointments);
      if (isRepaintAll) {
        this._getAppointmentContainer(true).html("");
        this._getAppointmentContainer(false).html("");
      }
      !appointments.length && this._cleanItemContainer();
      appointments.forEach((appointment, index) => {
        const container = this._isAllDayAppointment(appointment) ? $allDayFragment : $commonFragment;
        this._onEachAppointment(appointment, index, container, isRepaintAll);
      });
    });
  }
  _renderByFragments(renderFunction) {
    if (this.isVirtualScrolling) {
      const $commonFragment = renderer_default(dom_adapter_default.createDocumentFragment());
      const $allDayFragment = renderer_default(dom_adapter_default.createDocumentFragment());
      renderFunction($commonFragment, $allDayFragment);
      this._applyFragment($commonFragment, false);
      this._applyFragment($allDayFragment, true);
    } else {
      renderFunction(this._getAppointmentContainer(false), this._getAppointmentContainer(true));
    }
  }
  _attachAppointmentsEvents() {
    this._attachClickEvent();
    this._attachHoldEvent();
    this._attachContextMenuEvent();
    this._attachAppointmentDblClick();
    this._renderFocusState();
    this._attachFeedbackEvents();
    this._attachHoverEvents();
  }
  _clearItem(item) {
    const $items = this._findItemElementByItem(item.itemData);
    if (!$items.length) {
      return;
    }
    each($items, (_, $item) => {
      $item.detach();
      $item.remove();
    });
  }
  _clearDropDownItems() {
    this._virtualAppointments = {};
  }
  _clearDropDownItemsElements() {
    this.invoke("clearCompactAppointments");
  }
  _findItemElementByItem(item) {
    const result = [];
    const that = this;
    this.itemElements().each(function() {
      const $item = renderer_default(this);
      if ($item.data(that._itemDataKey()) === item) {
        result.push($item);
      }
    });
    return result;
  }
  _itemClass() {
    return APPOINTMENT_ITEM_CLASS;
  }
  _itemContainer() {
    const $container = super._itemContainer();
    let $result = $container;
    const $allDayContainer = this.option("allDayContainer");
    if ($allDayContainer) {
      $result = $container.add($allDayContainer);
    }
    return $result;
  }
  _cleanItemContainer() {
    super._cleanItemContainer();
    const $allDayContainer = this.option("allDayContainer");
    if ($allDayContainer) {
      $allDayContainer.empty();
    }
    this._virtualAppointments = {};
  }
  _clean() {
    super._clean();
    delete this._$currentAppointment;
    delete this._initialSize;
    delete this._initialCoordinates;
  }
  _init() {
    super._init();
    this.$element().addClass(COMPONENT_CLASS);
    this._preventSingleAppointmentClick = false;
  }
  _renderAppointmentTemplate($container, appointment, model) {
    var _this$_currentAppoint;
    const config = {
      isAllDay: appointment.allDay,
      isRecurrence: appointment.recurrenceRule,
      html: isPlainObject(appointment) && appointment.html ? appointment.html : void 0
    };
    const formatText = this.invoke("getTextAndFormatDate", model.appointmentData, (null === (_this$_currentAppoint = this._currentAppointmentSettings) || void 0 === _this$_currentAppoint ? void 0 : _this$_currentAppoint.agendaSettings) || model.targetedAppointmentData, "TIME");
    $container.append(this.isAgendaView ? createAgendaAppointmentLayout(formatText, config) : createAppointmentLayout(formatText, config));
    if (!this.isAgendaView) {
      $container.parent().prepend(renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.STRIP));
    }
  }
  _executeItemRenderAction(index, itemData, itemElement) {
    const action = this._getItemRenderAction();
    if (action) {
      action(this.invoke("mapAppointmentFields", {
        itemData,
        itemElement
      }));
    }
    delete this._currentAppointmentSettings;
  }
  _itemClickHandler(e) {
    super._itemClickHandler(e, {}, {
      afterExecute: (function(e2) {
        this._processItemClick(e2.args[0].event);
      }).bind(this)
    });
  }
  _processItemClick(e) {
    const $target = renderer_default(e.currentTarget);
    const data2 = this._getItemData($target);
    if ("keydown" === e.type || isFakeClickEvent(e)) {
      this.notifyObserver("showEditAppointmentPopup", {
        data: data2,
        target: $target
      });
      return;
    }
    this._appointmentClickTimeout = setTimeout(() => {
      if (!this._preventSingleAppointmentClick && isElementInDom($target)) {
        this.notifyObserver("showAppointmentTooltip", {
          data: data2,
          target: $target
        });
      }
      this._preventSingleAppointmentClick = false;
    }, 300);
  }
  _extendActionArgs($itemElement) {
    const args = super._extendActionArgs($itemElement);
    return this.invoke("mapAppointmentFields", args);
  }
  _render() {
    super._render();
    this._attachAppointmentDblClick();
  }
  _attachAppointmentDblClick() {
    const that = this;
    const itemSelector = that._itemSelector();
    const itemContainer = this._itemContainer();
    events_engine_default.off(itemContainer, DBLCLICK_EVENT_NAME2, itemSelector);
    events_engine_default.on(itemContainer, DBLCLICK_EVENT_NAME2, itemSelector, (e) => {
      that._itemDXEventHandler(e, "onAppointmentDblClick", {}, {
        afterExecute(e2) {
          that._dblClickHandler(e2.args[0].event);
        }
      });
    });
  }
  _dblClickHandler(e) {
    const $targetAppointment = renderer_default(e.currentTarget);
    const appointmentData = this._getItemData($targetAppointment);
    clearTimeout(this._appointmentClickTimeout);
    this._preventSingleAppointmentClick = true;
    this.notifyObserver("showEditAppointmentPopup", {
      data: appointmentData,
      target: $targetAppointment
    });
  }
  _renderItem(index, item, container) {
    const {
      itemData
    } = item;
    const $items = [];
    for (let i = 0; i < item.settings.length; i++) {
      const setting = item.settings[i];
      this._currentAppointmentSettings = setting;
      const $item = super._renderItem(index, itemData, container);
      $item.data(APPOINTMENT_SETTINGS_KEY, setting);
      $items.push($item);
    }
    return $items;
  }
  _getItemContent($itemFrame) {
    $itemFrame.data(APPOINTMENT_SETTINGS_KEY, this._currentAppointmentSettings);
    const $itemContent = super._getItemContent($itemFrame);
    return $itemContent;
  }
  _createItemByTemplate(itemTemplate, renderArgs) {
    const {
      itemData,
      container,
      index
    } = renderArgs;
    return itemTemplate.render({
      model: {
        appointmentData: itemData,
        targetedAppointmentData: this.invoke("getTargetedAppointmentData", itemData, renderer_default(container).parent())
      },
      container,
      index
    });
  }
  _getAppointmentContainer(allDay) {
    const $allDayContainer = this.option("allDayContainer");
    let $container = this.itemsContainer().not($allDayContainer);
    if (allDay && $allDayContainer) {
      $container = $allDayContainer;
    }
    return $container;
  }
  _postprocessRenderItem(args) {
    this._renderAppointment(args.itemElement, this._currentAppointmentSettings);
  }
  _renderAppointment(element, settings) {
    element.data(APPOINTMENT_SETTINGS_KEY, settings);
    this._applyResourceDataAttr(element);
    const rawAppointment = this._getItemData(element);
    const geometry = this.invoke("getAppointmentGeometry", settings);
    const allowResize = this.option("allowResize") && (!isDefined(settings.skipResizing) || isString(settings.skipResizing));
    const allowDrag = this.option("allowDrag");
    const {
      allDay
    } = settings;
    this.invoke("setCellDataCacheAlias", this._currentAppointmentSettings, geometry);
    if (settings.virtual) {
      const appointmentConfig = {
        itemData: rawAppointment,
        groupIndex: settings.groupIndex,
        groups: this.option("groups")
      };
      const deferredColor = this.option("getAppointmentColor")(appointmentConfig);
      this._processVirtualAppointment(settings, element, rawAppointment, deferredColor);
    } else {
      var _settings$info;
      const config = {
        data: rawAppointment,
        groupIndex: settings.groupIndex,
        observer: this.option("observer"),
        geometry,
        direction: settings.direction || "vertical",
        allowResize,
        allowDrag,
        allDay,
        reduced: settings.appointmentReduced,
        isCompact: settings.isCompact,
        startDate: new Date(null === (_settings$info = settings.info) || void 0 === _settings$info ? void 0 : _settings$info.appointment.startDate),
        cellWidth: this.invoke("getCellWidth"),
        cellHeight: this.invoke("getCellHeight"),
        resizableConfig: this._resizableConfig(rawAppointment, settings),
        groups: this.option("groups"),
        getAppointmentColor: this.option("getAppointmentColor"),
        getResourceDataAccessors: this.option("getResourceDataAccessors")
      };
      if (this.isAgendaView) {
        const agendaResourceProcessor = this.option("getAgendaResourceProcessor")();
        config.createPlainResourceListAsync = (rawAppointment2) => agendaResourceProcessor.createListAsync(rawAppointment2);
      }
      this._createComponent(element, this.isAgendaView ? AgendaAppointment : Appointment, _extends({}, config, {
        dataAccessors: this.option("dataAccessors"),
        getResizableStep: this.option("getResizableStep")
      }));
    }
  }
  _applyResourceDataAttr($appointment) {
    const dataAccessors = this.option("getResourceDataAccessors")();
    const rawAppointment = this._getItemData($appointment);
    each(dataAccessors.getter, (key) => {
      const value2 = dataAccessors.getter[key](rawAppointment);
      if (isDefined(value2)) {
        const prefix = `data-${normalizeKey(key.toLowerCase())}-`;
        wrapToArray(value2).forEach((value3) => $appointment.attr(prefix + normalizeKey(value3), true));
      }
    });
  }
  _resizableConfig(appointmentData, itemSetting) {
    return {
      area: this._calculateResizableArea(itemSetting, appointmentData),
      onResizeStart: (function(e) {
        this.resizeOccur = true;
        this._$currentAppointment = renderer_default(e.element);
        if (this.invoke("needRecalculateResizableArea")) {
          const updatedArea = this._calculateResizableArea(this._$currentAppointment.data(APPOINTMENT_SETTINGS_KEY), this._$currentAppointment.data("dxItemData"));
          e.component.option("area", updatedArea);
          e.component._renderDragOffsets(e.event);
        }
        this._initialSize = {
          width: e.width,
          height: e.height
        };
        this._initialCoordinates = locate(this._$currentAppointment);
      }).bind(this),
      onResizeEnd: (function(e) {
        this.resizeOccur = false;
        this._resizeEndHandler(e);
      }).bind(this)
    };
  }
  _calculateResizableArea(itemSetting, appointmentData) {
    const area = this.$element().closest(".dx-scrollable-content");
    return this.invoke("getResizableAppointmentArea", {
      coordinates: {
        left: itemSetting.left,
        top: 0,
        groupIndex: itemSetting.groupIndex
      },
      allDay: itemSetting.allDay
    }) || area;
  }
  _resizeEndHandler(e) {
    const $element = renderer_default(e.element);
    const {
      allDay,
      info
    } = $element.data("dxAppointmentSettings");
    const sourceAppointment = this._getItemData($element);
    const viewOffset = this.invoke("getViewOffsetMs");
    let dateRange;
    if (allDay) {
      dateRange = this.resizeAllDay(e);
    } else {
      const startDate = this._getEndResizeAppointmentStartDate(e, sourceAppointment, info.appointment);
      const {
        endDate
      } = info.appointment;
      const shiftedStartDate = dateUtilsTs.addOffsets(startDate, [-viewOffset]);
      const shiftedEndDate = dateUtilsTs.addOffsets(endDate, [-viewOffset]);
      dateRange = this._getDateRange(e, shiftedStartDate, shiftedEndDate);
      dateRange.startDate = dateUtilsTs.addOffsets(dateRange.startDate, [viewOffset]);
      dateRange.endDate = dateUtilsTs.addOffsets(dateRange.endDate, [viewOffset]);
    }
    this.updateResizedAppointment($element, dateRange, this.option("dataAccessors"), this.option("timeZoneCalculator"));
  }
  resizeAllDay(e) {
    const $element = renderer_default(e.element);
    const timeZoneCalculator = this.option("timeZoneCalculator");
    const dataAccessors = this.option("dataAccessors");
    return getAppointmentDateRange({
      handles: e.handles,
      appointmentSettings: $element.data("dxAppointmentSettings"),
      isVerticalViewDirection: this.option("isVerticalViewDirection")(),
      isVerticalGroupedWorkSpace: this.option("isVerticalGroupedWorkSpace")(),
      appointmentRect: getBoundingRect($element[0]),
      parentAppointmentRect: getBoundingRect($element.parent()[0]),
      viewDataProvider: this.option("getViewDataProvider")(),
      isDateAndTimeView: this.option("isDateAndTimeView")(),
      startDayHour: this.invoke("getStartDayHour"),
      endDayHour: this.invoke("getEndDayHour"),
      timeZoneCalculator,
      dataAccessors,
      rtlEnabled: this.option("rtlEnabled"),
      DOMMetaData: this.option("getDOMElementsMetaData")(),
      viewOffset: this.invoke("getViewOffsetMs")
    });
  }
  updateResizedAppointment($element, dateRange, dataAccessors, timeZoneCalculator) {
    const sourceAppointment = this._getItemData($element);
    const modifiedAppointmentAdapter = createAppointmentAdapter(sourceAppointment, dataAccessors, timeZoneCalculator).clone();
    modifiedAppointmentAdapter.startDate = new Date(dateRange.startDate);
    modifiedAppointmentAdapter.endDate = new Date(dateRange.endDate);
    this.notifyObserver("updateAppointmentAfterResize", {
      target: sourceAppointment,
      data: modifiedAppointmentAdapter.clone({
        pathTimeZone: "fromGrid"
      }).source(),
      $appointment: $element
    });
  }
  _getEndResizeAppointmentStartDate(e, rawAppointment, appointmentInfo) {
    const timeZoneCalculator = this.option("timeZoneCalculator");
    const appointmentAdapter = createAppointmentAdapter(rawAppointment, this.option("dataAccessors"), timeZoneCalculator);
    let {
      startDate
    } = appointmentInfo;
    const recurrenceProcessor = getRecurrenceProcessor();
    const {
      recurrenceRule,
      startDateTimeZone
    } = appointmentAdapter;
    const isAllDay = this.invoke("isAllDay", rawAppointment);
    const isRecurrent = recurrenceProcessor.isValidRecurrenceRule(recurrenceRule);
    if (!e.handles.top && !isRecurrent && !isAllDay) {
      startDate = timeZoneCalculator.createDate(appointmentAdapter.startDate, {
        appointmentTimeZone: startDateTimeZone,
        path: "toGrid"
      });
    }
    return startDate;
  }
  _getDateRange(e, startDate, endDate) {
    const itemData = this._getItemData(e.element);
    const deltaTime = this.invoke("getDeltaTime", e, this._initialSize, itemData);
    const renderingStrategyDirection = this.invoke("getRenderingStrategyDirection");
    let isStartDateChanged = false;
    const isAllDay = this.invoke("isAllDay", itemData);
    const needCorrectDates = this.invoke("needCorrectAppointmentDates") && !isAllDay;
    let startTime;
    let endTime;
    if ("vertical" !== renderingStrategyDirection || isAllDay) {
      isStartDateChanged = this.option("rtlEnabled") ? e.handles.right : e.handles.left;
    } else {
      isStartDateChanged = e.handles.top;
    }
    if (isStartDateChanged) {
      startTime = needCorrectDates ? this._correctStartDateByDelta(startDate, deltaTime) : startDate.getTime() - deltaTime;
      startTime += m_utils_time_zone_default.getTimezoneOffsetChangeInMs(startDate, endDate, startTime, endDate);
      endTime = endDate.getTime();
    } else {
      startTime = startDate.getTime();
      endTime = needCorrectDates ? this._correctEndDateByDelta(endDate, deltaTime) : endDate.getTime() + deltaTime;
      endTime -= m_utils_time_zone_default.getTimezoneOffsetChangeInMs(startDate, endDate, startDate, endTime);
    }
    return {
      startDate: new Date(startTime),
      endDate: new Date(endTime)
    };
  }
  _correctEndDateByDelta(endDate, deltaTime) {
    const endDayHour = this.invoke("getEndDayHour");
    const startDayHour = this.invoke("getStartDayHour");
    const maxDate = new Date(endDate);
    const minDate = new Date(endDate);
    const correctEndDate = new Date(endDate);
    minDate.setHours(startDayHour, 0, 0, 0);
    maxDate.setHours(endDayHour, 0, 0, 0);
    if (correctEndDate > maxDate) {
      correctEndDate.setHours(endDayHour, 0, 0, 0);
    }
    let result = correctEndDate.getTime() + deltaTime;
    const visibleDayDuration = (endDayHour - startDayHour) * toMs9("hour");
    const daysCount = deltaTime > 0 ? Math.ceil(deltaTime / visibleDayDuration) : Math.floor(deltaTime / visibleDayDuration);
    if (result > maxDate.getTime() || result <= minDate.getTime()) {
      const tailOfCurrentDay = maxDate.getTime() - correctEndDate.getTime();
      const tailOfPrevDays = deltaTime - tailOfCurrentDay;
      const correctedEndDate = new Date(correctEndDate).setDate(correctEndDate.getDate() + daysCount);
      const lastDay = new Date(correctedEndDate);
      lastDay.setHours(startDayHour, 0, 0, 0);
      result = lastDay.getTime() + tailOfPrevDays - visibleDayDuration * (daysCount - 1);
    }
    return result;
  }
  _correctStartDateByDelta(startDate, deltaTime) {
    const endDayHour = this.invoke("getEndDayHour");
    const startDayHour = this.invoke("getStartDayHour");
    const maxDate = new Date(startDate);
    const minDate = new Date(startDate);
    const correctStartDate = new Date(startDate);
    minDate.setHours(startDayHour, 0, 0, 0);
    maxDate.setHours(endDayHour, 0, 0, 0);
    if (correctStartDate < minDate) {
      correctStartDate.setHours(startDayHour, 0, 0, 0);
    }
    let result = correctStartDate.getTime() - deltaTime;
    const visibleDayDuration = (endDayHour - startDayHour) * toMs9("hour");
    const daysCount = deltaTime > 0 ? Math.ceil(deltaTime / visibleDayDuration) : Math.floor(deltaTime / visibleDayDuration);
    if (result < minDate.getTime() || result >= maxDate.getTime()) {
      const tailOfCurrentDay = correctStartDate.getTime() - minDate.getTime();
      const tailOfPrevDays = deltaTime - tailOfCurrentDay;
      const firstDay = new Date(correctStartDate.setDate(correctStartDate.getDate() - daysCount));
      firstDay.setHours(endDayHour, 0, 0, 0);
      result = firstDay.getTime() - tailOfPrevDays + visibleDayDuration * (daysCount - 1);
    }
    return result;
  }
  _processVirtualAppointment(appointmentSetting, $appointment, appointmentData, color) {
    const virtualAppointment = appointmentSetting.virtual;
    const virtualGroupIndex = virtualAppointment.index;
    if (!isDefined(this._virtualAppointments[virtualGroupIndex])) {
      this._virtualAppointments[virtualGroupIndex] = {
        coordinates: {
          top: virtualAppointment.top,
          left: virtualAppointment.left
        },
        items: {
          data: [],
          colors: [],
          settings: []
        },
        isAllDay: !!virtualAppointment.isAllDay,
        buttonColor: color
      };
    }
    appointmentSetting.targetedAppointmentData = this.invoke("getTargetedAppointmentData", appointmentData, $appointment);
    this._virtualAppointments[virtualGroupIndex].items.settings.push(appointmentSetting);
    this._virtualAppointments[virtualGroupIndex].items.data.push(appointmentData);
    this._virtualAppointments[virtualGroupIndex].items.colors.push(color);
    $appointment.remove();
  }
  _renderContentImpl() {
    super._renderContentImpl();
    this._renderDropDownAppointments();
  }
  _renderDropDownAppointments() {
    this._renderByFragments(($commonFragment, $allDayFragment) => {
      each(this._virtualAppointments, (groupIndex) => {
        const virtualGroup = this._virtualAppointments[groupIndex];
        const virtualItems = virtualGroup.items;
        const virtualCoordinates = virtualGroup.coordinates;
        const $fragment = virtualGroup.isAllDay ? $allDayFragment : $commonFragment;
        const {
          left
        } = virtualCoordinates;
        const buttonWidth = this.invoke("getDropDownAppointmentWidth", virtualGroup.isAllDay);
        const buttonHeight = this.invoke("getDropDownAppointmentHeight");
        const rtlOffset = this.option("rtlEnabled") ? buttonWidth : 0;
        this.notifyObserver("renderCompactAppointments", {
          $container: $fragment,
          coordinates: {
            top: virtualCoordinates.top,
            left: left + rtlOffset
          },
          items: virtualItems,
          buttonColor: virtualGroup.buttonColor,
          width: buttonWidth - this.option("_collectorOffset"),
          height: buttonHeight,
          onAppointmentClick: this.option("onItemClick"),
          allowDrag: this.option("allowDrag"),
          cellWidth: this.invoke("getCellWidth"),
          isCompact: this.invoke("isAdaptive") || this._isGroupCompact(virtualGroup)
        });
      });
    });
  }
  _isGroupCompact(virtualGroup) {
    return !virtualGroup.isAllDay && this.invoke("supportCompactDropDownAppointments");
  }
  _sortAppointmentsByStartDate(appointments) {
    return sortAppointmentsByStartDate(appointments, this.option("dataAccessors"));
  }
  _processRecurrenceAppointment(appointment, index, skipLongAppointments) {
    const recurrenceRule = ExpressionUtils.getField(this.option("dataAccessors"), "recurrenceRule", appointment);
    const result = {
      parts: [],
      indexes: []
    };
    if (recurrenceRule) {
      const dates = appointment.settings || appointment;
      const startDate = new Date(ExpressionUtils.getField(this.option("dataAccessors"), "startDate", dates));
      const startDateTimeZone = ExpressionUtils.getField(this.option("dataAccessors"), "startDateTimeZone", appointment);
      const endDate = new Date(ExpressionUtils.getField(this.option("dataAccessors"), "endDate", dates));
      const appointmentDuration = endDate.getTime() - startDate.getTime();
      const recurrenceException = ExpressionUtils.getField(this.option("dataAccessors"), "recurrenceException", appointment);
      const startViewDate = this.invoke("getStartViewDate");
      const endViewDate = this.invoke("getEndViewDate");
      const timezoneCalculator = this.option("timeZoneCalculator");
      const recurrentDates = getRecurrenceProcessor().generateDates({
        rule: recurrenceRule,
        exception: recurrenceException,
        start: startDate,
        end: endDate,
        min: startViewDate,
        max: endViewDate,
        appointmentTimezoneOffset: timezoneCalculator.getOriginStartDateOffsetInMs(startDate, startDateTimeZone, false)
      });
      const recurrentDateCount = appointment.settings ? 1 : recurrentDates.length;
      for (let i = 0; i < recurrentDateCount; i++) {
        const appointmentPart = extend({}, appointment, true);
        if (recurrentDates[i]) {
          const appointmentSettings = this._applyStartDateToObj(recurrentDates[i], {});
          this._applyEndDateToObj(new Date(recurrentDates[i].getTime() + appointmentDuration), appointmentSettings);
          appointmentPart.settings = appointmentSettings;
        } else {
          appointmentPart.settings = dates;
        }
        result.parts.push(appointmentPart);
        if (!skipLongAppointments) {
          this._processLongAppointment(appointmentPart, result);
        }
      }
      result.indexes.push(index);
    }
    return result;
  }
  _processLongAppointment(appointment, result) {
    const parts = this.splitAppointmentByDay(appointment);
    const partCount = parts.length;
    const endViewDate = this.invoke("getEndViewDate").getTime();
    const startViewDate = this.invoke("getStartViewDate").getTime();
    const timeZoneCalculator = this.option("timeZoneCalculator");
    result = result || {
      parts: []
    };
    if (partCount > 1) {
      extend(appointment, parts[0]);
      for (let i = 1; i < partCount; i++) {
        let startDate = ExpressionUtils.getField(this.option("dataAccessors"), "startDate", parts[i].settings).getTime();
        startDate = timeZoneCalculator.createDate(startDate, {
          path: "toGrid"
        });
        if (startDate < endViewDate && startDate > startViewDate) {
          result.parts.push(parts[i]);
        }
      }
    }
    return result;
  }
  _reduceRecurrenceAppointments(recurrenceIndexes, appointments) {
    each(recurrenceIndexes, (i, index) => {
      appointments.splice(index - i, 1);
    });
  }
  _combineAppointments(appointments, additionalAppointments) {
    if (additionalAppointments.length) {
      appointments.push(...additionalAppointments);
    }
    this._sortAppointmentsByStartDate(appointments);
  }
  _applyStartDateToObj(startDate, obj) {
    ExpressionUtils.setField(this.option("dataAccessors"), "startDate", obj, startDate);
    return obj;
  }
  _applyEndDateToObj(endDate, obj) {
    ExpressionUtils.setField(this.option("dataAccessors"), "endDate", obj, endDate);
    return obj;
  }
  moveAppointmentBack(dragEvent) {
    const $appointment = this._$currentAppointment;
    const size = this._initialSize;
    const coords = this._initialCoordinates;
    if (dragEvent) {
      this._removeDragSourceClassFromDraggedAppointment();
      if (isDeferred(dragEvent.cancel)) {
        dragEvent.cancel.resolve(true);
      } else {
        dragEvent.cancel = true;
      }
    }
    if ($appointment && !dragEvent) {
      if (coords) {
        move($appointment, coords);
        delete this._initialSize;
      }
      if (size) {
        setOuterWidth($appointment, size.width);
        setOuterHeight($appointment, size.height);
        delete this._initialCoordinates;
      }
    }
  }
  focus() {
    if (this._$currentAppointment) {
      const focusedElement = getPublicElement(this._$currentAppointment);
      this.option("focusedElement", focusedElement);
      events_engine_default.trigger(focusedElement, "focus");
    }
  }
  splitAppointmentByDay(appointment) {
    const dates = appointment.settings || appointment;
    const dataAccessors = this.option("dataAccessors");
    const originalStartDate = new Date(ExpressionUtils.getField(dataAccessors, "startDate", dates));
    let startDate = date_default2.makeDate(originalStartDate);
    let endDate = date_default2.makeDate(ExpressionUtils.getField(dataAccessors, "endDate", dates));
    const maxAllowedDate = this.invoke("getEndViewDate");
    const startDayHour = this.invoke("getStartDayHour");
    const endDayHour = this.invoke("getEndDayHour");
    const timeZoneCalculator = this.option("timeZoneCalculator");
    const adapter = createAppointmentAdapter(appointment, dataAccessors, timeZoneCalculator);
    const appointmentIsLong = getAppointmentTakesSeveralDays(adapter);
    const result = [];
    startDate = timeZoneCalculator.createDate(startDate, {
      path: "toGrid"
    });
    endDate = timeZoneCalculator.createDate(endDate, {
      path: "toGrid"
    });
    if (startDate.getHours() <= endDayHour && startDate.getHours() >= startDayHour && !appointmentIsLong) {
      result.push(this._applyStartDateToObj(new Date(startDate), {
        appointmentData: appointment
      }));
      startDate.setDate(startDate.getDate() + 1);
    }
    while (appointmentIsLong && startDate.getTime() < endDate.getTime() && startDate < maxAllowedDate) {
      const currentStartDate = new Date(startDate);
      const currentEndDate = new Date(startDate);
      this._checkStartDate(currentStartDate, originalStartDate, startDayHour);
      this._checkEndDate(currentEndDate, endDate, endDayHour);
      const appointmentData = deepExtendArraySafe({}, appointment, true);
      const appointmentSettings = {};
      this._applyStartDateToObj(currentStartDate, appointmentSettings);
      this._applyEndDateToObj(currentEndDate, appointmentSettings);
      appointmentData.settings = appointmentSettings;
      result.push(appointmentData);
      startDate = date_default2.trimTime(startDate);
      startDate.setDate(startDate.getDate() + 1);
      startDate.setHours(startDayHour);
    }
    return result;
  }
  _checkStartDate(currentDate, originalDate, startDayHour) {
    if (!date_default2.sameDate(currentDate, originalDate) || currentDate.getHours() <= startDayHour) {
      currentDate.setHours(startDayHour, 0, 0, 0);
    } else {
      currentDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());
    }
  }
  _checkEndDate(currentDate, originalDate, endDayHour) {
    if (!date_default2.sameDate(currentDate, originalDate) || currentDate.getHours() > endDayHour) {
      currentDate.setHours(endDayHour, 0, 0, 0);
    } else {
      currentDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());
    }
  }
  _removeDragSourceClassFromDraggedAppointment() {
    const $appointments = this._itemElements().filter(`.${APPOINTMENT_DRAG_SOURCE_CLASS}`);
    $appointments.each((_, element) => {
      const appointmentInstance = renderer_default(element).dxSchedulerAppointment("instance");
      appointmentInstance.option("isDragSource", false);
    });
  }
  _setDragSourceAppointment(appointment, settings) {
    const $appointments = this._findItemElementByItem(appointment);
    const {
      startDate,
      endDate
    } = settings.info.sourceAppointment;
    const {
      groupIndex
    } = settings;
    $appointments.forEach(($item) => {
      const {
        info: itemInfo,
        groupIndex: itemGroupIndex
      } = $item.data(APPOINTMENT_SETTINGS_KEY);
      const {
        startDate: itemStartDate,
        endDate: itemEndDate
      } = itemInfo.sourceAppointment;
      const appointmentInstance = $item.dxSchedulerAppointment("instance");
      const isDragSource = startDate.getTime() === itemStartDate.getTime() && endDate.getTime() === itemEndDate.getTime() && groupIndex === itemGroupIndex;
      appointmentInstance.option("isDragSource", isDragSource);
    });
  }
  updateResizableArea() {
    const $allResizableElements = this.$element().find(".dx-scheduler-appointment.dx-resizable");
    const horizontalResizables = grep($allResizableElements, (el) => {
      const $el = renderer_default(el);
      const resizableInst = $el.dxResizable("instance");
      const {
        area,
        handles
      } = resizableInst.option();
      return ("right left" === handles || "left right" === handles) && isPlainObject(area);
    });
    each(horizontalResizables, (_, el) => {
      const $el = renderer_default(el);
      const position = locate($el);
      const appointmentData = this._getItemData($el);
      const area = this._calculateResizableArea({
        left: position.left
      }, appointmentData);
      $el.dxResizable("instance").option("area", area);
    });
  }
};
component_registrator_default("dxSchedulerAppointments", SchedulerAppointments);
var m_appointment_collection_default = SchedulerAppointments;

// ../../../../../../node_modules/devextreme/esm/__internal/data_controller.js
var DataController = class {
  constructor(dataSourceOptions, _ref) {
    let {
      key
    } = _ref;
    this._isSharedDataSource = false;
    this._keyExpr = key;
    this.updateDataSource(dataSourceOptions);
  }
  _updateDataSource(dataSourceOptions) {
    if (!dataSourceOptions) {
      return;
    }
    if (dataSourceOptions instanceof DataSource) {
      this._isSharedDataSource = true;
      this._dataSource = dataSourceOptions;
    } else {
      const normalizedDataSourceOptions = normalizeDataSourceOptions(dataSourceOptions);
      this._dataSource = new DataSource(extend(true, {}, {}, normalizedDataSourceOptions));
    }
  }
  _updateDataSourceByItems(items) {
    this._dataSource = new DataSource({
      store: new array_store_default({
        key: this.key(),
        data: items
      }),
      pageSize: 0
    });
  }
  _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        this._isSharedDataSource = false;
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
    }
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(propName, propValue) {
    if (!this._dataSource) {
      return new Deferred().reject();
    }
    let pName = propName;
    let pValue = propValue;
    if (arguments.length < 2) {
      pValue = propName;
      pName = this.key();
    }
    return this._dataSource.loadSingle(pName, pValue);
  }
  loadFromStore(loadOptions) {
    return this.store().load(loadOptions);
  }
  loadNextPage() {
    this.pageIndex(1 + this.pageIndex());
    return this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(operationId) {
    this._dataSource.cancel(operationId);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(filter) {
    return this._dataSource.filter(filter);
  }
  addSearchFilter(storeLoadOptions) {
    this._dataSource._addSearchFilter(storeLoadOptions);
  }
  group(group) {
    return this._dataSource.group(group);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(pageIndex) {
    if (void 0 === pageIndex) {
      return this._dataSource.pageIndex(void 0);
    }
    return this._dataSource.pageIndex(pageIndex);
  }
  resetDataSource() {
    this._disposeDataSource();
  }
  resetDataSourcePageIndex() {
    if (this.pageIndex()) {
      this.pageIndex(0);
      this.load();
    }
  }
  updateDataSource(items, key) {
    const dataSourceOptions = items ?? this.items();
    if (key) {
      this._keyExpr = key;
    }
    this._disposeDataSource();
    if (Array.isArray(dataSourceOptions)) {
      this._updateDataSourceByItems(dataSourceOptions);
    } else {
      this._updateDataSource(dataSourceOptions);
    }
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(value2) {
    return this._dataSource.searchValue(value2);
  }
  searchOperation(operation) {
    return this._dataSource.searchOperation(operation);
  }
  searchExpr(expr) {
    return this._dataSource.searchExpr(expr);
  }
  select() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this._dataSource.select(args);
  }
  key() {
    var _this$_dataSource;
    const storeKey = null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.key();
    return isDefined(storeKey) && "this" === this._keyExpr ? storeKey : this._keyExpr;
  }
  keyOf(item) {
    return this.store().keyOf(item);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    var _this$_dataSource2;
    return null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 ? void 0 : _this$_dataSource2.items();
  }
  applyMapFunction(data2) {
    return this._dataSource._applyMapFunction(data2);
  }
  getDataSource() {
    return this._dataSource ?? null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(event, handler) {
    this._dataSource.on(event, handler);
  }
  off(event, handler) {
    this._dataSource.off(event, handler);
  }
};
var data_controller_default = DataController;

// ../../../../../../node_modules/devextreme/esm/data_controller.js
var data_controller_default2 = data_controller_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_drop_down_button.js
var DROP_DOWN_BUTTON_CONTENT = "dx-dropdownbutton-content";
var DropDownButton = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      itemTemplate: "item",
      keyExpr: "this",
      displayExpr: void 0,
      selectedItem: null,
      selectedItemKey: null,
      stylingMode: "outlined",
      deferRendering: true,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      useSelectMode: false,
      splitButton: false,
      showArrowIcon: true,
      template: null,
      text: "",
      type: "normal",
      icon: void 0,
      onButtonClick: null,
      onSelectionChanged: null,
      onItemClick: null,
      opened: false,
      items: null,
      dataSource: null,
      focusStateEnabled: true,
      hoverStateEnabled: true,
      dropDownOptions: {},
      dropDownContentTemplate: "content",
      wrapItemText: false,
      useItemTextAsTitle: true,
      grouped: false,
      groupTemplate: "group",
      buttonGroupOptions: {}
    });
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      selectedItem: true
    });
  },
  _init() {
    this.callBase();
    this._createItemClickAction();
    this._createActionClickAction();
    this._createSelectionChangedAction();
    this._initDataController();
    this._compileKeyGetter();
    this._compileDisplayGetter();
    this._options.cache("buttonGroupOptions", this.option("buttonGroupOptions"));
    this._options.cache("dropDownOptions", this.option("dropDownOptions"));
  },
  _initDataController() {
    const dataSource = this.option("dataSource");
    this._dataController = new data_controller_default2(dataSource ?? this.option("items"), {
      key: this.option("keyExpr")
    });
  },
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new FunctionTemplate((options) => {
        const $popupContent = renderer_default(options.container);
        const $listContainer = renderer_default("<div>").appendTo($popupContent);
        this._list = this._createComponent($listContainer, list_light_default, this._listOptions());
        this._list.registerKeyHandler("escape", this._escHandler.bind(this));
        this._list.registerKeyHandler("tab", this._escHandler.bind(this));
        this._list.registerKeyHandler("leftArrow", this._escHandler.bind(this));
        this._list.registerKeyHandler("rightArrow", this._escHandler.bind(this));
      })
    });
    this.callBase();
  },
  _compileKeyGetter() {
    this._keyGetter = compileGetter(this._dataController.key());
  },
  _compileDisplayGetter() {
    this._displayGetter = compileGetter(this.option("displayExpr"));
  },
  _initMarkup() {
    this.callBase();
    this.$element().addClass("dx-dropdownbutton");
    this._renderButtonGroup();
    this._updateArrowClass();
    if (isDefined(this.option("selectedItemKey"))) {
      this._loadSelectedItem().done(this._updateActionButton.bind(this));
    }
  },
  _renderFocusTarget: noop,
  _render() {
    if (!this.option("deferRendering") || this.option("opened")) {
      this._renderPopup();
    }
    this.callBase();
  },
  _renderContentImpl() {
    if (this._popup) {
      this._renderPopupContent();
    }
    return this.callBase();
  },
  _loadSelectedItem() {
    var _this$_loadSingleDefe;
    null === (_this$_loadSingleDefe = this._loadSingleDeferred) || void 0 === _this$_loadSingleDefe || _this$_loadSingleDefe.reject();
    const d = Deferred();
    if (this._list && void 0 !== this._lastSelectedItemData) {
      const cachedResult = this.option("useSelectMode") ? this._list.option("selectedItem") : this._lastSelectedItemData;
      return d.resolve(cachedResult);
    }
    this._lastSelectedItemData = void 0;
    const selectedItemKey = this.option("selectedItemKey");
    this._dataController.loadSingle(selectedItemKey).done(d.resolve).fail(() => {
      d.reject(null);
    });
    this._loadSingleDeferred = d;
    return d.promise();
  },
  _createActionClickAction() {
    this._actionClickAction = this._createActionByOption("onButtonClick");
  },
  _createSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged");
  },
  _createItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  },
  _fireSelectionChangedAction(_ref) {
    let {
      previousValue,
      value: value2
    } = _ref;
    this._selectionChangedAction({
      item: value2,
      previousItem: previousValue
    });
  },
  _fireItemClickAction(_ref2) {
    let {
      event,
      itemElement,
      itemData
    } = _ref2;
    return this._itemClickAction({
      event,
      itemElement,
      itemData: this._actionItem || itemData
    });
  },
  _getButtonTemplate() {
    const {
      template,
      splitButton,
      showArrowIcon
    } = this.option();
    if (template) {
      return template;
    }
    return splitButton || !showArrowIcon ? "content" : (_ref3, buttonContent) => {
      let {
        text,
        icon
      } = _ref3;
      const $firstIcon = getImageContainer(icon);
      const $textContainer = text ? renderer_default("<span>").text(text).addClass("dx-button-text") : void 0;
      const $secondIcon = getImageContainer("spindown").addClass("dx-icon-right");
      renderer_default(buttonContent).append($firstIcon, $textContainer, $secondIcon);
    };
  },
  _getActionButtonConfig() {
    const {
      icon,
      text,
      type,
      splitButton
    } = this.option();
    const actionButtonConfig = {
      text,
      icon,
      type,
      template: this._getButtonTemplate(),
      elementAttr: {
        class: "dx-dropdownbutton-action"
      }
    };
    if (splitButton) {
      actionButtonConfig.elementAttr.role = "menuitem";
    }
    return actionButtonConfig;
  },
  _getSpinButtonConfig() {
    const {
      type
    } = this.option();
    const config = {
      type,
      icon: "spindown",
      elementAttr: {
        class: "dx-dropdownbutton-toggle",
        role: "menuitem"
      }
    };
    return config;
  },
  _getButtonGroupItems() {
    const {
      splitButton
    } = this.option();
    const items = [this._getActionButtonConfig()];
    if (splitButton) {
      items.push(this._getSpinButtonConfig());
    }
    return items;
  },
  _buttonGroupItemClick(_ref4) {
    let {
      event,
      itemData
    } = _ref4;
    const isActionButton = "dx-dropdownbutton-action" === itemData.elementAttr.class;
    const isToggleButton = "dx-dropdownbutton-toggle" === itemData.elementAttr.class;
    if (isToggleButton) {
      this.toggle();
    } else if (isActionButton) {
      this._actionClickAction({
        event,
        selectedItem: this.option("selectedItem")
      });
      if (!this.option("splitButton")) {
        this.toggle();
      }
    }
  },
  _getButtonGroupOptions() {
    const {
      accessKey,
      focusStateEnabled,
      hoverStateEnabled,
      splitButton,
      stylingMode,
      tabIndex
    } = this.option();
    const buttonGroupOptions = extend({
      items: this._getButtonGroupItems(),
      width: "100%",
      height: "100%",
      selectionMode: "none",
      focusStateEnabled,
      hoverStateEnabled,
      stylingMode,
      accessKey,
      tabIndex,
      elementAttr: {
        role: splitButton ? "menu" : "group"
      },
      onItemClick: this._buttonGroupItemClick.bind(this),
      onKeyboardHandled: (e) => this._keyboardHandler(e)
    }, this._options.cache("buttonGroupOptions"));
    return buttonGroupOptions;
  },
  _renderPopupContent() {
    const $content = this._popup.$content();
    const template = this._getTemplateByOption("dropDownContentTemplate");
    $content.empty();
    this._popupContentId = `dx-${new guid_default()}`;
    this.setAria("id", this._popupContentId, $content);
    return template.render({
      container: getPublicElement($content),
      model: this.option("items") || this._dataController.getDataSource()
    });
  },
  _popupOptions() {
    const horizontalAlignment = this.option("rtlEnabled") ? "right" : "left";
    return extend({
      dragEnabled: false,
      focusStateEnabled: false,
      deferRendering: this.option("deferRendering"),
      hideOnOutsideClick: (e) => {
        const $element = this.$element();
        const $buttonClicked = renderer_default(e.target).closest(".dx-dropdownbutton");
        return !$buttonClicked.is($element);
      },
      showTitle: false,
      animation: {
        show: {
          type: "fade",
          duration: 0,
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          duration: 400,
          from: 1,
          to: 0
        }
      },
      _ignoreFunctionValueDeprecation: true,
      width: () => getElementWidth(this.$element()),
      height: "auto",
      shading: false,
      position: {
        of: this.$element(),
        collision: "flipfit",
        my: `${horizontalAlignment} top`,
        at: `${horizontalAlignment} bottom`
      },
      _wrapperClassExternal: "dx-dropdowneditor-overlay"
    }, this._options.cache("dropDownOptions"), {
      visible: this.option("opened")
    });
  },
  _listOptions() {
    const selectedItemKey = this.option("selectedItemKey");
    const useSelectMode = this.option("useSelectMode");
    return {
      selectionMode: useSelectMode ? "single" : "none",
      wrapItemText: this.option("wrapItemText"),
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      useItemTextAsTitle: this.option("useItemTextAsTitle"),
      onContentReady: () => this._fireContentReadyAction(),
      selectedItemKeys: isDefined(selectedItemKey) && useSelectMode ? [selectedItemKey] : [],
      grouped: this.option("grouped"),
      groupTemplate: this.option("groupTemplate"),
      keyExpr: this._dataController.key(),
      noDataText: this.option("noDataText"),
      displayExpr: this.option("displayExpr"),
      itemTemplate: this.option("itemTemplate"),
      items: this.option("items"),
      dataSource: this._dataController.getDataSource(),
      onItemClick: (e) => {
        if (!this.option("useSelectMode")) {
          this._lastSelectedItemData = e.itemData;
        }
        this.option("selectedItemKey", this._keyGetter(e.itemData));
        const actionResult = this._fireItemClickAction(e);
        if (false !== actionResult) {
          this.toggle(false);
          this._buttonGroup.focus();
        }
      }
    };
  },
  _upDownKeyHandler() {
    if (this._popup && this._popup.option("visible") && this._list) {
      this._list.focus();
    } else {
      this.open();
    }
    return true;
  },
  _escHandler() {
    this.close();
    this._buttonGroup.focus();
    return true;
  },
  _tabHandler() {
    this.close();
    return true;
  },
  _renderPopup() {
    const $popup = renderer_default("<div>");
    this.$element().append($popup);
    this._popup = this._createComponent($popup, ui_popup_default, this._popupOptions());
    this._popup.$content().addClass(DROP_DOWN_BUTTON_CONTENT);
    this._popup.$wrapper().addClass("dx-dropdownbutton-popup-wrapper");
    this._popup.$overlayContent().attr("aria-label", "Dropdown");
    this._popup.on("hiding", this._popupHidingHandler.bind(this));
    this._popup.on("showing", this._popupShowingHandler.bind(this));
    this._bindInnerWidgetOptions(this._popup, "dropDownOptions");
  },
  _popupHidingHandler() {
    this.option("opened", false);
    this._updateAriaAttributes(false);
  },
  _popupOptionChanged(args) {
    const options = ui_widget_default.getOptionsFromContainer(args);
    this._setPopupOption(options);
    const optionsKeys = Object.keys(options);
    if (optionsKeys.includes("width") || optionsKeys.includes("height")) {
      this._dimensionChanged();
    }
  },
  _dimensionChanged() {
    const popupWidth = getSizeValue(this.option("dropDownOptions.width"));
    if (void 0 === popupWidth) {
      this._setPopupOption("width", () => getElementWidth(this.$element()));
    }
  },
  _setPopupOption(optionName, value2) {
    this._setWidgetOption("_popup", arguments);
  },
  _popupShowingHandler() {
    this.option("opened", true);
    this._updateAriaAttributes(true);
  },
  _setElementAria(value2) {
    const elementAria = {
      owns: value2 ? this._popupContentId : void 0
    };
    this.setAria(elementAria, this.$element());
  },
  _setButtonsAria(value2) {
    const commonButtonAria = {
      expanded: value2,
      haspopup: "listbox"
    };
    const firstButtonAria = {};
    if (!this.option("text")) {
      firstButtonAria.label = "dropdownbutton";
    }
    this._getButtons().each((index, $button) => {
      if (0 === index) {
        this.setAria(_extends({}, firstButtonAria, commonButtonAria), renderer_default($button));
      } else {
        this.setAria(commonButtonAria, renderer_default($button));
      }
    });
  },
  _updateAriaAttributes(value2) {
    this._setElementAria(value2);
    this._setButtonsAria(value2);
  },
  _getButtons() {
    return this._buttonGroup.$element().find(".dx-button");
  },
  _renderButtonGroup() {
    const $buttonGroup = this._buttonGroup && this._buttonGroup.$element() || renderer_default("<div>");
    if (!this._buttonGroup) {
      this.$element().append($buttonGroup);
    }
    this._buttonGroup = this._createComponent($buttonGroup, button_group_default, this._getButtonGroupOptions());
    this._buttonGroup.registerKeyHandler("downArrow", this._upDownKeyHandler.bind(this));
    this._buttonGroup.registerKeyHandler("tab", this._tabHandler.bind(this));
    this._buttonGroup.registerKeyHandler("upArrow", this._upDownKeyHandler.bind(this));
    this._buttonGroup.registerKeyHandler("escape", this._escHandler.bind(this));
    this._bindInnerWidgetOptions(this._buttonGroup, "buttonGroupOptions");
    this._updateAriaAttributes(this.option("opened"));
  },
  _updateArrowClass() {
    const hasArrow = this.option("splitButton") || this.option("showArrowIcon");
    this.$element().toggleClass("dx-dropdownbutton-has-arrow", hasArrow);
  },
  toggle(visible) {
    if (!this._popup) {
      this._renderPopup();
      this._renderContent();
    }
    return this._popup.toggle(visible);
  },
  open() {
    return this.toggle(true);
  },
  close() {
    return this.toggle(false);
  },
  _setListOption(name2, value2) {
    this._list && this._list.option(name2, value2);
  },
  _getDisplayValue(item) {
    const isPrimitiveItem = !isObject(item);
    const displayValue = isPrimitiveItem ? item : this._displayGetter(item);
    return !isObject(displayValue) ? String(ensureDefined(displayValue, "")) : "";
  },
  _updateActionButton(selectedItem) {
    if (this.option("useSelectMode")) {
      this.option({
        text: this._getDisplayValue(selectedItem),
        icon: isPlainObject(selectedItem) ? selectedItem.icon : void 0
      });
    }
    this._setOptionWithoutOptionChange("selectedItem", selectedItem);
    this._setOptionWithoutOptionChange("selectedItemKey", this._keyGetter(selectedItem));
  },
  _clean() {
    this._list && this._list.$element().remove();
    this._popup && this._popup.$element().remove();
  },
  _selectedItemKeyChanged(value2) {
    this._setListOption("selectedItemKeys", this.option("useSelectMode") && isDefined(value2) ? [value2] : []);
    const previousItem = this.option("selectedItem");
    this._loadSelectedItem().always((selectedItem) => {
      this._updateActionButton(selectedItem);
      if (this._displayGetter(previousItem) !== this._displayGetter(selectedItem)) {
        this._fireSelectionChangedAction({
          previousValue: previousItem,
          value: selectedItem
        });
      }
    });
  },
  _updateButtonGroup(name2, value2) {
    this._buttonGroup.option(name2, value2);
    this._updateAriaAttributes(this.option("opened"));
  },
  _actionButtonOptionChanged(_ref5) {
    let {
      name: name2,
      value: value2
    } = _ref5;
    const newConfig = {};
    newConfig[name2] = value2;
    this._updateButtonGroup("items[0]", extend({}, this._getActionButtonConfig(), newConfig));
    this._popup && this._popup.repaint();
  },
  _selectModeChanged(value2) {
    if (value2) {
      this._setListOption("selectionMode", "single");
      const selectedItemKey = this.option("selectedItemKey");
      this._setListOption("selectedItemKeys", isDefined(selectedItemKey) ? [selectedItemKey] : []);
      this._selectedItemKeyChanged(this.option("selectedItemKey"));
    } else {
      this._setListOption("selectionMode", "none");
      this.option({
        selectedItemKey: void 0,
        selectedItem: void 0
      });
      this._actionButtonOptionChanged({
        text: this.option("text")
      });
    }
  },
  _updateItemCollection(optionName) {
    const selectedItemKey = this.option("selectedItemKey");
    this._setListOption("selectedItem", null);
    this._setWidgetOption("_list", [optionName]);
    if (isDefined(selectedItemKey)) {
      this._loadSelectedItem().done((selectedItem) => {
        this._setListOption("selectedItemKeys", [selectedItemKey]);
        this._setListOption("selectedItem", selectedItem);
      }).fail((error) => {
        this._setListOption("selectedItemKeys", []);
      }).always(this._updateActionButton.bind(this));
    }
  },
  _updateDataController(items) {
    this._dataController.updateDataSource(items, this.option("keyExpr"));
    this._updateKeyExpr();
  },
  _updateKeyExpr() {
    this._compileKeyGetter();
    this._setListOption("keyExpr", this._dataController.key());
  },
  focus() {
    this._buttonGroup.focus();
  },
  _optionChanged(args) {
    var _this$_popup;
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "useSelectMode":
        this._selectModeChanged(value2);
        break;
      case "splitButton":
        this._updateArrowClass();
        this._renderButtonGroup();
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._setListOption(name2, value2);
        this._updateActionButton(this.option("selectedItem"));
        break;
      case "keyExpr":
        this._updateDataController();
        break;
      case "buttonGroupOptions":
        this._innerWidgetOptionChanged(this._buttonGroup, args);
        break;
      case "dropDownOptions":
        if ("dropDownOptions.visible" === args.fullName) {
          break;
        }
        if (void 0 !== args.value.visible) {
          delete args.value.visible;
        }
        this._popupOptionChanged(args);
        this._innerWidgetOptionChanged(this._popup, args);
        break;
      case "opened":
        this.toggle(value2);
        break;
      case "focusStateEnabled":
      case "hoverStateEnabled":
        this._setListOption(name2, value2);
        this._updateButtonGroup(name2, value2);
        this.callBase(args);
        break;
      case "items":
        this._updateDataController(this.option("items"));
        this._updateItemCollection(name2);
        break;
      case "dataSource":
        this._dataController.updateDataSource(value2);
        this._updateKeyExpr();
        this._updateItemCollection(name2);
        break;
      case "icon":
      case "text":
        this._actionButtonOptionChanged(args);
        break;
      case "showArrowIcon":
        this._updateArrowClass();
        this._renderButtonGroup();
        this._popup && this._popup.repaint();
        break;
      case "width":
      case "height":
        this.callBase(args);
        null === (_this$_popup = this._popup) || void 0 === _this$_popup || _this$_popup.repaint();
        break;
      case "stylingMode":
      case "tabIndex":
        this._updateButtonGroup(name2, value2);
        break;
      case "type":
        this._updateButtonGroup("items", this._getButtonGroupItems());
        break;
      case "itemTemplate":
      case "grouped":
      case "noDataText":
      case "groupTemplate":
      case "wrapItemText":
      case "useItemTextAsTitle":
        this._setListOption(name2, value2);
        break;
      case "dropDownContentTemplate":
        this._renderContent();
        break;
      case "selectedItemKey":
        this._selectedItemKeyChanged(value2);
        break;
      case "selectedItem":
        break;
      case "onItemClick":
        this._createItemClickAction();
        break;
      case "onButtonClick":
        this._createActionClickAction();
        break;
      case "onSelectionChanged":
        this._createSelectionChangedAction();
        break;
      case "deferRendering":
        this.toggle(this.option("opened"));
        break;
      case "template":
        this._renderButtonGroup();
        break;
      default:
        this.callBase(args);
    }
  },
  getDataSource() {
    return this._dataController.getDataSource();
  }
});
component_registrator_default("dxDropDownButton", DropDownButton);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.utils.js
var TOOLBAR_ITEMS = ["dxAutocomplete", "dxButton", "dxCheckBox", "dxDateBox", "dxMenu", "dxSelectBox", "dxTabs", "dxTextBox", "dxButtonGroup", "dxDropDownButton"];
var getItemInstance = function($element) {
  const itemData = $element.data && $element.data();
  const dxComponents = itemData && itemData.dxComponents;
  const widgetName = dxComponents && dxComponents[0];
  return widgetName && itemData[widgetName];
};
function toggleItemFocusableElementTabIndex(context, item) {
  var _itemData$options;
  if (!context) {
    return;
  }
  const $item = context._findItemElementByItem(item);
  if (!$item.length) {
    return;
  }
  const itemData = context._getItemData($item);
  const isItemNotFocusable = !!(null !== (_itemData$options = itemData.options) && void 0 !== _itemData$options && _itemData$options.disabled || itemData.disabled || context.option("disabled"));
  const {
    widget
  } = itemData;
  if (widget && TOOLBAR_ITEMS.includes(widget)) {
    const $widget = $item.find(widget.toLowerCase().replace("dx", ".dx-"));
    if ($widget.length) {
      var _itemInstance$_focusT, _itemData$options2;
      const itemInstance = getItemInstance($widget);
      if (!itemInstance) {
        return;
      }
      let $focusTarget = null === (_itemInstance$_focusT = itemInstance._focusTarget) || void 0 === _itemInstance$_focusT ? void 0 : _itemInstance$_focusT.call(itemInstance);
      if ("dxDropDownButton" === widget) {
        $focusTarget = $focusTarget && $focusTarget.find(".dx-buttongroup");
      } else {
        $focusTarget = $focusTarget ?? renderer_default(itemInstance.element());
      }
      const tabIndex = null === (_itemData$options2 = itemData.options) || void 0 === _itemData$options2 ? void 0 : _itemData$options2.tabIndex;
      if (isItemNotFocusable) {
        $focusTarget.attr("tabIndex", -1);
      } else {
        $focusTarget.attr("tabIndex", tabIndex ?? 0);
      }
    }
  }
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/strategy/m_toolbar.multiline.js
var MultiLineStrategy = class {
  constructor(toolbar) {
    this._toolbar = toolbar;
  }
  _initMarkup() {
  }
  _updateMenuVisibility() {
  }
  _renderMenuItems() {
  }
  _renderItem() {
  }
  _getMenuItems() {
  }
  _getToolbarItems() {
    return this._toolbar.option("items") ?? [];
  }
  _getItemsWidth() {
    return this._toolbar._getSummaryItemsSize("width", this._toolbar._itemElements(), true);
  }
  _arrangeItems() {
    const $label = this._toolbar._$toolbarItemsContainer.find(".dx-toolbar-label").eq(0);
    if (!$label.length) {
      return;
    }
    const elementWidth = getWidth(this._toolbar.$element());
    const labelPaddings = getOuterWidth($label) - getWidth($label);
    $label.css("maxWidth", elementWidth - labelPaddings);
  }
  _hideOverflowItems() {
  }
  _dimensionChanged() {
  }
  _itemOptionChanged() {
  }
  _optionChanged() {
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/internal/m_toolbar.menu.list.js
var ToolbarMenuList = class extends ListBase {
  _init() {
    super._init();
    this._activeStateUnit = ".dx-toolbar-menu-action:not(.dx-toolbar-hidden-button-group)";
  }
  _initMarkup() {
    this._renderSections();
    super._initMarkup();
    this._setMenuRole();
  }
  _getSections() {
    return this._itemContainer().children();
  }
  _itemElements() {
    return this._getSections().children(this._itemSelector());
  }
  _renderSections() {
    const $container = this._itemContainer();
    each(["before", "center", "after", "menu"], (_, section) => {
      const sectionName = `_$${section}Section`;
      if (!this[sectionName]) {
        this[sectionName] = renderer_default("<div>").addClass("dx-toolbar-menu-section");
      }
      this[sectionName].appendTo($container);
    });
  }
  _renderItems() {
    super._renderItems.apply(this, arguments);
    this._updateSections();
  }
  _setMenuRole() {
    const $menuContainer = this.$element().find(".dx-scrollview-content");
    $menuContainer.attr("role", "menu");
  }
  _updateSections() {
    const $sections = this.$element().find(".dx-toolbar-menu-section");
    $sections.removeClass("dx-toolbar-menu-last-section");
    $sections.not(":empty").eq(-1).addClass("dx-toolbar-menu-last-section");
  }
  _renderItem(index, item, itemContainer, $after) {
    const location = item.location ?? "menu";
    const $container = this[`_$${location}Section`];
    const itemElement = super._renderItem(index, item, $container, $after);
    if (this._getItemTemplateName({
      itemData: item
    })) {
      itemElement.addClass("dx-toolbar-menu-custom");
    }
    if ("menu" === location || "dxButton" === item.widget || "dxButtonGroup" === item.widget || item.isAction) {
      itemElement.addClass("dx-toolbar-menu-action");
    }
    if ("dxButton" === item.widget) {
      itemElement.addClass("dx-toolbar-hidden-button");
    }
    if ("dxButtonGroup" === item.widget) {
      itemElement.addClass("dx-toolbar-hidden-button-group");
    }
    itemElement.addClass(item.cssClass);
    return itemElement;
  }
  _getItemTemplateName(args) {
    const template = super._getItemTemplateName(args);
    const data2 = args.itemData;
    const menuTemplate = data2 && data2.menuItemTemplate;
    return menuTemplate || template;
  }
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _itemClickHandler(e, args, config) {
    if (renderer_default(e.target).closest(".dx-toolbar-menu-action").length) {
      super._itemClickHandler(e, args, config);
    }
  }
  _clean() {
    this._getSections().empty();
    super._clean();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/internal/m_toolbar.menu.js
var DropDownMenu = class extends widget_default {
  _supportedKeys() {
    var _this$_list;
    let extension = {};
    if (!this.option("opened") || !(null !== (_this$_list = this._list) && void 0 !== _this$_list && _this$_list.option("focusedElement"))) {
      extension = this._button._supportedKeys();
    }
    return extend(super._supportedKeys(), extension, {
      tab() {
        this._popup && this._popup.hide();
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      items: [],
      onItemClick: null,
      dataSource: null,
      itemTemplate: "item",
      onButtonClick: null,
      activeStateEnabled: true,
      hoverStateEnabled: true,
      opened: false,
      onItemRendered: null,
      closeOnClick: true,
      useInkRipple: false,
      container: void 0,
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          to: 0
        }
      }
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useInkRipple: true,
        animation: {
          show: {
            type: "pop",
            duration: 200,
            from: {
              scale: 0
            },
            to: {
              scale: 1
            }
          },
          hide: {
            type: "pop",
            duration: 200,
            from: {
              scale: 1
            },
            to: {
              scale: 0
            }
          }
        }
      }
    }]);
  }
  _init() {
    super._init();
    this.$element().addClass("dx-dropdownmenu");
    this._initItemClickAction();
    this._initButtonClickAction();
  }
  _initItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  }
  _initButtonClickAction() {
    this._buttonClickAction = this._createActionByOption("onButtonClick");
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new ChildDefaultTemplate("content")
    });
    super._initTemplates();
  }
  _initMarkup() {
    this._renderButton();
    super._initMarkup();
  }
  _render() {
    super._render();
    this.setAria({
      haspopup: true,
      expanded: this.option("opened")
    });
  }
  _renderContentImpl() {
    if (this.option("opened")) {
      this._renderPopup();
    }
  }
  _clean() {
    this._cleanFocusState();
    this._list && this._list.$element().remove();
    this._popup && this._popup.$element().remove();
    delete this._list;
    delete this._popup;
  }
  _renderButton() {
    const $button = this.$element().addClass("dx-dropdownmenu-button");
    this._button = this._createComponent($button, button_default, {
      icon: "overflow",
      template: "content",
      stylingMode: isFluent() ? "text" : "contained",
      useInkRipple: this.option("useInkRipple"),
      hoverStateEnabled: false,
      focusStateEnabled: false,
      onClick: (e) => {
        this.option("opened", !this.option("opened"));
        this._buttonClickAction(e);
      }
    });
  }
  _toggleActiveState($element, value2, e) {
    this._button._toggleActiveState($element, value2, e);
  }
  _toggleMenuVisibility(opened) {
    var _this$_popup, _this$_popup2;
    const state = opened ?? !(null !== (_this$_popup = this._popup) && void 0 !== _this$_popup && _this$_popup.option("visible"));
    if (opened) {
      this._renderPopup();
    }
    null === (_this$_popup2 = this._popup) || void 0 === _this$_popup2 || _this$_popup2.toggle(state);
    this.setAria("expanded", state);
  }
  _renderPopup() {
    if (this._$popup) {
      return;
    }
    this._$popup = renderer_default("<div>").appendTo(this.$element());
    const {
      rtlEnabled,
      container,
      animation
    } = this.option();
    this._popup = this._createComponent(this._$popup, "dxPopup", {
      onInitialized(_ref) {
        let {
          component
        } = _ref;
        component.$wrapper().addClass("dx-dropdownmenu-popup-wrapper").addClass("dx-dropdownmenu-popup");
      },
      deferRendering: false,
      preventScrollEvents: false,
      contentTemplate: (contentElement) => this._renderList(contentElement),
      _ignoreFunctionValueDeprecation: true,
      maxHeight: () => this._getMaxHeight(),
      position: {
        my: "top " + (rtlEnabled ? "left" : "right"),
        at: "bottom " + (rtlEnabled ? "left" : "right"),
        collision: "fit flip",
        offset: {
          v: 3
        },
        of: this.$element()
      },
      animation,
      onOptionChanged: (_ref2) => {
        let {
          name: name2,
          value: value2
        } = _ref2;
        if ("visible" === name2) {
          this.option("opened", value2);
        }
      },
      container,
      autoResizeEnabled: false,
      height: "auto",
      width: "auto",
      hideOnOutsideClick: (e) => this._closeOutsideDropDownHandler(e),
      hideOnParentScroll: true,
      shading: false,
      dragEnabled: false,
      showTitle: false,
      fullScreen: false,
      _fixWrapperPosition: true
    });
  }
  _getMaxHeight() {
    const $element = this.$element();
    const offsetTop = $element.offset().top;
    const windowHeight = getOuterHeight(getWindow());
    const maxHeight = Math.max(offsetTop, windowHeight - offsetTop - getOuterHeight($element));
    return Math.min(windowHeight, maxHeight - 3 - 10);
  }
  _closeOutsideDropDownHandler(e) {
    const isOutsideClick = !renderer_default(e.target).closest(this.$element()).length;
    return isOutsideClick;
  }
  _renderList(contentElement) {
    const $content = renderer_default(contentElement);
    $content.addClass("dx-dropdownmenu-list");
    this._list = this._createComponent($content, ToolbarMenuList, {
      dataSource: this._getListDataSource(),
      pageLoadMode: "scrollBottom",
      indicateLoading: false,
      noDataText: "",
      itemTemplate: this.option("itemTemplate"),
      onItemClick: (e) => {
        if (this.option("closeOnClick")) {
          this.option("opened", false);
        }
        this._itemClickAction(e);
      },
      tabIndex: -1,
      focusStateEnabled: false,
      activeStateEnabled: true,
      onItemRendered: this.option("onItemRendered"),
      _itemAttributes: {
        role: "menuitem"
      }
    });
  }
  _itemOptionChanged(item, property, value2) {
    var _this$_list2;
    null === (_this$_list2 = this._list) || void 0 === _this$_list2 || _this$_list2._itemOptionChanged(item, property, value2);
    toggleItemFocusableElementTabIndex(this._list, item);
  }
  _getListDataSource() {
    return this.option("dataSource") ?? this.option("items");
  }
  _setListDataSource() {
    var _this$_list3;
    null === (_this$_list3 = this._list) || void 0 === _this$_list3 || _this$_list3.option("dataSource", this._getListDataSource());
    delete this._deferRendering;
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat([this._list]);
  }
  _toggleVisibility(visible) {
    var _this$_button;
    super._toggleVisibility(visible);
    null === (_this$_button = this._button) || void 0 === _this$_button || _this$_button.option("visible", visible);
  }
  _optionChanged(args) {
    var _this$_list4, _this$_list5, _this$_list6;
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "items":
      case "dataSource":
        if (!this.option("opened")) {
          this._deferRendering = true;
        } else {
          this._setListDataSource();
        }
        break;
      case "itemTemplate":
        null === (_this$_list4 = this._list) || void 0 === _this$_list4 || _this$_list4.option(name2, this._getTemplate(value2));
        break;
      case "onItemClick":
        this._initItemClickAction();
        break;
      case "onButtonClick":
        this._buttonClickAction();
        break;
      case "useInkRipple":
        this._invalidate();
        break;
      case "focusStateEnabled":
        null === (_this$_list5 = this._list) || void 0 === _this$_list5 || _this$_list5.option(name2, value2);
        super._optionChanged(args);
        break;
      case "onItemRendered":
        null === (_this$_list6 = this._list) || void 0 === _this$_list6 || _this$_list6.option(name2, value2);
        break;
      case "opened":
        if (this._deferRendering) {
          this._setListDataSource();
        }
        this._toggleMenuVisibility(value2);
        this._updateFocusableItemsTabIndex();
        break;
      case "closeOnClick":
        break;
      case "container":
        this._popup && this._popup.option(name2, value2);
        break;
      case "disabled":
        if (this._list) {
          this._updateFocusableItemsTabIndex();
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
  _updateFocusableItemsTabIndex() {
    this.option("items").forEach((item) => toggleItemFocusableElementTabIndex(this._list, item));
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/strategy/m_toolbar.singleline.js
var TOOLBAR_HIDDEN_ITEM = "dx-toolbar-item-invisible";
var SingleLineStrategy = class {
  constructor(toolbar) {
    this._toolbar = toolbar;
  }
  _initMarkup() {
    deferRender(() => {
      this._renderOverflowMenu();
      this._renderMenuItems();
    });
  }
  _renderOverflowMenu() {
    if (!this._hasVisibleMenuItems()) {
      return;
    }
    this._renderMenuButtonContainer();
    const $menu = renderer_default("<div>").appendTo(this._overflowMenuContainer());
    const itemClickAction = this._toolbar._createActionByOption("onItemClick");
    const menuItemTemplate = this._toolbar._getTemplateByOption("menuItemTemplate");
    this._menu = this._toolbar._createComponent($menu, DropDownMenu, {
      disabled: this._toolbar.option("disabled"),
      itemTemplate: () => menuItemTemplate,
      onItemClick: (e) => {
        itemClickAction(e);
      },
      container: this._toolbar.option("menuContainer"),
      onOptionChanged: (_ref) => {
        let {
          name: name2,
          value: value2
        } = _ref;
        if ("opened" === name2) {
          this._toolbar.option("overflowMenuVisible", value2);
        }
        if ("items" === name2) {
          this._updateMenuVisibility(value2);
        }
      }
    });
  }
  renderMenuItems() {
    if (!this._menu) {
      this._renderOverflowMenu();
    }
    this._menu && this._menu.option("items", this._getMenuItems());
    if (this._menu && !this._menu.option("items").length) {
      this._menu.option("opened", false);
    }
  }
  _renderMenuButtonContainer() {
    this._$overflowMenuContainer = renderer_default("<div>").appendTo(this._toolbar._$afterSection).addClass("dx-toolbar-button").addClass("dx-toolbar-menu-container");
  }
  _overflowMenuContainer() {
    return this._$overflowMenuContainer;
  }
  _updateMenuVisibility(menuItems) {
    const items = menuItems ?? this._getMenuItems();
    const isMenuVisible = items.length && this._hasVisibleMenuItems(items);
    this._toggleMenuVisibility(isMenuVisible);
  }
  _toggleMenuVisibility(value2) {
    if (!this._overflowMenuContainer()) {
      return;
    }
    this._overflowMenuContainer().toggleClass("dx-state-invisible", !value2);
  }
  _renderMenuItems() {
    deferRender(() => {
      this.renderMenuItems();
    });
  }
  _dimensionChanged() {
    this.renderMenuItems();
  }
  _getToolbarItems() {
    return grep(this._toolbar.option("items") ?? [], (item) => !this._toolbar._isMenuItem(item));
  }
  _getHiddenItems() {
    return this._toolbar._itemContainer().children(`.dx-toolbar-item-auto-hide.${TOOLBAR_HIDDEN_ITEM}`).not(".dx-state-invisible");
  }
  _getMenuItems() {
    const menuItems = grep(this._toolbar.option("items") ?? [], (item) => this._toolbar._isMenuItem(item));
    const $hiddenItems = this._getHiddenItems();
    this._restoreItems = this._restoreItems ?? [];
    const overflowItems = [].slice.call($hiddenItems).map((hiddenItem) => {
      const itemData = this._toolbar._getItemData(hiddenItem);
      const $itemContainer = renderer_default(hiddenItem);
      const $itemMarkup = $itemContainer.children();
      return extend({
        menuItemTemplate: () => {
          this._restoreItems.push({
            container: $itemContainer,
            item: $itemMarkup
          });
          const $container = renderer_default("<div>").addClass("dx-toolbar-item-auto-hide");
          return $container.append($itemMarkup);
        }
      }, itemData);
    });
    return [...overflowItems, ...menuItems];
  }
  _hasVisibleMenuItems(items) {
    const menuItems = items ?? this._toolbar.option("items");
    let result = false;
    const optionGetter = compileGetter("visible");
    const overflowGetter = compileGetter("locateInMenu");
    each(menuItems, (index, item) => {
      const itemVisible = optionGetter(item, {
        functionsAsIs: true
      });
      const itemOverflow = overflowGetter(item, {
        functionsAsIs: true
      });
      if (false !== itemVisible && ("auto" === itemOverflow || "always" === itemOverflow) || "menu" === item.location) {
        result = true;
      }
    });
    return result;
  }
  _arrangeItems() {
    this._toolbar._$centerSection.css({
      margin: "0 auto",
      float: "none"
    });
    each(this._restoreItems ?? [], (_, obj) => {
      renderer_default(obj.container).append(obj.item);
    });
    this._restoreItems = [];
    const elementWidth = getWidth(this._toolbar.$element());
    this._hideOverflowItems(elementWidth);
    return elementWidth;
  }
  _hideOverflowItems(width) {
    const overflowItems = this._toolbar.$element().find(".dx-toolbar-item-auto-hide");
    if (!overflowItems.length) {
      return;
    }
    const elementWidth = width ?? getWidth(this._toolbar.$element());
    renderer_default(overflowItems).removeClass(TOOLBAR_HIDDEN_ITEM);
    let itemsWidth = this._getItemsWidth();
    while (overflowItems.length && elementWidth < itemsWidth) {
      const $item = overflowItems.eq(-1);
      $item.addClass(TOOLBAR_HIDDEN_ITEM);
      itemsWidth = this._getItemsWidth();
      overflowItems.splice(-1, 1);
    }
  }
  _getItemsWidth() {
    return this._toolbar._getSummaryItemsSize("width", [this._toolbar._$beforeSection, this._toolbar._$centerSection, this._toolbar._$afterSection]);
  }
  _itemOptionChanged(item, property, value2) {
    if ("disabled" === property || "options.disabled" === property) {
      if (this._toolbar._isMenuItem(item)) {
        var _this$_menu;
        null === (_this$_menu = this._menu) || void 0 === _this$_menu || _this$_menu._itemOptionChanged(item, property, value2);
        return;
      }
    }
    this.renderMenuItems();
  }
  _renderItem(item, itemElement) {
    if ("auto" === item.locateInMenu) {
      itemElement.addClass("dx-toolbar-item-auto-hide");
    }
  }
  _optionChanged(name2, value2) {
    var _this$_menu2, _this$_menu3, _this$_menu4, _this$_menu5, _this$_menu6;
    switch (name2) {
      case "disabled":
        null === (_this$_menu2 = this._menu) || void 0 === _this$_menu2 || _this$_menu2.option(name2, value2);
        break;
      case "overflowMenuVisible":
        null === (_this$_menu3 = this._menu) || void 0 === _this$_menu3 || _this$_menu3.option("opened", value2);
        break;
      case "onItemClick":
        null === (_this$_menu4 = this._menu) || void 0 === _this$_menu4 || _this$_menu4.option(name2, value2);
        break;
      case "menuContainer":
        null === (_this$_menu5 = this._menu) || void 0 === _this$_menu5 || _this$_menu5.option("container", value2);
        break;
      case "menuItemTemplate":
        null === (_this$_menu6 = this._menu) || void 0 === _this$_menu6 || _this$_menu6.option("itemTemplate", value2);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.js
var Toolbar = class extends m_toolbar_base_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      menuItemTemplate: "menuItem",
      menuContainer: void 0,
      overflowMenuVisible: false,
      multiline: false
    });
  }
  _isMultiline() {
    return this.option("multiline");
  }
  _dimensionChanged(dimension) {
    if ("height" === dimension) {
      return;
    }
    super._dimensionChanged();
    this._layoutStrategy._dimensionChanged();
  }
  _initMarkup() {
    super._initMarkup();
    this._updateFocusableItemsTabIndex();
    this._layoutStrategy._initMarkup();
  }
  _renderToolbar() {
    super._renderToolbar();
    this._renderLayoutStrategy();
  }
  _itemContainer() {
    if (this._isMultiline()) {
      return this._$toolbarItemsContainer;
    }
    return super._itemContainer();
  }
  _renderLayoutStrategy() {
    this.$element().toggleClass("dx-toolbar-multiline", this._isMultiline());
    this._layoutStrategy = this._isMultiline() ? new MultiLineStrategy(this) : new SingleLineStrategy(this);
  }
  _renderSections() {
    if (this._isMultiline()) {
      return;
    }
    return super._renderSections();
  }
  _postProcessRenderItems() {
    this._layoutStrategy._hideOverflowItems();
    this._layoutStrategy._updateMenuVisibility();
    super._postProcessRenderItems();
    this._layoutStrategy._renderMenuItems();
  }
  _renderItem(index, item, itemContainer, $after) {
    const itemElement = super._renderItem(index, item, itemContainer, $after);
    this._layoutStrategy._renderItem(item, itemElement);
    const {
      widget,
      showText
    } = item;
    if ("dxButton" === widget && "inMenu" === showText) {
      itemElement.toggleClass("dx-toolbar-text-auto-hide");
    }
    return itemElement;
  }
  _getItemsWidth() {
    return this._layoutStrategy._getItemsWidth();
  }
  _getMenuItems() {
    return this._layoutStrategy._getMenuItems();
  }
  _getToolbarItems() {
    return this._layoutStrategy._getToolbarItems();
  }
  _arrangeItems() {
    if (this.$element().is(":hidden")) {
      return;
    }
    const elementWidth = this._layoutStrategy._arrangeItems();
    if (!this._isMultiline()) {
      super._arrangeItems(elementWidth);
    }
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    if (!this._isMenuItem(item)) {
      super._itemOptionChanged(item, property, value2, prevValue);
    }
    this._layoutStrategy._itemOptionChanged(item, property, value2);
    if ("disabled" === property || "options.disabled" === property) {
      toggleItemFocusableElementTabIndex(this, item);
    }
    if ("location" === property) {
      this.repaint();
    }
  }
  _updateFocusableItemsTabIndex() {
    this._getToolbarItems().forEach((item) => toggleItemFocusableElementTabIndex(this, item));
  }
  _isMenuItem(itemData) {
    return "menu" === itemData.location || "always" === itemData.locateInMenu;
  }
  _isToolbarItem(itemData) {
    return void 0 === itemData.location || "never" === itemData.locateInMenu;
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    this._layoutStrategy._optionChanged(name2, value2);
    switch (name2) {
      case "menuContainer":
      case "menuItemTemplate":
      case "overflowMenuVisible":
        break;
      case "multiline":
        this._invalidate();
        break;
      case "disabled":
        super._optionChanged(args);
        this._updateFocusableItemsTabIndex();
        break;
      default:
        super._optionChanged(args);
    }
  }
  updateDimensions() {
    this._dimensionChanged();
  }
};
component_registrator_default("dxToolbar", Toolbar);
var m_toolbar_default = Toolbar;

// ../../../../../../node_modules/devextreme/esm/ui/toolbar/ui.toolbar.js
var ui_toolbar_default = m_toolbar_default;

// ../../../../../../node_modules/devextreme/esm/ui/toolbar.js
var toolbar_default = ui_toolbar_default;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/header/m_calendar.js
var CALENDAR_CLASS = "dx-scheduler-navigator-calendar";
var CALENDAR_POPOVER_CLASS = "dx-scheduler-navigator-calendar-popover";
var SchedulerCalendar = class extends ui_widget_default {
  show(target) {
    if (!this._isMobileLayout()) {
      this._overlay.option("target", target);
    }
    this._overlay.show();
  }
  hide() {
    this._overlay.hide();
  }
  _keyboardHandler(opts) {
    var _this$_calendar;
    null === (_this$_calendar = this._calendar) || void 0 === _this$_calendar || _this$_calendar._keyboardHandler(opts);
  }
  _init() {
    super._init();
    this.$element();
  }
  _render() {
    super._render();
    this._renderOverlay();
  }
  _renderOverlay() {
    this.$element().addClass(CALENDAR_POPOVER_CLASS);
    const isMobileLayout = this._isMobileLayout();
    const overlayType = isMobileLayout ? ui_popup_default : ui_popover_default;
    this._overlay = this._createComponent(this.$element(), overlayType, {
      contentTemplate: () => this._createOverlayContent(),
      onShown: () => this._calendar.focus(),
      defaultOptionsRules: [{
        device: () => isMobileLayout,
        options: {
          fullScreen: true,
          showCloseButton: false,
          toolbarItems: [{
            shortcut: "cancel"
          }],
          _ignorePreventScrollEventsDeprecation: true,
          preventScrollEvents: false,
          enableBodyScroll: false
        }
      }]
    });
  }
  _createOverlayContent() {
    const result = renderer_default("<div>").addClass(CALENDAR_CLASS);
    this._calendar = this._createComponent(result, calendar_default, this._getCalendarOptions());
    if (this._isMobileLayout()) {
      const scrollable = this._createScrollable(result);
      return scrollable.$element();
    }
    return result;
  }
  _createScrollable(content) {
    const result = this._createComponent("<div>", ui_scrollable_default, {
      height: "auto",
      direction: "both"
    });
    result.$content().append(content);
    return result;
  }
  _optionChanged(_ref) {
    var _this$_calendar2;
    let {
      name: name2,
      value: value2
    } = _ref;
    if ("value" === name2) {
      null === (_this$_calendar2 = this._calendar) || void 0 === _this$_calendar2 || _this$_calendar2.option("value", value2);
    }
  }
  _getCalendarOptions() {
    return {
      value: this.option("value"),
      min: this.option("min"),
      max: this.option("max"),
      firstDayOfWeek: this.option("firstDayOfWeek"),
      focusStateEnabled: this.option("focusStateEnabled"),
      onValueChanged: this.option("onValueChanged"),
      skipFocusCheck: true,
      tabIndex: this.option("tabIndex")
    };
  }
  _isMobileLayout() {
    return !devices_default.current().generic;
  }
};
component_registrator_default("dxSchedulerCalendarPopup", SchedulerCalendar);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/header/m_date_navigator.js
var {
  trimTime
} = date_default2;
var DATE_NAVIGATOR_CLASS = "dx-scheduler-navigator";
var PREVIOUS_BUTTON_CLASS = "dx-scheduler-navigator-previous";
var CALENDAR_BUTTON_CLASS = "dx-scheduler-navigator-caption";
var NEXT_BUTTON_CLASS = "dx-scheduler-navigator-next";
var getDateNavigator = (header, item) => {
  const items = [getPreviousButtonOptions(header), getCalendarButtonOptions(header), getNextButtonOptions(header)];
  const stylingMode = isMaterialBased() ? "text" : "contained";
  return _extends({
    widget: "dxButtonGroup",
    cssClass: DATE_NAVIGATOR_CLASS,
    options: {
      items,
      stylingMode,
      selectionMode: "none",
      onItemClick: (e) => {
        e.itemData.clickHandler(e);
      }
    }
  }, item);
};
var getPreviousButtonOptions = (header) => ({
  key: "previous",
  icon: "chevronprev",
  elementAttr: {
    class: PREVIOUS_BUTTON_CLASS
  },
  clickHandler: () => header._updateDateByDirection(-1),
  onContentReady: (e) => {
    const previousButton = e.component;
    previousButton.option("disabled", isPreviousButtonDisabled(header));
    header._addEvent("min", () => {
      previousButton.option("disabled", isPreviousButtonDisabled(header));
    });
    header._addEvent("currentDate", () => {
      previousButton.option("disabled", isPreviousButtonDisabled(header));
    });
    header._addEvent("startViewDate", () => {
      previousButton.option("disabled", isPreviousButtonDisabled(header));
    });
  }
});
var getCalendarButtonOptions = (header) => ({
  key: "calendar",
  text: header.captionText,
  elementAttr: {
    class: CALENDAR_BUTTON_CLASS
  },
  clickHandler: (e) => header._showCalendar(e),
  onContentReady: (e) => {
    const calendarButton = e.component;
    header._addEvent("currentView", () => {
      calendarButton.option("text", header.captionText);
    });
    header._addEvent("currentDate", () => {
      calendarButton.option("text", header.captionText);
    });
    header._addEvent("startViewDate", () => {
      calendarButton.option("text", header.captionText);
    });
    header._addEvent("views", () => {
      calendarButton.option("text", header.captionText);
    });
    header._addEvent("firstDayOfWeek", () => {
      calendarButton.option("text", header.captionText);
    });
  }
});
var getNextButtonOptions = (header) => ({
  key: "next",
  icon: "chevronnext",
  elementAttr: {
    class: NEXT_BUTTON_CLASS
  },
  clickHandler: () => header._updateDateByDirection(1),
  onContentReady: (e) => {
    const nextButton = e.component;
    nextButton.option("disabled", isNextButtonDisabled(header));
    header._addEvent("min", () => {
      nextButton.option("disabled", isNextButtonDisabled(header));
    });
    header._addEvent("currentDate", () => {
      nextButton.option("disabled", isNextButtonDisabled(header));
    });
    header._addEvent("startViewDate", () => {
      nextButton.option("disabled", isNextButtonDisabled(header));
    });
  }
});
var isPreviousButtonDisabled = (header) => {
  let min = header.option("min");
  if (!min) {
    return false;
  }
  min = new Date(min);
  const caption = header._getCaption();
  min = trimTime(min);
  const previousDate = header._getNextDate(-1, caption.endDate);
  return previousDate < min;
};
var isNextButtonDisabled = (header) => {
  let max = header.option("max");
  if (!max) {
    return false;
  }
  max = new Date(max);
  const caption = header._getCaption();
  max = max.setHours(23, 59, 59);
  const nextDate = header._getNextDate(1, caption.startDate);
  return nextDate > max;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/header/m_utils.js
var {
  correctDateWithUnitBeginning: getPeriodStart,
  getFirstWeekDate: getWeekStart,
  getLastMonthDay,
  addDateInterval
} = date_default2;
var {
  format: formatDate
} = date_default;
var MS_DURATION = {
  milliseconds: 1
};
var DAY_DURATION = {
  days: 1
};
var WEEK_DURATION = {
  days: 7
};
var subMS = (date) => addDateInterval(date, MS_DURATION, -1);
var addMS = (date) => addDateInterval(date, MS_DURATION, 1);
var nextDay = (date) => addDateInterval(date, DAY_DURATION, 1);
var nextWeek = (date) => addDateInterval(date, WEEK_DURATION, 1);
var nextMonth = (date) => {
  const days3 = getLastMonthDay(date);
  return addDateInterval(date, {
    days: days3
  }, 1);
};
var isWeekend = (date) => 6 === date.getDay() || 0 === date.getDay();
var getWorkWeekStart = (firstDayOfWeek) => {
  let date = new Date(firstDayOfWeek);
  while (isWeekend(date)) {
    date = nextDay(date);
  }
  return date;
};
var getDateAfterWorkWeek = (workWeekStart) => {
  let date = new Date(workWeekStart);
  let workDaysCount = 0;
  while (workDaysCount < 5) {
    if (!isWeekend(date)) {
      workDaysCount++;
    }
    date = nextDay(date);
  }
  return date;
};
var nextAgendaStart = (date, agendaDuration) => addDateInterval(date, {
  days: agendaDuration
}, 1);
var getInterval = (options) => {
  const startDate = getIntervalStartDate(options);
  const endDate = getIntervalEndDate(startDate, options);
  return {
    startDate,
    endDate
  };
};
var getIntervalStartDate = (options) => {
  const {
    date,
    step,
    firstDayOfWeek
  } = options;
  switch (step) {
    case "day":
    case "week":
    case "month":
      return getPeriodStart(date, step, false, firstDayOfWeek);
    case "workWeek":
      const firstWeekDay = getWeekStart(date, firstDayOfWeek);
      return getWorkWeekStart(firstWeekDay);
    case "agenda":
      return new Date(date);
  }
};
var getIntervalEndDate = (startDate, options) => {
  const {
    intervalCount,
    step,
    agendaDuration
  } = options;
  let periodStartDate;
  let periodEndDate;
  let nextPeriodStartDate = new Date(startDate);
  for (let i = 0; i < intervalCount; i++) {
    periodStartDate = nextPeriodStartDate;
    periodEndDate = getPeriodEndDate(periodStartDate, step, agendaDuration);
    nextPeriodStartDate = getNextPeriodStartDate(periodEndDate, step);
  }
  return periodEndDate;
};
var getPeriodEndDate = (currentPeriodStartDate, step, agendaDuration) => {
  let date;
  switch (step) {
    case "day":
      date = nextDay(currentPeriodStartDate);
      break;
    case "week":
      date = nextWeek(currentPeriodStartDate);
      break;
    case "month":
      date = nextMonth(currentPeriodStartDate);
      break;
    case "workWeek":
      date = getDateAfterWorkWeek(currentPeriodStartDate);
      break;
    case "agenda":
      date = nextAgendaStart(currentPeriodStartDate, agendaDuration);
  }
  return subMS(date);
};
var getNextPeriodStartDate = (currentPeriodEndDate, step) => {
  let date = addMS(currentPeriodEndDate);
  if ("workWeek" === step) {
    while (isWeekend(date)) {
      date = nextDay(date);
    }
  }
  return date;
};
var getNextIntervalDate = (options, direction) => {
  const {
    date,
    step,
    intervalCount,
    agendaDuration
  } = options;
  let dayDuration;
  switch (step) {
    case "day":
      dayDuration = 1 * intervalCount;
      break;
    case "week":
    case "workWeek":
      dayDuration = 7 * intervalCount;
      break;
    case "agenda":
      dayDuration = agendaDuration;
      break;
    case "month":
      return getNextMonthDate(date, intervalCount, direction);
  }
  return addDateInterval(date, {
    days: dayDuration
  }, direction);
};
var getNextMonthDate = (date, intervalCount, direction) => {
  const currentDate = date.getDate();
  const currentMonthFirstDate = new Date(new Date(date.getTime()).setDate(1));
  const thatMonthFirstDate = new Date(currentMonthFirstDate.setMonth(currentMonthFirstDate.getMonth() + intervalCount * direction));
  const thatMonthDuration = getLastMonthDay(thatMonthFirstDate);
  const minDate = currentDate < thatMonthDuration ? currentDate : thatMonthDuration;
  const currentMonthMinDate = new Date(new Date(date.getTime()).setDate(minDate));
  const thatMonthMinDate = new Date(currentMonthMinDate.setMonth(currentMonthMinDate.getMonth() + intervalCount * direction));
  return thatMonthMinDate;
};
var getDateMonthFormatter = (isShort) => {
  const monthType = isShort ? "abbreviated" : "wide";
  const months = date_default.getMonthNames(monthType);
  return (date) => {
    const day = formatDate(date, "day");
    const month = months[date.getMonth()];
    return `${day} ${month}`;
  };
};
var formatMonthYear = (date) => {
  const months = date_default.getMonthNames("abbreviated");
  const month = months[date.getMonth()];
  const year = formatDate(date, "year");
  return `${month} ${year}`;
};
var getDateMonthYearFormatter = (isShort) => (date) => {
  const dateMonthFormat = getDateMonthFormatter(isShort);
  const dateMonth = dateMonthFormat(date);
  const year = formatDate(date, "year");
  return `${dateMonth} ${year}`;
};
var getDifferentYearCaption = (startDate, endDate) => {
  const firstDateText = formatDate(startDate, getDateMonthYearFormatter(true));
  const lastDateDateText = formatDate(endDate, getDateMonthYearFormatter(true));
  return `${firstDateText}-${lastDateDateText}`;
};
var getSameYearCaption = (startDate, endDate, isShort) => {
  const isDifferentMonthDates = startDate.getMonth() !== endDate.getMonth();
  const useShortFormat = isDifferentMonthDates || isShort;
  const firstDateFormat = isDifferentMonthDates ? getDateMonthFormatter(useShortFormat) : "d";
  const firstDateText = formatDate(startDate, firstDateFormat);
  const lastDateText = formatDate(endDate, getDateMonthYearFormatter(useShortFormat));
  return `${firstDateText}-${lastDateText}`;
};
var getSameDateCaption = (date, step, isShort) => {
  const useShortFormat = "agenda" === step ? isShort : false;
  const dateMonthFormat = getDateMonthFormatter(useShortFormat);
  const dateMonth = dateMonthFormat(date);
  const year = formatDate(date, "year");
  return `${dateMonth} ${year}`;
};
var formatCaptionByMonths = (startDate, endDate, isShort) => {
  const isDifferentYears = startDate.getFullYear() !== endDate.getFullYear();
  if (isDifferentYears) {
    return getDifferentYearCaption(startDate, endDate);
  }
  return getSameYearCaption(startDate, endDate, isShort);
};
var formatMonthViewCaption = (startDate, endDate) => {
  if (date_default2.sameMonth(startDate, endDate)) {
    return formatDate(startDate, "monthandyear");
  }
  const isSameYear = date_default2.sameYear(startDate, endDate);
  const firstDateText = isSameYear ? date_default.getMonthNames("abbreviated")[startDate.getMonth()] : formatMonthYear(startDate);
  const lastDateText = formatMonthYear(endDate);
  return `${firstDateText}-${lastDateText}`;
};
var getCaptionText = (startDate, endDate, isShort, step) => {
  if (date_default2.sameDate(startDate, endDate)) {
    return getSameDateCaption(startDate, step, isShort);
  }
  if ("month" === step) {
    return formatMonthViewCaption(startDate, endDate);
  }
  return formatCaptionByMonths(startDate, endDate, isShort);
};
var getCaption = (options, isShort, customizationFunction) => {
  const {
    startDate,
    endDate
  } = getInterval(options);
  let text = getCaptionText(startDate, endDate, isShort, options.step);
  if (isFunction(customizationFunction)) {
    text = customizationFunction({
      startDate,
      endDate,
      text
    });
  }
  return {
    startDate,
    endDate,
    text
  };
};
var STEP_MAP = {
  day: "day",
  week: "week",
  workWeek: "workWeek",
  month: "month",
  timelineDay: "day",
  timelineWeek: "week",
  timelineWorkWeek: "workWeek",
  timelineMonth: "month",
  agenda: "agenda"
};
var getStep = (view) => STEP_MAP[getViewType(view)];
var getViewType = (view) => {
  if (isObject(view) && view.type) {
    return view.type;
  }
  return view;
};
var getViewName = (view) => {
  if (isObject(view)) {
    return view.name ? view.name : view.type;
  }
  return view;
};
var getViewText = (view) => {
  if (view.name) {
    return view.name;
  }
  const viewName = camelize(view.type || view, true);
  return message_default.format(`dxScheduler-switcher${viewName}`);
};
var isValidView = (view) => Object.values(VIEWS).includes(view);
var validateViews = (views) => {
  views.forEach((view) => {
    const viewType = getViewType(view);
    if (!isValidView(viewType)) {
      errors_default.log("W0008", viewType);
    }
  });
};
var formatViews = (views) => {
  validateViews(views);
  return views.map((view) => {
    const text = getViewText(view);
    const type = getViewType(view);
    const name2 = getViewName(view);
    return {
      text,
      name: name2,
      view: {
        text,
        type,
        name: name2
      }
    };
  });
};
var isOneView = (views, selectedView) => 1 === views.length && views[0].name === selectedView;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/header/m_view_switcher.js
var VIEW_SWITCHER_CLASS = "dx-scheduler-view-switcher";
var VIEW_SWITCHER_DROP_DOWN_BUTTON_CLASS = "dx-scheduler-view-switcher-dropdown-button";
var VIEW_SWITCHER_DROP_DOWN_BUTTON_CONTENT_CLASS = "dx-scheduler-view-switcher-dropdown-button-content";
var getViewsAndSelectedView = (header) => {
  const views = formatViews(header.views);
  let selectedView = getViewName(header.currentView);
  const isSelectedViewInViews = views.some((view) => view.name === selectedView);
  selectedView = isSelectedViewInViews ? selectedView : void 0;
  return {
    selectedView,
    views
  };
};
var getViewSwitcher = (header, item) => {
  const {
    selectedView,
    views
  } = getViewsAndSelectedView(header);
  const stylingMode = isFluent() ? "outlined" : "contained";
  return _extends({
    widget: "dxButtonGroup",
    locateInMenu: "auto",
    cssClass: VIEW_SWITCHER_CLASS,
    options: {
      items: views,
      keyExpr: "name",
      selectedItemKeys: [selectedView],
      stylingMode,
      onItemClick: (e) => {
        const {
          view
        } = e.itemData;
        header._updateCurrentView(view);
      },
      onContentReady: (e) => {
        const viewSwitcher = e.component;
        header._addEvent("currentView", (view) => {
          viewSwitcher.option("selectedItemKeys", [getViewName(view)]);
        });
      }
    }
  }, item);
};
var getDropDownViewSwitcher = (header, item) => {
  const {
    selectedView,
    views
  } = getViewsAndSelectedView(header);
  const oneView = isOneView(views, selectedView);
  return _extends({
    widget: "dxDropDownButton",
    locateInMenu: "never",
    cssClass: VIEW_SWITCHER_CLASS,
    options: {
      items: views,
      useSelectMode: true,
      keyExpr: "name",
      selectedItemKey: selectedView,
      displayExpr: "text",
      showArrowIcon: !oneView,
      elementAttr: {
        class: VIEW_SWITCHER_DROP_DOWN_BUTTON_CLASS
      },
      onItemClick: (e) => {
        const {
          view
        } = e.itemData;
        header._updateCurrentView(view);
      },
      onContentReady: (e) => {
        const viewSwitcher = e.component;
        header._addEvent("currentView", (view) => {
          const views2 = formatViews(header.views);
          if (isOneView(views2, view)) {
            header.repaint();
          }
          viewSwitcher.option("selectedItemKey", getViewName(view));
        });
      },
      dropDownOptions: {
        onShowing: (e) => {
          if (oneView) {
            e.cancel = true;
          }
        },
        width: "max-content",
        _wrapperClassExternal: VIEW_SWITCHER_DROP_DOWN_BUTTON_CONTENT_CLASS
      }
    }
  }, item);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/header/m_header.js
var DEFAULT_ELEMENT = "defaultElement";
var VIEW_SWITCHER = "viewSwitcher";
var DATE_NAVIGATOR = "dateNavigator";
var COMPONENT_CLASS2 = "dx-scheduler-header";
var SchedulerHeader = class extends ui_widget_default {
  get views() {
    return this.option("views");
  }
  get captionText() {
    return this._getCaption().text;
  }
  get intervalOptions() {
    const step = getStep(this.currentView);
    const intervalCount = this.option("intervalCount");
    const firstDayOfWeek = this.option("firstDayOfWeek");
    const agendaDuration = this.option("agendaDuration");
    return {
      step,
      intervalCount,
      firstDayOfWeek,
      agendaDuration
    };
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      _useShortDateFormat: !devices_default.real().generic || devices_default.isSimulator()
    });
  }
  _createEventMap() {
    this.eventMap = /* @__PURE__ */ new Map([
      ["currentView", [(view) => {
        this.currentView = viewsUtils.getCurrentView(getViewName(view), this.option("views"));
      }]],
      ["items", [this.repaint.bind(this)]],
      ["views", [validateViews]],
      ["currentDate", [this._getCalendarOptionUpdater("value")]],
      ["min", [this._getCalendarOptionUpdater("min")]],
      ["max", [this._getCalendarOptionUpdater("max")]],
      ["tabIndex", [this.repaint.bind(this)]],
      ["focusStateEnabled", [this.repaint.bind(this)]],
      ["useDropDownViewSwitcher", [this.repaint.bind(this)]]
    ]);
  }
  _addEvent(name2, event) {
    if (!this.eventMap.has(name2)) {
      this.eventMap.set(name2, []);
    }
    const events = this.eventMap.get(name2);
    this.eventMap.set(name2, [...events, event]);
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    if (this.eventMap.has(name2)) {
      const events = this.eventMap.get(name2);
      events.forEach((event) => {
        event(value2);
      });
    }
  }
  _init() {
    super._init();
    this._createEventMap();
    this.$element().addClass(COMPONENT_CLASS2);
    this.currentView = viewsUtils.getCurrentView(getViewName(this.option("currentView")), this.option("views"));
  }
  _render() {
    super._render();
    this._createEventMap();
    this._renderToolbar();
  }
  _renderToolbar() {
    const config = this._createToolbarConfig();
    const toolbarElement = renderer_default("<div>");
    toolbarElement.appendTo(this.$element());
    this._toolbar = this._createComponent(toolbarElement, toolbar_default, config);
  }
  _createToolbarConfig() {
    const items = this.option("items");
    const parsedItems = items.map((element) => this._parseItem(element));
    return {
      items: parsedItems
    };
  }
  _parseItem(item) {
    const isDefaultElement = this._isDefaultItem(item);
    if (isDefaultElement) {
      const defaultElementType = item[DEFAULT_ELEMENT];
      switch (defaultElementType) {
        case VIEW_SWITCHER:
          if (this.option("useDropDownViewSwitcher")) {
            return getDropDownViewSwitcher(this, item);
          }
          return getViewSwitcher(this, item);
        case DATE_NAVIGATOR:
          this._renderCalendar();
          return getDateNavigator(this, item);
        default:
          errors_default.log(`Unknown default element type: ${defaultElementType}`);
      }
    }
    return item;
  }
  _callEvent(event, arg) {
    if (this.eventMap.has(event)) {
      const events = this.eventMap.get(event);
      events.forEach((event2) => event2(arg));
    }
  }
  _updateCurrentView(view) {
    const onCurrentViewChange = this.option("onCurrentViewChange");
    onCurrentViewChange(view.name);
    this._callEvent("currentView", view);
  }
  _updateCalendarValueAndCurrentDate(date) {
    this._updateCurrentDate(date);
    this._calendar.option("value", date);
  }
  _updateCurrentDate(date) {
    const onCurrentDateChange = this.option("onCurrentDateChange");
    onCurrentDateChange(date);
    this._callEvent("currentDate", date);
  }
  _renderCalendar() {
    this._calendar = this._createComponent("<div>", SchedulerCalendar, {
      value: this.option("currentDate"),
      min: this.option("min"),
      max: this.option("max"),
      firstDayOfWeek: this.option("firstDayOfWeek"),
      focusStateEnabled: this.option("focusStateEnabled"),
      tabIndex: this.option("tabIndex"),
      onValueChanged: (e) => {
        this._updateCurrentDate(e.value);
        this._calendar.hide();
      }
    });
    this._calendar.$element().appendTo(this.$element());
  }
  _getCalendarOptionUpdater(name2) {
    return (value2) => {
      if (this._calendar) {
        this._calendar.option(name2, value2);
      }
    };
  }
  _getNextDate(direction) {
    let initialDate = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    const date = initialDate ?? this.option("currentDate");
    const options = _extends({}, this.intervalOptions, {
      date
    });
    return getNextIntervalDate(options, direction);
  }
  _isMonth() {
    const {
      currentView
    } = this;
    return "month" === getViewType(currentView);
  }
  _getDisplayedDate() {
    const startViewDate = this.option("startViewDate");
    if (this._isMonth()) {
      return nextWeek(startViewDate);
    }
    return new Date(startViewDate);
  }
  _getCaption() {
    let date = this.option("currentDate");
    if (this.option("startViewDate")) {
      date = this._getDisplayedDate();
    }
    date = date_default2.trimTime(date);
    const options = _extends({}, this.intervalOptions, {
      date
    });
    const customizationFunction = this.option("customizeDateNavigatorText");
    const useShortDateFormat = this.option("_useShortDateFormat");
    return getCaption(options, useShortDateFormat, customizationFunction);
  }
  _updateDateByDirection(direction) {
    const date = this._getNextDate(direction);
    this._updateCalendarValueAndCurrentDate(date);
  }
  _showCalendar(e) {
    this._calendar.show(e.element);
  }
  _hideCalendar() {
    this._calendar.hide();
  }
  _isDefaultItem(item) {
    return Object.prototype.hasOwnProperty.call(item, DEFAULT_ELEMENT);
  }
};
component_registrator_default("dxSchedulerHeader", SchedulerHeader);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_cell_position_calculator.js
var BaseStrategy = class {
  constructor(options) {
    this.isVirtualScrolling = false;
    this.options = options;
  }
  get DOMMetaData() {
    return this.options.DOMMetaData;
  }
  get appointments() {
    return this.options.dateSettings;
  }
  get viewDataProvider() {
    return this.options.viewDataProvider;
  }
  get positionHelper() {
    return this.options.positionHelper;
  }
  get startViewDate() {
    return this.options.startViewDate;
  }
  get viewStartDayHour() {
    return this.options.viewStartDayHour;
  }
  get viewEndDayHour() {
    return this.options.viewEndDayHour;
  }
  get cellDuration() {
    return this.options.cellDuration;
  }
  get getPositionShift() {
    return this.options.getPositionShiftCallback;
  }
  get groupCount() {
    return this.options.groupCount;
  }
  get rtlEnabled() {
    return this.options.rtlEnabled;
  }
  get isVerticalGrouping() {
    return this.options.isVerticalGroupOrientation;
  }
  get showAllDayPanel() {
    return this.options.showAllDayPanel;
  }
  get supportAllDayRow() {
    return this.options.supportAllDayRow;
  }
  get isGroupedAllDayPanel() {
    return this.options.isGroupedAllDayPanel;
  }
  calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment) {
    const result = [];
    this.appointments.forEach((dateSetting, index) => {
      const coordinates = this.getCoordinateInfos({
        appointment: dateSetting,
        groupIndices,
        isAllDayRowAppointment,
        isRecurrentAppointment
      });
      coordinates.forEach((item) => {
        !!item && result.push(this._prepareObject(item, index));
      });
    });
    return result;
  }
  getCoordinateInfos(options) {
    const {
      appointment,
      isAllDayRowAppointment,
      groupIndices,
      recurrent
    } = options;
    const {
      startDate
    } = appointment;
    const groupIndex = !recurrent ? appointment.source.groupIndex : void 0;
    return this.getCoordinatesByDateInGroup(startDate, groupIndices, isAllDayRowAppointment, groupIndex);
  }
  _prepareObject(position, dateSettingIndex) {
    position.dateSettingIndex = dateSettingIndex;
    return {
      coordinates: position,
      dateSettingIndex
    };
  }
  getCoordinatesByDate(date, groupIndex, inAllDayRow) {
    const validGroupIndex = groupIndex || 0;
    const cellInfo = {
      groupIndex: validGroupIndex,
      startDate: date,
      isAllDay: inAllDayRow
    };
    const positionByMap = this.viewDataProvider.findCellPositionInMap(cellInfo, true);
    if (!positionByMap) {
      return;
    }
    const position = this.getCellPosition(positionByMap, inAllDayRow && !this.isVerticalGrouping);
    const groupEdgeIndices = this.viewDataProvider.getGroupEdgeIndices(validGroupIndex);
    const {
      top: vMin
    } = this.getCellPosition({
      columnIndex: positionByMap.columnIndex,
      rowIndex: groupEdgeIndices.firstRowIndex
    }, inAllDayRow && !this.isVerticalGrouping);
    const timeShift = inAllDayRow ? 0 : this.getTimeShiftRatio(positionByMap, date);
    const shift = this.getPositionShift(timeShift, inAllDayRow);
    const horizontalHMax = this.positionHelper.getHorizontalMax(validGroupIndex, date);
    const verticalMax = this.positionHelper.getVerticalMax({
      groupIndex: validGroupIndex,
      isVirtualScrolling: this.isVirtualScrolling,
      showAllDayPanel: this.showAllDayPanel,
      supportAllDayRow: this.supportAllDayRow,
      isGroupedAllDayPanel: this.isGroupedAllDayPanel,
      isVerticalGrouping: this.isVerticalGrouping
    });
    return {
      positionByMap,
      cellPosition: position.left + shift.cellPosition,
      top: position.top + shift.top,
      left: position.left + shift.left,
      rowIndex: position.rowIndex,
      columnIndex: position.columnIndex,
      hMax: horizontalHMax,
      vMax: verticalMax,
      vMin,
      groupIndex: validGroupIndex
    };
  }
  getCoordinatesByDateInGroup(startDate, groupIndices, inAllDayRow, groupIndex) {
    const result = [];
    if (this.viewDataProvider.isSkippedDate(startDate)) {
      return result;
    }
    let validGroupIndices = [groupIndex];
    if (!isDefined(groupIndex)) {
      validGroupIndices = this.groupCount ? groupIndices : [0];
    }
    validGroupIndices.forEach((groupIndex2) => {
      const coordinates = this.getCoordinatesByDate(startDate, groupIndex2, inAllDayRow);
      if (coordinates) {
        result.push(coordinates);
      }
    });
    return result;
  }
  getCellPosition(cellCoordinates, isAllDayPanel) {
    const {
      dateTableCellsMeta,
      allDayPanelCellsMeta
    } = this.DOMMetaData;
    const {
      columnIndex,
      rowIndex
    } = cellCoordinates;
    const position = isAllDayPanel ? allDayPanelCellsMeta[columnIndex] : dateTableCellsMeta[rowIndex][columnIndex];
    const validPosition = _extends({}, position);
    if (this.rtlEnabled) {
      validPosition.left += position.width;
    }
    if (validPosition) {
      validPosition.rowIndex = cellCoordinates.rowIndex;
      validPosition.columnIndex = cellCoordinates.columnIndex;
    }
    return validPosition;
  }
  getTimeShiftRatio(positionByMap, appointmentDate) {
    const {
      cellDuration,
      viewOffset
    } = this.options;
    const {
      rowIndex,
      columnIndex
    } = positionByMap;
    const matchedCell = this.viewDataProvider.viewDataMap.dateTableMap[rowIndex][columnIndex];
    const matchedCellStartDate = dateUtilsTs.addOffsets(matchedCell.cellData.startDate, [-viewOffset]);
    const result = (appointmentDate.getTime() - matchedCellStartDate.getTime()) / cellDuration;
    return result % 1;
  }
};
var VirtualStrategy = class extends BaseStrategy {
  constructor() {
    super(...arguments);
    this.isVirtualScrolling = true;
  }
  calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment) {
    const appointments = isAllDayRowAppointment ? this.appointments : this.appointments.filter((_ref) => {
      let {
        source,
        startDate,
        endDate
      } = _ref;
      return this.viewDataProvider.isGroupIntersectDateInterval(source.groupIndex, startDate, endDate);
    });
    if (isRecurrentAppointment) {
      return this.createRecurrentAppointmentInfos(appointments, isAllDayRowAppointment);
    }
    return super.calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment);
  }
  createRecurrentAppointmentInfos(dateSettings, isAllDayRowAppointment) {
    const result = [];
    dateSettings.forEach((_ref2, index) => {
      let {
        source,
        startDate
      } = _ref2;
      const coordinate = this.getCoordinatesByDate(startDate, source.groupIndex, isAllDayRowAppointment);
      if (coordinate) {
        result.push(this._prepareObject(coordinate, index));
      }
    });
    return result;
  }
};
var CellPositionCalculator = class {
  constructor(options) {
    this.options = options;
  }
  calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment) {
    const strategy = this.options.isVirtualScrolling ? new VirtualStrategy(this.options) : new BaseStrategy(this.options);
    return strategy.calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_text_utils.js
var createFormattedDateText = (options) => {
  const {
    startDate,
    endDate,
    allDay,
    format
  } = options;
  const formatType = format || getFormatType(startDate, endDate, allDay);
  return formatDates(startDate, endDate, formatType);
};
var getFormatType = (startDate, endDate, isAllDay, isDateAndTimeView2) => {
  if (isAllDay) {
    return "DATE";
  }
  if (isDateAndTimeView2 && date_default2.sameDate(startDate, endDate)) {
    return "TIME";
  }
  return "DATETIME";
};
var formatDates = (startDate, endDate, formatType) => {
  const isSameDate = startDate.getDate() === endDate.getDate();
  switch (formatType) {
    case "DATETIME":
      return [date_default.format(startDate, "monthandday"), " ", date_default.format(startDate, "shorttime"), " - ", isSameDate ? "" : `${date_default.format(endDate, "monthandday")} `, date_default.format(endDate, "shorttime")].join("");
    case "TIME":
      return `${date_default.format(startDate, "shorttime")} - ${date_default.format(endDate, "shorttime")}`;
    case "DATE":
      return `${date_default.format(startDate, "monthandday")}${isSameDate ? "" : ` - ${date_default.format(endDate, "monthandday")}`}`;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_settings_generator.js
var toMs10 = date_default2.dateToMilliseconds;
var DateGeneratorBaseStrategy = class {
  constructor(options) {
    this.options = options;
  }
  get rawAppointment() {
    return this.options.rawAppointment;
  }
  get timeZoneCalculator() {
    return this.options.timeZoneCalculator;
  }
  get viewDataProvider() {
    return this.options.viewDataProvider;
  }
  get appointmentTakesAllDay() {
    return this.options.appointmentTakesAllDay;
  }
  get supportAllDayRow() {
    return this.options.supportAllDayRow;
  }
  get isAllDayRowAppointment() {
    return this.options.isAllDayRowAppointment;
  }
  get timeZone() {
    return this.options.timeZone;
  }
  get dateRange() {
    return this.options.dateRange;
  }
  get firstDayOfWeek() {
    return this.options.firstDayOfWeek;
  }
  get viewStartDayHour() {
    return this.options.viewStartDayHour;
  }
  get viewEndDayHour() {
    return this.options.viewEndDayHour;
  }
  get endViewDate() {
    return this.options.endViewDate;
  }
  get viewType() {
    return this.options.viewType;
  }
  get isGroupedByDate() {
    return this.options.isGroupedByDate;
  }
  get isVerticalOrientation() {
    return this.options.isVerticalGroupOrientation;
  }
  get dataAccessors() {
    return this.options.dataAccessors;
  }
  get loadedResources() {
    return this.options.loadedResources;
  }
  get isDateAppointment() {
    return !isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;
  }
  getIntervalDuration() {
    return this.appointmentTakesAllDay ? this.options.allDayIntervalDuration : this.options.intervalDuration;
  }
  generate(appointmentAdapter) {
    const {
      isRecurrent
    } = appointmentAdapter;
    const itemGroupIndices = this._getGroupIndices(this.rawAppointment);
    let appointmentList = this._createAppointments(appointmentAdapter, itemGroupIndices);
    appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointmentAdapter);
    if (this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {
      appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointmentAdapter);
    }
    let dateSettings = this._createGridAppointmentList(appointmentList, appointmentAdapter);
    const firstViewDates = this._getAppointmentsFirstViewDate(dateSettings);
    dateSettings = this._fillNormalizedStartDate(dateSettings, firstViewDates);
    dateSettings = this._cropAppointmentsByStartDayHour(dateSettings, firstViewDates);
    dateSettings = this._fillNormalizedEndDate(dateSettings, this.rawAppointment);
    if (this._needSeparateLongParts()) {
      dateSettings = this._separateLongParts(dateSettings, appointmentAdapter);
    }
    dateSettings = this.shiftSourceAppointmentDates(dateSettings);
    return {
      dateSettings,
      itemGroupIndices,
      isRecurrent
    };
  }
  shiftSourceAppointmentDates(dateSettings) {
    const {
      viewOffset
    } = this.options;
    return dateSettings.map((item) => _extends({}, item, {
      source: _extends({}, item.source, {
        startDate: dateUtilsTs.addOffsets(item.source.startDate, [viewOffset]),
        endDate: dateUtilsTs.addOffsets(item.source.endDate, [viewOffset])
      })
    }));
  }
  _getProcessedByAppointmentTimeZone(appointmentList, appointment) {
    const hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);
    if (hasAppointmentTimeZone) {
      const appointmentOffsets = {
        startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),
        endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)
      };
      appointmentList.forEach((a) => {
        const sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone), sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);
        const startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;
        const endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;
        if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {
          a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs10("hour"));
        }
        if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {
          a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs10("hour"));
        }
      });
    }
    return appointmentList;
  }
  _createAppointments(appointment, groupIndices) {
    let appointments = this._createRecurrenceAppointments(appointment, groupIndices);
    if (!appointment.isRecurrent && 0 === appointments.length) {
      appointments.push({
        startDate: appointment.startDate,
        endDate: appointment.endDate
      });
    }
    appointments = appointments.map((item) => {
      var _item$endDate;
      const resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();
      if (item.startDate.getTime() === resultEndTime) {
        item.endDate.setTime(resultEndTime + toMs10("minute"));
      }
      return _extends({}, item, {
        exceptionDate: new Date(item.startDate)
      });
    });
    return appointments;
  }
  _canProcessNotNativeTimezoneDates(appointment) {
    const isTimeZoneSet = !isEmptyObject(this.timeZone);
    if (!isTimeZoneSet) {
      return false;
    }
    if (!appointment.isRecurrent) {
      return false;
    }
    return !m_utils_time_zone_default.isEqualLocalTimeZone(this.timeZone, appointment.startDate);
  }
  _getProcessedNotNativeDateIfCrossDST(date, offset) {
    if (offset < 0) {
      const newDate = new Date(date);
      const newDateMinusOneHour = new Date(newDate);
      newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);
      const newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;
      const newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;
      if (newDateOffset !== newDateMinusOneHourOffset) {
        return 0;
      }
    }
    return offset;
  }
  _getCommonOffset(date) {
    return this.timeZoneCalculator.getOffsets(date).common;
  }
  _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {
    return appointmentList.map((item) => {
      let diffStartDateOffset = this._getCommonOffset(appointment.startDate) - this._getCommonOffset(item.startDate);
      let diffEndDateOffset = this._getCommonOffset(appointment.endDate) - this._getCommonOffset(item.endDate);
      if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {
        return item;
      }
      diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);
      diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);
      const newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs10("hour"));
      let newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs10("hour"));
      const testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {
        path: "toGrid"
      });
      const testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {
        path: "toGrid"
      });
      if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {
        newEndDate = new Date(newStartDate.getTime() + appointment.duration);
      }
      return _extends({}, item, {
        startDate: newStartDate,
        endDate: newEndDate,
        exceptionDate: new Date(newStartDate)
      });
    });
  }
  _needSeparateLongParts() {
    return this.isVerticalOrientation ? this.isGroupedByDate : this.isGroupedByDate && this.appointmentTakesAllDay;
  }
  normalizeEndDateByViewEnd(rawAppointment, endDate) {
    let result = new Date(endDate.getTime());
    const isAllDay = isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;
    if (!isAllDay) {
      const roundedEndViewDate = date_default2.roundToHour(this.endViewDate);
      if (result > roundedEndViewDate) {
        result = roundedEndViewDate;
      }
    }
    const endDayHour = this.viewEndDayHour;
    const allDay = ExpressionUtils.getField(this.dataAccessors, "allDay", rawAppointment);
    const currentViewEndTime = new Date(new Date(endDate.getTime()).setHours(endDayHour, 0, 0, 0));
    if (result.getTime() > currentViewEndTime.getTime() || allDay && result.getHours() < endDayHour) {
      result = currentViewEndTime;
    }
    return result;
  }
  _fillNormalizedEndDate(dateSettings, rawAppointment) {
    return dateSettings.map((item) => _extends({}, item, {
      normalizedEndDate: this.normalizeEndDateByViewEnd(rawAppointment, item.endDate)
    }));
  }
  _separateLongParts(gridAppointmentList, appointmentAdapter) {
    let result = [];
    gridAppointmentList.forEach((gridAppointment) => {
      const maxDate = new Date(this.dateRange[1]);
      const {
        startDate,
        normalizedEndDate: endDateOfPart
      } = gridAppointment;
      const longStartDateParts = date_default2.getDatesOfInterval(startDate, endDateOfPart, {
        milliseconds: this.getIntervalDuration()
      });
      const list = longStartDateParts.filter((startDatePart) => new Date(startDatePart) < maxDate).map((date) => {
        const endDate = new Date(new Date(date).setMilliseconds(appointmentAdapter.duration));
        const normalizedEndDate = this.normalizeEndDateByViewEnd(this.rawAppointment, endDate);
        return {
          startDate: date,
          endDate,
          normalizedEndDate,
          source: gridAppointment.source
        };
      });
      result = result.concat(list);
    });
    return result;
  }
  _createGridAppointmentList(appointmentList, appointmentAdapter) {
    return appointmentList.map((source) => {
      const offsetDifference = appointmentAdapter.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();
      if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {
        source.startDate = dateUtilsTs.addOffsets(source.startDate, [offsetDifference * toMs10("minute")]);
        source.endDate = dateUtilsTs.addOffsets(source.endDate, [offsetDifference * toMs10("minute")]);
        source.exceptionDate = new Date(source.startDate);
      }
      const duration = source.endDate.getTime() - source.startDate.getTime();
      const startDate = this.timeZoneCalculator.createDate(source.startDate, {
        path: "toGrid"
      });
      const endDate = dateUtilsTs.addOffsets(startDate, [duration]);
      return {
        startDate,
        endDate,
        allDay: appointmentAdapter.allDay || false,
        source
      };
    });
  }
  _createExtremeRecurrenceDates(groupIndex) {
    let startViewDate = this.appointmentTakesAllDay ? date_default2.trimTime(this.dateRange[0]) : this.dateRange[0];
    let endViewDateByEndDayHour = this.dateRange[1];
    if (this.timeZone) {
      startViewDate = this.timeZoneCalculator.createDate(startViewDate, {
        path: "fromGrid"
      });
      endViewDateByEndDayHour = this.timeZoneCalculator.createDate(endViewDateByEndDayHour, {
        path: "fromGrid"
      });
      const daylightOffset = m_utils_time_zone_default.getDaylightOffsetInMs(startViewDate, endViewDateByEndDayHour);
      if (daylightOffset) {
        endViewDateByEndDayHour = new Date(endViewDateByEndDayHour.getTime() + daylightOffset);
      }
    }
    return [startViewDate, endViewDateByEndDayHour];
  }
  _createRecurrenceOptions(appointment, groupIndex) {
    const {
      viewOffset
    } = this.options;
    const originalAppointmentStartDate = dateUtilsTs.addOffsets(appointment.startDate, [viewOffset]);
    const originalAppointmentEndDate = dateUtilsTs.addOffsets(appointment.endDate, [viewOffset]);
    const [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(groupIndex);
    const shiftedMinRecurrenceDate = dateUtilsTs.addOffsets(minRecurrenceDate, [viewOffset]);
    const shiftedMaxRecurrenceDate = dateUtilsTs.addOffsets(maxRecurrenceDate, [viewOffset]);
    return {
      rule: appointment.recurrenceRule,
      exception: appointment.recurrenceException,
      min: shiftedMinRecurrenceDate,
      max: shiftedMaxRecurrenceDate,
      firstDayOfWeek: this.firstDayOfWeek,
      start: originalAppointmentStartDate,
      end: originalAppointmentEndDate,
      appointmentTimezoneOffset: this.timeZoneCalculator.getOriginStartDateOffsetInMs(originalAppointmentStartDate, appointment.rawAppointment.startDateTimeZone, true),
      getPostProcessedException: (date) => {
        if (isEmptyObject(this.timeZone) || m_utils_time_zone_default.isEqualLocalTimeZone(this.timeZone, date)) {
          return date;
        }
        const appointmentOffset = this.timeZoneCalculator.getOffsets(originalAppointmentStartDate).common;
        const exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;
        let diff = appointmentOffset - exceptionAppointmentOffset;
        diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);
        return new Date(date.getTime() - diff * date_default2.dateToMilliseconds("hour"));
      }
    };
  }
  _createRecurrenceAppointments(appointment, groupIndices) {
    const {
      duration
    } = appointment;
    const {
      viewOffset
    } = this.options;
    const option = this._createRecurrenceOptions(appointment);
    const generatedStartDates = getRecurrenceProcessor().generateDates(option);
    return generatedStartDates.map((date) => {
      const utcDate = m_utils_time_zone_default.createUTCDateWithLocalOffset(date);
      utcDate.setTime(utcDate.getTime() + duration);
      const endDate = m_utils_time_zone_default.createDateFromUTCWithLocalOffset(utcDate);
      return {
        startDate: new Date(date),
        endDate
      };
    }).map((_ref) => {
      let {
        startDate,
        endDate
      } = _ref;
      return {
        startDate: dateUtilsTs.addOffsets(startDate, [-viewOffset]),
        endDate: dateUtilsTs.addOffsets(endDate, [-viewOffset])
      };
    });
  }
  _getAppointmentsFirstViewDate(appointments) {
    const {
      viewOffset
    } = this.options;
    return appointments.map((appointment) => {
      const tableFirstDate = this._getAppointmentFirstViewDate(_extends({}, appointment, {
        startDate: dateUtilsTs.addOffsets(appointment.startDate, [viewOffset]),
        endDate: dateUtilsTs.addOffsets(appointment.endDate, [viewOffset])
      }));
      if (!tableFirstDate) {
        return appointment.startDate;
      }
      const firstDate = dateUtilsTs.addOffsets(tableFirstDate, [-viewOffset]);
      return firstDate > appointment.startDate ? firstDate : appointment.startDate;
    });
  }
  _fillNormalizedStartDate(appointments, firstViewDates, rawAppointment) {
    return appointments.map((item, idx) => _extends({}, item, {
      startDate: this._getAppointmentResultDate({
        appointment: item,
        rawAppointment,
        startDate: new Date(item.startDate),
        startDayHour: this.viewStartDayHour,
        firstViewDate: firstViewDates[idx]
      })
    }));
  }
  _cropAppointmentsByStartDayHour(appointments, firstViewDates) {
    return appointments.filter((appointment, idx) => {
      if (!firstViewDates[idx]) {
        return false;
      }
      if (this.appointmentTakesAllDay) {
        return true;
      }
      return appointment.endDate > appointment.startDate;
    });
  }
  _getAppointmentResultDate(options) {
    const {
      appointment,
      startDayHour,
      firstViewDate
    } = options;
    let {
      startDate
    } = options;
    let resultDate;
    if (this.appointmentTakesAllDay) {
      resultDate = date_default2.normalizeDate(startDate, firstViewDate);
    } else {
      if (startDate < firstViewDate) {
        startDate = firstViewDate;
      }
      resultDate = date_default2.normalizeDate(appointment.startDate, startDate);
    }
    return !this.isDateAppointment ? date_default2.roundDateByStartDayHour(resultDate, startDayHour) : resultDate;
  }
  _getAppointmentFirstViewDate(appointment) {
    const groupIndex = appointment.source.groupIndex || 0;
    const {
      startDate,
      endDate
    } = appointment;
    if (this.isAllDayRowAppointment || appointment.allDay) {
      return this.viewDataProvider.findAllDayGroupCellStartDate(groupIndex);
    }
    return this.viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, this.isDateAppointment);
  }
  _getGroupIndices(rawAppointment) {
    let result = [];
    if (rawAppointment && this.loadedResources.length) {
      const tree = createResourcesTree(this.loadedResources);
      result = getResourceTreeLeaves((field, action) => getDataAccessors(this.options.dataAccessors.resources, field, action), tree, rawAppointment);
    }
    return result;
  }
};
var DateGeneratorVirtualStrategy = class extends DateGeneratorBaseStrategy {
  get groupCount() {
    return getGroupCount(this.loadedResources);
  }
  _createRecurrenceAppointments(appointment, groupIndices) {
    const {
      duration
    } = appointment;
    const result = [];
    const validGroupIndices = this.groupCount ? groupIndices : [0];
    validGroupIndices.forEach((groupIndex) => {
      const option = this._createRecurrenceOptions(appointment, groupIndex);
      const generatedStartDates = getRecurrenceProcessor().generateDates(option);
      const recurrentInfo = generatedStartDates.map((date) => {
        const startDate = new Date(date);
        const utcDate = m_utils_time_zone_default.createUTCDateWithLocalOffset(date);
        utcDate.setTime(utcDate.getTime() + duration);
        const endDate = m_utils_time_zone_default.createDateFromUTCWithLocalOffset(utcDate);
        return {
          startDate,
          endDate,
          groupIndex
        };
      });
      result.push(...recurrentInfo);
    });
    return result;
  }
  _updateGroupIndices(appointments, groupIndices) {
    const result = [];
    groupIndices.forEach((groupIndex) => {
      const groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);
      if (groupStartDate) {
        appointments.forEach((appointment) => {
          const appointmentCopy = extend({}, appointment);
          appointmentCopy.groupIndex = groupIndex;
          result.push(appointmentCopy);
        });
      }
    });
    return result;
  }
  _getGroupIndices(resources) {
    var _groupIndices;
    let groupIndices = super._getGroupIndices(resources);
    const viewDataGroupIndices = this.viewDataProvider.getGroupIndices();
    if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {
      groupIndices = [0];
    }
    return groupIndices.filter((groupIndex) => -1 !== viewDataGroupIndices.indexOf(groupIndex));
  }
  _createAppointments(appointment, groupIndices) {
    const appointments = super._createAppointments(appointment, groupIndices);
    return !appointment.isRecurrent ? this._updateGroupIndices(appointments, groupIndices) : appointments;
  }
};
var AppointmentSettingsGenerator = class {
  constructor(options) {
    this.options = options;
    this.appointmentAdapter = createAppointmentAdapter(this.rawAppointment, this.dataAccessors, this.timeZoneCalculator);
  }
  get rawAppointment() {
    return this.options.rawAppointment;
  }
  get dataAccessors() {
    return this.options.dataAccessors;
  }
  get timeZoneCalculator() {
    return this.options.timeZoneCalculator;
  }
  get isAllDayRowAppointment() {
    return this.options.appointmentTakesAllDay && this.options.supportAllDayRow;
  }
  get groups() {
    return this.options.groups;
  }
  get dateSettingsStrategy() {
    const options = _extends({}, this.options, {
      isAllDayRowAppointment: this.isAllDayRowAppointment
    });
    return this.options.isVirtualScrolling ? new DateGeneratorVirtualStrategy(options) : new DateGeneratorBaseStrategy(options);
  }
  create() {
    const {
      dateSettings,
      itemGroupIndices,
      isRecurrent
    } = this._generateDateSettings();
    const cellPositions = this._calculateCellPositions(dateSettings, itemGroupIndices);
    const result = this._prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent);
    return result;
  }
  _generateDateSettings() {
    return this.dateSettingsStrategy.generate(this.appointmentAdapter);
  }
  _calculateCellPositions(dateSettings, itemGroupIndices) {
    const cellPositionCalculator = new CellPositionCalculator(_extends({}, this.options, {
      dateSettings
    }));
    return cellPositionCalculator.calculateCellPositions(itemGroupIndices, this.isAllDayRowAppointment, this.appointmentAdapter.isRecurrent);
  }
  _prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent) {
    const infos = [];
    cellPositions.forEach((_ref2) => {
      let {
        coordinates,
        dateSettingIndex
      } = _ref2;
      const dateSetting = dateSettings[dateSettingIndex];
      const dateText = this._getAppointmentDateText(dateSetting);
      const info = {
        appointment: dateSetting,
        sourceAppointment: dateSetting.source,
        dateText,
        isRecurrent
      };
      infos.push(_extends({}, coordinates, {
        info
      }));
    });
    return infos;
  }
  _getAppointmentDateText(sourceAppointment) {
    const {
      startDate,
      endDate,
      allDay
    } = sourceAppointment;
    return createFormattedDateText({
      startDate,
      endDate,
      allDay,
      format: "TIME"
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_appointments_positioning_strategy_base.js
var AppointmentPositioningStrategy = class {
  constructor(renderingStrategy) {
    this._renderingStrategy = renderingStrategy;
  }
  getDropDownAppointmentWidth(intervalCount, isAllDay) {
    if (isAllDay || !isDefined(isAllDay)) {
      return 75 * this._renderingStrategy.cellWidth / 100;
    }
    return 24;
  }
  getCollectorTopOffset(allDay) {
    return 3;
  }
  getCollectorLeftOffset() {
    return 3;
  }
  getAppointmentDefaultOffset() {
    if (this._renderingStrategy._isCompactTheme()) {
      return 22;
    }
    return this._renderingStrategy.appointmentOffset;
  }
  getDynamicAppointmentCountPerCell() {
    const renderingStrategy = this._renderingStrategy;
    const {
      cellHeight
    } = renderingStrategy;
    const allDayCount = Math.floor((cellHeight - renderingStrategy._getAppointmentDefaultOffset()) / renderingStrategy._getAppointmentDefaultHeight()) || this._getAppointmentMinCount();
    if (renderingStrategy.allDaySupported()) {
      return {
        allDay: "vertical" === renderingStrategy.groupOrientation ? allDayCount : this._renderingStrategy.appointmentCountPerCell,
        simple: this._calculateDynamicAppointmentCountPerCell() || this._getAppointmentMinCount()
      };
    }
    return allDayCount;
  }
  getDropDownAppointmentHeight() {
    return;
  }
  _getAppointmentMinCount() {
    return 1;
  }
  _calculateDynamicAppointmentCountPerCell() {
    return Math.floor(this._renderingStrategy._getAppointmentMaxWidth() / 50);
  }
  _getAppointmentDefaultWidth() {
    return 40;
  }
};
var m_appointments_positioning_strategy_base_default = AppointmentPositioningStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_appointments_positioning_strategy_adaptive.js
var AdaptivePositioningStrategy = class extends m_appointments_positioning_strategy_base_default {
  getDropDownAppointmentWidth(intervalCount, isAllDay) {
    return this.getDropDownButtonAdaptiveSize();
  }
  getDropDownButtonAdaptiveSize() {
    return 28;
  }
  getCollectorTopOffset(allDay) {
    const renderingStrategy = this._renderingStrategy;
    if (renderingStrategy.allDaySupported() && allDay) {
      return (renderingStrategy.allDayHeight - renderingStrategy.getDropDownButtonAdaptiveSize()) / 2;
    }
    return this._renderingStrategy.cellHeight - 40;
  }
  getCollectorLeftOffset() {
    const collectorWidth = this._renderingStrategy.getDropDownAppointmentWidth();
    return (this._renderingStrategy.cellWidth - collectorWidth) / 2;
  }
  getAppointmentDefaultOffset() {
    return 35;
  }
  getDynamicAppointmentCountPerCell() {
    const renderingStrategy = this._renderingStrategy;
    if (renderingStrategy.allDaySupported()) {
      return {
        allDay: 0,
        simple: this._calculateDynamicAppointmentCountPerCell() || this._getAppointmentMinCount()
      };
    }
    return 0;
  }
  getDropDownAppointmentHeight() {
    return 28;
  }
  _getAppointmentMinCount() {
    return 0;
  }
  _getAppointmentDefaultWidth() {
    const renderingStrategy = this._renderingStrategy;
    if (renderingStrategy.allDaySupported()) {
      return 30;
    }
    return super._getAppointmentDefaultWidth();
  }
  _calculateDynamicAppointmentCountPerCell() {
    return Math.floor(this._renderingStrategy._getAppointmentMaxWidth() / this._renderingStrategy._getAppointmentDefaultWidth());
  }
};
var m_appointments_positioning_strategy_adaptive_default = AdaptivePositioningStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_base.js
var toMs11 = date_default2.dateToMilliseconds;
var BaseRenderingStrategy = class {
  constructor(options) {
    this.options = options;
    this._initPositioningStrategy();
  }
  get isAdaptive() {
    return this.options.adaptivityEnabled;
  }
  get rtlEnabled() {
    return this.options.rtlEnabled;
  }
  get startDayHour() {
    return this.options.startDayHour;
  }
  get endDayHour() {
    return this.options.endDayHour;
  }
  get maxAppointmentsPerCell() {
    return this.options.maxAppointmentsPerCell;
  }
  get cellWidth() {
    return this.options.cellWidth;
  }
  get cellHeight() {
    return this.options.cellHeight;
  }
  get allDayHeight() {
    return this.options.allDayHeight;
  }
  get resizableStep() {
    return this.options.resizableStep;
  }
  get isGroupedByDate() {
    return this.options.isGroupedByDate;
  }
  get visibleDayDuration() {
    return this.options.visibleDayDuration;
  }
  get viewStartDayHour() {
    return this.options.viewStartDayHour;
  }
  get viewEndDayHour() {
    return this.options.viewEndDayHour;
  }
  get cellDuration() {
    return this.options.cellDuration;
  }
  get cellDurationInMinutes() {
    return this.options.cellDurationInMinutes;
  }
  get leftVirtualCellCount() {
    return this.options.leftVirtualCellCount;
  }
  get topVirtualCellCount() {
    return this.options.topVirtualCellCount;
  }
  get positionHelper() {
    return this.options.positionHelper;
  }
  get showAllDayPanel() {
    return this.options.showAllDayPanel;
  }
  get isGroupedAllDayPanel() {
    return this.options.isGroupedAllDayPanel;
  }
  get groupOrientation() {
    return this.options.groupOrientation;
  }
  get rowCount() {
    return this.options.rowCount;
  }
  get groupCount() {
    return this.options.groupCount;
  }
  get currentDate() {
    return this.options.currentDate;
  }
  get appointmentCountPerCell() {
    return this.options.appointmentCountPerCell;
  }
  get appointmentOffset() {
    return this.options.appointmentOffset;
  }
  get allowResizing() {
    return this.options.allowResizing;
  }
  get allowAllDayResizing() {
    return this.options.allowAllDayResizing;
  }
  get viewDataProvider() {
    return this.options.viewDataProvider;
  }
  get dataAccessors() {
    return this.options.dataAccessors;
  }
  get timeZoneCalculator() {
    return this.options.timeZoneCalculator;
  }
  get intervalCount() {
    return this.options.intervalCount;
  }
  get allDayPanelMode() {
    return this.options.allDayPanelMode;
  }
  get isVirtualScrolling() {
    return this.options.isVirtualScrolling;
  }
  _correctCollectorCoordinatesInAdaptive(coordinates, isAllDay) {
    coordinates.top += this.getCollectorTopOffset(isAllDay);
    coordinates.left += this.getCollectorLeftOffset();
  }
  _initPositioningStrategy() {
    this._positioningStrategy = this.isAdaptive ? new m_appointments_positioning_strategy_adaptive_default(this) : new m_appointments_positioning_strategy_base_default(this);
  }
  getPositioningStrategy() {
    return this._positioningStrategy;
  }
  getAppointmentMinSize() {
    return 2;
  }
  keepAppointmentSettings() {
    return false;
  }
  getDeltaTime(args, initialSize, appointment) {
  }
  getAppointmentGeometry(coordinates) {
    return coordinates;
  }
  needCorrectAppointmentDates() {
    return true;
  }
  getDirection() {
    return "horizontal";
  }
  createTaskPositionMap(items, skipSorting) {
    delete this._maxAppointmentCountPerCell;
    const length = null === items || void 0 === items ? void 0 : items.length;
    if (!length) {
      return;
    }
    const map2 = [];
    for (let i = 0; i < length; i++) {
      let coordinates = this._getItemPosition(items[i]);
      if (coordinates.length && this.rtlEnabled) {
        coordinates = this._correctRtlCoordinates(coordinates);
      }
      coordinates.forEach((item) => {
        item.leftVirtualCellCount = this.leftVirtualCellCount;
        item.topVirtualCellCount = this.topVirtualCellCount;
        item.leftVirtualWidth = this.leftVirtualCellCount * this.cellWidth;
        item.topVirtualHeight = this.topVirtualCellCount * this.cellHeight;
      });
      map2.push(coordinates);
    }
    const positionArray = this._getSortedPositions(map2);
    const resultPositions = this._getResultPositions(positionArray);
    return this._getExtendedPositionMap(map2, resultPositions);
  }
  _getDeltaWidth(args, initialSize) {
    const intervalWidth = this.resizableStep || this.getAppointmentMinSize();
    const initialWidth = initialSize.width;
    return Math.round((args.width - initialWidth) / intervalWidth);
  }
  _correctRtlCoordinates(coordinates) {
    const width = coordinates[0].width || this._getAppointmentMaxWidth();
    coordinates.forEach((coordinate) => {
      if (!coordinate.appointmentReduced) {
        coordinate.left -= width;
      }
    });
    return coordinates;
  }
  _getAppointmentMaxWidth() {
    return this.cellWidth;
  }
  _getItemPosition(initialAppointment) {
    const appointment = this.shiftAppointmentByViewOffset(initialAppointment);
    const position = this.generateAppointmentSettings(appointment);
    const allDay = this.isAllDay(appointment);
    let result = [];
    for (let j = 0; j < position.length; j++) {
      const height = this.calculateAppointmentHeight(appointment, position[j]);
      const width = this.calculateAppointmentWidth(appointment, position[j]);
      let resultWidth = width;
      let appointmentReduced = null;
      let multiWeekAppointmentParts = [];
      let initialRowIndex = position[j].rowIndex;
      let initialColumnIndex = position[j].columnIndex;
      if (this._needVerifyItemSize() || allDay) {
        const currentMaxAllowedPosition = position[j].hMax;
        if (this.isAppointmentGreaterThan(currentMaxAllowedPosition, {
          left: position[j].left,
          width
        })) {
          appointmentReduced = "head";
          initialRowIndex = position[j].rowIndex;
          initialColumnIndex = position[j].columnIndex;
          resultWidth = this._reduceMultiWeekAppointment(width, {
            left: position[j].left,
            right: currentMaxAllowedPosition
          });
          multiWeekAppointmentParts = this._getAppointmentParts({
            sourceAppointmentWidth: width,
            reducedWidth: resultWidth,
            height
          }, position[j]);
          if (this.rtlEnabled) {
            position[j].left = currentMaxAllowedPosition;
          }
        }
      }
      extend(position[j], {
        height,
        width: resultWidth,
        allDay,
        rowIndex: initialRowIndex,
        columnIndex: initialColumnIndex,
        appointmentReduced
      });
      result = this._getAppointmentPartsPosition(multiWeekAppointmentParts, position[j], result);
    }
    return result;
  }
  _getAppointmentPartsPosition(appointmentParts, position, result) {
    if (appointmentParts.length) {
      appointmentParts.unshift(position);
      result = result.concat(appointmentParts);
    } else {
      result.push(position);
    }
    return result;
  }
  getAppointmentSettingsGenerator(rawAppointment) {
    return new AppointmentSettingsGenerator(_extends({
      rawAppointment,
      appointmentTakesAllDay: this.isAppointmentTakesAllDay(rawAppointment),
      getPositionShiftCallback: this.getPositionShift.bind(this)
    }, this.options));
  }
  generateAppointmentSettings(rawAppointment) {
    return this.getAppointmentSettingsGenerator(rawAppointment).create();
  }
  isAppointmentTakesAllDay(rawAppointment) {
    const adapter = createAppointmentAdapter(rawAppointment, this.dataAccessors, this.timeZoneCalculator);
    return getAppointmentTakesAllDay(adapter, this.allDayPanelMode);
  }
  _getAppointmentParts(geometry, settings) {
    return [];
  }
  _getCompactAppointmentParts(appointmentWidth) {
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    return Math.round(appointmentWidth / cellWidth);
  }
  _reduceMultiWeekAppointment(sourceAppointmentWidth, bound) {
    if (this.rtlEnabled) {
      sourceAppointmentWidth = Math.floor(bound.left - bound.right);
    } else {
      sourceAppointmentWidth = bound.right - Math.floor(bound.left);
    }
    return sourceAppointmentWidth;
  }
  calculateAppointmentHeight(appointment, position) {
    return 0;
  }
  calculateAppointmentWidth(appointment, position) {
    return 0;
  }
  isAppointmentGreaterThan(etalon, comparisonParameters) {
    let result = comparisonParameters.left + comparisonParameters.width - etalon;
    if (this.rtlEnabled) {
      result = etalon + comparisonParameters.width - comparisonParameters.left;
    }
    return result > this.cellWidth / 2;
  }
  isAllDay(appointment) {
    return false;
  }
  cropAppointmentWidth(width, cellWidth) {
    return this.isGroupedByDate ? cellWidth : width;
  }
  _getSortedPositions(positionList, skipSorting) {
    const result = [];
    const round = (value2) => Math.round(100 * value2) / 100;
    const createItem = (rowIndex, columnIndex, top, left, bottom, right, position, allDay) => ({
      i: rowIndex,
      j: columnIndex,
      top: round(top),
      left: round(left),
      bottom: round(bottom),
      right: round(right),
      cellPosition: position,
      allDay
    });
    for (let rowIndex = 0, rowCount = positionList.length; rowIndex < rowCount; rowIndex++) {
      for (let columnIndex = 0, cellCount = positionList[rowIndex].length; columnIndex < cellCount; columnIndex++) {
        const {
          top,
          left,
          height,
          width,
          cellPosition,
          allDay
        } = positionList[rowIndex][columnIndex];
        result.push(createItem(rowIndex, columnIndex, top, left, top + height, left + width, cellPosition, allDay));
      }
    }
    return result.sort((a, b) => this._sortCondition(a, b));
  }
  _sortCondition(a, b) {
  }
  _getConditions(a, b) {
    const isSomeEdge = this._isSomeEdge(a, b);
    return {
      columnCondition: isSomeEdge || this._normalizeCondition(a.left, b.left),
      rowCondition: isSomeEdge || this._normalizeCondition(a.top, b.top),
      cellPositionCondition: isSomeEdge || this._normalizeCondition(a.cellPosition, b.cellPosition)
    };
  }
  _rowCondition(a, b) {
    const conditions = this._getConditions(a, b);
    return conditions.columnCondition || conditions.rowCondition;
  }
  _columnCondition(a, b) {
    const conditions = this._getConditions(a, b);
    return conditions.rowCondition || conditions.columnCondition;
  }
  _isSomeEdge(a, b) {
    return a.i === b.i && a.j === b.j;
  }
  _normalizeCondition(first, second) {
    const result = first - second;
    return Math.abs(result) > 1 ? result : 0;
  }
  _isItemsCross(firstItem, secondItem) {
    const areItemsInTheSameTable = !!firstItem.allDay === !!secondItem.allDay;
    const areItemsAllDay = firstItem.allDay && secondItem.allDay;
    if (areItemsInTheSameTable) {
      const orientation = this._getOrientation(areItemsAllDay);
      return this._checkItemsCrossing(firstItem, secondItem, orientation);
    }
    return false;
  }
  _checkItemsCrossing(firstItem, secondItem, orientation) {
    const firstItemSide1 = Math.floor(firstItem[orientation[0]]);
    const firstItemSide2 = Math.floor(firstItem[orientation[1]]);
    const secondItemSide1 = Math.ceil(secondItem[orientation[0]]);
    const secondItemSide2 = Math.ceil(secondItem[orientation[1]]);
    const isItemCross = Math.abs(firstItem[orientation[2]] - secondItem[orientation[2]]) <= 1;
    return isItemCross && (firstItemSide1 <= secondItemSide1 && firstItemSide2 > secondItemSide1 || firstItemSide1 < secondItemSide2 && firstItemSide2 >= secondItemSide2 || firstItemSide1 === secondItemSide1 && firstItemSide2 === secondItemSide2);
  }
  _getOrientation(isAllDay) {
    return isAllDay ? ["left", "right", "top"] : ["top", "bottom", "left"];
  }
  _getResultPositions(sortedArray) {
    const result = [];
    let i;
    let sortedIndex = 0;
    let currentItem;
    let indexes;
    let itemIndex;
    let maxIndexInStack = 0;
    let stack = {};
    const findFreeIndex = (indexes2, index) => {
      const isFind = indexes2.some((item) => item === index);
      if (isFind) {
        return findFreeIndex(indexes2, ++index);
      }
      return index;
    };
    const createItem = (currentItem2, index) => {
      const currentIndex = index || 0;
      return {
        index: currentIndex,
        i: currentItem2.i,
        j: currentItem2.j,
        left: currentItem2.left,
        right: currentItem2.right,
        top: currentItem2.top,
        bottom: currentItem2.bottom,
        allDay: currentItem2.allDay,
        sortedIndex: this._skipSortedIndex(currentIndex) ? null : sortedIndex++
      };
    };
    const startNewStack = (currentItem2) => {
      stack.items = [createItem(currentItem2)];
      stack.left = currentItem2.left;
      stack.right = currentItem2.right;
      stack.top = currentItem2.top;
      stack.bottom = currentItem2.bottom;
      stack.allDay = currentItem2.allDay;
    };
    const pushItemsInResult = (items) => {
      items.forEach((item) => {
        result.push({
          index: item.index,
          count: maxIndexInStack + 1,
          i: item.i,
          j: item.j,
          sortedIndex: item.sortedIndex
        });
      });
    };
    for (i = 0; i < sortedArray.length; i++) {
      currentItem = sortedArray[i];
      indexes = [];
      if (!stack.items) {
        startNewStack(currentItem);
      } else if (this._isItemsCross(stack, currentItem)) {
        stack.items.forEach((item) => {
          if (this._isItemsCross(item, currentItem)) {
            indexes.push(item.index);
          }
        });
        itemIndex = indexes.length ? findFreeIndex(indexes, 0) : 0;
        stack.items.push(createItem(currentItem, itemIndex));
        maxIndexInStack = Math.max(itemIndex, maxIndexInStack);
        stack.left = Math.min(stack.left, currentItem.left);
        stack.right = Math.max(stack.right, currentItem.right);
        stack.top = Math.min(stack.top, currentItem.top);
        stack.bottom = Math.max(stack.bottom, currentItem.bottom);
        stack.allDay = currentItem.allDay;
      } else {
        pushItemsInResult(stack.items);
        stack = {};
        startNewStack(currentItem);
        maxIndexInStack = 0;
      }
    }
    if (stack.items) {
      pushItemsInResult(stack.items);
    }
    return result.sort((a, b) => {
      const columnCondition = a.j - b.j;
      const rowCondition = a.i - b.i;
      return rowCondition || columnCondition;
    });
  }
  _skipSortedIndex(index) {
    return index > this._getMaxAppointmentCountPerCell() - 1;
  }
  _findIndexByKey(arr, iKey, jKey, iValue, jValue) {
    let result = 0;
    for (let i = 0, len = arr.length; i < len; i++) {
      if (arr[i][iKey] === iValue && arr[i][jKey] === jValue) {
        result = i;
        break;
      }
    }
    return result;
  }
  _getExtendedPositionMap(map2, positions) {
    let positionCounter = 0;
    const result = [];
    for (let i = 0, mapLength = map2.length; i < mapLength; i++) {
      const resultString = [];
      for (let j = 0, itemLength = map2[i].length; j < itemLength; j++) {
        map2[i][j].index = positions[positionCounter].index;
        map2[i][j].sortedIndex = positions[positionCounter].sortedIndex;
        map2[i][j].count = positions[positionCounter++].count;
        resultString.push(map2[i][j]);
        this._checkLongCompactAppointment(map2[i][j], resultString);
      }
      result.push(resultString);
    }
    return result;
  }
  _checkLongCompactAppointment(item, result) {
    this._splitLongCompactAppointment(item, result);
    return result;
  }
  _splitLongCompactAppointment(item, result) {
    const appointmentCountPerCell = this._getMaxAppointmentCountPerCellByType(item.allDay);
    let compactCount = 0;
    if (void 0 !== appointmentCountPerCell && item.index > appointmentCountPerCell - 1) {
      item.isCompact = true;
      compactCount = this._getCompactAppointmentParts(item.width);
      for (let k = 1; k < compactCount; k++) {
        const compactPart = extend(true, {}, item);
        compactPart.left = this._getCompactLeftCoordinate(item.left, k);
        compactPart.columnIndex += k;
        compactPart.sortedIndex = null;
        result.push(compactPart);
      }
    }
    return result;
  }
  _adjustDurationByDaylightDiff(duration, startDate, endDate) {
    const {
      viewOffset
    } = this.options;
    const originalStartDate = dateUtilsTs.addOffsets(startDate, [viewOffset]);
    const originalEndDate = dateUtilsTs.addOffsets(endDate, [viewOffset]);
    const daylightDiff = m_utils_time_zone_default.getDaylightOffset(originalStartDate, originalEndDate);
    const correctedDuration = this._needAdjustDuration(daylightDiff) ? this._calculateDurationByDaylightDiff(duration, daylightDiff) : duration;
    return correctedDuration <= Math.abs(daylightDiff) ? duration : correctedDuration;
  }
  _needAdjustDuration(diff) {
    return 0 !== diff;
  }
  _calculateDurationByDaylightDiff(duration, diff) {
    return duration + diff * toMs11("minute");
  }
  _getCollectorLeftOffset(isAllDay) {
    if (isAllDay || !this.isApplyCompactAppointmentOffset()) {
      return 0;
    }
    const dropDownButtonWidth = this.getDropDownAppointmentWidth(this.intervalCount, isAllDay);
    const rightOffset = this._isCompactTheme() ? 1 : 5;
    return this.cellWidth - dropDownButtonWidth - rightOffset;
  }
  _markAppointmentAsVirtual(coordinates) {
    let isAllDay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const countFullWidthAppointmentInCell = this._getMaxAppointmentCountPerCellByType(isAllDay);
    if (coordinates.count - countFullWidthAppointmentInCell > 0) {
      const {
        top,
        left
      } = coordinates;
      const compactRender = this.isAdaptive || !isAllDay && this.supportCompactDropDownAppointments();
      coordinates.virtual = {
        left: left + this._getCollectorLeftOffset(isAllDay),
        top,
        width: this.getDropDownAppointmentWidth(this.intervalCount, isAllDay),
        height: this.getDropDownAppointmentHeight(),
        index: this._generateAppointmentCollectorIndex(coordinates, isAllDay),
        isAllDay,
        groupIndex: coordinates.groupIndex,
        isCompact: compactRender
      };
    }
  }
  isApplyCompactAppointmentOffset() {
    return this.supportCompactDropDownAppointments();
  }
  supportCompactDropDownAppointments() {
    return true;
  }
  _generateAppointmentCollectorIndex(_ref, isAllDay) {
    let {
      groupIndex,
      rowIndex,
      columnIndex
    } = _ref;
    return `${groupIndex}-${rowIndex}-${columnIndex}-${isAllDay}`;
  }
  _getMaxAppointmentCountPerCellByType(isAllDay) {
    const appointmentCountPerCell = this._getMaxAppointmentCountPerCell();
    if (isObject(appointmentCountPerCell)) {
      return isAllDay ? appointmentCountPerCell.allDay : appointmentCountPerCell.simple;
    }
    return appointmentCountPerCell;
  }
  getDropDownAppointmentWidth(intervalCount, isAllDay) {
    return this.getPositioningStrategy().getDropDownAppointmentWidth(intervalCount, isAllDay);
  }
  getDropDownAppointmentHeight() {
    return this.getPositioningStrategy().getDropDownAppointmentHeight();
  }
  getDropDownButtonAdaptiveSize() {
    return 28;
  }
  getCollectorTopOffset(allDay) {
    return this.getPositioningStrategy().getCollectorTopOffset(allDay);
  }
  getCollectorLeftOffset() {
    return this.getPositioningStrategy().getCollectorLeftOffset();
  }
  getAppointmentDataCalculator() {
  }
  getVerticalAppointmentHeight(cellHeight, currentAppointmentCountInCell, maxAppointmentsPerCell) {
    let resultMaxAppointmentsPerCell = maxAppointmentsPerCell;
    if (isNumeric(this.maxAppointmentsPerCell)) {
      const dynamicAppointmentCountPerCell = this._getDynamicAppointmentCountPerCell();
      const maxAppointmentCountDisplayedInCell = dynamicAppointmentCountPerCell.allDay || dynamicAppointmentCountPerCell;
      const maxAppointmentsCount = Math.max(currentAppointmentCountInCell, maxAppointmentCountDisplayedInCell);
      resultMaxAppointmentsPerCell = Math.min(maxAppointmentsCount, maxAppointmentsPerCell);
    }
    return cellHeight / resultMaxAppointmentsPerCell;
  }
  _customizeCoordinates(coordinates, cellHeight, appointmentCountPerCell, topOffset, isAllDay) {
    const {
      index,
      count
    } = coordinates;
    const appointmentHeight = this.getVerticalAppointmentHeight(cellHeight, count, appointmentCountPerCell);
    const appointmentTop = coordinates.top + index * appointmentHeight;
    const top = appointmentTop + topOffset;
    const {
      width
    } = coordinates;
    const {
      left
    } = coordinates;
    if (coordinates.isCompact) {
      this.isAdaptive && this._correctCollectorCoordinatesInAdaptive(coordinates, isAllDay);
      this._markAppointmentAsVirtual(coordinates, isAllDay);
    }
    return {
      height: appointmentHeight,
      width,
      top,
      left,
      empty: this._isAppointmentEmpty(cellHeight, width)
    };
  }
  _isAppointmentEmpty(height, width) {
    return height < this._getAppointmentMinHeight() || width < this._getAppointmentMinWidth();
  }
  _calculateGeometryConfig(coordinates) {
    const overlappingMode = this.maxAppointmentsPerCell;
    const offsets = this._getOffsets();
    const appointmentDefaultOffset = this._getAppointmentDefaultOffset();
    let appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);
    let ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);
    let maxHeight = this._getMaxHeight();
    if (!isNumeric(appointmentCountPerCell)) {
      appointmentCountPerCell = coordinates.count;
      ratio = (maxHeight - offsets.unlimited) / maxHeight;
    }
    let topOffset = (1 - ratio) * maxHeight;
    if ("auto" === overlappingMode || isNumeric(overlappingMode)) {
      ratio = 1;
      maxHeight -= appointmentDefaultOffset;
      topOffset = appointmentDefaultOffset;
    }
    return {
      height: ratio * maxHeight,
      appointmentCountPerCell,
      offset: topOffset
    };
  }
  _getAppointmentCount(overlappingMode, coordinates) {
  }
  _getDefaultRatio(coordinates, appointmentCountPerCell) {
  }
  _getOffsets() {
  }
  _getMaxHeight() {
  }
  _needVerifyItemSize() {
    return false;
  }
  _getMaxAppointmentCountPerCell() {
    if (!this._maxAppointmentCountPerCell) {
      const overlappingMode = this.maxAppointmentsPerCell;
      let appointmentCountPerCell;
      if (isNumeric(overlappingMode)) {
        appointmentCountPerCell = overlappingMode;
      }
      if ("auto" === overlappingMode) {
        appointmentCountPerCell = this._getDynamicAppointmentCountPerCell();
      }
      if ("unlimited" === overlappingMode) {
        appointmentCountPerCell = void 0;
      }
      this._maxAppointmentCountPerCell = appointmentCountPerCell;
    }
    return this._maxAppointmentCountPerCell;
  }
  _getDynamicAppointmentCountPerCell() {
    return this.getPositioningStrategy().getDynamicAppointmentCountPerCell();
  }
  allDaySupported() {
    return false;
  }
  _isCompactTheme() {
    return "compact" === (current() || "").split(".").pop();
  }
  _getAppointmentDefaultOffset() {
    return this.getPositioningStrategy().getAppointmentDefaultOffset();
  }
  _getAppointmentDefaultHeight() {
    return this._getAppointmentHeightByTheme();
  }
  _getAppointmentMinHeight() {
    return this._getAppointmentDefaultHeight();
  }
  _getAppointmentHeightByTheme() {
    return this._isCompactTheme() ? 18 : 20;
  }
  _getAppointmentDefaultWidth() {
    return this.getPositioningStrategy()._getAppointmentDefaultWidth();
  }
  _getAppointmentMinWidth() {
    return this._getAppointmentDefaultWidth();
  }
  _needVerticalGroupBounds(allDay) {
    return false;
  }
  _needHorizontalGroupBounds() {
    return false;
  }
  getAppointmentDurationInMs(apptStartDate, apptEndDate, allDay) {
    if (allDay) {
      const appointmentDuration = apptEndDate.getTime() - apptStartDate.getTime();
      const ceilQuantityOfDays = Math.ceil(appointmentDuration / toMs11("day"));
      return ceilQuantityOfDays * this.visibleDayDuration;
    }
    const msInHour = toMs11("hour");
    const trimmedStartDate = date_default2.trimTime(apptStartDate);
    const trimmedEndDate = date_default2.trimTime(apptEndDate);
    const deltaDate = trimmedEndDate - trimmedStartDate;
    const quantityOfDays = deltaDate / toMs11("day") + 1;
    const dayVisibleHours = this.endDayHour - this.startDayHour;
    const appointmentDayHours = dayVisibleHours * quantityOfDays;
    const startHours = (apptStartDate - trimmedStartDate) / msInHour;
    const apptStartDelta = Math.max(0, startHours - this.startDayHour);
    const endHours = Math.max(0, (apptEndDate - trimmedEndDate) / msInHour - this.startDayHour);
    const apptEndDelta = Math.max(0, dayVisibleHours - endHours);
    const result = (appointmentDayHours - (apptStartDelta + apptEndDelta)) * msInHour;
    return result;
  }
  getPositionShift(timeShift, isAllDay) {
    return {
      top: timeShift * this.cellHeight,
      left: 0,
      cellPosition: 0
    };
  }
  shiftAppointmentByViewOffset(appointment) {
    const {
      viewOffset
    } = this.options;
    const startDateField = this.dataAccessors.expr.startDateExpr;
    const endDateField = this.dataAccessors.expr.endDateExpr;
    let startDate = new Date(ExpressionUtils.getField(this.dataAccessors, "startDate", appointment));
    startDate = dateUtilsTs.addOffsets(startDate, [-viewOffset]);
    let endDate = new Date(ExpressionUtils.getField(this.dataAccessors, "endDate", appointment));
    endDate = dateUtilsTs.addOffsets(endDate, [-viewOffset]);
    return _extends({}, appointment, {
      [startDateField]: startDate,
      [endDateField]: endDate
    });
  }
};
var m_strategy_base_default = BaseRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_agenda.js
var AgendaRenderingStrategy = class extends m_strategy_base_default {
  get instance() {
    return this.options.instance;
  }
  get agendaDuration() {
    return this.options.agendaDuration;
  }
  getAppointmentMinSize() {
  }
  getDeltaTime() {
  }
  keepAppointmentSettings() {
    return true;
  }
  getAppointmentGeometry(geometry) {
    return geometry;
  }
  groupAppointmentByResources(appointments) {
    const groups = this.instance._getCurrentViewOption("groups");
    const config = {
      loadedResources: this.options.loadedResources,
      resources: this.options.resources,
      dataAccessors: this.dataAccessors.resources
    };
    return groupAppointmentsByResources(config, appointments, groups);
  }
  createTaskPositionMap(appointments) {
    let height;
    let appointmentsByResources;
    this.calculateRows(appointments, this.agendaDuration, this.currentDate);
    if (appointments.length) {
      height = this.instance.fire("getAgendaVerticalStepHeight");
      appointmentsByResources = this.groupAppointmentByResources(appointments);
      let groupedAppts = [];
      each(appointmentsByResources, (i, appts) => {
        let additionalAppointments = [];
        let recurrentIndexes = [];
        each(appts, (index, appointment) => {
          const recurrenceBatch = this.instance.getAppointmentsInstance()._processRecurrenceAppointment(appointment, index);
          let appointmentBatch = null;
          if (!recurrenceBatch.indexes.length) {
            appointmentBatch = this.instance.getAppointmentsInstance()._processLongAppointment(appointment);
            additionalAppointments = additionalAppointments.concat(appointmentBatch.parts);
          }
          additionalAppointments = additionalAppointments.concat(recurrenceBatch.parts);
          recurrentIndexes = recurrentIndexes.concat(recurrenceBatch.indexes);
        });
        this.instance.getAppointmentsInstance()._reduceRecurrenceAppointments(recurrentIndexes, appts);
        this.instance.getAppointmentsInstance()._combineAppointments(appts, additionalAppointments);
        groupedAppts = groupedAppts.concat(appts);
      });
      Array.prototype.splice.apply(appointments, [0, appointments.length].concat(groupedAppts));
    }
    const result = [];
    let sortedIndex = 0;
    appointments.forEach((appt, index) => {
      result.push([{
        height,
        width: "100%",
        sortedIndex: sortedIndex++,
        groupIndex: this._calculateGroupIndex(index, appointmentsByResources),
        agendaSettings: appt.settings
      }]);
      delete appt.settings;
    });
    return result;
  }
  _calculateGroupIndex(apptIndex, appointmentsByResources) {
    let resultInd;
    let counter = 0;
    for (const i in appointmentsByResources) {
      const countApptInGroup = appointmentsByResources[i].length;
      if (apptIndex >= counter && apptIndex < counter + countApptInGroup) {
        resultInd = Number(i);
        break;
      }
      counter += countApptInGroup;
    }
    return resultInd;
  }
  _getDeltaWidth(args, initialSize) {
  }
  _getAppointmentMaxWidth() {
    return this.cellWidth;
  }
  _needVerifyItemSize() {
    return false;
  }
  _getAppointmentParts(geometry, settings) {
  }
  _reduceMultiWeekAppointment() {
  }
  calculateAppointmentHeight() {
    return 0;
  }
  calculateAppointmentWidth() {
    return 0;
  }
  isAppointmentGreaterThan(etalon, comparisonParameters) {
  }
  isAllDay() {
    return false;
  }
  _sortCondition() {
  }
  _rowCondition(a, b) {
  }
  _columnCondition(a, b) {
  }
  _findIndexByKey(arr, iKey, jKey, iValue, jValue) {
  }
  _markAppointmentAsVirtual() {
  }
  getDropDownAppointmentWidth() {
  }
  getCollectorLeftOffset() {
  }
  getCollectorTopOffset() {
  }
  replaceWrongAppointmentEndDate(rawAppointment, startDate, endDate) {
    const adapter = createAppointmentAdapter(rawAppointment, this.dataAccessors, this.timeZoneCalculator);
    replaceWrongEndDate(adapter, startDate, endDate, this.cellDuration, this.dataAccessors);
  }
  calculateRows(appointments, agendaDuration, currentDate, needClearSettings) {
    this._rows = [];
    currentDate = date_default2.trimTime(new Date(currentDate));
    const groupedAppointments = this.groupAppointmentByResources(appointments);
    each(groupedAppointments, (_, currentAppointments) => {
      const groupResult = [];
      const appts = {
        indexes: [],
        parts: []
      };
      if (!currentAppointments.length) {
        this._rows.push([]);
        return true;
      }
      each(currentAppointments, (index, appointment) => {
        const startDate = ExpressionUtils.getField(this.dataAccessors, "startDate", appointment);
        const endDate = ExpressionUtils.getField(this.dataAccessors, "endDate", appointment);
        this.replaceWrongAppointmentEndDate(appointment, startDate, endDate);
        needClearSettings && delete appointment.settings;
        const result = this.instance.getAppointmentsInstance()._processRecurrenceAppointment(appointment, index, false);
        appts.parts = appts.parts.concat(result.parts);
        appts.indexes = appts.indexes.concat(result.indexes);
      });
      this.instance.getAppointmentsInstance()._reduceRecurrenceAppointments(appts.indexes, currentAppointments);
      currentAppointments.push(...appts.parts);
      const appointmentCount = currentAppointments.length;
      for (let i = 0; i < agendaDuration; i++) {
        const day = new Date(currentDate);
        day.setMilliseconds(day.getMilliseconds() + 864e5 * i);
        if (void 0 === groupResult[i]) {
          groupResult[i] = 0;
        }
        for (let j = 0; j < appointmentCount; j++) {
          const appointmentData = currentAppointments[j].settings || currentAppointments[j];
          const adapter = createAppointmentAdapter(currentAppointments[j], this.dataAccessors, this.timeZoneCalculator);
          const appointmentIsLong = getAppointmentTakesSeveralDays(adapter);
          const appointmentIsRecurrence = ExpressionUtils.getField(this.dataAccessors, "recurrenceRule", currentAppointments[j]);
          if (this.instance.fire("dayHasAppointment", day, appointmentData, true) || !appointmentIsRecurrence && appointmentIsLong && this.instance.fire("dayHasAppointment", day, currentAppointments[j], true)) {
            groupResult[i] += 1;
          }
        }
      }
      this._rows.push(groupResult);
    });
    return this._rows;
  }
  _iterateRow(row, obj, index) {
    for (let i = 0; i < row.length; i++) {
      obj.counter += row[i];
      if (obj.counter >= index) {
        obj.indexInRow = i;
        break;
      }
    }
  }
  getDateByIndex(index, rows, startViewDate) {
    const obj = {
      counter: 0,
      indexInRow: 0
    };
    index++;
    for (let i = 0; i < rows.length; i++) {
      this._iterateRow(rows[i], obj, index);
      if (obj.indexInRow) {
        break;
      }
    }
    return new Date(new Date(startViewDate).setDate(startViewDate.getDate() + obj.indexInRow));
  }
  getAppointmentDataCalculator() {
    return ($appointment, originalStartDate) => {
      const apptIndex = $appointment.index();
      const startViewDate = this.instance.getStartViewDate();
      const calculatedStartDate = this.getDateByIndex(apptIndex, this._rows, startViewDate);
      const wrappedOriginalStartDate = new Date(originalStartDate);
      return {
        startDate: new Date(calculatedStartDate.setHours(wrappedOriginalStartDate.getHours(), wrappedOriginalStartDate.getMinutes(), wrappedOriginalStartDate.getSeconds(), wrappedOriginalStartDate.getMilliseconds()))
      };
    };
  }
};
var m_strategy_agenda_default = AgendaRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_horizontal.js
var toMs12 = date_default2.dateToMilliseconds;
var HorizontalRenderingStrategy = class extends m_strategy_base_default {
  _needVerifyItemSize() {
    return true;
  }
  calculateAppointmentWidth(appointment, position) {
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    const allDay = ExpressionUtils.getField(this.dataAccessors, "allDay", appointment);
    const {
      startDate,
      endDate,
      normalizedEndDate
    } = position.info.appointment;
    let duration = this.getAppointmentDurationInMs(startDate, normalizedEndDate, allDay);
    duration = this._adjustDurationByDaylightDiff(duration, startDate, normalizedEndDate);
    const cellDuration = this.cellDurationInMinutes * toMs12("minute");
    const skippedHours = getSkippedHoursInRange(startDate, endDate, appointment.allDay, this.viewDataProvider);
    const durationInCells = (duration - skippedHours * toMs12("hour")) / cellDuration;
    const width = this.cropAppointmentWidth(durationInCells * cellWidth, cellWidth);
    return width;
  }
  _needAdjustDuration(diff) {
    return diff < 0;
  }
  getAppointmentGeometry(coordinates) {
    const result = this._customizeAppointmentGeometry(coordinates);
    return super.getAppointmentGeometry(result);
  }
  _customizeAppointmentGeometry(coordinates) {
    const config = this._calculateGeometryConfig(coordinates);
    return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset);
  }
  _getOffsets() {
    return {
      unlimited: 0,
      auto: 0
    };
  }
  _getCompactLeftCoordinate(itemLeft, index) {
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    return itemLeft + cellWidth * index;
  }
  _getMaxHeight() {
    return this.cellHeight || this.getAppointmentMinSize();
  }
  _getAppointmentCount(overlappingMode, coordinates) {
    return this._getMaxAppointmentCountPerCellByType(false);
  }
  _getAppointmentDefaultHeight() {
    return 60;
  }
  _getAppointmentMinHeight() {
    return 35;
  }
  _sortCondition(a, b) {
    return this._columnCondition(a, b);
  }
  _getOrientation() {
    return ["left", "right", "top"];
  }
  getDropDownAppointmentWidth(intervalCount, isAllDay) {
    return this.cellWidth - 4;
  }
  getDeltaTime(args, initialSize) {
    let deltaTime = 0;
    const deltaWidth = args.width - initialSize.width;
    deltaTime = toMs12("minute") * Math.round(deltaWidth / this.cellWidth * this.cellDurationInMinutes);
    return deltaTime;
  }
  isAllDay(appointmentData) {
    return ExpressionUtils.getField(this.dataAccessors, "allDay", appointmentData);
  }
  _isItemsCross(firstItem, secondItem) {
    const orientation = this._getOrientation();
    return this._checkItemsCrossing(firstItem, secondItem, orientation);
  }
  getPositionShift(timeShift) {
    const positionShift = super.getPositionShift(timeShift);
    let left = this.cellWidth * timeShift;
    if (this.rtlEnabled) {
      left *= -1;
    }
    left += positionShift.left;
    return {
      top: 0,
      left,
      cellPosition: left
    };
  }
  supportCompactDropDownAppointments() {
    return false;
  }
};
var m_strategy_horizontal_default = HorizontalRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/helpers/m_position_helper.js
var getCellSize = (DOMMetaData) => {
  const {
    dateTableCellsMeta
  } = DOMMetaData;
  const length = null === dateTableCellsMeta || void 0 === dateTableCellsMeta ? void 0 : dateTableCellsMeta.length;
  if (!length) {
    return {
      width: 0,
      height: 0
    };
  }
  const cellIndex = length > 1 ? 1 : 0;
  const cellSize = dateTableCellsMeta[cellIndex][0];
  return {
    width: cellSize.width,
    height: cellSize.height
  };
};
var getMaxAllowedHorizontalPosition = (groupIndex, viewDataProvider, rtlEnabled, DOMMetaData) => {
  const {
    dateTableCellsMeta
  } = DOMMetaData;
  const firstRow = dateTableCellsMeta[0];
  if (!firstRow) {
    return 0;
  }
  const {
    columnIndex
  } = viewDataProvider.getLastGroupCellPosition(groupIndex);
  const cellPosition = firstRow[columnIndex];
  if (!cellPosition) {
    return 0;
  }
  return !rtlEnabled ? cellPosition.left + cellPosition.width : cellPosition.left;
};
var getCellHeight = (DOMMetaData) => getCellSize(DOMMetaData).height;
var getCellWidth = (DOMMetaData) => getCellSize(DOMMetaData).width;
var getAllDayHeight = (showAllDayPanel, isVerticalGrouping, DOMMetaData) => {
  if (!showAllDayPanel) {
    return 0;
  }
  if (isVerticalGrouping) {
    const {
      dateTableCellsMeta
    } = DOMMetaData;
    const length = null === dateTableCellsMeta || void 0 === dateTableCellsMeta ? void 0 : dateTableCellsMeta.length;
    return length ? dateTableCellsMeta[0][0].height : 0;
  }
  const {
    allDayPanelCellsMeta
  } = DOMMetaData;
  return null !== allDayPanelCellsMeta && void 0 !== allDayPanelCellsMeta && allDayPanelCellsMeta.length ? allDayPanelCellsMeta[0].height : 0;
};
var getMaxAllowedPosition = (groupIndex, viewDataProvider, rtlEnabled, DOMMetaData) => {
  const validGroupIndex = groupIndex || 0;
  return getMaxAllowedHorizontalPosition(validGroupIndex, viewDataProvider, rtlEnabled, DOMMetaData);
};
var getGroupWidth = (groupIndex, viewDataProvider, options) => {
  const {
    isVirtualScrolling,
    rtlEnabled,
    DOMMetaData
  } = options;
  const cellWidth = getCellWidth(DOMMetaData);
  let result = viewDataProvider.getCellCount(options) * cellWidth;
  if (isVirtualScrolling) {
    const groupedData = viewDataProvider.groupedDataMap.dateTableGroupedMap;
    const groupLength = groupedData[groupIndex][0].length;
    result = groupLength * cellWidth;
  }
  const position = getMaxAllowedPosition(groupIndex, viewDataProvider, rtlEnabled, DOMMetaData);
  const currentPosition = position[groupIndex];
  if (currentPosition) {
    if (rtlEnabled) {
      result = currentPosition - position[groupIndex + 1];
    } else if (0 === groupIndex) {
      result = currentPosition;
    } else {
      result = currentPosition - position[groupIndex - 1];
    }
  }
  return result;
};
var PositionHelper = class {
  get viewDataProvider() {
    return this.options.viewDataProvider;
  }
  get rtlEnabled() {
    return this.options.rtlEnabled;
  }
  get isGroupedByDate() {
    return this.options.isGroupedByDate;
  }
  get groupCount() {
    return this.options.groupCount;
  }
  get DOMMetaData() {
    return this.options.getDOMMetaDataCallback();
  }
  constructor(options) {
    this.options = options;
    this.groupStrategy = this.options.isVerticalGrouping ? new GroupStrategyBase(this.options) : new GroupStrategyHorizontal(this.options);
  }
  getHorizontalMax(groupIndex) {
    const getMaxPosition = (groupIndex2) => getMaxAllowedPosition(groupIndex2, this.viewDataProvider, this.rtlEnabled, this.DOMMetaData);
    if (this.isGroupedByDate) {
      const viewPortGroupCount = this.viewDataProvider.getViewPortGroupCount();
      return Math.max(getMaxPosition(groupIndex), getMaxPosition(viewPortGroupCount - 1));
    }
    return getMaxPosition(groupIndex);
  }
  getResizableStep() {
    const cellWidth = getCellWidth(this.DOMMetaData);
    if (this.isGroupedByDate) {
      return this.groupCount * cellWidth;
    }
    return cellWidth;
  }
  getVerticalMax(options) {
    return this.groupStrategy.getVerticalMax(options);
  }
  getOffsetByAllDayPanel(options) {
    return this.groupStrategy.getOffsetByAllDayPanel(options);
  }
  getGroupTop(options) {
    return this.groupStrategy.getGroupTop(options);
  }
};
var GroupStrategyBase = class {
  constructor(options) {
    this.options = options;
  }
  get viewDataProvider() {
    return this.options.viewDataProvider;
  }
  get isGroupedByDate() {
    return this.options.isGroupedByDate;
  }
  get rtlEnabled() {
    return this.options.rtlEnabled;
  }
  get groupCount() {
    return this.options.groupCount;
  }
  get DOMMetaData() {
    return this.options.getDOMMetaDataCallback();
  }
  getOffsetByAllDayPanel(_ref) {
    let {
      groupIndex,
      supportAllDayRow,
      showAllDayPanel
    } = _ref;
    let result = 0;
    if (supportAllDayRow && showAllDayPanel) {
      const allDayPanelHeight = getAllDayHeight(showAllDayPanel, true, this.DOMMetaData);
      result = allDayPanelHeight * (groupIndex + 1);
    }
    return result;
  }
  getVerticalMax(options) {
    let maxAllowedPosition = this._getMaxAllowedVerticalPosition(_extends({}, options, {
      viewDataProvider: this.viewDataProvider,
      rtlEnabled: this.rtlEnabled,
      DOMMetaData: this.DOMMetaData
    }));
    maxAllowedPosition += this.getOffsetByAllDayPanel(options);
    return maxAllowedPosition;
  }
  getGroupTop(_ref2) {
    let {
      groupIndex,
      showAllDayPanel,
      isGroupedAllDayPanel
    } = _ref2;
    const rowCount = this.viewDataProvider.getRowCountInGroup(groupIndex);
    const maxVerticalPosition = this._getMaxAllowedVerticalPosition({
      groupIndex,
      viewDataProvider: this.viewDataProvider,
      showAllDayPanel,
      isGroupedAllDayPanel,
      isVerticalGrouping: true,
      DOMMetaData: this.DOMMetaData
    });
    return maxVerticalPosition - getCellHeight(this.DOMMetaData) * rowCount;
  }
  _getAllDayHeight(showAllDayPanel) {
    return getAllDayHeight(showAllDayPanel, true, this.DOMMetaData);
  }
  _getMaxAllowedVerticalPosition(_ref3) {
    let {
      groupIndex,
      showAllDayPanel,
      isGroupedAllDayPanel
    } = _ref3;
    const {
      rowIndex
    } = this.viewDataProvider.getLastGroupCellPosition(groupIndex);
    const {
      dateTableCellsMeta
    } = this.DOMMetaData;
    const lastGroupRow = dateTableCellsMeta[rowIndex];
    if (!lastGroupRow) {
      return 0;
    }
    let result = lastGroupRow[0].top + lastGroupRow[0].height;
    if (isGroupedAllDayPanel) {
      result -= (groupIndex + 1) * this._getAllDayHeight(showAllDayPanel);
    }
    return result;
  }
};
var GroupStrategyHorizontal = class extends GroupStrategyBase {
  getOffsetByAllDayPanel() {
    return 0;
  }
  getVerticalMax(options) {
    const {
      isVirtualScrolling,
      groupIndex
    } = options;
    const correctedGroupIndex = isVirtualScrolling ? groupIndex : 0;
    return this._getMaxAllowedVerticalPosition(_extends({}, options, {
      groupIndex: correctedGroupIndex
    }));
  }
  getGroupTop() {
    return 0;
  }
  _getAllDayHeight(showAllDayPanel) {
    return getAllDayHeight(showAllDayPanel, false, this.DOMMetaData);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_horizontal_month_line.js
var HorizontalMonthLineRenderingStrategy = class extends m_strategy_horizontal_default {
  calculateAppointmentWidth(_, position) {
    const {
      startDate: startDateWithTime,
      normalizedEndDate
    } = position.info.appointment;
    const startDate = date_default2.trimTime(startDateWithTime);
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    const duration = Math.ceil(this._getDurationInDays(startDate, normalizedEndDate));
    let width = this.cropAppointmentWidth(duration * cellWidth, cellWidth);
    if (this.isVirtualScrolling) {
      const skippedDays = this.viewDataProvider.getSkippedDaysCount(position.groupIndex, startDate, normalizedEndDate, duration);
      width -= skippedDays * cellWidth;
    }
    return width;
  }
  _columnCondition(a, b) {
    const conditions = this._getConditions(a, b);
    return conditions.rowCondition || conditions.columnCondition || conditions.cellPositionCondition;
  }
  _getDurationInDays(startDate, endDate) {
    const adjustedDuration = this._adjustDurationByDaylightDiff(endDate.getTime() - startDate.getTime(), startDate, endDate);
    return adjustedDuration / date_default2.dateToMilliseconds("day") || 1;
  }
  getDeltaTime(args, initialSize) {
    return 864e5 * this._getDeltaWidth(args, initialSize);
  }
  isAllDay() {
    return false;
  }
  createTaskPositionMap(items, skipSorting) {
    if (!skipSorting) {
      sortAppointmentsByStartDate(items, this.dataAccessors);
    }
    return super.createTaskPositionMap(items);
  }
  _getSortedPositions(map2, skipSorting) {
    let result = super._getSortedPositions(map2);
    if (!skipSorting) {
      result = query_default(result).sortBy("top").thenBy("left").thenBy("cellPosition").thenBy("i").toArray();
    }
    return result;
  }
  needCorrectAppointmentDates() {
    return false;
  }
  getPositionShift(timeShift) {
    return {
      top: 0,
      left: 0,
      cellPosition: timeShift * this.cellWidth
    };
  }
};
var m_strategy_horizontal_month_line_default = HorizontalMonthLineRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_horizontal_month.js
var toMs13 = date_default2.dateToMilliseconds;
var HorizontalMonthRenderingStrategy = class extends m_strategy_horizontal_month_line_default {
  get endViewDate() {
    return this.options.endViewDate;
  }
  get adaptivityEnabled() {
    return this.options.adaptivityEnabled;
  }
  get DOMMetaData() {
    return this.options.DOMMetaData;
  }
  _getLeftPosition(settings) {
    const fullWeekAppointmentWidth = this.getGroupWidth(settings.groupIndex);
    return this._calculateMultiWeekAppointmentLeftOffset(settings.hMax, fullWeekAppointmentWidth);
  }
  _getChunkCount(fullChunksWidth, firstChunkWidth, weekWidth, settings) {
    const {
      groupIndex,
      info: {
        appointment: {
          startDate
        }
      }
    } = settings;
    const rawFullChunksWidth = fullChunksWidth - firstChunkWidth + weekWidth;
    const allChunksCount = Math.ceil(rawFullChunksWidth / weekWidth);
    const viewRowIndex = this._tryGetRowIndexInView(startDate);
    if (void 0 !== viewRowIndex) {
      const viewChunksCount = this.viewDataProvider.getRowCountInGroup(groupIndex);
      const allowedChunksCount = viewChunksCount - viewRowIndex;
      return allChunksCount <= allowedChunksCount ? allChunksCount : allowedChunksCount;
    }
    return allChunksCount;
  }
  _tryGetRowIndexInView(positionStartDate) {
    var _this$options$dataRan;
    const columnsCount = this.viewDataProvider.getColumnsCount();
    if ((null === (_this$options$dataRan = this.options.dataRange) || void 0 === _this$options$dataRan ? void 0 : _this$options$dataRan.length) < 1 || !columnsCount) {
      return;
    }
    const [startViewDate] = this.options.dateRange;
    const dayDurationMs = toMs13("day");
    const timeFromStart = positionStartDate.getTime() - startViewDate.getTime();
    return Math.floor(timeFromStart / dayDurationMs / columnsCount);
  }
  _getChunkWidths(geometry, settings, weekWidth) {
    const firstChunkWidth = geometry.reducedWidth;
    const fullChunksWidth = Math.floor(geometry.sourceAppointmentWidth);
    const widthWithoutFirstChunk = fullChunksWidth - firstChunkWidth;
    return [firstChunkWidth, fullChunksWidth, widthWithoutFirstChunk];
  }
  _getTailChunkSettings(withoutFirstChunkWidth, weekWidth, leftPosition) {
    const tailChunkWidth = withoutFirstChunkWidth % weekWidth || weekWidth;
    const rtlPosition = leftPosition + (weekWidth - tailChunkWidth);
    const tailChunkLeftPosition = this.rtlEnabled ? rtlPosition : leftPosition;
    return [tailChunkWidth, tailChunkLeftPosition];
  }
  _getAppointmentParts(geometry, settings) {
    const result = [];
    const weekWidth = Math.round(this.getGroupWidth(settings.groupIndex));
    const [firstChunkWidth, fullChunksWidth, withoutFirstChunkWidth] = this._getChunkWidths(geometry, settings, weekWidth);
    const leftPosition = this._getLeftPosition(settings);
    const {
      endDate
    } = settings.info.appointment;
    const hasTailChunk = this.endViewDate > endDate;
    const chunkCount = this._getChunkCount(fullChunksWidth, firstChunkWidth, weekWidth, settings);
    const [tailChunkWidth, tailChunkLeftPosition] = this._getTailChunkSettings(withoutFirstChunkWidth, weekWidth, leftPosition);
    for (let chunkIndex = 1; chunkIndex < chunkCount; chunkIndex++) {
      const topPosition = settings.top + this.cellHeight * chunkIndex;
      const isTailChunk = hasTailChunk && chunkIndex === chunkCount - 1;
      result.push(_extends({}, settings, {
        top: topPosition,
        left: isTailChunk ? tailChunkLeftPosition : leftPosition,
        height: geometry.height,
        width: isTailChunk ? tailChunkWidth : weekWidth,
        appointmentReduced: isTailChunk ? "tail" : "body",
        rowIndex: ++settings.rowIndex,
        columnIndex: 0
      }));
    }
    return result;
  }
  _calculateMultiWeekAppointmentLeftOffset(max, width) {
    return this.rtlEnabled ? max : max - width;
  }
  getGroupWidth(groupIndex) {
    return getGroupWidth(groupIndex, this.viewDataProvider, {
      intervalCount: this.options.intervalCount,
      currentDate: this.options.currentDate,
      viewType: this.options.viewType,
      hoursInterval: this.options.hoursInterval,
      startDayHour: this.options.startDayHour,
      endDayHour: this.options.endDayHour,
      isVirtualScrolling: this.isVirtualScrolling,
      rtlEnabled: this.rtlEnabled,
      DOMMetaData: this.DOMMetaData
    });
  }
  _getAppointmentDefaultHeight() {
    return this._getAppointmentHeightByTheme();
  }
  _getAppointmentMinHeight() {
    return this._getAppointmentDefaultHeight();
  }
  createTaskPositionMap(items) {
    return super.createTaskPositionMap(items, true);
  }
  _getSortedPositions(map2) {
    return super._getSortedPositions(map2, true);
  }
  _getDefaultRatio() {
    return 0.6;
  }
  _getOffsets() {
    return {
      unlimited: 26,
      auto: 30
    };
  }
  getDropDownAppointmentWidth(intervalCount, isAllDay) {
    if (this.adaptivityEnabled) {
      return this.getDropDownButtonAdaptiveSize();
    }
    const offset = intervalCount > 1 ? 60 : 36;
    return this.cellWidth - offset;
  }
  needCorrectAppointmentDates() {
    return false;
  }
  _needVerticalGroupBounds() {
    return false;
  }
  _needHorizontalGroupBounds() {
    return true;
  }
};
var m_strategy_horizontal_month_default = HorizontalMonthRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_vertical.js
var toMs14 = date_default2.dateToMilliseconds;
var VerticalRenderingStrategy = class extends m_strategy_base_default {
  getDeltaTime(args, initialSize, appointment) {
    let deltaTime = 0;
    if (this.isAllDay(appointment)) {
      deltaTime = this._getDeltaWidth(args, initialSize) * toMs14("day");
    } else {
      const deltaHeight = args.height - initialSize.height;
      deltaTime = toMs14("minute") * Math.round(deltaHeight / this.cellHeight * this.cellDurationInMinutes);
    }
    return deltaTime;
  }
  _correctCollectorCoordinatesInAdaptive(coordinates, isAllDay) {
    if (isAllDay) {
      super._correctCollectorCoordinatesInAdaptive(coordinates, isAllDay);
    } else if (0 === this._getMaxAppointmentCountPerCellByType()) {
      const {
        cellHeight
      } = this;
      const {
        cellWidth
      } = this;
      coordinates.top += (cellHeight - this.getDropDownButtonAdaptiveSize()) / 2;
      coordinates.left += (cellWidth - this.getDropDownButtonAdaptiveSize()) / 2;
    }
  }
  getAppointmentGeometry(coordinates) {
    let geometry = null;
    if (coordinates.allDay) {
      geometry = this._getAllDayAppointmentGeometry(coordinates);
    } else {
      geometry = this.isAdaptive && coordinates.isCompact ? this._getAdaptiveGeometry(coordinates) : this._getVerticalAppointmentGeometry(coordinates);
    }
    return super.getAppointmentGeometry(geometry);
  }
  _getAdaptiveGeometry(coordinates) {
    const config = this._calculateGeometryConfig(coordinates);
    return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset);
  }
  _getItemPosition(initialAppointment) {
    const allDay = this.isAllDay(initialAppointment);
    if (allDay) {
      return super._getItemPosition(initialAppointment);
    }
    const appointment = super.shiftAppointmentByViewOffset(initialAppointment);
    const adapter = createAppointmentAdapter(appointment, this.dataAccessors, this.timeZoneCalculator);
    const isRecurring = !!adapter.recurrenceRule;
    const appointmentStartDate = adapter.calculateStartDate("toGrid");
    const appointmentEndDate = adapter.calculateEndDate("toGrid");
    const appointmentDuration = appointmentEndDate - appointmentStartDate;
    const appointmentBeginInCurrentView = this.options.startViewDate < appointmentStartDate;
    const isAppointmentTakesSeveralDays = !m_utils_time_zone_default.isSameAppointmentDates(appointmentStartDate, appointmentEndDate);
    const settings = this.generateAppointmentSettings(appointment);
    let result = [];
    for (let j = 0; j < settings.length; j++) {
      const currentSetting = settings[j];
      const height = this.calculateAppointmentHeight(appointment, currentSetting);
      const width = this.calculateAppointmentWidth(appointment, currentSetting);
      let resultHeight = height;
      let appointmentReduced = null;
      let multiDaysAppointmentParts = [];
      const currentMaxAllowedPosition = currentSetting.vMax;
      if (this._isMultiViewAppointment(currentSetting, height) || isAppointmentTakesSeveralDays && !isRecurring) {
        const trimmedStartDate = date_default2.trimTime(appointmentStartDate);
        const trimmedSettingStartDate = date_default2.trimTime(currentSetting.info.appointment.startDate);
        const reduceHead = trimmedStartDate <= trimmedSettingStartDate || isRecurring;
        if (reduceHead) {
          resultHeight = this._reduceMultiDayAppointment(height, {
            top: currentSetting.top,
            bottom: currentMaxAllowedPosition
          });
          multiDaysAppointmentParts = this._getAppointmentParts({
            sourceAppointmentHeight: height,
            reducedHeight: resultHeight,
            width
          }, currentSetting);
        }
        const {
          startDate: currentSettingStartDate,
          normalizedEndDate: currentSettingNormalizedEndDate
        } = currentSetting.info.appointment;
        const currentSettingDuration = currentSettingNormalizedEndDate - currentSettingStartDate;
        const hasNextParts = currentSettingDuration < appointmentDuration;
        appointmentReduced = hasNextParts ? appointmentBeginInCurrentView ? "head" : "body" : appointmentBeginInCurrentView ? "head" : "tail";
      }
      extend(currentSetting, {
        height: resultHeight,
        width,
        allDay,
        appointmentReduced
      });
      result = this._getAppointmentPartsPosition(multiDaysAppointmentParts, currentSetting, result);
    }
    return result;
  }
  _isMultiViewAppointment(_ref, height) {
    let {
      vMax,
      top
    } = _ref;
    const fullAppointmentHeight = roundFloatPart(height, 2);
    const remainingHeight = roundFloatPart(vMax - top, 2);
    return fullAppointmentHeight > remainingHeight;
  }
  _reduceMultiDayAppointment(sourceAppointmentHeight, bound) {
    return Math.min(sourceAppointmentHeight, bound.bottom - Math.floor(bound.top));
  }
  _getGroupHeight() {
    return this.cellHeight * this.rowCount;
  }
  _getGroupTopOffset(appointmentSettings) {
    const {
      groupIndex
    } = appointmentSettings;
    const groupTop = Math.max(0, this.positionHelper.getGroupTop({
      groupIndex,
      showAllDayPanel: this.showAllDayPanel,
      isGroupedAllDayPanel: this.isGroupedAllDayPanel
    }));
    const allDayPanelOffset = this.positionHelper.getOffsetByAllDayPanel({
      groupIndex,
      supportAllDayRow: this.allDaySupported(),
      showAllDayPanel: this.showAllDayPanel
    });
    const appointmentGroupTopOffset = appointmentSettings.top - groupTop - allDayPanelOffset;
    return appointmentGroupTopOffset;
  }
  _getTailHeight(appointmentGeometry, appointmentSettings) {
    if (!this.isVirtualScrolling) {
      return appointmentGeometry.sourceAppointmentHeight - appointmentGeometry.reducedHeight;
    }
    const appointmentGroupTopOffset = this._getGroupTopOffset(appointmentSettings);
    const {
      sourceAppointmentHeight
    } = appointmentGeometry;
    const groupHeight = this._getGroupHeight();
    const tailHeight = appointmentGroupTopOffset + sourceAppointmentHeight - groupHeight;
    return tailHeight;
  }
  _getAppointmentParts(appointmentGeometry, appointmentSettings) {
    const {
      width
    } = appointmentGeometry;
    const result = [];
    let currentPartTop = Math.max(0, this.positionHelper.getGroupTop({
      groupIndex: appointmentSettings.groupIndex,
      showAllDayPanel: this.showAllDayPanel,
      isGroupedAllDayPanel: this.isGroupedAllDayPanel
    }));
    const cellsDiff = this.isGroupedByDate ? this.groupCount : 1;
    const offset = this.cellWidth * cellsDiff;
    const allDayPanelOffset = this.positionHelper.getOffsetByAllDayPanel({
      groupIndex: appointmentSettings.groupIndex,
      supportAllDayRow: this.allDaySupported(),
      showAllDayPanel: this.showAllDayPanel
    });
    currentPartTop += allDayPanelOffset;
    const minHeight = this.getAppointmentMinSize();
    const {
      hMax,
      vMax,
      vMin
    } = appointmentSettings;
    const maxHeight = this.isVirtualScrolling ? vMax : vMax - vMin;
    const hasTailPart = this.options.endViewDate > appointmentSettings.info.appointment.endDate;
    let left = Math.round(appointmentSettings.left + offset);
    let tailHeight = this._getTailHeight(appointmentGeometry, appointmentSettings);
    let {
      columnIndex
    } = appointmentSettings;
    while (tailHeight > 0 && left < hMax) {
      tailHeight = Math.max(minHeight, tailHeight);
      columnIndex += cellsDiff;
      const height = Math.min(tailHeight, maxHeight);
      result.push(_extends({}, appointmentSettings, {
        top: currentPartTop,
        left,
        height,
        width,
        appointmentReduced: "body",
        rowIndex: 0,
        columnIndex
      }));
      left += offset;
      tailHeight -= maxHeight;
    }
    if (hasTailPart && result.length > 0) {
      result[result.length - 1].appointmentReduced = "tail";
    }
    return result;
  }
  _getMinuteHeight() {
    return this.cellHeight / this.cellDurationInMinutes;
  }
  _getCompactLeftCoordinate(itemLeft, index) {
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    return itemLeft + (1 + cellWidth) * index;
  }
  _getVerticalAppointmentGeometry(coordinates) {
    const config = this._calculateVerticalGeometryConfig(coordinates);
    return this._customizeVerticalCoordinates(coordinates, config.width, config.appointmentCountPerCell, config.offset);
  }
  _customizeVerticalCoordinates(coordinates, width, appointmentCountPerCell, topOffset, isAllDay) {
    const appointmentWidth = Math.max(width / appointmentCountPerCell, width / coordinates.count);
    const {
      height
    } = coordinates;
    const appointmentLeft = coordinates.left + coordinates.index * appointmentWidth;
    const {
      top
    } = coordinates;
    if (coordinates.isCompact) {
      this._markAppointmentAsVirtual(coordinates, isAllDay);
    }
    return {
      height,
      width: appointmentWidth,
      top,
      left: appointmentLeft,
      empty: this._isAppointmentEmpty(height, width)
    };
  }
  _calculateVerticalGeometryConfig(coordinates) {
    const overlappingMode = this.maxAppointmentsPerCell;
    const offsets = this._getOffsets();
    const appointmentDefaultOffset = this._getAppointmentDefaultOffset();
    let appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);
    let ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);
    let maxWidth = this._getMaxWidth();
    if (!appointmentCountPerCell) {
      appointmentCountPerCell = coordinates.count;
      ratio = (maxWidth - offsets.unlimited) / maxWidth;
    }
    let topOffset = (1 - ratio) * maxWidth;
    if ("auto" === overlappingMode || isNumeric(overlappingMode)) {
      ratio = 1;
      maxWidth -= appointmentDefaultOffset;
      topOffset = 0;
    }
    return {
      width: ratio * maxWidth,
      appointmentCountPerCell,
      offset: topOffset
    };
  }
  _getMaxWidth() {
    return this.cellWidth;
  }
  isAllDay(appointmentData) {
    return getAppointmentTakesAllDay(createAppointmentAdapter(appointmentData, this.dataAccessors, this.timeZoneCalculator), this.allDayPanelMode);
  }
  _getAppointmentMaxWidth() {
    return this.cellWidth - this._getAppointmentDefaultOffset();
  }
  calculateAppointmentWidth(appointment, position) {
    if (!this.isAllDay(appointment)) {
      return 0;
    }
    const {
      startDate: startDateWithTime,
      endDate,
      normalizedEndDate
    } = position.info.appointment;
    const startDate = date_default2.trimTime(startDateWithTime);
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    const durationInHours = (normalizedEndDate.getTime() - startDate.getTime()) / toMs14("hour");
    const skippedHours = getSkippedHoursInRange(startDate, endDate, appointment.allDay, this.viewDataProvider);
    let width = Math.ceil((durationInHours - skippedHours) / 24) * cellWidth;
    width = this.cropAppointmentWidth(width, cellWidth);
    return width;
  }
  calculateAppointmentHeight(appointment, position) {
    if (this.isAllDay(appointment)) {
      return 0;
    }
    const {
      startDate,
      normalizedEndDate
    } = position.info.appointment;
    const allDay = ExpressionUtils.getField(this.dataAccessors, "allDay", appointment);
    const duration = this.getAppointmentDurationInMs(startDate, normalizedEndDate, allDay);
    const skippedMinutes = 60 * getSkippedHoursInRange(startDate, normalizedEndDate, appointment.allDay, this.viewDataProvider);
    const durationInMinutes = this._adjustDurationByDaylightDiff(duration, startDate, normalizedEndDate) / toMs14("minute") - skippedMinutes;
    const height = durationInMinutes * this._getMinuteHeight();
    return height;
  }
  getDirection() {
    return "vertical";
  }
  _sortCondition(a, b) {
    if (!!a.allDay !== !!b.allDay) {
      return a.allDay ? 1 : -1;
    }
    const isAllDay = a.allDay && b.allDay;
    return "vertical" === this.groupOrientation && isAllDay ? this._columnCondition(a, b) : this._rowCondition(a, b);
  }
  allDaySupported() {
    return true;
  }
  _getAllDayAppointmentGeometry(coordinates) {
    const config = this._calculateGeometryConfig(coordinates);
    return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset, true);
  }
  _calculateGeometryConfig(coordinates) {
    if (!this.allowResizing || !this.allowAllDayResizing) {
      coordinates.skipResizing = true;
    }
    const config = super._calculateGeometryConfig(coordinates);
    const minAppointmentCountPerCell = Math.min(config.appointmentCountPerCell, this._getDynamicAppointmentCountPerCell().allDay);
    if (coordinates.allDay && coordinates.count <= minAppointmentCountPerCell) {
      config.offset = 0;
    }
    return config;
  }
  _getAppointmentCount(overlappingMode, coordinates) {
    return "auto" !== overlappingMode && 1 === coordinates.count && !isNumeric(overlappingMode) ? coordinates.count : this._getMaxAppointmentCountPerCellByType(coordinates.allDay);
  }
  _getDefaultRatio(coordinates, appointmentCountPerCell) {
    return coordinates.count > this.appointmentCountPerCell ? 0.65 : 1;
  }
  _getOffsets() {
    return {
      unlimited: 5,
      auto: 20
    };
  }
  _getMaxHeight() {
    return this.allDayHeight || this.getAppointmentMinSize();
  }
  _needVerticalGroupBounds(allDay) {
    return !allDay;
  }
  _needHorizontalGroupBounds() {
    return false;
  }
  getPositionShift(timeShift, isAllDay) {
    if (!isAllDay && this.isAdaptive && 0 === this._getMaxAppointmentCountPerCellByType(isAllDay)) {
      return {
        top: 0,
        left: 0,
        cellPosition: 0
      };
    }
    return super.getPositionShift(timeShift, isAllDay);
  }
};
var m_strategy_vertical_default = VerticalRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_week.js
var WeekAppointmentRenderingStrategy = class extends m_strategy_vertical_default {
  isApplyCompactAppointmentOffset() {
    if (this.isAdaptive && 0 === this._getMaxAppointmentCountPerCellByType()) {
      return false;
    }
    return this.supportCompactDropDownAppointments();
  }
};
var m_strategy_week_default = WeekAppointmentRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_view_model_generator.js
var RENDERING_STRATEGIES = {
  horizontal: m_strategy_horizontal_default,
  horizontalMonth: m_strategy_horizontal_month_default,
  horizontalMonthLine: m_strategy_horizontal_month_line_default,
  vertical: m_strategy_vertical_default,
  week: m_strategy_week_default,
  agenda: m_strategy_agenda_default
};
var AppointmentViewModelGenerator = class {
  initRenderingStrategy(options) {
    const RenderingStrategy = RENDERING_STRATEGIES[options.appointmentRenderingStrategyName];
    this.renderingStrategy = new RenderingStrategy(options);
  }
  generate(filteredItems, options) {
    const {
      viewOffset
    } = options;
    const appointments = filteredItems ? filteredItems.slice() : [];
    this.initRenderingStrategy(options);
    const renderingStrategy = this.getRenderingStrategy();
    const positionMap = renderingStrategy.createTaskPositionMap(appointments);
    const shiftedViewModel = this.postProcess(appointments, positionMap);
    const viewModel = this.unshiftViewModelAppointmentsByViewOffset(shiftedViewModel, viewOffset);
    return {
      positionMap,
      viewModel
    };
  }
  postProcess(filteredItems, positionMap) {
    const renderingStrategy = this.getRenderingStrategy();
    return filteredItems.map((data2, index) => {
      if (!renderingStrategy.keepAppointmentSettings()) {
        delete data2.settings;
      }
      const appointmentSettings = positionMap[index];
      appointmentSettings.forEach((item2) => {
        item2.direction = "vertical" === renderingStrategy.getDirection() && !item2.allDay ? "vertical" : "horizontal";
      });
      const item = {
        itemData: data2,
        settings: appointmentSettings
      };
      item.needRepaint = true;
      item.needRemove = false;
      return item;
    });
  }
  makeRenovatedViewModels(viewModel, supportAllDayRow, isVerticalGrouping) {
    const strategy = this.getRenderingStrategy();
    const regularViewModels = [];
    const allDayViewModels = [];
    const compactOptions = [];
    const isAllDayPanel = supportAllDayRow && !isVerticalGrouping;
    viewModel.forEach((_ref) => {
      let {
        itemData,
        settings
      } = _ref;
      settings.forEach((options) => {
        const item = this.prepareViewModel(options, strategy, itemData);
        if (options.isCompact) {
          compactOptions.push({
            compactViewModel: options.virtual,
            appointmentViewModel: item
          });
        } else if (options.allDay && isAllDayPanel) {
          allDayViewModels.push(item);
        } else {
          regularViewModels.push(item);
        }
      });
    });
    const compactViewModels = this.prepareCompactViewModels(compactOptions, supportAllDayRow);
    const result = _extends({
      allDay: allDayViewModels,
      regular: regularViewModels
    }, compactViewModels);
    return result;
  }
  prepareViewModel(options, strategy, itemData) {
    const geometry = strategy.getAppointmentGeometry(options);
    const viewModel = {
      key: getAppointmentKey(geometry),
      appointment: itemData,
      geometry: _extends({}, geometry, {
        leftVirtualWidth: options.leftVirtualWidth,
        topVirtualHeight: options.topVirtualHeight
      }),
      info: _extends({}, options.info, {
        allDay: options.allDay,
        direction: options.direction,
        appointmentReduced: options.appointmentReduced,
        groupIndex: options.groupIndex
      })
    };
    return viewModel;
  }
  getCompactViewModelFrame(compactViewModel) {
    return {
      isAllDay: !!compactViewModel.isAllDay,
      isCompact: compactViewModel.isCompact,
      groupIndex: compactViewModel.groupIndex,
      geometry: {
        left: compactViewModel.left,
        top: compactViewModel.top,
        width: compactViewModel.width,
        height: compactViewModel.height
      },
      items: {
        colors: [],
        data: [],
        settings: []
      }
    };
  }
  prepareCompactViewModels(compactOptions, supportAllDayRow) {
    const regularCompact = {};
    const allDayCompact = {};
    compactOptions.forEach((_ref2) => {
      let {
        compactViewModel,
        appointmentViewModel
      } = _ref2;
      const {
        index,
        isAllDay
      } = compactViewModel;
      const viewModel = isAllDay && supportAllDayRow ? allDayCompact : regularCompact;
      if (!viewModel[index]) {
        viewModel[index] = this.getCompactViewModelFrame(compactViewModel);
      }
      const {
        settings,
        data: data2,
        colors
      } = viewModel[index].items;
      settings.push(appointmentViewModel);
      data2.push(appointmentViewModel.appointment);
      colors.push(appointmentViewModel.info.resourceColor);
    });
    const toArray2 = (items) => Object.keys(items).map((key) => _extends({
      key
    }, items[key]));
    const allDayViewModels = toArray2(allDayCompact);
    const regularViewModels = toArray2(regularCompact);
    return {
      allDayCompact: allDayViewModels,
      regularCompact: regularViewModels
    };
  }
  getRenderingStrategy() {
    return this.renderingStrategy;
  }
  unshiftViewModelAppointmentsByViewOffset(viewModel, viewOffset) {
    const processedAppointments = /* @__PURE__ */ new Set();
    for (const model of viewModel) {
      for (const setting of model.settings ?? []) {
        var _setting$info;
        const appointment = null === setting || void 0 === setting || null === (_setting$info = setting.info) || void 0 === _setting$info ? void 0 : _setting$info.appointment;
        if (appointment && !processedAppointments.has(appointment)) {
          appointment.startDate = dateUtilsTs.addOffsets(appointment.startDate, [viewOffset]);
          appointment.endDate = dateUtilsTs.addOffsets(appointment.endDate, [viewOffset]);
          appointment.normalizedEndDate = dateUtilsTs.addOffsets(appointment.normalizedEndDate, [viewOffset]);
          processedAppointments.add(appointment);
        }
      }
    }
    return viewModel;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_appointments_layout_manager.js
var toMs15 = date_default2.dateToMilliseconds;
var AppointmentLayoutManager = class {
  constructor(instance) {
    this.instance = instance;
    this.appointmentViewModel = new AppointmentViewModelGenerator();
  }
  get appointmentRenderingStrategyName() {
    return getAppointmentRenderingStrategyName(this.instance.currentViewType);
  }
  getCellDimensions(options) {
    if (this.instance._workSpace) {
      return {
        width: this.instance._workSpace.getCellWidth(),
        height: this.instance._workSpace.getCellHeight(),
        allDayHeight: this.instance._workSpace.getAllDayHeight()
      };
    }
    return;
  }
  _getRenderingStrategyOptions() {
    const workspace = this.instance.getWorkSpace();
    const {
      virtualScrollingDispatcher
    } = this.instance.getWorkSpace();
    const {
      cellCountInsideLeftVirtualCell,
      cellCountInsideTopVirtualRow
    } = virtualScrollingDispatcher;
    const groupCount = getGroupCount(this.instance.option("loadedResources"));
    const DOMMetaData = workspace.getDOMElementsMetaData();
    const allDayHeight = getAllDayHeight(workspace.option("showAllDayPanel"), workspace._isVerticalGroupedWorkSpace(), DOMMetaData);
    const rowCount = workspace._getRowCount();
    const {
      positionHelper,
      viewDataProvider
    } = workspace;
    const visibleDayDuration = viewDataProvider.getVisibleDayDuration(workspace.option("startDayHour"), workspace.option("endDayHour"), workspace.option("hoursInterval"));
    const cellDuration = getCellDuration(workspace.type, workspace.option("startDayHour"), workspace.option("endDayHour"), workspace.option("hoursInterval"));
    return {
      resources: this.instance.option("resources"),
      loadedResources: this.instance.option("loadedResources"),
      getAppointmentColor: this.instance.createGetAppointmentColor(),
      dataAccessors: this.instance._dataAccessors,
      appointmentRenderingStrategyName: this.appointmentRenderingStrategyName,
      adaptivityEnabled: this.instance.option("adaptivityEnabled"),
      rtlEnabled: this.instance.option("rtlEnabled"),
      startDayHour: this.instance._getCurrentViewOption("startDayHour"),
      endDayHour: this.instance._getCurrentViewOption("endDayHour"),
      viewOffset: this.instance._getCurrentViewOption("offset") * toMs15("minute"),
      maxAppointmentsPerCell: this.instance._getCurrentViewOption("maxAppointmentsPerCell"),
      currentDate: this.instance.option("currentDate"),
      isVirtualScrolling: this.instance.isVirtualScrolling(),
      leftVirtualCellCount: cellCountInsideLeftVirtualCell,
      topVirtualCellCount: cellCountInsideTopVirtualRow,
      intervalCount: workspace.option("intervalCount"),
      hoursInterval: workspace.option("hoursInterval"),
      showAllDayPanel: workspace.option("showAllDayPanel"),
      isGroupedAllDayPanel: workspace.isGroupedAllDayPanel(),
      groups: this.instance._getCurrentViewOption("groups"),
      groupCount,
      rowCount,
      appointmentCountPerCell: this.instance.option("_appointmentCountPerCell"),
      appointmentOffset: this.instance.option("_appointmentOffset"),
      allowResizing: this.instance._allowResizing(),
      allowAllDayResizing: this.instance._allowAllDayResizing(),
      startViewDate: workspace.getStartViewDate(),
      groupOrientation: workspace._getRealGroupOrientation(),
      cellWidth: getCellWidth(DOMMetaData),
      cellHeight: getCellHeight(DOMMetaData),
      allDayHeight,
      resizableStep: positionHelper.getResizableStep(),
      visibleDayDuration,
      allDayPanelMode: this.instance._getCurrentViewOption("allDayPanelMode"),
      timeZoneCalculator: this.instance.timeZoneCalculator,
      timeZone: this.instance.option("timeZone"),
      firstDayOfWeek: this.instance.getFirstDayOfWeek(),
      viewStartDayHour: this.instance._getCurrentViewOption("startDayHour"),
      viewEndDayHour: this.instance._getCurrentViewOption("endDayHour"),
      viewType: workspace.type,
      endViewDate: workspace.getEndViewDate(),
      positionHelper,
      isGroupedByDate: workspace.isGroupedByDate(),
      cellDuration,
      cellDurationInMinutes: workspace.option("cellDuration"),
      viewDataProvider: workspace.viewDataProvider,
      supportAllDayRow: workspace.supportAllDayRow(),
      dateRange: workspace.getDateRange(),
      intervalDuration: workspace.getIntervalDuration(),
      allDayIntervalDuration: workspace.getIntervalDuration(true),
      isVerticalGroupOrientation: workspace.isVerticalOrientation(),
      DOMMetaData,
      instance: this.instance,
      agendaDuration: workspace.option("agendaDuration")
    };
  }
  createAppointmentsMap(items) {
    const renderingStrategyOptions = this._getRenderingStrategyOptions();
    const {
      viewModel,
      positionMap
    } = this.appointmentViewModel.generate(items, renderingStrategyOptions);
    this._positionMap = positionMap;
    return viewModel;
  }
  _isDataChanged(data2) {
    const {
      appointmentDataProvider
    } = this.instance;
    const updatedData = appointmentDataProvider.getUpdatedAppointment();
    return updatedData === data2 || appointmentDataProvider.getUpdatedAppointmentKeys().some((item) => data2[item.key] === item.value);
  }
  _isAppointmentShouldAppear(currentAppointment, sourceAppointment) {
    return currentAppointment.needRepaint && sourceAppointment.needRemove;
  }
  _isSettingChanged(settings, sourceSetting) {
    if (settings.length !== sourceSetting.length) {
      return true;
    }
    const createSettingsToCompare = (settings2, index) => {
      const currentSetting = settings2[index];
      const leftVirtualCellCount = currentSetting.leftVirtualCellCount || 0;
      const topVirtualCellCount = currentSetting.topVirtualCellCount || 0;
      const columnIndex = currentSetting.columnIndex + leftVirtualCellCount;
      const rowIndex = currentSetting.rowIndex + topVirtualCellCount;
      const hMax = currentSetting.reduced ? currentSetting.hMax : void 0;
      const vMax = currentSetting.reduced ? currentSetting.vMax : void 0;
      return _extends({}, currentSetting, {
        columnIndex,
        rowIndex,
        positionByMap: void 0,
        topVirtualCellCount: void 0,
        leftVirtualCellCount: void 0,
        leftVirtualWidth: void 0,
        topVirtualHeight: void 0,
        hMax,
        vMax,
        info: {}
      });
    };
    for (let i = 0; i < settings.length; i++) {
      const newSettings = createSettingsToCompare(settings, i);
      const oldSettings = createSettingsToCompare(sourceSetting, i);
      if (oldSettings) {
        oldSettings.sortedIndex = newSettings.sortedIndex;
      }
      if (!equalByValue(newSettings, oldSettings)) {
        return true;
      }
    }
    return false;
  }
  _getAssociatedSourceAppointment(currentAppointment, sourceAppointments) {
    for (let i = 0; i < sourceAppointments.length; i++) {
      const item = sourceAppointments[i];
      if (item.itemData === currentAppointment.itemData) {
        return item;
      }
    }
    return null;
  }
  _getDeletedAppointments(currentAppointments, sourceAppointments) {
    const result = [];
    for (let i = 0; i < sourceAppointments.length; i++) {
      const sourceAppointment = sourceAppointments[i];
      const currentAppointment = this._getAssociatedSourceAppointment(sourceAppointment, currentAppointments);
      if (!currentAppointment) {
        sourceAppointment.needRemove = true;
        result.push(sourceAppointment);
      }
    }
    return result;
  }
  getRepaintedAppointments(currentAppointments, sourceAppointments) {
    if (0 === sourceAppointments.length || "agenda" === this.appointmentRenderingStrategyName) {
      return currentAppointments;
    }
    currentAppointments.forEach((appointment) => {
      const sourceAppointment = this._getAssociatedSourceAppointment(appointment, sourceAppointments);
      if (sourceAppointment) {
        const isDataChanged = this._isDataChanged(appointment.itemData);
        const isSettingChanged = this._isSettingChanged(appointment.settings, sourceAppointment.settings);
        const isAppointmentShouldAppear = this._isAppointmentShouldAppear(appointment, sourceAppointment);
        appointment.needRepaint = isDataChanged || isSettingChanged || isAppointmentShouldAppear;
      }
    });
    return currentAppointments.concat(this._getDeletedAppointments(currentAppointments, sourceAppointments));
  }
  getRenderingStrategyInstance() {
    const renderingStrategy = this.appointmentViewModel.getRenderingStrategy();
    if (!renderingStrategy) {
      const options = this._getRenderingStrategyOptions();
      this.appointmentViewModel.initRenderingStrategy(options);
    }
    return this.appointmentViewModel.getRenderingStrategy();
  }
};
var m_appointments_layout_manager_default = AppointmentLayoutManager;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_data_structures.js
var AppointmentTooltipInfo = class {
  constructor(appointment) {
    let targetedAppointment = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
    let color = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
    let settings = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [];
    this.appointment = appointment;
    this.targetedAppointment = targetedAppointment;
    this.color = color;
    this.settings = settings;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_compact_appointments_helper.js
var APPOINTMENT_COLLECTOR_CLASS = "dx-scheduler-appointment-collector";
var COMPACT_APPOINTMENT_COLLECTOR_CLASS = `${APPOINTMENT_COLLECTOR_CLASS}-compact`;
var APPOINTMENT_COLLECTOR_CONTENT_CLASS = `${APPOINTMENT_COLLECTOR_CLASS}-content`;
var CompactAppointmentsHelper = class {
  constructor(instance) {
    this.instance = instance;
    this.elements = [];
  }
  render(options) {
    const {
      isCompact: isCompact2,
      items,
      buttonColor
    } = options;
    const template = this._createTemplate(items.data.length, isCompact2);
    const button = this._createCompactButton(template, options);
    const $button = button.$element();
    this._makeBackgroundColor($button, items.colors, buttonColor);
    this._makeBackgroundDarker($button);
    this.elements.push($button);
    $button.data("items", this._createTooltipInfos(items));
    return $button;
  }
  clear() {
    this.elements.forEach((button) => {
      button.detach();
      button.remove();
    });
    this.elements = [];
  }
  _createTooltipInfos(items) {
    return items.data.map((appointment, index) => {
      var _items$settings;
      const targetedAdapter = createAppointmentAdapter(appointment, this.instance._dataAccessors, this.instance.timeZoneCalculator).clone();
      if ((null === (_items$settings = items.settings) || void 0 === _items$settings ? void 0 : _items$settings.length) > 0) {
        const {
          info
        } = items.settings[index];
        targetedAdapter.startDate = info.sourceAppointment.startDate;
        targetedAdapter.endDate = info.sourceAppointment.endDate;
      }
      return new AppointmentTooltipInfo(appointment, targetedAdapter.source(), items.colors[index], items.settings[index]);
    });
  }
  _onButtonClick(e, options) {
    const $button = renderer_default(e.element);
    this.instance.showAppointmentTooltipCore($button, $button.data("items"), this._getExtraOptionsForTooltip(options, $button));
  }
  _getExtraOptionsForTooltip(options, $appointmentCollector) {
    return {
      clickEvent: this._clickEvent(options.onAppointmentClick).bind(this),
      dragBehavior: options.allowDrag && this._createTooltipDragBehavior($appointmentCollector).bind(this),
      dropDownAppointmentTemplate: this.instance.option().dropDownAppointmentTemplate,
      isButtonClick: true
    };
  }
  _clickEvent(onAppointmentClick) {
    return (e) => {
      const clickEventArgs = this.instance._createEventArgs(e);
      onAppointmentClick(clickEventArgs);
    };
  }
  _createTooltipDragBehavior($appointmentCollector) {
    return (e) => {
      const $element = renderer_default(e.element);
      const $schedulerElement = renderer_default(this.instance.element());
      const workSpace = this.instance.getWorkSpace();
      const initialPosition = locate($appointmentCollector);
      const options = {
        filter: `.${LIST_ITEM_CLASS}`,
        isSetCursorOffset: true,
        initialPosition,
        getItemData: (itemElement) => {
          var _$$data;
          return null === (_$$data = renderer_default(itemElement).data(LIST_ITEM_DATA_KEY)) || void 0 === _$$data ? void 0 : _$$data.appointment;
        },
        getItemSettings: (_, event) => event.itemSettings
      };
      workSpace._createDragBehaviorBase($element, $schedulerElement, options);
    };
  }
  _getCollectorOffset(width, cellWidth) {
    return cellWidth - width - this._getCollectorRightOffset();
  }
  _getCollectorRightOffset() {
    return this.instance.getRenderingStrategyInstance()._isCompactTheme() ? 1 : 5;
  }
  _makeBackgroundDarker(button) {
    button.css("boxShadow", `inset ${getBoundingRect(button.get(0)).width}px 0 0 0 rgba(0, 0, 0, 0.3)`);
  }
  _makeBackgroundColor($button, colors, color) {
    when.apply(null, colors).done((function() {
      this._makeBackgroundColorCore($button, color, [...arguments]);
    }).bind(this));
  }
  _makeBackgroundColorCore($button, color, itemColors) {
    color && color.done((color2) => {
      const backgroundColor = getOverflowIndicatorColor(color2, itemColors);
      if (backgroundColor) {
        $button.css("backgroundColor", backgroundColor);
      }
    });
  }
  _setPosition(element, position) {
    move(element, {
      top: position.top,
      left: position.left
    });
  }
  _createCompactButton(template, options) {
    const $button = this._createCompactButtonElement(options);
    return this.instance._createComponent($button, button_default, {
      type: "default",
      width: options.width,
      height: options.height,
      onClick: (e) => this._onButtonClick(e, options),
      template: this._renderTemplate(template, options.items, options.isCompact)
    });
  }
  _createCompactButtonElement(_ref) {
    let {
      isCompact: isCompact2,
      $container,
      coordinates
    } = _ref;
    const result = renderer_default("<div>").addClass(APPOINTMENT_COLLECTOR_CLASS).toggleClass(COMPACT_APPOINTMENT_COLLECTOR_CLASS, isCompact2).appendTo($container);
    this._setPosition(result, coordinates);
    return result;
  }
  _renderTemplate(template, items, isCompact2) {
    return new FunctionTemplate((options) => template.render({
      model: {
        appointmentCount: items.data.length,
        isCompact: isCompact2
      },
      container: options.container
    }));
  }
  _createTemplate(count, isCompact2) {
    this._initButtonTemplate(count, isCompact2);
    return this.instance._getAppointmentTemplate("appointmentCollectorTemplate");
  }
  _initButtonTemplate(count, isCompact2) {
    this.instance._templateManager.addDefaultTemplates({
      appointmentCollector: new FunctionTemplate((options) => this._createButtonTemplate(count, renderer_default(options.container), isCompact2))
    });
  }
  _createButtonTemplate(appointmentCount, element, isCompact2) {
    const text = isCompact2 ? appointmentCount : message_default.getFormatter("dxScheduler-moreAppointments")(appointmentCount);
    return element.append(renderer_default("<span>").text(text)).addClass(APPOINTMENT_COLLECTOR_CONTENT_CLASS);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_utils.js
var utils2 = {
  dataAccessors: {
    getAppointmentSettings: (element) => renderer_default(element).data(APPOINTMENT_SETTINGS_KEY),
    getAppointmentInfo: (element) => {
      const settings = utils2.dataAccessors.getAppointmentSettings(element);
      return null === settings || void 0 === settings ? void 0 : settings.info;
    },
    create: (fields, currentDataAccessors, forceIsoDateParsing, dateSerializationFormat) => {
      const dataAccessors = currentDataAccessors ? _extends({}, currentDataAccessors) : {
        getter: {},
        setter: {},
        expr: {}
      };
      each(fields, (name2, expr) => {
        if (expr) {
          const getter = compileGetter(expr);
          const setter = compileSetter(expr);
          let dateGetter;
          let dateSetter;
          let serializationFormat;
          if (field = name2, "startDate" === field || "endDate" === field) {
            dateGetter = (object) => {
              let value2 = getter(object);
              if (forceIsoDateParsing) {
                value2 = date_serialization_default.deserializeDate(value2);
              }
              return value2;
            };
            dateSetter = (object, value2) => {
              if (dateSerializationFormat) {
                serializationFormat = dateSerializationFormat;
              } else if (forceIsoDateParsing && !serializationFormat) {
                const oldValue = getter(object);
                serializationFormat = date_serialization_default.getDateSerializationFormat(oldValue);
              }
              const newValue = date_serialization_default.serializeDate(value2, serializationFormat);
              setter(object, newValue);
            };
          }
          dataAccessors.getter[name2] = dateGetter || getter;
          dataAccessors.setter[name2] = dateSetter || setter;
          dataAccessors.expr[`${name2}Expr`] = expr;
        } else {
          delete dataAccessors.getter[name2];
          delete dataAccessors.setter[name2];
          delete dataAccessors.expr[`${name2}Expr`];
        }
        var field;
      });
      return dataAccessors;
    }
  },
  DOM: {
    getHeaderHeight: (header) => header ? header._$element && parseInt(getOuterHeight(header._$element), 10) : 0
  },
  renovation: {
    renderComponent: (widget, parentElement, componentClass, componentName, viewModel) => {
      let component = widget[componentName];
      if (!component) {
        const container = getPublicElement(parentElement);
        component = widget._createComponent(container, componentClass, viewModel);
        widget[componentName] = component;
      } else {
        const $element = component.$element();
        const elementStyle = $element.get(0).style;
        const {
          height
        } = elementStyle;
        const {
          width
        } = elementStyle;
        component.option(viewModel);
        if (height) {
          setHeight($element, height);
        }
        if (width) {
          setWidth($element, width);
        }
      }
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_subscribes.js
var toMs16 = date_default2.dateToMilliseconds;
var subscribes = {
  isCurrentViewAgenda() {
    return "agenda" === this.currentViewType;
  },
  currentViewUpdated(currentView) {
    this.option("currentView", currentView);
  },
  currentDateUpdated(date) {
    this.option("currentDate", date);
  },
  getOption(name2) {
    return this.option(name2);
  },
  getWorkspaceOption(name2) {
    return this.getWorkSpace().option(name2);
  },
  isVirtualScrolling() {
    return this.isVirtualScrolling();
  },
  setCellDataCacheAlias(appointment, geometry) {
    this._workSpace.setCellDataCacheAlias(appointment, geometry);
  },
  isGroupedByDate() {
    return this.getWorkSpace().isGroupedByDate();
  },
  showAppointmentTooltip(options) {
    const targetedAppointment = this.getTargetedAppointment(options.data, options.target);
    this.showAppointmentTooltip(options.data, options.target, targetedAppointment);
  },
  hideAppointmentTooltip() {
    this.hideAppointmentTooltip();
  },
  showEditAppointmentPopup(options) {
    const targetedData = this.getTargetedAppointment(options.data, options.target);
    this.showAppointmentPopup(options.data, false, targetedData);
  },
  updateAppointmentAfterResize(options) {
    const info = utils2.dataAccessors.getAppointmentInfo(options.$appointment);
    const {
      exceptionDate
    } = info.sourceAppointment;
    this._checkRecurringAppointment(options.target, options.data, exceptionDate, () => {
      this._updateAppointment(options.target, options.data, function() {
        this._appointments.moveAppointmentBack();
      });
    });
  },
  getUpdatedData(rawAppointment) {
    return this._getUpdatedData(rawAppointment);
  },
  updateAppointmentAfterDrag(_ref) {
    let {
      event,
      element,
      rawAppointment,
      newCellIndex,
      oldCellIndex
    } = _ref;
    const info = utils2.dataAccessors.getAppointmentInfo(element);
    const appointment = createAppointmentAdapter(rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    const targetedAppointment = createAppointmentAdapter(extend({}, rawAppointment, this._getUpdatedData(rawAppointment)), this._dataAccessors, this.timeZoneCalculator);
    const targetedRawAppointment = targetedAppointment.source();
    const becomeAllDay = targetedAppointment.allDay;
    const wasAllDay = appointment.allDay;
    const movedBetweenAllDayAndSimple = this._workSpace.supportAllDayRow() && (wasAllDay && !becomeAllDay || !wasAllDay && becomeAllDay);
    const isDragAndDropBetweenComponents = event.fromComponent !== event.toComponent;
    if (-1 === newCellIndex) {
      if (!isDragAndDropBetweenComponents) {
        this._appointments.moveAppointmentBack(event);
      }
      return;
    }
    if (newCellIndex !== oldCellIndex || isDragAndDropBetweenComponents || movedBetweenAllDayAndSimple) {
      this._checkRecurringAppointment(rawAppointment, targetedRawAppointment, info.sourceAppointment.exceptionDate, () => {
        this._updateAppointment(rawAppointment, targetedRawAppointment, function() {
          this._appointments.moveAppointmentBack(event);
        }, event);
      }, void 0, void 0, event);
    } else {
      this._appointments.moveAppointmentBack(event);
    }
  },
  onDeleteButtonPress(options) {
    const targetedData = this.getTargetedAppointment(options.data, renderer_default(options.target));
    this.checkAndDeleteAppointment(options.data, targetedData);
    this.hideAppointmentTooltip();
  },
  getTextAndFormatDate(appointmentRaw, targetedAppointmentRaw, format) {
    const appointmentAdapter = createAppointmentAdapter(appointmentRaw, this._dataAccessors, this.timeZoneCalculator);
    const targetedAdapter = createAppointmentAdapter(targetedAppointmentRaw || appointmentRaw, this._dataAccessors, this.timeZoneCalculator);
    const startDate = this.timeZoneCalculator.createDate(targetedAdapter.startDate, {
      path: "toGrid"
    });
    const endDate = this.timeZoneCalculator.createDate(targetedAdapter.endDate, {
      path: "toGrid"
    });
    const formatType = format || getFormatType(startDate, endDate, targetedAdapter.allDay, "month" !== this.currentViewType);
    return {
      text: targetedAdapter.text || appointmentAdapter.text,
      formatDate: formatDates(startDate, endDate, formatType)
    };
  },
  _createAppointmentTitle(data2) {
    if (isPlainObject(data2)) {
      return data2.text;
    }
    return String(data2);
  },
  getResizableAppointmentArea(options) {
    const {
      allDay
    } = options;
    const groups = this._getCurrentViewOption("groups");
    if (groups && groups.length) {
      if (allDay || this.getLayoutManager().getRenderingStrategyInstance()._needHorizontalGroupBounds()) {
        const horizontalGroupBounds = this._workSpace.getGroupBounds(options.coordinates);
        return {
          left: horizontalGroupBounds.left,
          right: horizontalGroupBounds.right,
          top: 0,
          bottom: 0
        };
      }
      if (this.getLayoutManager().getRenderingStrategyInstance()._needVerticalGroupBounds(allDay) && this._workSpace._isVerticalGroupedWorkSpace()) {
        const verticalGroupBounds = this._workSpace.getGroupBounds(options.coordinates);
        return {
          left: 0,
          right: 0,
          top: verticalGroupBounds.top,
          bottom: verticalGroupBounds.bottom
        };
      }
    }
    return;
  },
  needRecalculateResizableArea() {
    return this.getWorkSpace().needRecalculateResizableArea();
  },
  getAppointmentGeometry(settings) {
    return this.getLayoutManager().getRenderingStrategyInstance().getAppointmentGeometry(settings);
  },
  isAllDay(appointmentData) {
    return this.getLayoutManager().getRenderingStrategyInstance().isAllDay(appointmentData);
  },
  getDeltaTime(e, initialSize, itemData) {
    return this.getLayoutManager().getRenderingStrategyInstance().getDeltaTime(e, initialSize, itemData);
  },
  getDropDownAppointmentWidth(isAllDay) {
    return this.getLayoutManager().getRenderingStrategyInstance().getDropDownAppointmentWidth(this._getViewCountConfig().intervalCount, isAllDay);
  },
  getDropDownAppointmentHeight() {
    return this.getLayoutManager().getRenderingStrategyInstance().getDropDownAppointmentHeight();
  },
  getCellWidth() {
    return this.getWorkSpace().getCellWidth();
  },
  getCellHeight() {
    return this.getWorkSpace().getCellHeight();
  },
  getMaxAppointmentCountPerCellByType(isAllDay) {
    return this.getRenderingStrategyInstance()._getMaxAppointmentCountPerCellByType(isAllDay);
  },
  needCorrectAppointmentDates() {
    return this.getRenderingStrategyInstance().needCorrectAppointmentDates();
  },
  getRenderingStrategyDirection() {
    return this.getRenderingStrategyInstance().getDirection();
  },
  updateAppointmentEndDate(options) {
    const {
      endDate
    } = options;
    const endDayHour = this._getCurrentViewOption("endDayHour");
    const startDayHour = this._getCurrentViewOption("startDayHour");
    let updatedEndDate = endDate;
    if (endDate.getHours() >= endDayHour) {
      updatedEndDate.setHours(endDayHour, 0, 0, 0);
    } else if (!options.isSameDate && startDayHour > 0 && 60 * endDate.getHours() + endDate.getMinutes() < 60 * startDayHour) {
      updatedEndDate = new Date(updatedEndDate.getTime() - toMs16("day"));
      updatedEndDate.setHours(endDayHour, 0, 0, 0);
    }
    return updatedEndDate;
  },
  renderCompactAppointments(options) {
    this._compactAppointmentsHelper.render(options);
  },
  clearCompactAppointments() {
    this._compactAppointmentsHelper.clear();
  },
  supportCompactDropDownAppointments() {
    return this.getLayoutManager().getRenderingStrategyInstance().supportCompactDropDownAppointments();
  },
  getGroupCount() {
    return this._workSpace._getGroupCount();
  },
  mapAppointmentFields(config) {
    const {
      itemData,
      itemElement,
      targetedAppointment
    } = config;
    const targetedData = targetedAppointment || this.getTargetedAppointment(itemData, itemElement);
    return {
      appointmentData: config.itemData,
      appointmentElement: config.itemElement,
      targetedAppointmentData: targetedData
    };
  },
  dayHasAppointment(day, appointment, trimTime2) {
    return this.dayHasAppointment(day, appointment, trimTime2);
  },
  getLayoutManager() {
    return this._layoutManager;
  },
  getAgendaVerticalStepHeight() {
    return this.getWorkSpace().getAgendaVerticalStepHeight();
  },
  getAgendaDuration() {
    return this._getCurrentViewOption("agendaDuration");
  },
  getStartViewDate() {
    return this.getStartViewDate();
  },
  getEndViewDate() {
    return this.getEndViewDate();
  },
  forceMaxAppointmentPerCell() {
    return this.forceMaxAppointmentPerCell();
  },
  onAgendaReady(rows) {
    const $appts = this.getAppointmentsInstance()._itemElements();
    let total = 0;
    const applyClass = function(_, count) {
      const index = count + total - 1;
      $appts.eq(index).addClass(AGENDA_LAST_IN_DATE_APPOINTMENT_CLASS);
      total += count;
    };
    for (let i = 0; i < rows.length; i++) {
      each(rows[i], applyClass);
    }
  },
  getTimezone() {
    return this._getTimezoneOffsetByOption();
  },
  getTargetedAppointmentData(appointment, element) {
    return this.getTargetedAppointment(appointment, element);
  },
  getEndDayHour() {
    return this._workSpace.option("endDayHour") || this.option("endDayHour");
  },
  getStartDayHour() {
    return this._workSpace.option("startDayHour") || this.option("startDayHour");
  },
  getViewOffsetMs() {
    return this.getViewOffsetMs();
  },
  isAdaptive() {
    return this.option("adaptivityEnabled");
  },
  removeDroppableCellClass() {
    this._workSpace.removeDroppableCellClass();
  }
};
var m_subscribes_default = subscribes;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/common/validation_functions.js
var isInteger = (value2) => Number.isInteger(value2);
var greaterThan = function(value2, minimalValue) {
  let strict = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;
  return strict ? value2 > minimalValue : value2 >= minimalValue;
};
var lessThan = function(value2, maximalValue) {
  let strict = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;
  return strict ? value2 < maximalValue : value2 <= maximalValue;
};
var inRange = (value2, _ref) => {
  let [from, to] = _ref;
  return value2 >= from && value2 <= to;
};
var divisibleBy = (value2, divider) => value2 % divider === 0;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/core/options_validator.js
var OptionsValidator = class {
  constructor(validators) {
    this.validators = validators;
  }
  validate(options) {
    const errors = Object.entries(this.validators).reduce((result, _ref) => {
      let [validatorName, validator] = _ref;
      const validatorResult = validator.validate(options);
      if (true !== validatorResult) {
        result[validatorName] = validatorResult;
      }
      return result;
    }, {});
    return Object.keys(errors).length > 0 ? errors : true;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/core/options_validator_error_handler.js
var OptionsValidatorErrorHandler = class {
  constructor(validatorNameToErrorCodeMap, globalErrorHandler) {
    this.validatorNameToErrorCodeMap = validatorNameToErrorCodeMap;
    this.globalErrorHandler = globalErrorHandler;
  }
  handleValidationResult(optionsValidatorResult) {
    if (true === optionsValidatorResult) {
      return;
    }
    const uniqErrorCodes = Object.keys(optionsValidatorResult).reduce((set, validatorName) => {
      const errorCode = this.validatorNameToErrorCodeMap[validatorName];
      if (errorCode) {
        set.add(errorCode);
      }
      return set;
    }, /* @__PURE__ */ new Set());
    const errorCodeArray = [...uniqErrorCodes];
    errorCodeArray.forEach((errorCode, idx) => {
      const isLastErrorCode = idx === errorCodeArray.length - 1;
      if (!isLastErrorCode) {
        this.globalErrorHandler.logError(errorCode);
      } else {
        this.globalErrorHandler.throwError(errorCode);
      }
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/core/validator.js
var Validator = class {
  constructor(valueSelector, rules) {
    this.valueSelector = valueSelector;
    this.rules = rules;
  }
  validate(options) {
    const value2 = this.valueSelector(options);
    const errors = this.rules.reduce((result, rule) => {
      const validationResult = rule(value2);
      if (true !== validationResult) {
        result[rule.name] = validationResult;
      }
      return result;
    }, {});
    return Object.keys(errors).length ? errors : true;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/core/validator_rules.js
var createValidatorRule = (name2, ruleFunc) => {
  Object.defineProperty(ruleFunc, "name", {
    value: name2,
    writable: false
  });
  return ruleFunc;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/common/validator_rules.js
var mustBeInteger = createValidatorRule("mustBeInteger", (value2) => isInteger(value2) || `${value2} must be an integer.`);
var mustBeGreaterThan = function(minimalValue) {
  let strict = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
  return createValidatorRule("mustBeGreaterThan", (value2) => greaterThan(value2, minimalValue, strict) || `${value2} must be ${strict ? ">" : ">="} than ${minimalValue}.`);
};
var mustBeInRange = (range2) => createValidatorRule("mustBeInRange", (value2) => inRange(value2, range2) || `${value2} must be in range [${range2[0]}, ${range2[1]}].`);
var mustBeDivisibleBy = (divider) => createValidatorRule("mustBeDivisibleBy", (value2) => divisibleBy(value2, divider) || `${value2} must be divisible by ${divider}.`);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/validator_rules.js
var endDayHourMustBeGreaterThanStartDayHour = createValidatorRule("endDayHourGreaterThanStartDayHour", (_ref) => {
  let {
    startDayHour,
    endDayHour
  } = _ref;
  return greaterThan(endDayHour, startDayHour) || `endDayHour: ${endDayHour} must be greater that startDayHour: ${startDayHour}.`;
});
var visibleIntervalMustBeDivisibleByCellDuration = createValidatorRule("visibleIntervalMustBeDivisibleByCellDuration", (_ref2) => {
  let {
    cellDuration,
    startDayHour,
    endDayHour
  } = _ref2;
  const visibleInterval = 60 * (endDayHour - startDayHour);
  return divisibleBy(visibleInterval, cellDuration) || `endDayHour - startDayHour: ${visibleInterval} (minutes), must be divisible by cellDuration: ${cellDuration} (minutes).`;
});
var cellDurationMustBeLessThanVisibleInterval = createValidatorRule("cellDurationMustBeLessThanVisibleInterval", (_ref3) => {
  let {
    cellDuration,
    startDayHour,
    endDayHour
  } = _ref3;
  const visibleInterval = 60 * (endDayHour - startDayHour);
  return lessThan(cellDuration, visibleInterval, false) || `endDayHour - startDayHour: ${visibleInterval} (minutes), must be greater or equal the cellDuration: ${cellDuration} (minutes).`;
});

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/options_validator.js
var SchedulerOptionsValidator = class extends OptionsValidator {
  constructor() {
    super({
      startDayHour: new Validator((_ref) => {
        let {
          startDayHour
        } = _ref;
        return startDayHour;
      }, [mustBeInteger, mustBeInRange([0, 24])]),
      endDayHour: new Validator((_ref2) => {
        let {
          endDayHour
        } = _ref2;
        return endDayHour;
      }, [mustBeInteger, mustBeInRange([0, 24])]),
      offset: new Validator((_ref3) => {
        let {
          offset
        } = _ref3;
        return offset;
      }, [mustBeInteger, mustBeInRange([-1440, 1440]), mustBeDivisibleBy(5)]),
      cellDuration: new Validator((_ref4) => {
        let {
          cellDuration
        } = _ref4;
        return cellDuration;
      }, [mustBeInteger, mustBeGreaterThan(0)]),
      startDayHourAndEndDayHour: new Validator((options) => options, [endDayHourMustBeGreaterThanStartDayHour]),
      cellDurationAndVisibleInterval: new Validator((options) => options, [visibleIntervalMustBeDivisibleByCellDuration, cellDurationMustBeLessThanVisibleInterval])
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/options_validator_errors_handler.js
var GLOBAL_ERROR_HANDLER = {
  logError: (errorCode) => {
    ui_errors_default.log(errorCode);
  },
  throwError: (errorCode) => {
    throw ui_errors_default.Error(errorCode);
  }
};
var SchedulerOptionsValidatorErrorsHandler = class extends OptionsValidatorErrorHandler {
  constructor() {
    super({
      startDayHour: "E1058",
      endDayHour: "E1058",
      startDayHourAndEndDayHour: "E1058",
      offset: "E1061",
      cellDuration: "E1062",
      cellDurationAndVisibleInterval: "E1062"
    }, GLOBAL_ERROR_HANDLER);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/resources/m_agenda_resource_processor.js
var PromiseItem = class {
  constructor(rawAppointment, promise) {
    this.rawAppointment = rawAppointment;
    this.promise = promise;
  }
};
var AgendaResourceProcessor = class {
  get resourceDeclarations() {
    return this._resourceDeclarations;
  }
  set resourceDeclarations(value2) {
    this._resourceDeclarations = value2;
    this.isLoaded = false;
    this.isLoading = false;
    this.resourceMap.clear();
    this.appointmentPromiseQueue = [];
  }
  constructor() {
    let resourceDeclarations = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    this._resourceDeclarations = resourceDeclarations;
    this.isLoaded = false;
    this.isLoading = false;
    this.resourceMap = /* @__PURE__ */ new Map();
    this.appointmentPromiseQueue = [];
  }
  _pushAllResources() {
    this.appointmentPromiseQueue.forEach((_ref) => {
      let {
        promise,
        rawAppointment
      } = _ref;
      const result = [];
      this.resourceMap.forEach((resource, fieldName) => {
        const item = {
          label: resource.label,
          values: []
        };
        if (fieldName in rawAppointment) {
          wrapToArray(rawAppointment[fieldName]).forEach((value2) => item.values.push(resource.map.get(value2)));
        }
        if (item.values.length) {
          result.push(item);
        }
      });
      promise.resolve(result);
    });
    this.appointmentPromiseQueue = [];
  }
  _onPullResource(fieldName, valueName, displayName, label, items) {
    const map2 = /* @__PURE__ */ new Map();
    items.forEach((item) => map2.set(item[valueName], item[displayName]));
    this.resourceMap.set(fieldName, {
      label,
      map: map2
    });
  }
  _hasResourceDeclarations(resources) {
    if (0 === resources.length) {
      this.appointmentPromiseQueue.forEach((_ref2) => {
        let {
          promise
        } = _ref2;
        return promise.resolve([]);
      });
      this.appointmentPromiseQueue = [];
      return false;
    }
    return true;
  }
  _tryPullResources(resources, resultAsync) {
    if (!this.isLoading) {
      this.isLoading = true;
      const promises = [];
      resources.forEach((resource) => {
        const promise = new Deferred().done((items) => this._onPullResource(getFieldExpr(resource), getValueExpr(resource), getDisplayExpr(resource), resource.label, items));
        promises.push(promise);
        const dataSource = getWrappedDataSource(resource.dataSource);
        if (dataSource.isLoaded()) {
          promise.resolve(dataSource.items());
        } else {
          dataSource.load().done((list) => promise.resolve(list)).fail(() => promise.reject());
        }
      });
      when.apply(null, promises).done(() => {
        this.isLoaded = true;
        this.isLoading = false;
        this._pushAllResources();
      }).fail(() => resultAsync.reject());
    }
  }
  initializeState() {
    let resourceDeclarations = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    this.resourceDeclarations = resourceDeclarations;
  }
  createListAsync(rawAppointment) {
    const resultAsync = new Deferred();
    this.appointmentPromiseQueue.push(new PromiseItem(rawAppointment, resultAsync));
    if (this._hasResourceDeclarations(this.resourceDeclarations)) {
      if (this.isLoaded) {
        this._pushAllResources();
      } else {
        this._tryPullResources(this.resourceDeclarations, resultAsync);
      }
    }
    return resultAsync.promise();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/utils/promise.js
function createPromise() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    resolve,
    reject
  };
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/tooltip_strategies/m_tooltip_strategy_base.js
var TOOLTIP_APPOINTMENT_ITEM = "dx-tooltip-appointment-item";
var TOOLTIP_APPOINTMENT_ITEM_CONTENT = `${TOOLTIP_APPOINTMENT_ITEM}-content`;
var TOOLTIP_APPOINTMENT_ITEM_CONTENT_SUBJECT = `${TOOLTIP_APPOINTMENT_ITEM}-content-subject`;
var TOOLTIP_APPOINTMENT_ITEM_CONTENT_DATE = `${TOOLTIP_APPOINTMENT_ITEM}-content-date`;
var TOOLTIP_APPOINTMENT_ITEM_MARKER = `${TOOLTIP_APPOINTMENT_ITEM}-marker`;
var TOOLTIP_APPOINTMENT_ITEM_MARKER_BODY = `${TOOLTIP_APPOINTMENT_ITEM}-marker-body`;
var TOOLTIP_APPOINTMENT_ITEM_DELETE_BUTTON_CONTAINER = `${TOOLTIP_APPOINTMENT_ITEM}-delete-button-container`;
var TOOLTIP_APPOINTMENT_ITEM_DELETE_BUTTON = `${TOOLTIP_APPOINTMENT_ITEM}-delete-button`;
var TooltipStrategyBase = class {
  constructor(options) {
    this.asyncTemplatePromises = /* @__PURE__ */ new Set();
    this._tooltip = null;
    this._options = options;
    this._extraOptions = null;
  }
  show(target, dataList, extraOptions) {
    if (this._canShowTooltip(dataList)) {
      this.hide();
      this._extraOptions = extraOptions;
      this._showCore(target, dataList);
    }
  }
  _showCore(target, dataList) {
    if (!this._tooltip) {
      this._tooltip = this._createTooltip(target, dataList);
    } else {
      this._shouldUseTarget() && this._tooltip.option("target", target);
      this._list.option("dataSource", dataList);
    }
    this._prepareBeforeVisibleChanged(dataList);
    this._tooltip.option("visible", true);
  }
  _prepareBeforeVisibleChanged(dataList) {
  }
  _getContentTemplate(dataList) {
    return (container) => {
      const listElement = renderer_default("<div>");
      renderer_default(container).append(listElement);
      this._list = this._createList(listElement, dataList);
    };
  }
  isAlreadyShown(target) {
    if (this._tooltip && this._tooltip.option("visible")) {
      return this._tooltip.option("target")[0] === target[0];
    }
    return;
  }
  _onShown() {
    this._list.option("focusStateEnabled", this._extraOptions.focusStateEnabled);
  }
  dispose() {
  }
  hide() {
    if (this._tooltip) {
      this._tooltip.option("visible", false);
    }
  }
  _shouldUseTarget() {
    return true;
  }
  _createTooltip(target, dataList) {
  }
  _canShowTooltip(dataList) {
    if (!dataList.length) {
      return false;
    }
    return true;
  }
  _createListOption(dataList) {
    return {
      dataSource: dataList,
      onContentReady: this._onListRender.bind(this),
      onItemClick: (e) => this._onListItemClick(e),
      onItemContextMenu: this._onListItemContextMenu.bind(this),
      itemTemplate: (item, index) => this._renderTemplate(item.appointment, item.targetedAppointment, index, item.color),
      _swipeEnabled: false,
      pageLoadMode: "scrollBottom"
    };
  }
  _onListRender(e) {
  }
  _createTooltipElement(wrapperClass) {
    return renderer_default("<div>").appendTo(this._options.container).addClass(wrapperClass);
  }
  _createList(listElement, dataList) {
    return this._options.createComponent(listElement, m_list_edit_default, this._createListOption(dataList));
  }
  _renderTemplate(appointment, targetedAppointment, index, color) {
    const itemListContent = this._createItemListContent(appointment, targetedAppointment, color);
    this._options.addDefaultTemplates({
      [this._getItemListTemplateName()]: new FunctionTemplate((options) => {
        const $container = renderer_default(options.container);
        $container.append(itemListContent);
        return $container;
      })
    });
    const template = this._options.getAppointmentTemplate(`${this._getItemListTemplateName()}Template`);
    return this._createFunctionTemplate(template, appointment, targetedAppointment, index);
  }
  _createFunctionTemplate(template, appointmentData, targetedAppointmentData, index) {
    const isButtonClicked = !!this._extraOptions.isButtonClick;
    const isEmptyDropDownAppointmentTemplate = this._isEmptyDropDownAppointmentTemplate();
    return new FunctionTemplate((options) => {
      const {
        promise,
        resolve
      } = createPromise();
      this.asyncTemplatePromises.add(promise);
      return template.render({
        model: isEmptyDropDownAppointmentTemplate ? {
          appointmentData,
          targetedAppointmentData,
          isButtonClicked
        } : appointmentData,
        container: options.container,
        index,
        onRendered: () => {
          this.asyncTemplatePromises.delete(promise);
          resolve();
        }
      });
    });
  }
  _getItemListTemplateName() {
    return this._isEmptyDropDownAppointmentTemplate() ? "appointmentTooltip" : "dropDownAppointment";
  }
  _isEmptyDropDownAppointmentTemplate() {
    return !this._extraOptions.dropDownAppointmentTemplate || "dropDownAppointment" === this._extraOptions.dropDownAppointmentTemplate;
  }
  _onListItemClick(e) {
    this.hide();
    this._extraOptions.clickEvent && this._extraOptions.clickEvent(e);
    this._options.showAppointmentPopup(e.itemData.appointment, false, e.itemData.targetedAppointment);
  }
  _onListItemContextMenu(e) {
  }
  _createItemListContent(appointment, targetedAppointment, color) {
    const {
      editing
    } = this._extraOptions;
    const $itemElement = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM);
    $itemElement.append(this._createItemListMarker(color));
    $itemElement.append(this._createItemListInfo(this._options.createFormattedDateText(appointment, targetedAppointment)));
    const disabled = this._options.getAppointmentDisabled(appointment);
    if (!disabled && (editing && true === editing.allowDeleting || true === editing)) {
      $itemElement.append(this._createDeleteButton(appointment, targetedAppointment));
    }
    return $itemElement;
  }
  _createItemListMarker(color) {
    const $marker = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_MARKER);
    const $markerBody = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_MARKER_BODY);
    $marker.append($markerBody);
    color && color.done((value2) => $markerBody.css("background", value2));
    return $marker;
  }
  _createItemListInfo(object) {
    const result = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_CONTENT);
    const $title = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_CONTENT_SUBJECT).text(object.text);
    const $date = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_CONTENT_DATE).text(object.formatDate);
    return result.append($title).append($date);
  }
  _createDeleteButton(appointment, targetedAppointment) {
    const $container = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_DELETE_BUTTON_CONTAINER);
    const $deleteButton = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_DELETE_BUTTON);
    $container.append($deleteButton);
    this._options.createComponent($deleteButton, button_default, {
      icon: "trash",
      stylingMode: "text",
      onClick: (e) => {
        this.hide();
        e.event.stopPropagation();
        this._options.checkAndDeleteAppointment(appointment, targetedAppointment);
      }
    });
    return $container;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/tooltip_strategies/m_desktop_tooltip_strategy.js
var APPOINTMENT_TOOLTIP_WRAPPER_CLASS = "dx-scheduler-appointment-tooltip-wrapper";
var DesktopTooltipStrategy = class extends TooltipStrategyBase {
  _prepareBeforeVisibleChanged(dataList) {
    this._tooltip.option("position", {
      my: "bottom",
      at: "top",
      boundary: this._getBoundary(dataList),
      offset: this._extraOptions.offset,
      collision: "fit flipfit"
    });
  }
  _getBoundary(dataList) {
    return this._options.isAppointmentInAllDayPanel(dataList[0].appointment) ? this._options.container : this._options.getScrollableContainer();
  }
  _onShown() {
    super._onShown();
    if (this._extraOptions.isButtonClick) {
      this._list.focus();
      this._list.option("focusedElement", null);
    }
  }
  _createListOption(target, dataList) {
    const result = super._createListOption(target, dataList);
    result.showScrollbar = touch ? "always" : "onHover";
    return result;
  }
  _createTooltip(target, dataList) {
    const tooltip2 = this._createTooltipElement(APPOINTMENT_TOOLTIP_WRAPPER_CLASS);
    return this._options.createComponent(tooltip2, m_tooltip_default, {
      target,
      maxHeight: 200,
      rtlEnabled: this._extraOptions.rtlEnabled,
      onShown: this._onShown.bind(this),
      contentTemplate: this._getContentTemplate(dataList),
      wrapperAttr: {
        class: APPOINTMENT_TOOLTIP_WRAPPER_CLASS
      }
    });
  }
  _onListRender(e) {
    return this._extraOptions.dragBehavior && this._extraOptions.dragBehavior(e);
  }
  _onListItemContextMenu(e) {
    const contextMenuEventArgs = this._options.createEventArgs(e);
    this._options.onItemContextMenu(contextMenuEventArgs);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/tooltip_strategies/m_mobile_tooltip_strategy.js
var CLASS = {
  slidePanel: "dx-scheduler-overlay-panel",
  scrollableContent: ".dx-scrollable-content"
};
var MAX_HEIGHT = {
  PHONE: 250,
  TABLET: "90%",
  DEFAULT: "auto"
};
var MAX_WIDTH = {
  PHONE: "100%",
  TABLET: "80%"
};
var animationConfig = {
  show: {
    type: "slide",
    duration: 300,
    from: {
      position: {
        my: "top",
        at: "bottom",
        of: getWindow()
      }
    },
    to: {
      position: {
        my: "center",
        at: "center",
        of: getWindow()
      }
    }
  },
  hide: {
    type: "slide",
    duration: 300,
    to: {
      position: {
        my: "top",
        at: "bottom",
        of: getWindow()
      }
    },
    from: {
      position: {
        my: "center",
        at: "center",
        of: getWindow()
      }
    }
  }
};
var createPhoneDeviceConfig = (listHeight) => ({
  shading: false,
  width: MAX_WIDTH.PHONE,
  height: listHeight > MAX_HEIGHT.PHONE ? MAX_HEIGHT.PHONE : MAX_HEIGHT.DEFAULT,
  position: {
    my: "bottom",
    at: "bottom",
    of: getWindow()
  }
});
var createTabletDeviceConfig = (listHeight) => {
  const currentMaxHeight = 0.9 * getHeight(getWindow());
  return {
    shading: true,
    width: MAX_WIDTH.TABLET,
    height: listHeight > currentMaxHeight ? MAX_HEIGHT.TABLET : MAX_HEIGHT.DEFAULT,
    position: {
      my: "center",
      at: "center",
      of: getWindow()
    }
  };
};
var MobileTooltipStrategy = class extends TooltipStrategyBase {
  _shouldUseTarget() {
    return false;
  }
  setTooltipConfig() {
    const isTabletWidth = getWidth(getWindow()) > 700;
    const listHeight = getOuterHeight(this._list.$element().find(CLASS.scrollableContent));
    this._tooltip.option(isTabletWidth ? createTabletDeviceConfig(listHeight) : createPhoneDeviceConfig(listHeight));
  }
  async _onShowing() {
    this._tooltip.option("height", MAX_HEIGHT.DEFAULT);
    this.setTooltipConfig();
    await Promise.all([...this.asyncTemplatePromises]);
    this.setTooltipConfig();
  }
  _createTooltip(target, dataList) {
    const element = this._createTooltipElement(CLASS.slidePanel);
    return this._options.createComponent(element, ui_overlay_default, {
      target: getWindow(),
      hideOnOutsideClick: true,
      animation: animationConfig,
      onShowing: () => this._onShowing(),
      onShown: this._onShown.bind(this),
      contentTemplate: this._getContentTemplate(dataList),
      wrapperAttr: {
        class: CLASS.slidePanel
      }
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_table_creator.js
var SchedulerTableCreator = class {
  constructor() {
    this.VERTICAL = "vertical";
    this.HORIZONTAL = "horizontal";
  }
  insertAllDayRow(allDayElements, tableBody, index) {
    if (allDayElements[index]) {
      let row = allDayElements[index].find("tr");
      if (!row.length) {
        row = renderer_default(dom_adapter_default.createElement("tr"));
        row.append(allDayElements[index].get(0));
      }
      tableBody.appendChild(row.get ? row.get(0) : row);
    }
  }
  makeTable(options) {
    const tableBody = dom_adapter_default.createElement("tbody");
    const templateCallbacks = [];
    let row;
    const rowCountInGroup = options.groupCount ? options.rowCount / options.groupCount : options.rowCount;
    let allDayElementIndex = 0;
    const {
      allDayElements
    } = options;
    const {
      groupIndex
    } = options;
    const {
      rowCount
    } = options;
    renderer_default(options.container).append(tableBody);
    if (allDayElements) {
      this.insertAllDayRow(allDayElements, tableBody, 0);
      allDayElementIndex++;
    }
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
      row = dom_adapter_default.createElement("tr");
      tableBody.appendChild(row);
      const isLastRowInGroup = (rowIndex + 1) % rowCountInGroup === 0;
      if (options.rowClass) {
        row.className = options.rowClass;
      }
      for (let columnIndex = 0; columnIndex < options.cellCount; columnIndex++) {
        var _options$setAdditiona;
        const td = dom_adapter_default.createElement("td");
        row.appendChild(td);
        if (options.cellClass) {
          if (isFunction(options.cellClass)) {
            td.className = options.cellClass(rowIndex, columnIndex);
          } else {
            td.className = options.cellClass;
          }
        }
        let cellDataObject;
        let dataKey;
        let dataValue;
        if (options.getCellData) {
          cellDataObject = options.getCellData(td, rowIndex, columnIndex, groupIndex);
          dataKey = cellDataObject.key;
          dataValue = cellDataObject.value;
          dataKey && data(td, dataKey, dataValue);
        }
        null === (_options$setAdditiona = options.setAdditionalClasses) || void 0 === _options$setAdditiona || _options$setAdditiona.call(options, renderer_default(td), dataValue);
        if (options.cellTemplate && options.cellTemplate.render) {
          const additionalTemplateData = options.getTemplateData ? options.getTemplateData(rowIndex) : {};
          const templateOptions = {
            model: _extends({
              text: options.getCellText ? options.getCellText(rowIndex, columnIndex) : "",
              date: options.getCellDate ? options.getCellDate(rowIndex) : void 0
            }, additionalTemplateData),
            container: getPublicElement(renderer_default(td)),
            index: rowIndex * options.cellCount + columnIndex
          };
          if (dataValue) {
            if (dataValue.startDate) {
              templateOptions.model.startDate = dataValue.startDate;
            }
            if (dataValue.endDate) {
              templateOptions.model.endDate = dataValue.endDate;
            }
            if (dataValue.groups) {
              templateOptions.model.groups = dataValue.groups;
            }
            if (dataValue.allDay) {
              templateOptions.model.allDay = dataValue.allDay;
            }
          }
          templateCallbacks.push(options.cellTemplate.render.bind(options.cellTemplate, templateOptions));
        } else if (options.getCellText) {
          renderer_default("<div>").text(options.getCellText(rowIndex, columnIndex)).addClass(options.getCellTextClass).appendTo(renderer_default(td));
        }
      }
      if (allDayElements && isLastRowInGroup) {
        this.insertAllDayRow(allDayElements, tableBody, allDayElementIndex);
        allDayElementIndex++;
      }
    }
    return templateCallbacks;
  }
  makeGroupedTable(type, groups, cssClasses, cellCount, cellTemplate, rowCount, groupByDate) {
    let rows = [];
    if (type === this.VERTICAL) {
      rows = this._makeVerticalGroupedRows(groups, cssClasses, cellTemplate, rowCount);
    } else {
      rows = this._makeHorizontalGroupedRows(groups, cssClasses, cellCount, cellTemplate, groupByDate);
    }
    return rows;
  }
  makeGroupedTableFromJSON(type, data2, config) {
    let table;
    const cellStorage = [];
    let rowIndex = 0;
    config = config || {};
    const cellTag = config.cellTag || "td";
    const childrenField = config.childrenField || "children";
    const titleField = config.titleField || "title";
    const {
      groupTableClass
    } = config;
    const {
      groupRowClass
    } = config;
    const {
      groupCellClass
    } = config;
    const {
      groupCellCustomContent
    } = config;
    function getChildCount(item) {
      if (item[childrenField]) {
        return item[childrenField].length;
      }
      return 0;
    }
    function createCell(text, childCount, index, data3) {
      const cell = {
        element: dom_adapter_default.createElement(cellTag),
        childCount
      };
      if (groupCellClass) {
        cell.element.className = groupCellClass;
      }
      const cellText = dom_adapter_default.createTextNode(text);
      if ("function" === typeof groupCellCustomContent) {
        groupCellCustomContent(cell.element, cellText, index, data3);
      } else {
        cell.element.appendChild(cellText);
      }
      return cell;
    }
    !function() {
      table = dom_adapter_default.createElement("table");
      if (groupTableClass) {
        table.className = groupTableClass;
      }
    }();
    !function generateCells(data3) {
      for (let i = 0; i < data3.length; i++) {
        const childCount = getChildCount(data3[i]);
        const cell = createCell(data3[i][titleField], childCount, i, data3[i]);
        if (!cellStorage[rowIndex]) {
          cellStorage[rowIndex] = [];
        }
        cellStorage[rowIndex].push(cell);
        if (childCount) {
          generateCells(data3[i][childrenField]);
        } else {
          rowIndex++;
        }
      }
    }(data2);
    void cellStorage.forEach((cells) => {
      const row = dom_adapter_default.createElement("tr");
      if (groupRowClass) {
        row.className = groupRowClass;
      }
      const rowspans = [];
      for (let i = cells.length - 1; i >= 0; i--) {
        const prev = cells[i + 1];
        let rowspan = cells[i].childCount;
        if (prev && prev.childCount) {
          rowspan *= prev.childCount;
        }
        rowspans.push(rowspan);
      }
      rowspans.reverse();
      cells.forEach((cell, index) => {
        if (rowspans[index]) {
          cell.element.setAttribute("rowSpan", rowspans[index]);
        }
        row.appendChild(cell.element);
      });
      table.appendChild(row);
    });
    return table;
  }
  _makeFlexGroupedRowCells(group, repeatCount, cssClasses, cellTemplate) {
    let repeatByDate = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1;
    const cells = [];
    const {
      items
    } = group;
    const itemCount = items.length;
    for (let i = 0; i < repeatCount * repeatByDate; i++) {
      for (let j = 0; j < itemCount; j++) {
        let $container = renderer_default("<div>");
        const cell = {};
        if (cellTemplate && cellTemplate.render) {
          const templateOptions = {
            model: items[j],
            container: getPublicElement($container),
            index: i * itemCount + j
          };
          if (group.data) {
            templateOptions.model.data = group.data[j];
          }
          cell.template = cellTemplate.render.bind(cellTemplate, templateOptions);
        } else {
          $container.text(items[j].text).attr("title", items[j].text).addClass("dx-scheduler-group-header-content");
          $container = renderer_default("<div>").append($container);
        }
        const cssClass = isFunction(cssClasses.groupHeaderClass) ? cssClasses.groupHeaderClass(j) : cssClasses.groupHeaderClass;
        cell.element = $container.addClass(cssClass);
        cells.push(cell);
      }
    }
    return cells;
  }
  _makeVerticalGroupedRows(groups, cssClasses, cellTemplate, rowCount) {
    const cellTemplates = [];
    let repeatCount = 1;
    const cellsArray = [];
    const cellIterator = function(cell) {
      if (cell.template) {
        cellTemplates.push(cell.template);
      }
    };
    for (let i = 0; i < groups.length; i++) {
      if (i > 0) {
        repeatCount = groups[i - 1].items.length * repeatCount;
      }
      const cells = this._makeFlexGroupedRowCells(groups[i], repeatCount, cssClasses, cellTemplate);
      cells.forEach(cellIterator);
      cellsArray.push(cells);
    }
    const rows = [];
    const groupCount = cellsArray.length;
    for (let i = 0; i < groupCount; i++) {
      rows.push(renderer_default("<div>").addClass(cssClasses.groupHeaderRowClass));
    }
    for (let i = groupCount - 1; i >= 0; i--) {
      const currentColumnLength = cellsArray[i].length;
      for (let j = 0; j < currentColumnLength; j++) {
        rows[i].append(cellsArray[i][j].element);
      }
    }
    return {
      elements: renderer_default("<div>").addClass("dx-scheduler-group-flex-container").append(rows),
      cellTemplates
    };
  }
  _makeHorizontalGroupedRows(groups, cssClasses, cellCount, cellTemplate, groupByDate) {
    let repeatCount = 1;
    const groupCount = groups.length;
    const rows = [];
    const cellTemplates = [];
    const repeatByDate = groupByDate ? cellCount : 1;
    const cellIterator = function(cell) {
      if (cell.template) {
        cellTemplates.push(cell.template);
      }
      return cell.element;
    };
    for (let i = 0; i < groupCount; i++) {
      if (i > 0) {
        repeatCount = groups[i - 1].items.length * repeatCount;
      }
      const cells = this._makeGroupedRowCells(groups[i], repeatCount, cssClasses, cellTemplate, repeatByDate);
      rows.push(renderer_default("<tr>").addClass(cssClasses.groupRowClass).append(cells.map(cellIterator)));
    }
    const maxCellCount = rows[groupCount - 1].find("th").length;
    for (let j = 0; j < groupCount; j++) {
      const $cell = rows[j].find("th");
      let colspan = maxCellCount / $cell.length;
      if (!groupByDate) {
        colspan *= cellCount;
      }
      if (colspan > 1 && 1 === repeatByDate || groupByDate && groupCount > 1) {
        $cell.attr("colSpan", colspan);
      }
    }
    return {
      elements: rows,
      cellTemplates
    };
  }
  _makeGroupedRowCells(group, repeatCount, cssClasses, cellTemplate, repeatByDate) {
    repeatByDate = repeatByDate || 1;
    repeatCount *= repeatByDate;
    const cells = [];
    const {
      items
    } = group;
    const itemCount = items.length;
    for (let i = 0; i < repeatCount; i++) {
      for (let j = 0; j < itemCount; j++) {
        let $container = renderer_default("<div>");
        const cell = {};
        if (cellTemplate && cellTemplate.render) {
          const templateOptions = {
            model: items[j],
            container: getPublicElement($container),
            index: i * itemCount + j
          };
          if (group.data) {
            templateOptions.model.data = group.data[j];
          }
          cell.template = cellTemplate.render.bind(cellTemplate, templateOptions);
        } else {
          $container.text(items[j].text);
          $container = renderer_default("<div>").append($container);
        }
        $container.addClass(cssClasses.groupHeaderContentClass);
        let cssClass;
        if (isFunction(cssClasses.groupHeaderClass)) {
          cssClass = cssClasses.groupHeaderClass(j);
        } else {
          cssClass = cssClasses.groupHeaderClass;
        }
        cell.element = renderer_default("<th>").addClass(cssClass).append($container);
        cells.push(cell);
      }
    }
    return cells;
  }
};
var m_table_creator_default = {
  tableCreator: new SchedulerTableCreator()
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/utils/scroll.js
function getMemoizeScrollTo(getScrollableInstance) {
  const instance = getScrollableInstance();
  let lastParams = {};
  return function(params) {
    let force = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const normalizedParams = {
      top: void 0 !== params.top ? Math.ceil(params.top) : void 0,
      left: void 0 !== params.left ? Math.ceil(params.left) : void 0
    };
    const isSameParams = normalizedParams.top === lastParams.top && normalizedParams.left === lastParams.left;
    if (!force && isSameParams) {
      return;
    }
    lastParams = normalizedParams;
    instance.scrollTo(params);
  };
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/r1/utils/shallow_equals.js
var shallowEquals = (firstObject, secondObject) => {
  if (Object.keys(firstObject).length !== Object.keys(secondObject).length) {
    return false;
  }
  return Object.keys(firstObject).every((key) => firstObject[key] === secondObject[key]);
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/r1/template_wrapper.js
var _excluded2 = ["isEqual"];
var isDxElementWrapper = (element) => !!element.toArray;
var buildTemplateArgs = (model, template) => {
  const args = {
    template,
    model: _extends({}, model)
  };
  const _ref = model.data ?? {}, {
    isEqual
  } = _ref, data2 = _objectWithoutPropertiesLoose(_ref, _excluded2);
  if (isEqual) {
    args.model.data = data2;
    args.isEqual = isEqual;
  }
  return args;
};
var renderTemplateContent = (props, container) => {
  const {
    data: data2,
    index
  } = props.model ?? {
    data: {}
  };
  if (data2) {
    Object.keys(data2).forEach((name2) => {
      if (data2[name2] && dom_adapter_default.isNode(data2[name2])) {
        data2[name2] = getPublicElement(renderer_default(data2[name2]));
      }
    });
  }
  const rendered = props.template.render(_extends({
    container,
    transclude: props.transclude
  }, {
    renovated: props.renovated
  }, !props.transclude ? {
    model: data2
  } : {}, !props.transclude && Number.isFinite(index) ? {
    index
  } : {}));
  if (void 0 === rendered) {
    return [];
  }
  return isDxElementWrapper(rendered) ? rendered.toArray() : [renderer_default(rendered).get(0)];
};
var removeDifferentElements = (oldChildren, newChildren) => {
  newChildren.forEach((newElement) => {
    const hasOldChild = !!oldChildren.find((oldElement) => newElement === oldElement);
    if (!hasOldChild && newElement.parentNode) {
      renderer_default(newElement).remove();
    }
  });
};
var TemplateWrapper = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.renderTemplate = this.renderTemplate.bind(this);
  }
  renderTemplate() {
    const node = findDOMfromVNode(this.$LI, true);
    if (!(null !== node && void 0 !== node && node.parentNode)) {
      return () => {
      };
    }
    const container = node.parentNode;
    const $container = renderer_default(container);
    const $oldContainerContent = $container.contents().toArray();
    const content = renderTemplateContent(this.props, getPublicElement($container));
    replaceWith(renderer_default(node), renderer_default(content));
    return () => {
      const $actualContainerContent = renderer_default(container).contents().toArray();
      removeDifferentElements($oldContainerContent, $actualContainerContent);
      container.appendChild(node);
    };
  }
  shouldComponentUpdate(nextProps) {
    const {
      template,
      model
    } = this.props;
    const {
      template: nextTemplate,
      model: nextModel,
      isEqual
    } = nextProps;
    const equalityComparer = isEqual ?? shallowEquals;
    if (template !== nextTemplate) {
      return true;
    }
    if (!isDefined(model) || !isDefined(nextModel)) {
      return model !== nextModel;
    }
    const {
      data: data2,
      index
    } = model;
    const {
      data: nextData,
      index: nextIndex
    } = nextModel;
    if (index !== nextIndex) {
      return true;
    }
    return !equalityComparer(data2, nextData);
  }
  createEffects() {
    return [new InfernoEffect(this.renderTemplate, [this.props.template, this.props.model])];
  }
  updateEffects() {
    this._effects[0].update([this.props.template, this.props.model]);
  }
  componentWillUnmount() {
  }
  render() {
    return null;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/r1/utils/get_template.js
var getTemplate = (TemplateProp) => TemplateProp && (TemplateProp.defaultProps ? (props) => normalizeProps(createComponentVNode(2, TemplateProp, _extends({}, props))) : TemplateProp);

// ../../../../../../node_modules/devextreme/esm/__internal/core/r1/utils/update_props_immutable.js
var cloneObjectValue = (value2) => Array.isArray(value2) ? [...value2] : _extends({}, value2);
var cloneObjectProp = (value2, prevValue, fullNameParts) => {
  const result = fullNameParts.length > 0 && prevValue && value2 !== prevValue ? cloneObjectValue(prevValue) : cloneObjectValue(value2);
  const name2 = fullNameParts[0];
  if (fullNameParts.length > 1) {
    result[name2] = cloneObjectProp(value2[name2], null === prevValue || void 0 === prevValue ? void 0 : prevValue[name2], fullNameParts.slice(1));
  } else if (name2) {
    if (isPlainObject(value2[name2])) {
      result[name2] = cloneObjectValue(value2[name2]);
    } else {
      result[name2] = value2[name2];
    }
  }
  return result;
};
var updatePropsImmutable = (props, option, name2, fullName) => {
  const currentPropsValue = option[name2];
  const prevPropsValue = props[name2];
  const result = props;
  if (isPlainObject(currentPropsValue) || name2 !== fullName && Array.isArray(currentPropsValue)) {
    result[name2] = cloneObjectProp(currentPropsValue, prevPropsValue, getPathParts(fullName).slice(1));
  } else {
    result[name2] = currentPropsValue;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/r1/component_wrapper.js
var setDefaultOptionValue = (options, defaultValueGetter) => (name2) => {
  if (Object.prototype.hasOwnProperty.call(options, name2) && void 0 === options[name2]) {
    options[name2] = defaultValueGetter(name2);
  }
};
var ComponentWrapper = class extends dom_component_default {
  get _propsInfo() {
    return {
      allowNull: [],
      twoWay: [],
      elements: [],
      templates: [],
      props: []
    };
  }
  constructor(element, options) {
    super(element, options);
    this._shouldRaiseContentReady = false;
    this.validateKeyDownHandler();
  }
  validateKeyDownHandler() {
    const supportedKeyNames = this.getSupportedKeyNames();
    const hasComponentDefaultKeyHandlers = supportedKeyNames.length > 0;
    const hasComponentKeyDownMethod = "function" === typeof this._viewComponent.prototype.keyDown;
    if (hasComponentDefaultKeyHandlers && !hasComponentKeyDownMethod) {
      throw Error("Component's declaration must have 'keyDown' method.");
    }
  }
  get viewRef() {
    var _this$_viewRef;
    return null === (_this$_viewRef = this._viewRef) || void 0 === _this$_viewRef ? void 0 : _this$_viewRef.current;
  }
  _checkContentReadyOption(fullName) {
    const contentReadyOptions = this._getContentReadyOptions().reduce((options, name2) => {
      options[name2] = true;
      return options;
    }, {});
    this._checkContentReadyOption = (optionName) => !!contentReadyOptions[optionName];
    return this._checkContentReadyOption(fullName);
  }
  _getContentReadyOptions() {
    return ["rtlEnabled"];
  }
  _fireContentReady() {
    this._actionsMap.onContentReady({});
  }
  _getDefaultOptions() {
    const viewDefaultProps = this._getViewComponentDefaultProps();
    return extend(true, super._getDefaultOptions(), viewDefaultProps, this._propsInfo.twoWay.reduce((options, _ref) => {
      let [name2, defaultName, eventName] = _ref;
      return _extends({}, options, {
        [name2]: viewDefaultProps[defaultName],
        [eventName]: (value2) => this.option(name2, value2)
      });
    }, {}), this._propsInfo.templates.reduce((options, name2) => _extends({}, options, {
      [name2]: null
    }), {}));
  }
  _getUnwrappedOption() {
    const unwrappedProps = {};
    Object.keys(this.option()).forEach((key) => {
      unwrappedProps[key] = this.option(key);
    });
    return unwrappedProps;
  }
  _initializeComponent() {
    var _this$_templateManage;
    super._initializeComponent();
    null === (_this$_templateManage = this._templateManager) || void 0 === _this$_templateManage || _this$_templateManage.addDefaultTemplates(this.getDefaultTemplates());
    const optionProxy = this._getUnwrappedOption();
    this._props = this._optionsWithDefaultTemplates(optionProxy);
    this._propsInfo.templates.forEach((template) => {
      this._componentTemplates[template] = this._createTemplateComponent(this._props[template]);
    });
    Object.keys(this._getActionConfigsFull()).forEach((name2) => this._addAction(name2));
    this._viewRef = createRef();
    this.defaultKeyHandlers = this._createDefaultKeyHandlers();
  }
  _initMarkup() {
    const props = this.getProps();
    this._renderWrapper(props);
  }
  _renderWrapper(props) {
    const containerNode = this.$element()[0];
    if (!this._isNodeReplaced) {
      inferno_renderer_default.onPreRender();
    }
    inferno_renderer_default.render(this._viewComponent, props, containerNode, this._isNodeReplaced);
    if (!this._isNodeReplaced) {
      this._isNodeReplaced = true;
      inferno_renderer_default.onAfterRender();
      this._shouldRaiseContentReady = true;
    }
    if (this._shouldRaiseContentReady) {
      this._fireContentReady();
      this._shouldRaiseContentReady = false;
    }
  }
  _silent(name2, value2) {
    this._options.silent(name2, value2);
  }
  _render() {
  }
  _removeWidget() {
    inferno_renderer_default.remove(this.$element()[0]);
  }
  _dispose() {
    this._removeWidget();
    super._dispose();
  }
  get elementAttr() {
    const element = this.$element()[0];
    if (!this._elementAttr) {
      const {
        attributes
      } = element;
      const attrs = Array.from(attributes).filter((attr) => {
        var _attributes$attr$name;
        return !this._propsInfo.templates.includes(attr.name) && (null === (_attributes$attr$name = attributes[attr.name]) || void 0 === _attributes$attr$name ? void 0 : _attributes$attr$name.specified);
      }).reduce((result, _ref2) => {
        let {
          name: name2,
          value: value2
        } = _ref2;
        const updatedAttributes = result;
        const isDomAttr = name2 in element;
        updatedAttributes[name2] = "" === value2 && isDomAttr ? element[name2] : value2;
        return updatedAttributes;
      }, {});
      this._elementAttr = attrs;
      this._storedClasses = element.getAttribute("class") || "";
    }
    const elemStyle = element.style;
    const style = {};
    for (let i = 0; i < elemStyle.length; i += 1) {
      style[elemStyle[i]] = elemStyle.getPropertyValue(elemStyle[i]);
    }
    this._elementAttr.style = style;
    this._elementAttr.class = this._storedClasses;
    return this._elementAttr;
  }
  _getAdditionalActionConfigs() {
    return {
      onContentReady: {
        excludeValidators: ["disabled", "readOnly"]
      }
    };
  }
  _getAdditionalProps() {
    return [];
  }
  _patchOptionValues(options) {
    const {
      allowNull,
      twoWay,
      elements,
      props
    } = this._propsInfo;
    const viewDefaultProps = this._getViewComponentDefaultProps();
    const defaultWidgetPropsKeys = Object.keys(viewDefaultProps);
    const defaultOptions = this._getDefaultOptions();
    const {
      ref,
      children,
      onKeyboardHandled
    } = options;
    const onKeyDown = onKeyboardHandled ? (_, event_options) => {
      onKeyboardHandled(event_options);
    } : void 0;
    const widgetProps = {
      ref,
      children,
      onKeyDown
    };
    [...props, ...this._getAdditionalProps()].forEach((propName) => {
      if (Object.prototype.hasOwnProperty.call(options, propName)) {
        widgetProps[propName] = options[propName];
      }
    });
    allowNull.forEach(setDefaultOptionValue(widgetProps, () => null));
    defaultWidgetPropsKeys.forEach(setDefaultOptionValue(widgetProps, (name2) => defaultOptions[name2]));
    twoWay.forEach((_ref3) => {
      let [name2, defaultName] = _ref3;
      setDefaultOptionValue(widgetProps, () => defaultOptions[defaultName])(name2);
    });
    elements.forEach((name2) => {
      if (name2 in widgetProps) {
        const value2 = widgetProps[name2];
        if (isRenderer(value2)) {
          widgetProps[name2] = this._patchElementParam(value2);
        }
      }
    });
    return widgetProps;
  }
  getSupportedKeyNames() {
    return [];
  }
  prepareStyleProp(props) {
    if ("string" === typeof props.style) {
      return _extends({}, props, {
        style: {},
        cssText: props.style
      });
    }
    return props;
  }
  getProps() {
    const {
      elementAttr
    } = this.option();
    const options = this._patchOptionValues(_extends({}, this._props, {
      ref: this._viewRef,
      children: this._extractDefaultSlot(),
      aria: this._aria
    }));
    this._propsInfo.templates.forEach((template) => {
      options[template] = this._componentTemplates[template];
    });
    return this.prepareStyleProp(_extends({}, options, this.elementAttr, elementAttr, {
      className: [...(this.elementAttr.class ?? "").split(" "), ...((null === elementAttr || void 0 === elementAttr ? void 0 : elementAttr.class) ?? "").split(" ")].filter((c, i, a) => c && a.indexOf(c) === i).join(" ").trim(),
      class: ""
    }, this._actionsMap));
  }
  _getActionConfigs() {
    return {};
  }
  _getActionConfigsFull() {
    return _extends({}, this._getActionConfigs(), this._getAdditionalActionConfigs());
  }
  getDefaultTemplates() {
    const defaultTemplates = Object.values(this._templatesInfo);
    const result = {};
    defaultTemplates.forEach((template) => {
      result[template] = "dx-renovation-template-mock";
    });
    return result;
  }
  get _templatesInfo() {
    return {};
  }
  _optionsWithDefaultTemplates(options) {
    const templateOptions = Object.entries(this._templatesInfo).reduce((result, _ref4) => {
      let [templateName, templateValue] = _ref4;
      return _extends({}, result, {
        [templateName]: options[templateName] ?? templateValue
      });
    }, {});
    return _extends({}, options, templateOptions);
  }
  _init() {
    super._init();
    this.customKeyHandlers = {};
    this._actionsMap = {};
    this._aria = {};
    this._componentTemplates = {};
  }
  _createDefaultKeyHandlers() {
    const result = {};
    const keys = this.getSupportedKeyNames();
    keys.forEach((key) => {
      result[key] = (e) => this.viewRef.keyDown(keyboard_processor_default.createKeyDownOptions(e));
    });
    return result;
  }
  _addAction(event, actionToAdd) {
    let action = actionToAdd;
    if (!action) {
      const actionByOption = this._createActionByOption(event, this._getActionConfigsFull()[event]);
      action = (actArgs) => {
        Object.keys(actArgs).forEach((name2) => {
          if (isDefined(actArgs[name2]) && dom_adapter_default.isNode(actArgs[name2])) {
            actArgs[name2] = getPublicElement(renderer_default(actArgs[name2]));
          }
        });
        return actionByOption(actArgs);
      };
    }
    this._actionsMap[event] = action;
  }
  _optionChanged(option) {
    const {
      name: name2,
      fullName,
      value: value2,
      previousValue
    } = option;
    updatePropsImmutable(this._props, this.option(), name2, fullName);
    if (this._propsInfo.templates.includes(name2) && value2 !== previousValue) {
      this._componentTemplates[name2] = this._createTemplateComponent(value2);
    }
    if (name2 && this._getActionConfigsFull()[name2]) {
      this._addAction(name2);
    }
    this._shouldRaiseContentReady = this._shouldRaiseContentReady || this._checkContentReadyOption(fullName);
    super._optionChanged(option);
    this._invalidate();
  }
  _extractDefaultSlot() {
    if (this.option("_hasAnonymousTemplateContent")) {
      return inferno_renderer_default.createElement(TemplateWrapper, {
        template: this._getTemplate(this._templateManager.anonymousTemplateName),
        transclude: true,
        renovated: true
      });
    }
    return null;
  }
  _createTemplateComponent(templateOption) {
    if (!templateOption) {
      return;
    }
    const template = this._getTemplate(templateOption);
    if (isString(template) && "dx-renovation-template-mock" === template) {
      return;
    }
    return (model) => inferno_renderer_default.createElement(TemplateWrapper, buildTemplateArgs(model, template));
  }
  _wrapKeyDownHandler(initialHandler) {
    return (options) => {
      const {
        originalEvent,
        keyName,
        which
      } = options;
      const keys = this.customKeyHandlers;
      const func = keys[keyName] || keys[which];
      if (void 0 !== func) {
        const handler = func.bind(this);
        const result = handler(originalEvent, options);
        if (!result) {
          originalEvent.cancel = true;
          return originalEvent;
        }
      }
      return null === initialHandler || void 0 === initialHandler ? void 0 : initialHandler(originalEvent, options);
    };
  }
  _toPublicElement(element) {
    return getPublicElement(renderer_default(element));
  }
  _patchElementParam(value2) {
    try {
      const result = renderer_default(value2);
      const element = null === result || void 0 === result ? void 0 : result.get(0);
      return null !== element && void 0 !== element && element.nodeType ? element : value2;
    } catch (error) {
      return value2;
    }
  }
  repaint() {
    this._isNodeReplaced = false;
    this._shouldRaiseContentReady = true;
    this._removeWidget();
    this._refresh();
  }
  _supportedKeys() {
    return _extends({}, this.defaultKeyHandlers, this.customKeyHandlers);
  }
  registerKeyHandler(key, handler) {
    this.customKeyHandlers[key] = handler;
  }
  setAria(name2, value2) {
    this._aria[name2] = value2;
    this._initMarkup();
  }
  _getViewComponentDefaultProps() {
    return this._viewComponent.defaultProps || {};
  }
};
ComponentWrapper.IS_RENOVATED_WIDGET = false;
ComponentWrapper.IS_RENOVATED_WIDGET = true;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/all_day_panel_title.js
var AllDayPanelTitle = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const text = message_default.format("dxScheduler-allDay");
    return createVNode(1, "div", "dx-scheduler-all-day-title", text, 0);
  }
};
AllDayPanelTitle.defaultProps = {};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/all_day_panel_title.js
var AllDayPanelTitleComponent = class extends ComponentWrapper {
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: [],
      props: []
    };
  }
  get _viewComponent() {
    return AllDayPanelTitle;
  }
};
component_registrator_default("dxAllDayPanelTitle", AllDayPanelTitleComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/const.js
var DefaultSizes = {
  allDayPanelHeight: 25
};
var DATE_TABLE_CELL_CLASS = "dx-scheduler-date-table-cell";
var DATE_TABLE_ROW_CLASS2 = "dx-scheduler-date-table-row";
var ALL_DAY_PANEL_CELL_CLASS = "dx-scheduler-all-day-table-cell";

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/cell.js
var CellBaseDefaultProps = {
  className: "",
  isFirstGroupCell: false,
  isLastGroupCell: false,
  startDate: /* @__PURE__ */ new Date(),
  endDate: /* @__PURE__ */ new Date(),
  allDay: false,
  text: "",
  index: 0,
  contentTemplateProps: {
    data: {},
    index: 0
  }
};
var CellBase = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      isFirstGroupCell,
      isLastGroupCell,
      children,
      ariaLabel
    } = this.props;
    const classes = renderUtils.getGroupCellClasses(isFirstGroupCell, isLastGroupCell, className);
    return createVNode(1, "td", classes, children, 0, {
      "aria-label": ariaLabel
    });
  }
};
CellBase.defaultProps = CellBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_table_cell_base.js
var DateTableCallBaseDefaultProps = _extends({}, CellBaseDefaultProps, {
  otherMonth: false,
  today: false,
  firstDayOfMonth: false,
  isSelected: false,
  isFocused: false
});
var DateTableCellBase = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.dataCellTemplateProps = null;
  }
  getDataCellTemplateProps() {
    if (null !== this.dataCellTemplateProps) {
      return this.dataCellTemplateProps;
    }
    const {
      allDay,
      contentTemplateProps,
      endDate,
      groupIndex,
      groups,
      index,
      startDate
    } = this.props;
    this.dataCellTemplateProps = {
      data: _extends({
        startDate,
        endDate,
        groups,
        groupIndex: groups ? groupIndex : void 0,
        text: "",
        allDay: !!allDay || void 0
      }, null === contentTemplateProps || void 0 === contentTemplateProps ? void 0 : contentTemplateProps.data),
      index
    };
    return this.dataCellTemplateProps;
  }
  componentWillUpdate(nextProps) {
    if (this.props.allDay !== nextProps.allDay || this.props.contentTemplateProps !== nextProps.contentTemplateProps || this.props.endDate !== nextProps.endDate || this.props.groupIndex !== nextProps.groupIndex || this.props.groups !== nextProps.groups || this.props.index !== nextProps.index || this.props.startDate !== nextProps.startDate) {
      this.dataCellTemplateProps = null;
    }
  }
  render() {
    const {
      viewContext,
      allDay,
      className,
      isFocused,
      isSelected,
      isFirstGroupCell,
      isLastGroupCell,
      dataCellTemplate,
      children
    } = this.props;
    const {
      view: {
        type: viewType
      },
      crossScrollingEnabled
    } = viewContext;
    const cellSizeHorizontalClass = renderUtils.getCellSizeHorizontalClass(viewType, crossScrollingEnabled);
    const cellSizeVerticalClass = renderUtils.getCellSizeVerticalClass(!!allDay);
    const classes = renderUtils.combineClasses({
      [cellSizeHorizontalClass]: true,
      [cellSizeVerticalClass]: true,
      [DATE_TABLE_CELL_CLASS]: !allDay,
      "dx-state-focused": isSelected,
      "dx-scheduler-focused-cell": isFocused,
      [className ?? ""]: true
    });
    const ariaLabel = isSelected ? "Add appointment" : void 0;
    const dataCellTemplateProps = this.getDataCellTemplateProps();
    const DataCellTemplateComponent = getTemplate(dataCellTemplate);
    return createComponentVNode(2, CellBase, {
      className: classes,
      viewContext,
      isFirstGroupCell,
      isLastGroupCell,
      ariaLabel,
      startDate: CellBaseDefaultProps.startDate,
      endDate: CellBaseDefaultProps.endDate,
      index: CellBaseDefaultProps.index,
      children: createFragment([!DataCellTemplateComponent && children, !!DataCellTemplateComponent && DataCellTemplateComponent({
        index: dataCellTemplateProps.index,
        data: dataCellTemplateProps.data
      })], 0)
    });
  }
};
DateTableCellBase.defaultProps = DateTableCallBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/all_day_panel_cell.js
var AllDayPanelCell = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      viewContext,
      dataCellTemplate,
      endDate,
      groupIndex,
      groups,
      index,
      isFirstGroupCell,
      isFocused,
      isLastGroupCell,
      isSelected,
      startDate
    } = this.props;
    const DataCellTemplateComponent = getTemplate(dataCellTemplate);
    return createComponentVNode(2, DateTableCellBase, {
      className: `${ALL_DAY_PANEL_CELL_CLASS} ${className}`,
      viewContext,
      startDate,
      endDate,
      groups,
      groupIndex,
      allDay: true,
      isFirstGroupCell,
      isLastGroupCell,
      index,
      dataCellTemplate: DataCellTemplateComponent,
      isSelected,
      isFocused
    });
  }
};
AllDayPanelCell.defaultProps = DateTableCallBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/ordinary_cell.js
var OrdinaryCellDefaultProps = {};
var OrdinaryCell = class extends BaseInfernoComponent {
  render() {
    const {
      children,
      className,
      colSpan,
      styles
    } = this.props;
    return createVNode(1, "td", className, children, 0, {
      style: normalizeStyles(styles),
      colSpan
    });
  }
};
OrdinaryCell.defaultProps = OrdinaryCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/header_cell.js
var HeaderCell = class extends BaseInfernoComponent {
  render() {
    const {
      children,
      className,
      colSpan,
      styles
    } = this.props;
    return createVNode(1, "th", className, children, 0, {
      style: normalizeStyles(styles),
      colSpan
    });
  }
};
HeaderCell.defaultProps = OrdinaryCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/virtual_cell.js
var VirtualCellDefaultProps = {
  width: 0,
  isHeaderCell: false
};
var VirtualCell = class extends BaseInfernoComponent {
  render() {
    const {
      colSpan,
      isHeaderCell,
      width,
      styles
    } = this.props;
    const modifiedStyles = renderUtils.addWidthToStyle(width, styles);
    const Cell = isHeaderCell ? HeaderCell : OrdinaryCell;
    return createComponentVNode(2, Cell, {
      className: "dx-scheduler-virtual-cell",
      styles: modifiedStyles,
      colSpan
    });
  }
};
VirtualCell.defaultProps = VirtualCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/row.js
var RowDefaultProps = {
  className: "",
  leftVirtualCellWidth: 0,
  rightVirtualCellWidth: 0,
  isHeaderRow: false
};
var Row = class extends BaseInfernoComponent {
  render() {
    const {
      children,
      className,
      isHeaderRow,
      leftVirtualCellCount,
      leftVirtualCellWidth,
      rightVirtualCellCount,
      rightVirtualCellWidth,
      styles
    } = this.props;
    const hasLeftVirtualCell = !!leftVirtualCellCount;
    const hasRightVirtualCell = !!rightVirtualCellCount;
    return createVNode(1, "tr", className, [hasLeftVirtualCell && null != leftVirtualCellCount && splitNumber(leftVirtualCellCount, 1e3).map((colSpan, index) => createComponentVNode(2, VirtualCell, {
      className: `left-virtual-cell-${index}`,
      width: leftVirtualCellWidth * (colSpan / leftVirtualCellCount),
      colSpan,
      isHeaderCell: isHeaderRow ?? VirtualCellDefaultProps.isHeaderCell
    })), children, hasRightVirtualCell && null != rightVirtualCellCount && splitNumber(rightVirtualCellCount, 1e3).map((colSpan, index) => createComponentVNode(2, VirtualCell, {
      className: `right-virtual-cell-${index}`,
      width: rightVirtualCellWidth * (colSpan / rightVirtualCellCount),
      colSpan,
      isHeaderCell: isHeaderRow ?? VirtualCellDefaultProps.isHeaderCell
    }))], 0, {
      style: normalizeStyles(styles)
    });
  }
};
Row.defaultProps = RowDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/all_day_panel_table_body.js
var AllDayPanelTableBodyDefaultProps = {
  viewData: [],
  isVerticalGroupOrientation: false,
  className: "",
  leftVirtualCellWidth: 0,
  rightVirtualCellWidth: 0
};
var AllDayPanelTableBody = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      viewData,
      viewContext,
      leftVirtualCellWidth,
      rightVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellCount,
      isVerticalGroupOrientation,
      dataCellTemplate
    } = this.props;
    const classes = renderUtils.combineClasses({
      "dx-scheduler-all-day-table-row": true,
      [className ?? ""]: !!className
    });
    const DataCellTemplateComponent = getTemplate(dataCellTemplate);
    return createComponentVNode(2, Row, {
      leftVirtualCellWidth,
      rightVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellCount,
      className: classes,
      children: viewData.map((_ref) => {
        let {
          endDate,
          groupIndex: cellGroupIndex,
          groups,
          index: cellIndex,
          isFirstGroupCell,
          isFocused,
          isLastGroupCell,
          isSelected,
          key,
          startDate
        } = _ref;
        return createComponentVNode(2, AllDayPanelCell, {
          viewContext,
          isFirstGroupCell: !isVerticalGroupOrientation && isFirstGroupCell,
          isLastGroupCell: !isVerticalGroupOrientation && isLastGroupCell,
          startDate,
          endDate,
          groups,
          groupIndex: cellGroupIndex,
          index: cellIndex,
          dataCellTemplate: DataCellTemplateComponent,
          isSelected: isSelected ?? false,
          isFocused: isFocused ?? false
        }, key);
      })
    });
  }
};
AllDayPanelTableBody.defaultProps = AllDayPanelTableBodyDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/layout_props.js
var LayoutDefaultProps = {
  viewData: {
    groupedData: [],
    leftVirtualCellCount: 0,
    rightVirtualCellCount: 0,
    topVirtualRowCount: 0,
    bottomVirtualRowCount: 0
  },
  leftVirtualCellWidth: 0,
  rightVirtualCellWidth: 0,
  topVirtualRowHeight: 0,
  bottomVirtualRowHeight: 0,
  addDateTableClass: true,
  addVerticalSizesClassToRows: true
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/virtual_row.js
var VirtualRowDefaultProps = _extends({}, RowDefaultProps, {
  leftVirtualCellWidth: 0,
  rightVirtualCellWidth: 0,
  cellsCount: 1
});
var VirtualRow = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.virtualCells = null;
  }
  getVirtualCells() {
    if (null !== this.virtualCells) {
      return this.virtualCells;
    }
    const {
      cellsCount
    } = this.props;
    this.virtualCells = [...Array(cellsCount)];
    return this.virtualCells;
  }
  componentWillUpdate(nextProps) {
    if (this.props.cellsCount !== nextProps.cellsCount) {
      this.virtualCells = null;
    }
  }
  render() {
    const {
      className,
      leftVirtualCellCount,
      leftVirtualCellWidth,
      rightVirtualCellCount,
      rightVirtualCellWidth,
      styles,
      height
    } = this.props;
    const classes = `dx-scheduler-virtual-row ${className}`;
    const modifiedStyles = renderUtils.addHeightToStyle(height, styles);
    const virtualCells = this.getVirtualCells();
    return createComponentVNode(2, Row, {
      className: classes,
      styles: modifiedStyles,
      leftVirtualCellWidth,
      rightVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellCount,
      children: virtualCells.map((_, index) => createComponentVNode(2, VirtualCell, {
        width: VirtualCellDefaultProps.width,
        isHeaderCell: VirtualCellDefaultProps.isHeaderCell
      }, index.toString()))
    });
  }
};
VirtualRow.defaultProps = VirtualRowDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/table.js
var TableDefaultProps = {
  topVirtualRowHeight: 0,
  bottomVirtualRowHeight: 0,
  leftVirtualCellWidth: 0,
  rightVirtualCellWidth: 0,
  virtualCellsCount: 0
};
var Table = class extends BaseInfernoComponent {
  getResultStyles() {
    const {
      height,
      width,
      styles
    } = this.props;
    const heightAdded = renderUtils.addHeightToStyle(height, styles);
    return renderUtils.addWidthToStyle(width, heightAdded);
  }
  render() {
    const {
      className,
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      children,
      leftVirtualCellCount,
      leftVirtualCellWidth,
      rightVirtualCellCount,
      rightVirtualCellWidth,
      tableRef,
      virtualCellsCount
    } = this.props;
    const hasTopVirtualRow = !!topVirtualRowHeight;
    const hasBottomVirtualRow = !!bottomVirtualRowHeight;
    const resultStyles = this.getResultStyles();
    return createVNode(1, "table", className, createVNode(1, "tbody", null, [hasTopVirtualRow && createComponentVNode(2, VirtualRow, {
      height: topVirtualRowHeight,
      cellsCount: virtualCellsCount ?? VirtualRowDefaultProps.cellsCount,
      leftVirtualCellWidth: leftVirtualCellWidth ?? VirtualRowDefaultProps.leftVirtualCellWidth,
      rightVirtualCellWidth: rightVirtualCellWidth ?? VirtualRowDefaultProps.rightVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellCount
    }), children, hasBottomVirtualRow && createComponentVNode(2, VirtualRow, {
      height: bottomVirtualRowHeight,
      cellsCount: virtualCellsCount ?? VirtualRowDefaultProps.cellsCount,
      leftVirtualCellWidth: leftVirtualCellWidth ?? VirtualRowDefaultProps.leftVirtualCellWidth,
      rightVirtualCellWidth: rightVirtualCellWidth ?? VirtualRowDefaultProps.rightVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellCount
    })], 0), 2, {
      style: normalizeStyles(resultStyles)
    }, null, tableRef);
  }
};
Table.defaultProps = TableDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/all_day_panel_table.js
var AllDayTable = class extends InfernoWrapperComponent {
  constructor() {
    super(...arguments);
    this.allDayPanelData = null;
  }
  createEffects() {
    return [createReRenderEffect()];
  }
  getAllDayPanelData() {
    if (null !== this.allDayPanelData) {
      return this.allDayPanelData;
    }
    this.allDayPanelData = this.props.viewData.groupedData[0].allDayPanel;
    return this.allDayPanelData;
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.viewData !== nextProps.viewData) {
      this.allDayPanelData = null;
    }
  }
  render() {
    const {
      viewData,
      viewContext,
      width,
      tableRef,
      dataCellTemplate
    } = this.props;
    const allDayPanelData = this.getAllDayPanelData();
    const DataCellTemplateComponent = getTemplate(dataCellTemplate);
    return createComponentVNode(2, Table, {
      className: "dx-scheduler-all-day-table",
      height: allDayPanelData ? void 0 : DefaultSizes.allDayPanelHeight,
      width,
      tableRef,
      children: createComponentVNode(2, AllDayPanelTableBody, {
        viewData: allDayPanelData ?? AllDayPanelTableBodyDefaultProps.viewData,
        viewContext,
        leftVirtualCellWidth: viewData.leftVirtualCellWidth ?? AllDayPanelTableBodyDefaultProps.leftVirtualCellWidth,
        rightVirtualCellWidth: viewData.rightVirtualCellWidth ?? AllDayPanelTableBodyDefaultProps.rightVirtualCellWidth,
        leftVirtualCellCount: viewData.leftVirtualCellCount,
        rightVirtualCellCount: viewData.rightVirtualCellCount,
        dataCellTemplate: DataCellTemplateComponent
      })
    });
  }
};
AllDayTable.defaultProps = LayoutDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_table_body.js
var DateTableBodyDefaultProps = _extends({}, LayoutDefaultProps, {
  cellTemplate: DateTableCellBase
});
var DateTableBody = class extends BaseInfernoComponent {
  render() {
    const {
      viewData,
      viewContext,
      addVerticalSizesClassToRows,
      cellTemplate,
      dataCellTemplate
    } = this.props;
    const rowClasses = renderUtils.combineClasses({
      [DATE_TABLE_ROW_CLASS2]: true,
      "dx-scheduler-cell-sizes-vertical": addVerticalSizesClassToRows
    });
    const CellTemplateComponent = getTemplate(cellTemplate);
    const DataCellTemplateComponent = getTemplate(dataCellTemplate);
    return createFragment(viewData.groupedData.map((_ref) => {
      let {
        allDayPanel,
        dateTable,
        isGroupedAllDayPanel,
        key: fragmentKey
      } = _ref;
      return createFragment([isGroupedAllDayPanel && createComponentVNode(2, AllDayPanelTableBody, {
        viewData: allDayPanel ?? AllDayPanelTableBodyDefaultProps.viewData,
        viewContext,
        dataCellTemplate: DataCellTemplateComponent,
        isVerticalGroupOrientation: true,
        leftVirtualCellWidth: viewData.leftVirtualCellWidth ?? AllDayPanelTableBodyDefaultProps.leftVirtualCellWidth,
        rightVirtualCellWidth: viewData.rightVirtualCellWidth ?? AllDayPanelTableBodyDefaultProps.rightVirtualCellWidth,
        leftVirtualCellCount: viewData.leftVirtualCellCount,
        rightVirtualCellCount: viewData.rightVirtualCellCount
      }), dateTable.map((_ref2) => {
        let {
          cells,
          key: rowKey
        } = _ref2;
        return createComponentVNode(2, Row, {
          className: rowClasses,
          leftVirtualCellWidth: viewData.leftVirtualCellWidth ?? RowDefaultProps.leftVirtualCellWidth,
          rightVirtualCellWidth: viewData.rightVirtualCellWidth ?? RowDefaultProps.rightVirtualCellWidth,
          leftVirtualCellCount: viewData.leftVirtualCellCount,
          rightVirtualCellCount: viewData.rightVirtualCellCount,
          children: cells.map((_ref3) => {
            let {
              key: cellKey,
              endDate,
              firstDayOfMonth,
              groupIndex: cellGroupIndex,
              groups,
              index: cellIndex,
              isFirstGroupCell,
              isFocused,
              isLastGroupCell,
              isSelected,
              otherMonth,
              startDate,
              text,
              today
            } = _ref3;
            return CellTemplateComponent({
              key: cellKey,
              viewContext,
              isFirstGroupCell,
              isLastGroupCell,
              startDate,
              endDate,
              groups,
              groupIndex: cellGroupIndex,
              index: cellIndex,
              dataCellTemplate: DataCellTemplateComponent,
              text,
              today,
              otherMonth,
              firstDayOfMonth,
              isSelected,
              isFocused
            });
          })
        }, rowKey);
      })], 0, fragmentKey);
    }), 0);
  }
};
DateTableBody.defaultProps = DateTableBodyDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_table.js
var _excluded3 = ["viewData", "viewContext", "tableRef", "addDateTableClass", "width", "cellTemplate", "dataCellTemplate", "groupOrientation", "addVerticalSizesClassToRows"];
var DateTableDefaultProps = _extends({}, LayoutDefaultProps, {
  cellTemplate: DateTableCellBase
});
var DateTable = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const _this$props = this.props, {
      viewData,
      viewContext,
      tableRef,
      addDateTableClass,
      width,
      cellTemplate,
      dataCellTemplate,
      groupOrientation,
      addVerticalSizesClassToRows
    } = _this$props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded3);
    const classes = addDateTableClass ? "dx-scheduler-date-table" : void 0;
    const topVirtualRowHeight = viewData.topVirtualRowHeight ?? 0;
    const bottomVirtualRowHeight = viewData.bottomVirtualRowHeight ?? 0;
    const leftVirtualCellWidth = viewData.leftVirtualCellWidth ?? 0;
    const rightVirtualCellWidth = viewData.rightVirtualCellWidth ?? 0;
    const virtualCellsCount = viewData.groupedData[0].dateTable[0].cells.length;
    const CellTemplateComponent = getTemplate(cellTemplate);
    const DataCellTemplateComponent = getTemplate(dataCellTemplate);
    return normalizeProps(createComponentVNode(2, Table, _extends({}, restProps, {
      tableRef,
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      leftVirtualCellWidth,
      rightVirtualCellWidth,
      leftVirtualCellCount: viewData.leftVirtualCellCount,
      rightVirtualCellCount: viewData.rightVirtualCellCount,
      virtualCellsCount,
      className: classes,
      width,
      children: createComponentVNode(2, DateTableBody, {
        viewData,
        viewContext,
        cellTemplate: CellTemplateComponent,
        dataCellTemplate: DataCellTemplateComponent,
        leftVirtualCellWidth,
        rightVirtualCellWidth,
        groupOrientation,
        addVerticalSizesClassToRows,
        topVirtualRowHeight: DateTableBodyDefaultProps.topVirtualRowHeight,
        bottomVirtualRowHeight: DateTableBodyDefaultProps.bottomVirtualRowHeight,
        addDateTableClass: DateTableBodyDefaultProps.addDateTableClass
      })
    })));
  }
};
DateTable.defaultProps = DateTableDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/date_table.js
var DateTableComponent = class extends ComponentWrapper {
  _setOptionsByReference() {
    super._setOptionsByReference();
    this._optionsByReference = _extends({}, this._optionsByReference, {
      dataCellTemplate: true
    });
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["cellTemplate", "dataCellTemplate"],
      props: ["viewData", "viewContext", "cellTemplate", "groupOrientation", "leftVirtualCellWidth", "rightVirtualCellWidth", "topVirtualRowHeight", "bottomVirtualRowHeight", "addDateTableClass", "addVerticalSizesClassToRows", "width", "dataCellTemplate"]
    };
  }
  get _viewComponent() {
    return DateTable;
  }
};
component_registrator_default("dxDateTableLayoutBase", DateTableComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/all_day_table.js
var AllDayTableComponent = class extends DateTableComponent {
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["dataCellTemplate"],
      props: ["viewData", "viewContext", "groupOrientation", "leftVirtualCellWidth", "rightVirtualCellWidth", "topVirtualRowHeight", "bottomVirtualRowHeight", "addDateTableClass", "addVerticalSizesClassToRows", "width", "dataCellTemplate"]
    };
  }
  get _viewComponent() {
    return AllDayTable;
  }
};
component_registrator_default("dxAllDayTable", AllDayTableComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/month/date_table_month_cell.js
var DateTableMonthCell = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.contentTemplateProps = null;
  }
  getContentTemplateProps() {
    if (null !== this.contentTemplateProps) {
      return this.contentTemplateProps;
    }
    const {
      index,
      text
    } = this.props;
    this.contentTemplateProps = {
      data: {
        text
      },
      index
    };
    return this.contentTemplateProps;
  }
  componentWillUpdate(nextProps) {
    if (this.props.index !== nextProps.index || this.props.text !== nextProps.text) {
      this.contentTemplateProps = null;
    }
  }
  render() {
    const {
      viewContext,
      dataCellTemplate,
      endDate,
      groupIndex,
      groups,
      index,
      isFirstGroupCell,
      isFocused,
      isLastGroupCell,
      isSelected,
      startDate,
      text,
      className,
      firstDayOfMonth,
      otherMonth,
      today
    } = this.props;
    const classes = renderUtils.combineClasses({
      "dx-scheduler-date-table-other-month": !!otherMonth,
      "dx-scheduler-date-table-current-date": !!today,
      "dx-scheduler-date-table-first-of-month": !!firstDayOfMonth,
      [className ?? ""]: !!className
    });
    const contentTemplateProps = this.getContentTemplateProps();
    const DataCellTemplateComponent = getTemplate(dataCellTemplate);
    return createComponentVNode(2, DateTableCellBase, {
      className: classes,
      viewContext,
      dataCellTemplate: DataCellTemplateComponent,
      startDate,
      endDate,
      text,
      groups,
      groupIndex,
      index,
      isFirstGroupCell,
      isLastGroupCell,
      isSelected,
      isFocused,
      contentTemplateProps,
      children: createVNode(1, "div", "dx-scheduler-date-table-cell-text", text, 0)
    });
  }
};
DateTableMonthCell.defaultProps = DateTableCallBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/month/date_table_month.js
var _excluded4 = ["viewData", "viewContext", "addDateTableClass", "addVerticalSizesClassToRows", "dataCellTemplate", "groupOrientation", "tableRef", "width"];
var DateTableMonth = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const _this$props = this.props, {
      viewData,
      viewContext,
      addDateTableClass,
      addVerticalSizesClassToRows,
      dataCellTemplate,
      groupOrientation,
      tableRef,
      width
    } = _this$props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded4);
    const DataCellTemplateComponent = getTemplate(dataCellTemplate);
    return normalizeProps(createComponentVNode(2, DateTable, _extends({}, restProps, {
      viewData,
      viewContext,
      groupOrientation,
      addDateTableClass,
      dataCellTemplate: DataCellTemplateComponent,
      cellTemplate: DateTableMonthCell,
      tableRef,
      addVerticalSizesClassToRows,
      width
    })));
  }
};
DateTableMonth.defaultProps = DateTableDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/date_table_month.js
var DateTableMonthComponent = class extends DateTableComponent {
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["cellTemplate", "dataCellTemplate"],
      props: ["viewData", "viewContext", "cellTemplate", "groupOrientation", "leftVirtualCellWidth", "rightVirtualCellWidth", "topVirtualRowHeight", "bottomVirtualRowHeight", "addDateTableClass", "addVerticalSizesClassToRows", "width", "dataCellTemplate"]
    };
  }
  get _viewComponent() {
    return DateTableMonth;
  }
};
component_registrator_default("dxMonthDateTableLayout", DateTableMonthComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_props.js
var GroupPanelBaseDefaultProps = {
  groupPanelData: {
    groupPanelItems: [],
    baseColSpan: 1
  },
  groupByDate: false,
  styles: {}
};
var GroupPanelCellDefaultProps = {
  id: 0,
  text: "",
  data: {
    id: 0
  },
  className: ""
};
var GroupPanelRowDefaultProps = {
  groupItems: [],
  className: ""
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_horizontal_cell.js
var GroupPanelHorizontalCellDefaultProps = _extends({}, GroupPanelCellDefaultProps, {
  isFirstGroupCell: false,
  isLastGroupCell: false,
  colSpan: 1
});
var GroupPanelHorizontalCell = class extends BaseInfernoComponent {
  render() {
    const {
      cellTemplate,
      colSpan,
      color,
      data: data2,
      id,
      index,
      text,
      className,
      isFirstGroupCell,
      isLastGroupCell
    } = this.props;
    const classes = renderUtils.combineClasses({
      "dx-scheduler-group-header": true,
      "dx-scheduler-first-group-cell": isFirstGroupCell,
      "dx-scheduler-last-group-cell": isLastGroupCell,
      [className ?? ""]: !!className
    });
    const CellTemplateComponent = getTemplate(cellTemplate);
    return createVNode(1, "th", classes, createVNode(1, "div", "dx-scheduler-group-header-content", CellTemplateComponent ? CellTemplateComponent({
      data: {
        data: data2,
        id,
        color,
        text
      },
      index
    }) : createVNode(1, "div", null, text, 0), 0), 2, {
      colSpan
    });
  }
};
GroupPanelHorizontalCell.defaultProps = GroupPanelHorizontalCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_horizontal_row.js
var GroupPanelHorizontalRow = class extends BaseInfernoComponent {
  render() {
    const {
      cellTemplate,
      className,
      groupItems
    } = this.props;
    const CellTemplateComponent = getTemplate(cellTemplate);
    return createVNode(1, "tr", `dx-scheduler-group-row ${className}`, groupItems.map((_ref, index) => {
      let {
        colSpan,
        color,
        data: data2,
        id,
        isFirstGroupCell,
        isLastGroupCell,
        key,
        text
      } = _ref;
      return createComponentVNode(2, GroupPanelHorizontalCell, {
        text,
        id,
        data: data2,
        index,
        color,
        colSpan: colSpan ?? GroupPanelHorizontalCellDefaultProps.colSpan,
        isFirstGroupCell: !!isFirstGroupCell,
        isLastGroupCell: !!isLastGroupCell,
        cellTemplate: CellTemplateComponent
      }, key);
    }), 0);
  }
};
GroupPanelHorizontalRow.defaultProps = GroupPanelRowDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_horizontal.js
var GroupPanelHorizontal = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this._groupPanelItems = null;
  }
  getGroupPanelItems() {
    if (null !== this._groupPanelItems) {
      return this._groupPanelItems;
    }
    const {
      groupPanelData: {
        baseColSpan,
        groupPanelItems
      }
    } = this.props;
    const colSpans = groupPanelItems.reduceRight((currentColSpans, groupsRow, idx) => {
      const nextColSpans = currentColSpans;
      const currentLevelGroupCount = groupsRow.length;
      const previousColSpan = idx === groupPanelItems.length - 1 ? baseColSpan : currentColSpans[idx + 1];
      const previousLevelGroupCount = idx === groupPanelItems.length - 1 ? currentLevelGroupCount : groupPanelItems[idx + 1].length;
      const groupCountDiff = previousLevelGroupCount / currentLevelGroupCount;
      nextColSpans[idx] = groupCountDiff * previousColSpan;
      return nextColSpans;
    }, [...new Array(groupPanelItems.length)]);
    this._groupPanelItems = groupPanelItems.map((groupsRenderRow, index) => {
      const colSpan = colSpans[index];
      return groupsRenderRow.map((groupItem) => _extends({}, groupItem, {
        colSpan
      }));
    });
    return this._groupPanelItems;
  }
  componentWillUpdate(nextProps) {
    if (this.props.groupPanelData !== nextProps.groupPanelData) {
      this._groupPanelItems = null;
    }
  }
  render() {
    const {
      resourceCellTemplate
    } = this.props;
    const groupPanelItems = this.getGroupPanelItems();
    const ResourceCellTemplateComponent = getTemplate(resourceCellTemplate);
    return createFragment(groupPanelItems.map((group) => createComponentVNode(2, GroupPanelHorizontalRow, {
      groupItems: group,
      cellTemplate: ResourceCellTemplateComponent
    }, group[0].key)), 0);
  }
};
GroupPanelHorizontal.defaultProps = GroupPanelBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_vertical_cell.js
var GroupPanelVerticalCell = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      data: data2,
      id,
      color,
      text,
      index,
      cellTemplate
    } = this.props;
    const CellTemplateComponent = getTemplate(cellTemplate);
    return createVNode(1, "div", `dx-scheduler-group-header ${className}`, CellTemplateComponent ? CellTemplateComponent({
      data: {
        data: data2,
        id,
        color,
        text
      },
      index
    }) : createVNode(1, "div", "dx-scheduler-group-header-content", text, 0), 0);
  }
};
GroupPanelVerticalCell.defaultProps = GroupPanelCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_vertical_row.js
var GroupPanelVerticalRow = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      groupItems,
      cellTemplate
    } = this.props;
    const CellTemplateComponent = getTemplate(cellTemplate);
    return createVNode(1, "div", `dx-scheduler-group-row ${className}`, groupItems.map((_ref, index) => {
      let {
        color,
        data: data2,
        id,
        key,
        text
      } = _ref;
      return createComponentVNode(2, GroupPanelVerticalCell, {
        text,
        id,
        data: data2,
        index,
        color,
        cellTemplate: CellTemplateComponent
      }, key);
    }), 0);
  }
};
GroupPanelVerticalRow.defaultProps = GroupPanelRowDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_vertical.js
var GroupPanelVertical = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      elementRef,
      groupPanelData,
      resourceCellTemplate,
      height,
      styles
    } = this.props;
    const style = normalizeStyles(renderUtils.addHeightToStyle(height, styles));
    const ResourceCellTemplateComponent = getTemplate(resourceCellTemplate);
    return createVNode(1, "div", className, createVNode(1, "div", "dx-scheduler-group-flex-container", groupPanelData.groupPanelItems.map((group) => createComponentVNode(2, GroupPanelVerticalRow, {
      groupItems: group,
      cellTemplate: ResourceCellTemplateComponent
    }, group[0].key)), 0), 2, {
      style
    }, null, elementRef);
  }
};
GroupPanelVertical.defaultProps = GroupPanelBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel.js
var GroupPanelDefaultProps = _extends({}, GroupPanelBaseDefaultProps, {
  groups: [],
  groupOrientation: VERTICAL_GROUP_ORIENTATION
});
var GroupPanel = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const {
      className,
      viewContext,
      elementRef,
      groupPanelData,
      height,
      resourceCellTemplate,
      groupOrientation,
      groups,
      styles
    } = this.props;
    const ResourceCellTemplateComponent = getTemplate(resourceCellTemplate);
    const isVerticalLayout = isVerticalGroupingApplied(groups, groupOrientation);
    const Layout = isVerticalLayout ? GroupPanelVertical : GroupPanelHorizontal;
    return createComponentVNode(2, Layout, {
      viewContext,
      height,
      resourceCellTemplate: ResourceCellTemplateComponent,
      className,
      groupPanelData,
      elementRef,
      styles,
      groups: GroupPanelDefaultProps.groups,
      groupOrientation: GroupPanelDefaultProps.groupOrientation,
      groupByDate: GroupPanelDefaultProps.groupByDate
    });
  }
};
GroupPanel.defaultProps = GroupPanelDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/group_panel.js
var GroupPanelComponent = class extends ComponentWrapper {
  _setOptionsByReference() {
    super._setOptionsByReference();
    this._optionsByReference = _extends({}, this._optionsByReference, {
      resourceCellTemplate: true
    });
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["resourceCellTemplate"],
      props: ["viewContext", "groups", "groupOrientation", "groupPanelData", "groupByDate", "height", "className", "resourceCellTemplate"]
    };
  }
  get _viewComponent() {
    return GroupPanel;
  }
};
component_registrator_default("dxGroupPanel", GroupPanelComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_header_text.js
var DateHeaderTextDefaultProps = {
  text: "",
  splitText: false
};
var DateHeaderText = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this._textCache = null;
  }
  getTextParts() {
    if (null !== this._textCache) {
      return this._textCache;
    }
    const {
      text
    } = this.props;
    this._textCache = text ? text.split(" ") : [""];
    return this._textCache;
  }
  componentWillUpdate(nextProps) {
    if (this.props.text !== nextProps.text) {
      this._textCache = null;
    }
  }
  render() {
    const {
      splitText,
      text
    } = this.props;
    const textParts = this.getTextParts();
    return createFragment(splitText ? textParts.map((part) => createVNode(1, "div", "dx-scheduler-header-panel-cell-date", createVNode(1, "span", null, part, 0), 2)) : text, 0);
  }
};
DateHeaderText.defaultProps = DateHeaderTextDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_header_cell.js
var DateHeaderCellDefaultProps = _extends({}, CellBaseDefaultProps, {
  today: false,
  colSpan: 1,
  isWeekDayCell: false,
  splitText: false,
  isTimeCellTemplate: false
});
var DateHeaderCell = class extends BaseInfernoComponent {
  render() {
    const {
      viewContext: {
        view: {
          type: viewType
        },
        crossScrollingEnabled
      },
      colSpan,
      dateCellTemplate,
      groupIndex,
      groups,
      index,
      isTimeCellTemplate,
      splitText,
      startDate,
      text,
      timeCellTemplate,
      className,
      isFirstGroupCell,
      isLastGroupCell,
      isWeekDayCell,
      today
    } = this.props;
    const cellSizeHorizontalClass = renderUtils.getCellSizeHorizontalClass(viewType, crossScrollingEnabled);
    const cellClasses = renderUtils.combineClasses({
      "dx-scheduler-header-panel-cell": true,
      [cellSizeHorizontalClass]: true,
      "dx-scheduler-header-panel-current-time-cell": today,
      "dx-scheduler-header-panel-week-cell": isWeekDayCell,
      [className ?? ""]: !!className
    });
    const classes = renderUtils.getGroupCellClasses(isFirstGroupCell, isLastGroupCell, cellClasses);
    const useTemplate = !isTimeCellTemplate && !!dateCellTemplate || isTimeCellTemplate && !!timeCellTemplate;
    const TimeCellTemplateComponent = getTemplate(timeCellTemplate);
    const DateCellTemplateComponent = getTemplate(dateCellTemplate);
    const children = useTemplate ? createFragment([isTimeCellTemplate && TimeCellTemplateComponent && TimeCellTemplateComponent({
      data: {
        date: startDate,
        text,
        groups,
        groupIndex
      },
      index
    }), !isTimeCellTemplate && DateCellTemplateComponent && DateCellTemplateComponent({
      data: {
        date: startDate,
        text,
        groups,
        groupIndex
      },
      index
    })], 0) : createComponentVNode(2, DateHeaderText, {
      splitText,
      text
    });
    return createVNode(1, "th", classes, children, 0, {
      colSpan,
      title: text
    });
  }
};
DateHeaderCell.defaultProps = DateHeaderCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_header.js
var {
  isMaterialBased: isMaterialBased2
} = themeUtils.getThemeType();
var DateHeaderDefaultProps = {
  groupOrientation: "horizontal",
  groupByDate: false,
  groups: []
};
var DateHeader = class extends BaseInfernoComponent {
  render() {
    const {
      viewContext,
      dateCellTemplate,
      dateHeaderData: {
        dataMap,
        leftVirtualCellCount,
        leftVirtualCellWidth,
        rightVirtualCellCount,
        rightVirtualCellWidth
      },
      groupByDate,
      groupOrientation,
      groups
    } = this.props;
    const isHorizontalGrouping = isHorizontalGroupingApplied(groups, groupOrientation) && !groupByDate;
    const DateCellTemplateComponent = getTemplate(dateCellTemplate);
    return createFragment(dataMap.map((dateHeaderRow, rowIndex) => createComponentVNode(2, Row, {
      className: "dx-scheduler-header-row",
      leftVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellWidth,
      rightVirtualCellCount,
      isHeaderRow: true,
      children: dateHeaderRow.map((_ref) => {
        let {
          colSpan,
          endDate,
          groupIndex,
          groups: cellGroups,
          index,
          isFirstGroupCell,
          isLastGroupCell,
          key,
          startDate,
          text,
          today
        } = _ref;
        return createComponentVNode(2, DateHeaderCell, {
          viewContext,
          startDate,
          endDate,
          groups: isHorizontalGrouping ? cellGroups : void 0,
          groupIndex: isHorizontalGrouping ? groupIndex : void 0,
          today: today ?? false,
          isWeekDayCell: false,
          isTimeCellTemplate: false,
          index,
          text,
          isFirstGroupCell,
          isLastGroupCell,
          dateCellTemplate: DateCellTemplateComponent,
          colSpan,
          splitText: isMaterialBased2
        }, key);
      })
    }, rowIndex.toString())), 0);
  }
};
DateHeader.defaultProps = DateHeaderDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/header_panel.js
var HeaderPanelDefaultProps = _extends({}, GroupPanelDefaultProps, {
  isRenderDateHeader: true,
  dateHeaderTemplate: DateHeader
});
var HeaderPanel = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const {
      viewContext,
      dateHeaderData,
      groupByDate,
      groupOrientation,
      groupPanelData,
      groups,
      isRenderDateHeader,
      dateCellTemplate,
      dateHeaderTemplate,
      resourceCellTemplate,
      timeCellTemplate
    } = this.props;
    const isHorizontalGrouping = isHorizontalGroupingApplied(groups, groupOrientation);
    const DateCellTemplateComponent = getTemplate(dateCellTemplate);
    const DateHeaderTemplateComponent = getTemplate(dateHeaderTemplate);
    const ResourceCellTemplateComponent = getTemplate(resourceCellTemplate);
    const TimeCellTemplateComponent = getTemplate(timeCellTemplate);
    return createVNode(1, "thead", null, [isHorizontalGrouping && !groupByDate && createComponentVNode(2, GroupPanel, {
      viewContext,
      groupPanelData,
      groups,
      groupByDate,
      groupOrientation,
      resourceCellTemplate: ResourceCellTemplateComponent
    }), isRenderDateHeader && DateHeaderTemplateComponent({
      viewContext,
      groupByDate,
      dateHeaderData,
      groupOrientation,
      groups,
      dateCellTemplate: DateCellTemplateComponent,
      timeCellTemplate: TimeCellTemplateComponent
    }), groupByDate && createComponentVNode(2, GroupPanel, {
      viewContext,
      groupPanelData,
      groups,
      groupByDate,
      groupOrientation,
      resourceCellTemplate: ResourceCellTemplateComponent
    })], 0);
  }
};
HeaderPanel.defaultProps = HeaderPanelDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/header_panel.js
var HeaderPanelComponent = class extends ComponentWrapper {
  _setOptionsByReference() {
    super._setOptionsByReference();
    this._optionsByReference = _extends({}, this._optionsByReference, {
      dateHeaderData: true,
      resourceCellTemplate: true,
      dateCellTemplate: true,
      timeCellTemplate: true
    });
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["dateCellTemplate", "timeCellTemplate", "dateHeaderTemplate", "resourceCellTemplate"],
      props: ["viewContext", "dateHeaderData", "isRenderDateHeader", "dateCellTemplate", "timeCellTemplate", "dateHeaderTemplate", "groups", "groupOrientation", "groupPanelData", "groupByDate", "height", "className", "resourceCellTemplate"]
    };
  }
  get _viewComponent() {
    return HeaderPanel;
  }
};
component_registrator_default("dxHeaderPanelLayout", HeaderPanelComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/timeline/date_header_timeline.js
var {
  isMaterialBased: isMaterialBased3
} = getThemeType();
var TimelineDateHeaderLayout = class extends BaseInfernoComponent {
  render() {
    const {
      viewContext,
      groupByDate,
      groupOrientation,
      groups,
      dateHeaderData,
      dateCellTemplate,
      timeCellTemplate
    } = this.props;
    const {
      dataMap,
      isMonthDateHeader,
      leftVirtualCellCount,
      leftVirtualCellWidth,
      rightVirtualCellCount,
      rightVirtualCellWidth,
      weekDayLeftVirtualCellCount,
      weekDayLeftVirtualCellWidth,
      weekDayRightVirtualCellCount,
      weekDayRightVirtualCellWidth
    } = dateHeaderData;
    const isHorizontalGrouping = isHorizontalGroupingApplied(groups, groupOrientation) && !groupByDate;
    const DateCellTemplateComponent = getTemplate(dateCellTemplate);
    const TimeCellTemplateComponent = getTemplate(timeCellTemplate);
    return createFragment(dataMap.map((dateHeaderRow, rowIndex) => {
      const rowsCount = dataMap.length;
      const isTimeCellTemplate = rowsCount - 1 === rowIndex;
      const isWeekDayRow = rowsCount > 1 && 0 === rowIndex;
      const splitText = isMaterialBased3 && (isMonthDateHeader || isWeekDayRow);
      let validLeftVirtualCellCount = leftVirtualCellCount;
      let validRightVirtualCellCount = rightVirtualCellCount;
      let validRightVirtualCellWidth = rightVirtualCellWidth;
      let validLeftVirtualCellWidth = leftVirtualCellWidth;
      if (isWeekDayRow) {
        validLeftVirtualCellCount = weekDayLeftVirtualCellCount;
        validRightVirtualCellCount = weekDayRightVirtualCellCount;
        validRightVirtualCellWidth = weekDayRightVirtualCellWidth;
        validLeftVirtualCellWidth = weekDayLeftVirtualCellWidth;
      }
      return createComponentVNode(2, Row, {
        className: "dx-scheduler-header-row",
        leftVirtualCellWidth: validLeftVirtualCellWidth ?? RowDefaultProps.leftVirtualCellWidth,
        leftVirtualCellCount: validLeftVirtualCellCount,
        rightVirtualCellWidth: validRightVirtualCellWidth ?? RowDefaultProps.rightVirtualCellWidth,
        rightVirtualCellCount: validRightVirtualCellCount,
        children: dateHeaderRow.map((_ref) => {
          let {
            colSpan,
            endDate,
            groupIndex,
            groups: cellGroups,
            index,
            isFirstGroupCell,
            isLastGroupCell,
            key,
            startDate,
            text,
            today
          } = _ref;
          return createComponentVNode(2, DateHeaderCell, {
            viewContext,
            startDate,
            endDate,
            groups: isHorizontalGrouping ? cellGroups : void 0,
            groupIndex: isHorizontalGrouping ? groupIndex : void 0,
            today: today ?? DateHeaderCellDefaultProps.today,
            index,
            text,
            isFirstGroupCell,
            isLastGroupCell,
            isWeekDayCell: isWeekDayRow,
            colSpan,
            splitText,
            dateCellTemplate: DateCellTemplateComponent,
            timeCellTemplate: TimeCellTemplateComponent,
            isTimeCellTemplate
          }, key);
        })
      }, rowIndex.toString());
    }), 0);
  }
};
TimelineDateHeaderLayout.defaultProps = DateHeaderDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/timeline/header_panel_timeline.js
var HeaderPanelTimeline = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const {
      viewContext,
      dateCellTemplate,
      dateHeaderData,
      groupByDate,
      groupOrientation,
      groupPanelData,
      groups,
      isRenderDateHeader,
      resourceCellTemplate,
      timeCellTemplate
    } = this.props;
    const DateCellTemplateComponent = getTemplate(dateCellTemplate);
    const ResourceCellTemplateComponent = getTemplate(resourceCellTemplate);
    const TimeCellTemplateComponent = getTemplate(timeCellTemplate);
    return createComponentVNode(2, HeaderPanel, {
      viewContext,
      dateHeaderData,
      groupPanelData,
      groupByDate,
      groups,
      groupOrientation,
      isRenderDateHeader,
      dateHeaderTemplate: TimelineDateHeaderLayout,
      resourceCellTemplate: ResourceCellTemplateComponent,
      dateCellTemplate: DateCellTemplateComponent,
      timeCellTemplate: TimeCellTemplateComponent
    });
  }
};
HeaderPanelTimeline.defaultProps = HeaderPanelDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/header_panel_timeline.js
var HeaderPanelTimelineComponent = class extends HeaderPanelComponent {
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["dateCellTemplate", "timeCellTemplate", "dateHeaderTemplate", "resourceCellTemplate"],
      props: ["viewContext", "dateHeaderData", "isRenderDateHeader", "dateCellTemplate", "timeCellTemplate", "dateHeaderTemplate", "groups", "groupOrientation", "groupPanelData", "groupByDate", "height", "className", "resourceCellTemplate"]
    };
  }
  get _viewComponent() {
    return HeaderPanelTimeline;
  }
};
component_registrator_default("dxTimelineHeaderPanelLayout", HeaderPanelTimelineComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/time_panel_cell.js
var TimePanelCell = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.timeCellTemplateProps = null;
  }
  getTimeCellTemplateProps() {
    if (null !== this.timeCellTemplateProps) {
      return this.timeCellTemplateProps;
    }
    const {
      groupIndex,
      groups,
      index,
      startDate,
      text
    } = this.props;
    this.timeCellTemplateProps = {
      data: {
        date: startDate,
        groups,
        groupIndex,
        text
      },
      index
    };
    return this.timeCellTemplateProps;
  }
  componentWillUpdate(nextProps) {
    if (this.props.groupIndex !== nextProps.groupIndex || this.props.groups !== nextProps.groups || this.props.index !== nextProps.index || this.props.startDate !== nextProps.startDate || this.props.text !== nextProps.text) {
      this.timeCellTemplateProps = null;
    }
  }
  render() {
    const {
      className,
      viewContext,
      highlighted,
      isFirstGroupCell,
      isLastGroupCell,
      text,
      timeCellTemplate
    } = this.props;
    const cellSizeVerticalClass = renderUtils.getCellSizeVerticalClass(false);
    const classes = renderUtils.combineClasses({
      "dx-scheduler-time-panel-cell": true,
      [cellSizeVerticalClass]: true,
      "dx-scheduler-time-panel-current-time-cell": !!highlighted,
      [className ?? ""]: true
    });
    const timeCellTemplateProps = this.getTimeCellTemplateProps();
    const TimeCellTemplateComponent = getTemplate(timeCellTemplate);
    return createComponentVNode(2, CellBase, {
      className: classes,
      viewContext,
      isFirstGroupCell,
      isLastGroupCell,
      startDate: CellBaseDefaultProps.startDate,
      endDate: CellBaseDefaultProps.endDate,
      index: CellBaseDefaultProps.index,
      children: TimeCellTemplateComponent ? TimeCellTemplateComponent({
        index: timeCellTemplateProps.index,
        data: timeCellTemplateProps.data
      }) : createVNode(1, "div", null, text, 0)
    });
  }
};
TimePanelCell.defaultProps = CellBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/time_panel_table.js
var _excluded5 = ["timePanelData", "viewContext", "tableRef", "timeCellTemplate"];
var TimePanelTableDefaultProps = {
  timePanelData: {
    groupedData: [],
    leftVirtualCellCount: 0,
    rightVirtualCellCount: 0,
    topVirtualRowCount: 0,
    bottomVirtualRowCount: 0
  }
};
var TimePanelTable = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const _this$props = this.props, {
      timePanelData,
      viewContext,
      tableRef,
      timeCellTemplate
    } = _this$props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded5);
    const {
      topVirtualRowHeight,
      bottomVirtualRowHeight
    } = timePanelData;
    const TimeCellTemplateComponent = getTemplate(timeCellTemplate);
    return normalizeProps(createComponentVNode(2, Table, _extends({}, restProps, {
      className: "dx-scheduler-time-panel",
      topVirtualRowHeight: topVirtualRowHeight ?? 0,
      bottomVirtualRowHeight: bottomVirtualRowHeight ?? 0,
      virtualCellsCount: 1,
      tableRef,
      children: timePanelData.groupedData.map((_ref) => {
        let {
          dateTable,
          groupIndex,
          isGroupedAllDayPanel,
          key: fragmentKey
        } = _ref;
        return createFragment([isGroupedAllDayPanel && createComponentVNode(2, Row, {
          leftVirtualCellWidth: RowDefaultProps.leftVirtualCellWidth,
          rightVirtualCellWidth: RowDefaultProps.rightVirtualCellWidth,
          children: createComponentVNode(2, CellBase, {
            className: "dx-scheduler-time-panel-title-cell",
            viewContext,
            startDate: CellBaseDefaultProps.startDate,
            endDate: CellBaseDefaultProps.endDate,
            index: CellBaseDefaultProps.index,
            children: createComponentVNode(2, AllDayPanelTitle)
          })
        }), dateTable.map((_ref2) => {
          let {
            groups,
            highlighted,
            index: cellIndex,
            isFirstGroupCell,
            isLastGroupCell,
            key,
            startDate,
            text
          } = _ref2;
          return createComponentVNode(2, Row, {
            className: "dx-scheduler-time-panel-row",
            leftVirtualCellWidth: RowDefaultProps.leftVirtualCellWidth,
            rightVirtualCellWidth: RowDefaultProps.rightVirtualCellWidth,
            children: createComponentVNode(2, TimePanelCell, {
              viewContext,
              startDate,
              endDate: CellBaseDefaultProps.endDate,
              text,
              groups,
              groupIndex,
              isFirstGroupCell,
              isLastGroupCell,
              index: cellIndex,
              timeCellTemplate: TimeCellTemplateComponent,
              highlighted
            })
          }, key);
        })], 0, fragmentKey);
      })
    })));
  }
};
TimePanelTable.defaultProps = TimePanelTableDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/time_panel.js
var TimePanelComponent = class extends ComponentWrapper {
  _setOptionsByReference() {
    super._setOptionsByReference();
    this._optionsByReference = _extends({}, this._optionsByReference, {
      timeCellTemplate: true
    });
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["timeCellTemplate"],
      props: ["viewContext", "groupOrientation", "timePanelData", "timeCellTemplate"]
    };
  }
  get _viewComponent() {
    return TimePanelTable;
  }
};
component_registrator_default("dxTimePanelTableLayout", TimePanelComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/base/m_widget_observer.js
var WidgetObserver = class extends ui_widget_default {
  notifyObserver(subject, args) {
    const observer = this.option("observer");
    if (observer) {
      observer.fire(subject, args);
    }
  }
  invoke() {
    const observer = this.option("observer");
    if (observer) {
      return observer.fire.apply(observer, arguments);
    }
  }
};
var m_widget_observer_default = WidgetObserver;

// ../../../../../../node_modules/devextreme/esm/__internal/m_draggable.js
var window2 = getWindow();
var DRAGGABLE = "dxDraggable";
var DRAGSTART_EVENT_NAME = addNamespace(DRAG_START_EVENT, DRAGGABLE);
var DRAG_EVENT_NAME = addNamespace(DRAG_EVENT, DRAGGABLE);
var DRAGEND_EVENT_NAME = addNamespace(DRAG_END_EVENT, DRAGGABLE);
var DRAG_ENTER_EVENT_NAME = addNamespace(DRAG_ENTER_EVENT, DRAGGABLE);
var DRAGEND_LEAVE_EVENT_NAME = addNamespace(DRAG_LEAVE_EVENT, DRAGGABLE);
var POINTERDOWN_EVENT_NAME = addNamespace(pointer_default.down, DRAGGABLE);
var KEYDOWN_EVENT_NAME = addNamespace("keydown", DRAGGABLE);
var targetDraggable;
var sourceDraggable;
var getMousePosition = (event) => ({
  x: event.pageX - renderer_default(window2).scrollLeft(),
  y: event.pageY - renderer_default(window2).scrollTop()
});
var ScrollHelper = class {
  constructor(orientation, component) {
    this._$scrollableAtPointer = null;
    this._preventScroll = true;
    this._component = component;
    if ("vertical" === orientation) {
      this._scrollValue = "scrollTop";
      this._overFlowAttr = "overflowY";
      this._sizeAttr = "height";
      this._scrollSizeProp = "scrollHeight";
      this._clientSizeProp = "clientHeight";
      this._limitProps = {
        start: "top",
        end: "bottom"
      };
    } else {
      this._scrollValue = "scrollLeft";
      this._overFlowAttr = "overflowX";
      this._sizeAttr = "width";
      this._scrollSizeProp = "scrollWidth";
      this._clientSizeProp = "clientWidth";
      this._limitProps = {
        start: "left",
        end: "right"
      };
    }
  }
  updateScrollable(elements, mousePosition) {
    let isScrollableFound = false;
    elements.some((element) => {
      const $element = renderer_default(element);
      const isTargetOverOverlayWrapper = $element.hasClass("dx-overlay-wrapper");
      const isTargetOverOverlayContent = $element.hasClass("dx-overlay-content");
      if (isTargetOverOverlayWrapper || isTargetOverOverlayContent) {
        return true;
      }
      isScrollableFound = this._trySetScrollable(element, mousePosition);
      return isScrollableFound;
    });
    if (!isScrollableFound) {
      this._$scrollableAtPointer = null;
      this._scrollSpeed = 0;
    }
  }
  isScrolling() {
    return !!this._scrollSpeed;
  }
  isScrollable($element) {
    return ("auto" === $element.css(this._overFlowAttr) || $element.hasClass("dx-scrollable-container")) && $element.prop(this._scrollSizeProp) > Math.ceil("width" === this._sizeAttr ? getWidth($element) : getHeight($element));
  }
  _trySetScrollable(element, mousePosition) {
    const that = this;
    const $element = renderer_default(element);
    let distanceToBorders;
    const sensitivity = that._component.option("scrollSensitivity");
    let isScrollable = that.isScrollable($element);
    if (isScrollable) {
      distanceToBorders = that._calculateDistanceToBorders($element, mousePosition);
      if (sensitivity > distanceToBorders[that._limitProps.start]) {
        if (!that._preventScroll) {
          that._scrollSpeed = -that._calculateScrollSpeed(distanceToBorders[that._limitProps.start]);
          that._$scrollableAtPointer = $element;
        }
      } else if (sensitivity > distanceToBorders[that._limitProps.end]) {
        if (!that._preventScroll) {
          that._scrollSpeed = that._calculateScrollSpeed(distanceToBorders[that._limitProps.end]);
          that._$scrollableAtPointer = $element;
        }
      } else {
        isScrollable = false;
        that._preventScroll = false;
      }
    }
    return isScrollable;
  }
  _calculateDistanceToBorders($area, mousePosition) {
    const area = $area.get(0);
    let areaBoundingRect;
    if (area) {
      areaBoundingRect = getBoundingRect(area);
      return {
        left: mousePosition.x - areaBoundingRect.left,
        top: mousePosition.y - areaBoundingRect.top,
        right: areaBoundingRect.right - mousePosition.x,
        bottom: areaBoundingRect.bottom - mousePosition.y
      };
    }
    return {};
  }
  _calculateScrollSpeed(distance) {
    const component = this._component;
    const sensitivity = component.option("scrollSensitivity");
    const maxSpeed = component.option("scrollSpeed");
    return Math.ceil(((sensitivity - distance) / sensitivity) ** 2 * maxSpeed);
  }
  scrollByStep() {
    const that = this;
    if (that._$scrollableAtPointer && that._scrollSpeed) {
      if (that._$scrollableAtPointer.hasClass("dx-scrollable-container")) {
        const $scrollable = that._$scrollableAtPointer.closest(".dx-scrollable");
        const scrollableInstance = $scrollable.data("dxScrollable") || $scrollable.data("dxScrollView");
        if (scrollableInstance) {
          const nextScrollPosition = scrollableInstance.scrollOffset()[that._limitProps.start] + that._scrollSpeed;
          scrollableInstance.scrollTo({
            [that._limitProps.start]: nextScrollPosition
          });
        }
      } else {
        const nextScrollPosition = that._$scrollableAtPointer[that._scrollValue]() + that._scrollSpeed;
        that._$scrollableAtPointer[that._scrollValue](nextScrollPosition);
      }
      const dragMoveArgs = that._component._dragMoveArgs;
      if (dragMoveArgs) {
        that._component._dragMoveHandler(dragMoveArgs);
      }
    }
  }
  reset() {
    this._$scrollableAtPointer = null;
    this._scrollSpeed = 0;
    this._preventScroll = true;
  }
  isOutsideScrollable($scrollable, event) {
    if (!$scrollable) {
      return false;
    }
    const scrollableSize = getBoundingRect($scrollable.get(0));
    const start = scrollableSize[this._limitProps.start];
    const size = scrollableSize[this._sizeAttr];
    const mousePosition = getMousePosition(event);
    const location = "width" === this._sizeAttr ? mousePosition.x : mousePosition.y;
    return location < start || location > start + size;
  }
};
var ScrollAnimator = m_animator_default.inherit({
  ctor(strategy) {
    this.callBase();
    this._strategy = strategy;
  },
  _step() {
    const horizontalScrollHelper = this._strategy._horizontalScrollHelper;
    const verticalScrollHelper = this._strategy._verticalScrollHelper;
    horizontalScrollHelper && horizontalScrollHelper.scrollByStep();
    verticalScrollHelper && verticalScrollHelper.scrollByStep();
  }
});
var Draggable = dom_component_default.inherit({
  reset: noop,
  dragMove: noop,
  dragEnter: noop,
  dragLeave: noop,
  dragEnd(sourceEvent) {
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2._fireRemoveEvent(sourceEvent);
    return Deferred().resolve();
  },
  _fireRemoveEvent: noop,
  _getDefaultOptions() {
    return extend(this.callBase(), {
      onDragStart: null,
      onDragMove: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragLeave: null,
      onDragCancel: null,
      onCancelByEsc: false,
      onDrop: null,
      immediate: true,
      dragDirection: "both",
      boundary: void 0,
      boundOffset: 0,
      allowMoveByClick: false,
      itemData: null,
      container: void 0,
      dragTemplate: void 0,
      contentTemplate: "content",
      handle: "",
      filter: "",
      clone: false,
      autoScroll: true,
      scrollSpeed: 30,
      scrollSensitivity: 60,
      group: void 0,
      data: void 0
    });
  },
  _setOptionsByReference() {
    this.callBase.apply(this, arguments);
    extend(this._optionsByReference, {
      component: true,
      group: true,
      itemData: true,
      data: true
    });
  },
  _init() {
    this.callBase();
    this._attachEventHandlers();
    this._scrollAnimator = new ScrollAnimator(this);
    this._horizontalScrollHelper = new ScrollHelper("horizontal", this);
    this._verticalScrollHelper = new ScrollHelper("vertical", this);
    this._initScrollTop = 0;
    this._initScrollLeft = 0;
  },
  _normalizeCursorOffset(offset) {
    if (isObject(offset)) {
      offset = {
        h: offset.x,
        v: offset.y
      };
    }
    offset = splitPair(offset).map((value2) => parseFloat(value2));
    return {
      left: offset[0],
      top: 1 === offset.length ? offset[0] : offset[1]
    };
  },
  _getNormalizedCursorOffset(offset, options) {
    if (isFunction(offset)) {
      offset = offset.call(this, options);
    }
    return this._normalizeCursorOffset(offset);
  },
  _calculateElementOffset(options) {
    let elementOffset;
    let dragElementOffset;
    const {
      event
    } = options;
    const $element = renderer_default(options.itemElement);
    const $dragElement = renderer_default(options.dragElement);
    const isCloned = this._dragElementIsCloned();
    const cursorOffset = this.option("cursorOffset");
    let normalizedCursorOffset = {
      left: 0,
      top: 0
    };
    const currentLocate = this._initialLocate = locate($dragElement);
    if (isCloned || options.initialOffset || cursorOffset) {
      elementOffset = options.initialOffset || $element.offset();
      if (cursorOffset) {
        normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options);
        if (isFinite(normalizedCursorOffset.left)) {
          elementOffset.left = event.pageX;
        }
        if (isFinite(normalizedCursorOffset.top)) {
          elementOffset.top = event.pageY;
        }
      }
      dragElementOffset = $dragElement.offset();
      elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;
      elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left;
    }
    return elementOffset;
  },
  _initPosition(options) {
    const $dragElement = renderer_default(options.dragElement);
    const elementOffset = this._calculateElementOffset(options);
    if (elementOffset) {
      this._move(elementOffset, $dragElement);
    }
    this._startPosition = locate($dragElement);
  },
  _startAnimator() {
    if (!this._scrollAnimator.inProgress()) {
      this._scrollAnimator.start();
    }
  },
  _stopAnimator() {
    this._scrollAnimator.stop();
  },
  _addWidgetPrefix(className) {
    const componentName = this.NAME;
    return dasherize(componentName) + (className ? `-${className}` : "");
  },
  _getItemsSelector() {
    return this.option("filter") || "";
  },
  _$content() {
    const $element = this.$element();
    const $wrapper = $element.children(".dx-template-wrapper");
    return $wrapper.length ? $wrapper : $element;
  },
  _attachEventHandlers() {
    if (this.option("disabled")) {
      return;
    }
    let $element = this._$content();
    let itemsSelector = this._getItemsSelector();
    const allowMoveByClick = this.option("allowMoveByClick");
    const data2 = {
      direction: this.option("dragDirection"),
      immediate: this.option("immediate"),
      checkDropTarget: ($target, event) => {
        const targetGroup = this.option("group");
        const sourceGroup = this._getSourceDraggable().option("group");
        const $scrollable = this._getScrollable($target);
        if (this._verticalScrollHelper.isOutsideScrollable($scrollable, event) || this._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {
          return false;
        }
        return sourceGroup && sourceGroup === targetGroup;
      }
    };
    if (allowMoveByClick) {
      $element = this._getArea();
      events_engine_default.on($element, POINTERDOWN_EVENT_NAME, data2, this._pointerDownHandler.bind(this));
    }
    if (">" === itemsSelector[0]) {
      itemsSelector = itemsSelector.slice(1);
    }
    events_engine_default.on($element, DRAGSTART_EVENT_NAME, itemsSelector, data2, this._dragStartHandler.bind(this));
    events_engine_default.on($element, DRAG_EVENT_NAME, data2, this._dragMoveHandler.bind(this));
    events_engine_default.on($element, DRAGEND_EVENT_NAME, data2, this._dragEndHandler.bind(this));
    events_engine_default.on($element, DRAG_ENTER_EVENT_NAME, data2, this._dragEnterHandler.bind(this));
    events_engine_default.on($element, DRAGEND_LEAVE_EVENT_NAME, data2, this._dragLeaveHandler.bind(this));
    if (this.option("onCancelByEsc")) {
      events_engine_default.on($element, KEYDOWN_EVENT_NAME, this._keydownHandler.bind(this));
    }
  },
  _dragElementIsCloned() {
    return this._$dragElement && this._$dragElement.hasClass(this._addWidgetPrefix("clone"));
  },
  _getDragTemplateArgs($element, $container) {
    return {
      container: getPublicElement($container),
      model: {
        itemData: this.option("itemData"),
        itemElement: getPublicElement($element)
      }
    };
  },
  _createDragElement($element) {
    let result = $element;
    const clone2 = this.option("clone");
    const $container = this._getContainer();
    let template = this.option("dragTemplate");
    if (template) {
      template = this._getTemplate(template);
      result = renderer_default("<div>").appendTo($container);
      template.render(this._getDragTemplateArgs($element, result));
    } else if (clone2) {
      result = renderer_default("<div>").appendTo($container);
      $element.clone().css({
        width: $element.css("width"),
        height: $element.css("height")
      }).appendTo(result);
    }
    return result.toggleClass(this._addWidgetPrefix("clone"), result.get(0) !== $element.get(0)).toggleClass("dx-rtl", this.option("rtlEnabled"));
  },
  _resetDragElement() {
    if (this._dragElementIsCloned()) {
      this._$dragElement.remove();
    } else {
      this._toggleDraggingClass(false);
    }
    this._$dragElement = null;
  },
  _resetSourceElement() {
    this._toggleDragSourceClass(false);
    this._$sourceElement = null;
  },
  _detachEventHandlers() {
    events_engine_default.off(this._$content(), `.${DRAGGABLE}`);
    events_engine_default.off(this._getArea(), `.${DRAGGABLE}`);
  },
  _move(position, $element) {
    move($element || this._$dragElement, position);
  },
  _getDraggableElement(e) {
    const $sourceElement = this._getSourceElement();
    if ($sourceElement) {
      return $sourceElement;
    }
    const allowMoveByClick = this.option("allowMoveByClick");
    if (allowMoveByClick) {
      return this.$element();
    }
    let $target = renderer_default(e && e.target);
    const itemsSelector = this._getItemsSelector();
    if (">" === itemsSelector[0]) {
      const $items = this._$content().find(itemsSelector);
      if (!$items.is($target)) {
        $target = $target.closest($items);
      }
    }
    return $target;
  },
  _getSourceElement() {
    const draggable = this._getSourceDraggable();
    return draggable._$sourceElement;
  },
  _pointerDownHandler(e) {
    if (needSkipEvent(e)) {
      return;
    }
    const position = {};
    const $element = this.$element();
    const dragDirection = this.option("dragDirection");
    if ("horizontal" === dragDirection || "both" === dragDirection) {
      position.left = e.pageX - $element.offset().left + locate($element).left - getWidth($element) / 2;
    }
    if ("vertical" === dragDirection || "both" === dragDirection) {
      position.top = e.pageY - $element.offset().top + locate($element).top - getHeight($element) / 2;
    }
    this._move(position, $element);
    this._getAction("onDragMove")(this._getEventArgs(e));
  },
  _isValidElement(event, $element) {
    const handle = this.option("handle");
    const $target = renderer_default(event.originalEvent && event.originalEvent.target);
    if (handle && !$target.closest(handle).length) {
      return false;
    }
    if (!$element.length) {
      return false;
    }
    return !$element.is(".dx-state-disabled, .dx-state-disabled *");
  },
  _dragStartHandler(e) {
    const $element = this._getDraggableElement(e);
    this.dragInProgress = true;
    if (!this._isValidElement(e, $element)) {
      e.cancel = true;
      return;
    }
    if (this._$sourceElement) {
      return;
    }
    const dragStartArgs = this._getDragStartArgs(e, $element);
    this._getAction("onDragStart")(dragStartArgs);
    if (dragStartArgs.cancel) {
      e.cancel = true;
      return;
    }
    this.option("itemData", dragStartArgs.itemData);
    this._setSourceDraggable();
    this._$sourceElement = $element;
    let initialOffset = $element.offset();
    if (!this._hasClonedDraggable() && this.option("autoScroll")) {
      this._initScrollTop = this._getScrollableScrollTop();
      this._initScrollLeft = this._getScrollableScrollLeft();
      initialOffset = this._getDraggableElementOffset(initialOffset.left, initialOffset.top);
    }
    const $dragElement = this._$dragElement = this._createDragElement($element);
    this._toggleDraggingClass(true);
    this._toggleDragSourceClass(true);
    this._setGestureCoverCursor($dragElement.children());
    const isFixedPosition = "fixed" === $dragElement.css("position");
    this._initPosition(extend({}, dragStartArgs, {
      dragElement: $dragElement.get(0),
      initialOffset: isFixedPosition && initialOffset
    }));
    this._getAction("onDraggableElementShown")(_extends({}, dragStartArgs, {
      dragElement: $dragElement
    }));
    const $area = this._getArea();
    const areaOffset = this._getAreaOffset($area);
    const boundOffset = this._getBoundOffset();
    const areaWidth = getOuterWidth($area);
    const areaHeight = getOuterHeight($area);
    const elementWidth = getWidth($dragElement);
    const elementHeight = getHeight($dragElement);
    const startOffset_left = $dragElement.offset().left - areaOffset.left, startOffset_top = $dragElement.offset().top - areaOffset.top;
    if ($area.length) {
      e.maxLeftOffset = startOffset_left - boundOffset.left;
      e.maxRightOffset = areaWidth - startOffset_left - elementWidth - boundOffset.right;
      e.maxTopOffset = startOffset_top - boundOffset.top;
      e.maxBottomOffset = areaHeight - startOffset_top - elementHeight - boundOffset.bottom;
    }
    if (this.option("autoScroll")) {
      this._startAnimator();
    }
  },
  _getAreaOffset($area) {
    const offset = $area && position_default.offset($area);
    return offset || {
      left: 0,
      top: 0
    };
  },
  _toggleDraggingClass(value2) {
    this._$dragElement && this._$dragElement.toggleClass(this._addWidgetPrefix("dragging"), value2);
  },
  _toggleDragSourceClass(value2, $element) {
    const $sourceElement = $element || this._$sourceElement;
    $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix("source"), value2);
  },
  _setGestureCoverCursor($element) {
    renderer_default(".dx-gesture-cover").css("cursor", $element.css("cursor"));
  },
  _getBoundOffset() {
    let boundOffset = this.option("boundOffset");
    if (isFunction(boundOffset)) {
      boundOffset = boundOffset.call(this);
    }
    return quadToObject(boundOffset);
  },
  _getArea() {
    let area = this.option("boundary");
    if (isFunction(area)) {
      area = area.call(this);
    }
    return renderer_default(area);
  },
  _getContainer() {
    let container = this.option("container");
    if (void 0 === container) {
      container = value();
    }
    return renderer_default(container);
  },
  _getDraggableElementOffset(initialOffsetX, initialOffsetY) {
    var _this$_startPosition, _this$_startPosition2;
    const initScrollTop = this._initScrollTop;
    const initScrollLeft = this._initScrollLeft;
    const scrollTop = this._getScrollableScrollTop();
    const scrollLeft = this._getScrollableScrollLeft();
    const elementPosition = renderer_default(this.element()).css("position");
    const isFixedPosition = "fixed" === elementPosition;
    const result = {
      left: ((null === (_this$_startPosition = this._startPosition) || void 0 === _this$_startPosition ? void 0 : _this$_startPosition.left) ?? 0) + initialOffsetX,
      top: ((null === (_this$_startPosition2 = this._startPosition) || void 0 === _this$_startPosition2 ? void 0 : _this$_startPosition2.top) ?? 0) + initialOffsetY
    };
    if (isFixedPosition || this._hasClonedDraggable()) {
      return result;
    }
    return {
      left: isNumeric(scrollLeft) ? result.left + scrollLeft - initScrollLeft : result.left,
      top: isNumeric(scrollTop) ? result.top + scrollTop - initScrollTop : result.top
    };
  },
  _hasClonedDraggable() {
    return this.option("clone") || this.option("dragTemplate");
  },
  _dragMoveHandler(e) {
    this._dragMoveArgs = e;
    if (!this._$dragElement) {
      e.cancel = true;
      return;
    }
    const offset = this._getDraggableElementOffset(e.offset.x, e.offset.y);
    this._move(offset);
    this._updateScrollable(e);
    const eventArgs = this._getEventArgs(e);
    this._getAction("onDragMove")(eventArgs);
    if (true === eventArgs.cancel) {
      return;
    }
    const targetDraggable2 = this._getTargetDraggable();
    targetDraggable2.dragMove(e, scrollBy);
  },
  _updateScrollable(e) {
    const that = this;
    if (that.option("autoScroll")) {
      const mousePosition = getMousePosition(e);
      const allObjects = dom_adapter_default.elementsFromPoint(mousePosition.x, mousePosition.y, this.$element().get(0));
      that._verticalScrollHelper.updateScrollable(allObjects, mousePosition);
      that._horizontalScrollHelper.updateScrollable(allObjects, mousePosition);
    }
  },
  _getScrollable($element) {
    let $scrollable;
    $element.parents().toArray().some((parent) => {
      const $parent = renderer_default(parent);
      if (this._horizontalScrollHelper.isScrollable($parent) || this._verticalScrollHelper.isScrollable($parent)) {
        $scrollable = $parent;
        return true;
      }
      return false;
    });
    return $scrollable;
  },
  _getScrollableScrollTop() {
    var _this$_getScrollable;
    return (null === (_this$_getScrollable = this._getScrollable(renderer_default(this.element()))) || void 0 === _this$_getScrollable ? void 0 : _this$_getScrollable.scrollTop()) ?? 0;
  },
  _getScrollableScrollLeft() {
    var _this$_getScrollable2;
    return (null === (_this$_getScrollable2 = this._getScrollable(renderer_default(this.element()))) || void 0 === _this$_getScrollable2 ? void 0 : _this$_getScrollable2.scrollLeft()) ?? 0;
  },
  _defaultActionArgs() {
    const args = this.callBase.apply(this, arguments);
    const component = this.option("component");
    if (component) {
      args.component = component;
      args.element = component.element();
    }
    return args;
  },
  _getEventArgs(e) {
    const sourceDraggable2 = this._getSourceDraggable();
    const targetDraggable2 = this._getTargetDraggable();
    return {
      event: e,
      itemData: sourceDraggable2.option("itemData"),
      itemElement: getPublicElement(sourceDraggable2._$sourceElement),
      fromComponent: sourceDraggable2.option("component") || sourceDraggable2,
      toComponent: targetDraggable2.option("component") || targetDraggable2,
      fromData: sourceDraggable2.option("data"),
      toData: targetDraggable2.option("data")
    };
  },
  _getDragStartArgs(e, $itemElement) {
    const args = this._getEventArgs(e);
    return {
      event: args.event,
      itemData: args.itemData,
      itemElement: $itemElement,
      fromData: args.fromData
    };
  },
  _revertItemToInitialPosition() {
    !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);
  },
  _dragEndHandler(e) {
    const d = Deferred();
    const dragEndEventArgs = this._getEventArgs(e);
    const dropEventArgs = this._getEventArgs(e);
    const targetDraggable2 = this._getTargetDraggable();
    let needRevertPosition = true;
    this.dragInProgress = false;
    try {
      this._getAction("onDragEnd")(dragEndEventArgs);
    } finally {
      when(fromPromise(dragEndEventArgs.cancel)).done((cancel) => {
        if (!cancel) {
          if (targetDraggable2 !== this) {
            targetDraggable2._getAction("onDrop")(dropEventArgs);
          }
          if (!dropEventArgs.cancel) {
            needRevertPosition = false;
            when(fromPromise(targetDraggable2.dragEnd(dragEndEventArgs))).always(d.resolve);
            return;
          }
        }
        d.resolve();
      }).fail(d.resolve);
      d.done(() => {
        if (needRevertPosition) {
          this._revertItemToInitialPosition();
        }
        this._resetDragOptions(targetDraggable2);
      });
    }
  },
  _isTargetOverAnotherDraggable(e) {
    const sourceDraggable2 = this._getSourceDraggable();
    if (this === sourceDraggable2) {
      return false;
    }
    const $dragElement = sourceDraggable2._$dragElement;
    const $sourceDraggableElement = sourceDraggable2.$element();
    const $targetDraggableElement = this.$element();
    const mousePosition = getMousePosition(e);
    const elements = dom_adapter_default.elementsFromPoint(mousePosition.x, mousePosition.y, this.element());
    const firstWidgetElement = elements.filter((element) => {
      const $element = renderer_default(element);
      if ($element.hasClass(this._addWidgetPrefix())) {
        return !$element.closest($dragElement).length;
      }
      return false;
    })[0];
    const $sourceElement = this._getSourceElement();
    const isTargetOverItself = firstWidgetElement === $sourceDraggableElement.get(0);
    const isTargetOverNestedDraggable = renderer_default(firstWidgetElement).closest($sourceElement).length;
    return !firstWidgetElement || firstWidgetElement === $targetDraggableElement.get(0) && !isTargetOverItself && !isTargetOverNestedDraggable;
  },
  _dragEnterHandler(e) {
    this._fireDragEnterEvent(e);
    if (this._isTargetOverAnotherDraggable(e)) {
      this._setTargetDraggable();
    }
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2.dragEnter(e);
  },
  _dragLeaveHandler(e) {
    this._fireDragLeaveEvent(e);
    this._resetTargetDraggable();
    if (this !== this._getSourceDraggable()) {
      this.reset();
    }
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2.dragLeave(e);
  },
  _keydownHandler(e) {
    if (this.dragInProgress && "Escape" === e.key) {
      this._keydownEscapeHandler(e);
    }
  },
  _keydownEscapeHandler(e) {
    var _sourceDraggable;
    const $sourceElement = this._getSourceElement();
    if (!$sourceElement) {
      return;
    }
    const dragCancelEventArgs = this._getEventArgs(e);
    this._getAction("onDragCancel")(dragCancelEventArgs);
    if (dragCancelEventArgs.cancel) {
      return;
    }
    this.dragInProgress = false;
    null === (_sourceDraggable = sourceDraggable) || void 0 === _sourceDraggable || _sourceDraggable._toggleDraggingClass(false);
    this._detachEventHandlers();
    this._revertItemToInitialPosition();
    const targetDraggable2 = this._getTargetDraggable();
    this._resetDragOptions(targetDraggable2);
    this._attachEventHandlers();
  },
  _getAction(name2) {
    return this[`_${name2}Action`] || this._createActionByOption(name2);
  },
  _getAnonymousTemplateName: () => "content",
  _initTemplates() {
    if (!this.option("contentTemplate")) {
      return;
    }
    this._templateManager.addDefaultTemplates({
      content: new EmptyTemplate()
    });
    this.callBase.apply(this, arguments);
  },
  _render() {
    this.callBase();
    this.$element().addClass(this._addWidgetPrefix());
    const transclude = this._templateManager.anonymousTemplateName === this.option("contentTemplate");
    const template = this._getTemplateByOption("contentTemplate");
    if (template) {
      renderer_default(template.render({
        container: this.element(),
        transclude
      }));
    }
  },
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "onDragStart":
      case "onDragMove":
      case "onDragEnd":
      case "onDrop":
      case "onDragEnter":
      case "onDragLeave":
      case "onDragCancel":
      case "onDraggableElementShown":
        this[`_${name2}Action`] = this._createActionByOption(name2);
        break;
      case "dragTemplate":
      case "contentTemplate":
      case "container":
      case "clone":
      case "scrollSensitivity":
      case "scrollSpeed":
      case "boundOffset":
      case "handle":
      case "group":
      case "data":
      case "itemData":
        break;
      case "allowMoveByClick":
      case "dragDirection":
      case "disabled":
      case "boundary":
      case "filter":
      case "immediate":
        this._resetDragElement();
        this._detachEventHandlers();
        this._attachEventHandlers();
        break;
      case "onCancelByEsc":
        this._keydownHandler();
        break;
      case "autoScroll":
        this._verticalScrollHelper.reset();
        this._horizontalScrollHelper.reset();
        break;
      default:
        this.callBase(args);
    }
  },
  _getTargetDraggable() {
    return targetDraggable || this;
  },
  _getSourceDraggable() {
    return sourceDraggable || this;
  },
  _setTargetDraggable() {
    const currentGroup = this.option("group");
    const sourceDraggable2 = this._getSourceDraggable();
    if (currentGroup && currentGroup === sourceDraggable2.option("group")) {
      targetDraggable = this;
    }
  },
  _setSourceDraggable() {
    sourceDraggable = this;
  },
  _resetSourceDraggable() {
    sourceDraggable = null;
  },
  _resetTargetDraggable() {
    targetDraggable = null;
  },
  _resetDragOptions(targetDraggable2) {
    this.reset();
    targetDraggable2.reset();
    this._stopAnimator();
    this._horizontalScrollHelper.reset();
    this._verticalScrollHelper.reset();
    this._resetDragElement();
    this._resetSourceElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
  },
  _dispose() {
    this.callBase();
    this._detachEventHandlers();
    this._resetDragElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
    this._$sourceElement = null;
    this._stopAnimator();
  },
  _fireDragEnterEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onDragEnter")(args);
  },
  _fireDragLeaveEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onDragLeave")(args);
  }
});
component_registrator_default(DRAGGABLE, Draggable);
var m_draggable_default = Draggable;

// ../../../../../../node_modules/devextreme/esm/ui/draggable.js
var draggable_default = m_draggable_default;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/utils/is_scheduler_component.js
function isSchedulerComponent(component) {
  return "dxScheduler" === component.NAME;
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_appointment_drag_behavior.js
var APPOINTMENT_ITEM_CLASS2 = "dx-scheduler-appointment";
var AppointmentDragBehavior = class {
  constructor(scheduler) {
    this.scheduler = scheduler;
    this.workspace = this.scheduler._workSpace;
    this.appointments = this.scheduler._appointments;
    this.initialPosition = {
      left: 0,
      top: 0
    };
    this.appointmentInfo = null;
    this.dragBetweenComponentsPromise = null;
  }
  isAllDay(appointment) {
    return appointment.data("dxAppointmentSettings").allDay;
  }
  onDragStart(e) {
    const {
      itemSettings,
      itemData,
      initialPosition
    } = e;
    this.initialPosition = initialPosition;
    this.appointmentInfo = {
      appointment: itemData,
      settings: itemSettings
    };
    this.appointments.notifyObserver("hideAppointmentTooltip");
  }
  onDragMove(e) {
    if (e.fromComponent !== e.toComponent) {
      this.appointments.notifyObserver("removeDroppableCellClass");
    }
  }
  getAppointmentElement(e) {
    const itemElement = e.event.data && e.event.data.itemElement || e.itemElement;
    return renderer_default(itemElement);
  }
  onDragEnd(event) {
    const element = this.getAppointmentElement(event);
    const rawAppointment = this.appointments._getItemData(element);
    const container = this.appointments._getAppointmentContainer(this.isAllDay(element));
    container.append(element);
    const newCellIndex = this.workspace.getDroppableCellIndex();
    const oldCellIndex = this.workspace.getCellIndexByCoordinates(this.initialPosition);
    this.appointments.notifyObserver("updateAppointmentAfterDrag", {
      event,
      element,
      rawAppointment,
      newCellIndex,
      oldCellIndex
    });
  }
  onDragCancel() {
    this.removeDroppableClasses();
  }
  getItemData(appointmentElement) {
    const dataFromTooltip = renderer_default(appointmentElement).data(LIST_ITEM_DATA_KEY);
    const itemDataFromTooltip = null === dataFromTooltip || void 0 === dataFromTooltip ? void 0 : dataFromTooltip.appointment;
    const itemDataFromGrid = this.appointments._getItemData(appointmentElement);
    return itemDataFromTooltip || itemDataFromGrid;
  }
  getItemSettings(appointment) {
    const itemData = renderer_default(appointment).data(LIST_ITEM_DATA_KEY);
    return itemData && itemData.settings || [];
  }
  createDragStartHandler(options, appointmentDragging) {
    return (e) => {
      e.itemData = this.getItemData(e.itemElement);
      e.itemSettings = this.getItemSettings(e.itemElement);
      appointmentDragging.onDragStart && appointmentDragging.onDragStart(e);
      if (!e.cancel) {
        options.onDragStart(e);
      }
    };
  }
  createDragMoveHandler(options, appointmentDragging) {
    return (e) => {
      appointmentDragging.onDragMove && appointmentDragging.onDragMove(e);
      if (!e.cancel) {
        options.onDragMove(e);
      }
    };
  }
  createDragEndHandler(options, appointmentDragging) {
    return (e) => {
      const updatedData = this.appointments.invoke("getUpdatedData", e.itemData);
      this.appointmentInfo = null;
      e.toItemData = extend({}, e.itemData, updatedData);
      appointmentDragging.onDragEnd && appointmentDragging.onDragEnd(e);
      if (!e.cancel) {
        options.onDragEnd(e);
        if (e.fromComponent !== e.toComponent) {
          appointmentDragging.onRemove && appointmentDragging.onRemove(e);
        }
      }
      if (true === e.cancel) {
        this.removeDroppableClasses();
      }
      if (true !== e.cancel && isSchedulerComponent(e.toComponent)) {
        const targetDragBehavior = e.toComponent._getDragBehavior();
        targetDragBehavior.dragBetweenComponentsPromise = new Deferred();
      }
    };
  }
  createDropHandler(appointmentDragging) {
    return (e) => {
      const updatedData = this.appointments.invoke("getUpdatedData", e.itemData);
      e.itemData = extend({}, e.itemData, updatedData);
      if (e.fromComponent !== e.toComponent) {
        appointmentDragging.onAdd && appointmentDragging.onAdd(e);
      }
      if (this.dragBetweenComponentsPromise) {
        this.dragBetweenComponentsPromise.resolve();
      }
    };
  }
  addTo(container, config) {
    const appointmentDragging = this.scheduler.option("appointmentDragging") || {};
    const options = extend({
      component: this.scheduler,
      contentTemplate: null,
      filter: `.${APPOINTMENT_ITEM_CLASS2}`,
      immediate: false,
      onDragStart: this.onDragStart.bind(this),
      onDragMove: this.onDragMove.bind(this),
      onDragEnd: this.onDragEnd.bind(this),
      onDragCancel: this.onDragCancel.bind(this)
    }, config);
    this.appointments._createComponent(container, draggable_default, extend({}, options, appointmentDragging, {
      onDragStart: this.createDragStartHandler(options, appointmentDragging),
      onDragMove: this.createDragMoveHandler(options, appointmentDragging),
      onDragEnd: this.createDragEndHandler(options, appointmentDragging),
      onDrop: this.createDropHandler(appointmentDragging),
      onCancelByEsc: true
    }));
  }
  updateDragSource(appointment, settings) {
    const {
      appointmentInfo
    } = this;
    if (appointmentInfo || appointment) {
      const currentAppointment = appointment || appointmentInfo.appointment;
      const currentSettings = settings || appointmentInfo.settings;
      this.appointments._setDragSourceAppointment(currentAppointment, currentSettings);
    }
  }
  removeDroppableClasses() {
    this.appointments._removeDragSourceClassFromDraggedAppointment();
    this.workspace.removeDroppableCellClass();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/shaders/m_current_time_shader.js
var DATE_TIME_SHADER_CLASS = "dx-scheduler-date-time-shader";
var CurrentTimeShader = class {
  constructor(_workSpace) {
    this._workSpace = _workSpace;
    this._$container = this._workSpace._dateTableScrollable.$content();
  }
  render() {
    this.initShaderElements();
    this.renderShader();
    this._shader.forEach((shader) => {
      this._$container.append(shader);
    });
  }
  initShaderElements() {
    this._$shader = this.createShader();
    this._shader = [];
    this._shader.push(this._$shader);
  }
  renderShader() {
  }
  createShader() {
    return renderer_default("<div>").addClass(DATE_TIME_SHADER_CLASS);
  }
  clean() {
    this._$container && this._$container.find(`.${DATE_TIME_SHADER_CLASS}`).remove();
  }
};
var m_current_time_shader_default = CurrentTimeShader;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/shaders/m_current_time_shader_vertical.js
var DATE_TIME_SHADER_ALL_DAY_CLASS = "dx-scheduler-date-time-shader-all-day";
var DATE_TIME_SHADER_TOP_CLASS = "dx-scheduler-date-time-shader-top";
var DATE_TIME_SHADER_BOTTOM_CLASS = "dx-scheduler-date-time-shader-bottom";
var VerticalCurrentTimeShader = class extends m_current_time_shader_default {
  renderShader() {
    let shaderHeight = this._getShaderHeight();
    const maxHeight = this._getShaderMaxHeight();
    const isSolidShader = shaderHeight > maxHeight;
    if (shaderHeight > maxHeight) {
      shaderHeight = maxHeight;
    }
    setHeight(this._$shader, shaderHeight);
    const groupCount = this._workSpace._getGroupCount() || 1;
    if (this._workSpace.isGroupedByDate()) {
      this._renderGroupedByDateShaderParts(groupCount, shaderHeight, maxHeight, isSolidShader);
    } else {
      this._renderShaderParts(groupCount, shaderHeight, maxHeight, isSolidShader);
    }
  }
  _renderShaderParts(groupCount, shaderHeight, maxHeight, isSolidShader) {
    for (let i = 0; i < groupCount; i++) {
      const shaderWidth = this._getShaderWidth(i);
      this._renderTopShader(this._$shader, shaderHeight, shaderWidth, i);
      !isSolidShader && this._renderBottomShader(this._$shader, maxHeight, shaderHeight, shaderWidth, i);
      this._renderAllDayShader(shaderWidth, i);
    }
  }
  _renderGroupedByDateShaderParts(groupCount, shaderHeight, maxHeight, isSolidShader) {
    const shaderWidth = this._getShaderWidth(0);
    let bottomShaderWidth = shaderWidth - this._workSpace.getCellWidth();
    if (shaderHeight < 0) {
      shaderHeight = 0;
      bottomShaderWidth = shaderWidth;
    }
    this._renderTopShader(this._$shader, shaderHeight, shaderWidth * groupCount, 0);
    !isSolidShader && this._renderBottomShader(this._$shader, maxHeight, shaderHeight, bottomShaderWidth * groupCount + this._workSpace.getCellWidth(), 0);
    this._renderAllDayShader(shaderWidth * groupCount, 0);
  }
  _renderTopShader($shader, height, width, i) {
    this._$topShader = renderer_default("<div>").addClass(DATE_TIME_SHADER_TOP_CLASS);
    if (width) {
      setWidth(this._$topShader, width);
    }
    if (height) {
      setHeight(this._$topShader, height);
    }
    this._$topShader.css("marginTop", this._getShaderTopOffset(i));
    this._$topShader.css("left", this._getShaderOffset(i, width));
    $shader.append(this._$topShader);
  }
  _renderBottomShader($shader, maxHeight, height, width, i) {
    this._$bottomShader = renderer_default("<div>").addClass(DATE_TIME_SHADER_BOTTOM_CLASS);
    const shaderWidth = height < 0 ? width : width - this._workSpace.getCellWidth();
    const shaderHeight = height < 0 ? maxHeight : maxHeight - height;
    setWidth(this._$bottomShader, shaderWidth);
    setHeight(this._$bottomShader, shaderHeight);
    this._$bottomShader.css("left", this._getShaderOffset(i, width - this._workSpace.getCellWidth()));
    $shader.append(this._$bottomShader);
  }
  _renderAllDayShader(shaderWidth, i) {
    if (this._workSpace.option("showAllDayPanel")) {
      this._$allDayIndicator = renderer_default("<div>").addClass(DATE_TIME_SHADER_ALL_DAY_CLASS);
      setHeight(this._$allDayIndicator, this._workSpace.getAllDayHeight());
      setWidth(this._$allDayIndicator, shaderWidth);
      this._$allDayIndicator.css("left", this._getShaderOffset(i, shaderWidth));
      this._workSpace._$allDayPanel.prepend(this._$allDayIndicator);
    }
  }
  _getShaderOffset(i, width) {
    return this._workSpace.getGroupedStrategy().getShaderOffset(i, width);
  }
  _getShaderTopOffset(i) {
    return this._workSpace.getGroupedStrategy().getShaderTopOffset(i);
  }
  _getShaderHeight() {
    return this._workSpace.getGroupedStrategy().getShaderHeight();
  }
  _getShaderMaxHeight() {
    return this._workSpace.getGroupedStrategy().getShaderMaxHeight();
  }
  _getShaderWidth(i) {
    return this._workSpace.getGroupedStrategy().getShaderWidth(i);
  }
  clean() {
    super.clean();
    this._workSpace && this._workSpace._$allDayPanel && this._workSpace._$allDayPanel.find(`.${DATE_TIME_SHADER_ALL_DAY_CLASS}`).remove();
  }
};
var m_current_time_shader_vertical_default = VerticalCurrentTimeShader;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_cache.js
var Cache2 = class {
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._cache.size;
  }
  clear() {
    this._cache.clear();
  }
  get(name2, callback) {
    if (!this._cache.has(name2) && callback) {
      this.set(name2, callback());
    }
    return this._cache.get(name2);
  }
  set(name2, value2) {
    isDefined(value2) && this._cache.set(name2, value2);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_cells_selection_controller.js
var CellsSelectionController = class {
  handleArrowClick(options) {
    const {
      key,
      focusedCellPosition,
      edgeIndices,
      getCellDataByPosition,
      isAllDayPanelCell
    } = options;
    let nextCellIndices;
    switch (key) {
      case "down":
        nextCellIndices = this.getCellFromNextRowPosition(focusedCellPosition, "next", edgeIndices);
        break;
      case "up":
        nextCellIndices = this.getCellFromNextRowPosition(focusedCellPosition, "prev", edgeIndices);
        break;
      case "left":
        nextCellIndices = this.getCellFromNextColumnPosition(_extends({}, options, {
          direction: "prev"
        }));
        break;
      case "right":
        nextCellIndices = this.getCellFromNextColumnPosition(_extends({}, options, {
          direction: "next"
        }));
    }
    const currentCellData = getCellDataByPosition(nextCellIndices.rowIndex, nextCellIndices.columnIndex, isAllDayPanelCell);
    return this.moveToCell(_extends({}, options, {
      currentCellData
    }));
  }
  getCellFromNextRowPosition(focusedCellPosition, direction, edgeIndices) {
    const {
      columnIndex,
      rowIndex
    } = focusedCellPosition;
    const deltaPosition = "next" === direction ? 1 : -1;
    const nextRowIndex = rowIndex + deltaPosition;
    const validRowIndex = nextRowIndex >= 0 && nextRowIndex <= edgeIndices.lastRowIndex ? nextRowIndex : rowIndex;
    return {
      columnIndex,
      rowIndex: validRowIndex
    };
  }
  getCellFromNextColumnPosition(options) {
    const {
      focusedCellPosition,
      direction,
      edgeIndices,
      isRTL,
      isGroupedByDate,
      groupCount,
      isMultiSelection,
      viewType
    } = options;
    const {
      columnIndex,
      rowIndex
    } = focusedCellPosition;
    const {
      firstColumnIndex,
      lastColumnIndex,
      firstRowIndex,
      lastRowIndex
    } = edgeIndices;
    const step = isGroupedByDate && isMultiSelection ? groupCount : 1;
    const sign2 = isRTL ? -1 : 1;
    const deltaColumnIndex = "next" === direction ? sign2 * step : -1 * sign2 * step;
    const nextColumnIndex = columnIndex + deltaColumnIndex;
    const isValidColumnIndex = nextColumnIndex >= firstColumnIndex && nextColumnIndex <= lastColumnIndex;
    if (isValidColumnIndex) {
      return {
        columnIndex: nextColumnIndex,
        rowIndex
      };
    }
    return isDateAndTimeView(viewType) ? focusedCellPosition : this._processEdgeCell({
      nextColumnIndex,
      rowIndex,
      columnIndex,
      firstColumnIndex,
      lastColumnIndex,
      firstRowIndex,
      lastRowIndex,
      step
    });
  }
  _processEdgeCell(options) {
    const {
      nextColumnIndex,
      rowIndex,
      columnIndex,
      firstColumnIndex,
      lastColumnIndex,
      firstRowIndex,
      lastRowIndex,
      step
    } = options;
    let validColumnIndex = nextColumnIndex;
    let validRowIndex = rowIndex;
    const isLeftEdgeCell = nextColumnIndex < firstColumnIndex;
    const isRightEdgeCell = nextColumnIndex > lastColumnIndex;
    if (isLeftEdgeCell) {
      const columnIndexInNextRow = lastColumnIndex - (step - columnIndex % step - 1);
      const nextRowIndex = rowIndex - 1;
      const isValidRowIndex = nextRowIndex >= firstRowIndex;
      validRowIndex = isValidRowIndex ? nextRowIndex : rowIndex;
      validColumnIndex = isValidRowIndex ? columnIndexInNextRow : columnIndex;
    }
    if (isRightEdgeCell) {
      const columnIndexInNextRow = firstColumnIndex + columnIndex % step;
      const nextRowIndex = rowIndex + 1;
      const isValidRowIndex = nextRowIndex <= lastRowIndex;
      validRowIndex = isValidRowIndex ? nextRowIndex : rowIndex;
      validColumnIndex = isValidRowIndex ? columnIndexInNextRow : columnIndex;
    }
    return {
      columnIndex: validColumnIndex,
      rowIndex: validRowIndex
    };
  }
  moveToCell(options) {
    const {
      isMultiSelection,
      isMultiSelectionAllowed,
      focusedCellData,
      currentCellData
    } = options;
    const isValidMultiSelection = isMultiSelection && isMultiSelectionAllowed;
    const nextFocusedCellData = isValidMultiSelection ? this._getNextCellData(currentCellData, focusedCellData) : currentCellData;
    return nextFocusedCellData;
  }
  _getNextCellData(nextFocusedCellData, focusedCellData, isVirtualCell) {
    if (isVirtualCell) {
      return focusedCellData;
    }
    const isValidNextFocusedCell = this._isValidNextFocusedCell(nextFocusedCellData, focusedCellData);
    return isValidNextFocusedCell ? nextFocusedCellData : focusedCellData;
  }
  _isValidNextFocusedCell(nextFocusedCellData, focusedCellData) {
    if (!focusedCellData) {
      return true;
    }
    const {
      groupIndex,
      allDay
    } = focusedCellData;
    const {
      groupIndex: nextGroupIndex,
      allDay: nextAllDay
    } = nextFocusedCellData;
    return groupIndex === nextGroupIndex && allDay === nextAllDay;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_cells_selection_state.js
var CellsSelectionState = class {
  constructor(_viewDataProvider) {
    this._viewDataProvider = _viewDataProvider;
    this._focusedCell = null;
    this._selectedCells = null;
    this._firstSelectedCell = null;
    this._prevFocusedCell = null;
    this._prevSelectedCells = null;
  }
  get viewDataProvider() {
    return this._viewDataProvider;
  }
  get focusedCell() {
    const focusedCell = this._focusedCell;
    if (!focusedCell) {
      return;
    }
    const {
      groupIndex,
      startDate,
      allDay
    } = focusedCell;
    const cellInfo = {
      groupIndex,
      startDate,
      isAllDay: allDay,
      index: focusedCell.index
    };
    const cellPosition = this.viewDataProvider.findCellPositionInMap(cellInfo);
    return {
      coordinates: cellPosition,
      cellData: focusedCell
    };
  }
  setFocusedCell(rowIndex, columnIndex, isAllDay) {
    if (rowIndex >= 0) {
      const cell = this._viewDataProvider.getCellData(rowIndex, columnIndex, isAllDay);
      this._focusedCell = cell;
    }
  }
  setSelectedCells(lastCellCoordinates) {
    let firstCellCoordinates = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
    const viewDataProvider = this._viewDataProvider;
    const {
      rowIndex: lastRowIndex,
      columnIndex: lastColumnIndex,
      allDay: isLastCellAllDay
    } = lastCellCoordinates;
    if (lastRowIndex < 0) {
      return;
    }
    const firstCell = firstCellCoordinates ? viewDataProvider.getCellData(firstCellCoordinates.rowIndex, firstCellCoordinates.columnIndex, firstCellCoordinates.allDay) : this._firstSelectedCell;
    const lastCell = viewDataProvider.getCellData(lastRowIndex, lastColumnIndex, isLastCellAllDay);
    this._firstSelectedCell = firstCell;
    this._selectedCells = this._viewDataProvider.getCellsBetween(firstCell, lastCell);
  }
  setSelectedCellsByData(selectedCellsData) {
    this._selectedCells = selectedCellsData;
  }
  getSelectedCells() {
    return this._selectedCells;
  }
  releaseSelectedAndFocusedCells() {
    this.releaseSelectedCells();
    this.releaseFocusedCell();
  }
  releaseSelectedCells() {
    this._prevSelectedCells = this._selectedCells;
    this._prevFirstSelectedCell = this._firstSelectedCell;
    this._selectedCells = null;
    this._firstSelectedCell = null;
  }
  releaseFocusedCell() {
    this._prevFocusedCell = this._focusedCell;
    this._focusedCell = null;
  }
  restoreSelectedAndFocusedCells() {
    this._selectedCells = this._selectedCells || this._prevSelectedCells;
    this._focusedCell = this._focusedCell || this._prevFocusedCell;
    this._firstSelectedCell = this._firstSelectedCell || this._prevFirstSelectedCell;
    this._prevSelectedCells = null;
    this._prevFirstSelectedCell = null;
    this._prevFocusedCell = null;
  }
  clearSelectedAndFocusedCells() {
    this._prevSelectedCells = null;
    this._selectedCells = null;
    this._prevFocusedCell = null;
    this._focusedCell = null;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_virtual_scrolling.js
var DOCUMENT_SCROLL_EVENT_NAMESPACE = addNamespace("scroll", "dxSchedulerVirtualScrolling");
var scrollingOrientations = {
  vertical: "vertical",
  horizontal: "horizontal",
  both: "both",
  none: "none"
};
var DefaultScrollingOrientation = scrollingOrientations.both;
var VirtualScrollingDispatcher = class {
  constructor(options) {
    this.options = options;
    if (options) {
      this._rowHeight = this.getCellHeight();
      this._cellWidth = this.getCellWidth();
      this._createVirtualScrollingBase();
    }
  }
  get isRTL() {
    return this.options.isRTL();
  }
  get verticalVirtualScrolling() {
    return this._verticalVirtualScrolling;
  }
  set verticalVirtualScrolling(value2) {
    this._verticalVirtualScrolling = value2;
  }
  get horizontalVirtualScrolling() {
    return this._horizontalVirtualScrolling;
  }
  set horizontalVirtualScrolling(value2) {
    this._horizontalVirtualScrolling = value2;
  }
  get document() {
    return dom_adapter_default.getDocument();
  }
  get height() {
    return this.options.getSchedulerHeight();
  }
  get width() {
    return this.options.getSchedulerWidth();
  }
  get rowHeight() {
    return this._rowHeight;
  }
  set rowHeight(value2) {
    this._rowHeight = value2;
  }
  get outlineCount() {
    return this.options.getScrolling().outlineCount;
  }
  get cellWidth() {
    return this._cellWidth;
  }
  set cellWidth(value2) {
    this._cellWidth = value2;
  }
  get viewportWidth() {
    const width = this.width && this.options.getViewWidth();
    return width > 0 ? width : this.options.getWindowWidth();
  }
  get viewportHeight() {
    const height = this.height && this.options.getViewHeight();
    return height > 0 ? height : this.options.getWindowHeight();
  }
  get cellCountInsideTopVirtualRow() {
    var _this$verticalScrolli;
    return (null === (_this$verticalScrolli = this.verticalScrollingState) || void 0 === _this$verticalScrolli ? void 0 : _this$verticalScrolli.virtualItemCountBefore) || 0;
  }
  get cellCountInsideLeftVirtualCell() {
    var _this$horizontalScrol;
    return (null === (_this$horizontalScrol = this.horizontalScrollingState) || void 0 === _this$horizontalScrol ? void 0 : _this$horizontalScrol.virtualItemCountBefore) || 0;
  }
  get cellCountInsideRightVirtualCell() {
    var _this$horizontalScrol2;
    return (null === (_this$horizontalScrol2 = this.horizontalScrollingState) || void 0 === _this$horizontalScrol2 ? void 0 : _this$horizontalScrol2.virtualItemCountAfter) || 0;
  }
  get topVirtualRowsCount() {
    return this.cellCountInsideTopVirtualRow > 0 ? 1 : 0;
  }
  get leftVirtualCellsCount() {
    const virtualItemsCount = !this.isRTL ? this.cellCountInsideLeftVirtualCell : this.cellCountInsideRightVirtualCell;
    return Math.ceil(virtualItemsCount / 1e3);
  }
  get virtualRowOffset() {
    var _this$verticalScrolli2;
    return (null === (_this$verticalScrolli2 = this.verticalScrollingState) || void 0 === _this$verticalScrolli2 ? void 0 : _this$verticalScrolli2.virtualItemSizeBefore) || 0;
  }
  get virtualCellOffset() {
    var _this$horizontalScrol3;
    return (null === (_this$horizontalScrol3 = this.horizontalScrollingState) || void 0 === _this$horizontalScrol3 ? void 0 : _this$horizontalScrol3.virtualItemSizeBefore) || 0;
  }
  get scrollingState() {
    var _this$verticalVirtual, _this$horizontalVirtu;
    return {
      vertical: null === (_this$verticalVirtual = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual ? void 0 : _this$verticalVirtual.state,
      horizontal: null === (_this$horizontalVirtu = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu ? void 0 : _this$horizontalVirtu.state
    };
  }
  get verticalScrollingState() {
    return this.scrollingState.vertical;
  }
  get horizontalScrollingState() {
    return this.scrollingState.horizontal;
  }
  get scrollingOrientation() {
    const scrolling = this.options.getScrolling();
    if ("standard" === scrolling.mode) {
      return scrollingOrientations.none;
    }
    return scrolling.orientation || DefaultScrollingOrientation;
  }
  get verticalScrollingAllowed() {
    return this.scrollingOrientation === scrollingOrientations.vertical || this.scrollingOrientation === scrollingOrientations.both;
  }
  get horizontalScrollingAllowed() {
    return this.scrollingOrientation === scrollingOrientations.horizontal || this.scrollingOrientation === scrollingOrientations.both;
  }
  setViewOptions(options) {
    this.options = options;
    if (this.verticalVirtualScrolling) {
      this.verticalVirtualScrolling.options = options;
      this.verticalVirtualScrolling.itemSize = this.rowHeight;
      this.verticalVirtualScrolling.viewportSize = this.viewportHeight;
    }
    if (this.horizontalVirtualScrolling) {
      this.horizontalVirtualScrolling.options = options;
      this.verticalVirtualScrolling.itemSize = this.cellWidth;
      this.verticalVirtualScrolling.viewportSize = this.viewportWidth;
    }
  }
  getRenderState() {
    var _this$verticalVirtual2, _this$horizontalVirtu2;
    const verticalRenderState = (null === (_this$verticalVirtual2 = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual2 ? void 0 : _this$verticalVirtual2.getRenderState()) || {};
    const horizontalRenderState = (null === (_this$horizontalVirtu2 = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu2 ? void 0 : _this$horizontalVirtu2.getRenderState()) || {};
    return _extends({}, verticalRenderState, horizontalRenderState);
  }
  getCellHeight() {
    const cellHeight = this.options.getCellHeight();
    const result = cellHeight > 0 ? cellHeight : 50;
    return Math.floor(result);
  }
  getCellWidth() {
    let cellWidth = this.options.getCellWidth();
    const minCellWidth = this.options.getCellMinWidth();
    if (!cellWidth || cellWidth < minCellWidth) {
      cellWidth = minCellWidth;
    }
    const result = cellWidth > 0 ? cellWidth : 1;
    return Math.floor(result);
  }
  calculateCoordinatesByDataAndPosition(cellData, position, date, isCalculateTime, isVerticalDirectionView) {
    const {
      rowIndex,
      columnIndex
    } = position;
    const {
      startDate,
      endDate,
      allDay
    } = cellData;
    const timeToScroll = date.getTime();
    const cellStartTime = startDate.getTime();
    const cellEndTime = endDate.getTime();
    const scrollInCell = allDay || !isCalculateTime ? 0 : (timeToScroll - cellStartTime) / (cellEndTime - cellStartTime);
    const cellWidth = this.getCellWidth();
    const rowHeight = this.getCellHeight();
    const top = isVerticalDirectionView ? (rowIndex + scrollInCell) * rowHeight : rowIndex * rowHeight;
    let left = isVerticalDirectionView ? columnIndex * cellWidth : (columnIndex + scrollInCell) * cellWidth;
    if (this.isRTL) {
      left = this.options.getScrollableOuterWidth() - left;
    }
    return {
      top,
      left
    };
  }
  dispose() {
    if (this._onScrollHandler) {
      events_engine_default.off(this.document, DOCUMENT_SCROLL_EVENT_NAMESPACE, this._onScrollHandler);
    }
  }
  createVirtualScrolling() {
    const isVerticalVirtualScrollingCreated = !!this.verticalVirtualScrolling;
    const isHorizontalVirtualScrollingCreated = !!this.horizontalVirtualScrolling;
    if (this.verticalScrollingAllowed !== isVerticalVirtualScrollingCreated || this.horizontalScrollingAllowed !== isHorizontalVirtualScrollingCreated) {
      this._rowHeight = this.getCellHeight();
      this._cellWidth = this.getCellWidth();
      this._createVirtualScrollingBase();
    }
  }
  _createVirtualScrollingBase() {
    if (this.verticalScrollingAllowed) {
      this.verticalVirtualScrolling = new VerticalVirtualScrolling(_extends({}, this.options, {
        viewportHeight: this.viewportHeight,
        rowHeight: this.rowHeight,
        outlineCount: this.outlineCount
      }));
    }
    if (this.horizontalScrollingAllowed) {
      this.horizontalVirtualScrolling = new HorizontalVirtualScrolling(_extends({}, this.options, {
        viewportWidth: this.viewportWidth,
        cellWidth: this.cellWidth,
        outlineCount: this.outlineCount
      }));
    }
  }
  isAttachWindowScrollEvent() {
    return (this.horizontalScrollingAllowed || this.verticalScrollingAllowed) && !this.height;
  }
  attachScrollableEvents() {
    if (this.isAttachWindowScrollEvent()) {
      this._attachWindowScroll();
    }
  }
  _attachWindowScroll() {
    const window3 = getWindow();
    this._onScrollHandler = this.options.createAction(() => {
      const {
        scrollX,
        scrollY
      } = window3;
      if (scrollX >= 10 || scrollY >= 10) {
        this.handleOnScrollEvent({
          left: scrollX,
          top: scrollY
        });
      }
    });
    events_engine_default.on(this.document, DOCUMENT_SCROLL_EVENT_NAMESPACE, this._onScrollHandler);
  }
  handleOnScrollEvent(scrollPosition) {
    if (scrollPosition) {
      var _this$verticalVirtual3, _this$horizontalVirtu3;
      const {
        left,
        top
      } = scrollPosition;
      const verticalStateChanged = isDefined(top) && (null === (_this$verticalVirtual3 = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual3 ? void 0 : _this$verticalVirtual3.updateState(top));
      const horizontalStateChanged = isDefined(left) && (null === (_this$horizontalVirtu3 = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu3 ? void 0 : _this$horizontalVirtu3.updateState(left));
      if (verticalStateChanged || horizontalStateChanged) {
        var _this$options$updateR, _this$options;
        null === (_this$options$updateR = (_this$options = this.options).updateRender) || void 0 === _this$options$updateR || _this$options$updateR.call(_this$options);
      }
    }
  }
  updateDimensions(isForce) {
    const cellHeight = this.getCellHeight();
    const needUpdateVertical = this.verticalScrollingAllowed && cellHeight !== this.rowHeight;
    if ((needUpdateVertical || isForce) && this.verticalVirtualScrolling) {
      this.rowHeight = cellHeight;
      this.verticalVirtualScrolling.viewportSize = this.viewportHeight;
      this.verticalVirtualScrolling.reinitState(cellHeight, isForce);
    }
    const cellWidth = this.getCellWidth();
    const needUpdateHorizontal = this.horizontalScrollingAllowed && cellWidth !== this.cellWidth;
    if ((needUpdateHorizontal || isForce) && this.horizontalVirtualScrolling) {
      this.cellWidth = cellWidth;
      this.horizontalVirtualScrolling.viewportSize = this.viewportWidth;
      this.horizontalVirtualScrolling.reinitState(cellWidth, isForce);
    }
    if (needUpdateVertical || needUpdateHorizontal) {
      var _this$options$updateG, _this$options2;
      null === (_this$options$updateG = (_this$options2 = this.options).updateGrid) || void 0 === _this$options$updateG || _this$options$updateG.call(_this$options2);
    }
  }
};
var VirtualScrollingBase = class {
  constructor(options) {
    this.options = options;
    this._state = this.defaultState;
    this.viewportSize = this.options.viewportSize;
    this._itemSize = this.options.itemSize;
    this._position = -1;
    this._itemSizeChanged = false;
    this.updateState(0);
  }
  get itemSize() {
    return this._itemSize;
  }
  set itemSize(value2) {
    this._itemSizeChanged = this._itemSize !== value2;
    this._itemSize = value2;
  }
  get state() {
    return this._state;
  }
  set state(value2) {
    this._state = value2;
  }
  get startIndex() {
    return this.state.startIndex;
  }
  get pageSize() {
    return Math.ceil(this.viewportSize / this.itemSize);
  }
  get outlineCount() {
    return isDefined(this.options.outlineCount) ? this.options.outlineCount : Math.floor(this.pageSize / 2);
  }
  get groupCount() {
    return this.options.getGroupCount();
  }
  get isVerticalGrouping() {
    return this.options.isVerticalGrouping();
  }
  get defaultState() {
    return {
      prevPosition: 0,
      startIndex: -1,
      itemCount: 0,
      virtualItemCountBefore: 0,
      virtualItemCountAfter: 0,
      outlineCountBefore: 0,
      outlineCountAfter: 0,
      virtualItemSizeBefore: 0,
      virtualItemSizeAfter: 0,
      outlineSizeBefore: 0,
      outlineSizeAfter: 0
    };
  }
  get maxScrollPosition() {
    return this.getTotalItemCount() * this.itemSize - this.viewportSize;
  }
  get position() {
    return this._position;
  }
  set position(value2) {
    this._position = value2;
  }
  needUpdateState(position) {
    const {
      prevPosition,
      startIndex
    } = this.state;
    const isFirstInitialization = startIndex < 0;
    if (isFirstInitialization) {
      return true;
    }
    let isStartIndexChanged = false;
    if (this._validateAndSavePosition(position)) {
      if (0 === position || position === this.maxScrollPosition) {
        return true;
      }
      const currentPosition = prevPosition;
      const currentItemsCount = Math.floor(currentPosition / this.itemSize);
      const itemsCount = Math.floor(position / this.itemSize);
      isStartIndexChanged = Math.abs(currentItemsCount - itemsCount) >= this.outlineCount;
    }
    return isStartIndexChanged;
  }
  _validateAndSavePosition(position) {
    if (!isDefined(position)) {
      return false;
    }
    const result = this.position !== position;
    this.position = position;
    return result;
  }
  _correctPosition(position) {
    return position >= 0 ? Math.min(position, this.maxScrollPosition) : -1;
  }
  updateState(position, isForce) {
    position = this._correctPosition(position);
    if (!this.needUpdateState(position) && !isForce) {
      return false;
    }
    const itemsInfoBefore = this._calcItemInfoBefore(position);
    const itemsDeltaBefore = this._calcItemDeltaBefore(itemsInfoBefore);
    const {
      outlineCountAfter,
      virtualItemCountAfter,
      itemCountWithAfter
    } = this._calcItemInfoAfter(itemsDeltaBefore);
    const {
      virtualItemCountBefore,
      outlineCountBefore
    } = itemsInfoBefore;
    const itemCount = outlineCountBefore + itemCountWithAfter + outlineCountAfter;
    const itemCountBefore = Math.floor(position / this.itemSize);
    this.state.prevPosition = itemCountBefore * this.itemSize;
    this.state.startIndex = itemCountBefore - outlineCountBefore;
    this.state.virtualItemCountBefore = virtualItemCountBefore;
    this.state.outlineCountBefore = outlineCountBefore;
    this.state.itemCount = itemCount;
    this.state.outlineCountAfter = outlineCountAfter;
    this.state.virtualItemCountAfter = virtualItemCountAfter;
    this._updateStateCore();
    return true;
  }
  reinitState(itemSize, isForceUpdate) {
    const {
      position
    } = this;
    this.itemSize = itemSize;
    this.updateState(0, isForceUpdate);
    if (position > 0) {
      this.updateState(position, isForceUpdate);
    }
  }
  _calcItemInfoBefore(position) {
    let virtualItemCountBefore = Math.floor(position / this.itemSize);
    const outlineCountBefore = Math.min(virtualItemCountBefore, this.outlineCount);
    virtualItemCountBefore -= outlineCountBefore;
    return {
      virtualItemCountBefore,
      outlineCountBefore
    };
  }
  _calcItemDeltaBefore(itemInfoBefore) {
    const {
      virtualItemCountBefore,
      outlineCountBefore
    } = itemInfoBefore;
    const totalItemCount = this.getTotalItemCount();
    return totalItemCount - virtualItemCountBefore - outlineCountBefore;
  }
  getTotalItemCount() {
    throw "getTotalItemCount method should be implemented";
  }
  getRenderState() {
    throw "getRenderState method should be implemented";
  }
  _calcItemInfoAfter(itemsDeltaBefore) {
    const itemCountWithAfter = itemsDeltaBefore >= this.pageSize ? this.pageSize : itemsDeltaBefore;
    let virtualItemCountAfter = itemsDeltaBefore - itemCountWithAfter;
    const outlineCountAfter = virtualItemCountAfter > 0 ? Math.min(virtualItemCountAfter, this.outlineCount) : 0;
    if (virtualItemCountAfter > 0) {
      virtualItemCountAfter -= outlineCountAfter;
    }
    return {
      virtualItemCountAfter,
      outlineCountAfter,
      itemCountWithAfter
    };
  }
  _updateStateCore() {
    const {
      state
    } = this;
    const {
      virtualItemCountBefore
    } = state;
    const {
      virtualItemCountAfter
    } = state;
    const {
      outlineCountBefore
    } = state;
    const {
      outlineCountAfter
    } = state;
    const prevVirtualItemSizeBefore = state.virtualItemSizeBefore;
    const prevVirtualItemSizeAfter = state.virtualItemSizeAfter;
    const prevOutlineSizeBefore = state.outlineSizeBefore;
    const prevOutlineSizeAfter = state.outlineSizeAfter;
    const virtualItemSizeBefore = this.itemSize * virtualItemCountBefore;
    const virtualItemSizeAfter = this.itemSize * virtualItemCountAfter;
    const outlineSizeBefore = this.itemSize * outlineCountBefore;
    const outlineSizeAfter = this.itemSize * outlineCountAfter;
    const prevVirtualSizeBefore = prevVirtualItemSizeBefore + prevOutlineSizeBefore;
    const virtualSizeBefore = virtualItemSizeBefore + outlineSizeBefore;
    const prevVirtualSizeAfter = prevVirtualItemSizeAfter + prevOutlineSizeAfter;
    const virtualSizeAfter = virtualItemSizeAfter + outlineSizeAfter;
    const isAppend = prevVirtualSizeBefore < virtualSizeBefore;
    const isPrepend = prevVirtualSizeAfter < virtualSizeAfter;
    const needAddItems = this._itemSizeChanged || isAppend || isPrepend;
    if (needAddItems) {
      this._updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter);
    }
  }
  _updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter) {
    const {
      state
    } = this;
    state.virtualItemSizeBefore = virtualItemSizeBefore;
    state.virtualItemSizeAfter = virtualItemSizeAfter;
  }
};
var VerticalVirtualScrolling = class extends VirtualScrollingBase {
  constructor(options) {
    super(_extends({}, options, {
      itemSize: options.rowHeight,
      viewportSize: options.viewportHeight
    }));
  }
  get prevTopPosition() {
    return this.state.prevPosition;
  }
  get rowCount() {
    return this.state.itemCount;
  }
  get topVirtualRowCount() {
    return this.state.virtualItemCountBefore;
  }
  get bottomVirtualRowCount() {
    return this.state.virtualItemCountAfter;
  }
  getTotalItemCount() {
    return this.options.getTotalRowCount(this.groupCount, this.isVerticalGrouping);
  }
  getRenderState() {
    return {
      topVirtualRowHeight: this.state.virtualItemSizeBefore,
      bottomVirtualRowHeight: this.state.virtualItemSizeAfter,
      startRowIndex: this.state.startIndex,
      rowCount: this.state.itemCount,
      startIndex: this.state.startIndex
    };
  }
};
var HorizontalVirtualScrolling = class extends VirtualScrollingBase {
  constructor(options) {
    super(_extends({}, options, {
      itemSize: options.cellWidth,
      viewportSize: options.viewportWidth
    }));
  }
  get isRTL() {
    return this.options.isRTL();
  }
  getTotalItemCount() {
    return this.options.getTotalCellCount(this.groupCount, this.isVerticalGrouping);
  }
  getRenderState() {
    return {
      leftVirtualCellWidth: this.state.virtualItemSizeBefore,
      rightVirtualCellWidth: this.state.virtualItemSizeAfter,
      startCellIndex: this.state.startIndex,
      cellCount: this.state.itemCount,
      cellWidth: this.itemSize
    };
  }
  _updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter) {
    if (!this.isRTL) {
      super._updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter);
    } else {
      const {
        state
      } = this;
      state.virtualItemSizeAfter = virtualItemSizeBefore;
      state.virtualItemSizeBefore = virtualItemSizeAfter;
      state.startIndex = this.getTotalItemCount() - this.startIndex - this.state.itemCount;
    }
  }
};
var VirtualScrollingRenderer = class {
  constructor(_workspace) {
    this._workspace = _workspace;
    this._renderAppointmentTimeoutID = null;
  }
  getRenderTimeout() {
    return 15;
  }
  get workspace() {
    return this._workspace;
  }
  updateRender() {
    this._renderGrid();
    this._renderAppointments();
  }
  _renderGrid() {
    this.workspace.renderWorkSpace(false);
  }
  _renderAppointments() {
    const renderTimeout = this.getRenderTimeout();
    if (renderTimeout >= 0) {
      clearTimeout(this._renderAppointmentTimeoutID);
      this._renderAppointmentTimeoutID = setTimeout(() => this.workspace.updateAppointments(), renderTimeout);
    } else {
      this.workspace.updateAppointments();
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/const.js
var WORK_SPACE_BORDER_PX = 1;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_grouped_strategy_horizontal.js
var HorizontalGroupedStrategy = class {
  constructor(_workSpace) {
    this._workSpace = _workSpace;
  }
  prepareCellIndexes(cellCoordinates, groupIndex, inAllDay) {
    const groupByDay = this._workSpace.isGroupedByDate();
    if (!groupByDay) {
      return {
        rowIndex: cellCoordinates.rowIndex,
        columnIndex: cellCoordinates.columnIndex + groupIndex * this._workSpace._getCellCount()
      };
    }
    return {
      rowIndex: cellCoordinates.rowIndex,
      columnIndex: cellCoordinates.columnIndex * this._workSpace._getGroupCount() + groupIndex
    };
  }
  getGroupIndex(rowIndex, columnIndex) {
    const groupByDay = this._workSpace.isGroupedByDate();
    const groupCount = this._workSpace._getGroupCount();
    if (groupByDay) {
      return columnIndex % groupCount;
    }
    return Math.floor(columnIndex / this._workSpace._getCellCount());
  }
  calculateHeaderCellRepeatCount() {
    return this._workSpace._getGroupCount() || 1;
  }
  insertAllDayRowsIntoDateTable() {
    return false;
  }
  getTotalCellCount(groupCount) {
    groupCount = groupCount || 1;
    return this._workSpace._getCellCount() * groupCount;
  }
  getTotalRowCount() {
    return this._workSpace._getRowCount();
  }
  calculateTimeCellRepeatCount() {
    return 1;
  }
  getWorkSpaceMinWidth() {
    const workSpaceElementWidth = getBoundingRect(this._workSpace.$element().get(0)).width;
    return workSpaceElementWidth - this._workSpace.getTimePanelWidth() - 2 * WORK_SPACE_BORDER_PX;
  }
  getAllDayOffset() {
    return this._workSpace.getAllDayHeight();
  }
  getGroupCountClass(groups) {
    return;
  }
  getLeftOffset() {
    return this._workSpace.getTimePanelWidth();
  }
  _createGroupBoundOffset(startCell, endCell, cellWidth) {
    const extraOffset = cellWidth / 2;
    const startOffset = startCell ? startCell.offset().left - extraOffset : 0;
    const endOffset = endCell ? endCell.offset().left + cellWidth + extraOffset : 0;
    return {
      left: startOffset,
      right: endOffset,
      top: 0,
      bottom: 0
    };
  }
  _getGroupedByDateBoundOffset($cells, cellWidth) {
    const lastCellIndex = $cells.length - 1;
    const startCell = $cells.eq(0);
    const endCell = $cells.eq(lastCellIndex);
    return this._createGroupBoundOffset(startCell, endCell, cellWidth);
  }
  getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap) {
    if (this._workSpace.isGroupedByDate()) {
      return this._getGroupedByDateBoundOffset($cells, cellWidth);
    }
    let startCell;
    let endCell;
    const cellIndex = this._workSpace.getCellIndexByCoordinates(coordinates);
    const groupIndex = coordinates.groupIndex || Math.floor(cellIndex / cellCount);
    const currentCellGroup = groupedDataMap.dateTableGroupedMap[groupIndex];
    if (currentCellGroup) {
      const groupRowLength = currentCellGroup[0].length;
      const groupStartPosition = currentCellGroup[0][0].position;
      const groupEndPosition = currentCellGroup[0][groupRowLength - 1].position;
      startCell = $cells.eq(groupStartPosition.columnIndex);
      endCell = $cells.eq(groupEndPosition.columnIndex);
    }
    return this._createGroupBoundOffset(startCell, endCell, cellWidth);
  }
  shiftIndicator($indicator, height, rtlOffset, groupIndex) {
    const offset = this._getIndicatorOffset(groupIndex);
    const horizontalOffset = rtlOffset ? rtlOffset - offset : offset;
    $indicator.css("left", horizontalOffset);
    $indicator.css("top", height);
  }
  _getIndicatorOffset(groupIndex) {
    const groupByDay = this._workSpace.isGroupedByDate();
    return groupByDay ? this._calculateGroupByDateOffset(groupIndex) : this._calculateOffset(groupIndex);
  }
  _calculateOffset(groupIndex) {
    const indicatorStartPosition = this._workSpace.getIndicatorOffset(groupIndex);
    const offset = this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex;
    return indicatorStartPosition + offset;
  }
  _calculateGroupByDateOffset(groupIndex) {
    return this._workSpace.getIndicatorOffset(0) * this._workSpace._getGroupCount() + this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex;
  }
  getShaderOffset(i, width) {
    const offset = this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(i - 1) * i;
    return this._workSpace.option("rtlEnabled") ? getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).width - offset - this._workSpace.getTimePanelWidth() - width : offset;
  }
  getShaderTopOffset(i) {
    return -this.getShaderMaxHeight() * (i > 0 ? 1 : 0);
  }
  getShaderHeight() {
    const height = this._workSpace.getIndicationHeight();
    return height;
  }
  getShaderMaxHeight() {
    return getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).height;
  }
  getShaderWidth(i) {
    return this._workSpace.getIndicationWidth(i);
  }
  getScrollableScrollTop(allDay) {
    return !allDay ? this._workSpace.getScrollable().scrollTop() : 0;
  }
  addAdditionalGroupCellClasses(cellClass, index, i, j) {
    let applyUnconditionally = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    cellClass = this._addLastGroupCellClass(cellClass, index, applyUnconditionally);
    return this._addFirstGroupCellClass(cellClass, index, applyUnconditionally);
  }
  _addLastGroupCellClass(cellClass, index, applyUnconditionally) {
    if (applyUnconditionally) {
      return `${cellClass} ${LAST_GROUP_CELL_CLASS}`;
    }
    const groupByDate = this._workSpace.isGroupedByDate();
    if (groupByDate) {
      if (index % this._workSpace._getGroupCount() === 0) {
        return `${cellClass} ${LAST_GROUP_CELL_CLASS}`;
      }
    } else if (index % this._workSpace._getCellCount() === 0) {
      return `${cellClass} ${LAST_GROUP_CELL_CLASS}`;
    }
    return cellClass;
  }
  _addFirstGroupCellClass(cellClass, index, applyUnconditionally) {
    if (applyUnconditionally) {
      return `${cellClass} ${FIRST_GROUP_CELL_CLASS}`;
    }
    const groupByDate = this._workSpace.isGroupedByDate();
    if (groupByDate) {
      if ((index - 1) % this._workSpace._getGroupCount() === 0) {
        return `${cellClass} ${FIRST_GROUP_CELL_CLASS}`;
      }
    } else if ((index - 1) % this._workSpace._getCellCount() === 0) {
      return `${cellClass} ${FIRST_GROUP_CELL_CLASS}`;
    }
    return cellClass;
  }
};
var m_work_space_grouped_strategy_horizontal_default = HorizontalGroupedStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_grouped_strategy_vertical.js
var VerticalGroupedStrategy = class {
  constructor(_workSpace) {
    this._workSpace = _workSpace;
    this.cache = new Cache2();
  }
  prepareCellIndexes(cellCoordinates, groupIndex, inAllDayRow) {
    let rowIndex = cellCoordinates.rowIndex + groupIndex * this._workSpace._getRowCount();
    if (this._workSpace.supportAllDayRow() && this._workSpace.option("showAllDayPanel")) {
      rowIndex += groupIndex;
      if (!inAllDayRow) {
        rowIndex += 1;
      }
    }
    return {
      rowIndex,
      columnIndex: cellCoordinates.columnIndex
    };
  }
  getGroupIndex(rowIndex) {
    return Math.floor(rowIndex / this._workSpace._getRowCount());
  }
  calculateHeaderCellRepeatCount() {
    return 1;
  }
  insertAllDayRowsIntoDateTable() {
    return this._workSpace.option("showAllDayPanel");
  }
  getTotalCellCount() {
    return this._workSpace._getCellCount();
  }
  getTotalRowCount() {
    return this._workSpace._getRowCount() * this._workSpace._getGroupCount();
  }
  calculateTimeCellRepeatCount() {
    return this._workSpace._getGroupCount() || 1;
  }
  getWorkSpaceMinWidth() {
    let minWidth = this._workSpace._getWorkSpaceWidth();
    const workSpaceElementWidth = getBoundingRect(this._workSpace.$element().get(0)).width;
    const workspaceContainerWidth = workSpaceElementWidth - this._workSpace.getTimePanelWidth() - this._workSpace.getGroupTableWidth() - 2 * WORK_SPACE_BORDER_PX;
    if (minWidth < workspaceContainerWidth) {
      minWidth = workspaceContainerWidth;
    }
    return minWidth;
  }
  getAllDayOffset() {
    return 0;
  }
  getGroupCountClass(groups) {
    return getVerticalGroupCountClass(groups);
  }
  getLeftOffset() {
    return this._workSpace.getTimePanelWidth() + this._workSpace.getGroupTableWidth();
  }
  getGroupBoundsOffset(groupIndex, _ref) {
    let [$firstCell, $lastCell] = _ref;
    return this.cache.get(`groupBoundsOffset${groupIndex}`, () => {
      const startDayHour = this._workSpace.option("startDayHour");
      const endDayHour = this._workSpace.option("endDayHour");
      const hoursInterval = this._workSpace.option("hoursInterval");
      const dayHeight = calculateDayDuration(startDayHour, endDayHour) / hoursInterval * this._workSpace.getCellHeight();
      const scrollTop = this.getScrollableScrollTop();
      const headerRowHeight = getBoundingRect(this._workSpace._$headerPanelContainer.get(0)).height;
      let topOffset = groupIndex * dayHeight + headerRowHeight + this._workSpace.option("getHeaderHeight")() - scrollTop;
      if (this._workSpace.option("showAllDayPanel") && this._workSpace.supportAllDayRow()) {
        topOffset += this._workSpace.getCellHeight() * (groupIndex + 1);
      }
      const bottomOffset = topOffset + dayHeight;
      const {
        left
      } = $firstCell.getBoundingClientRect();
      const {
        right
      } = $lastCell.getBoundingClientRect();
      this._groupBoundsOffset = {
        left,
        right,
        top: topOffset,
        bottom: bottomOffset
      };
      return this._groupBoundsOffset;
    });
  }
  shiftIndicator($indicator, height, rtlOffset, i) {
    const offset = this._workSpace.getIndicatorOffset(0);
    const tableOffset = this._workSpace.option("crossScrollingEnabled") ? 0 : this._workSpace.getGroupTableWidth();
    const horizontalOffset = rtlOffset ? rtlOffset - offset : offset;
    let verticalOffset = this._workSpace._getRowCount() * this._workSpace.getCellHeight() * i;
    if (this._workSpace.supportAllDayRow() && this._workSpace.option("showAllDayPanel")) {
      verticalOffset += this._workSpace.getAllDayHeight() * (i + 1);
    }
    $indicator.css("left", horizontalOffset + tableOffset);
    $indicator.css("top", height + verticalOffset);
  }
  getShaderOffset(i, width) {
    const offset = this._workSpace.option("crossScrollingEnabled") ? 0 : this._workSpace.getGroupTableWidth();
    return this._workSpace.option("rtlEnabled") ? getBoundingRect(this._$container.get(0)).width - offset - this._workSpace.getWorkSpaceLeftOffset() - width : offset;
  }
  getShaderTopOffset(i) {
    return 0;
  }
  getShaderHeight() {
    let height = this._workSpace.getIndicationHeight();
    if (this._workSpace.supportAllDayRow() && this._workSpace.option("showAllDayPanel")) {
      height += this._workSpace.getCellHeight();
    }
    return height;
  }
  getShaderMaxHeight() {
    let height = this._workSpace._getRowCount() * this._workSpace.getCellHeight();
    if (this._workSpace.supportAllDayRow() && this._workSpace.option("showAllDayPanel")) {
      height += this._workSpace.getCellHeight();
    }
    return height;
  }
  getShaderWidth() {
    return this._workSpace.getIndicationWidth(0);
  }
  getScrollableScrollTop() {
    return this._workSpace.getScrollable().scrollTop();
  }
  addAdditionalGroupCellClasses(cellClass, index, i, j) {
    cellClass = this._addLastGroupCellClass(cellClass, i + 1);
    return this._addFirstGroupCellClass(cellClass, i + 1);
  }
  _addLastGroupCellClass(cellClass, index) {
    if (index % this._workSpace._getRowCount() === 0) {
      return `${cellClass} ${LAST_GROUP_CELL_CLASS}`;
    }
    return cellClass;
  }
  _addFirstGroupCellClass(cellClass, index) {
    if ((index - 1) % this._workSpace._getRowCount() === 0) {
      return `${cellClass} ${FIRST_GROUP_CELL_CLASS}`;
    }
    return cellClass;
  }
};
var m_work_space_grouped_strategy_vertical_default = VerticalGroupedStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_date_header_data_generator.js
var _excluded6 = ["startDate", "endDate", "isFirstGroupCell", "isLastGroupCell"];
var DateHeaderDataGenerator = class {
  constructor(_viewDataGenerator) {
    this._viewDataGenerator = _viewDataGenerator;
  }
  getCompleteDateHeaderMap(options, completeViewDataMap) {
    const {
      isGenerateWeekDaysHeaderData
    } = options;
    const result = [];
    if (isGenerateWeekDaysHeaderData) {
      const weekDaysRow = this._generateWeekDaysHeaderRowMap(options, completeViewDataMap);
      result.push(weekDaysRow);
    }
    const dateRow = this._generateHeaderDateRow(options, completeViewDataMap);
    result.push(dateRow);
    return result;
  }
  _generateWeekDaysHeaderRowMap(options, completeViewDataMap) {
    const {
      isGroupedByDate,
      groups,
      groupOrientation,
      startDayHour,
      endDayHour,
      hoursInterval,
      isHorizontalGrouping,
      intervalCount,
      viewOffset
    } = options;
    const cellCountInDay = this._viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
    const horizontalGroupCount = getHorizontalGroupCount(groups, groupOrientation);
    const index = completeViewDataMap[0][0].allDay ? 1 : 0;
    const colSpan = isGroupedByDate ? horizontalGroupCount * cellCountInDay : cellCountInDay;
    const groupCount = getGroupCount(groups);
    const datesRepeatCount = isHorizontalGrouping && !isGroupedByDate ? groupCount : 1;
    const daysInGroup = this._viewDataGenerator.daysInInterval * intervalCount;
    const daysInView = daysInGroup * datesRepeatCount;
    const weekDaysRow = [];
    for (let dayIndex = 0; dayIndex < daysInView; dayIndex += 1) {
      const cell = completeViewDataMap[index][dayIndex * colSpan];
      const shiftedStartDate = m_utils_time_zone_default.addOffsetsWithoutDST(cell.startDate, -viewOffset);
      weekDaysRow.push(_extends({}, cell, {
        colSpan,
        text: formatWeekdayAndDay(shiftedStartDate),
        isFirstGroupCell: false,
        isLastGroupCell: false
      }));
    }
    return weekDaysRow;
  }
  _generateHeaderDateRow(options, completeViewDataMap) {
    const {
      today,
      isGroupedByDate,
      groupOrientation,
      groups,
      headerCellTextFormat,
      getDateForHeaderText: getDateForHeaderText2,
      interval,
      startViewDate,
      startDayHour,
      endDayHour,
      hoursInterval,
      intervalCount,
      currentDate,
      viewType,
      viewOffset
    } = options;
    const horizontalGroupCount = getHorizontalGroupCount(groups, groupOrientation);
    const index = completeViewDataMap[0][0].allDay ? 1 : 0;
    const colSpan = isGroupedByDate ? horizontalGroupCount : 1;
    const isVerticalGrouping = "vertical" === groupOrientation;
    const cellCountInGroupRow = this._viewDataGenerator.getCellCount({
      intervalCount,
      currentDate,
      viewType,
      hoursInterval,
      startDayHour,
      endDayHour
    });
    const cellCountInDay = this._viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
    const slicedByColumnsData = isGroupedByDate ? completeViewDataMap[index].filter((_, columnIndex) => columnIndex % horizontalGroupCount === 0) : completeViewDataMap[index];
    const shouldShiftDatesForHeaderText = !isTimelineView(viewType) || viewType === VIEWS.TIMELINE_MONTH;
    return slicedByColumnsData.map((_ref, idx) => {
      let {
        startDate,
        isFirstGroupCell,
        isLastGroupCell
      } = _ref, restProps = _objectWithoutPropertiesLoose(_ref, _excluded6);
      const shiftedStartDate = m_utils_time_zone_default.addOffsetsWithoutDST(startDate, -viewOffset);
      const shiftedStartDateForHeaderText = shouldShiftDatesForHeaderText ? shiftedStartDate : startDate;
      const text = getHeaderCellText(idx % cellCountInGroupRow, shiftedStartDateForHeaderText, headerCellTextFormat, getDateForHeaderText2, {
        interval,
        startViewDate,
        startDayHour,
        cellCountInDay,
        viewOffset
      });
      return _extends({}, restProps, {
        startDate,
        text,
        today: date_default2.sameDate(shiftedStartDate, today),
        colSpan,
        isFirstGroupCell: isGroupedByDate || isFirstGroupCell && !isVerticalGrouping,
        isLastGroupCell: isGroupedByDate || isLastGroupCell && !isVerticalGrouping
      });
    });
  }
  generateDateHeaderData(completeDateHeaderMap, completeViewDataMap, options) {
    const {
      isGenerateWeekDaysHeaderData,
      cellWidth,
      isProvideVirtualCellsWidth,
      startDayHour,
      endDayHour,
      hoursInterval,
      isMonthDateHeader
    } = options;
    const dataMap = [];
    let weekDayRowConfig = {};
    const validCellWidth = cellWidth || 0;
    if (isGenerateWeekDaysHeaderData) {
      weekDayRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, completeViewDataMap, this._viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval), 0, validCellWidth);
      dataMap.push(weekDayRowConfig.dateRow);
    }
    const datesRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, completeViewDataMap, 1, isGenerateWeekDaysHeaderData ? 1 : 0, validCellWidth);
    dataMap.push(datesRowConfig.dateRow);
    return {
      dataMap,
      leftVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.leftVirtualCellWidth : void 0,
      rightVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.rightVirtualCellWidth : void 0,
      leftVirtualCellCount: datesRowConfig.leftVirtualCellCount,
      rightVirtualCellCount: datesRowConfig.rightVirtualCellCount,
      weekDayLeftVirtualCellWidth: weekDayRowConfig.leftVirtualCellWidth,
      weekDayRightVirtualCellWidth: weekDayRowConfig.rightVirtualCellWidth,
      weekDayLeftVirtualCellCount: weekDayRowConfig.leftVirtualCellCount,
      weekDayRightVirtualCellCount: weekDayRowConfig.rightVirtualCellCount,
      isMonthDateHeader
    };
  }
  _generateDateHeaderDataRow(options, completeDateHeaderMap, completeViewDataMap, baseColSpan, rowIndex, cellWidth) {
    const {
      startCellIndex,
      cellCount,
      isProvideVirtualCellsWidth,
      groups,
      groupOrientation,
      isGroupedByDate
    } = options;
    const horizontalGroupCount = getHorizontalGroupCount(groups, groupOrientation);
    const colSpan = isGroupedByDate ? horizontalGroupCount * baseColSpan : baseColSpan;
    const leftVirtualCellCount = Math.floor(startCellIndex / colSpan);
    const displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);
    const actualCellCount = Math.ceil((startCellIndex + displayedCellCount) / colSpan);
    const totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);
    const dateRow = completeDateHeaderMap[rowIndex].slice(leftVirtualCellCount, actualCellCount);
    const finalLeftVirtualCellCount = leftVirtualCellCount * colSpan;
    const finalLeftVirtualCellWidth = finalLeftVirtualCellCount * cellWidth;
    const finalRightVirtualCellCount = totalCellCount - actualCellCount * colSpan;
    const finalRightVirtualCellWidth = finalRightVirtualCellCount * cellWidth;
    return {
      dateRow,
      leftVirtualCellCount: finalLeftVirtualCellCount,
      leftVirtualCellWidth: isProvideVirtualCellsWidth ? finalLeftVirtualCellWidth : void 0,
      rightVirtualCellCount: finalRightVirtualCellCount,
      rightVirtualCellWidth: isProvideVirtualCellsWidth ? finalRightVirtualCellWidth : void 0
    };
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_grouped_data_map_provider.js
var toMs17 = date_default2.dateToMilliseconds;
var GroupedDataMapProvider = class {
  constructor(viewDataGenerator, viewDataMap, completeViewDataMap, viewOptions) {
    this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);
    this.completeViewDataMap = completeViewDataMap;
    this._viewOptions = viewOptions;
  }
  getGroupStartDate(groupIndex) {
    var _firstRow$;
    const firstRow = this.getFirstGroupRow(groupIndex);
    return (null === firstRow || void 0 === firstRow || null === (_firstRow$ = firstRow[0]) || void 0 === _firstRow$ || null === (_firstRow$ = _firstRow$.cellData) || void 0 === _firstRow$ ? void 0 : _firstRow$.startDate) ?? null;
  }
  getGroupEndDate(groupIndex) {
    const lastRow = this.getLastGroupRow(groupIndex);
    if (lastRow) {
      const lastColumnIndex = lastRow.length - 1;
      const {
        cellData
      } = lastRow[lastColumnIndex];
      const {
        endDate
      } = cellData;
      return endDate;
    }
  }
  findGroupCellStartDate(groupIndex, startDate, endDate, isFindByDate) {
    const groupData = this.getGroupFromDateTableGroupMap(groupIndex);
    const checkCellStartDate = (rowIndex, columnIndex) => {
      const {
        cellData
      } = groupData[rowIndex][columnIndex];
      let {
        startDate: secondMin,
        endDate: secondMax
      } = cellData;
      if (isFindByDate) {
        secondMin = date_default2.trimTime(secondMin);
        secondMax = date_default2.setToDayEnd(secondMin);
      }
      if (date_default2.intervalsOverlap({
        firstMin: startDate,
        firstMax: endDate,
        secondMin,
        secondMax
      })) {
        return secondMin;
      }
    };
    const startDateVerticalSearch = (() => {
      const cellCount = groupData[0].length;
      for (let columnIndex = 0; columnIndex < cellCount; ++columnIndex) {
        for (let rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {
          const result = checkCellStartDate(rowIndex, columnIndex);
          if (result) {
            return result;
          }
        }
      }
    })();
    const startDateHorizontalSearch = (() => {
      for (let rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {
        const row = groupData[rowIndex];
        for (let columnIndex = 0; columnIndex < row.length; ++columnIndex) {
          const result = checkCellStartDate(rowIndex, columnIndex);
          if (result) {
            return result;
          }
        }
      }
    })();
    return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch;
  }
  findAllDayGroupCellStartDate(groupIndex) {
    var _groupedData$;
    const groupedData = this.getGroupFromDateTableGroupMap(groupIndex);
    const cellData = null === groupedData || void 0 === groupedData || null === (_groupedData$ = groupedData[0]) || void 0 === _groupedData$ || null === (_groupedData$ = _groupedData$[0]) || void 0 === _groupedData$ ? void 0 : _groupedData$.cellData;
    return (null === cellData || void 0 === cellData ? void 0 : cellData.startDate) ?? null;
  }
  findCellPositionInMap(cellInfo, isAppointmentRender) {
    const {
      groupIndex,
      startDate,
      isAllDay,
      index
    } = cellInfo;
    const {
      allDayPanelGroupedMap,
      dateTableGroupedMap
    } = this.groupedDataMap;
    const {
      viewOffset
    } = this._viewOptions;
    const rows = isAllDay && !this._viewOptions.isVerticalGrouping ? allDayPanelGroupedMap[groupIndex] ? [allDayPanelGroupedMap[groupIndex]] : [] : dateTableGroupedMap[groupIndex] || [];
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex += 1) {
      const row = rows[rowIndex];
      for (let columnIndex = 0; columnIndex < row.length; columnIndex += 1) {
        const cell = row[columnIndex];
        const originCellData = cell.cellData;
        const cellData = isAppointmentRender ? _extends({}, originCellData, {
          startDate: dateUtilsTs.addOffsets(cell.cellData.startDate, [-viewOffset]),
          endDate: dateUtilsTs.addOffsets(cell.cellData.endDate, [-viewOffset])
        }) : originCellData;
        if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {
          if (this.isStartDateInCell(startDate, isAllDay, cellData, originCellData)) {
            return cell.position;
          }
        }
      }
    }
    return;
  }
  isStartDateInCell(startDate, inAllDayRow, _ref, _ref2) {
    let {
      startDate: cellStartDate,
      endDate: cellEndDate,
      allDay: cellAllDay
    } = _ref;
    let {
      startDate: originCellStartDate,
      endDate: originCellEndDate
    } = _ref2;
    const {
      viewType
    } = this._viewOptions;
    const cellSecondIntervalOffset = this.getCellSecondIntervalOffset(originCellStartDate, originCellEndDate);
    const isCellCoversTwoIntervals = 0 !== cellSecondIntervalOffset;
    switch (true) {
      case !isDateAndTimeView(viewType):
      case (inAllDayRow && cellAllDay):
        return date_default2.sameDate(startDate, cellStartDate);
      case (!inAllDayRow && !isCellCoversTwoIntervals):
        return startDate >= cellStartDate && startDate < cellEndDate;
      case (!inAllDayRow && isCellCoversTwoIntervals):
        return this.isStartDateInTwoIntervalsCell(startDate, cellSecondIntervalOffset, cellStartDate, cellEndDate);
      default:
        return false;
    }
  }
  getCellSecondIntervalOffset(cellStartDate, cellEndDate) {
    const nextHourCellStartDate = dateUtilsTs.addOffsets(cellStartDate, [toMs17("hour")]);
    const cellTimezoneDiff = m_utils_time_zone_default.getDaylightOffset(cellStartDate, cellEndDate);
    const cellNextHourTimezoneDiff = m_utils_time_zone_default.getDaylightOffset(cellStartDate, nextHourCellStartDate);
    const isDSTInsideCell = 0 !== cellTimezoneDiff;
    const isWinterTimezoneNextHour = cellNextHourTimezoneDiff < 0;
    return !isDSTInsideCell && isWinterTimezoneNextHour ? Math.abs(cellNextHourTimezoneDiff * toMs17("minute")) : 0;
  }
  isStartDateInTwoIntervalsCell(startDate, secondIntervalOffset, cellStartDate, cellEndDate) {
    const nextIntervalCellStartDate = dateUtilsTs.addOffsets(cellStartDate, [secondIntervalOffset]);
    const nextIntervalCellEndDate = dateUtilsTs.addOffsets(cellEndDate, [secondIntervalOffset]);
    const isInOriginInterval = startDate >= cellStartDate && startDate < cellEndDate;
    const isInSecondInterval = startDate >= nextIntervalCellStartDate && startDate < nextIntervalCellEndDate;
    return isInOriginInterval || isInSecondInterval;
  }
  _isSameGroupIndexAndIndex(cellData, groupIndex, index) {
    return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index);
  }
  getCellsGroup(groupIndex) {
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    const groupData = dateTableGroupedMap[groupIndex];
    if (groupData) {
      const {
        cellData
      } = groupData[0][0];
      return cellData.groups;
    }
  }
  getCompletedGroupsInfo() {
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    return dateTableGroupedMap.map((groupData) => {
      const firstCell = groupData[0][0];
      const {
        allDay,
        groupIndex
      } = firstCell.cellData;
      return {
        allDay,
        groupIndex,
        startDate: this.getGroupStartDate(groupIndex),
        endDate: this.getGroupEndDate(groupIndex)
      };
    }).filter((_ref3) => {
      let {
        startDate
      } = _ref3;
      return !!startDate;
    });
  }
  getGroupIndices() {
    return this.getCompletedGroupsInfo().map((_ref4) => {
      let {
        groupIndex
      } = _ref4;
      return groupIndex;
    });
  }
  getGroupFromDateTableGroupMap(groupIndex) {
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    return dateTableGroupedMap[groupIndex];
  }
  getFirstGroupRow(groupIndex) {
    const groupedData = this.getGroupFromDateTableGroupMap(groupIndex);
    if (groupedData) {
      const {
        cellData
      } = groupedData[0][0];
      return !cellData.allDay ? groupedData[0] : groupedData[1];
    }
  }
  getLastGroupRow(groupIndex) {
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    const groupedData = dateTableGroupedMap[groupIndex];
    if (groupedData) {
      const lastRowIndex = groupedData.length - 1;
      return groupedData[lastRowIndex];
    }
  }
  getLastGroupCellPosition(groupIndex) {
    const groupRow = this.getLastGroupRow(groupIndex);
    return null === groupRow || void 0 === groupRow ? void 0 : groupRow[(null === groupRow || void 0 === groupRow ? void 0 : groupRow.length) - 1].position;
  }
  getRowCountInGroup(groupIndex) {
    const groupRow = this.getLastGroupRow(groupIndex);
    const cellAmount = groupRow.length;
    const lastCellData = groupRow[cellAmount - 1].cellData;
    const lastCellIndex = lastCellData.index;
    return (lastCellIndex + 1) / groupRow.length;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/utils/math.js
var shiftIntegerByModule = (integerValue, moduleValue) => {
  if (!Number.isInteger(integerValue)) {
    throw Error(`Passed integer value ${integerValue} is not an integer.`);
  }
  if (!Number.isInteger(moduleValue)) {
    throw Error(`Passed module value ${moduleValue} is not an integer.`);
  }
  if (moduleValue <= 0) {
    throw Error(`Passed module value ${moduleValue} must be > 0.`);
  }
  const normalizedInteger = integerValue % moduleValue;
  switch (true) {
    case 0 === normalizedInteger:
      return 0;
    case normalizedInteger > 0:
      return normalizedInteger;
    case normalizedInteger < 0:
      return moduleValue + normalizedInteger;
    default:
      throw Error(`Unexpected division (${integerValue} % ${moduleValue}) occurred.`);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_time_panel_data_generator.js
var _excluded7 = ["allDay", "startDate", "endDate", "groups", "groupIndex", "isFirstGroupCell", "isLastGroupCell", "index"];
var toMs18 = date_default2.dateToMilliseconds;
var TimePanelDataGenerator = class {
  constructor(_viewDataGenerator) {
    this._viewDataGenerator = _viewDataGenerator;
  }
  getCompleteTimePanelMap(options, completeViewDataMap) {
    const {
      startViewDate,
      cellDuration,
      startDayHour,
      isVerticalGrouping,
      intervalCount,
      currentDate,
      viewType,
      hoursInterval,
      endDayHour,
      viewOffset,
      today,
      showCurrentTimeIndicator
    } = options;
    const rowsCount = completeViewDataMap.length - 1;
    const realEndViewDate = completeViewDataMap[rowsCount][completeViewDataMap[rowsCount].length - 1].endDate;
    const rowCountInGroup = this._viewDataGenerator.getRowCount({
      intervalCount,
      currentDate,
      viewType,
      hoursInterval,
      startDayHour,
      endDayHour
    });
    const cellCountInGroupRow = this._viewDataGenerator.getCellCount({
      intervalCount,
      currentDate,
      viewType,
      hoursInterval,
      startDayHour,
      endDayHour
    });
    let allDayRowsCount = 0;
    let usualCellIndex = 0;
    return completeViewDataMap.map((row, index) => {
      const _row$ = row[0], {
        allDay,
        startDate,
        groups,
        groupIndex,
        isFirstGroupCell,
        isLastGroupCell,
        index: cellIndex
      } = _row$, restCellProps = _objectWithoutPropertiesLoose(_row$, _excluded7);
      const highlighted = allDay ? false : this.isTimeCellShouldBeHighlighted(today, viewOffset, {
        startViewDate,
        realEndViewDate,
        showCurrentTimeIndicator
      }, {
        date: startDate,
        index: usualCellIndex,
        duration: Math.round(cellDuration),
        isFirst: 0 === usualCellIndex,
        isLast: this.isLastCellInGroup(completeViewDataMap, index)
      });
      if (allDay) {
        allDayRowsCount += 1;
        usualCellIndex = 0;
      } else {
        usualCellIndex += 1;
      }
      const timeIndex = (index - allDayRowsCount) % rowCountInGroup;
      return _extends({}, restCellProps, {
        startDate,
        allDay,
        highlighted,
        text: weekUtils.getTimePanelCellText(timeIndex, startDate, startViewDate, cellDuration, startDayHour, viewOffset),
        groups: isVerticalGrouping ? groups : void 0,
        groupIndex: isVerticalGrouping ? groupIndex : void 0,
        isFirstGroupCell: isVerticalGrouping && isFirstGroupCell,
        isLastGroupCell: isVerticalGrouping && isLastGroupCell,
        index: Math.floor(cellIndex / cellCountInGroupRow)
      });
    });
  }
  generateTimePanelData(completeTimePanelMap, options) {
    const {
      startRowIndex,
      rowCount,
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      isGroupedAllDayPanel,
      isVerticalGrouping,
      isAllDayPanelVisible
    } = options;
    const indexDifference = isVerticalGrouping || !isAllDayPanelVisible ? 0 : 1;
    const correctedStartRowIndex = startRowIndex + indexDifference;
    const displayedRowCount = getDisplayedRowCount(rowCount, completeTimePanelMap);
    const timePanelMap = completeTimePanelMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount);
    const timePanelData = {
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      isGroupedAllDayPanel
    };
    const {
      previousGroupedData: groupedData
    } = this._generateTimePanelDataFromMap(timePanelMap, isVerticalGrouping);
    timePanelData.groupedData = groupedData;
    return timePanelData;
  }
  _generateTimePanelDataFromMap(timePanelMap, isVerticalGrouping) {
    return timePanelMap.reduce((_ref, cellData) => {
      let {
        previousGroupIndex,
        previousGroupedData
      } = _ref;
      const currentGroupIndex = cellData.groupIndex;
      if (currentGroupIndex !== previousGroupIndex) {
        previousGroupedData.push({
          dateTable: [],
          isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!cellData.allDay, isVerticalGrouping),
          groupIndex: currentGroupIndex,
          key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)
        });
      }
      if (cellData.allDay) {
        previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellData;
      } else {
        previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellData);
      }
      return {
        previousGroupIndex: currentGroupIndex,
        previousGroupedData
      };
    }, {
      previousGroupIndex: -1,
      previousGroupedData: []
    });
  }
  isTimeCellShouldBeHighlighted(today, viewOffset, _ref2, cellData) {
    let {
      startViewDate,
      realEndViewDate,
      showCurrentTimeIndicator
    } = _ref2;
    const realToday = dateUtilsTs.addOffsets(today, [viewOffset]);
    const realStartViewDate = dateUtilsTs.addOffsets(startViewDate, [viewOffset]);
    if (!showCurrentTimeIndicator || realToday < realStartViewDate || realToday >= realEndViewDate) {
      return false;
    }
    const realTodayTimeMs = this.getLocalDateTimeInMs(realToday);
    const [startMs, endMs] = this.getHighlightedInterval(cellData);
    return startMs < endMs ? realTodayTimeMs >= startMs && realTodayTimeMs < endMs : realTodayTimeMs >= startMs && realTodayTimeMs < toMs18("day") || realTodayTimeMs >= 0 && realTodayTimeMs < endMs;
  }
  getHighlightedInterval(_ref3) {
    let {
      date,
      index,
      duration,
      isFirst,
      isLast
    } = _ref3;
    const cellTimeMs = this.getLocalDateTimeInMs(date);
    const isEvenCell = index % 2 === 0;
    switch (true) {
      case (isFirst || isLast && !isEvenCell):
        return [cellTimeMs, shiftIntegerByModule(cellTimeMs + duration, toMs18("day"))];
      case isEvenCell:
        return [shiftIntegerByModule(cellTimeMs - duration, toMs18("day")), shiftIntegerByModule(cellTimeMs + duration, toMs18("day"))];
      default:
        return [cellTimeMs, shiftIntegerByModule(cellTimeMs + 2 * duration, toMs18("day"))];
    }
  }
  getLocalDateTimeInMs(date) {
    const dateUtcMs = date.getTime() - date.getTimezoneOffset() * toMs18("minute");
    return shiftIntegerByModule(dateUtcMs, toMs18("day"));
  }
  isLastCellInGroup(completeViewDataMap, index) {
    if (index === completeViewDataMap.length - 1) {
      return true;
    }
    const {
      groupIndex: currentGroupIndex
    } = completeViewDataMap[index][0];
    const {
      groupIndex: nextGroupIndex,
      allDay: nextAllDay
    } = completeViewDataMap[index + 1][0];
    return nextAllDay || nextGroupIndex !== currentGroupIndex;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator.js
var toMs19 = date_default2.dateToMilliseconds;
var ViewDataGenerator = class {
  constructor() {
    this.daysInInterval = 1;
    this.isWorkView = false;
    this.tableAllDay = false;
  }
  isSkippedDate(date) {
    return false;
  }
  _calculateStartViewDate(options) {
  }
  getStartViewDate(options) {
    return this._calculateStartViewDate(options);
  }
  getCompleteViewDataMap(options) {
    const {
      groups,
      isGroupedByDate,
      isHorizontalGrouping,
      isVerticalGrouping,
      intervalCount,
      currentDate,
      viewType,
      startDayHour,
      endDayHour,
      hoursInterval
    } = options;
    this._setVisibilityDates(options);
    this.setHiddenInterval(startDayHour, endDayHour, hoursInterval);
    const groupsList = getAllGroups(groups);
    const cellCountInGroupRow = this.getCellCount({
      intervalCount,
      currentDate,
      viewType,
      startDayHour,
      endDayHour,
      hoursInterval
    });
    const rowCountInGroup = this.getRowCount({
      intervalCount,
      currentDate,
      viewType,
      hoursInterval,
      startDayHour,
      endDayHour
    });
    let viewDataMap = [];
    const allDayPanelData = this._generateAllDayPanelData(options, rowCountInGroup, cellCountInGroupRow);
    const viewCellsData = this._generateViewCellsData(options, rowCountInGroup, cellCountInGroupRow);
    if (allDayPanelData) {
      viewDataMap.push(allDayPanelData);
    }
    viewDataMap.push(...viewCellsData);
    if (isHorizontalGrouping && !isGroupedByDate) {
      viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList);
    }
    if (isVerticalGrouping) {
      viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList);
    }
    if (isGroupedByDate) {
      viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList);
    }
    return this._addKeysToCells(viewDataMap);
  }
  _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {
    const result = viewDataMap.map((row) => row.slice());
    groupsList.slice(1).forEach((groups, index) => {
      const groupIndex = index + 1;
      viewDataMap.forEach((row, rowIndex) => {
        const nextGroupRow = row.map((cellData) => _extends({}, cellData, {
          groups,
          groupIndex
        }));
        result[rowIndex].push(...nextGroupRow);
      });
    });
    return result;
  }
  _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {
    const result = viewDataMap.map((row) => row.slice());
    groupsList.slice(1).forEach((groups, index) => {
      const groupIndex = index + 1;
      const nextGroupMap = viewDataMap.map((cellsRow) => {
        const nextRow = cellsRow.map((cellData) => _extends({}, cellData, {
          groupIndex,
          groups
        }));
        return nextRow;
      });
      result.push(...nextGroupMap);
    });
    return result;
  }
  _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {
    const correctedGroupList = groupsList.slice(1);
    const correctedGroupCount = correctedGroupList.length;
    const result = viewDataMap.map((cellsRow) => {
      const groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {
        const rowWithCurrentCell = [...currentRow, _extends({}, cell, {
          isFirstGroupCell: true,
          isLastGroupCell: 0 === correctedGroupCount
        }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {
          groups,
          groupIndex: index + 1,
          isFirstGroupCell: false,
          isLastGroupCell: index === correctedGroupCount - 1
        }))];
        return rowWithCurrentCell;
      }, []);
      return groupedByDateCellsRow;
    });
    return result;
  }
  _addKeysToCells(viewDataMap) {
    const totalColumnCount = viewDataMap[0].length;
    const {
      currentViewDataMap: result
    } = viewDataMap.reduce((_ref, row, rowIndex) => {
      let {
        allDayPanelsCount,
        currentViewDataMap
      } = _ref;
      const isAllDay = row[0].allDay;
      const keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;
      const currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;
      currentViewDataMap[rowIndex].forEach((cell, columnIndex) => {
        cell.key = keyBase + columnIndex;
      });
      return {
        allDayPanelsCount: currentAllDayPanelsCount,
        currentViewDataMap
      };
    }, {
      allDayPanelsCount: 0,
      currentViewDataMap: viewDataMap
    });
    return result;
  }
  generateViewDataMap(completeViewDataMap, options) {
    const {
      rowCount,
      startCellIndex,
      startRowIndex,
      cellCount,
      isVerticalGrouping,
      isAllDayPanelVisible
    } = options;
    const sliceCells = (row, rowIndex, startIndex, count) => {
      const sliceToIndex = void 0 !== count ? startIndex + count : void 0;
      return row.slice(startIndex, sliceToIndex).map((cellData, columnIndex) => ({
        cellData,
        position: {
          rowIndex,
          columnIndex
        }
      }));
    };
    let correctedStartRowIndex = startRowIndex;
    let allDayPanelMap = [];
    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {
      correctedStartRowIndex++;
      allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount);
    }
    const displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);
    const dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));
    return {
      allDayPanelMap,
      dateTableMap
    };
  }
  _isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible) {
    return !isVerticalGrouping && isAllDayPanelVisible;
  }
  getViewDataFromMap(completeViewDataMap, viewDataMap, options) {
    const {
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      leftVirtualCellWidth,
      rightVirtualCellWidth,
      cellCount,
      rowCount,
      startRowIndex,
      startCellIndex,
      isProvideVirtualCellsWidth,
      isGroupedAllDayPanel,
      isVerticalGrouping,
      isAllDayPanelVisible
    } = options;
    const {
      allDayPanelMap,
      dateTableMap
    } = viewDataMap;
    const {
      groupedData
    } = dateTableMap.reduce((_ref2, cellsRow) => {
      let {
        previousGroupIndex,
        groupedData: groupedData2
      } = _ref2;
      const cellDataRow = cellsRow.map((_ref3) => {
        let {
          cellData
        } = _ref3;
        return cellData;
      });
      const firstCell = cellDataRow[0];
      const isAllDayRow = firstCell.allDay;
      const currentGroupIndex = firstCell.groupIndex;
      if (currentGroupIndex !== previousGroupIndex) {
        groupedData2.push({
          dateTable: [],
          isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!isAllDayRow, isVerticalGrouping),
          groupIndex: currentGroupIndex,
          key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)
        });
      }
      if (isAllDayRow) {
        groupedData2[groupedData2.length - 1].allDayPanel = cellDataRow;
      } else {
        groupedData2[groupedData2.length - 1].dateTable.push({
          cells: cellDataRow,
          key: cellDataRow[0].key - startCellIndex
        });
      }
      return {
        groupedData: groupedData2,
        previousGroupIndex: currentGroupIndex
      };
    }, {
      previousGroupIndex: -1,
      groupedData: []
    });
    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {
      groupedData[0].allDayPanel = allDayPanelMap.map((_ref4) => {
        let {
          cellData
        } = _ref4;
        return cellData;
      });
    }
    const totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);
    const totalRowCount = getTotalRowCountByCompleteData(completeViewDataMap);
    const displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);
    const displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);
    return {
      groupedData,
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,
      rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,
      isGroupedAllDayPanel,
      leftVirtualCellCount: startCellIndex,
      rightVirtualCellCount: void 0 === cellCount ? 0 : totalCellCount - startCellIndex - displayedCellCount,
      topVirtualRowCount: startRowIndex,
      bottomVirtualRowCount: totalRowCount - startRowIndex - displayedRowCount
    };
  }
  _generateViewCellsData(options, rowCount, cellCountInGroupRow) {
    const viewCellsData = [];
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
      viewCellsData.push(this._generateCellsRow(options, false, rowIndex, rowCount, cellCountInGroupRow));
    }
    return viewCellsData;
  }
  _generateAllDayPanelData(options, rowCount, columnCount) {
    if (!options.isAllDayPanelVisible) {
      return null;
    }
    return this._generateCellsRow(options, true, 0, rowCount, columnCount);
  }
  _generateCellsRow(options, allDay, rowIndex, rowCount, columnCount) {
    const cellsRow = [];
    for (let columnIndex = 0; columnIndex < columnCount; ++columnIndex) {
      const cellDataValue = this.getCellData(rowIndex, columnIndex, options, allDay);
      cellDataValue.index = rowIndex * columnCount + columnIndex;
      cellDataValue.isFirstGroupCell = this._isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);
      cellDataValue.isLastGroupCell = this._isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);
      cellsRow.push(cellDataValue);
    }
    return cellsRow;
  }
  getCellData(rowIndex, columnIndex, options, allDay) {
    return allDay ? this.prepareAllDayCellData(options, rowIndex, columnIndex) : this.prepareCellData(options, rowIndex, columnIndex);
  }
  prepareCellData(options, rowIndex, columnIndex) {
    const {
      groups,
      startDayHour,
      endDayHour,
      hoursInterval
    } = options;
    const groupsList = getAllGroups(groups);
    const startDate = this.getDateByCellIndices(options, rowIndex, columnIndex, this.getCellCountInDay(startDayHour, endDayHour, hoursInterval));
    const endDate = this.getCellEndDate(startDate, options);
    const data2 = {
      startDate,
      endDate,
      allDay: this.tableAllDay,
      groupIndex: 0
    };
    if (groupsList.length > 0) {
      data2.groups = groupsList[0];
    }
    return data2;
  }
  prepareAllDayCellData(options, rowIndex, columnIndex) {
    const data2 = this.prepareCellData(_extends({}, options, {
      viewOffset: 0
    }), rowIndex, columnIndex);
    const {
      viewOffset
    } = options;
    const startDate = date_default2.trimTime(data2.startDate);
    const shiftedStartDate = dateUtilsTs.addOffsets(startDate, [viewOffset]);
    return _extends({}, data2, {
      startDate: shiftedStartDate,
      endDate: shiftedStartDate,
      allDay: true
    });
  }
  getDateByCellIndices(options, rowIndex, columnIndex, cellCountInDay) {
    let {
      startViewDate
    } = options;
    const {
      startDayHour,
      interval,
      firstDayOfWeek,
      intervalCount,
      viewOffset
    } = options;
    const isStartViewDateDuringDST = startViewDate.getHours() !== Math.floor(startDayHour);
    if (isStartViewDateDuringDST) {
      const dateWithCorrectHours = getStartViewDateWithoutDST(startViewDate, startDayHour);
      startViewDate = new Date(dateWithCorrectHours.getTime() - toMs19("day"));
    }
    const columnCountBase = this.getCellCount(options);
    const rowCountBase = this.getRowCount(options);
    const cellIndex = this._calculateCellIndex(rowIndex, columnIndex, rowCountBase, columnCountBase);
    const millisecondsOffset = this.getMillisecondsOffset(cellIndex, interval, cellCountInDay);
    const offsetByCount = this.isWorkView ? this.getTimeOffsetByColumnIndex(columnIndex, this.getFirstDayOfWeek(firstDayOfWeek), columnCountBase, intervalCount) : 0;
    const startViewDateTime = startViewDate.getTime();
    const currentDate = new Date(startViewDateTime + millisecondsOffset + offsetByCount + viewOffset);
    const timeZoneDifference = isStartViewDateDuringDST ? 0 : date_default2.getTimezonesDifference(startViewDate, currentDate);
    currentDate.setTime(currentDate.getTime() + timeZoneDifference);
    return currentDate;
  }
  getMillisecondsOffset(cellIndex, interval, cellCountInDay) {
    const dayIndex = Math.floor(cellIndex / cellCountInDay);
    const realHiddenInterval = dayIndex * this.hiddenInterval;
    return interval * cellIndex + realHiddenInterval;
  }
  getTimeOffsetByColumnIndex(columnIndex, firstDayOfWeek, columnCount, intervalCount) {
    const firstDayOfWeekDiff = Math.max(0, firstDayOfWeek - 1);
    const columnsInWeek = columnCount / intervalCount;
    const weekendCount = Math.floor((columnIndex + firstDayOfWeekDiff) / columnsInWeek);
    return 2 * weekendCount * toMs19("day");
  }
  calculateEndDate(startDate, interval, endDayHour) {
    return this.getCellEndDate(startDate, {
      interval
    });
  }
  _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCountBase) {
    return calculateCellIndex(rowIndex, columnIndex, rowCount);
  }
  generateGroupedDataMap(viewDataMap) {
    const {
      allDayPanelMap,
      dateTableMap
    } = viewDataMap;
    const {
      previousGroupedDataMap: dateTableGroupedMap
    } = dateTableMap.reduce((previousOptions, cellsRow) => {
      const {
        previousGroupedDataMap,
        previousRowIndex,
        previousGroupIndex
      } = previousOptions;
      const {
        groupIndex: currentGroupIndex
      } = cellsRow[0].cellData;
      const currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;
      cellsRow.forEach((cell) => {
        const {
          groupIndex
        } = cell.cellData;
        if (!previousGroupedDataMap[groupIndex]) {
          previousGroupedDataMap[groupIndex] = [];
        }
        if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {
          previousGroupedDataMap[groupIndex][currentRowIndex] = [];
        }
        previousGroupedDataMap[groupIndex][currentRowIndex].push(cell);
      });
      return {
        previousGroupedDataMap,
        previousRowIndex: currentRowIndex,
        previousGroupIndex: currentGroupIndex
      };
    }, {
      previousGroupedDataMap: [],
      previousRowIndex: -1,
      previousGroupIndex: -1
    });
    const allDayPanelGroupedMap = [];
    null === allDayPanelMap || void 0 === allDayPanelMap || allDayPanelMap.forEach((cell) => {
      const {
        groupIndex
      } = cell.cellData;
      if (!allDayPanelGroupedMap[groupIndex]) {
        allDayPanelGroupedMap[groupIndex] = [];
      }
      allDayPanelGroupedMap[groupIndex].push(cell);
    });
    return {
      allDayPanelGroupedMap,
      dateTableGroupedMap
    };
  }
  _isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {
    const {
      groupOrientation,
      groups,
      isGroupedByDate
    } = options;
    const groupCount = getGroupCount(groups);
    if (isGroupedByDate) {
      return columnIndex % groupCount === 0;
    }
    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {
      return columnIndex % columnCount === 0;
    }
    return rowIndex % rowCount === 0;
  }
  _isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {
    const {
      groupOrientation,
      groups,
      isGroupedByDate
    } = options;
    const groupCount = getGroupCount(groups);
    if (isGroupedByDate) {
      return (columnIndex + 1) % groupCount === 0;
    }
    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {
      return (columnIndex + 1) % columnCount === 0;
    }
    return (rowIndex + 1) % rowCount === 0;
  }
  markSelectedAndFocusedCells(viewDataMap, renderOptions) {
    const {
      selectedCells,
      focusedCell
    } = renderOptions;
    if (!selectedCells && !focusedCell) {
      return viewDataMap;
    }
    const {
      allDayPanelMap,
      dateTableMap
    } = viewDataMap;
    const nextDateTableMap = dateTableMap.map((row) => this._markSelectedAndFocusedCellsInRow(row, selectedCells, focusedCell));
    const nextAllDayMap = this._markSelectedAndFocusedCellsInRow(allDayPanelMap, selectedCells, focusedCell);
    return {
      allDayPanelMap: nextAllDayMap,
      dateTableMap: nextDateTableMap
    };
  }
  _markSelectedAndFocusedCellsInRow(dataRow, selectedCells, focusedCell) {
    return dataRow.map((cell) => {
      const {
        index,
        groupIndex,
        allDay,
        startDate
      } = cell.cellData;
      const indexInSelectedCells = selectedCells.findIndex((_ref5) => {
        let {
          index: selectedCellIndex,
          groupIndex: selectedCellGroupIndex,
          allDay: selectedCellAllDay,
          startDate: selectedCellStartDate
        } = _ref5;
        return groupIndex === selectedCellGroupIndex && (index === selectedCellIndex || void 0 === selectedCellIndex && startDate.getTime() === selectedCellStartDate.getTime()) && !!allDay === !!selectedCellAllDay;
      });
      const isFocused = !!focusedCell && index === focusedCell.cellData.index && groupIndex === focusedCell.cellData.groupIndex && allDay === focusedCell.cellData.allDay;
      if (!isFocused && -1 === indexInSelectedCells) {
        return cell;
      }
      return _extends({}, cell, {
        cellData: _extends({}, cell.cellData, {
          isSelected: indexInSelectedCells > -1,
          isFocused
        })
      });
    });
  }
  getInterval(hoursInterval) {
    return hoursInterval * toMs19("hour");
  }
  _getIntervalDuration(intervalCount) {
    return toMs19("day") * intervalCount;
  }
  _setVisibilityDates(options) {
  }
  getCellCountInDay(startDayHour, endDayHour, hoursInterval) {
    const result = calculateDayDuration(startDayHour, endDayHour) / hoursInterval;
    return Math.ceil(result);
  }
  getCellCount(options) {
    const {
      intervalCount,
      viewType,
      startDayHour,
      endDayHour,
      hoursInterval
    } = options;
    const cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
    const columnCountInDay = isHorizontalView(viewType) ? cellCountInDay : 1;
    return this.daysInInterval * intervalCount * columnCountInDay;
  }
  getRowCount(options) {
    const {
      viewType,
      startDayHour,
      endDayHour,
      hoursInterval
    } = options;
    const cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
    const rowCountInDay = !isHorizontalView(viewType) ? cellCountInDay : 1;
    return rowCountInDay;
  }
  setHiddenInterval(startDayHour, endDayHour, hoursInterval) {
    this.hiddenInterval = toMs19("day") - this.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);
  }
  getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {
    const cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
    return hoursInterval * cellCountInDay * toMs19("hour");
  }
  getFirstDayOfWeek(firstDayOfWeekOption) {
    return firstDayOfWeekOption;
  }
  getCellEndDate(cellStartDate, options) {
    const durationMs = Math.round(options.interval);
    return m_utils_time_zone_default.addOffsetsWithoutDST(cellStartDate, durationMs);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator_day.js
var ViewDataGeneratorDay = class extends ViewDataGenerator {
  _calculateStartViewDate(options) {
    return dayUtils.calculateStartViewDate(options.currentDate, options.startDayHour, options.startDate, this._getIntervalDuration(options.intervalCount));
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator_month.js
var toMs20 = date_default2.dateToMilliseconds;
var ViewDataGeneratorMonth = class extends ViewDataGenerator {
  constructor() {
    super(...arguments);
    this.tableAllDay = void 0;
  }
  getCellData(rowIndex, columnIndex, options, allDay) {
    const {
      indicatorTime,
      timeZoneCalculator,
      intervalCount,
      viewOffset
    } = options;
    const data2 = super.getCellData(rowIndex, columnIndex, options, false);
    const startDate = m_utils_time_zone_default.addOffsetsWithoutDST(data2.startDate, -viewOffset);
    data2.today = this.isCurrentDate(startDate, indicatorTime, timeZoneCalculator);
    data2.otherMonth = this.isOtherMonth(startDate, this._minVisibleDate, this._maxVisibleDate);
    data2.firstDayOfMonth = isFirstCellInMonthWithIntervalCount(startDate, intervalCount);
    data2.text = monthUtils.getCellText(startDate, intervalCount);
    return data2;
  }
  isCurrentDate(date, indicatorTime, timeZoneCalculator) {
    return date_default2.sameDate(date, getToday(indicatorTime, timeZoneCalculator));
  }
  isOtherMonth(cellDate, minDate, maxDate) {
    return !date_default2.dateInRange(cellDate, minDate, maxDate, "date");
  }
  _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {
    return monthUtils.calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount);
  }
  calculateEndDate(startDate, interval, endDayHour) {
    return setOptionHour(startDate, endDayHour);
  }
  getInterval() {
    return toMs20("day");
  }
  _calculateStartViewDate(options) {
    return monthUtils.calculateStartViewDate(options.currentDate, options.startDayHour, options.startDate, options.intervalCount, this.getFirstDayOfWeek(options.firstDayOfWeek));
  }
  _setVisibilityDates(options) {
    const {
      intervalCount,
      startDate,
      currentDate
    } = options;
    const firstMonthDate = date_default2.getFirstMonthDate(startDate);
    const viewStart = monthUtils.getViewStartByOptions(startDate, currentDate, intervalCount, firstMonthDate);
    this._minVisibleDate = new Date(viewStart.setDate(1));
    const nextMonthDate = new Date(viewStart.setMonth(viewStart.getMonth() + intervalCount));
    this._maxVisibleDate = new Date(nextMonthDate.setDate(0));
  }
  getCellCount() {
    return 7;
  }
  getRowCount(options) {
    const startDate = new Date(options.currentDate);
    startDate.setDate(1);
    const endDate = new Date(startDate);
    endDate.setMonth(endDate.getMonth() + options.intervalCount);
    endDate.setDate(0);
    return calculateAlignedWeeksBetweenDates(startDate, endDate, options.firstDayOfWeek ?? date_default.firstDayOfWeekIndex());
  }
  getCellCountInDay() {
    return 1;
  }
  setHiddenInterval() {
    this.hiddenInterval = 0;
  }
  getCellEndDate(cellStartDate, options) {
    const {
      startDayHour,
      endDayHour
    } = options;
    const durationMs = (endDayHour - startDayHour) * toMs20("hour");
    return m_utils_time_zone_default.addOffsetsWithoutDST(cellStartDate, durationMs);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator_timeline_month.js
var toMs21 = date_default2.dateToMilliseconds;
var ViewDataGeneratorTimelineMonth = class extends ViewDataGenerator {
  _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {
    return monthUtils.calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount);
  }
  calculateEndDate(startDate, interval, endDayHour) {
    return setOptionHour(startDate, endDayHour);
  }
  getInterval() {
    return toMs21("day");
  }
  _calculateStartViewDate(options) {
    return timelineMonthUtils.calculateStartViewDate(options.currentDate, options.startDayHour, options.startDate, options.intervalCount);
  }
  getCellCount(options) {
    const {
      intervalCount
    } = options;
    const currentDate = new Date(options.currentDate);
    let cellCount = 0;
    for (let i = 1; i <= intervalCount; i++) {
      cellCount += new Date(currentDate.getFullYear(), currentDate.getMonth() + i, 0).getDate();
    }
    return cellCount;
  }
  setHiddenInterval() {
    this.hiddenInterval = 0;
  }
  getCellEndDate(cellStartDate, options) {
    const {
      startDayHour,
      endDayHour
    } = options;
    const durationMs = (endDayHour - startDayHour) * toMs21("hour");
    return m_utils_time_zone_default.addOffsetsWithoutDST(cellStartDate, durationMs);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator_week.js
var ViewDataGeneratorWeek = class extends ViewDataGenerator {
  constructor() {
    super(...arguments);
    this.daysInInterval = 7;
  }
  _getIntervalDuration(intervalCount) {
    return weekUtils.getIntervalDuration(intervalCount);
  }
  _calculateStartViewDate(options) {
    return weekUtils.calculateStartViewDate(options.currentDate, options.startDayHour, options.startDate, this._getIntervalDuration(options.intervalCount), this.getFirstDayOfWeek(options.firstDayOfWeek));
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator_work_week.js
var ViewDataGeneratorWorkWeek = class extends ViewDataGeneratorWeek {
  constructor() {
    super(...arguments);
    this.daysInInterval = 5;
    this.isWorkView = true;
  }
  isSkippedDate(date) {
    return isDataOnWeekend(date);
  }
  _calculateStartViewDate(options) {
    return workWeekUtils.calculateStartViewDate(options.currentDate, options.startDayHour, options.startDate, this._getIntervalDuration(options.intervalCount), this.getFirstDayOfWeek(options.firstDayOfWeek));
  }
  getFirstDayOfWeek(firstDayOfWeekOption) {
    return firstDayOfWeekOption || 0;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_utils.js
var DAYS_IN_WEEK = 7;
var MS_IN_DAY = 864e5;
var getViewDataGeneratorByViewType = (viewType) => {
  switch (viewType) {
    case VIEWS.MONTH:
      return new ViewDataGeneratorMonth();
    case VIEWS.TIMELINE_MONTH:
      return new ViewDataGeneratorTimelineMonth();
    case VIEWS.DAY:
    case VIEWS.TIMELINE_DAY:
      return new ViewDataGeneratorDay();
    case VIEWS.WEEK:
    case VIEWS.TIMELINE_WEEK:
      return new ViewDataGeneratorWeek();
    case VIEWS.WORK_WEEK:
    case VIEWS.TIMELINE_WORK_WEEK:
      return new ViewDataGeneratorWorkWeek();
    default:
      return new ViewDataGenerator();
  }
};
function alignToFirstDayOfWeek(date, firstDayOfWeek) {
  const newDate = new Date(date);
  let dayDiff = newDate.getDay() - firstDayOfWeek;
  if (dayDiff < 0) {
    dayDiff += DAYS_IN_WEEK;
  }
  newDate.setDate(newDate.getDate() - dayDiff);
  return newDate;
}
function alignToLastDayOfWeek(date, firstDayOfWeek) {
  const newDate = alignToFirstDayOfWeek(date, firstDayOfWeek);
  newDate.setDate(newDate.getDate() + DAYS_IN_WEEK - 1);
  return newDate;
}
function calculateDaysBetweenDates(fromDate, toDate) {
  const msDiff = date_default2.trimTime(toDate).getTime() - date_default2.trimTime(fromDate).getTime();
  return Math.round(msDiff / MS_IN_DAY) + 1;
}
function calculateAlignedWeeksBetweenDates(fromDate, toDate, firstDayOfWeek) {
  const alignedFromDate = alignToFirstDayOfWeek(fromDate, firstDayOfWeek);
  const alignedToDate = alignToLastDayOfWeek(toDate, firstDayOfWeek);
  const weekCount = calculateDaysBetweenDates(alignedFromDate, alignedToDate) / DAYS_IN_WEEK;
  return Math.max(weekCount, 6);
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_provider.js
var _excluded8 = ["groups", "groupOrientation", "groupByDate", "isAllDayPanelVisible", "viewOffset"];
var ViewDataProvider = class {
  constructor(viewType) {
    this.viewType = viewType;
    this.viewDataGenerator = getViewDataGeneratorByViewType(viewType);
    this.viewData = {};
    this.completeViewDataMap = [];
    this.completeDateHeaderMap = [];
    this.viewDataMap = {};
    this._groupedDataMapProvider = null;
  }
  get groupedDataMap() {
    return this._groupedDataMapProvider.groupedDataMap;
  }
  get hiddenInterval() {
    return this.viewDataGenerator.hiddenInterval;
  }
  isSkippedDate(date) {
    return this.viewDataGenerator.isSkippedDate(date);
  }
  update(options, isGenerateNewViewData) {
    this.viewDataGenerator = getViewDataGeneratorByViewType(options.viewType);
    const {
      viewDataGenerator
    } = this;
    const dateHeaderDataGenerator = new DateHeaderDataGenerator(viewDataGenerator);
    const timePanelDataGenerator = new TimePanelDataGenerator(viewDataGenerator);
    const renderOptions = this._transformRenderOptions(options);
    renderOptions.interval = this.viewDataGenerator.getInterval(renderOptions.hoursInterval);
    this._options = renderOptions;
    if (isGenerateNewViewData) {
      this.completeViewDataMap = viewDataGenerator.getCompleteViewDataMap(renderOptions);
      this.completeDateHeaderMap = dateHeaderDataGenerator.getCompleteDateHeaderMap(renderOptions, this.completeViewDataMap);
      if (renderOptions.isGenerateTimePanelData) {
        this.completeTimePanelMap = timePanelDataGenerator.getCompleteTimePanelMap(renderOptions, this.completeViewDataMap);
      }
    }
    this.viewDataMap = viewDataGenerator.generateViewDataMap(this.completeViewDataMap, renderOptions);
    this.updateViewData(renderOptions);
    this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, {
      isVerticalGrouping: renderOptions.isVerticalGrouping,
      viewType: renderOptions.viewType,
      viewOffset: options.viewOffset
    });
    this.dateHeaderData = dateHeaderDataGenerator.generateDateHeaderData(this.completeDateHeaderMap, this.completeViewDataMap, renderOptions);
    if (renderOptions.isGenerateTimePanelData) {
      this.timePanelData = timePanelDataGenerator.generateTimePanelData(this.completeTimePanelMap, renderOptions);
    }
  }
  createGroupedDataMapProvider() {
    this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, {
      isVerticalGrouping: this._options.isVerticalGrouping,
      viewType: this._options.viewType
    });
  }
  updateViewData(options) {
    const renderOptions = this._transformRenderOptions(options);
    this.viewDataMapWithSelection = this.viewDataGenerator.markSelectedAndFocusedCells(this.viewDataMap, renderOptions);
    this.viewData = this.viewDataGenerator.getViewDataFromMap(this.completeViewDataMap, this.viewDataMapWithSelection, renderOptions);
  }
  _transformRenderOptions(renderOptions) {
    const {
      groups,
      groupOrientation,
      groupByDate,
      isAllDayPanelVisible,
      viewOffset
    } = renderOptions, restOptions = _objectWithoutPropertiesLoose(renderOptions, _excluded8);
    return _extends({}, restOptions, {
      startViewDate: this.viewDataGenerator._calculateStartViewDate(renderOptions),
      isVerticalGrouping: isVerticalGroupingApplied(groups, groupOrientation),
      isHorizontalGrouping: isHorizontalGroupingApplied(groups, groupOrientation),
      isGroupedByDate: isGroupingByDate(groups, groupOrientation, groupByDate),
      isGroupedAllDayPanel: calculateIsGroupedAllDayPanel(groups, groupOrientation, isAllDayPanelVisible),
      groups,
      groupOrientation,
      isAllDayPanelVisible,
      viewOffset
    });
  }
  getGroupPanelData(options) {
    const renderOptions = this._transformRenderOptions(options);
    if (renderOptions.groups.length > 0) {
      const cellCount = this.getCellCount(renderOptions);
      return getGroupPanelData(renderOptions.groups, cellCount, renderOptions.isGroupedByDate, renderOptions.isGroupedByDate ? 1 : cellCount);
    }
    return;
  }
  getGroupStartDate(groupIndex) {
    return this._groupedDataMapProvider.getGroupStartDate(groupIndex);
  }
  getGroupEndDate(groupIndex) {
    return this._groupedDataMapProvider.getGroupEndDate(groupIndex);
  }
  findGroupCellStartDate(groupIndex, startDate, endDate) {
    let isFindByDate = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    return this._groupedDataMapProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isFindByDate);
  }
  findAllDayGroupCellStartDate(groupIndex) {
    return this._groupedDataMapProvider.findAllDayGroupCellStartDate(groupIndex);
  }
  findCellPositionInMap(cellInfo) {
    let isAppointmentRender = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    return this._groupedDataMapProvider.findCellPositionInMap(cellInfo, isAppointmentRender);
  }
  hasAllDayPanel() {
    const {
      viewData
    } = this.viewDataMap;
    const {
      allDayPanel
    } = viewData.groupedData[0];
    return !viewData.isGroupedAllDayPanel && (null === allDayPanel || void 0 === allDayPanel ? void 0 : allDayPanel.length) > 0;
  }
  getCellsGroup(groupIndex) {
    return this._groupedDataMapProvider.getCellsGroup(groupIndex);
  }
  getCompletedGroupsInfo() {
    return this._groupedDataMapProvider.getCompletedGroupsInfo();
  }
  getGroupIndices() {
    return this._groupedDataMapProvider.getGroupIndices();
  }
  getLastGroupCellPosition(groupIndex) {
    return this._groupedDataMapProvider.getLastGroupCellPosition(groupIndex);
  }
  getRowCountInGroup(groupIndex) {
    return this._groupedDataMapProvider.getRowCountInGroup(groupIndex);
  }
  getCellData(rowIndex, columnIndex, isAllDay, rtlEnabled) {
    const row = isAllDay && !this._options.isVerticalGrouping ? this.viewDataMap.allDayPanelMap : this.viewDataMap.dateTableMap[rowIndex];
    const actualColumnIndex = !rtlEnabled ? columnIndex : row.length - 1 - columnIndex;
    const {
      cellData
    } = row[actualColumnIndex];
    return cellData;
  }
  getCellsByGroupIndexAndAllDay(groupIndex, allDay) {
    const rowsPerGroup = this._getRowCountWithAllDayRows();
    const isShowAllDayPanel = this._options.isAllDayPanelVisible;
    const firstRowInGroup = this._options.isVerticalGrouping ? groupIndex * rowsPerGroup : 0;
    const lastRowInGroup = this._options.isVerticalGrouping ? (groupIndex + 1) * rowsPerGroup - 1 : rowsPerGroup;
    const correctedFirstRow = isShowAllDayPanel && !allDay ? firstRowInGroup + 1 : firstRowInGroup;
    const correctedLastRow = allDay ? correctedFirstRow : lastRowInGroup;
    return this.completeViewDataMap.slice(correctedFirstRow, correctedLastRow + 1).map((row) => row.filter((_ref) => {
      let {
        groupIndex: currentGroupIndex
      } = _ref;
      return groupIndex === currentGroupIndex;
    }));
  }
  getCellCountWithGroup(groupIndex) {
    let rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    return dateTableGroupedMap.filter((_, index) => index <= groupIndex).reduce((previous, row) => previous + row[rowIndex].length, 0);
  }
  hasGroupAllDayPanel(groupIndex) {
    var _this$groupedDataMap$2;
    if (this._options.isVerticalGrouping) {
      var _this$groupedDataMap$;
      return !!(null !== (_this$groupedDataMap$ = this.groupedDataMap.dateTableGroupedMap[groupIndex]) && void 0 !== _this$groupedDataMap$ && _this$groupedDataMap$[0][0].cellData.allDay);
    }
    return (null === (_this$groupedDataMap$2 = this.groupedDataMap.allDayPanelGroupedMap[groupIndex]) || void 0 === _this$groupedDataMap$2 ? void 0 : _this$groupedDataMap$2.length) > 0;
  }
  isGroupIntersectDateInterval(groupIndex, startDate, endDate) {
    const groupStartDate = this.getGroupStartDate(groupIndex);
    const groupEndDate = this.getGroupEndDate(groupIndex);
    return startDate < groupEndDate && endDate > groupStartDate;
  }
  findGlobalCellPosition(date) {
    let groupIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    let allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    const {
      completeViewDataMap
    } = this;
    const showAllDayPanel = this._options.isAllDayPanelVisible;
    for (let rowIndex = 0; rowIndex < completeViewDataMap.length; rowIndex += 1) {
      const currentRow = completeViewDataMap[rowIndex];
      for (let columnIndex = 0; columnIndex < currentRow.length; columnIndex += 1) {
        const cellData = currentRow[columnIndex];
        const {
          startDate: currentStartDate,
          endDate: currentEndDate,
          groupIndex: currentGroupIndex,
          allDay: currentAllDay
        } = cellData;
        if (groupIndex === currentGroupIndex && allDay === !!currentAllDay && this._compareDatesAndAllDay(date, currentStartDate, currentEndDate, allDay)) {
          return {
            position: {
              columnIndex,
              rowIndex: showAllDayPanel && !this._options.isVerticalGrouping ? rowIndex - 1 : rowIndex
            },
            cellData
          };
        }
      }
    }
    return;
  }
  _compareDatesAndAllDay(date, cellStartDate, cellEndDate, allDay) {
    return allDay ? date_default2.sameDate(date, cellStartDate) : date >= cellStartDate && date < cellEndDate;
  }
  getSkippedDaysCount(groupIndex, startDate, endDate, daysCount) {
    const {
      dateTableGroupedMap
    } = this._groupedDataMapProvider.groupedDataMap;
    const groupedData = dateTableGroupedMap[groupIndex];
    let includedDays = 0;
    for (let rowIndex = 0; rowIndex < groupedData.length; rowIndex += 1) {
      for (let columnIndex = 0; columnIndex < groupedData[rowIndex].length; columnIndex += 1) {
        const cell = groupedData[rowIndex][columnIndex].cellData;
        if (startDate.getTime() < cell.endDate.getTime() && endDate.getTime() > cell.startDate.getTime()) {
          includedDays += 1;
        }
      }
    }
    const lastCell = groupedData[groupedData.length - 1][groupedData[0].length - 1].cellData;
    const lastCellStart = date_default2.trimTime(lastCell.startDate);
    const daysAfterView = Math.floor((endDate.getTime() - lastCellStart.getTime()) / date_default2.dateToMilliseconds("day"));
    const deltaDays = daysAfterView > 0 ? daysAfterView : 0;
    return daysCount - includedDays - deltaDays;
  }
  getColumnsCount() {
    const {
      dateTableMap
    } = this.viewDataMap;
    return dateTableMap ? dateTableMap[0].length : 0;
  }
  getViewEdgeIndices(isAllDayPanel) {
    if (isAllDayPanel) {
      return {
        firstColumnIndex: 0,
        lastColumnIndex: this.viewDataMap.allDayPanelMap.length - 1,
        firstRowIndex: 0,
        lastRowIndex: 0
      };
    }
    return {
      firstColumnIndex: 0,
      lastColumnIndex: this.viewDataMap.dateTableMap[0].length - 1,
      firstRowIndex: 0,
      lastRowIndex: this.viewDataMap.dateTableMap.length - 1
    };
  }
  getGroupEdgeIndices(groupIndex, isAllDay) {
    const groupedDataMap = this.groupedDataMap.dateTableGroupedMap[groupIndex];
    const cellsCount = groupedDataMap[0].length;
    const rowsCount = groupedDataMap.length;
    const firstColumnIndex = groupedDataMap[0][0].position.columnIndex;
    const lastColumnIndex = groupedDataMap[0][cellsCount - 1].position.columnIndex;
    if (isAllDay) {
      return {
        firstColumnIndex,
        lastColumnIndex,
        firstRowIndex: 0,
        lastRowIndex: 0
      };
    }
    return {
      firstColumnIndex,
      lastColumnIndex,
      firstRowIndex: groupedDataMap[0][0].position.rowIndex,
      lastRowIndex: groupedDataMap[rowsCount - 1][0].position.rowIndex
    };
  }
  isSameCell(firstCellData, secondCellData) {
    const {
      startDate: firstStartDate,
      groupIndex: firstGroupIndex,
      allDay: firstAllDay,
      index: firstIndex
    } = firstCellData;
    const {
      startDate: secondStartDate,
      groupIndex: secondGroupIndex,
      allDay: secondAllDay,
      index: secondIndex
    } = secondCellData;
    return firstStartDate.getTime() === secondStartDate.getTime() && firstGroupIndex === secondGroupIndex && firstAllDay === secondAllDay && firstIndex === secondIndex;
  }
  getLastViewDate() {
    const {
      completeViewDataMap
    } = this;
    const rowsCount = completeViewDataMap.length - 1;
    return completeViewDataMap[rowsCount][completeViewDataMap[rowsCount].length - 1].endDate;
  }
  getStartViewDate() {
    return this._options.startViewDate;
  }
  getIntervalDuration(intervalCount) {
    return this.viewDataGenerator._getIntervalDuration(intervalCount);
  }
  getLastCellEndDate() {
    const lastEndDate = new Date(this.getLastViewDate().getTime() - date_default2.dateToMilliseconds("minute"));
    return dateUtilsTs.addOffsets(lastEndDate, [-this._options.viewOffset]);
  }
  getLastViewDateByEndDayHour(endDayHour) {
    const lastCellEndDate = this.getLastCellEndDate();
    const endTime = date_default2.dateTimeFromDecimal(endDayHour);
    const endDateOfLastViewCell = new Date(lastCellEndDate.setHours(endTime.hours, endTime.minutes));
    return this._adjustEndDateByDaylightDiff(lastCellEndDate, endDateOfLastViewCell);
  }
  _adjustEndDateByDaylightDiff(startDate, endDate) {
    const daylightDiff = m_utils_time_zone_default.getDaylightOffsetInMs(startDate, endDate);
    const endDateOfLastViewCell = new Date(endDate.getTime() - daylightDiff);
    return new Date(endDateOfLastViewCell.getTime() - date_default2.dateToMilliseconds("minute"));
  }
  getCellCountInDay(startDayHour, endDayHour, hoursInterval) {
    return this.viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
  }
  getCellCount(options) {
    return this.viewDataGenerator.getCellCount(options);
  }
  getRowCount(options) {
    return this.viewDataGenerator.getRowCount(options);
  }
  getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {
    return this.viewDataGenerator.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);
  }
  _getRowCountWithAllDayRows() {
    const allDayRowCount = this._options.isAllDayPanelVisible ? 1 : 0;
    return this.getRowCount(this._options) + allDayRowCount;
  }
  getFirstDayOfWeek(firstDayOfWeekOption) {
    return this.viewDataGenerator.getFirstDayOfWeek(firstDayOfWeekOption);
  }
  setViewOptions(options) {
    this._options = this._transformRenderOptions(options);
  }
  getViewOptions() {
    return this._options;
  }
  getViewPortGroupCount() {
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    return (null === dateTableGroupedMap || void 0 === dateTableGroupedMap ? void 0 : dateTableGroupedMap.length) || 0;
  }
  getCellsBetween(first, last) {
    const [firstCell, lastCell] = this.normalizeCellsOrder(first, last);
    const {
      index: firstIdx
    } = firstCell;
    const {
      index: lastIdx
    } = lastCell;
    const cellMatrix = this.getCellsByGroupIndexAndAllDay(firstCell.groupIndex ?? 0, lastCell.allDay ?? false);
    return isHorizontalView(this.viewType) ? this.getCellsBetweenHorizontalView(cellMatrix, firstIdx, lastIdx) : this.getCellsBetweenVerticalView(cellMatrix, firstIdx, lastIdx);
  }
  getCellsBetweenHorizontalView(cellMatrix, firstIdx, lastIdx) {
    return cellMatrix.reduce((result, row) => result.concat(row.filter((_ref2) => {
      let {
        index
      } = _ref2;
      return firstIdx <= index && index <= lastIdx;
    })), []);
  }
  getCellsBetweenVerticalView(cellMatrix, firstIdx, lastIdx) {
    var _cellMatrix$;
    const result = [];
    const matrixHeight = cellMatrix.length;
    const matrixWidth = (null === (_cellMatrix$ = cellMatrix[0]) || void 0 === _cellMatrix$ ? void 0 : _cellMatrix$.length) ?? 0;
    let inSegment = false;
    for (let columnIdx = 0; columnIdx < matrixWidth; columnIdx += 1) {
      for (let rowIdx = 0; rowIdx < matrixHeight; rowIdx += 1) {
        const cell = cellMatrix[rowIdx][columnIdx];
        const {
          index: cellIdx
        } = cell;
        if (cellIdx === firstIdx) {
          inSegment = true;
        }
        if (inSegment) {
          result.push(cell);
        }
        if (cellIdx === lastIdx) {
          return result;
        }
      }
    }
    return result;
  }
  normalizeCellsOrder(firstSelectedCell, lastSelectedCell) {
    return firstSelectedCell.startDate > lastSelectedCell.startDate ? [lastSelectedCell, firstSelectedCell] : [firstSelectedCell, lastSelectedCell];
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space.js
var {
  tableCreator
} = m_table_creator_default;
var {
  abstract
} = m_widget_observer_default;
var toMs22 = date_default2.dateToMilliseconds;
var COMPONENT_CLASS3 = "dx-scheduler-work-space";
var GROUPED_WORKSPACE_CLASS = "dx-scheduler-work-space-grouped";
var VERTICAL_GROUPED_WORKSPACE_CLASS = "dx-scheduler-work-space-vertical-grouped";
var WORKSPACE_VERTICAL_GROUP_TABLE_CLASS = "dx-scheduler-work-space-vertical-group-table";
var WORKSPACE_WITH_BOTH_SCROLLS_CLASS = "dx-scheduler-work-space-both-scrollbar";
var WORKSPACE_WITH_COUNT_CLASS = "dx-scheduler-work-space-count";
var WORKSPACE_WITH_GROUP_BY_DATE_CLASS = "dx-scheduler-work-space-group-by-date";
var WORKSPACE_WITH_ODD_CELLS_CLASS = "dx-scheduler-work-space-odd-cells";
var TIME_PANEL_CELL_CLASS = "dx-scheduler-time-panel-cell";
var TIME_PANEL_ROW_CLASS = "dx-scheduler-time-panel-row";
var ALL_DAY_PANEL_CLASS = "dx-scheduler-all-day-panel";
var ALL_DAY_TABLE_CLASS = "dx-scheduler-all-day-table";
var ALL_DAY_CONTAINER_CLASS = "dx-scheduler-all-day-appointments";
var ALL_DAY_TITLE_CLASS = "dx-scheduler-all-day-title";
var ALL_DAY_TABLE_CELL_CLASS = "dx-scheduler-all-day-table-cell";
var ALL_DAY_TABLE_ROW_CLASS = "dx-scheduler-all-day-table-row";
var WORKSPACE_WITH_ALL_DAY_CLASS = "dx-scheduler-work-space-all-day";
var WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS = "dx-scheduler-work-space-all-day-collapsed";
var WORKSPACE_WITH_MOUSE_SELECTION_CLASS = "dx-scheduler-work-space-mouse-selection";
var HORIZONTAL_SIZES_CLASS = "dx-scheduler-cell-sizes-horizontal";
var VERTICAL_SIZES_CLASS = "dx-scheduler-cell-sizes-vertical";
var HEADER_PANEL_CLASS = "dx-scheduler-header-panel";
var HEADER_PANEL_CELL_CLASS = "dx-scheduler-header-panel-cell";
var HEADER_ROW_CLASS = "dx-scheduler-header-row";
var GROUP_HEADER_CLASS = "dx-scheduler-group-header";
var DATE_TABLE_CELL_CLASS2 = "dx-scheduler-date-table-cell";
var VIRTUAL_ROW_CLASS = "dx-scheduler-virtual-row";
var DATE_TABLE_DROPPABLE_CELL_CLASS = "dx-scheduler-date-table-droppable-cell";
var SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME = addNamespace(pointer_default.down, "dxSchedulerWorkSpace");
var DragEventNames = {
  ENTER: addNamespace(DRAG_ENTER_EVENT, "dxSchedulerDateTable"),
  DROP: addNamespace(DROP_EVENT, "dxSchedulerDateTable"),
  LEAVE: addNamespace(DRAG_LEAVE_EVENT, "dxSchedulerDateTable")
};
var SCHEDULER_CELL_DXCLICK_EVENT_NAME = addNamespace(CLICK_EVENT_NAME, "dxSchedulerDateTable");
var SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME = addNamespace(pointer_default.down, "dxSchedulerDateTable");
var SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME = addNamespace(pointer_default.up, "dxSchedulerDateTable");
var SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME = addNamespace(pointer_default.move, "dxSchedulerDateTable");
var CELL_DATA = "dxCellData";
var DAY_MS = toMs22("day");
var HOUR_MS = toMs22("hour");
var DRAG_AND_DROP_SELECTOR = `.${DATE_TABLE_CLASS} td, .${ALL_DAY_TABLE_CLASS} td`;
var CELL_SELECTOR = `.${DATE_TABLE_CELL_CLASS2}, .${ALL_DAY_TABLE_CELL_CLASS}`;
var DEFAULT_WORKSPACE_RENDER_OPTIONS = {
  renderComponents: {
    header: true,
    timePanel: true,
    dateTable: true,
    allDayPanel: true
  },
  generateNewData: true
};
var SchedulerWorkSpace = class extends m_widget_observer_default {
  constructor() {
    super(...arguments);
    this.viewDirection = "vertical";
  }
  get type() {
    return "";
  }
  get viewDataProvider() {
    if (!this._viewDataProvider) {
      this._viewDataProvider = new ViewDataProvider(this.type);
    }
    return this._viewDataProvider;
  }
  get cache() {
    if (!this._cache) {
      this._cache = new Cache2();
    }
    return this._cache;
  }
  get cellsSelectionState() {
    if (!this._cellsSelectionState) {
      this._cellsSelectionState = new CellsSelectionState(this.viewDataProvider);
      const selectedCellsOption = this.option("selectedCellData");
      if ((null === selectedCellsOption || void 0 === selectedCellsOption ? void 0 : selectedCellsOption.length) > 0) {
        const validSelectedCells = selectedCellsOption.map((selectedCell) => {
          const {
            groups
          } = selectedCell;
          if (!groups || 0 === this._getGroupCount()) {
            return _extends({}, selectedCell, {
              groupIndex: 0
            });
          }
          const groupIndex = this._getGroupIndexByResourceId(groups);
          return _extends({}, selectedCell, {
            groupIndex
          });
        });
        this._cellsSelectionState.setSelectedCellsByData(validSelectedCells);
      }
    }
    return this._cellsSelectionState;
  }
  get cellsSelectionController() {
    if (!this._cellsSelectionController) {
      this._cellsSelectionController = new CellsSelectionController();
    }
    return this._cellsSelectionController;
  }
  get isAllDayPanelVisible() {
    return this._isShowAllDayPanel() && this.supportAllDayRow();
  }
  get verticalGroupTableClass() {
    return WORKSPACE_VERTICAL_GROUP_TABLE_CLASS;
  }
  get renovatedHeaderPanelComponent() {
    return HeaderPanelComponent;
  }
  get timeZoneCalculator() {
    return this.option("timeZoneCalculator");
  }
  get isDefaultDraggingMode() {
    return "default" === this.option("draggingMode");
  }
  _supportedKeys() {
    const clickHandler = function(e) {
      e.preventDefault();
      e.stopPropagation();
      const selectedCells = this.cellsSelectionState.getSelectedCells();
      if (null !== selectedCells && void 0 !== selectedCells && selectedCells.length) {
        const selectedCellsElement = selectedCells.map((cellData) => this._getCellByData(cellData)).filter((cell) => !!cell);
        e.target = selectedCellsElement;
        this._showPopup = true;
        this._cellClickAction({
          event: e,
          cellElement: renderer_default(selectedCellsElement),
          cellData: selectedCells[0]
        });
      }
    };
    const onArrowPressed = (e, key) => {
      var _this$cellsSelectionS;
      e.preventDefault();
      e.stopPropagation();
      const focusedCellData = null === (_this$cellsSelectionS = this.cellsSelectionState.focusedCell) || void 0 === _this$cellsSelectionS ? void 0 : _this$cellsSelectionS.cellData;
      if (focusedCellData) {
        const isAllDayPanelCell = focusedCellData.allDay && !this._isVerticalGroupedWorkSpace();
        const isMultiSelection = e.shiftKey;
        const isMultiSelectionAllowed = this.option("allowMultipleCellSelection");
        const isRTL = this._isRTL();
        const groupCount = this._getGroupCount();
        const isGroupedByDate = this.isGroupedByDate();
        const isHorizontalGrouping = this._isHorizontalGroupedWorkSpace();
        const focusedCellPosition = this.viewDataProvider.findCellPositionInMap(_extends({}, focusedCellData, {
          isAllDay: focusedCellData.allDay
        }));
        const edgeIndices = isHorizontalGrouping && isMultiSelection && !isGroupedByDate ? this.viewDataProvider.getGroupEdgeIndices(focusedCellData.groupIndex, isAllDayPanelCell) : this.viewDataProvider.getViewEdgeIndices(isAllDayPanelCell);
        const nextCellData = this.cellsSelectionController.handleArrowClick({
          focusedCellPosition,
          edgeIndices,
          isRTL,
          isGroupedByDate,
          groupCount,
          isMultiSelection,
          isMultiSelectionAllowed,
          viewType: this.type,
          key,
          getCellDataByPosition: this.viewDataProvider.getCellData.bind(this.viewDataProvider),
          isAllDayPanelCell,
          focusedCellData
        });
        this._processNextSelectedCell(nextCellData, focusedCellData, isMultiSelection && isMultiSelectionAllowed);
      }
    };
    return extend(super._supportedKeys(), {
      enter: clickHandler,
      space: clickHandler,
      downArrow: (e) => {
        onArrowPressed(e, "down");
      },
      upArrow: (e) => {
        onArrowPressed(e, "up");
      },
      rightArrow: (e) => {
        onArrowPressed(e, "right");
      },
      leftArrow: (e) => {
        onArrowPressed(e, "left");
      }
    });
  }
  _isRTL() {
    return this.option("rtlEnabled");
  }
  _moveToCell($cell, isMultiSelection) {
    if (!isDefined($cell) || !$cell.length) {
      return;
    }
    const isMultiSelectionAllowed = this.option("allowMultipleCellSelection");
    const currentCellData = this._getFullCellData($cell);
    const focusedCellData = this.cellsSelectionState.focusedCell.cellData;
    const nextFocusedCellData = this.cellsSelectionController.moveToCell({
      isMultiSelection,
      isMultiSelectionAllowed,
      currentCellData,
      focusedCellData,
      isVirtualCell: $cell.hasClass(VIRTUAL_CELL_CLASS)
    });
    this._processNextSelectedCell(nextFocusedCellData, focusedCellData, isMultiSelectionAllowed && isMultiSelection);
  }
  _processNextSelectedCell(nextCellData, focusedCellData, isMultiSelection) {
    const nextCellPosition = this.viewDataProvider.findCellPositionInMap({
      startDate: nextCellData.startDate,
      groupIndex: nextCellData.groupIndex,
      isAllDay: nextCellData.allDay,
      index: nextCellData.index
    });
    if (!this.viewDataProvider.isSameCell(focusedCellData, nextCellData)) {
      const $cell = nextCellData.allDay && !this._isVerticalGroupedWorkSpace() ? this._dom_getAllDayPanelCell(nextCellPosition.columnIndex) : this._dom_getDateCell(nextCellPosition);
      const isNextCellAllDay = nextCellData.allDay;
      this._setSelectedCellsStateAndUpdateSelection(isNextCellAllDay, nextCellPosition, isMultiSelection, $cell);
      this._dateTableScrollable.scrollToElement($cell);
    }
  }
  _setSelectedCellsStateAndUpdateSelection(isAllDay, cellPosition, isMultiSelection, $nextFocusedCell) {
    const nextCellCoordinates = {
      rowIndex: cellPosition.rowIndex,
      columnIndex: cellPosition.columnIndex,
      allDay: isAllDay
    };
    this.cellsSelectionState.setFocusedCell(nextCellCoordinates.rowIndex, nextCellCoordinates.columnIndex, isAllDay);
    if (isMultiSelection) {
      this.cellsSelectionState.setSelectedCells(nextCellCoordinates);
    } else {
      this.cellsSelectionState.setSelectedCells(nextCellCoordinates, nextCellCoordinates);
    }
    this.updateCellsSelection();
    this._updateSelectedCellDataOption(this.cellsSelectionState.getSelectedCells(), $nextFocusedCell);
  }
  _hasAllDayClass($cell) {
    return $cell.hasClass(ALL_DAY_TABLE_CELL_CLASS);
  }
  _focusInHandler(e) {
    if (renderer_default(e.target).is(this._focusTarget()) && false !== this._isCellClick) {
      delete this._isCellClick;
      delete this._contextMenuHandled;
      super._focusInHandler.apply(this, arguments);
      this.cellsSelectionState.restoreSelectedAndFocusedCells();
      if (!this.cellsSelectionState.focusedCell) {
        const cellCoordinates = {
          columnIndex: 0,
          rowIndex: 0,
          allDay: this._isVerticalGroupedWorkSpace() && this.isAllDayPanelVisible
        };
        this.cellsSelectionState.setFocusedCell(cellCoordinates.rowIndex, cellCoordinates.columnIndex, cellCoordinates.allDay);
        this.cellsSelectionState.setSelectedCells(cellCoordinates, cellCoordinates);
      }
      this.updateCellsSelection();
      this._updateSelectedCellDataOption(this.cellsSelectionState.getSelectedCells());
    }
  }
  _focusOutHandler() {
    super._focusOutHandler.apply(this, arguments);
    if (!this._contextMenuHandled && !this._disposed) {
      this.cellsSelectionState.releaseSelectedAndFocusedCells();
      this.viewDataProvider.updateViewData(this.generateRenderOptions());
      this.updateCellsSelection();
    }
  }
  _focusTarget() {
    return this.$element();
  }
  _isVerticalGroupedWorkSpace() {
    var _this$option;
    return !!(null !== (_this$option = this.option("groups")) && void 0 !== _this$option && _this$option.length) && "vertical" === this.option("groupOrientation");
  }
  _isHorizontalGroupedWorkSpace() {
    var _this$option2;
    return !!(null !== (_this$option2 = this.option("groups")) && void 0 !== _this$option2 && _this$option2.length) && "horizontal" === this.option("groupOrientation");
  }
  _isWorkSpaceWithCount() {
    return this.option("intervalCount") > 1;
  }
  _isWorkspaceWithOddCells() {
    return 0.5 === this.option("hoursInterval") && !this.isVirtualScrolling();
  }
  _getRealGroupOrientation() {
    return this._isVerticalGroupedWorkSpace() ? "vertical" : "horizontal";
  }
  createRAllDayPanelElements() {
    this._$allDayPanel = renderer_default("<div>").addClass(ALL_DAY_PANEL_CLASS);
    this._$allDayTitle = renderer_default("<div>").appendTo(this._$headerPanelEmptyCell);
  }
  _dateTableScrollableConfig() {
    let config = {
      useKeyboard: false,
      bounceEnabled: false,
      updateManually: true,
      onScroll: () => {
        var _this$_groupedStrateg;
        null === (_this$_groupedStrateg = this._groupedStrategy.cache) || void 0 === _this$_groupedStrateg || _this$_groupedStrateg.clear();
      }
    };
    if (this._needCreateCrossScrolling()) {
      config = extend(config, this._createCrossScrollingConfig(config));
    }
    if (this.isVirtualScrolling() && (this.virtualScrollingDispatcher.horizontalScrollingAllowed || this.virtualScrollingDispatcher.height)) {
      const currentOnScroll = config.onScroll;
      config = _extends({}, config, {
        onScroll: (e) => {
          null === currentOnScroll || void 0 === currentOnScroll || currentOnScroll(e);
          this.virtualScrollingDispatcher.handleOnScrollEvent(null === e || void 0 === e ? void 0 : e.scrollOffset);
        }
      });
    }
    return config;
  }
  _createCrossScrollingConfig(_ref) {
    let {
      onScroll
    } = _ref;
    return {
      direction: "both",
      onScroll: (event) => {
        null === onScroll || void 0 === onScroll || onScroll();
        this._scrollSync.sidebar({
          top: event.scrollOffset.top
        });
        this._scrollSync.header({
          left: event.scrollOffset.left
        });
      },
      onEnd: () => {
        this.option("onScrollEnd")();
      }
    };
  }
  _headerScrollableConfig() {
    return {
      useKeyboard: false,
      showScrollbar: "never",
      direction: "horizontal",
      useNative: false,
      updateManually: true,
      bounceEnabled: false,
      onScroll: (event) => {
        this._scrollSync.dateTable({
          left: event.scrollOffset.left
        });
      }
    };
  }
  _visibilityChanged(visible) {
    this.cache.clear();
    if (visible) {
      this._updateGroupTableHeight();
    }
    if (visible && this._needCreateCrossScrolling()) {
      this._setTableSizes();
    }
  }
  _setTableSizes() {
    this.cache.clear();
    this._attachTableClasses();
    let cellWidth = this.getCellWidth();
    if (cellWidth < this.getCellMinWidth()) {
      cellWidth = this.getCellMinWidth();
    }
    const minWidth = this.getWorkSpaceMinWidth();
    const groupCount = this._getGroupCount();
    const totalCellCount = this._getTotalCellCount(groupCount);
    let width = cellWidth * totalCellCount;
    if (width < minWidth) {
      width = minWidth;
    }
    setWidth(this._$headerPanel, width);
    setWidth(this._$dateTable, width);
    if (this._$allDayTable) {
      setWidth(this._$allDayTable, width);
    }
    this._attachHeaderTableClasses();
    this._updateGroupTableHeight();
    this._updateScrollable();
  }
  getWorkSpaceMinWidth() {
    return this._groupedStrategy.getWorkSpaceMinWidth();
  }
  _dimensionChanged() {
    if (!this._isVisible()) {
      return;
    }
    if (this.option("crossScrollingEnabled")) {
      this._setTableSizes();
    }
    this.updateHeaderEmptyCellWidth();
    this._updateScrollable();
    this.cache.clear();
  }
  _needCreateCrossScrolling() {
    return this.option("crossScrollingEnabled");
  }
  _getElementClass() {
    return noop();
  }
  _getRowCount() {
    return this.viewDataProvider.getRowCount({
      intervalCount: this.option("intervalCount"),
      currentDate: this.option("currentDate"),
      viewType: this.type,
      hoursInterval: this.option("hoursInterval"),
      startDayHour: this.option("startDayHour"),
      endDayHour: this.option("endDayHour")
    });
  }
  _getCellCount() {
    return this.viewDataProvider.getCellCount({
      intervalCount: this.option("intervalCount"),
      currentDate: this.option("currentDate"),
      viewType: this.type,
      hoursInterval: this.option("hoursInterval"),
      startDayHour: this.option("startDayHour"),
      endDayHour: this.option("endDayHour")
    });
  }
  isRenovatedRender() {
    return this.renovatedRenderSupported() && this.option("renovateRender");
  }
  _isVirtualModeOn() {
    return "virtual" === this.option("scrolling.mode");
  }
  isVirtualScrolling() {
    return this.isRenovatedRender() && this._isVirtualModeOn();
  }
  _initVirtualScrolling() {
    if (this.virtualScrollingDispatcher) {
      this.virtualScrollingDispatcher.dispose();
      this.virtualScrollingDispatcher = null;
    }
    this.virtualScrollingDispatcher = new VirtualScrollingDispatcher(this._getVirtualScrollingDispatcherOptions());
    this.virtualScrollingDispatcher.attachScrollableEvents();
    this.renderer = new VirtualScrollingRenderer(this);
  }
  onDataSourceChanged(argument) {
  }
  isGroupedAllDayPanel() {
    return calculateIsGroupedAllDayPanel(this.option("groups"), this.option("groupOrientation"), this.isAllDayPanelVisible);
  }
  generateRenderOptions(isProvideVirtualCellsWidth) {
    var _this$_getToday;
    const groupCount = this._getGroupCount();
    const groupOrientation = groupCount > 0 ? this.option("groupOrientation") : this._getDefaultGroupStrategy();
    const options = _extends({
      groupByDate: this.option("groupByDate"),
      startRowIndex: 0,
      startCellIndex: 0,
      groupOrientation,
      today: null === (_this$_getToday = this._getToday) || void 0 === _this$_getToday ? void 0 : _this$_getToday.call(this),
      groups: this.option("groups"),
      isProvideVirtualCellsWidth,
      isAllDayPanelVisible: this.isAllDayPanelVisible,
      selectedCells: this.cellsSelectionState.getSelectedCells(),
      focusedCell: this.cellsSelectionState.focusedCell,
      headerCellTextFormat: this._getFormat(),
      getDateForHeaderText: (_, date) => date,
      viewOffset: this.option("viewOffset"),
      startDayHour: this.option("startDayHour"),
      endDayHour: this.option("endDayHour"),
      cellDuration: this.getCellDuration(),
      viewType: this.type,
      intervalCount: this.option("intervalCount"),
      hoursInterval: this.option("hoursInterval"),
      currentDate: this.option("currentDate"),
      startDate: this.option("startDate"),
      firstDayOfWeek: this.option("firstDayOfWeek"),
      showCurrentTimeIndicator: this.option("showCurrentTimeIndicator")
    }, this.virtualScrollingDispatcher.getRenderState());
    return options;
  }
  renovatedRenderSupported() {
    return true;
  }
  _updateGroupTableHeight() {
    if (this._isVerticalGroupedWorkSpace() && hasWindow()) {
      this._setHorizontalGroupHeaderCellsHeight();
    }
  }
  updateHeaderEmptyCellWidth() {
    if (hasWindow() && this._isRenderHeaderPanelEmptyCell()) {
      const timePanelWidth = this.getTimePanelWidth();
      const groupPanelWidth = this.getGroupTableWidth();
      this._$headerPanelEmptyCell.css("width", timePanelWidth + groupPanelWidth);
    }
  }
  _isGroupsSpecified(resources) {
    var _this$option3;
    return (null === (_this$option3 = this.option("groups")) || void 0 === _this$option3 ? void 0 : _this$option3.length) && resources;
  }
  _getGroupIndexByResourceId(id) {
    const groups = this.option("groups");
    const resourceTree = createResourcesTree(groups);
    if (!resourceTree.length) {
      return 0;
    }
    return this._getGroupIndexRecursively(resourceTree, id);
  }
  _getGroupIndexRecursively(resourceTree, id) {
    const currentKey = resourceTree[0].name;
    const currentValue = id[currentKey];
    return resourceTree.reduce((prevIndex, _ref2) => {
      let {
        leafIndex,
        value: value2,
        children
      } = _ref2;
      const areValuesEqual = currentValue === value2;
      if (areValuesEqual && void 0 !== leafIndex) {
        return leafIndex;
      }
      if (areValuesEqual) {
        return this._getGroupIndexRecursively(children, id);
      }
      return prevIndex;
    }, 0);
  }
  _getViewStartByOptions() {
    return getViewStartByOptions(this.option("startDate"), this.option("currentDate"), this._getIntervalDuration(), this.option("startDate") ? this._calculateViewStartDate() : void 0);
  }
  _getIntervalDuration() {
    return this.viewDataProvider.getIntervalDuration(this.option("intervalCount"));
  }
  _getHeaderDate() {
    return this.getStartViewDate();
  }
  _calculateViewStartDate() {
    return calculateViewStartDate(this.option("startDate"));
  }
  _firstDayOfWeek() {
    return this.viewDataProvider.getFirstDayOfWeek(this.option("firstDayOfWeek"));
  }
  _attachEvents() {
    this._createSelectionChangedAction();
    this._attachClickEvent();
    this._attachContextMenuEvent();
  }
  _attachClickEvent() {
    const that = this;
    const pointerDownAction = this._createAction((e) => {
      that._pointerDownHandler(e.event);
    });
    this._createCellClickAction();
    const cellSelector = `.${DATE_TABLE_CELL_CLASS2},.${ALL_DAY_TABLE_CELL_CLASS}`;
    const $element = this.$element();
    events_engine_default.off($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME);
    events_engine_default.off($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME);
    events_engine_default.on($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME, (e) => {
      if (isMouseEvent(e) && e.which > 1) {
        e.preventDefault();
        return;
      }
      pointerDownAction({
        event: e
      });
    });
    events_engine_default.on($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME, cellSelector, (e) => {
      const $cell = renderer_default(e.target);
      that._cellClickAction({
        event: e,
        cellElement: getPublicElement($cell),
        cellData: that.getCellData($cell)
      });
    });
  }
  _createCellClickAction() {
    this._cellClickAction = this._createActionByOption("onCellClick", {
      afterExecute: (e) => this._cellClickHandler(e.args[0].event)
    });
  }
  _createSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged");
  }
  _cellClickHandler(argument) {
    if (this._showPopup) {
      delete this._showPopup;
      this._handleSelectedCellsClick();
    }
  }
  _pointerDownHandler(e) {
    const $target = renderer_default(e.target);
    if (!$target.hasClass(DATE_TABLE_CELL_CLASS2) && !$target.hasClass(ALL_DAY_TABLE_CELL_CLASS)) {
      this._isCellClick = false;
      return;
    }
    this._isCellClick = true;
    if ($target.hasClass("dx-scheduler-focused-cell")) {
      this._showPopup = true;
    } else {
      const cellCoordinates = this._getCoordinatesByCell($target);
      const isAllDayCell = this._hasAllDayClass($target);
      this._setSelectedCellsStateAndUpdateSelection(isAllDayCell, cellCoordinates, false, $target);
    }
  }
  _handleSelectedCellsClick() {
    const selectedCells = this.cellsSelectionState.getSelectedCells();
    const firstCellData = selectedCells[0];
    const lastCellData = selectedCells[selectedCells.length - 1];
    const result = {
      startDate: firstCellData.startDate,
      endDate: lastCellData.endDate
    };
    if (void 0 !== lastCellData.allDay) {
      result.allDay = lastCellData.allDay;
    }
    this.option("onSelectedCellsClick")(result, lastCellData.groups);
  }
  _attachContextMenuEvent() {
    this._createContextMenuAction();
    const cellSelector = `.${DATE_TABLE_CELL_CLASS2},.${ALL_DAY_TABLE_CELL_CLASS}`;
    const $element = this.$element();
    const eventName = addNamespace(name, this.NAME);
    events_engine_default.off($element, eventName, cellSelector);
    events_engine_default.on($element, eventName, cellSelector, this._contextMenuHandler.bind(this));
  }
  _contextMenuHandler(e) {
    const $cell = renderer_default(e.target);
    this._contextMenuAction({
      event: e,
      cellElement: getPublicElement($cell),
      cellData: this.getCellData($cell)
    });
    this._contextMenuHandled = true;
  }
  _createContextMenuAction() {
    this._contextMenuAction = this._createActionByOption("onCellContextMenu");
  }
  _getGroupHeaderContainer() {
    if (this._isVerticalGroupedWorkSpace()) {
      return this._$groupTable;
    }
    return this._$thead;
  }
  _getDateHeaderContainer() {
    return this._$thead;
  }
  _getCalculateHeaderCellRepeatCount() {
    return this._groupedStrategy.calculateHeaderCellRepeatCount();
  }
  _updateScrollable() {
    var _this$_headerScrollab, _this$_sidebarScrolla;
    this._dateTableScrollable.update();
    null === (_this$_headerScrollab = this._headerScrollable) || void 0 === _this$_headerScrollab || _this$_headerScrollab.update();
    null === (_this$_sidebarScrolla = this._sidebarScrollable) || void 0 === _this$_sidebarScrolla || _this$_sidebarScrolla.update();
  }
  _getTimePanelRowCount() {
    return this._getCellCountInDay();
  }
  _getCellCountInDay() {
    const hoursInterval = this.option("hoursInterval");
    const startDayHour = this.option("startDayHour");
    const endDayHour = this.option("endDayHour");
    return this.viewDataProvider.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
  }
  _getTotalCellCount(groupCount) {
    return this._groupedStrategy.getTotalCellCount(groupCount);
  }
  _getTotalRowCount(groupCount, includeAllDayPanelRows) {
    let result = this._groupedStrategy.getTotalRowCount(groupCount);
    if (includeAllDayPanelRows && this.isAllDayPanelVisible) {
      result += groupCount;
    }
    return result;
  }
  _getGroupIndex(rowIndex, columnIndex) {
    return this._groupedStrategy.getGroupIndex(rowIndex, columnIndex);
  }
  calculateEndDate(startDate) {
    const {
      viewDataGenerator
    } = this.viewDataProvider;
    return viewDataGenerator.calculateEndDate(startDate, viewDataGenerator.getInterval(this.option("hoursInterval")), this.option("endDayHour"));
  }
  _getGroupCount() {
    return getGroupCount(this.option("groups"));
  }
  _attachTablesEvents() {
    const element = this.$element();
    this._attachDragEvents(element);
    this._attachPointerEvents(element);
  }
  _detachDragEvents(element) {
    events_engine_default.off(element, DragEventNames.ENTER);
    events_engine_default.off(element, DragEventNames.LEAVE);
    events_engine_default.off(element, DragEventNames.DROP);
  }
  _attachDragEvents(element) {
    this._detachDragEvents(element);
    events_engine_default.on(element, DragEventNames.ENTER, DRAG_AND_DROP_SELECTOR, {
      checkDropTarget: (target, event) => !this._isOutsideScrollable(target, event)
    }, (e) => {
      if (!this.preventDefaultDragging) {
        this.removeDroppableCellClass();
        renderer_default(e.target).addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
      }
    });
    events_engine_default.on(element, DragEventNames.LEAVE, () => {
      if (!this.preventDefaultDragging) {
        this.removeDroppableCellClass();
      }
    });
    events_engine_default.on(element, DragEventNames.DROP, DRAG_AND_DROP_SELECTOR, () => {
      var _this$dragBehavior, _this$dragBehavior$dr;
      if (!this.dragBehavior) {
        return;
      }
      if (!(null !== (_this$dragBehavior = this.dragBehavior) && void 0 !== _this$dragBehavior && _this$dragBehavior.dragBetweenComponentsPromise)) {
        this.dragBehavior.removeDroppableClasses();
        return;
      }
      null === (_this$dragBehavior$dr = this.dragBehavior.dragBetweenComponentsPromise) || void 0 === _this$dragBehavior$dr || _this$dragBehavior$dr.then(() => {
        this.dragBehavior.removeDroppableClasses();
      });
    });
  }
  _attachPointerEvents(element) {
    let isPointerDown = false;
    events_engine_default.off(element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME);
    events_engine_default.off(element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME);
    events_engine_default.on(element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME, DRAG_AND_DROP_SELECTOR, (e) => {
      if (isMouseEvent(e) && 1 === e.which) {
        isPointerDown = true;
        this.$element().addClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);
        events_engine_default.off(dom_adapter_default.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);
        events_engine_default.on(dom_adapter_default.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME, () => {
          isPointerDown = false;
          this.$element().removeClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);
        });
      }
    });
    events_engine_default.on(element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME, DRAG_AND_DROP_SELECTOR, (e) => {
      if (isPointerDown && this._dateTableScrollable && !this._dateTableScrollable.option("scrollByContent")) {
        e.preventDefault();
        e.stopPropagation();
        this._moveToCell(renderer_default(e.target), true);
      }
    });
  }
  _getFormat() {
    return abstract();
  }
  getWorkArea() {
    return this._$dateTableContainer;
  }
  getScrollable() {
    return this._dateTableScrollable;
  }
  getScrollableScrollTop() {
    return this._dateTableScrollable.scrollTop();
  }
  getGroupedScrollableScrollTop(allDay) {
    return this._groupedStrategy.getScrollableScrollTop(allDay);
  }
  getScrollableScrollLeft() {
    return this._dateTableScrollable.scrollLeft();
  }
  getScrollableOuterWidth() {
    return this._dateTableScrollable.scrollWidth();
  }
  getScrollableContainer() {
    return renderer_default(this._dateTableScrollable.container());
  }
  getHeaderPanelHeight() {
    return this._$headerPanel && getOuterHeight(this._$headerPanel, true);
  }
  getTimePanelWidth() {
    return this._$timePanel && getBoundingRect(this._$timePanel.get(0)).width;
  }
  getGroupTableWidth() {
    return this._$groupTable ? getOuterWidth(this._$groupTable) : 0;
  }
  getWorkSpaceLeftOffset() {
    return this._groupedStrategy.getLeftOffset();
  }
  _getCellCoordinatesByIndex(index) {
    const columnIndex = Math.floor(index / this._getRowCount());
    const rowIndex = index - this._getRowCount() * columnIndex;
    return {
      columnIndex,
      rowIndex
    };
  }
  _getDateGenerationOptions() {
    var _this$viewDataProvide;
    return {
      startDayHour: this.option("startDayHour"),
      endDayHour: this.option("endDayHour"),
      isWorkView: this.viewDataProvider.viewDataGenerator.isWorkView,
      interval: null === (_this$viewDataProvide = this.viewDataProvider.viewDataGenerator) || void 0 === _this$viewDataProvide ? void 0 : _this$viewDataProvide.getInterval(this.option("hoursInterval")),
      startViewDate: this.getStartViewDate(),
      firstDayOfWeek: this._firstDayOfWeek()
    };
  }
  _getIntervalBetween(currentDate, allDay) {
    const firstViewDate = this.getStartViewDate();
    const startDayTime = this.option("startDayHour") * HOUR_MS;
    const timeZoneOffset = date_default2.getTimezonesDifference(firstViewDate, currentDate);
    const fullInterval = currentDate.getTime() - firstViewDate.getTime() - timeZoneOffset;
    const days3 = this._getDaysOfInterval(fullInterval, startDayTime);
    const weekendsCount = this._getWeekendsCount(days3);
    let result = (days3 - weekendsCount) * DAY_MS;
    if (!allDay) {
      const {
        hiddenInterval
      } = this.viewDataProvider;
      const visibleDayDuration = this.getVisibleDayDuration();
      result = fullInterval - days3 * hiddenInterval - weekendsCount * visibleDayDuration;
    }
    return result;
  }
  _getWeekendsCount(argument) {
    return 0;
  }
  _getDaysOfInterval(fullInterval, startDayTime) {
    return Math.floor((fullInterval + startDayTime) / DAY_MS);
  }
  _updateIndex(index) {
    return index * this._getRowCount();
  }
  _getDroppableCell() {
    return this._getDateTables().find(`.${DATE_TABLE_DROPPABLE_CELL_CLASS}`);
  }
  _getWorkSpaceWidth() {
    return this.cache.get("workspaceWidth", () => {
      if (this._needCreateCrossScrolling()) {
        return getBoundingRect(this._$dateTable.get(0)).width;
      }
      const totalWidth = getBoundingRect(this.$element().get(0)).width;
      const timePanelWidth = this.getTimePanelWidth();
      const groupTableWidth = this.getGroupTableWidth();
      return totalWidth - timePanelWidth - groupTableWidth;
    });
  }
  _getCellByCoordinates(cellCoordinates, groupIndex, inAllDayRow) {
    const indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex, inAllDayRow);
    return this._dom_getDateCell(indexes);
  }
  _dom_getDateCell(position) {
    return this._$dateTable.find(`tr:not(.${VIRTUAL_ROW_CLASS})`).eq(position.rowIndex).find(`td:not(.${VIRTUAL_CELL_CLASS})`).eq(position.columnIndex);
  }
  _dom_getAllDayPanelCell(columnIndex) {
    return this._$allDayPanel.find("tr").eq(0).find("td").eq(columnIndex);
  }
  _getCells(allDay, direction) {
    const cellClass = allDay ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS2;
    if ("vertical" === direction) {
      let result = [];
      for (let i = 1; ; i++) {
        const cells = this.$element().find(`tr .${cellClass}:nth-child(${i})`);
        if (!cells.length) {
          break;
        }
        result = result.concat(cells.toArray());
      }
      return renderer_default(result);
    }
    return this.$element().find(`.${cellClass}`);
  }
  _getFirstAndLastDataTableCell() {
    const selector = this.isVirtualScrolling() ? `.${DATE_TABLE_CELL_CLASS2}, .${VIRTUAL_CELL_CLASS}` : `.${DATE_TABLE_CELL_CLASS2}`;
    const $cells = this.$element().find(selector);
    return [$cells[0], $cells[$cells.length - 1]];
  }
  _getAllCells(allDay) {
    if (this._isVerticalGroupedWorkSpace()) {
      return this._$dateTable.find(`td:not(.${VIRTUAL_CELL_CLASS})`);
    }
    const cellClass = allDay && this.supportAllDayRow() ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS2;
    return this.$element().find(`.${cellClass}`);
  }
  _setHorizontalGroupHeaderCellsHeight() {
    const {
      height
    } = getBoundingRect(this._$dateTable.get(0));
    setOuterHeight(this._$groupTable, height);
  }
  _getGroupHeaderCells() {
    return this.$element().find(`.${GROUP_HEADER_CLASS}`);
  }
  _getScrollCoordinates(hours, minutes, date, groupIndex, allDay) {
    const currentDate = date || new Date(this.option("currentDate"));
    const startDayHour = this.option("startDayHour");
    const endDayHour = this.option("endDayHour");
    if (hours < startDayHour) {
      hours = startDayHour;
    }
    if (hours >= endDayHour) {
      hours = endDayHour - 1;
    }
    currentDate.setHours(hours, minutes, 0, 0);
    const cell = this.viewDataProvider.findGlobalCellPosition(currentDate, groupIndex, allDay);
    const {
      position,
      cellData
    } = cell;
    return this.virtualScrollingDispatcher.calculateCoordinatesByDataAndPosition(cellData, position, currentDate, isDateAndTimeView(this.type), "vertical" === this.viewDirection);
  }
  _isOutsideScrollable(target, event) {
    const $dateTableScrollableElement = this._dateTableScrollable.$element();
    const scrollableSize = getBoundingRect($dateTableScrollableElement.get(0));
    const window3 = getWindow();
    const isTargetInAllDayPanel = !renderer_default(target).closest($dateTableScrollableElement).length;
    const isOutsideHorizontalScrollable = event.pageX < scrollableSize.left || event.pageX > scrollableSize.left + scrollableSize.width + (window3.scrollX || 0);
    const isOutsideVerticalScrollable = event.pageY < scrollableSize.top || event.pageY > scrollableSize.top + scrollableSize.height + (window3.scrollY || 0);
    if (isTargetInAllDayPanel && !isOutsideHorizontalScrollable) {
      return false;
    }
    return isOutsideVerticalScrollable || isOutsideHorizontalScrollable;
  }
  setCellDataCache(cellCoordinates, groupIndex, $cell) {
    const key = JSON.stringify({
      rowIndex: cellCoordinates.rowIndex,
      columnIndex: cellCoordinates.columnIndex,
      groupIndex
    });
    this.cache.set(key, this.getCellData($cell));
  }
  setCellDataCacheAlias(appointment, geometry) {
    const key = JSON.stringify({
      rowIndex: appointment.rowIndex,
      columnIndex: appointment.columnIndex,
      groupIndex: appointment.groupIndex
    });
    const aliasKey = JSON.stringify({
      top: geometry.top,
      left: geometry.left
    });
    this.cache.set(aliasKey, this.cache.get(key));
  }
  supportAllDayRow() {
    return true;
  }
  keepOriginalHours() {
    return false;
  }
  _filterCellDataFields(cellData) {
    return extend(true, {}, {
      startDate: cellData.startDate,
      endDate: cellData.endDate,
      groups: cellData.groups,
      groupIndex: cellData.groupIndex,
      allDay: cellData.allDay
    });
  }
  getCellData($cell) {
    const cellData = this._getFullCellData($cell) || {};
    return this._filterCellDataFields(cellData);
  }
  _getFullCellData($cell) {
    const currentCell = $cell[0];
    if (currentCell) {
      return this._getDataByCell($cell);
    }
    return;
  }
  _getVirtualRowOffset() {
    return this.virtualScrollingDispatcher.virtualRowOffset;
  }
  _getVirtualCellOffset() {
    return this.virtualScrollingDispatcher.virtualCellOffset;
  }
  _getDataByCell($cell) {
    const rowIndex = $cell.parent().index() - this.virtualScrollingDispatcher.topVirtualRowsCount;
    const columnIndex = $cell.index() - this.virtualScrollingDispatcher.leftVirtualCellsCount;
    const {
      viewDataProvider
    } = this;
    const isAllDayCell = this._hasAllDayClass($cell);
    const cellData = viewDataProvider.getCellData(rowIndex, columnIndex, isAllDayCell);
    return cellData || void 0;
  }
  isGroupedByDate() {
    return this.option("groupByDate") && this._isHorizontalGroupedWorkSpace() && this._getGroupCount() > 0;
  }
  getCellIndexByDate(date, inAllDayRow) {
    const {
      viewDataGenerator
    } = this.viewDataProvider;
    const timeInterval = inAllDayRow ? 864e5 : viewDataGenerator.getInterval(this.option("hoursInterval"));
    const startViewDateOffset = getStartViewDateTimeOffset(this.getStartViewDate(), this.option("startDayHour"));
    const dateTimeStamp = this._getIntervalBetween(date, inAllDayRow) + startViewDateOffset;
    let index = Math.floor(dateTimeStamp / timeInterval);
    if (inAllDayRow) {
      index = this._updateIndex(index);
    }
    if (index < 0) {
      index = 0;
    }
    return index;
  }
  getDroppableCellIndex() {
    const $droppableCell = this._getDroppableCell();
    const $row = $droppableCell.parent();
    const rowIndex = $row.index();
    return rowIndex * $row.find("td").length + $droppableCell.index();
  }
  getDataByDroppableCell() {
    const cellData = this.getCellData(renderer_default(this._getDroppableCell()));
    const {
      allDay
    } = cellData;
    const {
      startDate
    } = cellData;
    const {
      endDate
    } = cellData;
    return {
      startDate,
      endDate,
      allDay,
      groups: cellData.groups
    };
  }
  getDateRange() {
    return [this.getStartViewDate(), this.getEndViewDateByEndDayHour()];
  }
  getCellMinWidth() {
    return 75;
  }
  getRoundedCellWidth(groupIndex, startIndex, cellCount) {
    if (groupIndex < 0 || !hasWindow()) {
      return 0;
    }
    const $row = this.$element().find(`.${DATE_TABLE_ROW_CLASS}`).eq(0);
    let width = 0;
    const $cells = $row.find(`.${DATE_TABLE_CELL_CLASS2}`);
    const totalCellCount = this._getCellCount() * groupIndex;
    cellCount = cellCount || this._getCellCount();
    if (!isDefined(startIndex)) {
      startIndex = totalCellCount;
    }
    for (let i = startIndex; i < totalCellCount + cellCount; i++) {
      const element = renderer_default($cells).eq(i).get(0);
      const elementWidth = element ? getBoundingRect(element).width : 0;
      width += elementWidth;
    }
    return width / (totalCellCount + cellCount - startIndex);
  }
  getCellWidth() {
    return getCellWidth(this.getDOMElementsMetaData());
  }
  getCellHeight() {
    return getCellHeight(this.getDOMElementsMetaData());
  }
  getAllDayHeight() {
    return getAllDayHeight(this.option("showAllDayPanel"), this._isVerticalGroupedWorkSpace(), this.getDOMElementsMetaData());
  }
  getMaxAllowedPosition(groupIndex) {
    return getMaxAllowedPosition(groupIndex, this.viewDataProvider, this.option("rtlEnabled"), this.getDOMElementsMetaData());
  }
  getAllDayOffset() {
    return this._groupedStrategy.getAllDayOffset();
  }
  getCellIndexByCoordinates(coordinates, allDay) {
    const {
      horizontalScrollingState,
      verticalScrollingState
    } = this.virtualScrollingDispatcher;
    const cellCount = (null === horizontalScrollingState || void 0 === horizontalScrollingState ? void 0 : horizontalScrollingState.itemCount) ?? this._getTotalCellCount(this._getGroupCount());
    const cellWidth = this.getCellWidth();
    const cellHeight = allDay ? this.getAllDayHeight() : this.getCellHeight();
    const leftCoordinateOffset = (null === horizontalScrollingState || void 0 === horizontalScrollingState ? void 0 : horizontalScrollingState.virtualItemSizeBefore) ?? 0;
    const topCoordinateOffset = (null === verticalScrollingState || void 0 === verticalScrollingState ? void 0 : verticalScrollingState.virtualItemSizeBefore) ?? 0;
    const topIndex = Math.floor(Math.floor(coordinates.top - topCoordinateOffset) / Math.floor(cellHeight));
    let leftIndex = (coordinates.left - leftCoordinateOffset) / cellWidth;
    leftIndex = Math.floor(leftIndex + 0.05);
    if (this._isRTL()) {
      leftIndex = cellCount - leftIndex - 1;
    }
    return cellCount * topIndex + leftIndex;
  }
  getStartViewDate() {
    return this.viewDataProvider.getStartViewDate();
  }
  getEndViewDate() {
    return this.viewDataProvider.getLastCellEndDate();
  }
  getEndViewDateByEndDayHour() {
    return this.viewDataProvider.getLastViewDateByEndDayHour(this.option("endDayHour"));
  }
  getCellDuration() {
    return getCellDuration(this.type, this.option("startDayHour"), this.option("endDayHour"), this.option("hoursInterval"));
  }
  getIntervalDuration(allDay) {
    return allDay ? toMs22("day") : this.getCellDuration();
  }
  getVisibleDayDuration() {
    const startDayHour = this.option("startDayHour");
    const endDayHour = this.option("endDayHour");
    const hoursInterval = this.option("hoursInterval");
    return this.viewDataProvider.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);
  }
  getGroupBounds(coordinates) {
    const groupBounds = this._groupedStrategy instanceof m_work_space_grouped_strategy_vertical_default ? this.getGroupBoundsVertical(coordinates.groupIndex) : this.getGroupBoundsHorizontal(coordinates);
    return this._isRTL() ? this.getGroupBoundsRtlCorrection(groupBounds) : groupBounds;
  }
  getGroupBoundsVertical(groupIndex) {
    const $firstAndLastCells = this._getFirstAndLastDataTableCell();
    return this._groupedStrategy.getGroupBoundsOffset(groupIndex, $firstAndLastCells);
  }
  getGroupBoundsHorizontal(coordinates) {
    const cellCount = this._getCellCount();
    const $cells = this._getCells();
    const cellWidth = this.getCellWidth();
    const {
      groupedDataMap
    } = this.viewDataProvider;
    return this._groupedStrategy.getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap);
  }
  getGroupBoundsRtlCorrection(groupBounds) {
    const cellWidth = this.getCellWidth();
    return _extends({}, groupBounds, {
      left: groupBounds.right - 2 * cellWidth,
      right: groupBounds.left + 2 * cellWidth
    });
  }
  needRecalculateResizableArea() {
    return this._isVerticalGroupedWorkSpace() && 0 !== this.getScrollable().scrollTop();
  }
  getCellDataByCoordinates(coordinates, allDay) {
    const key = JSON.stringify({
      top: coordinates.top,
      left: coordinates.left
    });
    return this.cache.get(key, () => {
      const $cells = this._getCells(allDay);
      const cellIndex = this.getCellIndexByCoordinates(coordinates, allDay);
      const $cell = $cells.eq(cellIndex);
      return this.getCellData($cell);
    });
  }
  getVisibleBounds() {
    const result = {};
    const $scrollable = this.getScrollable().$element();
    const cellHeight = this.getCellHeight();
    const scrolledCellCount = this.getScrollableScrollTop() / cellHeight;
    const totalCellCount = scrolledCellCount + getHeight($scrollable) / cellHeight;
    result.top = {
      hours: Math.floor(scrolledCellCount * this.option("hoursInterval")) + this.option("startDayHour"),
      minutes: scrolledCellCount % 2 ? 30 : 0
    };
    result.bottom = {
      hours: Math.floor(totalCellCount * this.option("hoursInterval")) + this.option("startDayHour"),
      minutes: Math.floor(totalCellCount) % 2 ? 30 : 0
    };
    return result;
  }
  updateScrollPosition(date, groups) {
    let allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    const newDate = this.timeZoneCalculator.createDate(date, {
      path: "toGrid"
    });
    const inAllDayRow = allDay && this.isAllDayPanelVisible;
    if (this.needUpdateScrollPosition(newDate, groups, inAllDayRow)) {
      this.scrollTo(newDate, groups, inAllDayRow, false);
    }
  }
  needUpdateScrollPosition(date, groups, inAllDayRow) {
    const cells = this._getCellsInViewport(inAllDayRow);
    const groupIndex = this._isGroupsSpecified(groups) ? this._getGroupIndexByResourceId(groups) : 0;
    const time = date.getTime();
    const trimmedTime = date_default2.trimTime(date).getTime();
    return cells.reduce((currentResult, cell) => {
      const {
        startDate: cellStartDate,
        endDate: cellEndDate,
        groupIndex: cellGroupIndex
      } = this.getCellData(cell);
      const cellStartTime = cellStartDate.getTime();
      const cellEndTime = cellEndDate.getTime();
      if ((!inAllDayRow && cellStartTime <= time && time < cellEndTime || inAllDayRow && trimmedTime === cellStartTime) && groupIndex === cellGroupIndex) {
        return false;
      }
      return currentResult;
    }, true);
  }
  _getCellsInViewport(inAllDayRow) {
    const $scrollable = this.getScrollable().$element();
    const cellHeight = this.getCellHeight();
    const cellWidth = this.getCellWidth();
    const totalColumnCount = this._getTotalCellCount(this._getGroupCount());
    const scrollableScrollTop = this.getScrollableScrollTop();
    const scrollableScrollLeft = this.getScrollableScrollLeft();
    const fullScrolledRowCount = scrollableScrollTop / cellHeight - this.virtualScrollingDispatcher.topVirtualRowsCount;
    let scrolledRowCount = Math.floor(fullScrolledRowCount);
    if (scrollableScrollTop % cellHeight !== 0) {
      scrolledRowCount += 1;
    }
    const fullScrolledColumnCount = scrollableScrollLeft / cellWidth;
    let scrolledColumnCount = Math.floor(fullScrolledColumnCount);
    if (scrollableScrollLeft % cellWidth !== 0) {
      scrolledColumnCount += 1;
    }
    const rowCount = Math.floor(fullScrolledRowCount + getHeight($scrollable) / cellHeight);
    const columnCount = Math.floor(fullScrolledColumnCount + getWidth($scrollable) / cellWidth);
    const $cells = this._getAllCells(inAllDayRow);
    const result = [];
    $cells.each(function(index) {
      const $cell = renderer_default(this);
      const columnIndex = index % totalColumnCount;
      const rowIndex = index / totalColumnCount;
      if (scrolledColumnCount <= columnIndex && columnIndex < columnCount && scrolledRowCount <= rowIndex && rowIndex < rowCount) {
        result.push($cell);
      }
    });
    return result;
  }
  scrollToTime(hours, minutes, date) {
    if (!this._isValidScrollDate(date)) {
      return;
    }
    const coordinates = this._getScrollCoordinates(hours, minutes, date);
    const scrollable = this.getScrollable();
    scrollable.scrollBy({
      top: coordinates.top - scrollable.scrollTop(),
      left: 0
    });
  }
  scrollTo(date, groups) {
    let allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    let throwWarning = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : true;
    if (!this._isValidScrollDate(date, throwWarning)) {
      return;
    }
    const groupIndex = this._getGroupCount() && groups ? this._getGroupIndexByResourceId(groups) : 0;
    const isScrollToAllDay = allDay && this.isAllDayPanelVisible;
    const coordinates = this._getScrollCoordinates(date.getHours(), date.getMinutes(), date, groupIndex, isScrollToAllDay);
    const scrollable = this.getScrollable();
    const $scrollable = scrollable.$element();
    const cellWidth = this.getCellWidth();
    const offset = this.option("rtlEnabled") ? cellWidth : 0;
    const scrollableHeight = getHeight($scrollable);
    const scrollableWidth = getWidth($scrollable);
    const cellHeight = this.getCellHeight();
    const xShift = (scrollableWidth - cellWidth) / 2;
    const yShift = (scrollableHeight - cellHeight) / 2;
    const left = coordinates.left - scrollable.scrollLeft() - xShift - offset;
    let top = coordinates.top - scrollable.scrollTop() - yShift;
    if (isScrollToAllDay && !this._isVerticalGroupedWorkSpace()) {
      top = 0;
    }
    if (this.option("templatesRenderAsynchronously")) {
      setTimeout(() => {
        scrollable.scrollBy({
          left,
          top
        });
      });
    } else {
      scrollable.scrollBy({
        left,
        top
      });
    }
  }
  _isValidScrollDate(date) {
    let throwWarning = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
    const min = this.getStartViewDate();
    const max = this.getEndViewDate();
    if (date < min || date > max) {
      throwWarning && ui_errors_default.log("W1008", date);
      return false;
    }
    return true;
  }
  needApplyCollectorOffset() {
    return false;
  }
  removeDroppableCellClass($cellElement) {
    const $cell = $cellElement || this._getDroppableCell();
    null === $cell || void 0 === $cell || $cell.removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
  }
  _getCoordinatesByCell($cell) {
    const columnIndex = $cell.index() - this.virtualScrollingDispatcher.leftVirtualCellsCount;
    let rowIndex = $cell.parent().index();
    const isAllDayCell = this._hasAllDayClass($cell);
    const isVerticalGrouping = this._isVerticalGroupedWorkSpace();
    if (!(isAllDayCell && !isVerticalGrouping)) {
      rowIndex -= this.virtualScrollingDispatcher.topVirtualRowsCount;
    }
    return {
      rowIndex,
      columnIndex
    };
  }
  _isShowAllDayPanel() {
    return this.option("showAllDayPanel");
  }
  _getTimePanelCells() {
    return this.$element().find(`.${TIME_PANEL_CELL_CLASS}`);
  }
  _getRDateTableProps() {
    return {
      viewData: this.viewDataProvider.viewData,
      viewContext: this.getR1ComponentsViewContext(),
      dataCellTemplate: this.option("dataCellTemplate"),
      addDateTableClass: !this.option("crossScrollingEnabled") || this.isVirtualScrolling(),
      groupOrientation: this.option("groupOrientation"),
      addVerticalSizesClassToRows: false
    };
  }
  getR1ComponentsViewContext() {
    return {
      view: {
        type: this.type
      },
      crossScrollingEnabled: !!this.option("crossScrollingEnabled")
    };
  }
  _updateSelectedCellDataOption(selectedCellData, $nextFocusedCell) {
    const correctedSelectedCellData = selectedCellData.map((_ref3) => {
      let {
        startDate,
        endDate,
        allDay,
        groupIndex,
        groups
      } = _ref3;
      return {
        startDate,
        endDate,
        allDay,
        groupIndex,
        groups
      };
    });
    this.option("selectedCellData", correctedSelectedCellData);
    this._selectionChangedAction({
      selectedCellData: correctedSelectedCellData
    });
  }
  _getCellByData(cellData) {
    const {
      startDate,
      groupIndex,
      allDay,
      index
    } = cellData;
    const position = this.viewDataProvider.findCellPositionInMap({
      startDate,
      groupIndex,
      isAllDay: allDay,
      index
    });
    if (!position) {
      return;
    }
    return allDay && !this._isVerticalGroupedWorkSpace() ? this._dom_getAllDayPanelCell(position.columnIndex) : this._dom_getDateCell(position);
  }
  getDOMElementsMetaData() {
    return this.cache.get("cellElementsMeta", () => ({
      dateTableCellsMeta: this._getDateTableDOMElementsInfo(),
      allDayPanelCellsMeta: this._getAllDayPanelDOMElementsInfo()
    }));
  }
  _getDateTableDOMElementsInfo() {
    const dateTableCells = this._getAllCells(false);
    if (!dateTableCells.length || !hasWindow()) {
      return [
        [{}]
      ];
    }
    const dateTable = this._getDateTable();
    const dateTableRect = getBoundingRect(dateTable.get(0));
    const columnsCount = this.viewDataProvider.getColumnsCount();
    const result = [];
    dateTableCells.each((index, cell) => {
      const rowIndex = Math.floor(index / columnsCount);
      if (result.length === rowIndex) {
        result.push([]);
      }
      this._addCellMetaData(result[rowIndex], cell, dateTableRect);
    });
    return result;
  }
  _getAllDayPanelDOMElementsInfo() {
    const result = [];
    if (this.isAllDayPanelVisible && !this._isVerticalGroupedWorkSpace() && hasWindow()) {
      const allDayCells = this._getAllCells(true);
      if (!allDayCells.length) {
        return [{}];
      }
      const allDayAppointmentContainer = this._$allDayPanel;
      const allDayPanelRect = getBoundingRect(allDayAppointmentContainer.get(0));
      allDayCells.each((_, cell) => {
        this._addCellMetaData(result, cell, allDayPanelRect);
      });
    }
    return result;
  }
  _addCellMetaData(cellMetaDataArray, cell, parentRect) {
    const cellRect = getBoundingRect(cell);
    cellMetaDataArray.push({
      left: cellRect.left - parentRect.left,
      top: cellRect.top - parentRect.top,
      width: cellRect.width,
      height: cellRect.height
    });
  }
  _oldRender_getAllDayCellData(groupIndex) {
    return (cell, rowIndex, columnIndex) => {
      const validColumnIndex = columnIndex % this._getCellCount();
      const options = this._getDateGenerationOptions(true);
      let startDate = this.viewDataProvider.viewDataGenerator.getDateByCellIndices(options, rowIndex, validColumnIndex, this._getCellCountInDay());
      startDate = date_default2.trimTime(startDate);
      let validGroupIndex = groupIndex || 0;
      if (this.isGroupedByDate()) {
        validGroupIndex = Math.floor(columnIndex % this._getGroupCount());
      } else if (this._isHorizontalGroupedWorkSpace()) {
        validGroupIndex = Math.floor(columnIndex / this._getCellCount());
      }
      const data2 = {
        startDate,
        endDate: startDate,
        allDay: true,
        groupIndex: validGroupIndex
      };
      const groupsArray = getCellGroups(validGroupIndex, this.option("groups"));
      if (groupsArray.length) {
        data2.groups = getGroupsObjectFromGroupsArray(groupsArray);
      }
      return {
        key: CELL_DATA,
        value: data2
      };
    };
  }
  renderRWorkSpace() {
    let {
      header,
      timePanel,
      dateTable,
      allDayPanel
    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : DEFAULT_WORKSPACE_RENDER_OPTIONS.renderComponents;
    if (header) {
      this.renderRHeaderPanel();
    }
    if (timePanel) {
      this.renderRTimeTable();
    }
    if (dateTable) {
      this.renderRDateTable();
    }
    if (allDayPanel) {
      this.renderRAllDayPanel();
    }
  }
  renderRDateTable() {
    utils2.renovation.renderComponent(this, this._$dateTable, DateTableComponent, "renovatedDateTable", this._getRDateTableProps());
  }
  renderRGroupPanel() {
    var _this$option4;
    const options = {
      viewContext: this.getR1ComponentsViewContext(),
      groups: this.option("groups"),
      groupOrientation: this.option("groupOrientation"),
      groupByDate: this.isGroupedByDate(),
      resourceCellTemplate: this.option("resourceCellTemplate"),
      className: this.verticalGroupTableClass,
      groupPanelData: this.viewDataProvider.getGroupPanelData(this.generateRenderOptions())
    };
    if (null !== (_this$option4 = this.option("groups")) && void 0 !== _this$option4 && _this$option4.length) {
      this._attachGroupCountClass();
      utils2.renovation.renderComponent(this, this._getGroupHeaderContainer(), GroupPanelComponent, "renovatedGroupPanel", options);
    } else {
      this._detachGroupCountClass();
    }
  }
  renderRAllDayPanel() {
    const visible = this.isAllDayPanelVisible && !this.isGroupedAllDayPanel();
    if (visible) {
      var _this$virtualScrollin;
      this._toggleAllDayVisibility(false);
      const options = _extends({
        viewData: this.viewDataProvider.viewData,
        viewContext: this.getR1ComponentsViewContext(),
        dataCellTemplate: this.option("dataCellTemplate"),
        startCellIndex: 0
      }, (null === (_this$virtualScrollin = this.virtualScrollingDispatcher.horizontalVirtualScrolling) || void 0 === _this$virtualScrollin ? void 0 : _this$virtualScrollin.getRenderState()) || {});
      utils2.renovation.renderComponent(this, this._$allDayTable, AllDayTableComponent, "renovatedAllDayPanel", options);
      utils2.renovation.renderComponent(this, this._$allDayTitle, AllDayPanelTitleComponent, "renovatedAllDayPanelTitle", {});
    }
    this._toggleAllDayVisibility(true);
  }
  renderRTimeTable() {
    utils2.renovation.renderComponent(this, this._$timePanel, TimePanelComponent, "renovatedTimePanel", {
      viewContext: this.getR1ComponentsViewContext(),
      timePanelData: this.viewDataProvider.timePanelData,
      timeCellTemplate: this.option("timeCellTemplate"),
      groupOrientation: this.option("groupOrientation")
    });
  }
  renderRHeaderPanel() {
    var _this$option5;
    let isRenderDateHeader = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;
    if (null !== (_this$option5 = this.option("groups")) && void 0 !== _this$option5 && _this$option5.length) {
      this._attachGroupCountClass();
    } else {
      this._detachGroupCountClass();
    }
    utils2.renovation.renderComponent(this, this._$thead, this.renovatedHeaderPanelComponent, "renovatedHeaderPanel", {
      viewContext: this.getR1ComponentsViewContext(),
      dateHeaderData: this.viewDataProvider.dateHeaderData,
      groupPanelData: this.viewDataProvider.getGroupPanelData(this.generateRenderOptions()),
      dateCellTemplate: this.option("dateCellTemplate"),
      timeCellTemplate: this.option("timeCellTemplate"),
      groups: this.option("groups"),
      groupByDate: this.isGroupedByDate(),
      groupOrientation: this.option("groupOrientation"),
      resourceCellTemplate: this.option("resourceCellTemplate"),
      isRenderDateHeader
    });
  }
  initDragBehavior(scheduler) {
    if (!this.dragBehavior && scheduler) {
      this.dragBehavior = new AppointmentDragBehavior(scheduler);
      const $rootElement = renderer_default(scheduler.element());
      this._createDragBehavior(this.getWorkArea(), $rootElement);
      if (!this._isVerticalGroupedWorkSpace()) {
        this._createDragBehavior(this._$allDayPanel, $rootElement);
      }
    }
  }
  _createDragBehavior($targetElement, $rootElement) {
    const options = {
      getItemData: (itemElement, appointments) => appointments._getItemData(itemElement),
      getItemSettings: ($itemElement) => $itemElement.data(APPOINTMENT_SETTINGS_KEY)
    };
    this._createDragBehaviorBase($targetElement, $rootElement, options);
  }
  _createDragBehaviorBase(targetElement, rootElement, options) {
    const container = this.$element().find(`.${FIXED_CONTAINER_CLASS}`);
    this.dragBehavior.addTo(targetElement, createDragBehaviorConfig(container, rootElement, this.isDefaultDraggingMode, this.dragBehavior, () => {
      if (!this.isDefaultDraggingMode) {
        this.preventDefaultDragging = false;
      }
    }, () => {
      if (!this.isDefaultDraggingMode) {
        this.preventDefaultDragging = true;
      }
    }, () => this._getDroppableCell(), () => this._getDateTables(), () => this.removeDroppableCellClass(), () => this.getCellWidth(), options));
  }
  _isRenderHeaderPanelEmptyCell() {
    return this._isVerticalGroupedWorkSpace();
  }
  _dispose() {
    super._dispose();
    this.virtualScrollingDispatcher.dispose();
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      currentDate: /* @__PURE__ */ new Date(),
      intervalCount: 1,
      startDate: null,
      firstDayOfWeek: void 0,
      startDayHour: 0,
      endDayHour: 24,
      viewOffset: 0,
      hoursInterval: 0.5,
      activeStateEnabled: true,
      hoverStateEnabled: true,
      groups: [],
      showAllDayPanel: true,
      allDayExpanded: false,
      onCellClick: null,
      crossScrollingEnabled: false,
      dataCellTemplate: null,
      timeCellTemplate: null,
      resourceCellTemplate: null,
      dateCellTemplate: null,
      allowMultipleCellSelection: true,
      indicatorTime: /* @__PURE__ */ new Date(),
      indicatorUpdateInterval: 5 * toMs22("minute"),
      shadeUntilCurrentTime: true,
      groupOrientation: "horizontal",
      selectedCellData: [],
      groupByDate: false,
      scrolling: {
        mode: "standard"
      },
      allDayPanelMode: "all",
      renovateRender: true,
      height: void 0,
      draggingMode: "outlook",
      onScrollEnd: () => {
      },
      getHeaderHeight: void 0,
      onRenderAppointments: () => {
      },
      onShowAllDayPanel: () => {
      },
      onSelectedCellsClick: () => {
      },
      timeZoneCalculator: void 0,
      schedulerHeight: void 0,
      schedulerWidth: void 0
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case "startDayHour":
      case "endDayHour":
      case "viewOffset":
      case "dateCellTemplate":
      case "resourceCellTemplate":
      case "dataCellTemplate":
      case "timeCellTemplate":
      case "hoursInterval":
      case "firstDayOfWeek":
      case "currentDate":
      case "startDate":
        this._cleanWorkSpace();
        break;
      case "groups":
        this._cleanView();
        this._removeAllDayElements();
        this._initGrouping();
        this.repaint();
        break;
      case "groupOrientation":
        this._initGroupedStrategy();
        this._createAllDayPanelElements();
        this._removeAllDayElements();
        this._cleanWorkSpace();
        this._toggleGroupByDateClass();
        break;
      case "showAllDayPanel":
        if (this._isVerticalGroupedWorkSpace()) {
          this._cleanView();
          this._removeAllDayElements();
          this._initGrouping();
          this.repaint();
        } else if (!this.isRenovatedRender()) {
          this._toggleAllDayVisibility(true);
        } else {
          this.renderWorkSpace();
        }
        break;
      case "allDayExpanded":
        this._changeAllDayVisibility();
        this._attachTablesEvents();
        this._updateScrollable();
        break;
      case "onSelectionChanged":
        this._createSelectionChangedAction();
        break;
      case "onCellClick":
        this._createCellClickAction();
        break;
      case "onCellContextMenu":
        this._attachContextMenuEvent();
        break;
      case "intervalCount":
        this._cleanWorkSpace();
        this._toggleWorkSpaceCountClass();
        break;
      case "groupByDate":
        this._cleanWorkSpace();
        this._toggleGroupByDateClass();
        break;
      case "crossScrollingEnabled":
        this._toggleHorizontalScrollClass();
        this._dateTableScrollable.option(this._dateTableScrollableConfig());
        break;
      case "allDayPanelMode":
        this.updateShowAllDayPanel();
        this.updateAppointments();
        break;
      case "width":
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "timeZoneCalculator":
      case "allowMultipleCellSelection":
      case "selectedCellData":
        break;
      case "renovateRender":
      case "scrolling":
        this.repaint();
        break;
      case "schedulerHeight":
      case "schedulerWidth":
        this.virtualScrollingDispatcher.updateDimensions(true);
        break;
      default:
        super._optionChanged(args);
    }
  }
  updateShowAllDayPanel() {
    const isHiddenAllDayPanel = "hidden" === this.option("allDayPanelMode");
    this.option("onShowAllDayPanel")(!isHiddenAllDayPanel);
  }
  _getVirtualScrollingDispatcherOptions() {
    return {
      getCellHeight: this.getCellHeight.bind(this),
      getCellWidth: this.getCellWidth.bind(this),
      getCellMinWidth: this.getCellMinWidth.bind(this),
      isRTL: this._isRTL.bind(this),
      getSchedulerHeight: () => this.option("schedulerHeight"),
      getSchedulerWidth: () => this.option("schedulerWidth"),
      getViewHeight: () => this.$element().height ? this.$element().height() : getHeight(this.$element()),
      getViewWidth: () => this.$element().width ? this.$element().width() : getWidth(this.$element()),
      getWindowHeight: () => getWindow().innerHeight,
      getWindowWidth: () => getWindow().innerWidth,
      getScrolling: () => this.option("scrolling"),
      getScrollableOuterWidth: this.getScrollableOuterWidth.bind(this),
      getScrollable: this.getScrollable.bind(this),
      createAction: this._createAction.bind(this),
      updateRender: this.updateRender.bind(this),
      updateGrid: this.updateGrid.bind(this),
      getGroupCount: this._getGroupCount.bind(this),
      isVerticalGrouping: this._isVerticalGroupedWorkSpace.bind(this),
      getTotalRowCount: this._getTotalRowCount.bind(this),
      getTotalCellCount: this._getTotalCellCount.bind(this)
    };
  }
  _cleanWorkSpace() {
    this._cleanView();
    this._toggleGroupedClass();
    this._toggleWorkSpaceWithOddCells();
    this.virtualScrollingDispatcher.updateDimensions(true);
    this._renderView();
    this.option("crossScrollingEnabled") && this._setTableSizes();
    this.cache.clear();
  }
  _init() {
    this._scrollSync = {};
    this._viewDataProvider = null;
    this._cellsSelectionState = null;
    this._activeStateUnit = CELL_SELECTOR;
    super._init();
    this._initGrouping();
    this._toggleHorizontalScrollClass();
    this._toggleWorkSpaceCountClass();
    this._toggleGroupByDateClass();
    this._toggleWorkSpaceWithOddCells();
    this.$element().addClass(COMPONENT_CLASS3).addClass(this._getElementClass());
  }
  _initPositionHelper() {
    this.positionHelper = new PositionHelper({
      key: this.option("key"),
      viewDataProvider: this.viewDataProvider,
      viewStartDayHour: this.option("startDayHour"),
      viewEndDayHour: this.option("endDayHour"),
      cellDuration: this.getCellDuration(),
      groupedStrategy: this._groupedStrategy,
      isGroupedByDate: this.isGroupedByDate(),
      rtlEnabled: this.option("rtlEnabled"),
      startViewDate: this.getStartViewDate(),
      isVerticalGrouping: this._isVerticalGroupedWorkSpace(),
      groupCount: this._getGroupCount(),
      isVirtualScrolling: this.isVirtualScrolling(),
      getDOMMetaDataCallback: this.getDOMElementsMetaData.bind(this)
    });
  }
  _initGrouping() {
    this._initGroupedStrategy();
    this._toggleGroupingDirectionClass();
    this._toggleGroupByDateClass();
  }
  isVerticalOrientation() {
    var _this$option6;
    const orientation = null !== (_this$option6 = this.option("groups")) && void 0 !== _this$option6 && _this$option6.length ? this.option("groupOrientation") : this._getDefaultGroupStrategy();
    return "vertical" === orientation;
  }
  _initGroupedStrategy() {
    const Strategy = this.isVerticalOrientation() ? m_work_space_grouped_strategy_vertical_default : m_work_space_grouped_strategy_horizontal_default;
    this._groupedStrategy = new Strategy(this);
  }
  _getDefaultGroupStrategy() {
    return "horizontal";
  }
  _toggleHorizontalScrollClass() {
    this.$element().toggleClass(WORKSPACE_WITH_BOTH_SCROLLS_CLASS, this.option("crossScrollingEnabled"));
  }
  _toggleGroupByDateClass() {
    this.$element().toggleClass(WORKSPACE_WITH_GROUP_BY_DATE_CLASS, this.isGroupedByDate());
  }
  _toggleWorkSpaceCountClass() {
    this.$element().toggleClass(WORKSPACE_WITH_COUNT_CLASS, this._isWorkSpaceWithCount());
  }
  _toggleWorkSpaceWithOddCells() {
    this.$element().toggleClass(WORKSPACE_WITH_ODD_CELLS_CLASS, this._isWorkspaceWithOddCells());
  }
  _toggleGroupingDirectionClass() {
    this.$element().toggleClass(VERTICAL_GROUPED_WORKSPACE_CLASS, this._isVerticalGroupedWorkSpace());
  }
  _getDateTableCellClass(rowIndex, columnIndex) {
    const cellClass = `${DATE_TABLE_CELL_CLASS2} ${HORIZONTAL_SIZES_CLASS} ${VERTICAL_SIZES_CLASS}`;
    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, columnIndex + 1, rowIndex, columnIndex);
  }
  _getGroupHeaderClass(i) {
    const cellClass = GROUP_HEADER_CLASS;
    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1);
  }
  _initWorkSpaceUnits() {
    this._$headerPanelContainer = renderer_default("<div>").addClass("dx-scheduler-header-panel-container");
    this._$headerTablesContainer = renderer_default("<div>").addClass("dx-scheduler-header-tables-container");
    this._$headerPanel = renderer_default("<table>");
    this._$thead = renderer_default("<thead>").appendTo(this._$headerPanel);
    this._$headerPanelEmptyCell = renderer_default("<div>").addClass("dx-scheduler-header-panel-empty-cell");
    this._$allDayTable = renderer_default("<table>");
    this._$fixedContainer = renderer_default("<div>").addClass(FIXED_CONTAINER_CLASS);
    this._$allDayContainer = renderer_default("<div>").addClass(ALL_DAY_CONTAINER_CLASS);
    this._$dateTableScrollableContent = renderer_default("<div>").addClass("dx-scheduler-date-table-scrollable-content");
    this._$sidebarScrollableContent = renderer_default("<div>").addClass("dx-scheduler-side-bar-scrollable-content");
    this._initAllDayPanelElements();
    if (this.isRenovatedRender()) {
      this.createRAllDayPanelElements();
    } else {
      this._createAllDayPanelElements();
    }
    this._$timePanel = renderer_default("<table>").addClass(TIME_PANEL_CLASS);
    this._$dateTable = renderer_default("<table>");
    this._$dateTableContainer = renderer_default("<div>").addClass("dx-scheduler-date-table-container");
    this._$groupTable = renderer_default("<div>").addClass(WORKSPACE_VERTICAL_GROUP_TABLE_CLASS);
  }
  _initAllDayPanelElements() {
    this._allDayTitles = [];
    this._allDayTables = [];
    this._allDayPanels = [];
  }
  _initDateTableScrollable() {
    const $dateTableScrollable = renderer_default("<div>").addClass("dx-scheduler-date-table-scrollable");
    this._dateTableScrollable = this._createComponent($dateTableScrollable, ui_scrollable_default, this._dateTableScrollableConfig());
    this._scrollSync.dateTable = getMemoizeScrollTo(() => this._dateTableScrollable);
  }
  _createWorkSpaceElements() {
    if (this.option("crossScrollingEnabled")) {
      this._createWorkSpaceScrollableElements();
    } else {
      this._createWorkSpaceStaticElements();
    }
  }
  _createWorkSpaceStaticElements() {
    this._$dateTableContainer.append(this._$dateTable);
    if (this._isVerticalGroupedWorkSpace()) {
      this._$dateTableContainer.append(this._$allDayContainer);
      this._$dateTableScrollableContent.append(this._$groupTable, this._$timePanel, this._$dateTableContainer);
      this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);
      this._$headerTablesContainer.append(this._$headerPanel);
    } else {
      var _this$_$allDayPanel;
      this._$dateTableScrollableContent.append(this._$timePanel, this._$dateTableContainer);
      this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);
      this._$headerTablesContainer.append(this._$headerPanel, this._$allDayPanel);
      null === (_this$_$allDayPanel = this._$allDayPanel) || void 0 === _this$_$allDayPanel || _this$_$allDayPanel.append(this._$allDayContainer, this._$allDayTable);
    }
    this._appendHeaderPanelEmptyCellIfNecessary();
    this._$headerPanelContainer.append(this._$headerTablesContainer);
    this.$element().append(this._$fixedContainer, this._$headerPanelContainer, this._dateTableScrollable.$element());
  }
  _createWorkSpaceScrollableElements() {
    this.$element().append(this._$fixedContainer);
    this._$flexContainer = renderer_default("<div>").addClass("dx-scheduler-work-space-flex-container");
    this._createHeaderScrollable();
    this._headerScrollable.$content().append(this._$headerPanel);
    this._appendHeaderPanelEmptyCellIfNecessary();
    this._$headerPanelContainer.append(this._$headerTablesContainer);
    this.$element().append(this._$headerPanelContainer);
    this.$element().append(this._$flexContainer);
    this._createSidebarScrollable();
    this._$flexContainer.append(this._dateTableScrollable.$element());
    this._$dateTableContainer.append(this._$dateTable);
    this._$dateTableScrollableContent.append(this._$dateTableContainer);
    this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);
    if (this._isVerticalGroupedWorkSpace()) {
      this._$dateTableContainer.append(this._$allDayContainer);
      this._$sidebarScrollableContent.append(this._$groupTable, this._$timePanel);
    } else {
      var _this$_$allDayPanel2;
      this._headerScrollable.$content().append(this._$allDayPanel);
      null === (_this$_$allDayPanel2 = this._$allDayPanel) || void 0 === _this$_$allDayPanel2 || _this$_$allDayPanel2.append(this._$allDayContainer, this._$allDayTable);
      this._$sidebarScrollableContent.append(this._$timePanel);
    }
    this._sidebarScrollable.$content().append(this._$sidebarScrollableContent);
  }
  _appendHeaderPanelEmptyCellIfNecessary() {
    this._isRenderHeaderPanelEmptyCell() && this._$headerPanelContainer.append(this._$headerPanelEmptyCell);
  }
  _createHeaderScrollable() {
    const $headerScrollable = renderer_default("<div>").addClass("dx-scheduler-header-scrollable").appendTo(this._$headerTablesContainer);
    this._headerScrollable = this._createComponent($headerScrollable, ui_scrollable_default, this._headerScrollableConfig());
    this._scrollSync.header = getMemoizeScrollTo(() => this._headerScrollable);
  }
  _createSidebarScrollable() {
    const $timePanelScrollable = renderer_default("<div>").addClass("dx-scheduler-sidebar-scrollable").appendTo(this._$flexContainer);
    this._sidebarScrollable = this._createComponent($timePanelScrollable, ui_scrollable_default, {
      useKeyboard: false,
      showScrollbar: "never",
      direction: "vertical",
      useNative: false,
      updateManually: true,
      bounceEnabled: false,
      onScroll: (event) => {
        this._scrollSync.dateTable({
          top: event.scrollOffset.top
        });
      }
    });
    this._scrollSync.sidebar = getMemoizeScrollTo(() => this._sidebarScrollable);
  }
  _attachTableClasses() {
    this._addTableClass(this._$dateTable, DATE_TABLE_CLASS);
    if (this._isVerticalGroupedWorkSpace()) {
      const groupCount = this._getGroupCount();
      for (let i = 0; i < groupCount; i++) {
        this._addTableClass(this._allDayTables[i], ALL_DAY_TABLE_CLASS);
      }
    } else if (!this.isRenovatedRender()) {
      this._addTableClass(this._$allDayTable, ALL_DAY_TABLE_CLASS);
    }
  }
  _attachHeaderTableClasses() {
    this._addTableClass(this._$headerPanel, HEADER_PANEL_CLASS);
  }
  _addTableClass($el, className) {
    $el && !$el.hasClass(className) && $el.addClass(className);
  }
  _initMarkup() {
    this.cache.clear();
    this._initWorkSpaceUnits();
    this._initVirtualScrolling();
    this._initDateTableScrollable();
    this._createWorkSpaceElements();
    super._initMarkup();
    if (!this.option("crossScrollingEnabled")) {
      this._attachTableClasses();
      this._attachHeaderTableClasses();
    }
    this._toggleGroupedClass();
    this._renderView();
    this._attachEvents();
  }
  _render() {
    super._render();
    this._renderDateTimeIndication();
    this._setIndicationUpdateInterval();
  }
  _toggleGroupedClass() {
    this.$element().toggleClass(GROUPED_WORKSPACE_CLASS, this._getGroupCount() > 0);
  }
  _renderView() {
    if (this.isRenovatedRender()) {
      if (this._isVerticalGroupedWorkSpace()) {
        this.renderRGroupPanel();
      }
    } else {
      this._applyCellTemplates(this._renderGroupHeader());
    }
    this.renderWorkSpace();
    if (this.isRenovatedRender()) {
      this.virtualScrollingDispatcher.updateDimensions();
    }
    this._updateGroupTableHeight();
    this.updateHeaderEmptyCellWidth();
    this._shader = new m_current_time_shader_vertical_default(this);
  }
  updateCellsSelection() {
    const renderOptions = this.generateRenderOptions();
    this.viewDataProvider.updateViewData(renderOptions);
    this.renderRWorkSpace({
      timePanel: true,
      dateTable: true,
      allDayPanel: true
    });
  }
  _renderDateTimeIndication() {
    return noop();
  }
  renderCurrentDateTimeLineAndShader() {
    return noop();
  }
  renderCurrentDateTimeIndication() {
    return noop();
  }
  _setIndicationUpdateInterval() {
    return noop();
  }
  _detachGroupCountClass() {
    [...VERTICAL_GROUP_COUNT_CLASSES].forEach((className) => {
      this.$element().removeClass(className);
    });
  }
  _attachGroupCountClass() {
    const className = this._groupedStrategy.getGroupCountClass(this.option("groups"));
    this.$element().addClass(className);
  }
  _getDateHeaderTemplate() {
    return this.option("dateCellTemplate");
  }
  _toggleAllDayVisibility(isUpdateScrollable) {
    const showAllDayPanel = this._isShowAllDayPanel();
    this.$element().toggleClass(WORKSPACE_WITH_ALL_DAY_CLASS, showAllDayPanel);
    this._changeAllDayVisibility();
    isUpdateScrollable && this._updateScrollable();
  }
  _changeAllDayVisibility() {
    this.cache.clear();
    this.$element().toggleClass(WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS, !this.option("allDayExpanded") && this._isShowAllDayPanel());
  }
  _getDateTables() {
    return this._$dateTable.add(this._$allDayTable);
  }
  _getDateTable() {
    return this._$dateTable;
  }
  _removeAllDayElements() {
    this._$allDayTable && this._$allDayTable.remove();
    this._$allDayTitle && this._$allDayTitle.remove();
  }
  _cleanView() {
    var _this$_shader;
    this.cache.clear();
    this._cleanTableWidths();
    this.cellsSelectionState.clearSelectedAndFocusedCells();
    if (!this.isRenovatedRender()) {
      var _this$_$allDayTable, _this$_$sidebarTable;
      this._$thead.empty();
      this._$dateTable.empty();
      this._$timePanel.empty();
      this._$groupTable.empty();
      null === (_this$_$allDayTable = this._$allDayTable) || void 0 === _this$_$allDayTable || _this$_$allDayTable.empty();
      null === (_this$_$sidebarTable = this._$sidebarTable) || void 0 === _this$_$sidebarTable || _this$_$sidebarTable.empty();
    }
    null === (_this$_shader = this._shader) || void 0 === _this$_shader || _this$_shader.clean();
    delete this._interval;
  }
  _clean() {
    events_engine_default.off(dom_adapter_default.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);
    this._disposeRenovatedComponents();
    super._clean();
  }
  _cleanTableWidths() {
    this._$headerPanel.css("width", "");
    this._$dateTable.css("width", "");
    this._$allDayTable && this._$allDayTable.css("width", "");
  }
  _disposeRenovatedComponents() {
    var _this$renovatedAllDay, _this$renovatedDateTa, _this$renovatedTimePa, _this$renovatedGroupP, _this$renovatedHeader;
    null === (_this$renovatedAllDay = this.renovatedAllDayPanel) || void 0 === _this$renovatedAllDay || _this$renovatedAllDay.dispose();
    this.renovatedAllDayPanel = void 0;
    null === (_this$renovatedDateTa = this.renovatedDateTable) || void 0 === _this$renovatedDateTa || _this$renovatedDateTa.dispose();
    this.renovatedDateTable = void 0;
    null === (_this$renovatedTimePa = this.renovatedTimePanel) || void 0 === _this$renovatedTimePa || _this$renovatedTimePa.dispose();
    this.renovatedTimePanel = void 0;
    null === (_this$renovatedGroupP = this.renovatedGroupPanel) || void 0 === _this$renovatedGroupP || _this$renovatedGroupP.dispose();
    this.renovatedGroupPanel = void 0;
    null === (_this$renovatedHeader = this.renovatedHeaderPanel) || void 0 === _this$renovatedHeader || _this$renovatedHeader.dispose();
    this.renovatedHeaderPanel = void 0;
  }
  getGroupedStrategy() {
    return this._groupedStrategy;
  }
  getFixedContainer() {
    return this._$fixedContainer;
  }
  getAllDayContainer() {
    return this._$allDayContainer;
  }
  updateRender() {
    this.renderer.updateRender();
  }
  updateGrid() {
    this.renderer._renderGrid();
  }
  updateAppointments() {
    var _this$dragBehavior2;
    this.option("onRenderAppointments")();
    null === (_this$dragBehavior2 = this.dragBehavior) || void 0 === _this$dragBehavior2 || _this$dragBehavior2.updateDragSource();
  }
  _createAllDayPanelElements() {
    const groupCount = this._getGroupCount();
    if (this._isVerticalGroupedWorkSpace() && 0 !== groupCount) {
      for (let i = 0; i < groupCount; i++) {
        const $allDayTitle = renderer_default("<div>").addClass(ALL_DAY_TITLE_CLASS).text(message_default.format("dxScheduler-allDay"));
        this._allDayTitles.push($allDayTitle);
        this._$allDayTable = renderer_default("<table>");
        this._allDayTables.push(this._$allDayTable);
        this._$allDayPanel = renderer_default("<div>").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);
        this._allDayPanels.push(this._$allDayPanel);
      }
    } else {
      this._$allDayTitle = renderer_default("<div>").addClass(ALL_DAY_TITLE_CLASS).text(message_default.format("dxScheduler-allDay")).appendTo(this.$element());
      this._$allDayTable = renderer_default("<table>");
      this._$allDayPanel = renderer_default("<div>").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);
    }
  }
  renderWorkSpace() {
    let {
      generateNewData,
      renderComponents
    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : DEFAULT_WORKSPACE_RENDER_OPTIONS;
    this.cache.clear();
    this.viewDataProvider.update(this.generateRenderOptions(), generateNewData);
    if (this.isRenovatedRender()) {
      this.renderRWorkSpace(renderComponents);
    } else {
      this._renderDateHeader();
      this._renderTimePanel();
      this._renderGroupAllDayPanel();
      this._renderDateTable();
      this._renderAllDayPanel();
    }
    this._initPositionHelper();
  }
  _renderGroupHeader() {
    const $container = this._getGroupHeaderContainer();
    const groupCount = this._getGroupCount();
    let cellTemplates = [];
    if (groupCount) {
      const groupRows = this._makeGroupRows(this.option("groups"), this.option("groupByDate"));
      this._attachGroupCountClass();
      $container.append(groupRows.elements);
      cellTemplates = groupRows.cellTemplates;
    } else {
      this._detachGroupCountClass();
    }
    return cellTemplates;
  }
  _applyCellTemplates(templates) {
    null === templates || void 0 === templates || templates.forEach((template) => {
      template();
    });
  }
  _makeGroupRows(groups, groupByDate) {
    const tableCreatorStrategy = this._isVerticalGroupedWorkSpace() ? tableCreator.VERTICAL : tableCreator.HORIZONTAL;
    return tableCreator.makeGroupedTable(tableCreatorStrategy, groups, {
      groupHeaderRowClass: GROUP_ROW_CLASS,
      groupRowClass: GROUP_ROW_CLASS,
      groupHeaderClass: this._getGroupHeaderClass.bind(this),
      groupHeaderContentClass: GROUP_HEADER_CONTENT_CLASS
    }, this._getCellCount() || 1, this.option("resourceCellTemplate"), this._getGroupCount(), groupByDate);
  }
  _renderDateHeader() {
    const container = this._getDateHeaderContainer();
    const $headerRow = renderer_default("<tr>").addClass(HEADER_ROW_CLASS);
    const count = this._getCellCount();
    const cellTemplate = this._getDateHeaderTemplate();
    const repeatCount = this._getCalculateHeaderCellRepeatCount();
    const templateCallbacks = [];
    const groupByDate = this.isGroupedByDate();
    if (!groupByDate) {
      for (let rowIndex = 0; rowIndex < repeatCount; rowIndex++) {
        for (let columnIndex = 0; columnIndex < count; columnIndex++) {
          const templateIndex = rowIndex * count + columnIndex;
          this._renderDateHeaderTemplate($headerRow, columnIndex, templateIndex, cellTemplate, templateCallbacks);
        }
      }
      container.append($headerRow);
    } else {
      const colSpan = groupByDate ? this._getGroupCount() : 1;
      for (let columnIndex = 0; columnIndex < count; columnIndex++) {
        const templateIndex = columnIndex * repeatCount;
        const cellElement = this._renderDateHeaderTemplate($headerRow, columnIndex, templateIndex, cellTemplate, templateCallbacks);
        cellElement.attr("colSpan", colSpan);
      }
      container.prepend($headerRow);
    }
    this._applyCellTemplates(templateCallbacks);
    return $headerRow;
  }
  _renderDateHeaderTemplate(container, panelCellIndex, templateIndex, cellTemplate, templateCallbacks) {
    const validTemplateIndex = this.isGroupedByDate() ? Math.floor(templateIndex / this._getGroupCount()) : templateIndex;
    const {
      completeDateHeaderMap
    } = this.viewDataProvider;
    const {
      text,
      startDate: date
    } = completeDateHeaderMap[completeDateHeaderMap.length - 1][validTemplateIndex];
    const $cell = renderer_default("<th>").addClass(this._getHeaderPanelCellClass(panelCellIndex)).attr("title", text);
    if (null !== cellTemplate && void 0 !== cellTemplate && cellTemplate.render) {
      templateCallbacks.push(cellTemplate.render.bind(cellTemplate, {
        model: _extends({
          text,
          date
        }, this._getGroupsForDateHeaderTemplate(templateIndex)),
        index: templateIndex,
        container: getPublicElement($cell)
      }));
    } else {
      $cell.text(text);
    }
    container.append($cell);
    return $cell;
  }
  _getGroupsForDateHeaderTemplate(templateIndex) {
    let indexMultiplier = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    let groupIndex;
    let groups;
    if (this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate()) {
      groupIndex = this._getGroupIndex(0, templateIndex * indexMultiplier);
      const groupsArray = getCellGroups(groupIndex, this.option("groups"));
      groups = getGroupsObjectFromGroupsArray(groupsArray);
    }
    return {
      groups,
      groupIndex
    };
  }
  _getHeaderPanelCellClass(i) {
    const cellClass = `${HEADER_PANEL_CELL_CLASS} ${HORIZONTAL_SIZES_CLASS}`;
    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1, void 0, void 0, this.isGroupedByDate());
  }
  _renderAllDayPanel(index) {
    let cellCount = this._getCellCount();
    if (!this._isVerticalGroupedWorkSpace()) {
      cellCount *= this._getGroupCount() || 1;
    }
    const cellTemplates = this._renderTableBody({
      container: this._allDayPanels.length ? getPublicElement(this._allDayTables[index]) : getPublicElement(this._$allDayTable),
      rowCount: 1,
      cellCount,
      cellClass: this._getAllDayPanelCellClass.bind(this),
      rowClass: ALL_DAY_TABLE_ROW_CLASS,
      cellTemplate: this.option("dataCellTemplate"),
      getCellData: this._oldRender_getAllDayCellData(index),
      groupIndex: index
    }, true);
    this._toggleAllDayVisibility(true);
    this._applyCellTemplates(cellTemplates);
  }
  _renderGroupAllDayPanel() {
    if (this._isVerticalGroupedWorkSpace()) {
      const groupCount = this._getGroupCount();
      for (let i = 0; i < groupCount; i++) {
        this._renderAllDayPanel(i);
      }
    }
  }
  _getAllDayPanelCellClass(i, j) {
    const cellClass = `${ALL_DAY_TABLE_CELL_CLASS} ${HORIZONTAL_SIZES_CLASS}`;
    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, j + 1);
  }
  _renderTimePanel() {
    const repeatCount = this._groupedStrategy.calculateTimeCellRepeatCount();
    const getData = (rowIndex, field) => {
      let allDayPanelsCount = 0;
      if (this.isAllDayPanelVisible) {
        allDayPanelsCount = 1;
      }
      if (this.isGroupedAllDayPanel()) {
        allDayPanelsCount = Math.ceil((rowIndex + 1) / this._getRowCount());
      }
      const validRowIndex = rowIndex + allDayPanelsCount;
      return this.viewDataProvider.completeTimePanelMap[validRowIndex][field];
    };
    this._renderTableBody({
      container: getPublicElement(this._$timePanel),
      rowCount: this._getTimePanelRowCount() * repeatCount,
      cellCount: 1,
      cellClass: this._getTimeCellClass.bind(this),
      rowClass: TIME_PANEL_ROW_CLASS,
      cellTemplate: this.option("timeCellTemplate"),
      getCellText: (rowIndex) => getData(rowIndex, "text"),
      getCellDate: (rowIndex) => getData(rowIndex, "startDate"),
      groupCount: this._getGroupCount(),
      allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayTitles : void 0,
      getTemplateData: ((rowIndex) => {
        if (!this._isVerticalGroupedWorkSpace()) {
          return {};
        }
        const groupIndex = this._getGroupIndex(rowIndex, 0);
        const groupsArray = getCellGroups(groupIndex, this.option("groups"));
        const groups = getGroupsObjectFromGroupsArray(groupsArray);
        return {
          groupIndex,
          groups
        };
      }).bind(this)
    });
  }
  _getTimeCellClass(i) {
    const cellClass = `${TIME_PANEL_CELL_CLASS} ${VERTICAL_SIZES_CLASS}`;
    return this._isVerticalGroupedWorkSpace() ? this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i, i) : cellClass;
  }
  _renderDateTable() {
    const groupCount = this._getGroupCount();
    this._renderTableBody({
      container: getPublicElement(this._$dateTable),
      rowCount: this._getTotalRowCount(groupCount),
      cellCount: this._getTotalCellCount(groupCount),
      cellClass: this._getDateTableCellClass.bind(this),
      rowClass: DATE_TABLE_ROW_CLASS,
      cellTemplate: this.option("dataCellTemplate"),
      getCellData: (_, rowIndex, columnIndex) => {
        const isGroupedAllDayPanel = this.isGroupedAllDayPanel();
        let validRowIndex = rowIndex;
        if (isGroupedAllDayPanel) {
          const rowCount = this._getRowCount();
          const allDayPanelsCount = Math.ceil(rowIndex / rowCount);
          validRowIndex += allDayPanelsCount;
        }
        const {
          cellData
        } = this.viewDataProvider.viewDataMap.dateTableMap[validRowIndex][columnIndex];
        return {
          value: this._filterCellDataFields(cellData),
          fullValue: cellData,
          key: CELL_DATA
        };
      },
      allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayPanels : void 0,
      groupCount,
      groupByDate: this.option("groupByDate")
    });
  }
  _insertAllDayRowsIntoDateTable() {
    return this._groupedStrategy.insertAllDayRowsIntoDateTable();
  }
  _renderTableBody(options, delayCellTemplateRendering) {
    let result = [];
    if (!delayCellTemplateRendering) {
      this._applyCellTemplates(tableCreator.makeTable(options));
    } else {
      result = tableCreator.makeTable(options);
    }
    return result;
  }
};
var createDragBehaviorConfig = (container, rootElement, isDefaultDraggingMode, dragBehavior, enableDefaultDragging, disableDefaultDragging, getDroppableCell, getDateTables, removeDroppableCellClass, getCellWidth2, options) => {
  const state = {
    dragElement: void 0,
    itemData: void 0
  };
  const isItemDisabled = () => {
    const {
      itemData
    } = state;
    if (itemData) {
      const getter = compileGetter("disabled");
      return getter(itemData);
    }
    return true;
  };
  const cursorOffset = options.isSetCursorOffset ? () => {
    const $dragElement = renderer_default(state.dragElement);
    return {
      x: getWidth($dragElement) / 2,
      y: getHeight($dragElement) / 2
    };
  } : void 0;
  return {
    container,
    dragTemplate: () => state.dragElement,
    onDragStart: (e) => {
      if (!isDefaultDraggingMode) {
        disableDefaultDragging();
      }
      const canceled = e.cancel;
      const {
        event
      } = e;
      const $itemElement = renderer_default(e.itemElement);
      const appointments = e.component._appointments;
      state.itemData = options.getItemData(e.itemElement, appointments);
      const settings = options.getItemSettings($itemElement, e);
      const {
        initialPosition
      } = options;
      if (!isItemDisabled()) {
        event.data = event.data || {};
        if (!canceled) {
          if (!settings.isCompact) {
            dragBehavior.updateDragSource(state.itemData, settings);
          }
          state.dragElement = ((itemData, settings2, appointments2) => {
            const appointmentIndex = appointments2.option("items").length;
            settings2.isCompact = false;
            settings2.virtual = false;
            const items = appointments2._renderItem(appointmentIndex, {
              itemData,
              settings: [settings2]
            });
            return items[0];
          })(state.itemData, settings, appointments);
          event.data.itemElement = state.dragElement;
          event.data.initialPosition = initialPosition ?? locate(renderer_default(state.dragElement));
          event.data.itemData = state.itemData;
          event.data.itemSettings = settings;
          dragBehavior.onDragStart(event.data);
          resetPosition(renderer_default(state.dragElement));
        }
      }
    },
    onDragMove: () => {
      if (isDefaultDraggingMode) {
        return;
      }
      const elements = (() => {
        const appointmentWidth = getWidth(state.dragElement);
        const cellWidth = getCellWidth2();
        const isWideAppointment = appointmentWidth > cellWidth;
        const isNarrowAppointment = appointmentWidth <= 10;
        const dragElementContainer = renderer_default(state.dragElement).parent().get(0);
        const boundingRect = getBoundingRect(dragElementContainer);
        const newX = boundingRect.left;
        const newY = boundingRect.top;
        if (isWideAppointment) {
          return dom_adapter_default.elementsFromPoint(newX + 10, newY + 10, dragElementContainer);
        }
        if (isNarrowAppointment) {
          return dom_adapter_default.elementsFromPoint(newX, newY, dragElementContainer);
        }
        return dom_adapter_default.elementsFromPoint(newX + appointmentWidth / 2, newY + 10, dragElementContainer);
      })();
      const isMoveUnderControl = !!elements.find((el) => el === rootElement.get(0));
      const dateTables = getDateTables();
      const droppableCell = elements.find((el) => {
        const {
          classList
        } = el;
        const isCurrentSchedulerElement = 1 === dateTables.find(el).length;
        return isCurrentSchedulerElement && (classList.contains(DATE_TABLE_CELL_CLASS2) || classList.contains(ALL_DAY_TABLE_CELL_CLASS));
      });
      if (droppableCell) {
        if (!getDroppableCell().is(droppableCell)) {
          removeDroppableCellClass();
        }
        renderer_default(droppableCell).addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
      } else if (!isMoveUnderControl) {
        removeDroppableCellClass();
      }
    },
    onDragEnd: (e) => {
      var _state$dragElement;
      if (!isDefaultDraggingMode) {
        enableDefaultDragging();
      }
      if (!isItemDisabled()) {
        dragBehavior.onDragEnd(e);
      }
      null === (_state$dragElement = state.dragElement) || void 0 === _state$dragElement || _state$dragElement.remove();
      removeDroppableCellClass();
    },
    cursorOffset,
    filter: options.filter
  };
};
var m_work_space_default = SchedulerWorkSpace;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_agenda.js
var {
  tableCreator: tableCreator2
} = m_table_creator_default;
var AGENDA_CLASS = "dx-scheduler-agenda";
var AGENDA_DATE_CLASS = "dx-scheduler-agenda-date";
var GROUP_TABLE_CLASS = "dx-scheduler-group-table";
var TIME_PANEL_ROW_CLASS2 = "dx-scheduler-time-panel-row";
var TIME_PANEL_CELL_CLASS2 = "dx-scheduler-time-panel-cell";
var NODATA_CONTAINER_CLASS = "dx-scheduler-agenda-nodata";
var LAST_ROW_CLASS = "dx-scheduler-date-table-last-row";
var SchedulerAgenda = class extends m_work_space_default {
  get type() {
    return VIEWS.AGENDA;
  }
  get renderingStrategy() {
    return this.invoke("getLayoutManager").getRenderingStrategyInstance();
  }
  get appointmentDataProvider() {
    return this.option("getAppointmentDataProvider")();
  }
  getStartViewDate() {
    return this._startViewDate;
  }
  _init() {
    super._init();
    this._activeStateUnit = void 0;
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      agendaDuration: 7,
      rowHeight: 60,
      noDataText: ""
    });
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    const {
      value: value2
    } = args;
    switch (name2) {
      case "agendaDuration":
        break;
      case "noDataText":
      case "rowHeight":
        this._recalculateAgenda(this._rows);
        break;
      case "groups":
        if (!value2 || !value2.length) {
          if (this._$groupTable) {
            this._$groupTable.remove();
            this._$groupTable = null;
            this._detachGroupCountClass();
          }
        } else if (!this._$groupTable) {
          this._initGroupTable();
          this._dateTableScrollable.$content().prepend(this._$groupTable);
        }
        super._optionChanged(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
  _renderFocusState() {
    return noop();
  }
  _renderFocusTarget() {
    return noop();
  }
  _cleanFocusState() {
    return noop();
  }
  supportAllDayRow() {
    return false;
  }
  _isVerticalGroupedWorkSpace() {
    return false;
  }
  _getElementClass() {
    return AGENDA_CLASS;
  }
  _calculateStartViewDate() {
    return agendaUtils.calculateStartViewDate(this.option("currentDate"), this.option("startDayHour"));
  }
  _getRowCount() {
    return this.option("agendaDuration");
  }
  _getCellCount() {
    return 1;
  }
  _getTimePanelRowCount() {
    return this.option("agendaDuration");
  }
  _renderAllDayPanel() {
    return noop();
  }
  _toggleAllDayVisibility() {
    return noop();
  }
  _initWorkSpaceUnits() {
    this._initGroupTable();
    this._$timePanel = renderer_default("<table>").addClass(TIME_PANEL_CLASS);
    this._$dateTable = renderer_default("<table>").addClass(DATE_TABLE_CLASS);
    this._$dateTableScrollableContent = renderer_default("<div>").addClass("dx-scheduler-date-table-scrollable-content");
    this._$dateTableContainer = renderer_default("<div>").addClass("dx-scheduler-date-table-container");
  }
  _initGroupTable() {
    const groups = this.option("groups");
    if (groups && groups.length) {
      this._$groupTable = renderer_default("<table>").addClass(GROUP_TABLE_CLASS);
    }
  }
  _renderView() {
    this._startViewDate = this._calculateStartViewDate();
    this._rows = [];
    this._initPositionHelper();
  }
  _recalculateAgenda(rows) {
    let cellTemplates = [];
    this._cleanView();
    if (this._rowsIsEmpty(rows)) {
      this._renderNoData();
      return;
    }
    this._rows = rows;
    if (this._$groupTable) {
      cellTemplates = this._renderGroupHeader();
      this._setGroupHeaderCellsHeight();
    }
    this._renderTimePanel();
    this._renderDateTable();
    this.invoke("onAgendaReady", rows);
    this._applyCellTemplates(cellTemplates);
    this._dateTableScrollable.update();
  }
  _renderNoData() {
    this._$noDataContainer = renderer_default("<div>").addClass(NODATA_CONTAINER_CLASS).html(this.option("noDataText"));
    this._dateTableScrollable.$content().append(this._$noDataContainer);
  }
  _setTableSizes() {
    return noop();
  }
  _toggleHorizontalScrollClass() {
    return noop();
  }
  _createCrossScrollingConfig(argument) {
    return noop();
  }
  _setGroupHeaderCellsHeight() {
    const $cells = this._getGroupHeaderCells().filter((_, element) => !element.getAttribute("rowSpan"));
    const rows = this._removeEmptyRows(this._rows);
    if (!rows.length) {
      return;
    }
    for (let i = 0; i < $cells.length; i++) {
      const $cellContent = $cells.eq(i).find(".dx-scheduler-group-header-content");
      setOuterHeight($cellContent, this._getGroupRowHeight(rows[i]));
    }
  }
  _rowsIsEmpty(rows) {
    let result = true;
    for (let i = 0; i < rows.length; i++) {
      const groupRow = rows[i];
      for (let j = 0; j < groupRow.length; j++) {
        if (groupRow[j]) {
          result = false;
          break;
        }
      }
    }
    return result;
  }
  _attachGroupCountClass() {
    const className = getVerticalGroupCountClass(this.option("groups"));
    this.$element().addClass(className);
  }
  _removeEmptyRows(rows) {
    const result = [];
    for (let i = 0; i < rows.length; i++) {
      if (rows[i].length && !(data2 = rows[i], !data2.some((value2) => value2 > 0))) {
        result.push(rows[i]);
      }
    }
    var data2;
    return result;
  }
  _getGroupHeaderContainer() {
    return this._$groupTable;
  }
  _makeGroupRows() {
    const tree = createReducedResourcesTree(this.option("loadedResources"), (field, action) => getDataAccessors(this.option("getResourceDataAccessors")(), field, action), this.option("getFilteredItems")());
    const cellTemplate = this.option("resourceCellTemplate");
    const getGroupHeaderContentClass = GROUP_HEADER_CONTENT_CLASS;
    const cellTemplates = [];
    const table = tableCreator2.makeGroupedTableFromJSON(tableCreator2.VERTICAL, tree, {
      cellTag: "th",
      groupTableClass: GROUP_TABLE_CLASS,
      groupRowClass: GROUP_ROW_CLASS,
      groupCellClass: this._getGroupHeaderClass(),
      groupCellCustomContent(cell, cellTextElement, index, data2) {
        const container = dom_adapter_default.createElement("div");
        container.className = getGroupHeaderContentClass;
        if (cellTemplate && cellTemplate.render) {
          cellTemplates.push(cellTemplate.render.bind(cellTemplate, {
            model: {
              data: data2.data,
              id: data2.value,
              color: data2.color,
              text: cellTextElement.textContent
            },
            container: getPublicElement(renderer_default(container)),
            index
          }));
        } else {
          const contentWrapper = dom_adapter_default.createElement("div");
          contentWrapper.appendChild(cellTextElement);
          container.appendChild(contentWrapper);
        }
        cell.appendChild(container);
      },
      cellTemplate
    });
    return {
      elements: renderer_default(table).find(`.${GROUP_ROW_CLASS}`),
      cellTemplates
    };
  }
  _cleanView() {
    this._$dateTable.empty();
    this._$timePanel.empty();
    if (this._$groupTable) {
      this._$groupTable.empty();
    }
    if (this._$noDataContainer) {
      this._$noDataContainer.empty();
      this._$noDataContainer.remove();
      delete this._$noDataContainer;
    }
  }
  _createWorkSpaceElements() {
    this._createWorkSpaceStaticElements();
  }
  _createWorkSpaceStaticElements() {
    this._$dateTableContainer.append(this._$dateTable);
    this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);
    if (this._$groupTable) {
      this._$dateTableScrollableContent.prepend(this._$groupTable);
    }
    this._$dateTableScrollableContent.append(this._$timePanel, this._$dateTableContainer);
    this.$element().append(this._dateTableScrollable.$element());
  }
  _renderDateTable() {
    this._renderTableBody({
      container: getPublicElement(this._$dateTable),
      rowClass: DATE_TABLE_ROW_CLASS,
      cellClass: this._getDateTableCellClass()
    });
  }
  _attachTablesEvents() {
    return noop();
  }
  _attachEvents() {
    return noop();
  }
  _cleanCellDataCache() {
    return noop();
  }
  isIndicationAvailable() {
    return false;
  }
  _prepareCellTemplateOptions(text, date, rowIndex, $cell) {
    const groupsOpt = this.option("groups");
    const groups = {};
    const isGroupedView = !!groupsOpt.length;
    const path = isGroupedView && getPathToLeaf(rowIndex, groupsOpt) || [];
    path.forEach((resourceValue, resourceIndex) => {
      const resourceName = groupsOpt[resourceIndex].name;
      groups[resourceName] = resourceValue;
    });
    const groupIndex = isGroupedView ? this._getGroupIndexByResourceId(groups) : void 0;
    return {
      model: {
        text,
        date,
        groups,
        groupIndex
      },
      container: getPublicElement($cell),
      index: rowIndex
    };
  }
  _renderTableBody(options, delayCellTemplateRendering) {
    const cellTemplates = [];
    const cellTemplateOpt = options.cellTemplate;
    this._$rows = [];
    let i;
    const fillTableBody = (function(rowIndex, rowSize) {
      if (rowSize) {
        let date;
        let cellDateNumber;
        let cellDayName;
        const $row = renderer_default("<tr>");
        const $td = renderer_default("<td>");
        setHeight($td, this._getRowHeight(rowSize));
        if (options.getStartDate) {
          date = options.getStartDate && options.getStartDate(rowIndex);
          cellDateNumber = date_default.format(date, "d");
          cellDayName = date_default.format(date, formatWeekday);
        }
        if (cellTemplateOpt && cellTemplateOpt.render) {
          const templateOptions = this._prepareCellTemplateOptions(`${cellDateNumber} ${cellDayName}`, date, i, $td);
          cellTemplates.push(cellTemplateOpt.render.bind(cellTemplateOpt, templateOptions));
        } else if (cellDateNumber && cellDayName) {
          $td.addClass(AGENDA_DATE_CLASS).text(`${cellDateNumber} ${cellDayName}`);
        }
        if (options.rowClass) {
          $row.addClass(options.rowClass);
        }
        if (options.cellClass) {
          $td.addClass(options.cellClass);
        }
        $row.append($td);
        this._$rows.push($row);
      }
    }).bind(this);
    for (i = 0; i < this._rows.length; i++) {
      each(this._rows[i], fillTableBody);
      this._setLastRowClass();
    }
    renderer_default(options.container).append(renderer_default("<tbody>").append(this._$rows));
    this._applyCellTemplates(cellTemplates);
  }
  _setLastRowClass() {
    if (this._rows.length > 1 && this._$rows.length) {
      const $lastRow = this._$rows[this._$rows.length - 1];
      $lastRow.addClass(LAST_ROW_CLASS);
    }
  }
  _renderTimePanel() {
    this._renderTableBody({
      container: getPublicElement(this._$timePanel),
      rowCount: this._getTimePanelRowCount(),
      cellCount: 1,
      rowClass: TIME_PANEL_ROW_CLASS2,
      cellClass: TIME_PANEL_CELL_CLASS2,
      cellTemplate: this.option("dateCellTemplate"),
      getStartDate: this._getTimePanelStartDate.bind(this)
    });
  }
  _getTimePanelStartDate(rowIndex) {
    const current2 = new Date(this.option("currentDate"));
    const cellDate = new Date(current2.setDate(current2.getDate() + rowIndex));
    return cellDate;
  }
  _getRowHeight(rowSize) {
    const baseHeight = this.option("rowHeight");
    const innerOffset = 5 * (rowSize - 1);
    return rowSize ? baseHeight * rowSize + innerOffset + 20 : 0;
  }
  _getGroupRowHeight(groupRows) {
    if (!groupRows) {
      return;
    }
    let result = 0;
    for (let i = 0; i < groupRows.length; i++) {
      result += this._getRowHeight(groupRows[i]);
    }
    return result;
  }
  _calculateRows(appointments) {
    return this.renderingStrategy.calculateRows(appointments, this.option("agendaDuration"), this.option("currentDate"));
  }
  onDataSourceChanged(appointments) {
    super.onDataSourceChanged();
    this._renderView();
    const rows = this._calculateRows(appointments);
    this._recalculateAgenda(rows);
  }
  getAgendaVerticalStepHeight() {
    return this.option("rowHeight");
  }
  getEndViewDate() {
    const currentDate = new Date(this.option("currentDate"));
    const agendaDuration = this.option("agendaDuration");
    currentDate.setHours(this.option("endDayHour"));
    const result = currentDate.setDate(currentDate.getDate() + agendaDuration - 1) - 6e4;
    return new Date(result);
  }
  getEndViewDateByEndDayHour() {
    return this.getEndViewDate();
  }
  getCellDataByCoordinates() {
    return {
      startDate: null,
      endDate: null
    };
  }
  updateScrollPosition(date) {
    const newDate = this.timeZoneCalculator.createDate(date, {
      path: "toGrid"
    });
    const bounds = this.getVisibleBounds();
    const startDateHour = newDate.getHours();
    const startDateMinutes = newDate.getMinutes();
    if (this.needUpdateScrollPosition(startDateHour, startDateMinutes, bounds, newDate)) {
      this.scrollToTime(startDateHour, startDateMinutes, newDate);
    }
  }
  needUpdateScrollPosition(hours, minutes, bounds, newData) {
    let isUpdateNeeded = false;
    if (hours < bounds.top.hours || hours > bounds.bottom.hours) {
      isUpdateNeeded = true;
    }
    if (hours === bounds.top.hours && minutes < bounds.top.minutes) {
      isUpdateNeeded = true;
    }
    if (hours === bounds.bottom.hours && minutes > bounds.top.minutes) {
      isUpdateNeeded = true;
    }
    return isUpdateNeeded;
  }
  renovatedRenderSupported() {
    return false;
  }
  _setSelectedCellsByCellData() {
  }
  _getIntervalDuration() {
    return date_default2.dateToMilliseconds("day") * this.option("intervalCount");
  }
  getDOMElementsMetaData() {
    return {
      dateTableCellsMeta: [
        [{}]
      ],
      allDayPanelCellsMeta: [{}]
    };
  }
};
component_registrator_default("dxSchedulerAgenda", SchedulerAgenda);
var m_agenda_default = SchedulerAgenda;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/shaders/m_current_time_shader_horizontal.js
var HorizontalCurrentTimeShader = class extends m_current_time_shader_default {
  renderShader() {
    const groupCount = this._workSpace._isHorizontalGroupedWorkSpace() ? this._workSpace._getGroupCount() : 1;
    for (let i = 0; i < groupCount; i += 1) {
      const isFirstShader = 0 === i;
      const $shader = isFirstShader ? this._$shader : this.createShader();
      if (this._workSpace.isGroupedByDate()) {
        this._customizeGroupedByDateShader($shader, i);
      } else {
        this._customizeShader($shader, i);
      }
      !isFirstShader && this._shader.push($shader);
    }
  }
  _customizeShader($shader, groupIndex) {
    const shaderWidth = this._workSpace.getIndicationWidth();
    this._applyShaderWidth($shader, shaderWidth);
    if (groupIndex >= 1) {
      const workSpace = this._workSpace;
      const indicationWidth = workSpace._getCellCount() * workSpace.getCellWidth();
      $shader.css("left", indicationWidth);
    } else {
      $shader.css("left", 0);
    }
  }
  _applyShaderWidth($shader, width) {
    const maxWidth = getBoundingRect(this._$container.get(0)).width;
    if (width > maxWidth) {
      width = maxWidth;
    }
    if (width > 0) {
      setWidth($shader, width);
    }
  }
  _customizeGroupedByDateShader($shader, groupIndex) {
    const cellCount = this._workSpace.getIndicationCellCount();
    const integerPart = Math.floor(cellCount);
    const fractionPart = cellCount - integerPart;
    const isFirstShaderPart = 0 === groupIndex;
    const workSpace = this._workSpace;
    const shaderWidth = isFirstShaderPart ? workSpace.getIndicationWidth() : fractionPart * workSpace.getCellWidth();
    let shaderLeft;
    this._applyShaderWidth($shader, shaderWidth);
    if (isFirstShaderPart) {
      shaderLeft = workSpace._getCellCount() * workSpace.getCellWidth() * groupIndex;
    } else {
      shaderLeft = workSpace.getCellWidth() * integerPart * workSpace._getGroupCount() + groupIndex * workSpace.getCellWidth();
    }
    $shader.css("left", shaderLeft);
  }
};
var m_current_time_shader_horizontal_default = HorizontalCurrentTimeShader;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_indicator.js
var toMs23 = date_default2.dateToMilliseconds;
var TIME_PANEL_CURRENT_TIME_CELL_CLASS = "dx-scheduler-time-panel-current-time-cell";
var SchedulerWorkSpaceIndicator = class extends m_work_space_default {
  _getToday() {
    const viewOffset = this.option("viewOffset");
    const today = getToday(this.option("indicatorTime"), this.timeZoneCalculator);
    return dateUtilsTs.addOffsets(today, [-viewOffset]);
  }
  isIndicationOnView() {
    if (this.option("showCurrentTimeIndicator")) {
      const today = this._getToday();
      const endViewDate = date_default2.trimTime(this.getEndViewDate());
      return date_default2.dateInRange(today, this.getStartViewDate(), new Date(endViewDate.getTime() + toMs23("day")));
    }
    return false;
  }
  isIndicationAvailable() {
    if (!hasWindow()) {
      return false;
    }
    const today = this._getToday();
    return today >= date_default2.trimTime(new Date(this.getStartViewDate()));
  }
  isIndicatorVisible() {
    const today = this._getToday();
    const endViewDate = new Date(this.getEndViewDate().getTime() + toMs23("minute") - 1);
    const firstViewDate = new Date(this.getStartViewDate());
    firstViewDate.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
    endViewDate.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
    return date_default2.dateInRange(today, firstViewDate, endViewDate);
  }
  _renderIndicator(height, rtlOffset, $container, groupCount) {
    const groupedByDate = this.isGroupedByDate();
    const repeatCount = groupedByDate ? 1 : groupCount;
    for (let i = 0; i < repeatCount; i++) {
      const $indicator = this._createIndicator($container);
      setWidth($indicator, groupedByDate ? this.getCellWidth() * groupCount : this.getCellWidth());
      this._groupedStrategy.shiftIndicator($indicator, height, rtlOffset, i);
    }
  }
  _createIndicator($container) {
    const $indicator = renderer_default("<div>").addClass("dx-scheduler-date-time-indicator");
    $container.append($indicator);
    return $indicator;
  }
  _getRtlOffset(width) {
    return this.option("rtlEnabled") ? getBoundingRect(this._dateTableScrollable.$content().get(0)).width - this.getTimePanelWidth() - width : 0;
  }
  _setIndicationUpdateInterval() {
    if (!this.option("showCurrentTimeIndicator") || 0 === this.option("indicatorUpdateInterval")) {
      return;
    }
    this._clearIndicatorUpdateInterval();
    this._indicatorInterval = setInterval(() => {
      this.renderCurrentDateTimeIndication();
    }, this.option("indicatorUpdateInterval"));
  }
  _clearIndicatorUpdateInterval() {
    if (this._indicatorInterval) {
      clearInterval(this._indicatorInterval);
      delete this._indicatorInterval;
    }
  }
  _isVerticalShader() {
    return true;
  }
  getIndicationWidth(groupIndex) {
    const maxWidth = this.getCellWidth() * this._getCellCount();
    let difference = this._getIndicatorDuration();
    if (difference > this._getCellCount()) {
      difference = this._getCellCount();
    }
    const width = difference * this.getRoundedCellWidth(groupIndex, groupIndex * this._getCellCount(), difference);
    return maxWidth < width ? maxWidth : width;
  }
  getIndicatorOffset(groupIndex) {
    const difference = this._getIndicatorDuration() - 1;
    const offset = difference * this.getRoundedCellWidth(groupIndex, groupIndex * this._getCellCount(), difference);
    return offset;
  }
  _getIndicatorDuration() {
    const today = this._getToday();
    const firstViewDate = new Date(this.getStartViewDate());
    let timeDiff = today.getTime() - firstViewDate.getTime();
    if ("workWeek" === this.option("type")) {
      timeDiff -= this._getWeekendsCount(Math.round(timeDiff / toMs23("day"))) * toMs23("day");
    }
    return Math.ceil((timeDiff + 1) / toMs23("day"));
  }
  getIndicationHeight() {
    const today = m_utils_time_zone_default.getDateWithoutTimezoneChange(this._getToday());
    const cellHeight = this.getCellHeight();
    const date = new Date(this.getStartViewDate());
    if (this.isIndicationOnView()) {
      date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
    }
    const duration = today.getTime() - date.getTime();
    const cellCount = duration / this.getCellDuration();
    return cellCount * cellHeight;
  }
  _dispose() {
    this._clearIndicatorUpdateInterval();
    super._dispose.apply(this, arguments);
  }
  renderCurrentDateTimeIndication() {
    this.renderCurrentDateTimeLineAndShader();
    if (this.isRenovatedRender()) {
      this.renderWorkSpace({
        generateNewData: true,
        renderComponents: {
          header: true,
          timePanel: true
        }
      });
    }
  }
  renderCurrentDateTimeLineAndShader() {
    var _this$_shader;
    this._cleanDateTimeIndicator();
    null === (_this$_shader = this._shader) || void 0 === _this$_shader || _this$_shader.clean();
    this._renderDateTimeIndication();
  }
  _isCurrentTimeHeaderCell(headerIndex) {
    if (this.isIndicationOnView()) {
      const {
        completeDateHeaderMap
      } = this.viewDataProvider;
      const date = completeDateHeaderMap[completeDateHeaderMap.length - 1][headerIndex].startDate;
      return date_default2.sameDate(date, this._getToday());
    }
    return false;
  }
  _getHeaderPanelCellClass(i) {
    const cellClass = super._getHeaderPanelCellClass(i);
    if (this._isCurrentTimeHeaderCell(i)) {
      return `${cellClass} ${HEADER_CURRENT_TIME_CELL_CLASS}`;
    }
    return cellClass;
  }
  _cleanView() {
    super._cleanView();
    this._cleanDateTimeIndicator();
  }
  _dimensionChanged() {
    super._dimensionChanged();
    this.renderCurrentDateTimeLineAndShader();
  }
  _cleanDateTimeIndicator() {
    this.$element().find(".dx-scheduler-date-time-indicator").remove();
  }
  _cleanWorkSpace() {
    super._cleanWorkSpace();
    this._renderDateTimeIndication();
    this._setIndicationUpdateInterval();
  }
  _optionChanged(args) {
    switch (args.name) {
      case "showCurrentTimeIndicator":
      case "indicatorTime":
        this._cleanWorkSpace();
        break;
      case "indicatorUpdateInterval":
        this._setIndicationUpdateInterval();
        break;
      case "showAllDayPanel":
      case "allDayExpanded":
      case "crossScrollingEnabled":
        super._optionChanged(args);
        this.renderCurrentDateTimeIndication();
        break;
      case "shadeUntilCurrentTime":
        this.renderCurrentDateTimeIndication();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      showCurrentTimeIndicator: true,
      indicatorTime: /* @__PURE__ */ new Date(),
      indicatorUpdateInterval: 5 * toMs23("minute"),
      shadeUntilCurrentTime: true
    });
  }
  _getCurrentTimePanelCellIndices() {
    const rowCountPerGroup = this._getTimePanelRowCount();
    const today = this._getToday();
    const index = this.getCellIndexByDate(today);
    const {
      rowIndex: currentTimeRowIndex
    } = this._getCellCoordinatesByIndex(index);
    if (void 0 === currentTimeRowIndex) {
      return [];
    }
    let cellIndices;
    if (0 === currentTimeRowIndex) {
      cellIndices = [currentTimeRowIndex];
    } else {
      cellIndices = currentTimeRowIndex % 2 === 0 ? [currentTimeRowIndex - 1, currentTimeRowIndex] : [currentTimeRowIndex, currentTimeRowIndex + 1];
    }
    const verticalGroupCount = this._isVerticalGroupedWorkSpace() ? this._getGroupCount() : 1;
    return [...new Array(verticalGroupCount)].reduce((currentIndices, _, groupIndex) => [...currentIndices, ...cellIndices.map((cellIndex) => rowCountPerGroup * groupIndex + cellIndex)], []);
  }
  _renderDateTimeIndication() {
    if (!this.isIndicationAvailable()) {
      return;
    }
    if (this.option("shadeUntilCurrentTime")) {
      this._shader.render();
    }
    if (!this.isIndicationOnView() || !this.isIndicatorVisible()) {
      return;
    }
    const groupCount = this._getGroupCount() || 1;
    const $container = this._dateTableScrollable.$content();
    const height = this.getIndicationHeight();
    const rtlOffset = this._getRtlOffset(this.getCellWidth());
    this._renderIndicator(height, rtlOffset, $container, groupCount);
    if (!this.isRenovatedRender()) {
      this._setCurrentTimeCells();
    }
  }
  _setCurrentTimeCells() {
    const timePanelCells = this._getTimePanelCells();
    const currentTimeCellIndices = this._getCurrentTimePanelCellIndices();
    currentTimeCellIndices.forEach((timePanelCellIndex) => {
      timePanelCells.eq(timePanelCellIndex).addClass(TIME_PANEL_CURRENT_TIME_CELL_CLASS);
    });
  }
  _cleanCurrentTimeCells() {
    this.$element().find(`.${TIME_PANEL_CURRENT_TIME_CELL_CLASS}`).removeClass(TIME_PANEL_CURRENT_TIME_CELL_CLASS);
  }
};
component_registrator_default("dxSchedulerWorkSpace", SchedulerWorkSpaceIndicator);
var m_work_space_indicator_default = SchedulerWorkSpaceIndicator;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_timeline.js
var {
  tableCreator: tableCreator3
} = m_table_creator_default;
var TIMELINE_CLASS = "dx-scheduler-timeline";
var GROUP_TABLE_CLASS2 = "dx-scheduler-group-table";
var HORIZONTAL_GROUPED_WORKSPACE_CLASS = "dx-scheduler-work-space-horizontal-grouped";
var HEADER_PANEL_CELL_CLASS2 = "dx-scheduler-header-panel-cell";
var HEADER_PANEL_WEEK_CELL_CLASS = "dx-scheduler-header-panel-week-cell";
var HEADER_ROW_CLASS2 = "dx-scheduler-header-row";
var HORIZONTAL = "horizontal";
var toMs24 = date_default2.dateToMilliseconds;
var SchedulerTimeline = class extends m_work_space_indicator_default {
  constructor() {
    super(...arguments);
    this.viewDirection = "horizontal";
  }
  get verticalGroupTableClass() {
    return GROUP_TABLE_CLASS2;
  }
  get renovatedHeaderPanelComponent() {
    return HeaderPanelTimelineComponent;
  }
  getGroupTableWidth() {
    return this._$sidebarTable ? getOuterWidth(this._$sidebarTable) : 0;
  }
  _getTotalRowCount(groupCount) {
    if (this._isHorizontalGroupedWorkSpace()) {
      return this._getRowCount();
    }
    groupCount = groupCount || 1;
    return this._getRowCount() * groupCount;
  }
  _getFormat() {
    return "shorttime";
  }
  _getWorkSpaceHeight() {
    if (this.option("crossScrollingEnabled") && hasWindow()) {
      return getBoundingRect(this._$dateTable.get(0)).height;
    }
    return getBoundingRect(this.$element().get(0)).height;
  }
  _dateTableScrollableConfig() {
    const config = super._dateTableScrollableConfig();
    const timelineConfig = {
      direction: HORIZONTAL
    };
    return this.option("crossScrollingEnabled") ? config : extend(config, timelineConfig);
  }
  _needCreateCrossScrolling() {
    return true;
  }
  _headerScrollableConfig() {
    const config = super._headerScrollableConfig();
    return extend(config, {
      scrollByContent: true
    });
  }
  supportAllDayRow() {
    return false;
  }
  _getGroupHeaderContainer() {
    if (this._isHorizontalGroupedWorkSpace()) {
      return this._$thead;
    }
    return this._$sidebarTable;
  }
  _insertAllDayRowsIntoDateTable() {
    return false;
  }
  _needRenderWeekHeader() {
    return false;
  }
  _incrementDate(date) {
    date.setDate(date.getDate() + 1);
  }
  getIndicationCellCount() {
    const timeDiff = this._getTimeDiff();
    return this._calculateDurationInCells(timeDiff);
  }
  _getTimeDiff() {
    let today = this._getToday();
    const date = this._getIndicationFirstViewDate();
    const startViewDate = this.getStartViewDate();
    const dayLightOffset = m_utils_time_zone_default.getDaylightOffsetInMs(startViewDate, today);
    if (dayLightOffset) {
      today = new Date(today.getTime() + dayLightOffset);
    }
    return today.getTime() - date.getTime();
  }
  _calculateDurationInCells(timeDiff) {
    const today = this._getToday();
    const differenceInDays = Math.floor(timeDiff / toMs24("day"));
    let duration = (timeDiff - differenceInDays * toMs24("day") - this.option("startDayHour") * toMs24("hour")) / this.getCellDuration();
    if (today.getHours() > this.option("endDayHour")) {
      duration = this._getCellCountInDay();
    }
    if (duration < 0) {
      duration = 0;
    }
    return differenceInDays * this._getCellCountInDay() + duration;
  }
  getIndicationWidth() {
    if (this.isGroupedByDate()) {
      const cellCount = this.getIndicationCellCount();
      const integerPart = Math.floor(cellCount);
      const fractionPart = cellCount - integerPart;
      return this.getCellWidth() * (integerPart * this._getGroupCount() + fractionPart);
    }
    return this.getIndicationCellCount() * this.getCellWidth();
  }
  _isVerticalShader() {
    return false;
  }
  _isCurrentTimeHeaderCell() {
    return false;
  }
  _setTableSizes() {
    super._setTableSizes();
    const minHeight = this._getWorkSpaceMinHeight();
    setHeight(this._$sidebarTable, minHeight);
    setHeight(this._$dateTable, minHeight);
    this.virtualScrollingDispatcher.updateDimensions();
  }
  _getWorkSpaceMinHeight() {
    let minHeight = this._getWorkSpaceHeight();
    const workspaceContainerHeight = getOuterHeight(this._$flexContainer, true);
    if (minHeight < workspaceContainerHeight) {
      minHeight = workspaceContainerHeight;
    }
    return minHeight;
  }
  _getCellCoordinatesByIndex(index) {
    return {
      columnIndex: index % this._getCellCount(),
      rowIndex: 0
    };
  }
  _getCellByCoordinates(cellCoordinates, groupIndex) {
    const indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex);
    return this._$dateTable.find("tr").eq(indexes.rowIndex).find("td").eq(indexes.columnIndex);
  }
  _getWorkSpaceWidth() {
    return getOuterWidth(this._$dateTable, true);
  }
  _getIndicationFirstViewDate() {
    return date_default2.trimTime(new Date(this.getStartViewDate()));
  }
  _getIntervalBetween(currentDate, allDay) {
    const startDayHour = this.option("startDayHour");
    const endDayHour = this.option("endDayHour");
    const firstViewDate = this.getStartViewDate();
    const firstViewDateTime = firstViewDate.getTime();
    const hiddenInterval = (24 - endDayHour + startDayHour) * toMs24("hour");
    const timeZoneOffset = date_default2.getTimezonesDifference(firstViewDate, currentDate);
    const apptStart = currentDate.getTime();
    const fullInterval = apptStart - firstViewDateTime - timeZoneOffset;
    const fullDays = Math.floor(fullInterval / toMs24("day"));
    const tailDuration = fullInterval - fullDays * toMs24("day");
    let tailDelta = 0;
    const cellCount = this._getCellCountInDay() * (fullDays - this._getWeekendsCount(fullDays));
    const gapBeforeAppt = apptStart - date_default2.trimTime(new Date(currentDate)).getTime();
    let result = cellCount * this.option("hoursInterval") * toMs24("hour");
    if (!allDay) {
      if (currentDate.getHours() < startDayHour) {
        tailDelta = tailDuration - hiddenInterval + gapBeforeAppt;
      } else if (currentDate.getHours() >= startDayHour && currentDate.getHours() < endDayHour) {
        tailDelta = tailDuration;
      } else if (currentDate.getHours() >= startDayHour && currentDate.getHours() >= endDayHour) {
        tailDelta = tailDuration - (gapBeforeAppt - endDayHour * toMs24("hour"));
      } else if (!fullDays) {
        result = fullInterval;
      }
      result += tailDelta;
    }
    return result;
  }
  _getWeekendsCount(argument) {
    return 0;
  }
  getAllDayContainer() {
    return null;
  }
  getTimePanelWidth() {
    return 0;
  }
  getIntervalDuration(allDay) {
    return this.getCellDuration();
  }
  getCellMinWidth() {
    return 0;
  }
  getWorkSpaceLeftOffset() {
    return 0;
  }
  scrollToTime(hours, minutes, date) {
    const coordinates = this._getScrollCoordinates(hours, minutes, date);
    const scrollable = this.getScrollable();
    const offset = this.option("rtlEnabled") ? getBoundingRect(this.getScrollableContainer().get(0)).width : 0;
    if (this.option("templatesRenderAsynchronously")) {
      setTimeout(() => {
        scrollable.scrollBy({
          left: coordinates.left - scrollable.scrollLeft() - offset,
          top: 0
        });
      });
    } else {
      scrollable.scrollBy({
        left: coordinates.left - scrollable.scrollLeft() - offset,
        top: 0
      });
    }
  }
  renderRAllDayPanel() {
  }
  renderRTimeTable() {
  }
  _renderGroupAllDayPanel() {
  }
  generateRenderOptions(argument) {
    const options = super.generateRenderOptions(true);
    return _extends({}, options, {
      isGenerateWeekDaysHeaderData: this._needRenderWeekHeader(),
      getDateForHeaderText: timelineWeekUtils.getDateForHeaderText
    });
  }
  _init() {
    super._init();
    this.$element().addClass(TIMELINE_CLASS);
    this._$sidebarTable = renderer_default("<div>").addClass(GROUP_TABLE_CLASS2);
  }
  _getDefaultGroupStrategy() {
    return "vertical";
  }
  _toggleGroupingDirectionClass() {
    this.$element().toggleClass(HORIZONTAL_GROUPED_WORKSPACE_CLASS, this._isHorizontalGroupedWorkSpace());
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      groupOrientation: "vertical"
    });
  }
  _createWorkSpaceElements() {
    this._createWorkSpaceScrollableElements();
  }
  _toggleAllDayVisibility() {
    return noop();
  }
  _changeAllDayVisibility() {
    return noop();
  }
  _getDateHeaderTemplate() {
    return this.option("timeCellTemplate");
  }
  _renderView() {
    let groupCellTemplates;
    if (!this.isRenovatedRender()) {
      groupCellTemplates = this._renderGroupHeader();
    }
    this.renderWorkSpace();
    if (this.isRenovatedRender()) {
      this.virtualScrollingDispatcher.updateDimensions();
    }
    this._shader = new m_current_time_shader_horizontal_default(this);
    this._$sidebarTable.appendTo(this._sidebarScrollable.$content());
    if (this.isRenovatedRender() && this._isVerticalGroupedWorkSpace()) {
      this.renderRGroupPanel();
    }
    this.updateHeaderEmptyCellWidth();
    this._applyCellTemplates(groupCellTemplates);
  }
  _setHorizontalGroupHeaderCellsHeight() {
    return noop();
  }
  _getTimePanelCells() {
    return this.$element().find(`.${HEADER_PANEL_CELL_CLASS2}:not(.${HEADER_PANEL_WEEK_CELL_CLASS})`);
  }
  _getCurrentTimePanelCellIndices() {
    const columnCountPerGroup = this._getCellCount();
    const today = this._getToday();
    const index = this.getCellIndexByDate(today);
    const {
      columnIndex: currentTimeColumnIndex
    } = this._getCellCoordinatesByIndex(index);
    if (void 0 === currentTimeColumnIndex) {
      return [];
    }
    const horizontalGroupCount = this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate() ? this._getGroupCount() : 1;
    return [...new Array(horizontalGroupCount)].map((_, groupIndex) => columnCountPerGroup * groupIndex + currentTimeColumnIndex);
  }
  _renderTimePanel() {
    return noop();
  }
  _renderAllDayPanel() {
    return noop();
  }
  _createAllDayPanelElements() {
    return noop();
  }
  _renderDateHeader() {
    const $headerRow = super._renderDateHeader();
    if (this._needRenderWeekHeader()) {
      const firstViewDate = new Date(this.getStartViewDate());
      let currentDate = new Date(firstViewDate);
      const $cells = [];
      const groupCount = this._getGroupCount();
      const cellCountInDay = this._getCellCountInDay();
      const colSpan = this.isGroupedByDate() ? cellCountInDay * groupCount : cellCountInDay;
      const cellTemplate = this.option("dateCellTemplate");
      const horizontalGroupCount = this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate() ? groupCount : 1;
      const cellsInGroup = this.viewDataProvider.viewDataGenerator.daysInInterval * this.option("intervalCount");
      const cellsCount = cellsInGroup * horizontalGroupCount;
      for (let templateIndex = 0; templateIndex < cellsCount; templateIndex++) {
        const $th = renderer_default("<th>");
        const text = formatWeekdayAndDay(currentDate);
        if (cellTemplate) {
          const templateOptions = {
            model: _extends({
              text,
              date: new Date(currentDate)
            }, this._getGroupsForDateHeaderTemplate(templateIndex, colSpan)),
            container: $th,
            index: templateIndex
          };
          cellTemplate.render(templateOptions);
        } else {
          $th.text(text);
        }
        $th.addClass(HEADER_PANEL_CELL_CLASS2).addClass(HEADER_PANEL_WEEK_CELL_CLASS).attr("colSpan", colSpan);
        $cells.push($th);
        if (templateIndex % cellsInGroup === cellsInGroup - 1) {
          currentDate = new Date(firstViewDate);
        } else {
          this._incrementDate(currentDate);
        }
      }
      const $row = renderer_default("<tr>").addClass(HEADER_ROW_CLASS2).append($cells);
      $headerRow.before($row);
    }
  }
  _renderIndicator(height, rtlOffset, $container, groupCount) {
    let $indicator;
    const width = this.getIndicationWidth();
    if ("vertical" === this.option("groupOrientation")) {
      $indicator = this._createIndicator($container);
      setHeight($indicator, getBoundingRect($container.get(0)).height);
      $indicator.css("left", rtlOffset ? rtlOffset - width : width);
    } else {
      for (let i = 0; i < groupCount; i++) {
        const offset = this.isGroupedByDate() ? i * this.getCellWidth() : this._getCellCount() * this.getCellWidth() * i;
        $indicator = this._createIndicator($container);
        setHeight($indicator, getBoundingRect($container.get(0)).height);
        $indicator.css("left", rtlOffset ? rtlOffset - width - offset : width + offset);
      }
    }
  }
  _makeGroupRows(groups, groupByDate) {
    const tableCreatorStrategy = "vertical" === this.option("groupOrientation") ? tableCreator3.VERTICAL : tableCreator3.HORIZONTAL;
    return tableCreator3.makeGroupedTable(tableCreatorStrategy, groups, {
      groupRowClass: GROUP_ROW_CLASS,
      groupHeaderRowClass: GROUP_ROW_CLASS,
      groupHeaderClass: this._getGroupHeaderClass.bind(this),
      groupHeaderContentClass: GROUP_HEADER_CONTENT_CLASS
    }, this._getCellCount() || 1, this.option("resourceCellTemplate"), this._getTotalRowCount(this._getGroupCount()), groupByDate);
  }
  _setCurrentTimeCells() {
    const timePanelCells = this._getTimePanelCells();
    const currentTimeCellIndices = this._getCurrentTimePanelCellIndices();
    currentTimeCellIndices.forEach((timePanelCellIndex) => {
      timePanelCells.eq(timePanelCellIndex).addClass(HEADER_CURRENT_TIME_CELL_CLASS);
    });
  }
  _cleanCurrentTimeCells() {
    this.$element().find(`.${HEADER_CURRENT_TIME_CELL_CLASS}`).removeClass(HEADER_CURRENT_TIME_CELL_CLASS);
  }
};
component_registrator_default("dxSchedulerTimeline", SchedulerTimeline);
var m_timeline_default = SchedulerTimeline;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_timeline_day.js
var TIMELINE_CLASS2 = "dx-scheduler-timeline-day";
var SchedulerTimelineDay = class extends m_timeline_default {
  get type() {
    return VIEWS.TIMELINE_DAY;
  }
  _getElementClass() {
    return TIMELINE_CLASS2;
  }
  _needRenderWeekHeader() {
    return this._isWorkSpaceWithCount();
  }
};
component_registrator_default("dxSchedulerTimelineDay", SchedulerTimelineDay);
var m_timeline_day_default = SchedulerTimelineDay;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_timeline_month.js
var TIMELINE_CLASS3 = "dx-scheduler-timeline-month";
var SchedulerTimelineMonth = class extends m_timeline_default {
  constructor() {
    super(...arguments);
    this.viewDirection = "horizontal";
  }
  get type() {
    return VIEWS.TIMELINE_MONTH;
  }
  get renovatedHeaderPanelComponent() {
    return HeaderPanelComponent;
  }
  _renderView() {
    super._renderView();
    this._updateScrollable();
  }
  _getElementClass() {
    return TIMELINE_CLASS3;
  }
  _getDateHeaderTemplate() {
    return this.option("dateCellTemplate");
  }
  _calculateDurationInCells(timeDiff) {
    return timeDiff / this.getCellDuration();
  }
  isIndicatorVisible() {
    return true;
  }
  _getFormat() {
    return formatWeekdayAndDay;
  }
  _getIntervalBetween(currentDate) {
    const firstViewDate = this.getStartViewDate();
    const timeZoneOffset = date_default2.getTimezonesDifference(firstViewDate, currentDate);
    return currentDate.getTime() - (firstViewDate.getTime() - 36e5 * this.option("startDayHour")) - timeZoneOffset;
  }
  _getViewStartByOptions() {
    return monthUtils.getViewStartByOptions(this.option("startDate"), this.option("currentDate"), this.option("intervalCount"), date_default2.getFirstMonthDate(this.option("startDate")));
  }
  generateRenderOptions() {
    const options = super.generateRenderOptions(true);
    return _extends({}, options, {
      getDateForHeaderText: (_, date) => date
    });
  }
  keepOriginalHours() {
    return true;
  }
};
component_registrator_default("dxSchedulerTimelineMonth", SchedulerTimelineMonth);
var m_timeline_month_default = SchedulerTimelineMonth;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_timeline_week.js
var TIMELINE_CLASS4 = "dx-scheduler-timeline-week";
var SchedulerTimelineWeek = class extends m_timeline_default {
  get type() {
    return VIEWS.TIMELINE_WEEK;
  }
  _getElementClass() {
    return TIMELINE_CLASS4;
  }
  _getHeaderPanelCellWidth($headerRow) {
    return getBoundingRect($headerRow.children().first().get(0)).width;
  }
  _needRenderWeekHeader() {
    return true;
  }
  _incrementDate(date) {
    date.setDate(date.getDate() + 1);
  }
};
component_registrator_default("dxSchedulerTimelineWeek", SchedulerTimelineWeek);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_timeline_work_week.js
var TIMELINE_CLASS5 = "dx-scheduler-timeline-work-week";
var SchedulerTimelineWorkWeek = class extends SchedulerTimelineWeek {
  get type() {
    return VIEWS.TIMELINE_WORK_WEEK;
  }
  constructor() {
    super(...arguments);
    this._getWeekendsCount = getWeekendsCount;
  }
  _getElementClass() {
    return TIMELINE_CLASS5;
  }
  _incrementDate(date) {
    const day = date.getDay();
    if (5 === day) {
      date.setDate(date.getDate() + 2);
    }
    super._incrementDate(date);
  }
};
component_registrator_default("dxSchedulerTimelineWorkWeek", SchedulerTimelineWorkWeek);
var m_timeline_work_week_default = SchedulerTimelineWorkWeek;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_vertical.js
var SchedulerWorkspaceVertical = class extends m_work_space_indicator_default {
  _getFormat() {
    return formatWeekdayAndDay;
  }
  generateRenderOptions() {
    const options = super.generateRenderOptions();
    return _extends({}, options, {
      isGenerateTimePanelData: true
    });
  }
  _isRenderHeaderPanelEmptyCell() {
    return true;
  }
};
var m_work_space_vertical_default = SchedulerWorkspaceVertical;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_day.js
var DAY_CLASS = "dx-scheduler-work-space-day";
var SchedulerWorkSpaceDay = class extends m_work_space_vertical_default {
  get type() {
    return VIEWS.DAY;
  }
  _getElementClass() {
    return DAY_CLASS;
  }
  _renderDateHeader() {
    return 1 === this.option("intervalCount") ? null : super._renderDateHeader();
  }
  renderRHeaderPanel() {
    if (1 === this.option("intervalCount")) {
      super.renderRHeaderPanel(false);
    } else {
      super.renderRHeaderPanel(true);
    }
  }
};
component_registrator_default("dxSchedulerWorkSpaceDay", SchedulerWorkSpaceDay);
var m_work_space_day_default = SchedulerWorkSpaceDay;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_month.js
var MONTH_CLASS = "dx-scheduler-work-space-month";
var DATE_TABLE_CURRENT_DATE_CLASS = "dx-scheduler-date-table-current-date";
var DATE_TABLE_CELL_TEXT_CLASS = "dx-scheduler-date-table-cell-text";
var DATE_TABLE_FIRST_OF_MONTH_CLASS = "dx-scheduler-date-table-first-of-month";
var DATE_TABLE_OTHER_MONTH_DATE_CLASS = "dx-scheduler-date-table-other-month";
var toMs25 = date_default2.dateToMilliseconds;
var SchedulerWorkSpaceMonth = class extends m_work_space_indicator_default {
  get type() {
    return VIEWS.MONTH;
  }
  _getElementClass() {
    return MONTH_CLASS;
  }
  _getFormat() {
    return formatWeekday;
  }
  _getIntervalBetween(currentDate) {
    const firstViewDate = this.getStartViewDate();
    const timeZoneOffset = date_default2.getTimezonesDifference(firstViewDate, currentDate);
    return currentDate.getTime() - (firstViewDate.getTime() - 36e5 * this.option("startDayHour")) - timeZoneOffset;
  }
  _getDateGenerationOptions() {
    return _extends({}, super._getDateGenerationOptions(), {
      cellCountInDay: 1
    });
  }
  getCellWidth() {
    return this.cache.get("cellWidth", () => {
      let averageWidth = 0;
      const cells = this._getCells().slice(0, 7);
      cells.each((index, element) => {
        averageWidth += hasWindow() ? getBoundingRect(element).width : 0;
      });
      return 0 === cells.length ? void 0 : averageWidth / 7;
    });
  }
  _insertAllDayRowsIntoDateTable() {
    return false;
  }
  _getCellCoordinatesByIndex(index) {
    const rowIndex = Math.floor(index / this._getCellCount());
    const columnIndex = index - this._getCellCount() * rowIndex;
    return {
      rowIndex,
      columnIndex
    };
  }
  _needCreateCrossScrolling() {
    return this.option("crossScrollingEnabled") || this._isVerticalGroupedWorkSpace();
  }
  _getViewStartByOptions() {
    return monthUtils.getViewStartByOptions(this.option("startDate"), this.option("currentDate"), this.option("intervalCount"), date_default2.getFirstMonthDate(this.option("startDate")));
  }
  _updateIndex(index) {
    return index;
  }
  isIndicationAvailable() {
    return false;
  }
  getIntervalDuration() {
    return toMs25("day");
  }
  getTimePanelWidth() {
    return 0;
  }
  supportAllDayRow() {
    return false;
  }
  keepOriginalHours() {
    return true;
  }
  getWorkSpaceLeftOffset() {
    return 0;
  }
  needApplyCollectorOffset() {
    return true;
  }
  _getHeaderDate() {
    return this._getViewStartByOptions();
  }
  scrollToTime() {
    return noop();
  }
  renderRAllDayPanel() {
  }
  renderRTimeTable() {
  }
  renderRDateTable() {
    utils2.renovation.renderComponent(this, this._$dateTable, DateTableMonthComponent, "renovatedDateTable", this._getRDateTableProps());
  }
  _createWorkSpaceElements() {
    if (this._isVerticalGroupedWorkSpace()) {
      this._createWorkSpaceScrollableElements();
    } else {
      super._createWorkSpaceElements();
    }
  }
  _toggleAllDayVisibility() {
    return noop();
  }
  _changeAllDayVisibility() {
    return noop();
  }
  _renderTimePanel() {
    return noop();
  }
  _renderAllDayPanel() {
    return noop();
  }
  _setMonthClassesToCell($cell, data2) {
    $cell.toggleClass(DATE_TABLE_CURRENT_DATE_CLASS, data2.isCurrentDate).toggleClass(DATE_TABLE_FIRST_OF_MONTH_CLASS, data2.firstDayOfMonth).toggleClass(DATE_TABLE_OTHER_MONTH_DATE_CLASS, data2.otherMonth);
  }
  _createAllDayPanelElements() {
  }
  _renderTableBody(options) {
    options.getCellText = (rowIndex, columnIndex) => {
      const date = this.viewDataProvider.completeViewDataMap[rowIndex][columnIndex].startDate;
      return monthUtils.getCellText(date, this.option("intervalCount"));
    };
    options.getCellTextClass = DATE_TABLE_CELL_TEXT_CLASS;
    options.setAdditionalClasses = this._setMonthClassesToCell.bind(this);
    super._renderTableBody(options);
  }
};
component_registrator_default("dxSchedulerWorkSpaceMonth", SchedulerWorkSpaceMonth);
var m_work_space_month_default = SchedulerWorkSpaceMonth;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_week.js
var WEEK_CLASS = "dx-scheduler-work-space-week";
var SchedulerWorkSpaceWeek = class extends m_work_space_vertical_default {
  get type() {
    return VIEWS.WEEK;
  }
  _getElementClass() {
    return WEEK_CLASS;
  }
  _calculateViewStartDate() {
    return weekUtils.calculateViewStartDate(this.option("startDate"), this._firstDayOfWeek());
  }
};
component_registrator_default("dxSchedulerWorkSpaceWeek", SchedulerWorkSpaceWeek);
var m_work_space_week_default = SchedulerWorkSpaceWeek;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_work_week.js
var WORK_WEEK_CLASS = "dx-scheduler-work-space-work-week";
var SchedulerWorkSpaceWorkWeek = class extends m_work_space_week_default {
  get type() {
    return VIEWS.WORK_WEEK;
  }
  constructor() {
    super(...arguments);
    this._getWeekendsCount = getWeekendsCount;
  }
  _getElementClass() {
    return WORK_WEEK_CLASS;
  }
};
component_registrator_default("dxSchedulerWorkSpaceWorkWeek", SchedulerWorkSpaceWorkWeek);
var m_work_space_work_week_default = SchedulerWorkSpaceWorkWeek;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_scheduler.js
var toMs26 = date_default2.dateToMilliseconds;
var WIDGET_CLASS = "dx-scheduler";
var WIDGET_SMALL_CLASS = `${WIDGET_CLASS}-small`;
var WIDGET_ADAPTIVE_CLASS = `${WIDGET_CLASS}-adaptive`;
var WIDGET_READONLY_CLASS = `${WIDGET_CLASS}-readonly`;
var FULL_DATE_FORMAT3 = "yyyyMMddTHHmmss";
var UTC_FULL_DATE_FORMAT2 = `${FULL_DATE_FORMAT3}Z`;
var VIEWS_CONFIG = {
  day: {
    workSpace: m_work_space_day_default,
    renderingStrategy: "vertical"
  },
  week: {
    workSpace: m_work_space_week_default,
    renderingStrategy: "vertical"
  },
  workWeek: {
    workSpace: m_work_space_work_week_default,
    renderingStrategy: "vertical"
  },
  month: {
    workSpace: m_work_space_month_default,
    renderingStrategy: "horizontalMonth"
  },
  timelineDay: {
    workSpace: m_timeline_day_default,
    renderingStrategy: "horizontal"
  },
  timelineWeek: {
    workSpace: SchedulerTimelineWeek,
    renderingStrategy: "horizontal"
  },
  timelineWorkWeek: {
    workSpace: m_timeline_work_week_default,
    renderingStrategy: "horizontal"
  },
  timelineMonth: {
    workSpace: m_timeline_month_default,
    renderingStrategy: "horizontalMonthLine"
  },
  agenda: {
    workSpace: m_agenda_default,
    renderingStrategy: "agenda"
  }
};
var StoreEventNames = {
  ADDING: "onAppointmentAdding",
  ADDED: "onAppointmentAdded",
  DELETING: "onAppointmentDeleting",
  DELETED: "onAppointmentDeleted",
  UPDATING: "onAppointmentUpdating",
  UPDATED: "onAppointmentUpdated"
};
var RECURRENCE_EDITING_MODE = {
  SERIES: "editSeries",
  OCCURENCE: "editOccurence",
  CANCEL: "cancel"
};
var Scheduler = class extends ui_widget_default {
  _getDefaultOptions() {
    const defaultOptions = extend(super._getDefaultOptions(), {
      views: ["day", "week"],
      currentView: "day",
      currentDate: date_default2.trimTime(/* @__PURE__ */ new Date()),
      min: void 0,
      max: void 0,
      dateSerializationFormat: void 0,
      firstDayOfWeek: void 0,
      groups: [],
      resources: [],
      loadedResources: [],
      resourceLoaderMap: /* @__PURE__ */ new Map(),
      dataSource: null,
      customizeDateNavigatorText: void 0,
      appointmentTemplate: "item",
      dropDownAppointmentTemplate: "dropDownAppointment",
      appointmentCollectorTemplate: "appointmentCollector",
      dataCellTemplate: null,
      timeCellTemplate: null,
      resourceCellTemplate: null,
      dateCellTemplate: null,
      startDayHour: 0,
      endDayHour: 24,
      offset: 0,
      editing: {
        allowAdding: true,
        allowDeleting: true,
        allowDragging: true,
        allowResizing: true,
        allowUpdating: true,
        allowTimeZoneEditing: false
      },
      showAllDayPanel: true,
      showCurrentTimeIndicator: true,
      shadeUntilCurrentTime: false,
      indicatorUpdateInterval: 3e5,
      indicatorTime: void 0,
      recurrenceEditMode: "dialog",
      cellDuration: 30,
      maxAppointmentsPerCell: "auto",
      selectedCellData: [],
      groupByDate: false,
      onAppointmentRendered: null,
      onAppointmentClick: null,
      onAppointmentDblClick: null,
      onAppointmentContextMenu: null,
      onCellClick: null,
      onCellContextMenu: null,
      onAppointmentAdding: null,
      onAppointmentAdded: null,
      onAppointmentUpdating: null,
      onAppointmentUpdated: null,
      onAppointmentDeleting: null,
      onAppointmentDeleted: null,
      onAppointmentFormOpening: null,
      onAppointmentTooltipShowing: null,
      appointmentTooltipTemplate: "appointmentTooltip",
      appointmentPopupTemplate: "appointmentPopup",
      crossScrollingEnabled: false,
      useDropDownViewSwitcher: false,
      startDateExpr: "startDate",
      endDateExpr: "endDate",
      textExpr: "text",
      descriptionExpr: "description",
      allDayExpr: "allDay",
      recurrenceRuleExpr: "recurrenceRule",
      recurrenceExceptionExpr: "recurrenceException",
      disabledExpr: "disabled",
      remoteFiltering: false,
      timeZone: "",
      startDateTimeZoneExpr: "startDateTimeZone",
      endDateTimeZoneExpr: "endDateTimeZone",
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      adaptivityEnabled: false,
      allowMultipleCellSelection: true,
      scrolling: {
        mode: "standard"
      },
      allDayPanelMode: "all",
      renovateRender: true,
      _draggingMode: "outlook",
      _appointmentTooltipOffset: {
        x: 0,
        y: 0
      },
      _appointmentTooltipButtonsPosition: "bottom",
      _appointmentTooltipOpenButtonText: message_default.format("dxScheduler-openAppointment"),
      _appointmentCountPerCell: 2,
      _collectorOffset: 0,
      _appointmentOffset: 26,
      toolbar: [{
        location: "before",
        defaultElement: "dateNavigator"
      }, {
        location: "after",
        defaultElement: "viewSwitcher"
      }]
    });
    return extend(true, defaultOptions, {
      integrationOptions: {
        useDeferUpdateForTemplates: false
      }
    });
  }
  get filteredItems() {
    if (!this._filteredItems) {
      this._filteredItems = [];
    }
    return this._filteredItems;
  }
  set filteredItems(value2) {
    this._filteredItems = value2;
  }
  get preparedItems() {
    if (!this._preparedItems) {
      this._preparedItems = [];
    }
    return this._preparedItems;
  }
  set preparedItems(value2) {
    this._preparedItems = value2;
  }
  get currentView() {
    return viewsUtils.getCurrentView(this.option("currentView"), this.option("views"));
  }
  get currentViewType() {
    return isObject(this.currentView) ? this.currentView.type : this.currentView;
  }
  get timeZoneCalculator() {
    if (!this._timeZoneCalculator) {
      this._timeZoneCalculator = createTimeZoneCalculator(this.option("timeZone"));
    }
    return this._timeZoneCalculator;
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions();
    extend(this._deprecatedOptions, {
      dropDownAppointmentTemplate: {
        since: "19.2",
        message: "appointmentTooltipTemplate"
      }
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => !devices_default.current().generic,
      options: {
        useDropDownViewSwitcher: true,
        editing: {
          allowDragging: false,
          allowResizing: false
        }
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useDropDownViewSwitcher: true,
        dateCellTemplate(data2, index, element) {
          const {
            text
          } = data2;
          text.split(" ").forEach((text2, index2) => {
            const span = renderer_default("<span>").text(text2).addClass("dx-scheduler-header-panel-cell-date");
            renderer_default(element).append(span);
            if (!index2) {
              renderer_default(element).append(" ");
            }
          });
        },
        _appointmentTooltipButtonsPosition: "top",
        _appointmentTooltipOpenButtonText: null,
        _appointmentCountPerCell: 1,
        _collectorOffset: 20,
        _appointmentOffset: 30
      }
    }, {
      device: () => isMaterial(),
      options: {
        _appointmentTooltipOffset: {
          x: 0,
          y: 11
        }
      }
    }]);
  }
  _postponeDataSourceLoading(promise) {
    this.postponedOperations.add("_reloadDataSource", this._reloadDataSource.bind(this), promise);
  }
  _postponeResourceLoading() {
    const whenLoaded = this.postponedOperations.add("loadResources", () => {
      const groups = this._getCurrentViewOption("groups");
      return loadResources(groups, this.option("resources"), this.option("resourceLoaderMap"));
    });
    const resolveCallbacks = new Deferred();
    whenLoaded.done((resources) => {
      this.option("loadedResources", resources);
      resolveCallbacks.resolve(resources);
    });
    this._postponeDataSourceLoading(whenLoaded);
    return resolveCallbacks.promise();
  }
  _optionChanged(args) {
    var _this$_header, _this$_header2, _this$_header4;
    this.validateOptions();
    let {
      value: value2
    } = args;
    const {
      name: name2
    } = args;
    switch (args.name) {
      case "customizeDateNavigatorText":
        this._updateOption("header", name2, value2);
        break;
      case "firstDayOfWeek":
        this._updateOption("workSpace", name2, value2);
        this._updateOption("header", name2, value2);
        break;
      case "currentDate":
        value2 = this._dateOption(name2);
        value2 = date_default2.trimTime(new Date(value2));
        this.option("selectedCellData", []);
        this._workSpace.option(name2, new Date(value2));
        null === (_this$_header = this._header) || void 0 === _this$_header || _this$_header.option(name2, new Date(value2));
        null === (_this$_header2 = this._header) || void 0 === _this$_header2 || _this$_header2.option("startViewDate", this.getStartViewDate());
        this._appointments.option("items", []);
        this._filterAppointmentsByDate();
        this._postponeDataSourceLoading();
        break;
      case "dataSource":
        this._initDataSource();
        this.appointmentDataProvider.setDataSource(this._dataSource);
        this._postponeResourceLoading().done(() => {
          this._filterAppointmentsByDate();
          this._updateOption("workSpace", "showAllDayPanel", this.option("showAllDayPanel"));
        });
        break;
      case "min":
      case "max":
        value2 = this._dateOption(name2);
        this._updateOption("header", name2, new Date(value2));
        this._updateOption("workSpace", name2, new Date(value2));
        break;
      case "views":
        if (this._getCurrentViewOptions()) {
          this.repaint();
        } else {
          var _this$_header3;
          null === (_this$_header3 = this._header) || void 0 === _this$_header3 || _this$_header3.option(name2, value2);
        }
        break;
      case "useDropDownViewSwitcher":
        null === (_this$_header4 = this._header) || void 0 === _this$_header4 || _this$_header4.option(name2, value2);
        break;
      case "currentView":
        this._appointments.option({
          items: [],
          allowDrag: this._allowDragging(),
          allowResize: this._allowResizing(),
          itemTemplate: this._getAppointmentTemplate("appointmentTemplate")
        });
        this._postponeResourceLoading().done((resources) => {
          var _this$_header5;
          this._refreshWorkSpace(resources);
          null === (_this$_header5 = this._header) || void 0 === _this$_header5 || _this$_header5.option(this._headerConfig());
          this._filterAppointmentsByDate();
          this._appointments.option("allowAllDayResize", "day" !== value2);
        });
        this.postponedOperations.callPostponedOperations();
        break;
      case "appointmentTemplate":
        this._appointments.option("itemTemplate", value2);
        break;
      case "dateCellTemplate":
      case "resourceCellTemplate":
      case "dataCellTemplate":
      case "timeCellTemplate":
        this.repaint();
        break;
      case "groups":
        this._postponeResourceLoading().done((resources) => {
          this._refreshWorkSpace(resources);
          this._filterAppointmentsByDate();
        });
        break;
      case "resources":
        this._dataAccessors.resources = createExpressions(this.option("resources"));
        this.agendaResourceProcessor.initializeState(this.option("resources"));
        this.updateInstances();
        this.option("resourceLoaderMap").clear();
        this._postponeResourceLoading().done((resources) => {
          this._appointments.option("items", []);
          this._refreshWorkSpace(resources);
          this._filterAppointmentsByDate();
          this._createAppointmentPopupForm();
        });
        break;
      case "startDayHour":
      case "endDayHour":
        this.updateInstances();
        this._appointments.option("items", []);
        this._updateOption("workSpace", name2, value2);
        this._appointments.repaint();
        this._filterAppointmentsByDate();
        this._postponeDataSourceLoading();
        break;
      case "offset":
        this.updateInstances();
        this._appointments.option("items", []);
        this._updateOption("workSpace", "viewOffset", this.normalizeViewOffsetValue(value2));
        this._appointments.repaint();
        this._filterAppointmentsByDate();
        this._postponeDataSourceLoading();
        break;
      case StoreEventNames.ADDING:
      case StoreEventNames.ADDED:
      case StoreEventNames.UPDATING:
      case StoreEventNames.UPDATED:
      case StoreEventNames.DELETING:
      case StoreEventNames.DELETED:
      case "onAppointmentFormOpening":
      case "onAppointmentTooltipShowing":
        this._actions[name2] = this._createActionByOption(name2);
        break;
      case "onAppointmentRendered":
        this._appointments.option("onItemRendered", this._getAppointmentRenderedAction());
        break;
      case "onAppointmentClick":
        this._appointments.option("onItemClick", this._createActionByOption(name2));
        break;
      case "onAppointmentDblClick":
        this._appointments.option(name2, this._createActionByOption(name2));
        break;
      case "onAppointmentContextMenu":
        this._appointments.option("onItemContextMenu", this._createActionByOption(name2));
        this._appointmentTooltip._options.onItemContextMenu = this._createActionByOption(name2);
        break;
      case "noDataText":
      case "allowMultipleCellSelection":
      case "selectedCellData":
      case "accessKey":
      case "onCellClick":
      case "onCellContextMenu":
        this._workSpace.option(name2, value2);
        break;
      case "crossScrollingEnabled":
        this._postponeResourceLoading().done((resources) => {
          this._appointments.option("items", []);
          this._refreshWorkSpace(resources);
          if (this._readyToRenderAppointments) {
            this._appointments.option("items", this._getAppointmentsToRepaint());
          }
        });
        break;
      case "cellDuration":
        this._updateOption("workSpace", name2, value2);
        this._appointments.option("items", []);
        if (this._readyToRenderAppointments) {
          this._updateOption("workSpace", "hoursInterval", value2 / 60);
          this._appointments.option("items", this._getAppointmentsToRepaint());
        }
        break;
      case "tabIndex":
      case "focusStateEnabled":
        this._updateOption("header", name2, value2);
        this._updateOption("workSpace", name2, value2);
        this._appointments.option(name2, value2);
        super._optionChanged(args);
        break;
      case "width":
        this._updateOption("header", name2, value2);
        if (this.option("crossScrollingEnabled")) {
          this._updateOption("workSpace", "width", value2);
        }
        this._updateOption("workSpace", "schedulerWidth", value2);
        super._optionChanged(args);
        this._dimensionChanged(null, true);
        break;
      case "height":
        super._optionChanged(args);
        this._dimensionChanged(null, true);
        this._updateOption("workSpace", "schedulerHeight", value2);
        break;
      case "editing": {
        this._initEditing();
        const editing = this._editing;
        this._bringEditingModeToAppointments(editing);
        this.hideAppointmentTooltip();
        this._cleanPopup();
        break;
      }
      case "showAllDayPanel":
        this.updateInstances();
        this.repaint();
        break;
      case "showCurrentTimeIndicator":
      case "indicatorTime":
      case "indicatorUpdateInterval":
      case "shadeUntilCurrentTime":
      case "groupByDate":
        this._updateOption("workSpace", name2, value2);
        this.repaint();
        break;
      case "appointmentDragging":
      case "appointmentTooltipTemplate":
      case "appointmentPopupTemplate":
      case "recurrenceEditMode":
      case "remoteFiltering":
      case "timeZone":
        this.updateInstances();
        this.repaint();
        break;
      case "dropDownAppointmentTemplate":
      case "appointmentCollectorTemplate":
      case "_appointmentTooltipOffset":
      case "_appointmentTooltipButtonsPosition":
      case "_appointmentTooltipOpenButtonText":
      case "_appointmentCountPerCell":
      case "_collectorOffset":
      case "_appointmentOffset":
        this.repaint();
        break;
      case "dateSerializationFormat":
      case "maxAppointmentsPerCell":
        break;
      case "startDateExpr":
      case "endDateExpr":
      case "startDateTimeZoneExpr":
      case "endDateTimeZoneExpr":
      case "textExpr":
      case "descriptionExpr":
      case "allDayExpr":
      case "recurrenceRuleExpr":
      case "recurrenceExceptionExpr":
      case "disabledExpr":
        this._updateExpression(name2, value2);
        this.appointmentDataProvider.updateDataAccessors(this._dataAccessors);
        this._initAppointmentTemplate();
        this.repaint();
        break;
      case "adaptivityEnabled":
        this._toggleAdaptiveClass();
        this.repaint();
        break;
      case "scrolling":
        this.option("crossScrollingEnabled", this._isHorizontalVirtualScrolling() || this.option("crossScrollingEnabled"));
        this._updateOption("workSpace", args.fullName, value2);
        break;
      case "allDayPanelMode":
        this.updateInstances();
        this._updateOption("workSpace", args.fullName, value2);
        break;
      case "renovateRender":
        this._updateOption("workSpace", name2, value2);
        break;
      case "_draggingMode":
        this._workSpace.option("draggingMode", value2);
        break;
      case "toolbar":
        this._header ? this._header.option("items", value2) : this.repaint();
        break;
      case "loadedResources":
      case "resourceLoaderMap":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dateOption(optionName) {
    const optionValue = this._getCurrentViewOption(optionName);
    return date_serialization_default.deserializeDate(optionValue);
  }
  _getSerializationFormat(optionName) {
    const value2 = this._getCurrentViewOption(optionName);
    if ("number" === typeof value2) {
      return "number";
    }
    if (!isString(value2)) {
      return;
    }
    return date_serialization_default.getDateSerializationFormat(value2);
  }
  _bringEditingModeToAppointments(editing) {
    const editingConfig = {
      allowDelete: editing.allowUpdating && editing.allowDeleting
    };
    if (!this._isAgenda()) {
      editingConfig.allowDrag = editing.allowDragging;
      editingConfig.allowResize = editing.allowResizing;
      editingConfig.allowAllDayResize = editing.allowResizing && this._supportAllDayResizing();
    }
    this._appointments.option(editingConfig);
    this.repaint();
  }
  _isAgenda() {
    return "agenda" === this.getLayoutManager().appointmentRenderingStrategyName;
  }
  _allowDragging() {
    return this._editing.allowDragging && !this._isAgenda();
  }
  _allowResizing() {
    return this._editing.allowResizing && !this._isAgenda();
  }
  _allowAllDayResizing() {
    return this._editing.allowResizing && this._supportAllDayResizing();
  }
  _supportAllDayResizing() {
    return "day" !== this.currentViewType || this.currentView.intervalCount > 1;
  }
  _isAllDayExpanded() {
    return this.option("showAllDayPanel") && this.appointmentDataProvider.hasAllDayAppointments(this.filteredItems, this.preparedItems);
  }
  _getTimezoneOffsetByOption(date) {
    return m_utils_time_zone_default.calculateTimezoneByValue(this.option("timeZone"), date);
  }
  _filterAppointmentsByDate() {
    const dateRange = this._workSpace.getDateRange();
    const startDate = this.timeZoneCalculator.createDate(dateRange[0], {
      path: "fromGrid"
    });
    const endDate = this.timeZoneCalculator.createDate(dateRange[1], {
      path: "fromGrid"
    });
    this.appointmentDataProvider.filterByDate(startDate, endDate, this.option("remoteFiltering"), this.option("dateSerializationFormat"));
  }
  _reloadDataSource() {
    const result = new Deferred();
    if (this._dataSource) {
      this._dataSource.load().done(() => {
        hide();
        this._fireContentReadyAction(result);
      }).fail(() => {
        hide();
        result.reject();
      });
      this._dataSource.isLoading() && show({
        container: this.$element(),
        position: {
          of: this.$element()
        }
      });
    } else {
      this._fireContentReadyAction(result);
    }
    return result.promise();
  }
  _fireContentReadyAction(result) {
    const contentReadyBase = super._fireContentReadyAction.bind(this);
    const fireContentReady = () => {
      contentReadyBase();
      null === result || void 0 === result || result.resolve();
    };
    if (this._workSpaceRecalculation) {
      var _this$_workSpaceRecal;
      null === (_this$_workSpaceRecal = this._workSpaceRecalculation) || void 0 === _this$_workSpaceRecal || _this$_workSpaceRecal.done(() => {
        fireContentReady();
      });
    } else {
      fireContentReady();
    }
  }
  _dimensionChanged(value2) {
    let isForce = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const isFixedHeight = "number" === typeof this.option("height");
    const isFixedWidth = "number" === typeof this.option("width");
    if (!this._isVisible()) {
      return;
    }
    this._toggleSmallClass();
    const workspace = this.getWorkSpace();
    if (!this._isAgenda() && this.filteredItems && workspace) {
      if (isForce || !isFixedHeight || !isFixedWidth) {
        workspace.option("allDayExpanded", this._isAllDayExpanded());
        workspace._dimensionChanged();
        const appointments = this.getLayoutManager().createAppointmentsMap(this.filteredItems);
        this._appointments.option("items", appointments);
      }
    }
    this.hideAppointmentTooltip();
    this._appointmentPopup.triggerResize();
    this._appointmentPopup.updatePopupFullScreenMode();
  }
  _clean() {
    this._cleanPopup();
    super._clean();
  }
  _toggleSmallClass() {
    const {
      width
    } = getBoundingRect(this.$element().get(0));
    this.$element().toggleClass(WIDGET_SMALL_CLASS, width < 400);
  }
  _toggleAdaptiveClass() {
    this.$element().toggleClass(WIDGET_ADAPTIVE_CLASS, this.option("adaptivityEnabled"));
  }
  _visibilityChanged(visible) {
    visible && this._dimensionChanged(null, true);
  }
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _initAllDayPanel() {
    if ("hidden" === this.option("allDayPanelMode")) {
      this.option("showAllDayPanel", false);
    }
  }
  _init() {
    this._initExpressions({
      startDate: this.option("startDateExpr"),
      endDate: this.option("endDateExpr"),
      startDateTimeZone: this.option("startDateTimeZoneExpr"),
      endDateTimeZone: this.option("endDateTimeZoneExpr"),
      allDay: this.option("allDayExpr"),
      text: this.option("textExpr"),
      description: this.option("descriptionExpr"),
      recurrenceRule: this.option("recurrenceRuleExpr"),
      recurrenceException: this.option("recurrenceExceptionExpr"),
      disabled: this.option("disabledExpr")
    });
    super._init();
    this._initAllDayPanel();
    this._initDataSource();
    this._customizeDataSourceLoadOptions();
    this.$element().addClass(WIDGET_CLASS);
    this._initEditing();
    this.updateInstances();
    this._initActions();
    this._compactAppointmentsHelper = new CompactAppointmentsHelper(this);
    this._asyncTemplatesTimers = [];
    this._dataSourceLoadedCallback = callbacks_default();
    this._subscribes = m_subscribes_default;
    this.agendaResourceProcessor = new AgendaResourceProcessor(this.option("resources"));
    this._optionsValidator = new SchedulerOptionsValidator();
    this._optionsValidatorErrorHandler = new SchedulerOptionsValidatorErrorsHandler();
  }
  createAppointmentDataProvider() {
    var _this$appointmentData;
    null === (_this$appointmentData = this.appointmentDataProvider) || void 0 === _this$appointmentData || _this$appointmentData.destroy();
    this.appointmentDataProvider = new AppointmentDataProvider({
      dataSource: this._dataSource,
      dataAccessors: this._dataAccessors,
      timeZoneCalculator: this.timeZoneCalculator,
      dateSerializationFormat: this.option("dateSerializationFormat"),
      resources: this.option("resources"),
      startDayHour: this._getCurrentViewOption("startDayHour"),
      endDayHour: this._getCurrentViewOption("endDayHour"),
      viewOffset: this.getViewOffsetMs(),
      appointmentDuration: this._getCurrentViewOption("cellDuration"),
      allDayPanelMode: this._getCurrentViewOption("allDayPanelMode"),
      showAllDayPanel: this.option("showAllDayPanel"),
      getLoadedResources: () => this.option("loadedResources"),
      getIsVirtualScrolling: () => this.isVirtualScrolling(),
      getSupportAllDayRow: () => this._workSpace.supportAllDayRow(),
      getViewType: () => this._workSpace.type,
      getViewDirection: () => this._workSpace.viewDirection,
      getDateRange: () => this._workSpace.getDateRange(),
      getGroupCount: () => this._workSpace._getGroupCount(),
      getViewDataProvider: () => this._workSpace.viewDataProvider
    });
  }
  updateInstances() {
    this._timeZoneCalculator = null;
    if (this.getWorkSpace()) {
      this.createAppointmentDataProvider();
    }
  }
  _customizeDataSourceLoadOptions() {
    var _this$_dataSource;
    null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource || _this$_dataSource.on("customizeStoreLoadOptions", (_ref) => {
      let {
        storeLoadOptions
      } = _ref;
      storeLoadOptions.startDate = this.getStartViewDate();
      storeLoadOptions.endDate = this.getEndViewDate();
    });
  }
  _initTemplates() {
    this._initAppointmentTemplate();
    this._templateManager.addDefaultTemplates({
      appointmentTooltip: new EmptyTemplate(),
      dropDownAppointment: new EmptyTemplate()
    });
    super._initTemplates();
  }
  _initAppointmentTemplate() {
    const {
      expr
    } = this._dataAccessors;
    const createGetter = (property) => compileGetter(`appointmentData.${property}`);
    const getDate = (getter) => (data2) => {
      const value2 = getter(data2);
      if (value2 instanceof Date) {
        return value2.valueOf();
      }
      return value2;
    };
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data2, model) => this.getAppointmentsInstance()._renderAppointmentTemplate($container, data2, model), ["html", "text", "startDate", "endDate", "allDay", "description", "recurrenceRule", "recurrenceException", "startDateTimeZone", "endDateTimeZone"], this.option("integrationOptions.watchMethod"), {
        text: createGetter(expr.textExpr),
        startDate: getDate(createGetter(expr.startDateExpr)),
        endDate: getDate(createGetter(expr.endDateExpr)),
        startDateTimeZone: createGetter(expr.startDateTimeZoneExpr),
        endDateTimeZone: createGetter(expr.endDateTimeZoneExpr),
        allDay: createGetter(expr.allDayExpr),
        recurrenceRule: createGetter(expr.recurrenceRuleExpr)
      })
    });
  }
  _renderContent() {
    this._renderContentImpl();
  }
  _updatePreparedItems(items) {
    this.preparedItems = getPreparedDataItems(items, this._dataAccessors, this._getCurrentViewOption("cellDuration"), this.timeZoneCalculator);
  }
  _dataSourceChangedHandler(result) {
    if (this._readyToRenderAppointments) {
      this._workSpaceRecalculation.done(() => {
        this._updatePreparedItems(result);
        this._renderAppointments();
        this.getWorkSpace().onDataSourceChanged(this.filteredItems);
      });
    }
  }
  isVirtualScrolling() {
    var _currentViewOptions$s;
    const workspace = this.getWorkSpace();
    if (workspace) {
      return workspace.isVirtualScrolling();
    }
    const currentViewOptions = this._getCurrentViewOptions();
    const scrolling = this.option("scrolling");
    return "virtual" === (null === scrolling || void 0 === scrolling ? void 0 : scrolling.mode) || "virtual" === (null === currentViewOptions || void 0 === currentViewOptions || null === (_currentViewOptions$s = currentViewOptions.scrolling) || void 0 === _currentViewOptions$s ? void 0 : _currentViewOptions$s.mode);
  }
  _filterAppointments() {
    this.filteredItems = this.appointmentDataProvider.filter(this.preparedItems);
  }
  _renderAppointments() {
    const workspace = this.getWorkSpace();
    this._filterAppointments();
    workspace.option("allDayExpanded", this._isAllDayExpanded());
    let viewModel = [];
    if (this._isVisible()) {
      viewModel = this._getAppointmentsToRepaint();
    }
    this._appointments.option("items", viewModel);
    this.appointmentDataProvider.cleanState();
  }
  _getAppointmentsToRepaint() {
    const layoutManager = this.getLayoutManager();
    const appointmentsMap = layoutManager.createAppointmentsMap(this.filteredItems);
    return layoutManager.getRepaintedAppointments(appointmentsMap, this.getAppointmentsInstance().option("items"));
  }
  _initExpressions(fields) {
    this._dataAccessors = utils2.dataAccessors.create(fields, this._dataAccessors, config_default().forceIsoDateParsing, this.option("dateSerializationFormat"));
    this._dataAccessors.resources = createExpressions(this.option("resources"));
  }
  _updateExpression(name2, value2) {
    const exprObj = {};
    exprObj[name2.replace("Expr", "")] = value2;
    this._initExpressions(exprObj);
  }
  getResourceDataAccessors() {
    return this._dataAccessors.resources;
  }
  _initEditing() {
    const editing = this.option("editing");
    this._editing = {
      allowAdding: !!editing,
      allowUpdating: !!editing,
      allowDeleting: !!editing,
      allowResizing: !!editing,
      allowDragging: !!editing
    };
    if (isObject(editing)) {
      this._editing = extend(this._editing, editing);
    }
    this._editing.allowDragging = this._editing.allowDragging && this._editing.allowUpdating;
    this._editing.allowResizing = this._editing.allowResizing && this._editing.allowUpdating;
    this.$element().toggleClass(WIDGET_READONLY_CLASS, this._isReadOnly());
  }
  _isReadOnly() {
    let result = true;
    const editing = this._editing;
    for (const prop in editing) {
      if (Object.prototype.hasOwnProperty.call(editing, prop)) {
        result = result && !editing[prop];
      }
    }
    return result;
  }
  _dispose() {
    var _this$_recurrenceDial;
    this._appointmentTooltip && this._appointmentTooltip.dispose();
    null === (_this$_recurrenceDial = this._recurrenceDialog) || void 0 === _this$_recurrenceDial || _this$_recurrenceDial.hide(RECURRENCE_EDITING_MODE.CANCEL);
    this.hideAppointmentPopup();
    this.hideAppointmentTooltip();
    this._asyncTemplatesTimers.forEach(clearTimeout);
    this._asyncTemplatesTimers = [];
    super._dispose();
  }
  _initActions() {
    this._actions = {
      onAppointmentAdding: this._createActionByOption(StoreEventNames.ADDING),
      onAppointmentAdded: this._createActionByOption(StoreEventNames.ADDED),
      onAppointmentUpdating: this._createActionByOption(StoreEventNames.UPDATING),
      onAppointmentUpdated: this._createActionByOption(StoreEventNames.UPDATED),
      onAppointmentDeleting: this._createActionByOption(StoreEventNames.DELETING),
      onAppointmentDeleted: this._createActionByOption(StoreEventNames.DELETED),
      onAppointmentFormOpening: this._createActionByOption("onAppointmentFormOpening"),
      onAppointmentTooltipShowing: this._createActionByOption("onAppointmentTooltipShowing")
    };
  }
  _getAppointmentRenderedAction() {
    return this._createActionByOption("onAppointmentRendered", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _renderFocusTarget() {
    return noop();
  }
  _initMarkup() {
    super._initMarkup();
    this._renderMainContainer();
    this._renderHeader();
    this._layoutManager = new m_appointments_layout_manager_default(this);
    this._appointments = this._createComponent("<div>", m_appointment_collection_default, this._appointmentsConfig());
    this._appointments.option("itemTemplate", this._getAppointmentTemplate("appointmentTemplate"));
    this._appointmentTooltip = new (this.option("adaptivityEnabled") ? MobileTooltipStrategy : DesktopTooltipStrategy)(this._getAppointmentTooltipOptions());
    this._createAppointmentPopupForm();
    if (this._isDataSourceLoaded() || this._isDataSourceLoading()) {
      this._initMarkupCore(this.option("loadedResources"));
      this._dataSourceChangedHandler(this._dataSource.items());
      this._fireContentReadyAction();
    } else {
      const groups = this._getCurrentViewOption("groups");
      loadResources(groups, this.option("resources"), this.option("resourceLoaderMap")).done((resources) => {
        this.option("loadedResources", resources);
        this._initMarkupCore(resources);
        this._reloadDataSource();
      });
    }
  }
  _createAppointmentPopupForm() {
    var _this$_appointmentPop;
    if (this._appointmentForm) {
      var _this$_appointmentFor;
      null === (_this$_appointmentFor = this._appointmentForm.form) || void 0 === _this$_appointmentFor || _this$_appointmentFor.dispose();
    }
    this._appointmentForm = this.createAppointmentForm();
    null === (_this$_appointmentPop = this._appointmentPopup) || void 0 === _this$_appointmentPop || _this$_appointmentPop.dispose();
    this._appointmentPopup = this.createAppointmentPopup(this._appointmentForm);
  }
  _renderMainContainer() {
    this._mainContainer = renderer_default("<div>").addClass("dx-scheduler-container");
    this.$element().append(this._mainContainer);
  }
  createAppointmentForm() {
    const scheduler = {
      createResourceEditorModel: () => createResourceEditorModel(this.option("resources"), this.option("loadedResources")),
      getDataAccessors: () => this._dataAccessors,
      createComponent: (element, component, options) => this._createComponent(element, component, options),
      getEditingConfig: () => this._editing,
      getFirstDayOfWeek: () => this.option("firstDayOfWeek"),
      getStartDayHour: () => this.option("startDayHour"),
      getCalculatedEndDate: (startDateWithStartHour) => this._workSpace.calculateEndDate(startDateWithStartHour),
      getTimeZoneCalculator: () => this.timeZoneCalculator
    };
    return new AppointmentForm(scheduler);
  }
  createAppointmentPopup(form) {
    const scheduler = {
      getElement: () => this.$element(),
      createComponent: (element, component, options) => this._createComponent(element, component, options),
      focus: () => this.focus(),
      getResources: () => this.option("resources"),
      getEditingConfig: () => this._editing,
      getTimeZoneCalculator: () => this.timeZoneCalculator,
      getDataAccessors: () => this._dataAccessors,
      getAppointmentFormOpening: () => this._actions.onAppointmentFormOpening,
      processActionResult: (arg, canceled) => this._processActionResult(arg, canceled),
      addAppointment: (appointment) => this.addAppointment(appointment),
      updateAppointment: (sourceAppointment, updatedAppointment) => this.updateAppointment(sourceAppointment, updatedAppointment),
      updateScrollPosition: (startDate, resourceItem, inAllDayRow) => {
        this._workSpace.updateScrollPosition(startDate, resourceItem, inAllDayRow);
      }
    };
    return new AppointmentPopup(scheduler, form);
  }
  _getAppointmentTooltipOptions() {
    return {
      createComponent: this._createComponent.bind(this),
      container: this.$element(),
      getScrollableContainer: this.getWorkSpaceScrollableContainer.bind(this),
      addDefaultTemplates: this._templateManager.addDefaultTemplates.bind(this._templateManager),
      getAppointmentTemplate: this._getAppointmentTemplate.bind(this),
      showAppointmentPopup: this.showAppointmentPopup.bind(this),
      checkAndDeleteAppointment: this.checkAndDeleteAppointment.bind(this),
      isAppointmentInAllDayPanel: this.isAppointmentInAllDayPanel.bind(this),
      createFormattedDateText: (appointment, targetedAppointment, format) => this.fire("getTextAndFormatDate", appointment, targetedAppointment, format),
      getAppointmentDisabled: (appointment) => createAppointmentAdapter(appointment, this._dataAccessors, this.timeZoneCalculator).disabled,
      onItemContextMenu: this._createActionByOption("onAppointmentContextMenu"),
      createEventArgs: this._createEventArgs.bind(this)
    };
  }
  _createEventArgs(e) {
    const config = {
      itemData: e.itemData.appointment,
      itemElement: e.itemElement,
      targetedAppointment: e.itemData.targetedAppointment
    };
    return extend({}, this.fire("mapAppointmentFields", config), {
      component: e.component,
      element: e.element,
      event: e.event,
      model: e.model
    });
  }
  checkAndDeleteAppointment(appointment, targetedAppointment) {
    const targetedAdapter = createAppointmentAdapter(targetedAppointment, this._dataAccessors, this.timeZoneCalculator);
    const deletingOptions = this.fireOnAppointmentDeleting(appointment, targetedAdapter);
    this._checkRecurringAppointment(appointment, targetedAppointment, targetedAdapter.startDate, () => {
      this.processDeleteAppointment(appointment, deletingOptions);
    }, true);
  }
  _getExtraAppointmentTooltipOptions() {
    return {
      rtlEnabled: this.option("rtlEnabled"),
      focusStateEnabled: this.option("focusStateEnabled"),
      editing: this.option("editing"),
      offset: this.option("_appointmentTooltipOffset")
    };
  }
  isAppointmentInAllDayPanel(appointmentData) {
    const workSpace = this._workSpace;
    const itTakesAllDay = this.appointmentTakesAllDay(appointmentData);
    return itTakesAllDay && workSpace.supportAllDayRow() && workSpace.option("showAllDayPanel");
  }
  _initMarkupCore(resources) {
    this._readyToRenderAppointments = hasWindow();
    this._workSpace && this._cleanWorkspace();
    this._renderWorkSpace(resources);
    this._appointments.option({
      fixedContainer: this._workSpace.getFixedContainer(),
      allDayContainer: this._workSpace.getAllDayContainer()
    });
    this._waitAsyncTemplate(() => {
      var _this$_workSpaceRecal2;
      return null === (_this$_workSpaceRecal2 = this._workSpaceRecalculation) || void 0 === _this$_workSpaceRecal2 ? void 0 : _this$_workSpaceRecal2.resolve();
    });
    this.createAppointmentDataProvider();
    this._filterAppointmentsByDate();
    this._validateKeyFieldIfAgendaExist();
  }
  _isDataSourceLoaded() {
    return this._dataSource && this._dataSource.isLoaded();
  }
  _render() {
    var _this$getWorkSpace;
    this._toggleSmallClass();
    this._toggleAdaptiveClass();
    null === (_this$getWorkSpace = this.getWorkSpace()) || void 0 === _this$getWorkSpace || _this$getWorkSpace.updateHeaderEmptyCellWidth();
    super._render();
  }
  _renderHeader() {
    if (0 !== this.option("toolbar").length) {
      const $header = renderer_default("<div>").appendTo(this._mainContainer);
      this._header = this._createComponent($header, SchedulerHeader, this._headerConfig());
    }
  }
  _headerConfig() {
    const currentViewOptions = this._getCurrentViewOptions();
    const countConfig = this._getViewCountConfig();
    const result = extend({
      firstDayOfWeek: this.getFirstDayOfWeek(),
      currentView: this.option("currentView"),
      isAdaptive: this.option("adaptivityEnabled"),
      tabIndex: this.option("tabIndex"),
      focusStateEnabled: this.option("focusStateEnabled"),
      rtlEnabled: this.option("rtlEnabled"),
      useDropDownViewSwitcher: this.option("useDropDownViewSwitcher"),
      customizeDateNavigatorText: this.option("customizeDateNavigatorText"),
      agendaDuration: currentViewOptions.agendaDuration || 7
    }, currentViewOptions);
    result.intervalCount = countConfig.intervalCount;
    result.views = this.option("views");
    result.min = new Date(this._dateOption("min"));
    result.max = new Date(this._dateOption("max"));
    result.currentDate = date_default2.trimTime(new Date(this._dateOption("currentDate")));
    result.onCurrentViewChange = (name2) => {
      this.option("currentView", name2);
    };
    result.onCurrentDateChange = (date) => {
      this.option("currentDate", date);
    };
    result.items = this.option("toolbar");
    result.startViewDate = this.getStartViewDate();
    result.todayDate = () => {
      const result2 = this.timeZoneCalculator.createDate(/* @__PURE__ */ new Date(), {
        path: "toGrid"
      });
      return result2;
    };
    return result;
  }
  _appointmentsConfig() {
    const config = {
      getResources: () => this.option("resources"),
      getResourceDataAccessors: this.getResourceDataAccessors.bind(this),
      getAgendaResourceProcessor: () => this.agendaResourceProcessor,
      getAppointmentColor: this.createGetAppointmentColor(),
      getAppointmentDataProvider: () => this.appointmentDataProvider,
      dataAccessors: this._dataAccessors,
      observer: this,
      onItemRendered: this._getAppointmentRenderedAction(),
      onItemClick: this._createActionByOption("onAppointmentClick"),
      onItemContextMenu: this._createActionByOption("onAppointmentContextMenu"),
      onAppointmentDblClick: this._createActionByOption("onAppointmentDblClick"),
      tabIndex: this.option("tabIndex"),
      focusStateEnabled: this.option("focusStateEnabled"),
      allowDrag: this._allowDragging(),
      allowDelete: this._editing.allowUpdating && this._editing.allowDeleting,
      allowResize: this._allowResizing(),
      allowAllDayResize: this._allowAllDayResizing(),
      rtlEnabled: this.option("rtlEnabled"),
      currentView: this.currentView,
      groups: this._getCurrentViewOption("groups"),
      timeZoneCalculator: this.timeZoneCalculator,
      getResizableStep: () => this._workSpace ? this._workSpace.positionHelper.getResizableStep() : 0,
      getDOMElementsMetaData: () => {
        var _this$_workSpace;
        return null === (_this$_workSpace = this._workSpace) || void 0 === _this$_workSpace ? void 0 : _this$_workSpace.getDOMElementsMetaData();
      },
      getViewDataProvider: () => {
        var _this$_workSpace2;
        return null === (_this$_workSpace2 = this._workSpace) || void 0 === _this$_workSpace2 ? void 0 : _this$_workSpace2.viewDataProvider;
      },
      isVerticalViewDirection: () => "vertical" === this.getRenderingStrategyInstance().getDirection(),
      isVerticalGroupedWorkSpace: () => this._workSpace._isVerticalGroupedWorkSpace(),
      isDateAndTimeView: () => isDateAndTimeView(this._workSpace.type),
      onContentReady: () => {
        var _this$_workSpace3;
        null === (_this$_workSpace3 = this._workSpace) || void 0 === _this$_workSpace3 || _this$_workSpace3.option("allDayExpanded", this._isAllDayExpanded());
      }
    };
    return config;
  }
  getCollectorOffset() {
    if (this._workSpace.needApplyCollectorOffset() && !this.option("adaptivityEnabled")) {
      return this.option("_collectorOffset");
    }
    return 0;
  }
  getAppointmentDurationInMinutes() {
    return this._getCurrentViewOption("cellDuration");
  }
  _getCurrentViewType() {
    return this.currentViewType;
  }
  _renderWorkSpace(groups) {
    var _this$_header6;
    this._readyToRenderAppointments && this._toggleSmallClass();
    const $workSpace = renderer_default("<div>").appendTo(this._mainContainer);
    const countConfig = this._getViewCountConfig();
    const workSpaceComponent = VIEWS_CONFIG[this._getCurrentViewType()].workSpace;
    const workSpaceConfig = this._workSpaceConfig(groups, countConfig);
    this._workSpace = this._createComponent($workSpace, workSpaceComponent, workSpaceConfig);
    this._allowDragging() && this._workSpace.initDragBehavior(this, this._all);
    this._workSpace._attachTablesEvents();
    this._workSpace.getWorkArea().append(this._appointments.$element());
    this._recalculateWorkspace();
    countConfig.startDate && (null === (_this$_header6 = this._header) || void 0 === _this$_header6 ? void 0 : _this$_header6.option("currentDate", this._workSpace._getHeaderDate()));
    this._appointments.option("_collectorOffset", this.getCollectorOffset());
  }
  _getViewCountConfig() {
    const currentView = this.option("currentView");
    const view = this._getViewByName(currentView);
    const viewCount = view && view.intervalCount || 1;
    const startDate = view && view.startDate || null;
    return {
      intervalCount: viewCount,
      startDate
    };
  }
  _getViewByName(name2) {
    const views = this.option("views");
    for (let i = 0; i < views.length; i++) {
      if (views[i].name === name2 || views[i].type === name2 || views[i] === name2) {
        return views[i];
      }
    }
  }
  _recalculateWorkspace() {
    this._workSpaceRecalculation = new Deferred();
    this._waitAsyncTemplate(() => {
      triggerResizeEvent(this._workSpace.$element());
      this._workSpace.renderCurrentDateTimeLineAndShader();
    });
  }
  _workSpaceConfig(groups, countConfig) {
    var _currentViewOptions$s2;
    const currentViewOptions = this._getCurrentViewOptions();
    const scrolling = this.option("scrolling");
    const isVirtualScrolling = "virtual" === scrolling.mode || "virtual" === (null === (_currentViewOptions$s2 = currentViewOptions.scrolling) || void 0 === _currentViewOptions$s2 ? void 0 : _currentViewOptions$s2.mode);
    const horizontalVirtualScrollingAllowed = isVirtualScrolling && (!isDefined(scrolling.orientation) || ["horizontal", "both"].filter((item) => {
      var _currentViewOptions$s3;
      return scrolling.orientation === item || (null === (_currentViewOptions$s3 = currentViewOptions.scrolling) || void 0 === _currentViewOptions$s3 ? void 0 : _currentViewOptions$s3.orientation) === item;
    }).length > 0);
    const crossScrollingEnabled = this.option("crossScrollingEnabled") || horizontalVirtualScrollingAllowed || isTimelineView(this.currentViewType);
    const result = extend({
      resources: this.option("resources"),
      loadedResources: this.option("loadedResources"),
      getFilteredItems: () => this.filteredItems,
      getResourceDataAccessors: this.getResourceDataAccessors.bind(this),
      noDataText: this.option("noDataText"),
      firstDayOfWeek: this.option("firstDayOfWeek"),
      startDayHour: this.option("startDayHour"),
      endDayHour: this.option("endDayHour"),
      viewOffset: this.getViewOffsetMs(),
      tabIndex: this.option("tabIndex"),
      accessKey: this.option("accessKey"),
      focusStateEnabled: this.option("focusStateEnabled"),
      cellDuration: this.option("cellDuration"),
      showAllDayPanel: this.option("showAllDayPanel"),
      showCurrentTimeIndicator: this.option("showCurrentTimeIndicator"),
      indicatorTime: this.option("indicatorTime"),
      indicatorUpdateInterval: this.option("indicatorUpdateInterval"),
      shadeUntilCurrentTime: this.option("shadeUntilCurrentTime"),
      allDayExpanded: this._appointments.option("items"),
      crossScrollingEnabled,
      dataCellTemplate: this.option("dataCellTemplate"),
      timeCellTemplate: this.option("timeCellTemplate"),
      resourceCellTemplate: this.option("resourceCellTemplate"),
      dateCellTemplate: this.option("dateCellTemplate"),
      allowMultipleCellSelection: this.option("allowMultipleCellSelection"),
      selectedCellData: this.option("selectedCellData"),
      onSelectionChanged: (args) => {
        this.option("selectedCellData", args.selectedCellData);
      },
      groupByDate: this._getCurrentViewOption("groupByDate"),
      scrolling,
      draggingMode: this.option("_draggingMode"),
      timeZoneCalculator: this.timeZoneCalculator,
      schedulerHeight: this.option("height"),
      schedulerWidth: this.option("width"),
      allDayPanelMode: this.option("allDayPanelMode"),
      onSelectedCellsClick: this.showAddAppointmentPopup.bind(this),
      onRenderAppointments: this._renderAppointments.bind(this),
      onShowAllDayPanel: (value2) => this.option("showAllDayPanel", value2),
      getHeaderHeight: () => utils2.DOM.getHeaderHeight(this._header),
      onScrollEnd: () => this._appointments.updateResizableArea(),
      renovateRender: this._isRenovatedRender(isVirtualScrolling)
    }, currentViewOptions);
    result.observer = this;
    result.intervalCount = countConfig.intervalCount;
    result.startDate = countConfig.startDate;
    result.groups = groups;
    result.onCellClick = this._createActionByOption("onCellClick");
    result.onCellContextMenu = this._createActionByOption("onCellContextMenu");
    result.currentDate = date_default2.trimTime(new Date(this._dateOption("currentDate")));
    result.hoursInterval = result.cellDuration / 60;
    result.allDayExpanded = false;
    result.dataCellTemplate = result.dataCellTemplate ? this._getTemplate(result.dataCellTemplate) : null;
    result.timeCellTemplate = result.timeCellTemplate ? this._getTemplate(result.timeCellTemplate) : null;
    result.resourceCellTemplate = result.resourceCellTemplate ? this._getTemplate(result.resourceCellTemplate) : null;
    result.dateCellTemplate = result.dateCellTemplate ? this._getTemplate(result.dateCellTemplate) : null;
    result.getAppointmentDataProvider = () => this.appointmentDataProvider;
    return result;
  }
  _isRenovatedRender(isVirtualScrolling) {
    return this.option("renovateRender") && hasWindow() || isVirtualScrolling;
  }
  _waitAsyncTemplate(callback) {
    if (this._options.silent("templatesRenderAsynchronously")) {
      const timer = setTimeout(() => {
        callback();
        clearTimeout(timer);
      });
      this._asyncTemplatesTimers.push(timer);
    } else {
      callback();
    }
  }
  _getCurrentViewOptions() {
    return this.currentView;
  }
  _getCurrentViewOption(optionName) {
    if (this.currentView && void 0 !== this.currentView[optionName]) {
      return this.currentView[optionName];
    }
    return this.option(optionName);
  }
  _getAppointmentTemplate(optionName) {
    const currentViewOptions = this._getCurrentViewOptions();
    if (currentViewOptions && currentViewOptions[optionName]) {
      return this._getTemplate(currentViewOptions[optionName]);
    }
    return this._getTemplateByOption(optionName);
  }
  _updateOption(viewName, optionName, value2) {
    const currentViewOptions = this._getCurrentViewOptions();
    if (!currentViewOptions || !isDefined(currentViewOptions[optionName])) {
      this[`_${viewName}`].option(optionName, value2);
    }
  }
  _refreshWorkSpace(groups) {
    this._cleanWorkspace();
    delete this._workSpace;
    this._renderWorkSpace(groups);
    if (this._readyToRenderAppointments) {
      this._appointments.option({
        fixedContainer: this._workSpace.getFixedContainer(),
        allDayContainer: this._workSpace.getAllDayContainer()
      });
      this._waitAsyncTemplate(() => this._workSpaceRecalculation.resolve());
    }
  }
  _cleanWorkspace() {
    this._appointments.$element().detach();
    this._workSpace._dispose();
    this._workSpace.$element().remove();
    this.option("selectedCellData", []);
  }
  getWorkSpaceScrollable() {
    return this._workSpace.getScrollable();
  }
  getWorkSpaceScrollableContainer() {
    return this._workSpace.getScrollableContainer();
  }
  getWorkSpace() {
    return this._workSpace;
  }
  getHeader() {
    return this._header;
  }
  _cleanPopup() {
    var _this$_appointmentPop2;
    null === (_this$_appointmentPop2 = this._appointmentPopup) || void 0 === _this$_appointmentPop2 || _this$_appointmentPop2.dispose();
  }
  _checkRecurringAppointment(rawAppointment, singleAppointment, exceptionDate, callback, isDeleted, isPopupEditing, dragEvent, recurrenceEditMode) {
    const recurrenceRule = ExpressionUtils.getField(this._dataAccessors, "recurrenceRule", rawAppointment);
    if (!getRecurrenceProcessor().evalRecurrenceRule(recurrenceRule).isValid || !this._editing.allowUpdating) {
      callback();
      return;
    }
    const editMode = recurrenceEditMode || this.option("recurrenceEditMode");
    switch (editMode) {
      case "series":
        callback();
        break;
      case "occurrence":
        this._excludeAppointmentFromSeries(rawAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing, dragEvent);
        break;
      default:
        if (dragEvent) {
          dragEvent.cancel = new Deferred();
        }
        this._showRecurrenceChangeConfirm(isDeleted).done((editingMode) => {
          editingMode === RECURRENCE_EDITING_MODE.SERIES && callback();
          editingMode === RECURRENCE_EDITING_MODE.OCCURENCE && this._excludeAppointmentFromSeries(rawAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing, dragEvent);
        }).fail(() => this._appointments.moveAppointmentBack(dragEvent));
    }
  }
  _excludeAppointmentFromSeries(rawAppointment, newRawAppointment, exceptionDate, isDeleted, isPopupEditing, dragEvent) {
    const appointment = excludeFromRecurrence(rawAppointment, exceptionDate, this._dataAccessors, this._timeZoneCalculator);
    const singleRawAppointment = _extends({}, newRawAppointment);
    delete singleRawAppointment[this._dataAccessors.expr.recurrenceExceptionExpr];
    delete singleRawAppointment[this._dataAccessors.expr.recurrenceRuleExpr];
    const keyPropertyName = this.appointmentDataProvider.keyName;
    delete singleRawAppointment[keyPropertyName];
    const canCreateNewAppointment = !isDeleted && !isPopupEditing;
    if (canCreateNewAppointment) {
      this.addAppointment(singleRawAppointment);
    }
    if (isPopupEditing) {
      this._appointmentPopup.show(singleRawAppointment, {
        isToolbarVisible: true,
        action: ACTION_TO_APPOINTMENT.EXCLUDE_FROM_SERIES,
        excludeInfo: {
          sourceAppointment: rawAppointment,
          updatedAppointment: appointment.source()
        }
      });
      this._editAppointmentData = rawAppointment;
    } else {
      this._updateAppointment(rawAppointment, appointment.source(), () => {
        this._appointments.moveAppointmentBack(dragEvent);
      }, dragEvent);
    }
  }
  _createRecurrenceException(appointment, exceptionDate) {
    const result = [];
    if (appointment.recurrenceException) {
      result.push(appointment.recurrenceException);
    }
    result.push(this._getSerializedDate(exceptionDate, appointment.startDate, appointment.allDay));
    return result.join();
  }
  _getSerializedDate(date, startDate, isAllDay) {
    isAllDay && date.setHours(startDate.getHours(), startDate.getMinutes(), startDate.getSeconds(), startDate.getMilliseconds());
    return date_serialization_default.serializeDate(date, UTC_FULL_DATE_FORMAT2);
  }
  _showRecurrenceChangeConfirm(isDeleted) {
    const title = message_default.format(isDeleted ? "dxScheduler-confirmRecurrenceDeleteTitle" : "dxScheduler-confirmRecurrenceEditTitle");
    const message = message_default.format(isDeleted ? "dxScheduler-confirmRecurrenceDeleteMessage" : "dxScheduler-confirmRecurrenceEditMessage");
    const seriesText = message_default.format(isDeleted ? "dxScheduler-confirmRecurrenceDeleteSeries" : "dxScheduler-confirmRecurrenceEditSeries");
    const occurrenceText = message_default.format(isDeleted ? "dxScheduler-confirmRecurrenceDeleteOccurrence" : "dxScheduler-confirmRecurrenceEditOccurrence");
    this._recurrenceDialog = custom({
      title,
      messageHtml: message,
      showCloseButton: true,
      showTitle: true,
      buttons: [{
        text: seriesText,
        onClick: () => RECURRENCE_EDITING_MODE.SERIES
      }, {
        text: occurrenceText,
        onClick: () => RECURRENCE_EDITING_MODE.OCCURENCE
      }],
      popupOptions: {
        wrapperAttr: {
          class: "dx-dialog"
        }
      }
    });
    return this._recurrenceDialog.show();
  }
  _getUpdatedData(rawAppointment) {
    const viewOffset = this.getViewOffsetMs();
    const getConvertedFromGrid = (date) => {
      if (!date) {
        return;
      }
      const result2 = this.timeZoneCalculator.createDate(date, {
        path: "fromGrid"
      });
      return dateUtilsTs.addOffsets(result2, [-viewOffset]);
    };
    const isValidDate3 = (date) => !isNaN(new Date(date).getTime());
    const targetCell = this.getTargetCellData();
    const appointment = createAppointmentAdapter(rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    const cellStartDate = getConvertedFromGrid(targetCell.startDate);
    const cellEndDate = getConvertedFromGrid(targetCell.endDate);
    let appointmentStartDate = new Date(appointment.startDate);
    appointmentStartDate = dateUtilsTs.addOffsets(appointmentStartDate, [-viewOffset]);
    let appointmentEndDate = new Date(appointment.endDate);
    appointmentEndDate = dateUtilsTs.addOffsets(appointmentEndDate, [-viewOffset]);
    let resultedStartDate = cellStartDate ?? appointmentStartDate;
    if (!isValidDate3(appointmentStartDate)) {
      appointmentStartDate = resultedStartDate;
    }
    if (!isValidDate3(appointmentEndDate)) {
      appointmentEndDate = cellEndDate;
    }
    const duration = appointmentEndDate.getTime() - appointmentStartDate.getTime();
    const isKeepAppointmentHours = this._workSpace.keepOriginalHours() && isValidDate3(appointment.startDate) && isValidDate3(cellStartDate);
    if (isKeepAppointmentHours) {
      const startDate = this.timeZoneCalculator.createDate(appointmentStartDate, {
        path: "toGrid"
      });
      const timeInMs = startDate.getTime() - date_default2.trimTime(startDate).getTime();
      const targetCellStartDate = dateUtilsTs.addOffsets(targetCell.startDate, [-viewOffset]);
      resultedStartDate = new Date(date_default2.trimTime(targetCellStartDate).getTime() + timeInMs);
      resultedStartDate = this.timeZoneCalculator.createDate(resultedStartDate, {
        path: "fromGrid"
      });
    }
    const result = createAppointmentAdapter({}, this._dataAccessors, this.timeZoneCalculator);
    if (void 0 !== targetCell.allDay) {
      result.allDay = targetCell.allDay;
    }
    result.startDate = resultedStartDate;
    let resultedEndDate = new Date(resultedStartDate.getTime() + duration);
    if (this.appointmentTakesAllDay(rawAppointment) && !result.allDay && this._workSpace.supportAllDayRow()) {
      resultedEndDate = this._workSpace.calculateEndDate(resultedStartDate);
    }
    if (appointment.allDay && !this._workSpace.supportAllDayRow() && !this._workSpace.keepOriginalHours()) {
      const dateCopy = new Date(resultedStartDate);
      dateCopy.setHours(0);
      resultedEndDate = new Date(dateCopy.getTime() + duration);
      if (0 !== resultedEndDate.getHours()) {
        resultedEndDate.setHours(this._getCurrentViewOption("endDayHour"));
      }
    }
    result.startDate = dateUtilsTs.addOffsets(result.startDate, [viewOffset]);
    result.endDate = dateUtilsTs.addOffsets(resultedEndDate, [viewOffset]);
    const rawResult = result.source();
    setResourceToAppointment(this.option("resources"), this.getResourceDataAccessors(), rawResult, targetCell.groups);
    return rawResult;
  }
  getTargetedAppointment(appointment, element) {
    const settings = utils2.dataAccessors.getAppointmentSettings(element);
    const info = utils2.dataAccessors.getAppointmentInfo(element);
    const appointmentIndex = renderer_default(element).data(this._appointments._itemIndexKey());
    const adapter = createAppointmentAdapter(appointment, this._dataAccessors, this.timeZoneCalculator);
    const targetedAdapter = adapter.clone();
    if (this._isAgenda() && adapter.isRecurrent) {
      const {
        agendaSettings
      } = settings;
      targetedAdapter.startDate = ExpressionUtils.getField(this._dataAccessors, "startDate", agendaSettings);
      targetedAdapter.endDate = ExpressionUtils.getField(this._dataAccessors, "endDate", agendaSettings);
    } else if (settings) {
      targetedAdapter.startDate = info ? info.sourceAppointment.startDate : adapter.startDate;
      targetedAdapter.endDate = info ? info.sourceAppointment.endDate : adapter.endDate;
    }
    const rawTargetedAppointment = targetedAdapter.source();
    if (element) {
      this.setTargetedAppointmentResources(rawTargetedAppointment, element, appointmentIndex);
    }
    if (info) {
      rawTargetedAppointment.displayStartDate = new Date(info.appointment.startDate);
      rawTargetedAppointment.displayEndDate = new Date(info.appointment.endDate);
    }
    return rawTargetedAppointment;
  }
  subscribe(subject, action) {
    this._subscribes[subject] = m_subscribes_default[subject] = action;
  }
  fire(subject) {
    const callback = this._subscribes[subject];
    const args = Array.prototype.slice.call(arguments);
    if (!isFunction(callback)) {
      throw ui_errors_default.Error("E1031", subject);
    }
    return callback.apply(this, args.slice(1));
  }
  getTargetCellData() {
    return this._workSpace.getDataByDroppableCell();
  }
  _updateAppointment(target, rawAppointment, onUpdatePrevented, dragEvent) {
    const updatingOptions = {
      newData: rawAppointment,
      oldData: extend({}, target),
      cancel: false
    };
    const performFailAction = (function(err) {
      if (onUpdatePrevented) {
        onUpdatePrevented.call(this);
      }
      if (err && "Error" === err.name) {
        throw err;
      }
    }).bind(this);
    this._actions[StoreEventNames.UPDATING](updatingOptions);
    if (dragEvent && !isDeferred(dragEvent.cancel)) {
      dragEvent.cancel = new Deferred();
    }
    return this._processActionResult(updatingOptions, function(canceled) {
      let deferred = new Deferred();
      if (!canceled) {
        this._expandAllDayPanel(rawAppointment);
        try {
          deferred = this.appointmentDataProvider.update(target, rawAppointment).done(() => {
            dragEvent && dragEvent.cancel.resolve(false);
          }).always((storeAppointment) => this._onDataPromiseCompleted(StoreEventNames.UPDATED, storeAppointment)).fail(() => performFailAction());
        } catch (err) {
          performFailAction(err);
          deferred.resolve();
        }
      } else {
        performFailAction();
        deferred.resolve();
      }
      return deferred.promise();
    });
  }
  _processActionResult(actionOptions, callback) {
    const deferred = new Deferred();
    const resolveCallback = (callbackResult) => {
      when(fromPromise(callbackResult)).always(deferred.resolve);
    };
    if (isPromise(actionOptions.cancel)) {
      when(fromPromise(actionOptions.cancel)).always((cancel) => {
        if (!isDefined(cancel)) {
          cancel = "rejected" === actionOptions.cancel.state();
        }
        resolveCallback(callback.call(this, cancel));
      });
    } else {
      resolveCallback(callback.call(this, actionOptions.cancel));
    }
    return deferred.promise();
  }
  _expandAllDayPanel(appointment) {
    if (!this._isAllDayExpanded() && this.appointmentTakesAllDay(appointment)) {
      this._workSpace.option("allDayExpanded", true);
    }
  }
  _onDataPromiseCompleted(handlerName, storeAppointment, appointment) {
    const args = {
      appointmentData: appointment || storeAppointment
    };
    if (storeAppointment instanceof Error) {
      args.error = storeAppointment;
    } else {
      this._appointmentPopup.visible && this._appointmentPopup.hide();
    }
    this._actions[handlerName](args);
    this._fireContentReadyAction();
  }
  getAppointmentsInstance() {
    return this._appointments;
  }
  getLayoutManager() {
    return this._layoutManager;
  }
  getRenderingStrategyInstance() {
    return this.getLayoutManager().getRenderingStrategyInstance();
  }
  getActions() {
    return this._actions;
  }
  appointmentTakesAllDay(rawAppointment) {
    const appointment = createAppointmentAdapter(rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    return getAppointmentTakesAllDay(appointment, this._getCurrentViewOption("allDayPanelMode"));
  }
  dayHasAppointment(day, rawAppointment, trimTime2) {
    const getConvertedToTimeZone = (date) => this.timeZoneCalculator.createDate(date, {
      path: "toGrid"
    });
    const appointment = createAppointmentAdapter(rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    let startDate = new Date(appointment.startDate);
    let endDate = new Date(appointment.endDate);
    startDate = getConvertedToTimeZone(startDate);
    endDate = getConvertedToTimeZone(endDate);
    if (day.getTime() === endDate.getTime()) {
      return startDate.getTime() === endDate.getTime();
    }
    if (trimTime2) {
      day = date_default2.trimTime(day);
      startDate = date_default2.trimTime(startDate);
      endDate = date_default2.trimTime(endDate);
    }
    const dayTimeStamp = day.getTime();
    const startDateTimeStamp = startDate.getTime();
    const endDateTimeStamp = endDate.getTime();
    return startDateTimeStamp <= dayTimeStamp && dayTimeStamp <= endDateTimeStamp;
  }
  setTargetedAppointmentResources(rawAppointment, element, appointmentIndex) {
    const groups = this._getCurrentViewOption("groups");
    if (null !== groups && void 0 !== groups && groups.length) {
      const resourcesSetter = this.getResourceDataAccessors().setter;
      const workSpace = this._workSpace;
      let getGroups;
      let setResourceCallback;
      if (this._isAgenda()) {
        getGroups = function() {
          const apptSettings = this.getLayoutManager()._positionMap[appointmentIndex];
          return getCellGroups(apptSettings[0].groupIndex, this.getWorkSpace().option("groups"));
        };
        setResourceCallback = function(_, group) {
          resourcesSetter[group.name](rawAppointment, group.id);
        };
      } else {
        getGroups = function() {
          const setting = utils2.dataAccessors.getAppointmentSettings(element) || {};
          return workSpace.getCellDataByCoordinates({
            left: setting.left,
            top: setting.top
          }).groups;
        };
        setResourceCallback = function(field, value2) {
          resourcesSetter[field](rawAppointment, value2);
        };
      }
      each(getGroups.call(this), setResourceCallback);
    }
  }
  getStartViewDate() {
    var _this$_workSpace4;
    return null === (_this$_workSpace4 = this._workSpace) || void 0 === _this$_workSpace4 ? void 0 : _this$_workSpace4.getStartViewDate();
  }
  getEndViewDate() {
    return this._workSpace.getEndViewDate();
  }
  showAddAppointmentPopup(cellData, cellGroups) {
    const appointmentAdapter = createAppointmentAdapter({}, this._dataAccessors, this.timeZoneCalculator);
    appointmentAdapter.allDay = cellData.allDay;
    appointmentAdapter.startDate = this.timeZoneCalculator.createDate(cellData.startDate, {
      path: "fromGrid"
    });
    appointmentAdapter.endDate = this.timeZoneCalculator.createDate(cellData.endDate, {
      path: "fromGrid"
    });
    const resultAppointment = extend(appointmentAdapter.source(), cellGroups);
    this.showAppointmentPopup(resultAppointment, true);
  }
  showAppointmentPopup(rawAppointment, createNewAppointment, rawTargetedAppointment) {
    const newRawTargetedAppointment = _extends({}, rawTargetedAppointment);
    if (newRawTargetedAppointment) {
      delete newRawTargetedAppointment.displayStartDate;
      delete newRawTargetedAppointment.displayEndDate;
    }
    const appointment = createAppointmentAdapter(newRawTargetedAppointment || rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    const newTargetedAppointment = extend({}, rawAppointment, newRawTargetedAppointment);
    const isCreateAppointment = createNewAppointment ?? isEmptyObject(rawAppointment);
    if (isEmptyObject(rawAppointment)) {
      rawAppointment = this.createPopupAppointment();
    }
    if (isCreateAppointment) {
      delete this._editAppointmentData;
      this._editing.allowAdding && this._appointmentPopup.show(rawAppointment, {
        isToolbarVisible: true,
        action: ACTION_TO_APPOINTMENT.CREATE
      });
    } else {
      this._checkRecurringAppointment(rawAppointment, newTargetedAppointment, appointment.startDate, () => {
        this._editAppointmentData = rawAppointment;
        this._appointmentPopup.show(rawAppointment, {
          isToolbarVisible: this._editing.allowUpdating,
          action: ACTION_TO_APPOINTMENT.UPDATE
        });
      }, false, true);
    }
  }
  createPopupAppointment() {
    const result = {};
    const toMs27 = date_default2.dateToMilliseconds;
    const startDate = new Date(this.option("currentDate"));
    const endDate = new Date(startDate.getTime() + this.option("cellDuration") * toMs27("minute"));
    ExpressionUtils.setField(this._dataAccessors, "startDate", result, startDate);
    ExpressionUtils.setField(this._dataAccessors, "endDate", result, endDate);
    return result;
  }
  hideAppointmentPopup(saveChanges) {
    var _this$_appointmentPop3;
    if (null !== (_this$_appointmentPop3 = this._appointmentPopup) && void 0 !== _this$_appointmentPop3 && _this$_appointmentPop3.visible) {
      saveChanges && this._appointmentPopup.saveChangesAsync();
      this._appointmentPopup.hide();
    }
  }
  showAppointmentTooltip(appointment, element, targetedAppointment) {
    if (appointment) {
      const settings = utils2.dataAccessors.getAppointmentSettings(element);
      const appointmentConfig = {
        itemData: targetedAppointment || appointment,
        groupIndex: null === settings || void 0 === settings ? void 0 : settings.groupIndex,
        groups: this.option("groups")
      };
      const getAppointmentColor2 = this.createGetAppointmentColor();
      const deferredColor = getAppointmentColor2(appointmentConfig);
      const info = new AppointmentTooltipInfo(appointment, targetedAppointment, deferredColor);
      this.showAppointmentTooltipCore(element, [info]);
    }
  }
  createGetAppointmentColor() {
    return (appointmentConfig) => {
      const resourceConfig = {
        resources: this.option("resources"),
        dataAccessors: this.getResourceDataAccessors(),
        loadedResources: this.option("loadedResources"),
        resourceLoaderMap: this.option("resourceLoaderMap")
      };
      return getAppointmentColor(resourceConfig, appointmentConfig);
    };
  }
  showAppointmentTooltipCore(target, data2, options) {
    const arg = {
      cancel: false,
      appointments: data2.map((item) => {
        const result = {
          appointmentData: item.appointment,
          currentAppointmentData: _extends({}, item.targetedAppointment),
          color: item.color
        };
        if (item.settings.info) {
          const {
            startDate,
            endDate
          } = item.settings.info.appointment;
          result.currentAppointmentData.displayStartDate = startDate;
          result.currentAppointmentData.displayEndDate = endDate;
        }
        return result;
      }),
      targetElement: getPublicElement(target)
    };
    this._createActionByOption("onAppointmentTooltipShowing")(arg);
    if (this._appointmentTooltip.isAlreadyShown(target)) {
      this.hideAppointmentTooltip();
    } else {
      this._processActionResult(arg, (canceled) => {
        !canceled && this._appointmentTooltip.show(target, data2, _extends({}, this._getExtraAppointmentTooltipOptions(), options));
      });
    }
  }
  hideAppointmentTooltip() {
    this._appointmentTooltip && this._appointmentTooltip.hide();
  }
  scrollToTime(hours, minutes, date) {
    ui_errors_default.log("W0002", "dxScheduler", "scrollToTime", "21.1", 'Use the "scrollTo" method instead');
    this._workSpace.scrollToTime(hours, minutes, date);
  }
  scrollTo(date, groups, allDay) {
    this._workSpace.scrollTo(date, groups, allDay);
  }
  _isHorizontalVirtualScrolling() {
    const scrolling = this.option("scrolling");
    const {
      orientation,
      mode
    } = scrolling;
    const isVirtualScrolling = "virtual" === mode;
    return isVirtualScrolling && ("horizontal" === orientation || "both" === orientation);
  }
  addAppointment(rawAppointment) {
    const appointment = createAppointmentAdapter(rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    appointment.text = appointment.text || "";
    const serializedAppointment = appointment.source(true);
    const addingOptions = {
      appointmentData: serializedAppointment,
      cancel: false
    };
    this._actions[StoreEventNames.ADDING](addingOptions);
    return this._processActionResult(addingOptions, (canceled) => {
      if (canceled) {
        return new Deferred().resolve();
      }
      this._expandAllDayPanel(serializedAppointment);
      return this.appointmentDataProvider.add(serializedAppointment).always((storeAppointment) => this._onDataPromiseCompleted(StoreEventNames.ADDED, storeAppointment));
    });
  }
  updateAppointment(target, appointment) {
    return this._updateAppointment(target, appointment);
  }
  deleteAppointment(rawAppointment) {
    const deletingOptions = this.fireOnAppointmentDeleting(rawAppointment);
    this.processDeleteAppointment(rawAppointment, deletingOptions);
  }
  fireOnAppointmentDeleting(rawAppointment, targetedAppointmentData) {
    const deletingOptions = {
      appointmentData: rawAppointment,
      targetedAppointmentData,
      cancel: false
    };
    this._actions[StoreEventNames.DELETING](deletingOptions);
    return deletingOptions;
  }
  processDeleteAppointment(rawAppointment, deletingOptions) {
    this._processActionResult(deletingOptions, function(canceled) {
      if (!canceled) {
        this.appointmentDataProvider.remove(rawAppointment).always((storeAppointment) => this._onDataPromiseCompleted(StoreEventNames.DELETED, storeAppointment, rawAppointment));
      }
    });
  }
  deleteRecurrence(appointment, date, recurrenceEditMode) {
    this._checkRecurringAppointment(appointment, {}, date, () => {
      this.processDeleteAppointment(appointment, {
        cancel: false
      });
    }, true, false, null, recurrenceEditMode);
  }
  focus() {
    if (this._editAppointmentData) {
      this._appointments.focus();
    } else {
      this._workSpace.focus();
    }
  }
  getFirstDayOfWeek() {
    return isDefined(this.option("firstDayOfWeek")) ? this.option("firstDayOfWeek") : date_default.firstDayOfWeekIndex();
  }
  _validateKeyFieldIfAgendaExist() {
    if (!this.appointmentDataProvider.isDataSourceInit) {
      return;
    }
    const hasAgendaView = !!this._getViewByName("agenda");
    const isKeyExist = !!this.appointmentDataProvider.keyName;
    if (hasAgendaView && !isKeyExist) {
      ui_errors_default.log("W1023");
    }
  }
  _getDragBehavior() {
    return this._workSpace.dragBehavior;
  }
  getViewOffsetMs() {
    const offsetFromOptions = this._getCurrentViewOption("offset");
    return this.normalizeViewOffsetValue(offsetFromOptions);
  }
  normalizeViewOffsetValue(viewOffset) {
    if (!isDefined(viewOffset) || this.currentViewType === VIEWS.AGENDA) {
      return 0;
    }
    return viewOffset * toMs26("minute");
  }
  validateOptions() {
    const currentViewOptions = _extends({}, this.option(), {
      startDayHour: this._getCurrentViewOption("startDayHour"),
      endDayHour: this._getCurrentViewOption("endDayHour"),
      offset: this._getCurrentViewOption("offset"),
      cellDuration: this._getCurrentViewOption("cellDuration")
    });
    const validationResult = this._optionsValidator.validate(currentViewOptions);
    this._optionsValidatorErrorHandler.handleValidationResult(validationResult);
  }
};
Scheduler.include(data_helper_default);
component_registrator_default("dxScheduler", Scheduler);
var m_scheduler_default = Scheduler;

// ../../../../../../node_modules/devextreme/esm/ui/scheduler.js
var scheduler_default = m_scheduler_default;

// ../../../../../../node_modules/devextreme-vue/esm/scheduler.js
var DxScheduler = createComponent({
  props: {
    accessKey: String,
    adaptivityEnabled: Boolean,
    allDayExpr: String,
    allDayPanelMode: String,
    appointmentCollectorTemplate: {},
    appointmentDragging: Object,
    appointmentTemplate: {},
    appointmentTooltipTemplate: {},
    cellDuration: Number,
    crossScrollingEnabled: Boolean,
    currentDate: [Date, Number, String],
    currentView: String,
    customizeDateNavigatorText: Function,
    dataCellTemplate: {},
    dataSource: {},
    dateCellTemplate: {},
    dateSerializationFormat: String,
    descriptionExpr: String,
    disabled: Boolean,
    dropDownAppointmentTemplate: {},
    editing: [Boolean, Object],
    elementAttr: Object,
    endDateExpr: String,
    endDateTimeZoneExpr: String,
    endDayHour: Number,
    firstDayOfWeek: {
      type: Number,
      validator: (v) => typeof v !== "number" || [
        0,
        1,
        2,
        3,
        4,
        5,
        6
      ].indexOf(v) !== -1
    },
    focusStateEnabled: Boolean,
    groupByDate: Boolean,
    groups: Array,
    height: [Function, Number, String],
    hint: String,
    indicatorUpdateInterval: Number,
    max: [Date, Number, String],
    maxAppointmentsPerCell: [Number, String],
    min: [Date, Number, String],
    noDataText: String,
    offset: Number,
    onAppointmentAdded: Function,
    onAppointmentAdding: Function,
    onAppointmentClick: Function,
    onAppointmentContextMenu: Function,
    onAppointmentDblClick: Function,
    onAppointmentDeleted: Function,
    onAppointmentDeleting: Function,
    onAppointmentFormOpening: Function,
    onAppointmentRendered: Function,
    onAppointmentTooltipShowing: Function,
    onAppointmentUpdated: Function,
    onAppointmentUpdating: Function,
    onCellClick: Function,
    onCellContextMenu: Function,
    onContentReady: Function,
    onDisposing: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    recurrenceEditMode: String,
    recurrenceExceptionExpr: String,
    recurrenceRuleExpr: String,
    remoteFiltering: Boolean,
    resourceCellTemplate: {},
    resources: Array,
    rtlEnabled: Boolean,
    scrolling: Object,
    selectedCellData: Array,
    shadeUntilCurrentTime: Boolean,
    showAllDayPanel: Boolean,
    showCurrentTimeIndicator: Boolean,
    startDateExpr: String,
    startDateTimeZoneExpr: String,
    startDayHour: Number,
    tabIndex: Number,
    textExpr: String,
    timeCellTemplate: {},
    timeZone: String,
    useDropDownViewSwitcher: Boolean,
    views: Array,
    visible: Boolean,
    width: [Function, Number, String]
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:adaptivityEnabled": null,
    "update:allDayExpr": null,
    "update:allDayPanelMode": null,
    "update:appointmentCollectorTemplate": null,
    "update:appointmentDragging": null,
    "update:appointmentTemplate": null,
    "update:appointmentTooltipTemplate": null,
    "update:cellDuration": null,
    "update:crossScrollingEnabled": null,
    "update:currentDate": null,
    "update:currentView": null,
    "update:customizeDateNavigatorText": null,
    "update:dataCellTemplate": null,
    "update:dataSource": null,
    "update:dateCellTemplate": null,
    "update:dateSerializationFormat": null,
    "update:descriptionExpr": null,
    "update:disabled": null,
    "update:dropDownAppointmentTemplate": null,
    "update:editing": null,
    "update:elementAttr": null,
    "update:endDateExpr": null,
    "update:endDateTimeZoneExpr": null,
    "update:endDayHour": null,
    "update:firstDayOfWeek": null,
    "update:focusStateEnabled": null,
    "update:groupByDate": null,
    "update:groups": null,
    "update:height": null,
    "update:hint": null,
    "update:indicatorUpdateInterval": null,
    "update:max": null,
    "update:maxAppointmentsPerCell": null,
    "update:min": null,
    "update:noDataText": null,
    "update:offset": null,
    "update:onAppointmentAdded": null,
    "update:onAppointmentAdding": null,
    "update:onAppointmentClick": null,
    "update:onAppointmentContextMenu": null,
    "update:onAppointmentDblClick": null,
    "update:onAppointmentDeleted": null,
    "update:onAppointmentDeleting": null,
    "update:onAppointmentFormOpening": null,
    "update:onAppointmentRendered": null,
    "update:onAppointmentTooltipShowing": null,
    "update:onAppointmentUpdated": null,
    "update:onAppointmentUpdating": null,
    "update:onCellClick": null,
    "update:onCellContextMenu": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:recurrenceEditMode": null,
    "update:recurrenceExceptionExpr": null,
    "update:recurrenceRuleExpr": null,
    "update:remoteFiltering": null,
    "update:resourceCellTemplate": null,
    "update:resources": null,
    "update:rtlEnabled": null,
    "update:scrolling": null,
    "update:selectedCellData": null,
    "update:shadeUntilCurrentTime": null,
    "update:showAllDayPanel": null,
    "update:showCurrentTimeIndicator": null,
    "update:startDateExpr": null,
    "update:startDateTimeZoneExpr": null,
    "update:startDayHour": null,
    "update:tabIndex": null,
    "update:textExpr": null,
    "update:timeCellTemplate": null,
    "update:timeZone": null,
    "update:useDropDownViewSwitcher": null,
    "update:views": null,
    "update:visible": null,
    "update:width": null
  },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = scheduler_default;
    this.$_hasAsyncTemplate = false;
    this.$_expectedChildren = {
      appointmentDragging: { isCollectionItem: false, optionName: "appointmentDragging" },
      editing: { isCollectionItem: false, optionName: "editing" },
      resource: { isCollectionItem: true, optionName: "resources" },
      scrolling: { isCollectionItem: false, optionName: "scrolling" },
      view: { isCollectionItem: true, optionName: "views" }
    };
  }
});
var DxAppointmentDragging = createConfigurationComponent({
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:autoScroll": null,
    "update:data": null,
    "update:group": null,
    "update:onAdd": null,
    "update:onDragEnd": null,
    "update:onDragMove": null,
    "update:onDragStart": null,
    "update:onRemove": null,
    "update:scrollSensitivity": null,
    "update:scrollSpeed": null
  },
  props: {
    autoScroll: Boolean,
    data: {},
    group: String,
    onAdd: Function,
    onDragEnd: Function,
    onDragMove: Function,
    onDragStart: Function,
    onRemove: Function,
    scrollSensitivity: Number,
    scrollSpeed: Number
  }
});
DxAppointmentDragging.$_optionName = "appointmentDragging";
var DxEditing = createConfigurationComponent({
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowAdding": null,
    "update:allowDeleting": null,
    "update:allowDragging": null,
    "update:allowResizing": null,
    "update:allowTimeZoneEditing": null,
    "update:allowUpdating": null
  },
  props: {
    allowAdding: Boolean,
    allowDeleting: Boolean,
    allowDragging: Boolean,
    allowResizing: Boolean,
    allowTimeZoneEditing: Boolean,
    allowUpdating: Boolean
  }
});
DxEditing.$_optionName = "editing";
var DxResource = createConfigurationComponent({
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowMultiple": null,
    "update:colorExpr": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:fieldExpr": null,
    "update:label": null,
    "update:useColorAsDefault": null,
    "update:valueExpr": null
  },
  props: {
    allowMultiple: Boolean,
    colorExpr: String,
    dataSource: {},
    displayExpr: [Function, String],
    fieldExpr: String,
    label: String,
    useColorAsDefault: Boolean,
    valueExpr: [Function, String]
  }
});
DxResource.$_optionName = "resources";
DxResource.$_isCollectionItem = true;
var DxScrolling = createConfigurationComponent({
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:mode": null
  },
  props: {
    mode: String
  }
});
DxScrolling.$_optionName = "scrolling";
var DxView = createConfigurationComponent({
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:agendaDuration": null,
    "update:allDayPanelMode": null,
    "update:appointmentCollectorTemplate": null,
    "update:appointmentTemplate": null,
    "update:appointmentTooltipTemplate": null,
    "update:cellDuration": null,
    "update:dataCellTemplate": null,
    "update:dateCellTemplate": null,
    "update:dropDownAppointmentTemplate": null,
    "update:endDayHour": null,
    "update:firstDayOfWeek": null,
    "update:groupByDate": null,
    "update:groupOrientation": null,
    "update:groups": null,
    "update:intervalCount": null,
    "update:maxAppointmentsPerCell": null,
    "update:name": null,
    "update:offset": null,
    "update:resourceCellTemplate": null,
    "update:scrolling": null,
    "update:startDate": null,
    "update:startDayHour": null,
    "update:timeCellTemplate": null,
    "update:type": null
  },
  props: {
    agendaDuration: Number,
    allDayPanelMode: String,
    appointmentCollectorTemplate: {},
    appointmentTemplate: {},
    appointmentTooltipTemplate: {},
    cellDuration: Number,
    dataCellTemplate: {},
    dateCellTemplate: {},
    dropDownAppointmentTemplate: {},
    endDayHour: Number,
    firstDayOfWeek: {
      type: Number,
      validator: (v) => typeof v !== "number" || [
        0,
        1,
        2,
        3,
        4,
        5,
        6
      ].indexOf(v) !== -1
    },
    groupByDate: Boolean,
    groupOrientation: String,
    groups: Array,
    intervalCount: Number,
    maxAppointmentsPerCell: [Number, String],
    name: String,
    offset: Number,
    resourceCellTemplate: {},
    scrolling: Object,
    startDate: [Date, Number, String],
    startDayHour: Number,
    timeCellTemplate: {},
    type: String
  }
});
DxView.$_optionName = "views";
DxView.$_isCollectionItem = true;
DxView.$_expectedChildren = {
  scrolling: { isCollectionItem: false, optionName: "scrolling" }
};
var scheduler_default2 = DxScheduler;
export {
  DxAppointmentDragging,
  DxEditing,
  DxResource,
  DxScheduler,
  DxScrolling,
  DxView,
  scheduler_default2 as default
};
/*! Bundled license information:

devextreme-vue/esm/scheduler.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)
*/
//# sourceMappingURL=devextreme-vue_scheduler.js.map
