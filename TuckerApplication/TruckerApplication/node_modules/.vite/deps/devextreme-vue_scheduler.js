import {
  Comment,
  createApp,
  defineComponent,
  h,
  toRaw,
  version
} from "./chunk-IYPBRSHA.js";
import {
  __export
} from "./chunk-IER6VNQZ.js";

// ../../../../../../node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// ../../../../../../node_modules/devextreme/esm/core/utils/type.js
var types = {
  "[object Array]": "array",
  "[object Date]": "date",
  "[object Object]": "object",
  "[object String]": "string"
};
var type = function(object) {
  if (null === object) {
    return "null";
  }
  const typeOfObject = Object.prototype.toString.call(object);
  return "object" === typeof object ? types[typeOfObject] || "object" : typeof object;
};
var isBoolean = function(object) {
  return "boolean" === typeof object;
};
var isExponential = function(value2) {
  return isNumeric(value2) && -1 !== value2.toString().indexOf("e");
};
var isDate = function(object) {
  return "date" === type(object);
};
var isDefined = function(object) {
  return null !== object && void 0 !== object;
};
var isFunction = function(object) {
  return "function" === typeof object;
};
var isString = function(object) {
  return "string" === typeof object;
};
var isNumeric = function(object) {
  return "number" === typeof object && isFinite(object) || !isNaN(object - parseFloat(object));
};
var isObject = function(object) {
  return "object" === type(object);
};
var isEmptyObject = function(object) {
  let property;
  for (property in object) {
    return false;
  }
  return true;
};
var isPlainObject = function(object) {
  if (!object || "object" !== type(object)) {
    return false;
  }
  const proto = Object.getPrototypeOf(object);
  if (!proto) {
    return true;
  }
  const ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return "function" === typeof ctor && Object.toString.call(ctor) === Object.toString.call(Object);
};
var isPrimitive = function(value2) {
  return -1 === ["object", "array", "function"].indexOf(type(value2));
};
var isWindow = function(object) {
  return null != object && object === object.window;
};
var isRenderer = function(object) {
  return !!object && !!(object.jquery || object.dxRenderer);
};
var isPromise = function(object) {
  return !!object && isFunction(object.then);
};
var isDeferred = function(object) {
  return !!object && isFunction(object.done) && isFunction(object.fail);
};
var isEvent = function(object) {
  return !!(object && object.preventDefault);
};

// ../../../../../../node_modules/devextreme/esm/core/utils/extend.js
var extendFromObject = function(target, source, overrideExistingValues) {
  target = target || {};
  for (const prop in source) {
    if (Object.prototype.hasOwnProperty.call(source, prop)) {
      const value2 = source[prop];
      if (!(prop in target) || overrideExistingValues) {
        target[prop] = value2;
      }
    }
  }
  return target;
};
var extend = function(target) {
  target = target || {};
  let i = 1;
  let deep = false;
  if ("boolean" === typeof target) {
    deep = target;
    target = arguments[1] || {};
    i++;
  }
  for (; i < arguments.length; i++) {
    const source = arguments[i];
    if (null == source) {
      continue;
    }
    for (const key in source) {
      const targetValue = target[key];
      const sourceValue = source[key];
      let sourceValueIsArray = false;
      let clone3;
      if ("__proto__" === key || "constructor" === key || target === sourceValue) {
        continue;
      }
      if (deep && sourceValue && (isPlainObject(sourceValue) || (sourceValueIsArray = Array.isArray(sourceValue)))) {
        if (sourceValueIsArray) {
          clone3 = targetValue && Array.isArray(targetValue) ? targetValue : [];
        } else {
          clone3 = targetValue && isPlainObject(targetValue) ? targetValue : {};
        }
        target[key] = extend(deep, clone3, sourceValue);
      } else if (void 0 !== sourceValue) {
        target[key] = sourceValue;
      }
    }
  }
  return target;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/iterator.js
var map = (values, callback) => {
  if (Array.isArray(values)) {
    return values.map(callback);
  }
  const result2 = [];
  for (const key in values) {
    result2.push(callback(values[key], key));
  }
  return result2;
};
var each = (values, callback) => {
  if (!values) {
    return;
  }
  if ("length" in values) {
    for (let i = 0; i < values.length; i++) {
      if (false === callback.call(values[i], i, values[i])) {
        break;
      }
    }
  } else {
    for (const key in values) {
      if (false === callback.call(values[key], key, values[key])) {
        break;
      }
    }
  }
  return values;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/console.js
var noop = function() {
};
var getConsoleMethod = function(method) {
  if ("undefined" === typeof console || !isFunction(console[method])) {
    return noop;
  }
  return console[method].bind(console);
};
var logger = {
  log: getConsoleMethod("log"),
  info: getConsoleMethod("info"),
  warn: getConsoleMethod("warn"),
  error: getConsoleMethod("error")
};
var debug = function() {
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  return {
    assert,
    assertParam: function(parameter, message) {
      assert(null !== parameter && void 0 !== parameter, message);
    }
  };
}();

// ../../../../../../node_modules/devextreme/esm/core/utils/string.js
var encodeHtml = function() {
  const encodeRegExp = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
  return function(str) {
    return String(str).replace(encodeRegExp[0], "&amp;").replace(encodeRegExp[1], "&quot;").replace(encodeRegExp[2], "&#39;").replace(encodeRegExp[3], "&lt;").replace(encodeRegExp[4], "&gt;");
  };
}();
var splitQuad = function(raw) {
  switch (typeof raw) {
    case "string":
      return raw.split(/\s+/, 4);
    case "object":
      return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
    case "number":
      return [raw];
    default:
      return raw;
  }
};
var quadToObject = function(raw) {
  const quad = splitQuad(raw);
  let left = parseInt(quad && quad[0], 10);
  let top = parseInt(quad && quad[1], 10);
  let right = parseInt(quad && quad[2], 10);
  let bottom = parseInt(quad && quad[3], 10);
  if (!isFinite(left)) {
    left = 0;
  }
  if (!isFinite(top)) {
    top = left;
  }
  if (!isFinite(right)) {
    right = left;
  }
  if (!isFinite(bottom)) {
    bottom = top;
  }
  return {
    top,
    right,
    bottom,
    left
  };
};
function format(template) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  if (isFunction(template)) {
    return template(...values);
  }
  values.forEach((value2, index2) => {
    if (isString(value2)) {
      value2 = value2.replace(/\$/g, "$$$$");
    }
    const placeholderReg = new RegExp("\\{" + index2 + "\\}", "gm");
    template = template.replace(placeholderReg, value2);
  });
  return template;
}
var isEmpty = function() {
  const SPACE_REGEXP = /\s/g;
  return function(text) {
    return !text || !text.replace(SPACE_REGEXP, "");
  };
}();

// ../../../../../../node_modules/devextreme/esm/core/version.js
var version2 = "24.1.6";
var fullVersion = "24.1.6";

// ../../../../../../node_modules/devextreme/esm/core/utils/error.js
var ERROR_URL = "https://js.devexpress.com/error/" + version2.split(".").slice(0, 2).join("_") + "/";
function error_default(baseErrors, errors2) {
  const exports = {
    ERROR_MESSAGES: extend(errors2, baseErrors),
    Error: function() {
      return function(args) {
        const id = args[0];
        args = args.slice(1);
        const details = formatDetails(id, args);
        const url = getErrorUrl(id);
        const message = formatMessage(id, details);
        return extend(new Error(message), {
          __id: id,
          __details: details,
          url
        });
      }([].slice.call(arguments));
    },
    log: function(id) {
      let method = "log";
      if (/^E\d+$/.test(id)) {
        method = "error";
      } else if (/^W\d+$/.test(id)) {
        method = "warn";
      }
      logger[method]("log" === method ? id : function(args) {
        const id2 = args[0];
        args = args.slice(1);
        return formatMessage(id2, formatDetails(id2, args));
      }([].slice.call(arguments)));
    }
  };
  function formatDetails(id, args) {
    args = [exports.ERROR_MESSAGES[id]].concat(args);
    return format.apply(this, args).replace(/\.*\s*?$/, "");
  }
  function formatMessage(id, details) {
    const kind = null !== id && void 0 !== id && id.startsWith("W") ? "warning" : "error";
    return format.apply(this, ["{0} - {1}.\n\nFor additional information on this {2} message, see: {3}", id, details, kind, getErrorUrl(id)]);
  }
  function getErrorUrl(id) {
    return ERROR_URL + id;
  }
  return exports;
}

// ../../../../../../node_modules/devextreme/esm/core/errors.js
var errors_default = error_default({
  E0001: "Method is not implemented",
  E0002: "Member name collision: {0}",
  E0003: "A class must be instantiated using the 'new' keyword",
  E0004: "The NAME property of the component is not specified",
  E0005: "Unknown device",
  E0006: "Unknown endpoint key is requested",
  E0007: "'Invalidate' method is called outside the update transaction",
  E0008: "Type of the option name is not appropriate to create an action",
  E0009: "Component '{0}' has not been initialized for an element",
  E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
  E0011: "Unknown animation type '{0}'",
  E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
  E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
  E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
  E0015: "Queued task returned an unexpected result",
  E0017: "Event namespace is not defined",
  E0018: "DevExpress.ui.DevExpressPopup widget is required",
  E0020: "Template engine '{0}' is not supported",
  E0021: "Unknown theme is set: {0}",
  E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
  E0023: "Template name is not specified",
  E0024: "DevExtreme bundle already included",
  E0025: "Unexpected argument type",
  E0100: "Unknown validation type is detected",
  E0101: "Misconfigured range validation rule is detected",
  E0102: "Misconfigured comparison validation rule is detected",
  E0103: "validationCallback of an asynchronous rule should return a jQuery or a native promise",
  E0110: "Unknown validation group is detected",
  E0120: "Adapter for a DevExpressValidator component cannot be configured",
  E0121: "The 'customItem' parameter of the 'onCustomItemCreating' function is empty or contains invalid data. Assign a custom object or a Promise that is resolved after the item is created.",
  W0000: "'{0}' is deprecated in {1}. {2}",
  W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
  W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
  W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
  W0004: "Timeout for theme loading is over: {0}",
  W0005: "'{0}' event is deprecated in {1}. {2}",
  W0006: "Invalid recurrence rule: '{0}'",
  W0007: "'{0}' Globalize culture is not defined",
  W0008: "Invalid view name: '{0}'",
  W0009: "Invalid time zone name: '{0}'",
  W0010: "{0} is deprecated in {1}. {2}",
  W0011: "Number parsing is invoked while the parser is not defined",
  W0012: "Date parsing is invoked while the parser is not defined",
  W0013: "'{0}' file is deprecated in {1}. {2}",
  W0014: "{0} - '{1}' type is deprecated in {2}. {3}",
  W0015: "Instead of returning a value from the '{0}' function, write it into the '{1}' field of the function's parameter.",
  W0016: 'The "{0}" option does not accept the "{1}" value since v{2}. {3}.',
  W0017: 'Setting the "{0}" property with a function is deprecated since v21.2',
  W0018: 'Setting the "position" property with a function is deprecated since v21.2',
  W0019: "DevExtreme: Unable to Locate a Valid License Key.\n\nIf you are using a 30-day trial version of DevExtreme, you must uninstall all copies of DevExtreme once your 30-day trial period expires. For terms and conditions that govern use of DevExtreme UI components/libraries, please refer to the DevExtreme End User License Agreement: https://js.devexpress.com/EULAs/DevExtremeComplete.\n\nTo use DevExtreme in a commercial project, you must purchase a license. For pricing/licensing options, please visit: https://js.devexpress.com/Buy.\n\nIf you have licensing-related questions or need help with a purchase, please email clientservices@devexpress.com.\n\n",
  W0020: "DevExtreme: License Key Has Expired.\n\nA mismatch exists between the license key used and the DevExtreme version referenced in this project.\n\nTo proceed, you can:\n• use a version of DevExtreme linked to your license key: https://www.devexpress.com/ClientCenter/DownloadManager\n• renew your DevExpress Subscription: https://www.devexpress.com/buy/renew (once you renew your subscription, you will be entitled to product updates and support service as defined in the DevExtreme End User License Agreement)\n\nIf you have licensing-related questions or need help with a renewal, please email clientservices@devexpress.com.\n\n",
  W0021: "DevExtreme: License Key Verification Has Failed.\n\nTo verify your DevExtreme license, make certain to specify a correct key in the GlobalConfig. If you continue to encounter this error, please visit https://www.devexpress.com/ClientCenter/DownloadManager to obtain a valid license key.\n\nIf you have a valid license and this problem persists, please submit a support ticket via the DevExpress Support Center. We will be happy to follow-up: https://supportcenter.devexpress.com/ticket/create.\n\n",
  W0022: "DevExtreme: Pre-release software. Not suitable for commercial use.\n\nPre-release software may contain deficiencies and as such, should not be considered for use or integrated in any mission critical application.\n\n",
  W0023: "DevExtreme: the following 'devextreme' package version does not match versions of other DevExpress products used in this application:\n\n{0}\n\nInteroperability between different versions of the products listed herein cannot be guaranteed.\n\n"
});

// ../../../../../../node_modules/devextreme/esm/core/class.js
var wrapOverridden = function(baseProto, methodName, method) {
  return function() {
    const prevCallBase = this.callBase;
    this.callBase = baseProto[methodName];
    try {
      return method.apply(this, arguments);
    } finally {
      this.callBase = prevCallBase;
    }
  };
};
var clonePrototype = function(obj) {
  const func = function() {
  };
  func.prototype = obj.prototype;
  return new func();
};
var redefine = function(members) {
  const that = this;
  let overridden;
  let memberName;
  let member;
  if (!members) {
    return that;
  }
  for (memberName in members) {
    member = members[memberName];
    overridden = "function" === typeof that.prototype[memberName] && "function" === typeof member;
    that.prototype[memberName] = overridden ? wrapOverridden(that.parent.prototype, memberName, member) : member;
  }
  return that;
};
var include = function() {
  const classObj = this;
  let argument;
  let name2;
  let i;
  const hasClassObjOwnProperty = Object.prototype.hasOwnProperty.bind(classObj);
  const isES6Class = !hasClassObjOwnProperty("_includedCtors") && !hasClassObjOwnProperty("_includedPostCtors");
  if (isES6Class) {
    classObj._includedCtors = classObj._includedCtors.slice(0);
    classObj._includedPostCtors = classObj._includedPostCtors.slice(0);
  }
  for (i = 0; i < arguments.length; i++) {
    argument = arguments[i];
    if (argument.ctor) {
      classObj._includedCtors.push(argument.ctor);
    }
    if (argument.postCtor) {
      classObj._includedPostCtors.push(argument.postCtor);
    }
    for (name2 in argument) {
      if ("ctor" === name2 || "postCtor" === name2 || "default" === name2) {
        continue;
      }
      classObj.prototype[name2] = argument[name2];
    }
  }
  return classObj;
};
var subclassOf = function(parentClass) {
  const hasParentProperty = Object.prototype.hasOwnProperty.bind(this)("parent");
  const isES6Class = !hasParentProperty && this.parent;
  if (isES6Class) {
    const baseClass = Object.getPrototypeOf(this);
    return baseClass === parentClass || baseClass.subclassOf(parentClass);
  } else {
    if (this.parent === parentClass) {
      return true;
    }
    if (!this.parent || !this.parent.subclassOf) {
      return false;
    }
    return this.parent.subclassOf(parentClass);
  }
};
var abstract = function() {
  throw errors_default.Error("E0001");
};
var copyStatic = function() {
  const hasOwn = Object.prototype.hasOwnProperty;
  return function(source, destination) {
    for (const key in source) {
      if (!hasOwn.call(source, key)) {
        return;
      }
      destination[key] = source[key];
    }
  };
}();
var classImpl = function() {
};
classImpl.inherit = function(members) {
  const inheritor = function() {
    if (!this || isWindow(this) || "function" !== typeof this.constructor) {
      throw errors_default.Error("E0003");
    }
    const instance = this;
    const ctor = instance.ctor;
    const includedCtors = instance.constructor._includedCtors;
    const includedPostCtors = instance.constructor._includedPostCtors;
    let i;
    for (i = 0; i < includedCtors.length; i++) {
      includedCtors[i].call(instance);
    }
    if (ctor) {
      ctor.apply(instance, arguments);
    }
    for (i = 0; i < includedPostCtors.length; i++) {
      includedPostCtors[i].call(instance);
    }
  };
  inheritor.prototype = clonePrototype(this);
  copyStatic(this, inheritor);
  inheritor.inherit = this.inherit;
  inheritor.abstract = abstract;
  inheritor.redefine = redefine;
  inheritor.include = include;
  inheritor.subclassOf = subclassOf;
  inheritor.parent = this;
  inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
  inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
  inheritor.prototype.constructor = inheritor;
  inheritor.redefine(members);
  return inheritor;
};
classImpl.abstract = abstract;
var class_default = classImpl;

// ../../../../../../node_modules/devextreme/esm/core/utils/dependency_injector.js
function dependency_injector_default(object) {
  const BaseClass = class_default.inherit(object);
  let InjectedClass = BaseClass;
  let instance = new InjectedClass(object);
  const initialFields = {};
  const injectFields = function(injectionObject, initial) {
    each(injectionObject, function(key) {
      if (isFunction(instance[key])) {
        if (initial || !object[key]) {
          object[key] = function() {
            return instance[key].apply(object, arguments);
          };
        }
      } else {
        if (initial) {
          initialFields[key] = object[key];
        }
        object[key] = instance[key];
      }
    });
  };
  injectFields(object, true);
  object.inject = function(injectionObject) {
    InjectedClass = InjectedClass.inherit(injectionObject);
    instance = new InjectedClass();
    injectFields(injectionObject);
  };
  object.resetInjection = function() {
    extend(object, initialFields);
    InjectedClass = BaseClass;
    instance = new BaseClass();
  };
  return object;
}

// ../../../../../../node_modules/devextreme/esm/core/config.js
var config = {
  rtlEnabled: false,
  defaultCurrency: "USD",
  defaultUseCurrencyAccountingStyle: true,
  oDataFilterToLower: true,
  serverDecimalSeparator: ".",
  decimalSeparator: ".",
  thousandsSeparator: ",",
  forceIsoDateParsing: true,
  wrapActionsBeforeExecute: true,
  useLegacyStoreResult: false,
  useJQuery: void 0,
  editorStylingMode: void 0,
  useLegacyVisibleIndex: false,
  floatingActionButtonConfig: {
    icon: "add",
    closeIcon: "close",
    label: "",
    position: {
      at: "right bottom",
      my: "right bottom",
      offset: {
        x: -16,
        y: -16
      }
    },
    maxSpeedDialActionCount: 5,
    shading: false,
    direction: "auto"
  },
  optionsParser: (optionsString) => {
    if ("{" !== optionsString.trim().charAt(0)) {
      optionsString = "{" + optionsString + "}";
    }
    try {
      return JSON.parse(optionsString);
    } catch (ex) {
      try {
        return JSON.parse(normalizeToJSONString(optionsString));
      } catch (exNormalize) {
        throw errors_default.Error("E3018", ex, optionsString);
      }
    }
  }
};
var normalizeToJSONString = (optionsString) => optionsString.replace(/'/g, '"').replace(/,\s*([\]}])/g, "$1").replace(/([{,])\s*([^":\s]+)\s*:/g, '$1"$2":');
var deprecatedFields = ["decimalSeparator", "thousandsSeparator"];
var configMethod = function() {
  if (!arguments.length) {
    return config;
  }
  const newConfig = arguments.length <= 0 ? void 0 : arguments[0];
  deprecatedFields.forEach((deprecatedField) => {
    if (newConfig[deprecatedField]) {
      const message = `Now, the ${deprecatedField} is selected based on the specified locale.`;
      errors_default.log("W0003", "config", deprecatedField, "19.2", message);
    }
  });
  extend(config, newConfig);
};
if ("undefined" !== typeof DevExpress && DevExpress.config) {
  configMethod(DevExpress.config);
}
var config_default = configMethod;

// ../../../../../../node_modules/devextreme/esm/core/guid.js
var Guid = class_default.inherit({
  ctor: function(value2) {
    if (value2) {
      value2 = String(value2);
    }
    this._value = this._normalize(value2 || this._generate());
  },
  _normalize: function(value2) {
    value2 = value2.replace(/[^a-f0-9]/gi, "").toLowerCase();
    while (value2.length < 32) {
      value2 += "0";
    }
    return [value2.substr(0, 8), value2.substr(8, 4), value2.substr(12, 4), value2.substr(16, 4), value2.substr(20, 12)].join("-");
  },
  _generate: function() {
    let value2 = "";
    for (let i = 0; i < 32; i++) {
      value2 += Math.round(15 * Math.random()).toString(16);
    }
    return value2;
  },
  toString: function() {
    return this._value;
  },
  valueOf: function() {
    return this._value;
  },
  toJSON: function() {
    return this._value;
  }
});
var guid_default = Guid;

// ../../../../../../node_modules/devextreme/esm/core/utils/callbacks.js
var Callback = function(options2) {
  this._options = options2 || {};
  this._list = [];
  this._queue = [];
  this._firing = false;
  this._fired = false;
  this._firingIndexes = [];
};
Callback.prototype._fireCore = function(context2, args) {
  const firingIndexes = this._firingIndexes;
  const list = this._list;
  const stopOnFalse = this._options.stopOnFalse;
  const step = firingIndexes.length;
  for (firingIndexes[step] = 0; firingIndexes[step] < list.length; firingIndexes[step]++) {
    const result2 = list[firingIndexes[step]].apply(context2, args);
    if (false === result2 && stopOnFalse) {
      break;
    }
  }
  firingIndexes.pop();
};
Callback.prototype.add = function(fn) {
  if ("function" === typeof fn && (!this._options.unique || !this.has(fn))) {
    this._list.push(fn);
  }
  return this;
};
Callback.prototype.remove = function(fn) {
  const list = this._list;
  const firingIndexes = this._firingIndexes;
  const index2 = list.indexOf(fn);
  if (index2 > -1) {
    list.splice(index2, 1);
    if (this._firing && firingIndexes.length) {
      for (let step = 0; step < firingIndexes.length; step++) {
        if (index2 <= firingIndexes[step]) {
          firingIndexes[step]--;
        }
      }
    }
  }
  return this;
};
Callback.prototype.has = function(fn) {
  const list = this._list;
  return fn ? list.indexOf(fn) > -1 : !!list.length;
};
Callback.prototype.empty = function(fn) {
  this._list = [];
  return this;
};
Callback.prototype.fireWith = function(context2, args) {
  const queue = this._queue;
  args = args || [];
  args = args.slice ? args.slice() : args;
  if (this._options.syncStrategy) {
    this._firing = true;
    this._fireCore(context2, args);
  } else {
    queue.push([context2, args]);
    if (this._firing) {
      return;
    }
    this._firing = true;
    while (queue.length) {
      const memory = queue.shift();
      this._fireCore(memory[0], memory[1]);
    }
  }
  this._firing = false;
  this._fired = true;
  return this;
};
Callback.prototype.fire = function() {
  this.fireWith(this, arguments);
};
Callback.prototype.fired = function() {
  return this._fired;
};
var Callbacks = function(options2) {
  return new Callback(options2);
};
var callbacks_default = Callbacks;

// ../../../../../../node_modules/devextreme/esm/core/utils/deferred.js
var deferredConfig = [{
  method: "resolve",
  handler: "done",
  state: "resolved"
}, {
  method: "reject",
  handler: "fail",
  state: "rejected"
}, {
  method: "notify",
  handler: "progress"
}];
var DeferredObj = function() {
  const that = this;
  this._state = "pending";
  this._promise = {};
  deferredConfig.forEach((function(config3) {
    const methodName = config3.method;
    this[methodName + "Callbacks"] = callbacks_default();
    this[methodName] = (function() {
      return this[methodName + "With"](this._promise, arguments);
    }).bind(this);
    this._promise[config3.handler] = function(handler) {
      if (!handler) {
        return this;
      }
      const callbacks2 = that[methodName + "Callbacks"];
      if (callbacks2.fired()) {
        handler.apply(that[methodName + "Context"], that[methodName + "Args"]);
      } else {
        callbacks2.add((function(context2, args) {
          handler.apply(context2, args);
        }).bind(this));
      }
      return this;
    };
  }).bind(this));
  this._promise.always = function(handler) {
    return this.done(handler).fail(handler);
  };
  this._promise.catch = function(handler) {
    return this.then(null, handler);
  };
  this._promise.then = function(resolve, reject) {
    const result2 = new DeferredObj();
    ["done", "fail"].forEach((function(method) {
      const callback = "done" === method ? resolve : reject;
      this[method](function() {
        if (!callback) {
          result2["done" === method ? "resolve" : "reject"].apply(this, arguments);
          return;
        }
        const callbackResult = callback && callback.apply(this, arguments);
        if (isDeferred(callbackResult)) {
          callbackResult.done(result2.resolve).fail(result2.reject);
        } else if (isPromise(callbackResult)) {
          callbackResult.then(result2.resolve, result2.reject);
        } else {
          result2.resolve.apply(this, isDefined(callbackResult) ? [callbackResult] : arguments);
        }
      });
    }).bind(this));
    return result2.promise();
  };
  this._promise.state = function() {
    return that._state;
  };
  this._promise.promise = function(args) {
    return args ? extend(args, that._promise) : that._promise;
  };
  this._promise.promise(this);
};
deferredConfig.forEach(function(config3) {
  const methodName = config3.method;
  const state = config3.state;
  DeferredObj.prototype[methodName + "With"] = function(context2, args) {
    const callbacks2 = this[methodName + "Callbacks"];
    if ("pending" === this.state()) {
      this[methodName + "Args"] = args;
      this[methodName + "Context"] = context2;
      if (state) {
        this._state = state;
      }
      callbacks2.fire(context2, args);
      if ("pending" !== state) {
        this.resolveCallbacks.empty();
        this.rejectCallbacks.empty();
      }
    }
    return this;
  };
});
function fromPromise(promise, context2) {
  if (isDeferred(promise)) {
    return promise;
  } else if (isPromise(promise)) {
    const d = new DeferredObj();
    promise.then(function() {
      d.resolveWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    }, function() {
      d.rejectWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    });
    return d;
  }
  return new DeferredObj().resolveWith(context2, [promise]);
}
var whenFunc = function() {
  if (1 === arguments.length) {
    return fromPromise(arguments[0]);
  }
  const values = [].slice.call(arguments);
  const contexts = [];
  let resolvedCount = 0;
  const deferred = new DeferredObj();
  const updateState = function(i) {
    return function(value2) {
      contexts[i] = this;
      values[i] = arguments.length > 1 ? [].slice.call(arguments) : value2;
      resolvedCount++;
      if (resolvedCount === values.length) {
        deferred.resolveWith(contexts, values);
      }
    };
  };
  for (let i = 0; i < values.length; i++) {
    if (isDeferred(values[i])) {
      values[i].promise().done(updateState(i)).fail(deferred.reject);
    } else {
      resolvedCount++;
    }
  }
  if (resolvedCount === values.length) {
    deferred.resolveWith(contexts, values);
  }
  return deferred.promise();
};
function Deferred() {
  return new DeferredObj();
}
function when() {
  return whenFunc.apply(this, arguments);
}

// ../../../../../../node_modules/devextreme/esm/core/utils/variable_wrapper.js
var variable_wrapper_default = dependency_injector_default({
  isWrapped: function() {
    return false;
  },
  isWritableWrapped: function() {
    return false;
  },
  wrap: function(value2) {
    return value2;
  },
  unwrap: function(value2) {
    return value2;
  },
  assign: function() {
    logger.error("Method 'assign' should not be used for not wrapped variables. Use 'isWrapped' method for ensuring.");
  }
});

// ../../../../../../node_modules/devextreme/esm/core/utils/object.js
var clone = function() {
  function Clone() {
  }
  return function(obj) {
    Clone.prototype = obj;
    return new Clone();
  };
}();
var orderEach = function(map2, func) {
  const keys = [];
  let key;
  let i;
  for (key in map2) {
    if (Object.prototype.hasOwnProperty.call(map2, key)) {
      keys.push(key);
    }
  }
  keys.sort(function(x, y) {
    const isNumberX = isNumeric(x);
    const isNumberY = isNumeric(y);
    if (isNumberX && isNumberY) {
      return x - y;
    }
    if (isNumberX && !isNumberY) {
      return -1;
    }
    if (!isNumberX && isNumberY) {
      return 1;
    }
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  });
  for (i = 0; i < keys.length; i++) {
    key = keys[i];
    func(key, map2[key]);
  }
};
var assignValueToProperty = function(target, property, value2, assignByReference) {
  if (!assignByReference && variable_wrapper_default.isWrapped(target[property])) {
    variable_wrapper_default.assign(target[property], value2);
  } else {
    target[property] = value2;
  }
};
var deepExtendArraySafe = function(target, changes, extendComplexObject, assignByReference) {
  let prevValue;
  let newValue;
  for (const name2 in changes) {
    prevValue = target[name2];
    newValue = changes[name2];
    if ("__proto__" === name2 || "constructor" === name2 || target === newValue) {
      continue;
    }
    if (isPlainObject(newValue)) {
      const goDeeper = extendComplexObject ? isObject(prevValue) : isPlainObject(prevValue);
      newValue = deepExtendArraySafe(goDeeper ? prevValue : {}, newValue, extendComplexObject, assignByReference);
    }
    if (void 0 !== newValue && prevValue !== newValue) {
      assignValueToProperty(target, name2, newValue, assignByReference);
    }
  }
  return target;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/data.js
var unwrapVariable = variable_wrapper_default.unwrap;
var isWrapped = variable_wrapper_default.isWrapped;
var assign = variable_wrapper_default.assign;
var bracketsToDots = function(expr) {
  return expr.replace(/\[/g, ".").replace(/\]/g, "");
};
var getPathParts = function(name2) {
  return bracketsToDots(name2).split(".");
};
var readPropValue = function(obj, propName, options2) {
  options2 = options2 || {};
  if ("this" === propName) {
    return unwrap(obj, options2);
  }
  return unwrap(obj[propName], options2);
};
var assignPropValue = function(obj, propName, value2, options2) {
  if ("this" === propName) {
    throw new errors_default.Error("E4016");
  }
  const propValue = obj[propName];
  if (options2.unwrapObservables && isWrapped(propValue)) {
    assign(propValue, value2);
  } else {
    obj[propName] = value2;
  }
};
var prepareOptions = function(options2) {
  options2 = options2 || {};
  options2.unwrapObservables = void 0 !== options2.unwrapObservables ? options2.unwrapObservables : true;
  return options2;
};
function unwrap(value2, options2) {
  return options2.unwrapObservables ? unwrapVariable(value2) : value2;
}
var compileGetter = function(expr) {
  if (arguments.length > 1) {
    expr = [].slice.call(arguments);
  }
  if (!expr || "this" === expr) {
    return function(obj) {
      return obj;
    };
  }
  if ("string" === typeof expr) {
    const path = getPathParts(expr);
    return function(obj, options2) {
      options2 = prepareOptions(options2);
      const functionAsIs = options2.functionsAsIs;
      const hasDefaultValue = "defaultValue" in options2;
      let current2 = unwrap(obj, options2);
      for (let i = 0; i < path.length; i++) {
        if (!current2) {
          if (null == current2 && hasDefaultValue) {
            return options2.defaultValue;
          }
          break;
        }
        const pathPart = path[i];
        if (hasDefaultValue && isObject(current2) && !(pathPart in current2)) {
          return options2.defaultValue;
        }
        let next = unwrap(current2[pathPart], options2);
        if (!functionAsIs && isFunction(next)) {
          next = next.call(current2);
        }
        current2 = next;
      }
      return current2;
    };
  }
  if (Array.isArray(expr)) {
    return combineGetters(expr);
  }
  if (isFunction(expr)) {
    return expr;
  }
};
function combineGetters(getters) {
  const compiledGetters = {};
  for (let i = 0, l = getters.length; i < l; i++) {
    const getter = getters[i];
    compiledGetters[getter] = compileGetter(getter);
  }
  return function(obj, options2) {
    let result2;
    each(compiledGetters, function(name2) {
      const value2 = this(obj, options2);
      if (void 0 === value2) {
        return;
      }
      let current2 = result2 || (result2 = {});
      const path = name2.split(".");
      const last = path.length - 1;
      for (let i = 0; i < last; i++) {
        const pathItem = path[i];
        if (!(pathItem in current2)) {
          current2[pathItem] = {};
        }
        current2 = current2[pathItem];
      }
      current2[path[last]] = value2;
    });
    return result2;
  };
}
function toLowerCase(value2, options2) {
  return null !== options2 && void 0 !== options2 && options2.locale ? value2.toLocaleLowerCase(options2.locale) : value2.toLowerCase();
}
function toUpperCase(value2, options2) {
  return null !== options2 && void 0 !== options2 && options2.locale ? value2.toLocaleUpperCase(options2.locale) : value2.toUpperCase();
}
var ensurePropValueDefined = function(obj, propName, value2, options2) {
  if (isDefined(value2)) {
    return value2;
  }
  const newValue = {};
  assignPropValue(obj, propName, newValue, options2);
  return newValue;
};
var compileSetter = function(expr) {
  expr = getPathParts(expr || "this");
  const lastLevelIndex = expr.length - 1;
  return function(obj, value2, options2) {
    options2 = prepareOptions(options2);
    let currentValue = unwrap(obj, options2);
    expr.forEach(function(propertyName, levelIndex) {
      let propertyValue = readPropValue(currentValue, propertyName, options2);
      const isPropertyFunc = !options2.functionsAsIs && isFunction(propertyValue) && !isWrapped(propertyValue);
      if (levelIndex === lastLevelIndex) {
        if (options2.merge && isPlainObject(value2) && (!isDefined(propertyValue) || isPlainObject(propertyValue))) {
          propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options2);
          deepExtendArraySafe(propertyValue, value2, false, true);
        } else if (isPropertyFunc) {
          currentValue[propertyName](value2);
        } else {
          assignPropValue(currentValue, propertyName, value2, options2);
        }
      } else {
        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options2);
        if (isPropertyFunc) {
          propertyValue = propertyValue.call(currentValue);
        }
        currentValue = propertyValue;
      }
    });
  };
};
var toComparable = function(value2, caseSensitive) {
  var _options$collatorOpti;
  let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
  if (value2 instanceof Date) {
    return value2.getTime();
  }
  if (value2 && value2 instanceof class_default && value2.valueOf) {
    return value2.valueOf();
  }
  const isCaseSensitive = "case" === (null === options2 || void 0 === options2 || null === (_options$collatorOpti = options2.collatorOptions) || void 0 === _options$collatorOpti ? void 0 : _options$collatorOpti.sensitivity) || caseSensitive;
  if (!isCaseSensitive && "string" === typeof value2) {
    var _options$collatorOpti2, _options$locale;
    if ("base" === (null === options2 || void 0 === options2 || null === (_options$collatorOpti2 = options2.collatorOptions) || void 0 === _options$collatorOpti2 ? void 0 : _options$collatorOpti2.sensitivity)) {
      const REMOVE_DIACRITICAL_MARKS_REGEXP = /[\u0300-\u036f]/g;
      value2 = value2.normalize("NFD").replace(REMOVE_DIACRITICAL_MARKS_REGEXP, "");
    }
    const locale = null === options2 || void 0 === options2 || null === (_options$locale = options2.locale) || void 0 === _options$locale ? void 0 : _options$locale.toLowerCase();
    const useUpperCase = locale && !!["hy", "el"].find((code) => locale === code || locale.startsWith(`${code}-`));
    return (useUpperCase ? toUpperCase : toLowerCase)(value2, options2);
  }
  return value2;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/common.js
var ensureDefined = function(value2, defaultValue) {
  return isDefined(value2) ? value2 : defaultValue;
};
var executeAsync = function(action, context2) {
  const deferred = new Deferred();
  const normalizedContext = context2 || this;
  const task = {
    promise: deferred.promise(),
    abort: function() {
      clearTimeout(timerId);
      deferred.rejectWith(normalizedContext);
    }
  };
  const timerId = (arguments[2] || setTimeout)(function() {
    const result2 = action.call(normalizedContext);
    if (result2 && result2.done && isFunction(result2.done)) {
      result2.done(function() {
        deferred.resolveWith(normalizedContext);
      });
    } else {
      deferred.resolveWith(normalizedContext);
    }
  }, "number" === typeof context2 ? context2 : 0);
  return task;
};
var delayedFuncs = [];
var delayedNames = [];
var delayedDeferreds = [];
var executingName;
var deferExecute = function(name2, func, deferred) {
  if (executingName && executingName !== name2) {
    delayedFuncs.push(func);
    delayedNames.push(name2);
    deferred = deferred || new Deferred();
    delayedDeferreds.push(deferred);
    return deferred;
  } else {
    const oldExecutingName = executingName;
    const currentDelayedCount = delayedDeferreds.length;
    executingName = name2;
    let result2 = func();
    if (!result2) {
      if (delayedDeferreds.length > currentDelayedCount) {
        result2 = when.apply(this, delayedDeferreds.slice(currentDelayedCount));
      } else if (deferred) {
        deferred.resolve();
      }
    }
    executingName = oldExecutingName;
    if (deferred && result2 && result2.done) {
      result2.done(deferred.resolve).fail(deferred.reject);
    }
    if (!executingName && delayedFuncs.length) {
      ("render" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());
    }
    return result2 || when();
  }
};
var deferRender = function(func, deferred) {
  return deferExecute("render", func, deferred);
};
var deferUpdate = function(func, deferred) {
  return deferExecute("update", func, deferred);
};
var deferRenderer = function(func) {
  return function() {
    const that = this;
    return deferExecute("render", function() {
      return func.call(that);
    });
  };
};
var deferUpdater = function(func) {
  return function() {
    const that = this;
    return deferExecute("update", function() {
      return func.call(that);
    });
  };
};
var findBestMatches = function(targetFilter, items, mapFn) {
  const bestMatches = [];
  let maxMatchCount = 0;
  each(items, (index2, itemSrc) => {
    let matchCount = 0;
    const item = mapFn ? mapFn(itemSrc) : itemSrc;
    each(targetFilter, (paramName, targetValue) => {
      const value2 = item[paramName];
      if (void 0 === value2) {
        return;
      }
      if (match(value2, targetValue)) {
        matchCount++;
        return;
      }
      matchCount = -1;
      return false;
    });
    if (matchCount < maxMatchCount) {
      return;
    }
    if (matchCount > maxMatchCount) {
      bestMatches.length = 0;
      maxMatchCount = matchCount;
    }
    bestMatches.push(itemSrc);
  });
  return bestMatches;
};
var match = function(value2, targetValue) {
  if (Array.isArray(value2) && Array.isArray(targetValue)) {
    let mismatch = false;
    each(value2, (index2, valueItem) => {
      if (valueItem !== targetValue[index2]) {
        mismatch = true;
        return false;
      }
    });
    if (mismatch) {
      return false;
    }
    return true;
  }
  if (value2 === targetValue) {
    return true;
  }
  return false;
};
var splitPair = function(raw) {
  switch (type(raw)) {
    case "string":
      return raw.split(/\s+/, 2);
    case "object":
      return [raw.x ?? raw.h, raw.y ?? raw.v];
    case "number":
      return [raw];
    case "array":
      return raw;
    default:
      return null;
  }
};
var normalizeKey = function(id) {
  let key = isString(id) ? id : id.toString();
  const arr = key.match(/[^a-zA-Z0-9_]/g);
  arr && each(arr, (_, sign2) => {
    key = key.replace(sign2, "__" + sign2.charCodeAt() + "__");
  });
  return key;
};
var pairToObject = function(raw, preventRound) {
  const pair = splitPair(raw);
  let h2 = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);
  let v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);
  if (!isFinite(h2)) {
    h2 = 0;
  }
  if (!isFinite(v)) {
    v = h2;
  }
  return {
    h: h2,
    v
  };
};
var getKeyHash = function(key) {
  if (key instanceof guid_default) {
    return key.toString();
  } else if (isObject(key) || Array.isArray(key)) {
    try {
      const keyHash = JSON.stringify(key);
      return "{}" === keyHash ? key : keyHash;
    } catch (e) {
      return key;
    }
  }
  return key;
};
var escapeRegExp = function(string) {
  return string.replace(/[[\]{}\-()*+?.\\^$|\s]/g, "\\$&");
};
var applyServerDecimalSeparator = function(value2) {
  const separator = config_default().serverDecimalSeparator;
  if (isDefined(value2)) {
    value2 = value2.toString().replace(".", separator);
  }
  return value2;
};
var noop2 = function() {
};
var grep = function(elements, checkFunction, invert) {
  const result2 = [];
  let check;
  const expectedCheck = !invert;
  for (let i = 0; i < elements.length; i++) {
    check = !!checkFunction(elements[i], i);
    if (check === expectedCheck) {
      result2.push(elements[i]);
    }
  }
  return result2;
};
var compareArrays = (array1, array2, depth, options2) => {
  if (array1.length !== array2.length) {
    return false;
  }
  return !array1.some((item, idx) => !compareByValue(item, array2[idx], depth + 1, _extends({}, options2, {
    strict: true
  })));
};
var compareObjects = (object1, object2, depth, options2) => {
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  const keys2Set = new Set(keys2);
  return !keys1.some((key) => !keys2Set.has(key) || !compareByValue(object1[key], object2[key], depth + 1, options2));
};
var DEFAULT_EQUAL_BY_VALUE_OPTS = {
  maxDepth: 3,
  strict: true
};
var compareByValue = (value1, value2, depth, options2) => {
  const {
    strict,
    maxDepth
  } = options2;
  const comparable1 = toComparable(value1, true);
  const comparable2 = toComparable(value2, true);
  const comparisonResult = strict ? comparable1 === comparable2 : comparable1 == comparable2;
  switch (true) {
    case comparisonResult:
    case depth >= maxDepth:
      return true;
    case (isObject(comparable1) && isObject(comparable2)):
      return compareObjects(comparable1, comparable2, depth, options2);
    case (Array.isArray(comparable1) && Array.isArray(comparable2)):
      return compareArrays(comparable1, comparable2, depth, options2);
    default:
      return false;
  }
};
var equalByValue = function(value1, value2) {
  let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : DEFAULT_EQUAL_BY_VALUE_OPTS;
  const compareOptions = _extends({}, DEFAULT_EQUAL_BY_VALUE_OPTS, options2);
  return compareByValue(value1, value2, 0, compareOptions);
};

// ../../../../../../node_modules/devextreme/esm/core/utils/shadow_dom.js
var DX_RULE_PREFIX = "dx-";
var ownerDocumentStyleSheet = null;
function createConstructedStyleSheet(rootNode) {
  try {
    return new CSSStyleSheet();
  } catch (err) {
    const styleElement = rootNode.ownerDocument.createElement("style");
    rootNode.appendChild(styleElement);
    return styleElement.sheet;
  }
}
function processRules(targetStyleSheet, styleSheets, needApplyAllStyles) {
  for (let i = 0; i < styleSheets.length; i++) {
    const sheet = styleSheets[i];
    try {
      for (let j = 0; j < sheet.cssRules.length; j++) {
        insertRule(targetStyleSheet, sheet.cssRules[j], needApplyAllStyles);
      }
    } catch (err) {
    }
  }
}
function insertRule(targetStyleSheet, rule, needApplyAllStyles) {
  var _rule$selectorText, _rule$cssRules, _rule$name, _rule$style;
  const isDxRule = needApplyAllStyles || (null === (_rule$selectorText = rule.selectorText) || void 0 === _rule$selectorText ? void 0 : _rule$selectorText.includes(DX_RULE_PREFIX)) || (null === (_rule$cssRules = rule.cssRules) || void 0 === _rule$cssRules || null === (_rule$cssRules = _rule$cssRules[0]) || void 0 === _rule$cssRules || null === (_rule$cssRules = _rule$cssRules.selectorText) || void 0 === _rule$cssRules ? void 0 : _rule$cssRules.includes(DX_RULE_PREFIX)) || (null === (_rule$name = rule.name) || void 0 === _rule$name ? void 0 : _rule$name.startsWith(DX_RULE_PREFIX)) || "DXIcons" === (null === (_rule$style = rule.style) || void 0 === _rule$style ? void 0 : _rule$style.fontFamily);
  if (isDxRule) {
    targetStyleSheet.insertRule(rule.cssText, targetStyleSheet.cssRules.length);
  }
}
function addShadowDomStyles($element) {
  var _el$getRootNode;
  const el = $element.get(0);
  const root = null === (_el$getRootNode = el.getRootNode) || void 0 === _el$getRootNode ? void 0 : _el$getRootNode.call(el);
  if (!(null !== root && void 0 !== root && root.host)) {
    return;
  }
  if (!ownerDocumentStyleSheet) {
    ownerDocumentStyleSheet = createConstructedStyleSheet(root);
    processRules(ownerDocumentStyleSheet, el.ownerDocument.styleSheets, false);
  }
  const currentShadowDomStyleSheet = createConstructedStyleSheet(root);
  processRules(currentShadowDomStyleSheet, root.styleSheets, true);
  root.adoptedStyleSheets = [ownerDocumentStyleSheet, currentShadowDomStyleSheet];
}
function isPositionInElementRectangle(element, x, y) {
  const rect = element.getBoundingClientRect();
  return rect && x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom;
}
function createQueue() {
  let shiftIndex = 0;
  const items = [];
  return {
    push(item) {
      items.push(item);
      return this;
    },
    shift() {
      shiftIndex++;
      return items[shiftIndex - 1];
    },
    get length() {
      return items.length - shiftIndex;
    },
    get items() {
      return items;
    }
  };
}
function getShadowElementsFromPoint(x, y, root) {
  const elementQueue = createQueue().push(root);
  while (elementQueue.length) {
    const el = elementQueue.shift();
    for (let i = 0; i < el.childNodes.length; i++) {
      const childNode = el.childNodes[i];
      if (childNode.nodeType === Node.ELEMENT_NODE && isPositionInElementRectangle(childNode, x, y) && "none" !== getComputedStyle(childNode).pointerEvents) {
        elementQueue.push(childNode);
      }
    }
  }
  const result2 = elementQueue.items.reverse();
  result2.pop();
  return result2;
}

// ../../../../../../node_modules/devextreme/esm/core/dom_adapter.js
var nativeDOMAdapterStrategy = {
  querySelectorAll: (element, selector) => element.querySelectorAll(selector),
  elementMatches(element, selector) {
    const matches = element.matches || element.matchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector || ((selector2) => {
      const doc = element.document || element.ownerDocument;
      if (!doc) {
        return false;
      }
      const items = this.querySelectorAll(doc, selector2);
      for (let i = 0; i < items.length; i++) {
        if (items[i] === element) {
          return true;
        }
      }
    });
    return matches.call(element, selector);
  },
  createElement(tagName, context2) {
    context2 = context2 || this._document;
    return context2.createElement(tagName);
  },
  createElementNS(ns, tagName, context2) {
    context2 = context2 || this._document;
    return context2.createElementNS(ns, tagName);
  },
  createTextNode(text, context2) {
    context2 = context2 || this._document;
    return context2.createTextNode(text);
  },
  createAttribute(text, context2) {
    context2 = context2 || this._document;
    return context2.createAttribute(text);
  },
  isNode: (element) => element && "object" === typeof element && "nodeType" in element && "nodeName" in element,
  isElementNode: (element) => element && 1 === element.nodeType,
  isTextNode: (element) => element && 3 === element.nodeType,
  isDocument: (element) => element && 9 === element.nodeType,
  isDocumentFragment: (element) => element && 11 === element.nodeType,
  removeElement(element) {
    const parentNode = element && element.parentNode;
    if (parentNode) {
      parentNode.removeChild(element);
    }
  },
  insertElement(parentElement, newElement, nextSiblingElement) {
    if (parentElement && newElement && parentElement !== newElement) {
      if (nextSiblingElement) {
        parentElement.insertBefore(newElement, nextSiblingElement);
      } else {
        parentElement.appendChild(newElement);
      }
    }
  },
  getAttribute: (element, name2) => element.getAttribute(name2),
  setAttribute(element, name2, value2) {
    if ("style" === name2) {
      element.style.cssText = value2;
    } else {
      element.setAttribute(name2, value2);
    }
  },
  removeAttribute(element, name2) {
    element.removeAttribute(name2);
  },
  setProperty(element, name2, value2) {
    element[name2] = value2;
  },
  setText(element, text) {
    if (element) {
      element.textContent = text;
    }
  },
  setClass(element, className, isAdd) {
    if (1 === element.nodeType && className) {
      isAdd ? element.classList.add(className) : element.classList.remove(className);
    }
  },
  setStyle(element, name2, value2) {
    element.style[name2] = value2 || "";
  },
  _document: "undefined" === typeof document ? void 0 : document,
  getDocument() {
    return this._document;
  },
  getActiveElement(element) {
    const activeElementHolder = this.getRootNode(element);
    return activeElementHolder.activeElement;
  },
  getRootNode(element) {
    var _element$getRootNode;
    return (null === element || void 0 === element || null === (_element$getRootNode = element.getRootNode) || void 0 === _element$getRootNode ? void 0 : _element$getRootNode.call(element)) ?? this._document;
  },
  getBody() {
    return this._document.body;
  },
  createDocumentFragment() {
    return this._document.createDocumentFragment();
  },
  getDocumentElement() {
    return this._document.documentElement;
  },
  getLocation() {
    return this._document.location;
  },
  getSelection() {
    return this._document.selection;
  },
  getReadyState() {
    return this._document.readyState;
  },
  getHead() {
    return this._document.head;
  },
  hasDocumentProperty(property) {
    return property in this._document;
  },
  listen(element, event, callback, options2) {
    if (!element || !("addEventListener" in element)) {
      return noop2;
    }
    element.addEventListener(event, callback, options2);
    return () => {
      element.removeEventListener(event, callback);
    };
  },
  elementsFromPoint(x, y, element) {
    const activeElementHolder = this.getRootNode(element);
    if (activeElementHolder.host) {
      return getShadowElementsFromPoint(x, y, activeElementHolder);
    }
    return activeElementHolder.elementsFromPoint(x, y);
  }
};
var dom_adapter_default = dependency_injector_default(nativeDOMAdapterStrategy);

// ../../../../../../node_modules/devextreme/esm/core/memorized_callbacks.js
var MemorizedCallbacks = class {
  constructor() {
    this.memory = [];
    this.callbacks = callbacks_default();
  }
  add(fn) {
    each(this.memory, (_, item) => fn.apply(fn, item));
    this.callbacks.add(fn);
  }
  remove(fn) {
    this.callbacks.remove(fn);
  }
  fire() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.memory.push(args);
    this.callbacks.fire.apply(this.callbacks, args);
  }
};

// ../../../../../../node_modules/devextreme/esm/events/core/event_registrator_callbacks.js
var event_registrator_callbacks_default = new MemorizedCallbacks();

// ../../../../../../node_modules/devextreme/esm/events/utils/event_target.js
var getEventTarget = (event) => {
  var _originalEvent$target, _originalEvent$compos;
  const originalEvent = event.originalEvent;
  if (!originalEvent) {
    return event.target;
  }
  const isShadowDOMUsed = Boolean(null === (_originalEvent$target = originalEvent.target) || void 0 === _originalEvent$target ? void 0 : _originalEvent$target.shadowRoot);
  if (!isShadowDOMUsed) {
    return originalEvent.target;
  }
  const path = originalEvent.path ?? (null === (_originalEvent$compos = originalEvent.composedPath) || void 0 === _originalEvent$compos ? void 0 : _originalEvent$compos.call(originalEvent));
  const target = (null === path || void 0 === path ? void 0 : path[0]) ?? event.target;
  return target;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/window.js
var hasWindowValue = "undefined" !== typeof window;
var hasWindow = () => hasWindowValue;
var windowObject = hasWindow() ? window : void 0;
if (!windowObject) {
  windowObject = {};
  windowObject.window = windowObject;
}
var getWindow = () => windowObject;
var hasProperty = (prop) => hasWindow() && prop in windowObject;
var defaultScreenFactorFunc = (width) => {
  if (width < 768) {
    return "xs";
  } else if (width < 992) {
    return "sm";
  } else if (width < 1200) {
    return "md";
  } else {
    return "lg";
  }
};
var getCurrentScreenFactor = (screenFactorCallback) => {
  const screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;
  const windowWidth = dom_adapter_default.getDocumentElement().clientWidth;
  return screenFactorFunc(windowWidth);
};
var getNavigator = () => hasWindow() ? windowObject.navigator : {
  userAgent: ""
};

// ../../../../../../node_modules/devextreme/esm/events/core/hook_touch_props.js
var touchPropsToHook = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"];
var touchPropHook = function(name2, event) {
  if (event[name2] && !event.touches || !event.touches) {
    return event[name2];
  }
  const touches = event.touches.length ? event.touches : event.changedTouches;
  if (!touches.length) {
    return;
  }
  return touches[0][name2];
};
function hook_touch_props_default(callback) {
  touchPropsToHook.forEach(function(name2) {
    callback(name2, function(event) {
      return touchPropHook(name2, event);
    });
  }, this);
}

// ../../../../../../node_modules/devextreme/esm/core/utils/call_once.js
var callOnce = function(handler) {
  let result2;
  let wrappedHandler = function() {
    result2 = handler.apply(this, arguments);
    wrappedHandler = function() {
      return result2;
    };
    return result2;
  };
  return function() {
    return wrappedHandler.apply(this, arguments);
  };
};
var call_once_default = callOnce;

// ../../../../../../node_modules/devextreme/esm/events/core/events_engine.js
var window2 = getWindow();
var EMPTY_EVENT_NAME = "dxEmptyEventType";
var NATIVE_EVENTS_TO_SUBSCRIBE = {
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  pointerenter: "pointerover",
  pointerleave: "pointerout"
};
var NATIVE_EVENTS_TO_TRIGGER = {
  focusin: "focus",
  focusout: "blur"
};
var NO_BUBBLE_EVENTS = ["blur", "focus", "load"];
var forcePassiveFalseEventNames = ["touchmove", "wheel", "mousewheel", "touchstart"];
var EVENT_PROPERTIES = ["target", "relatedTarget", "delegateTarget", "altKey", "bubbles", "cancelable", "changedTouches", "ctrlKey", "detail", "eventPhase", "metaKey", "shiftKey", "view", "char", "code", "charCode", "key", "keyCode", "button", "buttons", "offsetX", "offsetY", "pointerId", "pointerType", "targetTouches", "toElement", "touches"];
function matchesSafe(target, selector) {
  return !isWindow(target) && "#document" !== target.nodeName && dom_adapter_default.elementMatches(target, selector);
}
var elementDataMap = /* @__PURE__ */ new WeakMap();
var guid = 0;
var skipEvent;
var special = function() {
  const specialData = {};
  event_registrator_callbacks_default.add(function(eventName, eventObject) {
    specialData[eventName] = eventObject;
  });
  return {
    getField: function(eventName, field) {
      return specialData[eventName] && specialData[eventName][field];
    },
    callMethod: function(eventName, methodName, context2, args) {
      return specialData[eventName] && specialData[eventName][methodName] && specialData[eventName][methodName].apply(context2, args);
    }
  };
}();
var eventsEngine = dependency_injector_default({
  on: getHandler(normalizeOnArguments(iterate(function(element, eventName, selector, data2, handler) {
    const handlersController = getHandlersController(element, eventName);
    handlersController.addHandler(handler, selector, data2);
  }))),
  one: getHandler(normalizeOnArguments(function(element, eventName, selector, data2, handler) {
    const oneTimeHandler = function() {
      eventsEngine.off(element, eventName, selector, oneTimeHandler);
      handler.apply(this, arguments);
    };
    eventsEngine.on(element, eventName, selector, data2, oneTimeHandler);
  })),
  off: getHandler(normalizeOffArguments(iterate(function(element, eventName, selector, handler) {
    const handlersController = getHandlersController(element, eventName);
    handlersController.removeHandler(handler, selector);
  }))),
  trigger: getHandler(normalizeTriggerArguments(function(element, event, extraParameters) {
    const eventName = event.type;
    const handlersController = getHandlersController(element, event.type);
    special.callMethod(eventName, "trigger", element, [event, extraParameters]);
    handlersController.callHandlers(event, extraParameters);
    const noBubble = special.getField(eventName, "noBubble") || event.isPropagationStopped() || -1 !== NO_BUBBLE_EVENTS.indexOf(eventName);
    if (!noBubble) {
      const parents = [];
      const getParents = function(element2) {
        const parent = element2.parentNode ?? (isObject(element2.host) ? element2.host : null);
        if (parent) {
          parents.push(parent);
          getParents(parent);
        }
      };
      getParents(element);
      parents.push(window2);
      let i = 0;
      while (parents[i] && !event.isPropagationStopped()) {
        const parentDataByEvent = getHandlersController(parents[i], event.type);
        parentDataByEvent.callHandlers(extend(event, {
          currentTarget: parents[i]
        }), extraParameters);
        i++;
      }
    }
    if (element.nodeType || isWindow(element)) {
      special.callMethod(eventName, "_default", element, [event, extraParameters]);
      callNativeMethod(eventName, element);
    }
  })),
  triggerHandler: getHandler(normalizeTriggerArguments(function(element, event, extraParameters) {
    const handlersController = getHandlersController(element, event.type);
    handlersController.callHandlers(event, extraParameters);
  }))
});
function applyForEach(args, method) {
  const element = args[0];
  if (!element) {
    return;
  }
  if (dom_adapter_default.isNode(element) || isWindow(element)) {
    method.apply(eventsEngine, args);
  } else if (!isString(element) && "length" in element) {
    const itemArgs = Array.prototype.slice.call(args, 0);
    Array.prototype.forEach.call(element, function(itemElement) {
      itemArgs[0] = itemElement;
      applyForEach(itemArgs, method);
    });
  } else {
    throw errors_default.Error("E0025");
  }
}
function getHandler(method) {
  return function() {
    applyForEach(arguments, method);
  };
}
function detectPassiveEventHandlersSupport() {
  let isSupported = false;
  try {
    const options2 = Object.defineProperty({}, "passive", {
      get: function() {
        isSupported = true;
        return true;
      }
    });
    window2.addEventListener("test", null, options2);
  } catch (e) {
  }
  return isSupported;
}
var passiveEventHandlersSupported = call_once_default(detectPassiveEventHandlersSupport);
var contains = (container, element) => {
  if (isWindow(container)) {
    return contains(container.document, element);
  }
  return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
};
function getHandlersController(element, eventName) {
  let elementData = elementDataMap.get(element);
  eventName = eventName || "";
  const eventNameParts = eventName.split(".");
  const namespaces2 = eventNameParts.slice(1);
  const eventNameIsDefined = !!eventNameParts[0];
  eventName = eventNameParts[0] || EMPTY_EVENT_NAME;
  if (!elementData) {
    elementData = {};
    elementDataMap.set(element, elementData);
  }
  if (!elementData[eventName]) {
    elementData[eventName] = {
      handleObjects: [],
      nativeHandler: null
    };
  }
  const eventData2 = elementData[eventName];
  return {
    addHandler: function(handler, selector, data2) {
      const callHandler = function(e, extraParameters) {
        const handlerArgs = [e];
        const target = e.currentTarget;
        const relatedTarget = e.relatedTarget;
        let secondaryTargetIsInside;
        let result2;
        if (eventName in NATIVE_EVENTS_TO_SUBSCRIBE) {
          secondaryTargetIsInside = relatedTarget && target && (relatedTarget === target || contains(target, relatedTarget));
        }
        if (void 0 !== extraParameters) {
          handlerArgs.push(extraParameters);
        }
        special.callMethod(eventName, "handle", element, [e, data2]);
        if (!secondaryTargetIsInside) {
          result2 = handler.apply(target, handlerArgs);
        }
        if (false === result2) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      const handleObject = {
        handler,
        wrappedHandler: function(e, extraParameters) {
          if (skipEvent && e.type === skipEvent) {
            return;
          }
          e.data = data2;
          e.delegateTarget = element;
          if (selector) {
            let currentTarget = e.target;
            while (currentTarget && currentTarget !== element) {
              if (matchesSafe(currentTarget, selector)) {
                e.currentTarget = currentTarget;
                callHandler(e, extraParameters);
              }
              currentTarget = currentTarget.parentNode;
            }
          } else {
            var _e$target;
            e.currentTarget = e.delegateTarget || e.target;
            const isTargetInShadowDOM = Boolean(null === (_e$target = e.target) || void 0 === _e$target ? void 0 : _e$target.shadowRoot);
            if (isTargetInShadowDOM) {
              const target = getEventTarget(e);
              e.target = target;
            }
            callHandler(e, extraParameters);
          }
        },
        selector,
        type: eventName,
        data: data2,
        namespace: namespaces2.join("."),
        namespaces: namespaces2,
        guid: ++guid
      };
      eventData2.handleObjects.push(handleObject);
      const firstHandlerForTheType = 1 === eventData2.handleObjects.length;
      let shouldAddNativeListener = firstHandlerForTheType && eventNameIsDefined;
      let nativeListenerOptions;
      if (shouldAddNativeListener) {
        shouldAddNativeListener = !special.callMethod(eventName, "setup", element, [data2, namespaces2, handler]);
      }
      if (shouldAddNativeListener) {
        eventData2.nativeHandler = getNativeHandler(eventName);
        if (passiveEventHandlersSupported() && forcePassiveFalseEventNames.indexOf(eventName) > -1) {
          nativeListenerOptions = {
            passive: false
          };
        }
        eventData2.removeListener = dom_adapter_default.listen(element, NATIVE_EVENTS_TO_SUBSCRIBE[eventName] || eventName, eventData2.nativeHandler, nativeListenerOptions);
      }
      special.callMethod(eventName, "add", element, [handleObject]);
    },
    removeHandler: function(handler, selector) {
      const removeByEventName = function(eventName2) {
        const eventData3 = elementData[eventName2];
        if (!eventData3.handleObjects.length) {
          delete elementData[eventName2];
          return;
        }
        let removedHandler;
        eventData3.handleObjects = eventData3.handleObjects.filter(function(handleObject) {
          const skip = namespaces2.length && !isSubset(handleObject.namespaces, namespaces2) || handler && handleObject.handler !== handler || selector && handleObject.selector !== selector;
          if (!skip) {
            removedHandler = handleObject.handler;
            special.callMethod(eventName2, "remove", element, [handleObject]);
          }
          return skip;
        });
        const lastHandlerForTheType = !eventData3.handleObjects.length;
        const shouldRemoveNativeListener = lastHandlerForTheType && eventName2 !== EMPTY_EVENT_NAME;
        if (shouldRemoveNativeListener) {
          special.callMethod(eventName2, "teardown", element, [namespaces2, removedHandler]);
          if (eventData3.nativeHandler) {
            eventData3.removeListener();
          }
          delete elementData[eventName2];
        }
      };
      if (eventNameIsDefined) {
        removeByEventName(eventName);
      } else {
        for (const name2 in elementData) {
          removeByEventName(name2);
        }
      }
      const elementDataIsEmpty = 0 === Object.keys(elementData).length;
      if (elementDataIsEmpty) {
        elementDataMap.delete(element);
      }
    },
    callHandlers: function(event, extraParameters) {
      let forceStop = false;
      const handleCallback = function(handleObject) {
        if (forceStop) {
          return;
        }
        if (!namespaces2.length || isSubset(handleObject.namespaces, namespaces2)) {
          handleObject.wrappedHandler(event, extraParameters);
          forceStop = event.isImmediatePropagationStopped();
        }
      };
      eventData2.handleObjects.forEach(handleCallback);
      if (namespaces2.length && elementData[EMPTY_EVENT_NAME]) {
        elementData[EMPTY_EVENT_NAME].handleObjects.forEach(handleCallback);
      }
    }
  };
}
function getNativeHandler(subscribeName) {
  return function(event, extraParameters) {
    const handlersController = getHandlersController(this, subscribeName);
    event = eventsEngine.Event(event);
    handlersController.callHandlers(event, extraParameters);
  };
}
function isSubset(original, checked) {
  for (let i = 0; i < checked.length; i++) {
    if (original.indexOf(checked[i]) < 0) {
      return false;
    }
  }
  return true;
}
function normalizeOnArguments(callback) {
  return function(element, eventName, selector, data2, handler) {
    if (!handler) {
      handler = data2;
      data2 = void 0;
    }
    if ("string" !== typeof selector) {
      data2 = selector;
      selector = void 0;
    }
    if (!handler && "string" === typeof eventName) {
      handler = data2 || selector;
      selector = void 0;
      data2 = void 0;
    }
    callback(element, eventName, selector, data2, handler);
  };
}
function normalizeOffArguments(callback) {
  return function(element, eventName, selector, handler) {
    if ("function" === typeof selector) {
      handler = selector;
      selector = void 0;
    }
    callback(element, eventName, selector, handler);
  };
}
function normalizeTriggerArguments(callback) {
  return function(element, src, extraParameters) {
    if ("string" === typeof src) {
      src = {
        type: src
      };
    }
    if (!src.target) {
      src.target = element;
    }
    src.currentTarget = element;
    if (!src.delegateTarget) {
      src.delegateTarget = element;
    }
    if (!src.type && src.originalEvent) {
      src.type = src.originalEvent.type;
    }
    callback(element, src instanceof eventsEngine.Event ? src : eventsEngine.Event(src), extraParameters);
  };
}
function normalizeEventArguments(callback) {
  eventsEngine.Event = function(src, config3) {
    if (!(this instanceof eventsEngine.Event)) {
      return new eventsEngine.Event(src, config3);
    }
    if (!src) {
      src = {};
    }
    if ("string" === typeof src) {
      src = {
        type: src
      };
    }
    if (!config3) {
      config3 = {};
    }
    callback.call(this, src, config3);
  };
  Object.assign(eventsEngine.Event.prototype, {
    _propagationStopped: false,
    _immediatePropagationStopped: false,
    _defaultPrevented: false,
    isPropagationStopped: function() {
      return !!(this._propagationStopped || this.originalEvent && this.originalEvent.propagationStopped);
    },
    stopPropagation: function() {
      this._propagationStopped = true;
      this.originalEvent && this.originalEvent.stopPropagation();
    },
    isImmediatePropagationStopped: function() {
      return this._immediatePropagationStopped;
    },
    stopImmediatePropagation: function() {
      this.stopPropagation();
      this._immediatePropagationStopped = true;
      this.originalEvent && this.originalEvent.stopImmediatePropagation();
    },
    isDefaultPrevented: function() {
      return !!(this._defaultPrevented || this.originalEvent && this.originalEvent.defaultPrevented);
    },
    preventDefault: function() {
      this._defaultPrevented = true;
      this.originalEvent && this.originalEvent.preventDefault();
    }
  });
  return eventsEngine.Event;
}
function iterate(callback) {
  const iterateEventNames = function(element, eventName) {
    if (eventName && eventName.indexOf(" ") > -1) {
      const args = Array.prototype.slice.call(arguments, 0);
      eventName.split(" ").forEach(function(eventName2) {
        args[1] = eventName2;
        callback.apply(this, args);
      });
    } else {
      callback.apply(this, arguments);
    }
  };
  return function(element, eventName) {
    if ("object" === typeof eventName) {
      const args = Array.prototype.slice.call(arguments, 0);
      for (const name2 in eventName) {
        args[1] = name2;
        args[args.length - 1] = eventName[name2];
        iterateEventNames.apply(this, args);
      }
    } else {
      iterateEventNames.apply(this, arguments);
    }
  };
}
function callNativeMethod(eventName, element) {
  const nativeMethodName = NATIVE_EVENTS_TO_TRIGGER[eventName] || eventName;
  if (function(eventName2, element2) {
    return "click" === eventName2 && "a" === element2.localName;
  }(eventName, element)) {
    return;
  }
  if (isFunction(element[nativeMethodName])) {
    skipEvent = eventName;
    element[nativeMethodName]();
    skipEvent = void 0;
  }
}
function calculateWhich(event) {
  if (function(event2) {
    return null == event2.which && 0 === event2.type.indexOf("key");
  }(event)) {
    return null != event.charCode ? event.charCode : event.keyCode;
  }
  if (function(event2) {
    return !event2.which && void 0 !== event2.button && /^(?:mouse|pointer|contextmenu|drag|drop)|click/.test(event2.type);
  }(event)) {
    const whichByButton = {
      1: 1,
      2: 3,
      3: 1,
      4: 2
    };
    return whichByButton[event.button];
  }
  return event.which;
}
function initEvent(EventClass) {
  if (EventClass) {
    eventsEngine.Event = EventClass;
    eventsEngine.Event.prototype = EventClass.prototype;
  }
}
initEvent(normalizeEventArguments(function(src, config3) {
  var _src$view;
  const srcIsEvent = src instanceof eventsEngine.Event || hasWindow() && src instanceof window2.Event || (null === (_src$view = src.view) || void 0 === _src$view ? void 0 : _src$view.Event) && src instanceof src.view.Event;
  if (srcIsEvent) {
    this.originalEvent = src;
    this.type = src.type;
    this.currentTarget = void 0;
    if (Object.prototype.hasOwnProperty.call(src, "isTrusted")) {
      this.isTrusted = src.isTrusted;
    }
    this.timeStamp = src.timeStamp || Date.now();
  } else {
    Object.assign(this, src);
  }
  addProperty("which", calculateWhich, this);
  if (0 === src.type.indexOf("touch")) {
    delete config3.pageX;
    delete config3.pageY;
  }
  Object.assign(this, config3);
  this.guid = ++guid;
}));
function addProperty(propName, hook, eventInstance) {
  Object.defineProperty(eventInstance || eventsEngine.Event.prototype, propName, {
    enumerable: true,
    configurable: true,
    get: function() {
      return this.originalEvent && hook(this.originalEvent);
    },
    set: function(value2) {
      Object.defineProperty(this, propName, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value2
      });
    }
  });
}
EVENT_PROPERTIES.forEach((prop) => addProperty(prop, (event) => event[prop]));
hook_touch_props_default(addProperty);
var beforeSetStrategy = callbacks_default();
var afterSetStrategy = callbacks_default();
eventsEngine.set = function(engine) {
  beforeSetStrategy.fire();
  eventsEngine.inject(engine);
  initEvent(engine.Event);
  afterSetStrategy.fire();
};
eventsEngine.subscribeGlobal = function() {
  applyForEach(arguments, normalizeOnArguments(function() {
    const args = arguments;
    eventsEngine.on.apply(this, args);
    beforeSetStrategy.add(function() {
      const offArgs = Array.prototype.slice.call(args, 0);
      offArgs.splice(3, 1);
      eventsEngine.off.apply(this, offArgs);
    });
    afterSetStrategy.add(function() {
      eventsEngine.on.apply(this, args);
    });
  }));
};
eventsEngine.forcePassiveFalseEventNames = forcePassiveFalseEventNames;
eventsEngine.passiveEventHandlersSupported = passiveEventHandlersSupported;
var events_engine_default = eventsEngine;

// ../../../../../../node_modules/devextreme/esm/core/element_data.js
var dataMap = /* @__PURE__ */ new WeakMap();
var strategy;
var strategyChanging = new MemorizedCallbacks();
var beforeCleanDataFunc = function() {
};
var afterCleanDataFunc = function() {
};
var setDataStrategy = function(value2) {
  strategyChanging.fire(value2);
  strategy = value2;
  const cleanData = strategy.cleanData;
  strategy.cleanData = function(nodes) {
    beforeCleanDataFunc(nodes);
    const result2 = cleanData.call(this, nodes);
    afterCleanDataFunc(nodes);
    return result2;
  };
};
setDataStrategy({
  data: function() {
    const element = arguments[0];
    const key = arguments[1];
    const value2 = arguments[2];
    if (!element) {
      return;
    }
    let elementData = dataMap.get(element);
    if (!elementData) {
      elementData = {};
      dataMap.set(element, elementData);
    }
    if (void 0 === key) {
      return elementData;
    }
    if (2 === arguments.length) {
      return elementData[key];
    }
    elementData[key] = value2;
    return value2;
  },
  removeData: function(element, key) {
    if (!element) {
      return;
    }
    if (void 0 === key) {
      dataMap.delete(element);
    } else {
      const elementData = dataMap.get(element);
      if (elementData) {
        delete elementData[key];
      }
    }
  },
  cleanData: function(elements) {
    for (let i = 0; i < elements.length; i++) {
      events_engine_default.off(elements[i]);
      dataMap.delete(elements[i]);
    }
  }
});
function data() {
  return strategy.data.apply(this, arguments);
}
function beforeCleanData(callback) {
  beforeCleanDataFunc = callback;
}
function removeData(element, key) {
  return strategy.removeData.call(this, element, key);
}
function cleanDataRecursive(element, cleanSelf) {
  if (!dom_adapter_default.isElementNode(element)) {
    return;
  }
  const childElements = element.getElementsByTagName("*");
  strategy.cleanData(childElements);
  if (cleanSelf) {
    strategy.cleanData([element]);
  }
}

// ../../../../../../node_modules/devextreme/esm/core/utils/inflector.js
var _normalize = function(text) {
  if (void 0 === text || null === text) {
    return "";
  }
  return String(text);
};
var _upperCaseFirst = function(text) {
  return _normalize(text).charAt(0).toUpperCase() + text.substr(1);
};
var _chop = function(text) {
  return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/);
};
var dasherize = function(text) {
  return map(_chop(text), function(p2) {
    return p2.toLowerCase();
  }).join("-");
};
var camelize = function(text, upperFirst) {
  return map(_chop(text), function(p2, i) {
    p2 = p2.toLowerCase();
    if (upperFirst || i > 0) {
      p2 = _upperCaseFirst(p2);
    }
    return p2;
  }).join("");
};
var humanize = function(text) {
  return _upperCaseFirst(dasherize(text).replace(/-/g, " "));
};
var titleize = function(text) {
  return map(_chop(text), function(p2) {
    return _upperCaseFirst(p2.toLowerCase());
  }).join(" ");
};
var DIGIT_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
var captionize = function(name2) {
  const captionList = [];
  let i;
  let char;
  let isPrevCharNewWord = false;
  let isNewWord = false;
  for (i = 0; i < name2.length; i++) {
    char = name2.charAt(i);
    isNewWord = char === char.toUpperCase() && "-" !== char && ")" !== char && "/" !== char || char in DIGIT_CHARS;
    if ("_" === char || "." === char) {
      char = " ";
      isNewWord = true;
    } else if (0 === i) {
      char = char.toUpperCase();
      isNewWord = true;
    } else if (!isPrevCharNewWord && isNewWord) {
      if (captionList.length > 0) {
        captionList.push(" ");
      }
    }
    captionList.push(char);
    isPrevCharNewWord = isNewWord;
  }
  return captionList.join("");
};

// ../../../../../../node_modules/devextreme/esm/core/utils/style.js
var jsPrefixes = ["", "Webkit", "Moz", "O", "Ms"];
var cssPrefixes = {
  "": "",
  Webkit: "-webkit-",
  Moz: "-moz-",
  O: "-o-",
  ms: "-ms-"
};
var getStyles = call_once_default(function() {
  return dom_adapter_default.createElement("dx").style;
});
var forEachPrefixes = function(prop, callBack) {
  prop = camelize(prop, true);
  let result2;
  for (let i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
    const jsPrefix = jsPrefixes[i];
    const prefixedProp = jsPrefix + prop;
    const lowerPrefixedProp = camelize(prefixedProp);
    result2 = callBack(lowerPrefixedProp, jsPrefix);
    if (void 0 === result2) {
      result2 = callBack(prefixedProp, jsPrefix);
    }
    if (void 0 !== result2) {
      break;
    }
  }
  return result2 || "";
};
var styleProp = function(name2) {
  if (name2 in getStyles()) {
    return name2;
  }
  const originalName = name2;
  name2 = name2.charAt(0).toUpperCase() + name2.substr(1);
  for (let i = 1; i < jsPrefixes.length; i++) {
    const prefixedProp = jsPrefixes[i].toLowerCase() + name2;
    if (prefixedProp in getStyles()) {
      return prefixedProp;
    }
  }
  return originalName;
};
var stylePropPrefix = function(prop) {
  return forEachPrefixes(prop, function(specific, jsPrefix) {
    if (specific in getStyles()) {
      return cssPrefixes[jsPrefix];
    }
  });
};
var pxExceptions = ["fillOpacity", "columnCount", "flexGrow", "flexShrink", "fontWeight", "lineHeight", "opacity", "zIndex", "zoom"];
var normalizeStyleProp = function(prop, value2) {
  if (isNumeric(value2) && -1 === pxExceptions.indexOf(prop)) {
    value2 += "px";
  }
  return value2;
};
var setStyle = function(element, styleString) {
  let resetStyle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;
  if (resetStyle) {
    const styleList = [].slice.call(element.style);
    styleList.forEach((propertyName) => {
      element.style.removeProperty(propertyName);
    });
  }
  styleString.split(";").forEach((style) => {
    const parts = style.split(":").map((stylePart) => stylePart.trim());
    if (2 === parts.length) {
      const [property, value2] = parts;
      element.style[property] = value2;
    }
  });
};

// ../../../../../../node_modules/devextreme/esm/core/utils/size.js
var window3 = getWindow();
var SPECIAL_HEIGHT_VALUES = ["auto", "none", "inherit", "initial"];
var getSizeByStyles = function(elementStyles, styles) {
  let result2 = 0;
  styles.forEach(function(style) {
    result2 += parseFloat(elementStyles[style]) || 0;
  });
  return result2;
};
var getElementBoxParams = function(name2, elementStyles) {
  const beforeName = "width" === name2 ? "Left" : "Top";
  const afterName = "width" === name2 ? "Right" : "Bottom";
  return {
    padding: getSizeByStyles(elementStyles, ["padding" + beforeName, "padding" + afterName]),
    border: getSizeByStyles(elementStyles, ["border" + beforeName + "Width", "border" + afterName + "Width"]),
    margin: getSizeByStyles(elementStyles, ["margin" + beforeName, "margin" + afterName])
  };
};
var getElementComputedStyle = function(element) {
  var _element$ownerDocumen;
  const view = (null === element || void 0 === element || null === (_element$ownerDocumen = element.ownerDocument) || void 0 === _element$ownerDocumen ? void 0 : _element$ownerDocumen.defaultView) || window3;
  return view.getComputedStyle && view.getComputedStyle(element);
};
var getCSSProperty = function(element, styles, name2, defaultValue) {
  var _element$style;
  return (null === styles || void 0 === styles ? void 0 : styles[name2]) || (null === (_element$style = element.style) || void 0 === _element$style ? void 0 : _element$style[name2]) || defaultValue;
};
var boxIndices = {
  content: 0,
  padding: 1,
  border: 2,
  margin: 3,
  "content-box": 0,
  "border-box": 2
};
var dimensionComponents = {
  width: ["left", "right"],
  height: ["top", "bottom"]
};
function getComponentThickness(elem, dimension, component, styles) {
  const get = (elem2, styles2, field) => parseFloat(getCSSProperty(elem2, styles2, field, "0")) || 0;
  const suffix = "border" === component ? "-width" : "";
  return get(elem, styles, `${component}-${dimensionComponents[dimension][0]}${suffix}`) + get(elem, styles, `${component}-${dimensionComponents[dimension][1]}${suffix}`);
}
var getSize = function(element, dimension, box) {
  const offsetFieldName = "width" === dimension ? "offsetWidth" : "offsetHeight";
  const styles = getElementComputedStyle(element);
  let result2 = getCSSProperty(element, styles, dimension);
  if ("" === result2 || "auto" === result2) {
    result2 = element[offsetFieldName];
  }
  result2 = parseFloat(result2) || 0;
  const currentBox = getCSSProperty(element, styles, "boxSizing", "content-box");
  const targetBox = box || currentBox;
  let targetBoxIndex = boxIndices[targetBox];
  let currentBoxIndex = boxIndices[currentBox];
  if (void 0 === targetBoxIndex || void 0 === currentBoxIndex) {
    throw new Error();
  }
  if (currentBoxIndex === targetBoxIndex) {
    return result2;
  }
  const coeff = Math.sign(targetBoxIndex - currentBoxIndex);
  let padding = false;
  let border = false;
  let margin = false;
  let scrollThickness = false;
  if (1 === coeff) {
    targetBoxIndex += 1;
    currentBoxIndex += 1;
  }
  for (let boxPart = currentBoxIndex; boxPart !== targetBoxIndex; boxPart += coeff) {
    switch (boxPart) {
      case boxIndices.content:
        break;
      case boxIndices.padding:
        padding = coeff * getComponentThickness(element, dimension, "padding", styles);
        break;
      case boxIndices.border:
        border = coeff * getComponentThickness(element, dimension, "border", styles);
        break;
      case boxIndices.margin:
        margin = coeff * getComponentThickness(element, dimension, "margin", styles);
    }
  }
  if (padding || border) {
    const paddingAndBorder = (false === padding ? coeff * getComponentThickness(element, dimension, "padding", styles) : padding) + (false === border ? coeff * getComponentThickness(element, dimension, "border", styles) : border);
    scrollThickness = coeff * Math.max(0, Math.floor(element[offsetFieldName] - result2 - coeff * paddingAndBorder)) || 0;
  }
  return result2 + margin + padding + border + scrollThickness;
};
var getContainerHeight = function(container) {
  return isWindow(container) ? container.innerHeight : container.offsetHeight;
};
var parseHeight = function(value2, container, element) {
  if (value2.indexOf("px") > 0) {
    value2 = parseInt(value2.replace("px", ""));
  } else if (value2.indexOf("%") > 0) {
    value2 = parseInt(value2.replace("%", "")) * getContainerHeight(container) / 100;
  } else if (!isNaN(value2)) {
    value2 = parseInt(value2);
  } else if (value2.indexOf("vh") > 0) {
    value2 = window3.innerHeight / 100 * parseInt(value2.replace("vh", ""));
  } else if (element && value2.indexOf("em") > 0) {
    value2 = parseFloat(value2.replace("em", "")) * parseFloat(window3.getComputedStyle(element).fontSize);
  }
  return value2;
};
var getHeightWithOffset = function(value2, offset2, container) {
  if (!value2) {
    return null;
  }
  if (SPECIAL_HEIGHT_VALUES.indexOf(value2) > -1) {
    return offset2 ? null : value2;
  }
  if (isString(value2)) {
    value2 = parseHeight(value2, container);
  }
  if (isNumeric(value2)) {
    return Math.max(0, value2 + offset2);
  }
  const operationString = offset2 < 0 ? " - " : " ";
  return "calc(" + value2 + operationString + Math.abs(offset2) + "px)";
};
var addOffsetToMaxHeight = function(value2, offset2, container) {
  const maxHeight = getHeightWithOffset(value2, offset2, container);
  return null !== maxHeight ? maxHeight : "none";
};
var addOffsetToMinHeight = function(value2, offset2, container) {
  const minHeight = getHeightWithOffset(value2, offset2, container);
  return null !== minHeight ? minHeight : 0;
};
var getVerticalOffsets = function(element, withMargins) {
  if (!element) {
    return 0;
  }
  const boxParams = getElementBoxParams("height", window3.getComputedStyle(element));
  return boxParams.padding + boxParams.border + (withMargins ? boxParams.margin : 0);
};
var getVisibleHeight = function(element) {
  if (element) {
    const boundingClientRect = element.getBoundingClientRect();
    if (boundingClientRect.height) {
      return boundingClientRect.height;
    }
  }
  return 0;
};
var implementationsMap = {
  getWidth: function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return elementSizeHelper("width", ...args);
  },
  setWidth: function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return elementSizeHelper("width", ...args);
  },
  getHeight: function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return elementSizeHelper("height", ...args);
  },
  setHeight: function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return elementSizeHelper("height", ...args);
  },
  getOuterWidth: function() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return elementSizeHelper("outerWidth", ...args);
  },
  setOuterWidth: function() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return elementSizeHelper("outerWidth", ...args);
  },
  getOuterHeight: function() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return elementSizeHelper("outerHeight", ...args);
  },
  setOuterHeight: function() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    return elementSizeHelper("outerHeight", ...args);
  },
  getInnerWidth: function() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    return elementSizeHelper("innerWidth", ...args);
  },
  setInnerWidth: function() {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }
    return elementSizeHelper("innerWidth", ...args);
  },
  getInnerHeight: function() {
    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      args[_key11] = arguments[_key11];
    }
    return elementSizeHelper("innerHeight", ...args);
  },
  setInnerHeight: function() {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }
    return elementSizeHelper("innerHeight", ...args);
  }
};
function elementSizeHelper(sizeProperty, el, value2) {
  return 2 === arguments.length ? elementSize(el, sizeProperty) : elementSize(el, sizeProperty, value2);
}
var getWidth = (el) => implementationsMap.getWidth(el);
var setWidth = (el, value2) => implementationsMap.setWidth(el, value2);
var getHeight = (el) => implementationsMap.getHeight(el);
var setHeight = (el, value2) => implementationsMap.setHeight(el, value2);
var getOuterWidth = (el, includeMargin) => implementationsMap.getOuterWidth(el, includeMargin || false);
var setOuterWidth = (el, value2) => implementationsMap.setOuterWidth(el, value2);
var getOuterHeight = (el, includeMargin) => implementationsMap.getOuterHeight(el, includeMargin || false);
var setOuterHeight = (el, value2) => implementationsMap.setOuterHeight(el, value2);
var getInnerWidth = (el) => implementationsMap.getInnerWidth(el);
var getInnerHeight = (el) => implementationsMap.getInnerHeight(el);
var elementSize = function(el, sizeProperty, value2) {
  const partialName = sizeProperty.toLowerCase().indexOf("width") >= 0 ? "Width" : "Height";
  const propName = partialName.toLowerCase();
  const isOuter = 0 === sizeProperty.indexOf("outer");
  const isInner = 0 === sizeProperty.indexOf("inner");
  const isGetter = 2 === arguments.length || "boolean" === typeof value2;
  if (isRenderer(el)) {
    if (el.length > 1 && !isGetter) {
      for (let i = 0; i < el.length; i++) {
        elementSize(el[i], sizeProperty, value2);
      }
      return;
    }
    el = el[0];
  }
  if (!el) {
    return;
  }
  if (isWindow(el)) {
    return isOuter ? el["inner" + partialName] : dom_adapter_default.getDocumentElement()["client" + partialName];
  }
  if (dom_adapter_default.isDocument(el)) {
    const documentElement = dom_adapter_default.getDocumentElement();
    const body = dom_adapter_default.getBody();
    return Math.max(body["scroll" + partialName], body["offset" + partialName], documentElement["scroll" + partialName], documentElement["offset" + partialName], documentElement["client" + partialName]);
  }
  if (isGetter) {
    let box = "content";
    if (isOuter) {
      box = value2 ? "margin" : "border";
    }
    if (isInner) {
      box = "padding";
    }
    return getSize(el, propName, box);
  }
  if (isNumeric(value2)) {
    const elementStyles = getElementComputedStyle(el);
    const sizeAdjustment = getElementBoxParams(propName, elementStyles);
    const isBorderBox = "border-box" === elementStyles.boxSizing;
    value2 = Number(value2);
    if (isOuter) {
      value2 -= isBorderBox ? 0 : sizeAdjustment.border + sizeAdjustment.padding;
    } else if (isInner) {
      value2 += isBorderBox ? sizeAdjustment.border : -sizeAdjustment.padding;
    } else if (isBorderBox) {
      value2 += sizeAdjustment.border + sizeAdjustment.padding;
    }
  }
  value2 += isNumeric(value2) ? "px" : "";
  dom_adapter_default.setStyle(el, propName, value2);
  return null;
};
var getWindowByElement = (el) => isWindow(el) ? el : el.defaultView;
var getOffset = (el) => {
  if (!el.getClientRects().length) {
    return {
      top: 0,
      left: 0
    };
  }
  const rect = el.getBoundingClientRect();
  const win = getWindowByElement(el.ownerDocument);
  const docElem = el.ownerDocument.documentElement;
  return {
    top: rect.top + win.pageYOffset - docElem.clientTop,
    left: rect.left + win.pageXOffset - docElem.clientLeft
  };
};

// ../../../../../../node_modules/devextreme/esm/core/utils/html_parser.js
var isTagName = /<([a-z][^/\0>\x20\t\r\n\f]+)/i;
var tagWrappers = {
  default: {
    tagsCount: 0,
    startTags: "",
    endTags: ""
  },
  thead: {
    tagsCount: 1,
    startTags: "<table>",
    endTags: "</table>"
  },
  td: {
    tagsCount: 3,
    startTags: "<table><tbody><tr>",
    endTags: "</tr></tbody></table>"
  },
  col: {
    tagsCount: 2,
    startTags: "<table><colgroup>",
    endTags: "</colgroup></table>"
  },
  tr: {
    tagsCount: 2,
    startTags: "<table><tbody>",
    endTags: "</tbody></table>"
  }
};
tagWrappers.tbody = tagWrappers.colgroup = tagWrappers.caption = tagWrappers.tfoot = tagWrappers.thead;
tagWrappers.th = tagWrappers.td;
var parseHTML = function(html) {
  if ("string" !== typeof html) {
    return null;
  }
  const fragment = dom_adapter_default.createDocumentFragment();
  let container = fragment.appendChild(dom_adapter_default.createElement("div"));
  const tags = isTagName.exec(html);
  const firstRootTag = tags && tags[1].toLowerCase();
  const tagWrapper = tagWrappers[firstRootTag] || tagWrappers.default;
  container.innerHTML = tagWrapper.startTags + html + tagWrapper.endTags;
  for (let i = 0; i < tagWrapper.tagsCount; i++) {
    container = container.lastChild;
  }
  return [...container.childNodes];
};
var isTablePart = function(html) {
  const tags = isTagName.exec(html);
  return tags && tags[1] in tagWrappers;
};

// ../../../../../../node_modules/devextreme/esm/core/renderer_base.js
var window4 = getWindow();
var renderer;
var initRender = function(selector, context2) {
  if (!selector) {
    this.length = 0;
    return this;
  }
  if ("string" === typeof selector) {
    if ("body" === selector) {
      this[0] = context2 ? context2.body : dom_adapter_default.getBody();
      this.length = 1;
      return this;
    }
    context2 = context2 || dom_adapter_default.getDocument();
    if ("<" === selector[0]) {
      this[0] = dom_adapter_default.createElement(selector.slice(1, -1), context2);
      this.length = 1;
      return this;
    }
    [].push.apply(this, dom_adapter_default.querySelectorAll(context2, selector));
    return this;
  } else if (dom_adapter_default.isNode(selector) || isWindow(selector)) {
    this[0] = selector;
    this.length = 1;
    return this;
  } else if (Array.isArray(selector)) {
    [].push.apply(this, selector);
    return this;
  }
  return renderer(selector.toArray ? selector.toArray() : [selector]);
};
renderer = function(selector, context2) {
  return new initRender(selector, context2);
};
renderer.fn = {
  dxRenderer: true
};
initRender.prototype = renderer.fn;
var repeatMethod = function(methodName, args) {
  for (let i = 0; i < this.length; i++) {
    const item = renderer(this[i]);
    item[methodName].apply(item, args);
  }
  return this;
};
var setAttributeValue = function(element, attrName, value2) {
  if (void 0 !== value2 && null !== value2 && false !== value2) {
    dom_adapter_default.setAttribute(element, attrName, value2);
  } else {
    dom_adapter_default.removeAttribute(element, attrName);
  }
};
initRender.prototype.show = function() {
  return this.toggle(true);
};
initRender.prototype.hide = function() {
  return this.toggle(false);
};
initRender.prototype.toggle = function(value2) {
  if (this[0]) {
    this.toggleClass("dx-state-invisible", !value2);
  }
  return this;
};
initRender.prototype.attr = function(attrName, value2) {
  if (this.length > 1 && arguments.length > 1) {
    return repeatMethod.call(this, "attr", arguments);
  }
  if (!this[0]) {
    if (isObject(attrName) || void 0 !== value2) {
      return this;
    } else {
      return;
    }
  }
  if (!this[0].getAttribute) {
    return this.prop(attrName, value2);
  }
  if ("string" === typeof attrName && 1 === arguments.length) {
    const result2 = this[0].getAttribute(attrName);
    return null == result2 ? void 0 : result2;
  } else if (isPlainObject(attrName)) {
    for (const key in attrName) {
      this.attr(key, attrName[key]);
    }
  } else {
    setAttributeValue(this[0], attrName, value2);
  }
  return this;
};
initRender.prototype.removeAttr = function(attrName) {
  this[0] && dom_adapter_default.removeAttribute(this[0], attrName);
  return this;
};
initRender.prototype.prop = function(propName, value2) {
  if (!this[0]) {
    return this;
  }
  if ("string" === typeof propName && 1 === arguments.length) {
    return this[0][propName];
  } else if (isPlainObject(propName)) {
    for (const key in propName) {
      this.prop(key, propName[key]);
    }
  } else {
    dom_adapter_default.setProperty(this[0], propName, value2);
  }
  return this;
};
initRender.prototype.addClass = function(className) {
  return this.toggleClass(className, true);
};
initRender.prototype.removeClass = function(className) {
  return this.toggleClass(className, false);
};
initRender.prototype.hasClass = function(className) {
  if (!this[0] || void 0 === this[0].className) {
    return false;
  }
  const classNames = className.split(" ");
  for (let i = 0; i < classNames.length; i++) {
    if (this[0].classList) {
      if (this[0].classList.contains(classNames[i])) {
        return true;
      }
    } else {
      const className2 = isString(this[0].className) ? this[0].className : dom_adapter_default.getAttribute(this[0], "class");
      if ((className2 || "").split(" ").indexOf(classNames[i]) >= 0) {
        return true;
      }
    }
  }
  return false;
};
initRender.prototype.toggleClass = function(className, value2) {
  if (this.length > 1) {
    return repeatMethod.call(this, "toggleClass", arguments);
  }
  if (!this[0] || !className) {
    return this;
  }
  value2 = void 0 === value2 ? !this.hasClass(className) : value2;
  const classNames = className.split(" ");
  for (let i = 0; i < classNames.length; i++) {
    dom_adapter_default.setClass(this[0], classNames[i], value2);
  }
  return this;
};
initRender.prototype.html = function(value2) {
  if (!arguments.length) {
    return this[0].innerHTML;
  }
  this.empty();
  if ("string" === typeof value2 && !isTablePart(value2) || "number" === typeof value2) {
    this[0].innerHTML = value2;
    return this;
  }
  return this.append(parseHTML(value2));
};
var appendElements = function(element, nextSibling) {
  if (!this[0] || !element) {
    return;
  }
  if ("string" === typeof element) {
    element = parseHTML(element);
  } else if (element.nodeType) {
    element = [element];
  } else if (isNumeric(element)) {
    element = [dom_adapter_default.createTextNode(element)];
  }
  for (let i = 0; i < element.length; i++) {
    const item = element[i];
    let container = this[0];
    const wrapTR = "TABLE" === container.tagName && "TR" === item.tagName;
    if (wrapTR && container.tBodies && container.tBodies.length) {
      container = container.tBodies[0];
    }
    dom_adapter_default.insertElement(container, item.nodeType ? item : item[0], nextSibling);
  }
};
var setCss = function(name2, value2) {
  if (!this[0] || !this[0].style) {
    return;
  }
  if (null === value2 || "number" === typeof value2 && isNaN(value2)) {
    return;
  }
  name2 = styleProp(name2);
  for (let i = 0; i < this.length; i++) {
    this[i].style[name2] = normalizeStyleProp(name2, value2);
  }
};
initRender.prototype.css = function(name2, value2) {
  if (isString(name2)) {
    if (2 === arguments.length) {
      setCss.call(this, name2, value2);
    } else {
      if (!this[0]) {
        return;
      }
      name2 = styleProp(name2);
      const result2 = window4.getComputedStyle(this[0])[name2] || this[0].style[name2];
      return isNumeric(result2) ? result2.toString() : result2;
    }
  } else if (isPlainObject(name2)) {
    for (const key in name2) {
      setCss.call(this, key, name2[key]);
    }
  }
  return this;
};
initRender.prototype.prepend = function(element) {
  if (arguments.length > 1) {
    for (let i = 0; i < arguments.length; i++) {
      this.prepend(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element, this[0].firstChild]);
  return this;
};
initRender.prototype.append = function(element) {
  if (arguments.length > 1) {
    for (let i = 0; i < arguments.length; i++) {
      this.append(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element]);
  return this;
};
initRender.prototype.prependTo = function(element) {
  if (this.length > 1) {
    for (let i = this.length - 1; i >= 0; i--) {
      renderer(this[i]).prependTo(element);
    }
    return this;
  }
  element = renderer(element);
  if (element[0]) {
    dom_adapter_default.insertElement(element[0], this[0], element[0].firstChild);
  }
  return this;
};
initRender.prototype.appendTo = function(element) {
  if (this.length > 1) {
    return repeatMethod.call(this, "appendTo", arguments);
  }
  dom_adapter_default.insertElement(renderer(element)[0], this[0]);
  return this;
};
initRender.prototype.insertBefore = function(element) {
  if (element && element[0]) {
    dom_adapter_default.insertElement(element[0].parentNode, this[0], element[0]);
  }
  return this;
};
initRender.prototype.insertAfter = function(element) {
  if (element && element[0]) {
    dom_adapter_default.insertElement(element[0].parentNode, this[0], element[0].nextSibling);
  }
  return this;
};
initRender.prototype.before = function(element) {
  if (this[0]) {
    dom_adapter_default.insertElement(this[0].parentNode, element[0], this[0]);
  }
  return this;
};
initRender.prototype.after = function(element) {
  if (this[0]) {
    dom_adapter_default.insertElement(this[0].parentNode, element[0], this[0].nextSibling);
  }
  return this;
};
initRender.prototype.wrap = function(wrapper) {
  if (this[0]) {
    const wrap = renderer(wrapper);
    wrap.insertBefore(this);
    wrap.append(this);
  }
  return this;
};
initRender.prototype.wrapInner = function(wrapper) {
  const contents = this.contents();
  if (contents.length) {
    contents.wrap(wrapper);
  } else {
    this.append(wrapper);
  }
  return this;
};
initRender.prototype.replaceWith = function(element) {
  if (!(element && element[0])) {
    return;
  }
  if (element.is(this)) {
    return this;
  }
  element.insertBefore(this);
  this.remove();
  return element;
};
initRender.prototype.remove = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "remove", arguments);
  }
  cleanDataRecursive(this[0], true);
  dom_adapter_default.removeElement(this[0]);
  return this;
};
initRender.prototype.detach = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "detach", arguments);
  }
  dom_adapter_default.removeElement(this[0]);
  return this;
};
initRender.prototype.empty = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "empty", arguments);
  }
  cleanDataRecursive(this[0]);
  dom_adapter_default.setText(this[0], "");
  return this;
};
initRender.prototype.clone = function() {
  const result2 = [];
  for (let i = 0; i < this.length; i++) {
    result2.push(this[i].cloneNode(true));
  }
  return renderer(result2);
};
initRender.prototype.text = function(value2) {
  if (!arguments.length) {
    let result2 = "";
    for (let i = 0; i < this.length; i++) {
      result2 += this[i] && this[i].textContent || "";
    }
    return result2;
  }
  const text = isFunction(value2) ? value2() : value2;
  cleanDataRecursive(this[0], false);
  dom_adapter_default.setText(this[0], isDefined(text) ? text : "");
  return this;
};
initRender.prototype.val = function(value2) {
  if (1 === arguments.length) {
    return this.prop("value", isDefined(value2) ? value2 : "");
  }
  return this.prop("value");
};
initRender.prototype.contents = function() {
  if (!this[0]) {
    return renderer();
  }
  const result2 = [];
  result2.push.apply(result2, this[0].childNodes);
  return renderer(result2);
};
initRender.prototype.find = function(selector) {
  const result2 = renderer();
  if (!selector) {
    return result2;
  }
  const nodes = [];
  let i;
  if ("string" === typeof selector) {
    selector = selector.trim();
    for (i = 0; i < this.length; i++) {
      const element = this[i];
      if (dom_adapter_default.isElementNode(element)) {
        const elementId = element.getAttribute("id");
        let queryId = elementId || "dx-query-children";
        if (!elementId) {
          setAttributeValue(element, "id", queryId);
        }
        queryId = "[id='" + queryId + "'] ";
        const querySelector = queryId + selector.replace(/([^\\])(,)/g, "$1, " + queryId);
        nodes.push.apply(nodes, dom_adapter_default.querySelectorAll(element, querySelector));
        setAttributeValue(element, "id", elementId);
      } else if (dom_adapter_default.isDocument(element) || dom_adapter_default.isDocumentFragment(element)) {
        nodes.push.apply(nodes, dom_adapter_default.querySelectorAll(element, selector));
      }
    }
  } else {
    for (i = 0; i < this.length; i++) {
      selector = dom_adapter_default.isNode(selector) ? selector : selector[0];
      if (this[i] !== selector && this[i].contains(selector)) {
        nodes.push(selector);
      }
    }
  }
  return result2.add(nodes);
};
var isVisible = function(_, element) {
  element = element.host ?? element;
  if (!element.nodeType) {
    return true;
  }
  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
};
initRender.prototype.filter = function(selector) {
  if (!selector) {
    return renderer();
  }
  if (":visible" === selector) {
    return this.filter(isVisible);
  } else if (":hidden" === selector) {
    return this.filter(function(_, element) {
      return !isVisible(0, element);
    });
  }
  const result2 = [];
  for (let i = 0; i < this.length; i++) {
    const item = this[i];
    if (dom_adapter_default.isElementNode(item) && "string" === type(selector)) {
      dom_adapter_default.elementMatches(item, selector) && result2.push(item);
    } else if (dom_adapter_default.isNode(selector) || isWindow(selector)) {
      selector === item && result2.push(item);
    } else if (isFunction(selector)) {
      selector.call(item, i, item) && result2.push(item);
    } else {
      for (let j = 0; j < selector.length; j++) {
        selector[j] === item && result2.push(item);
      }
    }
  }
  return renderer(result2);
};
initRender.prototype.not = function(selector) {
  const result2 = [];
  const nodes = this.filter(selector).toArray();
  for (let i = 0; i < this.length; i++) {
    if (-1 === nodes.indexOf(this[i])) {
      result2.push(this[i]);
    }
  }
  return renderer(result2);
};
initRender.prototype.is = function(selector) {
  return !!this.filter(selector).length;
};
initRender.prototype.children = function(selector) {
  let result2 = [];
  for (let i = 0; i < this.length; i++) {
    const nodes = this[i] ? this[i].childNodes : [];
    for (let j = 0; j < nodes.length; j++) {
      if (dom_adapter_default.isElementNode(nodes[j])) {
        result2.push(nodes[j]);
      }
    }
  }
  result2 = renderer(result2);
  return selector ? result2.filter(selector) : result2;
};
initRender.prototype.siblings = function() {
  const element = this[0];
  if (!element || !element.parentNode) {
    return renderer();
  }
  const result2 = [];
  const parentChildNodes = element.parentNode.childNodes || [];
  for (let i = 0; i < parentChildNodes.length; i++) {
    const node = parentChildNodes[i];
    if (dom_adapter_default.isElementNode(node) && node !== element) {
      result2.push(node);
    }
  }
  return renderer(result2);
};
initRender.prototype.each = function(callback) {
  for (let i = 0; i < this.length; i++) {
    if (false === callback.call(this[i], i, this[i])) {
      break;
    }
  }
};
initRender.prototype.index = function(element) {
  if (!element) {
    return this.parent().children().index(this);
  }
  element = renderer(element);
  return this.toArray().indexOf(element[0]);
};
initRender.prototype.get = function(index2) {
  return this[index2 < 0 ? this.length + index2 : index2];
};
initRender.prototype.eq = function(index2) {
  index2 = index2 < 0 ? this.length + index2 : index2;
  return renderer(this[index2]);
};
initRender.prototype.first = function() {
  return this.eq(0);
};
initRender.prototype.last = function() {
  return this.eq(-1);
};
initRender.prototype.select = function() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].select && this[i].select();
  }
  return this;
};
initRender.prototype.parent = function(selector) {
  if (!this[0]) {
    return renderer();
  }
  const result2 = renderer(this[0].parentNode);
  return !selector || result2.is(selector) ? result2 : renderer();
};
initRender.prototype.parents = function(selector) {
  const result2 = [];
  let parent = this.parent();
  while (parent && parent[0] && !dom_adapter_default.isDocument(parent[0])) {
    if (dom_adapter_default.isElementNode(parent[0])) {
      if (!selector || parent.is(selector)) {
        result2.push(parent.get(0));
      }
    }
    parent = parent.parent();
  }
  return renderer(result2);
};
initRender.prototype.closest = function(selector) {
  if (this.is(selector)) {
    return this;
  }
  let parent = this.parent();
  while (parent && parent.length) {
    if (parent.is(selector)) {
      return parent;
    }
    parent = parent.parent();
  }
  return renderer();
};
initRender.prototype.next = function(selector) {
  if (!this[0]) {
    return renderer();
  }
  let next = renderer(this[0].nextSibling);
  if (!arguments.length) {
    return next;
  }
  while (next && next.length) {
    if (next.is(selector)) {
      return next;
    }
    next = next.next();
  }
  return renderer();
};
initRender.prototype.prev = function() {
  if (!this[0]) {
    return renderer();
  }
  return renderer(this[0].previousSibling);
};
initRender.prototype.add = function(selector) {
  const targets = renderer(selector);
  const result2 = this.toArray();
  for (let i = 0; i < targets.length; i++) {
    const target = targets[i];
    if (-1 === result2.indexOf(target)) {
      result2.push(target);
    }
  }
  return renderer(result2);
};
var emptyArray = [];
initRender.prototype.splice = function() {
  return renderer(emptyArray.splice.apply(this, arguments));
};
initRender.prototype.slice = function() {
  return renderer(emptyArray.slice.apply(this, arguments));
};
initRender.prototype.toArray = function() {
  return emptyArray.slice.call(this);
};
initRender.prototype.offset = function() {
  if (!this[0]) {
    return;
  }
  return getOffset(this[0]);
};
initRender.prototype.offsetParent = function() {
  if (!this[0]) {
    return renderer();
  }
  let offsetParent = renderer(this[0].offsetParent);
  while (offsetParent[0] && "static" === offsetParent.css("position")) {
    offsetParent = renderer(offsetParent[0].offsetParent);
  }
  offsetParent = offsetParent[0] ? offsetParent : renderer(dom_adapter_default.getDocumentElement());
  return offsetParent;
};
initRender.prototype.position = function() {
  if (!this[0]) {
    return;
  }
  let offset2;
  const marginTop = parseFloat(this.css("marginTop"));
  const marginLeft = parseFloat(this.css("marginLeft"));
  if ("fixed" === this.css("position")) {
    offset2 = this[0].getBoundingClientRect();
    return {
      top: offset2.top - marginTop,
      left: offset2.left - marginLeft
    };
  }
  offset2 = this.offset();
  const offsetParent = this.offsetParent();
  let parentOffset = {
    top: 0,
    left: 0
  };
  if ("HTML" !== offsetParent[0].nodeName) {
    parentOffset = offsetParent.offset();
  }
  parentOffset = {
    top: parentOffset.top + parseFloat(offsetParent.css("borderTopWidth")),
    left: parentOffset.left + parseFloat(offsetParent.css("borderLeftWidth"))
  };
  return {
    top: offset2.top - parentOffset.top - marginTop,
    left: offset2.left - parentOffset.left - marginLeft
  };
};
[{
  name: "scrollLeft",
  offsetProp: "pageXOffset",
  scrollWindow: function(win, value2) {
    win.scrollTo(value2, win.pageYOffset);
  }
}, {
  name: "scrollTop",
  offsetProp: "pageYOffset",
  scrollWindow: function(win, value2) {
    win.scrollTo(win.pageXOffset, value2);
  }
}].forEach(function(directionStrategy) {
  const propName = directionStrategy.name;
  initRender.prototype[propName] = function(value2) {
    if (!this[0]) {
      return;
    }
    const window28 = getWindowByElement(this[0]);
    if (void 0 === value2) {
      return window28 ? window28[directionStrategy.offsetProp] : this[0][propName];
    }
    if (window28) {
      directionStrategy.scrollWindow(window28, value2);
    } else {
      this[0][propName] = value2;
    }
    return this;
  };
});
initRender.prototype.data = function(key, value2) {
  if (!this[0]) {
    return;
  }
  if (arguments.length < 2) {
    return data.call(renderer, this[0], key);
  }
  data.call(renderer, this[0], key, value2);
  return this;
};
initRender.prototype.removeData = function(key) {
  this[0] && removeData(this[0], key);
  return this;
};
var rendererWrapper = function() {
  return renderer.apply(this, arguments);
};
Object.defineProperty(rendererWrapper, "fn", {
  enumerable: true,
  configurable: true,
  get: function() {
    return renderer.fn;
  },
  set: function(value2) {
    renderer.fn = value2;
  }
});
var renderer_base_default = {
  set: function(strategy4) {
    renderer = strategy4;
  },
  get: function() {
    return rendererWrapper;
  }
};

// ../../../../../../node_modules/devextreme/esm/core/renderer.js
var renderer_default = renderer_base_default.get();

// ../../../../../../node_modules/devextreme/esm/core/component_registrator_callbacks.js
var component_registrator_callbacks_default = new MemorizedCallbacks();

// ../../../../../../node_modules/devextreme/esm/events/core/event_registrator.js
var registerEvent = function(name2, eventObject) {
  const strategy4 = {};
  if ("noBubble" in eventObject) {
    strategy4.noBubble = eventObject.noBubble;
  }
  if ("bindType" in eventObject) {
    strategy4.bindType = eventObject.bindType;
  }
  if ("delegateType" in eventObject) {
    strategy4.delegateType = eventObject.delegateType;
  }
  each(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], function(_, methodName) {
    if (!eventObject[methodName]) {
      return;
    }
    strategy4[methodName] = function() {
      const args = [].slice.call(arguments);
      args.unshift(this);
      return eventObject[methodName].apply(eventObject, args);
    };
  });
  event_registrator_callbacks_default.fire(name2, strategy4);
};
registerEvent.callbacks = event_registrator_callbacks_default;
var event_registrator_default = registerEvent;

// ../../../../../../node_modules/devextreme/esm/events/remove.js
var removeEvent = "dxremove";
var eventPropName = "dxRemoveEvent";
beforeCleanData(function(elements) {
  elements = [].slice.call(elements);
  for (let i = 0; i < elements.length; i++) {
    const $element = renderer_default(elements[i]);
    if ($element.prop(eventPropName)) {
      $element[0][eventPropName] = null;
      events_engine_default.triggerHandler($element, "dxremove");
    }
  }
});
event_registrator_default("dxremove", {
  noBubble: true,
  setup: function(element) {
    renderer_default(element).prop(eventPropName, true);
  }
});

// ../../../../../../node_modules/devextreme/esm/core/utils/public_component.js
var componentNames = /* @__PURE__ */ new WeakMap();
var nextAnonymousComponent = 0;
var getName = function(componentClass, newName) {
  if (isDefined(newName)) {
    componentNames.set(componentClass, newName);
    return;
  }
  if (!componentNames.has(componentClass)) {
    const generatedName = "dxPrivateComponent" + nextAnonymousComponent++;
    componentNames.set(componentClass, generatedName);
    return generatedName;
  }
  return componentNames.get(componentClass);
};
function attachInstanceToElement($element, componentInstance, disposeFn) {
  const data2 = data($element.get(0));
  const name2 = getName(componentInstance.constructor);
  data2[name2] = componentInstance;
  if (disposeFn) {
    events_engine_default.one($element, removeEvent, function() {
      disposeFn.call(componentInstance);
    });
  }
  if (!data2.dxComponents) {
    data2.dxComponents = [];
  }
  data2.dxComponents.push(name2);
}
function getInstanceByElement($element, componentClass) {
  const name2 = getName(componentClass);
  return data($element.get(0), name2);
}

// ../../../../../../node_modules/devextreme/esm/core/component_registrator.js
var registerComponent = function(name2, namespace, componentClass) {
  if (!componentClass) {
    componentClass = namespace;
  } else {
    namespace[name2] = componentClass;
  }
  getName(componentClass, name2);
  component_registrator_callbacks_default.fire(name2, componentClass);
};
var registerRendererComponent = function(name2, componentClass) {
  renderer_default.fn[name2] = function(options2) {
    const isMemberInvoke = "string" === typeof options2;
    let result2;
    if (isMemberInvoke) {
      const memberName = options2;
      const memberArgs = [].slice.call(arguments).slice(1);
      this.each(function() {
        const instance = componentClass.getInstance(this);
        if (!instance) {
          throw errors_default.Error("E0009", name2);
        }
        const member = instance[memberName];
        const memberValue = member.apply(instance, memberArgs);
        if (void 0 === result2) {
          result2 = memberValue;
        }
      });
    } else {
      this.each(function() {
        const instance = componentClass.getInstance(this);
        if (instance) {
          instance.option(options2);
        } else {
          new componentClass(this, options2);
        }
      });
      result2 = this;
    }
    return result2;
  };
};
component_registrator_callbacks_default.add(registerRendererComponent);
var component_registrator_default = registerComponent;

// ../../../../../../node_modules/devextreme/esm/core/utils/ready_callbacks.js
var callbacks = [];
var subscribeReady = call_once_default(() => {
  const removeListener = dom_adapter_default.listen(dom_adapter_default.getDocument(), "DOMContentLoaded", () => {
    readyCallbacks.fire();
    removeListener();
  });
});
var readyCallbacks = {
  add: (callback) => {
    const windowExists = hasWindow();
    if (windowExists && "loading" !== dom_adapter_default.getReadyState()) {
      callback();
    } else {
      callbacks.push(callback);
      windowExists && subscribeReady();
    }
  },
  fire: () => {
    callbacks.forEach((callback) => callback());
    callbacks = [];
  }
};
var ready_callbacks_default = dependency_injector_default(readyCallbacks);

// ../../../../../../node_modules/devextreme/esm/core/utils/resize_callbacks.js
var resizeCallbacks = function() {
  let prevSize;
  const callbacks2 = callbacks_default();
  const originalCallbacksAdd = callbacks2.add;
  const originalCallbacksRemove = callbacks2.remove;
  if (!hasWindow()) {
    return callbacks2;
  }
  const formatSize = function() {
    const window28 = getWindow();
    return {
      width: window28.innerWidth,
      height: window28.innerHeight
    };
  };
  const handleResize = function() {
    const now = formatSize();
    if (now.width === prevSize.width && now.height === prevSize.height) {
      return;
    }
    let changedDimension;
    if (now.width === prevSize.width) {
      changedDimension = "height";
    }
    if (now.height === prevSize.height) {
      changedDimension = "width";
    }
    prevSize = now;
    callbacks2.fire(changedDimension);
  };
  const setPrevSize = call_once_default(function() {
    prevSize = formatSize();
  });
  let removeListener;
  callbacks2.add = function() {
    const result2 = originalCallbacksAdd.apply(callbacks2, arguments);
    setPrevSize();
    ready_callbacks_default.add(function() {
      if (!removeListener && callbacks2.has()) {
        removeListener = dom_adapter_default.listen(getWindow(), "resize", handleResize);
      }
    });
    return result2;
  };
  callbacks2.remove = function() {
    const result2 = originalCallbacksRemove.apply(callbacks2, arguments);
    if (!callbacks2.has() && removeListener) {
      removeListener();
      removeListener = void 0;
    }
    return result2;
  };
  return callbacks2;
}();
var resize_callbacks_default = resizeCallbacks;

// ../../../../../../node_modules/devextreme/esm/core/events_strategy.js
var EventsStrategy = class _EventsStrategy {
  constructor(owner) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    this._events = {};
    this._owner = owner;
    this._options = options2;
  }
  static create(owner, strategy4) {
    if (strategy4) {
      return isFunction(strategy4) ? strategy4(owner) : strategy4;
    } else {
      return new _EventsStrategy(owner);
    }
  }
  hasEvent(eventName) {
    const callbacks2 = this._events[eventName];
    return callbacks2 ? callbacks2.has() : false;
  }
  fireEvent(eventName, eventArgs) {
    const callbacks2 = this._events[eventName];
    if (callbacks2) {
      callbacks2.fireWith(this._owner, eventArgs);
    }
    return this._owner;
  }
  on(eventName, eventHandler) {
    if (isPlainObject(eventName)) {
      each(eventName, (e, h2) => {
        this.on(e, h2);
      });
    } else {
      let callbacks2 = this._events[eventName];
      if (!callbacks2) {
        callbacks2 = callbacks_default({
          syncStrategy: this._options.syncStrategy
        });
        this._events[eventName] = callbacks2;
      }
      const addFn = callbacks2.originalAdd || callbacks2.add;
      addFn.call(callbacks2, eventHandler);
    }
  }
  off(eventName, eventHandler) {
    const callbacks2 = this._events[eventName];
    if (callbacks2) {
      if (isFunction(eventHandler)) {
        callbacks2.remove(eventHandler);
      } else {
        callbacks2.empty();
      }
    }
  }
  dispose() {
    each(this._events, (eventName, event) => {
      event.empty();
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/core/utils/storage.js
var window5 = getWindow();
var getSessionStorage = function() {
  let sessionStorage;
  try {
    sessionStorage = window5.sessionStorage;
  } catch (e) {
  }
  return sessionStorage;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/view_port.js
var ready = ready_callbacks_default.add;
var changeCallback = callbacks_default();
var $originalViewPort = renderer_default();
var value = function() {
  let $current;
  return function(element) {
    if (!arguments.length) {
      return $current;
    }
    const $element = renderer_default(element);
    $originalViewPort = $element;
    const isNewViewportFound = !!$element.length;
    const prevViewPort = value();
    $current = isNewViewportFound ? $element : renderer_default("body");
    changeCallback.fire(isNewViewportFound ? value() : renderer_default(), prevViewPort);
  };
}();
ready(function() {
  value(".dx-viewport");
});
function originalViewPort() {
  return $originalViewPort;
}

// ../../../../../../node_modules/devextreme/esm/core/devices.js
var window6 = getWindow();
var KNOWN_UA_TABLE = {
  iPhone: "iPhone",
  iPhone5: "iPhone",
  iPhone6: "iPhone",
  iPhone6plus: "iPhone",
  iPad: "iPad",
  iPadMini: "iPad Mini",
  androidPhone: "Android Mobile",
  androidTablet: "Android",
  msSurface: "Windows ARM Tablet PC",
  desktop: "desktop"
};
var DEFAULT_DEVICE = {
  deviceType: "desktop",
  platform: "generic",
  version: [],
  phone: false,
  tablet: false,
  android: false,
  ios: false,
  generic: true,
  grade: "A",
  mac: false
};
var UA_PARSERS = {
  generic(userAgent) {
    const isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/);
    const isTablet = !isPhone && /Windows(.*)arm(.*)Tablet PC/i.test(userAgent);
    const isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
    const isMac = /((intel|ppc) mac os x)/.test(userAgent.toLowerCase());
    if (!(isPhone || isTablet || isDesktop || isMac)) {
      return null;
    }
    return {
      deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
      platform: "generic",
      version: [],
      grade: "A",
      mac: isMac
    };
  },
  appleTouchDevice(userAgent) {
    const navigator3 = getNavigator();
    const isIpadOs = /Macintosh/i.test(userAgent) && (null === navigator3 || void 0 === navigator3 ? void 0 : navigator3.maxTouchPoints) > 2;
    const isAppleDevice = /ip(hone|od|ad)/i.test(userAgent);
    if (!isAppleDevice && !isIpadOs) {
      return null;
    }
    const isPhone = /ip(hone|od)/i.test(userAgent);
    const matches = userAgent.match(/os\s{0,}X? (\d+)_(\d+)_?(\d+)?/i);
    const version3 = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
    const isIPhone4 = 480 === window6.screen.height;
    const grade = isIPhone4 ? "B" : "A";
    return {
      deviceType: isPhone ? "phone" : "tablet",
      platform: "ios",
      version: version3,
      grade
    };
  },
  android(userAgent) {
    const isAndroid = /android|htc_|silk/i.test(userAgent);
    const isWinPhone = /windows phone/i.test(userAgent);
    if (!isAndroid || isWinPhone) {
      return null;
    }
    const isPhone = /mobile/i.test(userAgent);
    const matches = userAgent.match(/android (\d+)\.?(\d+)?\.?(\d+)?/i);
    const version3 = matches ? [parseInt(matches[1], 10), parseInt(matches[2] || 0, 10), parseInt(matches[3] || 0, 10)] : [];
    const worseThan4_4 = version3.length > 1 && (version3[0] < 4 || 4 === version3[0] && version3[1] < 4);
    const grade = worseThan4_4 ? "B" : "A";
    return {
      deviceType: isPhone ? "phone" : "tablet",
      platform: "android",
      version: version3,
      grade
    };
  }
};
var UA_PARSERS_ARRAY = [UA_PARSERS.appleTouchDevice, UA_PARSERS.android, UA_PARSERS.generic];
var Devices = class {
  constructor(options2) {
    this._window = (null === options2 || void 0 === options2 ? void 0 : options2.window) || window6;
    this._realDevice = this._getDevice();
    this._currentDevice = void 0;
    this._currentOrientation = void 0;
    this._eventsStrategy = new EventsStrategy(this);
    this.changed = callbacks_default();
    if (hasWindow()) {
      ready_callbacks_default.add(this._recalculateOrientation.bind(this));
      resize_callbacks_default.add(this._recalculateOrientation.bind(this));
    }
  }
  current(deviceOrName) {
    if (deviceOrName) {
      this._currentDevice = this._getDevice(deviceOrName);
      this._forced = true;
      this.changed.fire();
      return;
    }
    if (!this._currentDevice) {
      deviceOrName = void 0;
      try {
        deviceOrName = this._getDeviceOrNameFromWindowScope();
      } catch (e) {
        deviceOrName = this._getDeviceNameFromSessionStorage();
      } finally {
        if (!deviceOrName) {
          deviceOrName = this._getDeviceNameFromSessionStorage();
        }
        if (deviceOrName) {
          this._forced = true;
        }
      }
      this._currentDevice = this._getDevice(deviceOrName);
    }
    return this._currentDevice;
  }
  real(forceDevice) {
    return extend({}, this._realDevice);
  }
  orientation() {
    return this._currentOrientation;
  }
  isForced() {
    return this._forced;
  }
  isRippleEmulator() {
    return !!this._window.tinyHippos;
  }
  _getCssClasses(device) {
    const result2 = [];
    const realDevice2 = this._realDevice;
    device = device || this.current();
    if (device.deviceType) {
      result2.push(`dx-device-${device.deviceType}`);
      if ("desktop" !== device.deviceType) {
        result2.push("dx-device-mobile");
      }
    }
    result2.push(`dx-device-${realDevice2.platform}`);
    if (realDevice2.version && realDevice2.version.length) {
      result2.push(`dx-device-${realDevice2.platform}-${realDevice2.version[0]}`);
    }
    if (this.isSimulator()) {
      result2.push("dx-simulator");
    }
    if (config_default().rtlEnabled) {
      result2.push("dx-rtl");
    }
    return result2;
  }
  attachCssClasses(element, device) {
    this._deviceClasses = this._getCssClasses(device).join(" ");
    renderer_default(element).addClass(this._deviceClasses);
  }
  detachCssClasses(element) {
    renderer_default(element).removeClass(this._deviceClasses);
  }
  isSimulator() {
    try {
      return this._isSimulator || hasWindow() && this._window.top !== this._window.self && this._window.top["dx-force-device"] || this.isRippleEmulator();
    } catch (e) {
      return false;
    }
  }
  forceSimulator() {
    this._isSimulator = true;
  }
  _getDevice(deviceName) {
    if ("genericPhone" === deviceName) {
      deviceName = {
        deviceType: "phone",
        platform: "generic",
        generic: true
      };
    }
    if (isPlainObject(deviceName)) {
      return this._fromConfig(deviceName);
    } else {
      let ua;
      if (deviceName) {
        ua = KNOWN_UA_TABLE[deviceName];
        if (!ua) {
          throw errors_default.Error("E0005");
        }
      } else {
        const navigator3 = getNavigator();
        ua = navigator3.userAgent;
      }
      return this._fromUA(ua);
    }
  }
  _getDeviceOrNameFromWindowScope() {
    let result2;
    if (hasWindow() && (this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"])) {
      result2 = this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"];
    }
    return result2;
  }
  _getDeviceNameFromSessionStorage() {
    const sessionStorage = getSessionStorage();
    if (!sessionStorage) {
      return;
    }
    const deviceOrName = sessionStorage.getItem("dx-force-device");
    try {
      return JSON.parse(deviceOrName);
    } catch (ex) {
      return deviceOrName;
    }
  }
  _fromConfig(config3) {
    const result2 = extend({}, DEFAULT_DEVICE, this._currentDevice, config3);
    const shortcuts = {
      phone: "phone" === result2.deviceType,
      tablet: "tablet" === result2.deviceType,
      android: "android" === result2.platform,
      ios: "ios" === result2.platform,
      generic: "generic" === result2.platform
    };
    return extend(result2, shortcuts);
  }
  _fromUA(ua) {
    for (let idx = 0; idx < UA_PARSERS_ARRAY.length; idx += 1) {
      const parser = UA_PARSERS_ARRAY[idx];
      const config3 = parser(ua);
      if (config3) {
        return this._fromConfig(config3);
      }
    }
    return DEFAULT_DEVICE;
  }
  _changeOrientation() {
    const $window = renderer_default(this._window);
    const orientation = getHeight($window) > getWidth($window) ? "portrait" : "landscape";
    if (this._currentOrientation === orientation) {
      return;
    }
    this._currentOrientation = orientation;
    this._eventsStrategy.fireEvent("orientationChanged", [{
      orientation
    }]);
  }
  _recalculateOrientation() {
    const windowWidth = getWidth(this._window);
    if (this._currentWidth === windowWidth) {
      return;
    }
    this._currentWidth = windowWidth;
    this._changeOrientation();
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
};
var devices = new Devices();
var viewPortElement = value();
if (viewPortElement) {
  devices.attachCssClasses(viewPortElement);
}
changeCallback.add((viewPort2, prevViewport) => {
  devices.detachCssClasses(prevViewport);
  devices.attachCssClasses(viewPort2);
});
var devices_default = devices;

// ../../../../../../node_modules/devextreme/esm/core/element.js
function getPublicElementNonJquery(element) {
  if (element && element.get) {
    return element.get(0);
  }
  return element;
}
var strategy2 = getPublicElementNonJquery;
function getPublicElement(element) {
  return strategy2(element);
}

// ../../../../../../node_modules/devextreme/esm/core/utils/dom.js
var window7 = getWindow();
var getRootNodeHost = (element) => {
  if (!element.getRootNode) {
    return;
  }
  const host = element.getRootNode().host;
  if (isString(host)) {
    return;
  }
  return host;
};
var resetActiveElement = () => {
  const activeElement = dom_adapter_default.getActiveElement();
  if (activeElement && activeElement !== dom_adapter_default.getBody()) {
    var _activeElement$blur;
    null === (_activeElement$blur = activeElement.blur) || void 0 === _activeElement$blur || _activeElement$blur.call(activeElement);
  }
};
var clearSelection = () => {
  const selection = window7.getSelection();
  if (!selection) {
    return;
  }
  if ("Caret" === selection.type) {
    return;
  }
  if (selection.empty) {
    selection.empty();
  } else if (selection.removeAllRanges) {
    try {
      selection.removeAllRanges();
    } catch (e) {
    }
  }
};
var closestCommonParent = (startTarget, endTarget) => {
  const $startTarget = renderer_default(startTarget);
  const $endTarget = renderer_default(endTarget);
  if ($startTarget[0] === $endTarget[0]) {
    return $startTarget[0];
  }
  const $startParents = $startTarget.parents();
  const $endParents = $endTarget.parents();
  const startingParent = Math.min($startParents.length, $endParents.length);
  for (let i = -startingParent; i < 0; i++) {
    if ($startParents.get(i) === $endParents.get(i)) {
      return $startParents.get(i);
    }
  }
};
var normalizeTemplateElement = (element) => {
  let $element = isDefined(element) && (element.nodeType || isRenderer(element)) ? renderer_default(element) : renderer_default("<div>").html(element).contents();
  if (1 === $element.length) {
    if ($element.is("script")) {
      $element = normalizeTemplateElement($element.html().trim());
    } else if ($element.is("table")) {
      $element = $element.children("tbody").contents();
    }
  }
  return $element;
};
var clipboardText = (event, text) => {
  const clipboard = event.originalEvent && event.originalEvent.clipboardData || window7.clipboardData;
  if (!text) {
    return clipboard && clipboard.getData("Text");
  }
  clipboard && clipboard.setData("Text", text);
};
var contains2 = (container, element) => {
  if (!element) {
    return false;
  }
  if (isWindow(container)) {
    return contains2(container.document, element);
  }
  return container.contains(element) || contains2(container, getRootNodeHost(element));
};
var createTextElementHiddenCopy = (element, text, options2) => {
  const elementStyles = window7.getComputedStyle(renderer_default(element).get(0));
  const includePaddings = options2 && options2.includePaddings;
  return renderer_default("<div>").text(text).css({
    fontStyle: elementStyles.fontStyle,
    fontVariant: elementStyles.fontVariant,
    fontWeight: elementStyles.fontWeight,
    fontSize: elementStyles.fontSize,
    fontFamily: elementStyles.fontFamily,
    letterSpacing: elementStyles.letterSpacing,
    border: elementStyles.border,
    paddingTop: includePaddings ? elementStyles.paddingTop : "",
    paddingRight: includePaddings ? elementStyles.paddingRight : "",
    paddingBottom: includePaddings ? elementStyles.paddingBottom : "",
    paddingLeft: includePaddings ? elementStyles.paddingLeft : "",
    visibility: "hidden",
    whiteSpace: "pre",
    position: "absolute",
    float: "left"
  });
};
var insertBefore = (element, newElement) => {
  if (newElement) {
    dom_adapter_default.insertElement(element.parentNode, newElement, element);
  }
  return element;
};
var replaceWith = (element, newElement) => {
  if (!(newElement && newElement[0])) {
    return;
  }
  if (newElement.is(element)) {
    return element;
  }
  each(newElement, (_, currentElement) => {
    insertBefore(element[0], currentElement);
  });
  element.remove();
  return newElement;
};
var isElementInDom = ($element) => {
  const element = null === $element || void 0 === $element ? void 0 : $element.get(0);
  const shadowHost = null === element || void 0 === element ? void 0 : element.getRootNode().host;
  return !!renderer_default(shadowHost || element).closest(getWindow().document).length;
};

// ../../../../../../node_modules/devextreme/esm/events/visibility_change.js
var triggerVisibilityChangeEvent = function(eventName) {
  return function(element) {
    const $element = renderer_default(element || "body");
    const changeHandlers = $element.filter(".dx-visibility-change-handler").add($element.find(".dx-visibility-change-handler"));
    for (let i = 0; i < changeHandlers.length; i++) {
      events_engine_default.triggerHandler(changeHandlers[i], eventName);
    }
  };
};
var triggerShownEvent = triggerVisibilityChangeEvent("dxshown");
var triggerHidingEvent = triggerVisibilityChangeEvent("dxhiding");
var triggerResizeEvent = triggerVisibilityChangeEvent("dxresize");

// ../../../../../../node_modules/devextreme/esm/core/templates/template_base.js
var renderedCallbacks = callbacks_default({
  syncStrategy: true
});
var TemplateBase = class {
  render(options2) {
    options2 = options2 || {};
    const onRendered = options2.onRendered;
    delete options2.onRendered;
    let $result;
    if (options2.renovated && options2.transclude && this._element) {
      $result = renderer_default("<div>").append(this._element).contents();
    } else {
      $result = this._renderCore(options2);
    }
    this._ensureResultInContainer($result, options2.container);
    renderedCallbacks.fire($result, options2.container);
    onRendered && onRendered();
    return $result;
  }
  _ensureResultInContainer($result, container) {
    if (!container) {
      return;
    }
    const $container = renderer_default(container);
    const resultInContainer = contains2($container.get(0), $result.get(0));
    $container.append($result);
    if (resultInContainer) {
      return;
    }
    const resultInBody = contains2(dom_adapter_default.getBody(), $container.get(0));
    if (!resultInBody) {
      return;
    }
    triggerShownEvent($result);
  }
  _renderCore() {
    throw errors_default.Error("E0001");
  }
};

// ../../../../../../node_modules/devextreme/esm/core/templates/bindable_template.js
var watchChanges = function(rawData, watchMethod, fields, fieldsMap, callback) {
  let fieldsDispose;
  const globalDispose = ((data2, watchMethod2, callback2) => watchMethod2(() => data2, callback2))(rawData, watchMethod, function(dataWithRawFields) {
    fieldsDispose && fieldsDispose();
    if (isPrimitive(dataWithRawFields)) {
      callback(dataWithRawFields);
      return;
    }
    fieldsDispose = function(data2, watchMethod2, fields2, fieldsMap2, callback2) {
      const resolvedData = {};
      const missedFields = fields2.slice();
      const watchHandlers = fields2.map(function(name2) {
        const fieldGetter = fieldsMap2[name2];
        return watchMethod2(fieldGetter ? () => fieldGetter(data2) : () => data2[name2], function(value2) {
          resolvedData[name2] = value2;
          if (missedFields.length) {
            const index2 = missedFields.indexOf(name2);
            if (index2 >= 0) {
              missedFields.splice(index2, 1);
            }
          }
          if (!missedFields.length) {
            callback2(resolvedData);
          }
        });
      });
      return function() {
        watchHandlers.forEach((dispose) => dispose());
      };
    }(dataWithRawFields, watchMethod, fields, fieldsMap, callback);
  });
  return function() {
    fieldsDispose && fieldsDispose();
    globalDispose && globalDispose();
  };
};
var BindableTemplate = class extends TemplateBase {
  constructor(render4, fields, watchMethod, fieldsMap) {
    super();
    this._render = render4;
    this._fields = fields;
    this._fieldsMap = fieldsMap || {};
    this._watchMethod = watchMethod;
  }
  _renderCore(options2) {
    const $container = renderer_default(options2.container);
    const dispose = watchChanges(options2.model, this._watchMethod, this._fields, this._fieldsMap, (data2) => {
      $container.empty();
      this._render($container, data2, options2.model);
    });
    events_engine_default.on($container, removeEvent, dispose);
    return $container.contents();
  }
};

// ../../../../../../node_modules/devextreme/esm/core/templates/empty_template.js
var EmptyTemplate = class extends TemplateBase {
  _renderCore() {
    return renderer_default();
  }
};

// ../../../../../../node_modules/devextreme/esm/core/utils/math.js
var sign = function(value2) {
  if (0 === value2) {
    return 0;
  }
  return value2 / Math.abs(value2);
};
var fitIntoRange = function(value2, minValue, maxValue) {
  const isMinValueUndefined = !minValue && 0 !== minValue;
  const isMaxValueUndefined = !maxValue && 0 !== maxValue;
  isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value2, maxValue) : value2);
  isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value2, minValue) : value2);
  return Math.min(Math.max(value2, minValue), maxValue);
};
var inRange = function(value2, minValue, maxValue) {
  return value2 >= minValue && value2 <= maxValue;
};
function getExponent(value2) {
  return Math.abs(parseInt(value2.toExponential().split("e")[1]));
}
function getExponentialNotation(value2) {
  const parts = value2.toExponential().split("e");
  const mantissa = parseFloat(parts[0]);
  const exponent = parseInt(parts[1]);
  return {
    exponent,
    mantissa
  };
}
function multiplyInExponentialForm(value2, exponentShift) {
  const exponentialNotation = getExponentialNotation(value2);
  return parseFloat(`${exponentialNotation.mantissa}e${exponentialNotation.exponent + exponentShift}`);
}
function _isEdgeBug() {
  return "0.000300" !== 3e-4.toPrecision(3);
}
function adjust(value2, interval) {
  let precision = getPrecision(interval || 0) + 2;
  const separatedValue = value2.toString().split(".");
  const sourceValue = value2;
  const absValue = Math.abs(value2);
  let separatedAdjustedValue;
  const isExponentValue = isExponential(value2);
  const integerPart = absValue > 1 ? 10 : 0;
  if (1 === separatedValue.length) {
    return value2;
  }
  if (!isExponentValue) {
    if (isExponential(interval)) {
      precision = separatedValue[0].length + getExponent(interval);
    }
    value2 = absValue;
    value2 = value2 - Math.floor(value2) + integerPart;
  }
  precision = _isEdgeBug() && getExponent(value2) > 6 || precision > 7 ? 15 : 7;
  if (!isExponentValue) {
    separatedAdjustedValue = parseFloat(value2.toPrecision(precision)).toString().split(".");
    if (separatedAdjustedValue[0] === integerPart.toString()) {
      return parseFloat(separatedValue[0] + "." + separatedAdjustedValue[1]);
    }
  }
  return parseFloat(sourceValue.toPrecision(precision));
}
function getPrecision(value2) {
  const str = value2.toString();
  if (str.indexOf(".") < 0) {
    return 0;
  }
  const mantissa = str.split(".");
  const positionOfDelimiter = mantissa[1].indexOf("e");
  return positionOfDelimiter >= 0 ? positionOfDelimiter : mantissa[1].length;
}
function roundFloatPart(value2) {
  let digitsCount = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
  return parseFloat(value2.toFixed(digitsCount));
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/utils/date/toMilliseconds.js
var timeIntervals = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 864e5,
  week: 6048e5,
  month: 2592e6,
  quarter: 7776e6,
  year: 31536e6
};
function toMilliseconds(value2) {
  return timeIntervals[value2];
}

// ../../../../../../node_modules/devextreme/esm/core/utils/date.js
var DAYS_IN_WEEK = 7;
var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"];
var getDatesInterval = function(startDate, endDate, intervalUnit) {
  const delta = endDate.getTime() - startDate.getTime();
  const millisecondCount = toMilliseconds(intervalUnit) || 1;
  return Math.floor(delta / millisecondCount);
};
var getNextDateUnit = function(unit, withWeeks) {
  const interval = getDateUnitInterval(unit);
  switch (interval) {
    case "millisecond":
      return "second";
    case "second":
      return "minute";
    case "minute":
      return "hour";
    case "hour":
      return "day";
    case "day":
      return withWeeks ? "week" : "month";
    case "week":
      return "month";
    case "month":
      return "quarter";
    case "quarter":
    case "year":
      return "year";
    default:
      return 0;
  }
};
var convertMillisecondsToDateUnits = function(value2) {
  let i;
  let dateUnitCount;
  let dateUnitInterval;
  const dateUnitIntervals2 = ["millisecond", "second", "minute", "hour", "day", "month", "year"];
  const result2 = {};
  for (i = dateUnitIntervals2.length - 1; i >= 0; i--) {
    dateUnitInterval = dateUnitIntervals2[i];
    dateUnitCount = Math.floor(value2 / toMilliseconds(dateUnitInterval));
    if (dateUnitCount > 0) {
      result2[dateUnitInterval + "s"] = dateUnitCount;
      value2 -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount);
    }
  }
  return result2;
};
var dateToMilliseconds = function(tickInterval) {
  let milliseconds = 0;
  if (isObject(tickInterval)) {
    each(tickInterval, function(key, value2) {
      milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value2);
    });
  }
  if (isString(tickInterval)) {
    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
  }
  return milliseconds;
};
function convertDateUnitToMilliseconds(dateUnit, count) {
  return toMilliseconds(dateUnit) * count;
}
function getDateUnitInterval(tickInterval) {
  let maxInterval = -1;
  let i;
  if (isString(tickInterval)) {
    return tickInterval;
  }
  if (isObject(tickInterval)) {
    each(tickInterval, function(key, value2) {
      for (i = 0; i < dateUnitIntervals.length; i++) {
        if (value2 && (key === dateUnitIntervals[i] + "s" || key === dateUnitIntervals[i]) && maxInterval < i) {
          maxInterval = i;
        }
      }
    });
    return dateUnitIntervals[maxInterval];
  }
  return "";
}
var tickIntervalToFormatMap = {
  millisecond: "millisecond",
  second: "longtime",
  minute: "shorttime",
  hour: "shorttime",
  day: "day",
  week: "day",
  month: "month",
  quarter: "quarter",
  year: "year"
};
function getDateFormatByTickInterval(tickInterval) {
  return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || "";
}
var getQuarter = function(month) {
  return Math.floor(month / 3);
};
var getFirstQuarterMonth = function(month) {
  return 3 * getQuarter(month);
};
function correctDateWithUnitBeginning(date, dateInterval, withCorrection, firstDayOfWeek) {
  date = new Date(date.getTime());
  const oldDate = new Date(date.getTime());
  let firstQuarterMonth;
  let month;
  const dateUnitInterval = getDateUnitInterval(dateInterval);
  switch (dateUnitInterval) {
    case "second":
      date = new Date(1e3 * Math.floor(oldDate.getTime() / 1e3));
      break;
    case "minute":
      date = new Date(6e4 * Math.floor(oldDate.getTime() / 6e4));
      break;
    case "hour":
      date = new Date(36e5 * Math.floor(oldDate.getTime() / 36e5));
      break;
    case "year":
      date.setMonth(0);
    case "month":
      date.setDate(1);
    case "day":
      date.setHours(0, 0, 0, 0);
      break;
    case "week":
      date = getFirstWeekDate(date, firstDayOfWeek || 0);
      date.setHours(0, 0, 0, 0);
      break;
    case "quarter":
      firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
      month = date.getMonth();
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
      if (month !== firstQuarterMonth) {
        date.setMonth(firstQuarterMonth);
      }
  }
  if (withCorrection && "hour" !== dateUnitInterval && "minute" !== dateUnitInterval && "second" !== dateUnitInterval) {
    fixTimezoneGap(oldDate, date);
  }
  return date;
}
function trimTime(date) {
  return correctDateWithUnitBeginning(date, "day");
}
var setToDayEnd = function(date) {
  const result2 = trimTime(date);
  result2.setDate(result2.getDate() + 1);
  return new Date(result2.getTime() - 1);
};
var getDatesDifferences = function(date1, date2) {
  let counter = 0;
  const differences = {
    year: date1.getFullYear() !== date2.getFullYear(),
    month: date1.getMonth() !== date2.getMonth(),
    day: date1.getDate() !== date2.getDate(),
    hour: date1.getHours() !== date2.getHours(),
    minute: date1.getMinutes() !== date2.getMinutes(),
    second: date1.getSeconds() !== date2.getSeconds(),
    millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
  };
  each(differences, function(key, value2) {
    if (value2) {
      counter++;
    }
  });
  if (0 === counter && 0 !== getTimezonesDifference(date1, date2)) {
    differences.hour = true;
    counter++;
  }
  differences.count = counter;
  return differences;
};
function addDateInterval(value2, interval, dir) {
  const result2 = new Date(value2.getTime());
  const intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : isNumeric(interval) ? convertMillisecondsToDateUnits(interval) : interval;
  if (intervalObject.years) {
    result2.setFullYear(result2.getFullYear() + intervalObject.years * dir);
  }
  if (intervalObject.quarters) {
    result2.setMonth(result2.getMonth() + 3 * intervalObject.quarters * dir);
  }
  if (intervalObject.months) {
    result2.setMonth(result2.getMonth() + intervalObject.months * dir);
  }
  if (intervalObject.weeks) {
    result2.setDate(result2.getDate() + 7 * intervalObject.weeks * dir);
  }
  if (intervalObject.days) {
    result2.setDate(result2.getDate() + intervalObject.days * dir);
  }
  if (intervalObject.hours) {
    result2.setTime(result2.getTime() + 36e5 * intervalObject.hours * dir);
  }
  if (intervalObject.minutes) {
    result2.setTime(result2.getTime() + 6e4 * intervalObject.minutes * dir);
  }
  if (intervalObject.seconds) {
    result2.setTime(result2.getTime() + 1e3 * intervalObject.seconds * dir);
  }
  if (intervalObject.milliseconds) {
    result2.setTime(result2.getTime() + intervalObject.milliseconds * dir);
  }
  return result2;
}
var addInterval = function(value2, interval, isNegative) {
  const dir = isNegative ? -1 : 1;
  return isDate(value2) ? addDateInterval(value2, interval, dir) : adjust(value2 + interval * dir, interval);
};
var getSequenceByInterval = function(min, max, interval) {
  const intervals = [];
  let cur;
  intervals.push(isDate(min) ? new Date(min.getTime()) : min);
  cur = min;
  while (cur < max) {
    cur = addInterval(cur, interval);
    intervals.push(cur);
  }
  return intervals;
};
var getViewFirstCellDate = function(viewType, date) {
  if ("month" === viewType) {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  }
  if ("year" === viewType) {
    return createDateWithFullYear(date.getFullYear(), 0, date.getDate());
  }
  if ("decade" === viewType) {
    return createDateWithFullYear(getFirstYearInDecade(date), date.getMonth(), date.getDate());
  }
  if ("century" === viewType) {
    return createDateWithFullYear(getFirstDecadeInCentury(date), date.getMonth(), date.getDate());
  }
};
var getViewLastCellDate = function(viewType, date) {
  if ("month" === viewType) {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
  }
  if ("year" === viewType) {
    return createDateWithFullYear(date.getFullYear(), 11, date.getDate());
  }
  if ("decade" === viewType) {
    return createDateWithFullYear(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate());
  }
  if ("century" === viewType) {
    return createDateWithFullYear(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate());
  }
};
var getViewMinBoundaryDate = function(viewType, date) {
  const resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  if ("month" === viewType) {
    return resultDate;
  }
  resultDate.setMonth(0);
  if ("year" === viewType) {
    return resultDate;
  }
  if ("decade" === viewType) {
    resultDate.setFullYear(getFirstYearInDecade(date));
  }
  if ("century" === viewType) {
    resultDate.setFullYear(getFirstDecadeInCentury(date));
  }
  return resultDate;
};
var getViewMaxBoundaryDate = function(viewType, date) {
  const resultDate = new Date(date);
  resultDate.setDate(getLastMonthDay(date));
  if ("month" === viewType) {
    return resultDate;
  }
  resultDate.setMonth(11);
  resultDate.setDate(getLastMonthDay(resultDate));
  if ("year" === viewType) {
    return resultDate;
  }
  if ("decade" === viewType) {
    resultDate.setFullYear(getFirstYearInDecade(date) + 9);
  }
  if ("century" === viewType) {
    resultDate.setFullYear(getFirstDecadeInCentury(date) + 99);
  }
  return resultDate;
};
function getLastMonthDay(date) {
  const resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
  return resultDate.getDate();
}
var getViewUp = function(typeView) {
  switch (typeView) {
    case "month":
      return "year";
    case "year":
      return "decade";
    case "decade":
      return "century";
  }
};
var getViewDown = function(typeView) {
  switch (typeView) {
    case "century":
      return "decade";
    case "decade":
      return "year";
    case "year":
      return "month";
  }
};
var getDifferenceInMonth = function(typeView) {
  let difference = 1;
  if ("year" === typeView) {
    difference = 12;
  }
  if ("decade" === typeView) {
    difference = 120;
  }
  if ("century" === typeView) {
    difference = 1200;
  }
  return difference;
};
var getDifferenceInMonthForCells = function(typeView) {
  let difference = 1;
  if ("decade" === typeView) {
    difference = 12;
  }
  if ("century" === typeView) {
    difference = 120;
  }
  return difference;
};
function getDateIntervalByString(intervalString) {
  const result2 = {};
  switch (intervalString) {
    case "year":
      result2.years = 1;
      break;
    case "month":
      result2.months = 1;
      break;
    case "quarter":
      result2.months = 3;
      break;
    case "week":
      result2.weeks = 1;
      break;
    case "day":
      result2.days = 1;
      break;
    case "hour":
      result2.hours = 1;
      break;
    case "minute":
      result2.minutes = 1;
      break;
    case "second":
      result2.seconds = 1;
      break;
    case "millisecond":
      result2.milliseconds = 1;
  }
  return result2;
}
function sameDate(date1, date2) {
  return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate();
}
function sameMonthAndYear(date1, date2) {
  return sameYear(date1, date2) && date1.getMonth() === date2.getMonth();
}
function sameYear(date1, date2) {
  return date1 && date2 && date1.getFullYear() === date2.getFullYear();
}
function sameHoursAndMinutes(date1, date2) {
  return date1 && date2 && date1.getHours() === date2.getHours() && date1.getMinutes() === date2.getMinutes();
}
var sameDecade = function(date1, date2) {
  if (!isDefined(date1) || !isDefined(date2)) {
    return;
  }
  const startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10;
  const startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
  return date1 && date2 && startDecadeDate1 === startDecadeDate2;
};
var sameCentury = function(date1, date2) {
  if (!isDefined(date1) || !isDefined(date2)) {
    return;
  }
  const startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100;
  const startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
  return date1 && date2 && startCenturyDate1 === startCenturyDate2;
};
function getFirstDecadeInCentury(date) {
  return date && date.getFullYear() - date.getFullYear() % 100;
}
function getFirstYearInDecade(date) {
  return date && date.getFullYear() - date.getFullYear() % 10;
}
var getShortDateFormat = function() {
  return "yyyy/MM/dd";
};
var getFirstMonthDate = function(date) {
  if (!isDefined(date)) {
    return;
  }
  return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
};
var getLastMonthDate = function(date) {
  if (!isDefined(date)) {
    return;
  }
  return createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
};
function getFirstWeekDate(date, firstDayOfWeek) {
  const delta = (date.getDay() - firstDayOfWeek + DAYS_IN_WEEK) % DAYS_IN_WEEK;
  const result2 = new Date(date);
  result2.setDate(date.getDate() - delta);
  return result2;
}
function getUTCTime(date) {
  return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
}
function getDayNumber(date) {
  const ms = getUTCTime(date) - getUTCTime(getFirstDateInYear(date.getFullYear()));
  return 1 + Math.floor(ms / toMilliseconds("day"));
}
function getFirstDateInYear(year) {
  return new Date(year, 0, 1);
}
function getLastDateInYear(year) {
  return new Date(year, 11, 31);
}
function getDayWeekNumber(date, firstDayOfWeek) {
  let day = date.getDay() - firstDayOfWeek + 1;
  if (day <= 0) {
    day += DAYS_IN_WEEK;
  }
  return day;
}
function getWeekNumber(date, firstDayOfWeek, rule) {
  const firstWeekDayInYear = getDayWeekNumber(getFirstDateInYear(date.getFullYear()), firstDayOfWeek);
  const lastWeekDayInYear = getDayWeekNumber(getLastDateInYear(date.getFullYear()), firstDayOfWeek);
  const daysInFirstWeek = DAYS_IN_WEEK - firstWeekDayInYear + 1;
  let weekNumber = Math.ceil((getDayNumber(date) - daysInFirstWeek) / 7);
  switch (rule) {
    case "fullWeek":
      if (daysInFirstWeek === DAYS_IN_WEEK) {
        weekNumber++;
      }
      if (0 === weekNumber) {
        const lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
        return getWeekNumber(lastDateInPreviousYear, firstDayOfWeek, rule);
      }
      return weekNumber;
    case "firstDay": {
      if (daysInFirstWeek > 0) {
        weekNumber++;
      }
      const isSunday = 7 === firstWeekDayInYear || 7 === lastWeekDayInYear;
      if (weekNumber > 52 && !isSunday || 54 === weekNumber) {
        weekNumber = 1;
      }
      return weekNumber;
    }
    case "firstFourDays": {
      if (daysInFirstWeek > 3) {
        weekNumber++;
      }
      const isThursday = 4 === firstWeekDayInYear || 4 === lastWeekDayInYear;
      if (weekNumber > 52 && !isThursday) {
        weekNumber = 1;
      }
      if (0 === weekNumber) {
        const lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
        return getWeekNumber(lastDateInPreviousYear, firstDayOfWeek, rule);
      }
      return weekNumber;
    }
  }
}
var normalizeDateByWeek = function(date, currentDate) {
  const differenceInDays = dateUtils.getDatesInterval(date, currentDate, "day");
  let resultDate = new Date(date);
  if (differenceInDays >= 6) {
    resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7));
  }
  return resultDate;
};
var dateInRange = function(date, min, max, format2) {
  if ("date" === format2) {
    min = min && dateUtils.correctDateWithUnitBeginning(min, "day");
    max = max && dateUtils.correctDateWithUnitBeginning(max, "day");
    date = date && dateUtils.correctDateWithUnitBeginning(date, "day");
  }
  return normalizeDate(date, min, max) === date;
};
var intervalsOverlap = function(options2) {
  const {
    firstMin,
    firstMax,
    secondMin,
    secondMax
  } = options2;
  return firstMin <= secondMin && secondMin <= firstMax || firstMin > secondMin && firstMin < secondMax || firstMin < secondMax && firstMax > secondMax;
};
var dateTimeFromDecimal = function(number) {
  const hours = Math.floor(number);
  const minutes = number % 1 * 60;
  return {
    hours,
    minutes
  };
};
var roundDateByStartDayHour = function(date, startDayHour) {
  const startTime = this.dateTimeFromDecimal(startDayHour);
  const result2 = new Date(date);
  if (date.getHours() === startTime.hours && date.getMinutes() < startTime.minutes || date.getHours() < startTime.hours) {
    result2.setHours(startTime.hours, startTime.minutes, 0, 0);
  }
  return result2;
};
function normalizeDate(date, min, max) {
  let normalizedDate = date;
  if (!isDefined(date)) {
    return date;
  }
  if (isDefined(min) && date < min) {
    normalizedDate = min;
  }
  if (isDefined(max) && date > max) {
    normalizedDate = max;
  }
  return normalizedDate;
}
function fixTimezoneGap(oldDate, newDate) {
  if (!isDefined(oldDate)) {
    return;
  }
  const diff = newDate.getHours() - oldDate.getHours();
  if (0 === diff) {
    return;
  }
  const sign2 = 1 === diff || -23 === diff ? -1 : 1;
  const trial = new Date(newDate.getTime() + 36e5 * sign2);
  if (sign2 > 0 || trial.getDate() === newDate.getDate()) {
    newDate.setTime(trial.getTime());
  }
}
var roundToHour = function(date) {
  const result2 = new Date(date.getTime());
  result2.setHours(result2.getHours() + 1);
  result2.setMinutes(0);
  return result2;
};
function getTimezonesDifference(min, max) {
  return 60 * (max.getTimezoneOffset() - min.getTimezoneOffset()) * 1e3;
}
var makeDate = function(date) {
  return new Date(date);
};
var getDatesOfInterval = function(startDate, endDate, step) {
  const result2 = [];
  let currentDate = new Date(startDate.getTime());
  while (currentDate < endDate) {
    result2.push(new Date(currentDate.getTime()));
    currentDate = this.addInterval(currentDate, step);
  }
  return result2;
};
var createDateWithFullYear = function(year) {
  const result2 = new Date(...arguments);
  result2.setFullYear(year);
  return result2;
};
var getMachineTimezoneName = () => {
  const hasIntl3 = "undefined" !== typeof Intl;
  return hasIntl3 ? Intl.DateTimeFormat().resolvedOptions().timeZone : null;
};
var dateUtils = {
  dateUnitIntervals,
  convertMillisecondsToDateUnits,
  dateToMilliseconds,
  getNextDateUnit,
  convertDateUnitToMilliseconds,
  getDateUnitInterval,
  getDateFormatByTickInterval,
  getDatesDifferences,
  correctDateWithUnitBeginning,
  trimTime,
  setToDayEnd,
  roundDateByStartDayHour,
  dateTimeFromDecimal,
  addDateInterval,
  addInterval,
  getSequenceByInterval,
  getDateIntervalByString,
  sameHoursAndMinutes,
  sameDate,
  sameMonthAndYear,
  sameMonth: sameMonthAndYear,
  sameYear,
  sameDecade,
  sameCentury,
  getDifferenceInMonth,
  getDifferenceInMonthForCells,
  getFirstYearInDecade,
  getFirstDecadeInCentury,
  getShortDateFormat,
  getViewFirstCellDate,
  getViewLastCellDate,
  getViewDown,
  getViewUp,
  getLastMonthDay,
  getLastMonthDate,
  getFirstMonthDate,
  getFirstWeekDate,
  getWeekNumber,
  normalizeDateByWeek,
  getQuarter,
  getFirstQuarterMonth,
  dateInRange,
  intervalsOverlap,
  roundToHour,
  normalizeDate,
  getViewMinBoundaryDate,
  getViewMaxBoundaryDate,
  fixTimezoneGap,
  getTimezonesDifference,
  makeDate,
  getDatesInterval,
  getDatesOfInterval,
  createDateWithFullYear,
  getMachineTimezoneName
};
dateUtils.sameView = function(view, date1, date2) {
  return dateUtils[camelize("same " + view)](date1, date2);
};
var date_default = dateUtils;

// ../../../../../../node_modules/devextreme/esm/localization/ldml/date.formatter.js
function leftPad(text, length) {
  while (text.length < length) {
    text = "0" + text;
  }
  return text;
}
var FORMAT_TYPES = {
  3: "abbreviated",
  4: "wide",
  5: "narrow"
};
var LDML_FORMATTERS = {
  y: function(date, count, useUtc) {
    let year = date[useUtc ? "getUTCFullYear" : "getFullYear"]();
    if (2 === count) {
      year %= 100;
    }
    return leftPad(year.toString(), count);
  },
  M: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, "format")[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  L: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, "standalone")[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  Q: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const quarter = Math.floor(month / 3);
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getQuarterNames(formatType)[quarter];
    }
    return leftPad((quarter + 1).toString(), Math.min(count, 2));
  },
  E: function(date, count, useUtc, dateParts) {
    const day = date[useUtc ? "getUTCDay" : "getDay"]();
    const formatType = FORMAT_TYPES[count < 3 ? 3 : count];
    return dateParts.getDayNames(formatType)[day];
  },
  a: function(date, count, useUtc, dateParts) {
    const hours = date[useUtc ? "getUTCHours" : "getHours"]();
    const period = hours < 12 ? 0 : 1;
    const formatType = FORMAT_TYPES[count];
    return dateParts.getPeriodNames(formatType)[period];
  },
  d: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCDate" : "getDate"]().toString(), Math.min(count, 2));
  },
  H: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCHours" : "getHours"]().toString(), Math.min(count, 2));
  },
  h: function(date, count, useUtc) {
    const hours = date[useUtc ? "getUTCHours" : "getHours"]();
    return leftPad((hours % 12 || 12).toString(), Math.min(count, 2));
  },
  m: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCMinutes" : "getMinutes"]().toString(), Math.min(count, 2));
  },
  s: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCSeconds" : "getSeconds"]().toString(), Math.min(count, 2));
  },
  S: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCMilliseconds" : "getMilliseconds"]().toString(), 3).substr(0, count);
  },
  x: function(date, count, useUtc) {
    const timezoneOffset = useUtc ? 0 : date.getTimezoneOffset();
    const signPart = timezoneOffset > 0 ? "-" : "+";
    const timezoneOffsetAbs = Math.abs(timezoneOffset);
    const hours = Math.floor(timezoneOffsetAbs / 60);
    const minutes = timezoneOffsetAbs % 60;
    const hoursPart = leftPad(hours.toString(), 2);
    const minutesPart = leftPad(minutes.toString(), 2);
    return signPart + hoursPart + (count >= 3 ? ":" : "") + (count > 1 || minutes ? minutesPart : "");
  },
  X: function(date, count, useUtc) {
    if (useUtc || !date.getTimezoneOffset()) {
      return "Z";
    }
    return LDML_FORMATTERS.x(date, count, useUtc);
  },
  Z: function(date, count, useUtc) {
    return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc);
  }
};
var getFormatter = function(format2, dateParts) {
  return function(date) {
    let charIndex;
    let formatter;
    let char;
    let charCount = 0;
    let isEscaping = false;
    let isCurrentCharEqualsNext;
    let result2 = "";
    if (!date) {
      return null;
    }
    if (!format2) {
      return date;
    }
    const useUtc = "Z" === format2[format2.length - 1] || "'Z'" === format2.slice(-3);
    for (charIndex = 0; charIndex < format2.length; charIndex++) {
      char = format2[charIndex];
      formatter = LDML_FORMATTERS[char];
      isCurrentCharEqualsNext = char === format2[charIndex + 1];
      charCount++;
      if (!isCurrentCharEqualsNext) {
        if (formatter && !isEscaping) {
          result2 += formatter(date, charCount, useUtc, dateParts);
        }
        charCount = 0;
      }
      if ("'" === char && !isCurrentCharEqualsNext) {
        isEscaping = !isEscaping;
      } else if (isEscaping || !formatter) {
        result2 += char;
      }
      if ("'" === char && isCurrentCharEqualsNext) {
        charIndex++;
      }
    }
    return result2;
  };
};

// ../../../../../../node_modules/devextreme/esm/localization/default_date_names.js
var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
var DAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var PERIODS = ["AM", "PM"];
var QUARTERS = ["Q1", "Q2", "Q3", "Q4"];
var cutCaptions = (captions, format2) => {
  const lengthByFormat = {
    abbreviated: 3,
    short: 2,
    narrow: 1
  };
  return map(captions, (caption) => caption.substr(0, lengthByFormat[format2]));
};
var default_date_names_default = {
  getMonthNames: function(format2) {
    return cutCaptions(MONTHS, format2);
  },
  getDayNames: function(format2) {
    return cutCaptions(DAYS, format2);
  },
  getQuarterNames: function(format2) {
    return QUARTERS;
  },
  getPeriodNames: function(format2) {
    return PERIODS;
  }
};

// ../../../../../../node_modules/devextreme/esm/core/utils/date_serialization.js
var ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/;
var ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
var ISO8601_PATTERN_PARTS = ["", "yyyy", "", "MM", "", "dd", "THH", "", "mm", "", "ss", ".SSS"];
var DATE_SERIALIZATION_PATTERN = /^(\d{4})\/(\d{2})\/(\d{2})$/;
var dateParser = function(text, skipISO8601Parsing) {
  let result2;
  if (isString(text) && !skipISO8601Parsing) {
    result2 = parseISO8601String(text);
  }
  return result2 || parseDate(text);
};
function getTimePart(part) {
  return +part || 0;
}
function parseDate(text) {
  const isDefaultSerializationFormat = "yyyy/MM/dd" === getDateSerializationFormat(text);
  const parsedValue = !isDate(text) && Date.parse(text);
  if (!parsedValue && isDefaultSerializationFormat) {
    const parts = text.match(DATE_SERIALIZATION_PATTERN);
    if (parts) {
      const newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));
      newDate.setFullYear(getTimePart(parts[1]));
      newDate.setMonth(getTimePart(parts[2]) - 1);
      newDate.setDate(getTimePart(parts[3]));
      return newDate;
    }
  }
  return isNumeric(parsedValue) ? new Date(parsedValue) : text;
}
function parseISO8601String(text) {
  let parts = text.match(ISO8601_PATTERN);
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]));
    }
    return;
  }
  const year = getTimePart(parts[1]);
  const month = --parts[3];
  const day = parts[5];
  let timeZoneHour = 0;
  let timeZoneMinute = 0;
  const correctYear = (d) => {
    year < 100 && d.setFullYear(year);
    return d;
  };
  timeZoneHour = getTimePart(parts[14]);
  timeZoneMinute = getTimePart(parts[16]);
  if ("-" === parts[13]) {
    timeZoneHour = -timeZoneHour;
    timeZoneMinute = -timeZoneMinute;
  }
  const hour = getTimePart(parts[6]) - timeZoneHour;
  const minute = getTimePart(parts[8]) - timeZoneMinute;
  const second = getTimePart(parts[10]);
  const millisecond = function(part) {
    part = part || "";
    return getTimePart(part) * Math.pow(10, 3 - part.length);
  }(parts[11]);
  if (parts[12]) {
    return correctYear(new Date(Date.UTC(year, month, day, hour, minute, second, millisecond)));
  }
  return correctYear(new Date(year, month, day, hour, minute, second, millisecond));
}
var getIso8601Format = function(text, useUtc) {
  let parts = text.match(ISO8601_PATTERN);
  let result2 = "";
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return parts[3] ? "HH:mm:ss" : "HH:mm";
    }
    return;
  }
  for (let i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
    if (parts[i]) {
      result2 += ISO8601_PATTERN_PARTS[i] || parts[i];
    }
  }
  if ("Z" === parts[12]) {
    result2 += "'Z'";
  }
  if (parts[14]) {
    if (parts[15]) {
      result2 += "xxx";
    } else if (parts[16]) {
      result2 += "xx";
    } else {
      result2 += "x";
    }
  }
  return result2;
};
var deserializeDate = function(value2) {
  if ("number" === typeof value2) {
    return new Date(value2);
  }
  return dateParser(value2, !config_default().forceIsoDateParsing);
};
var serializeDate = function(value2, serializationFormat) {
  if (!serializationFormat) {
    return value2;
  }
  if (!isDate(value2)) {
    return null;
  }
  if ("number" === serializationFormat) {
    return value2 && value2.valueOf ? value2.valueOf() : null;
  }
  return getFormatter(serializationFormat, default_date_names_default)(value2);
};
var getDateSerializationFormat = function(value2) {
  if ("number" === typeof value2) {
    return "number";
  } else if (isString(value2)) {
    let format2;
    if (config_default().forceIsoDateParsing) {
      format2 = getIso8601Format(value2);
    }
    if (format2) {
      return format2;
    } else if (value2.indexOf(":") >= 0) {
      return "yyyy/MM/dd HH:mm:ss";
    } else {
      return "yyyy/MM/dd";
    }
  } else if (value2) {
    return null;
  }
};
var date_serialization_default = {
  dateParser,
  deserializeDate,
  serializeDate,
  getDateSerializationFormat
};

// ../../../../../../node_modules/devextreme/esm/core/utils/position.js
var getDefaultAlignment = (isRtlEnabled) => {
  const rtlEnabled = isRtlEnabled ?? config_default().rtlEnabled;
  return rtlEnabled ? "right" : "left";
};
var getBoundingRect = (element) => {
  if (isWindow(element)) {
    return {
      width: element.outerWidth,
      height: element.outerHeight
    };
  }
  return element.getBoundingClientRect();
};

// ../../../../../../node_modules/devextreme/esm/data/utils.js
var ready2 = ready_callbacks_default.add;
var XHR_ERROR_UNLOAD = "DEVEXTREME_XHR_ERROR_UNLOAD";
var normalizeBinaryCriterion = function(crit) {
  return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]];
};
var normalizeSortingInfo = function(info) {
  if (!Array.isArray(info)) {
    info = [info];
  }
  return map(info, function(i) {
    const result2 = {
      selector: isFunction(i) || "string" === typeof i ? i : i.getter || i.field || i.selector,
      desc: !!(i.desc || "d" === String(i.dir).charAt(0).toLowerCase())
    };
    if (i.compare) {
      result2.compare = i.compare;
    }
    return result2;
  });
};
var errorMessageFromXhr = function() {
  const textStatusMessages = {
    timeout: "Network connection timeout",
    error: "Unspecified network error",
    parsererror: "Unexpected server response"
  };
  let unloading;
  ready2(function() {
    const window28 = getWindow();
    dom_adapter_default.listen(window28, "beforeunload", function() {
      unloading = true;
    });
  });
  return function(xhr, textStatus) {
    if (unloading) {
      return XHR_ERROR_UNLOAD;
    }
    if (xhr.status < 400) {
      return function(textStatus2) {
        let result2 = textStatusMessages[textStatus2];
        if (!result2) {
          return textStatus2;
        }
        return result2;
      }(textStatus);
    }
    return xhr.statusText;
  };
}();
var aggregators = {
  count: {
    seed: 0,
    step: function(count) {
      return 1 + count;
    }
  },
  sum: {
    seed: 0,
    step: function(sum, item) {
      return sum + item;
    }
  },
  min: {
    step: function(min, item) {
      return item < min ? item : min;
    }
  },
  max: {
    step: function(max, item) {
      return item > max ? item : max;
    }
  },
  avg: {
    seed: [0, 0],
    step: function(pair, value2) {
      return [pair[0] + value2, pair[1] + 1];
    },
    finalize: function(pair) {
      return pair[1] ? pair[0] / pair[1] : NaN;
    }
  }
};
var processRequestResultLock = function() {
  let lockCount = 0;
  let lockDeferred;
  return {
    obtain: function() {
      if (0 === lockCount) {
        lockDeferred = new Deferred();
      }
      lockCount++;
    },
    release: function() {
      lockCount--;
      if (lockCount < 1) {
        lockDeferred.resolve();
      }
    },
    promise: function() {
      const deferred = 0 === lockCount ? new Deferred().resolve() : lockDeferred;
      return deferred.promise();
    },
    reset: function() {
      lockCount = 0;
      if (lockDeferred) {
        lockDeferred.resolve();
      }
    }
  };
}();
function isConjunctiveOperator(condition) {
  return /^(and|&&|&)$/i.test(condition);
}
var keysEqual = function(keyExpr, key1, key2) {
  if (Array.isArray(keyExpr)) {
    const names = map(key1, function(v, k) {
      return k;
    });
    let name2;
    for (let i = 0; i < names.length; i++) {
      name2 = names[i];
      if (!equalByValue(key1[name2], key2[name2], {
        strict: false
      })) {
        return false;
      }
    }
    return true;
  }
  return equalByValue(key1, key2, {
    strict: false
  });
};
var isUnaryOperation = function(crit) {
  return "!" === crit[0] && Array.isArray(crit[1]);
};
var isGroupOperator = function(value2) {
  return "and" === value2 || "or" === value2;
};
var isUniformEqualsByOr = function(crit) {
  if (crit.length > 2 && Array.isArray(crit[0]) && "or" === crit[1] && "string" === typeof crit[0][0] && "=" === crit[0][1]) {
    const [prop] = crit[0];
    return !crit.find((el, i) => i % 2 !== 0 ? "or" !== el : !Array.isArray(el) || 3 !== el.length || el[0] !== prop || "=" !== el[1]);
  }
  return false;
};
var isGroupCriterion = function(crit) {
  const first = crit[0];
  const second = crit[1];
  if (Array.isArray(first)) {
    return true;
  }
  if (isFunction(first)) {
    if (Array.isArray(second) || isFunction(second) || isGroupOperator(second)) {
      return true;
    }
  }
  return false;
};
var trivialPromise = function() {
  const d = new Deferred();
  return d.resolve.apply(d, arguments).promise();
};
var rejectedPromise = function() {
  const d = new Deferred();
  return d.reject.apply(d, arguments).promise();
};
function throttle(func, timeout) {
  let timeoutId;
  return function() {
    if (!timeoutId) {
      timeoutId = setTimeout(() => {
        timeoutId = void 0;
        func.call(this);
      }, isFunction(timeout) ? timeout() : timeout);
    }
    return timeoutId;
  };
}
function throttleChanges(func, timeout) {
  let cache = [];
  const throttled = throttle(function() {
    func.call(this, cache);
    cache = [];
  }, timeout);
  return function(changes) {
    if (Array.isArray(changes)) {
      cache.push(...changes);
    }
    return throttled.call(this, cache);
  };
}

// ../../../../../../node_modules/devextreme/esm/data/errors.js
var errors = error_default(errors_default.ERROR_MESSAGES, {
  E4000: "[DevExpress.data]: {0}",
  E4001: "Unknown aggregating function is detected: '{0}'",
  E4002: "Unsupported OData protocol version is used",
  E4003: "Unknown filter operation is used: {0}",
  E4004: "The thenby() method is called before the sortby() method",
  E4005: "Store requires a key expression for this operation",
  E4006: "ArrayStore 'data' option must be an array",
  E4007: "Compound keys cannot be auto-generated",
  E4008: "Attempt to insert an item with a duplicated key",
  E4009: "Data item cannot be found",
  E4010: "CustomStore does not support creating queries",
  E4011: "Custom Store method is not implemented or is not a function: {0}",
  E4012: "Custom Store method returns an invalid value: {0}",
  E4013: "Local Store requires the 'name' configuration option is specified",
  E4014: "Unknown data type is specified for ODataStore: {0}",
  E4015: "Unknown entity name or alias is used: {0}",
  E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
  E4017: "Keys cannot be modified",
  E4018: "The server has returned a non-numeric value in a response to an item count request",
  E4019: "Mixing of group operators inside a single group of filter expression is not allowed",
  E4020: "Unknown store type is detected: {0}",
  E4021: "The server response does not provide the totalCount value",
  E4022: "The server response does not provide the groupCount value",
  E4023: "Could not parse the following XML: {0}",
  E4024: "String function {0} cannot be used with the data field {1} of type {2}.",
  W4000: "Data returned from the server has an incorrect structure",
  W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',
  W4002: "Data loading has failed for some cells due to the following error: {0}"
});
var errorHandler = null;
var handleError = function(error) {
  var _errorHandler;
  null === (_errorHandler = errorHandler) || void 0 === _errorHandler || _errorHandler(error);
};

// ../../../../../../node_modules/devextreme/esm/data/array_utils.js
function hasKey(target, keyOrKeys) {
  let key;
  const keys = "string" === typeof keyOrKeys ? keyOrKeys.split() : keyOrKeys.slice();
  while (keys.length) {
    key = keys.shift();
    if (key in target) {
      return true;
    }
  }
  return false;
}
function findItems(keyInfo, items, key, groupCount) {
  let childItems;
  let result2;
  if (groupCount) {
    for (let i = 0; i < items.length; i++) {
      childItems = items[i].items || items[i].collapsedItems || [];
      result2 = findItems(keyInfo, childItems || [], key, groupCount - 1);
      if (result2) {
        return result2;
      }
    }
  } else if (indexByKey(keyInfo, items, key) >= 0) {
    return items;
  }
}
function getItems(keyInfo, items, key, groupCount) {
  if (groupCount) {
    return findItems(keyInfo, items, key, groupCount) || [];
  }
  return items;
}
function generateDataByKeyMap(keyInfo, array) {
  if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {
    const dataByKeyMap = {};
    const arrayLength = array.length;
    for (let i = 0; i < arrayLength; i++) {
      dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i];
    }
    array._dataByKeyMap = dataByKeyMap;
    array._dataByKeyMapLength = arrayLength;
  }
}
function getCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
}
function getHasKeyCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
  return true;
}
function setDataByKeyMapValue(array, key, data2) {
  if (array._dataByKeyMap) {
    array._dataByKeyMap[JSON.stringify(key)] = data2;
    array._dataByKeyMapLength += data2 ? 1 : -1;
  }
}
function cloneInstanceWithChangedPaths(instance, changes, clonedInstances) {
  clonedInstances = clonedInstances || /* @__PURE__ */ new WeakMap();
  const result2 = instance ? Object.create(Object.getPrototypeOf(instance)) : {};
  if (instance) {
    clonedInstances.set(instance, result2);
  }
  const instanceWithoutPrototype = _extends({}, instance);
  deepExtendArraySafe(result2, instanceWithoutPrototype, true, true);
  for (const name2 in instanceWithoutPrototype) {
    const value2 = instanceWithoutPrototype[name2];
    const change = null === changes || void 0 === changes ? void 0 : changes[name2];
    if (isObject(value2) && !isPlainObject(value2) && isObject(change) && !clonedInstances.has(value2)) {
      result2[name2] = cloneInstanceWithChangedPaths(value2, change, clonedInstances);
    }
  }
  for (const name2 in result2) {
    const prop = result2[name2];
    if (isObject(prop) && clonedInstances.has(prop)) {
      result2[name2] = clonedInstances.get(prop);
    }
  }
  return result2;
}
function createObjectWithChanges(target, changes) {
  const result2 = cloneInstanceWithChangedPaths(target, changes);
  return deepExtendArraySafe(result2, changes, true, true);
}
function applyBatch(_ref) {
  let {
    keyInfo,
    data: data2,
    changes,
    groupCount,
    useInsertIndex,
    immutable,
    disableCache,
    logError,
    skipCopying
  } = _ref;
  const resultItems = true === immutable ? [...data2] : data2;
  changes.forEach((item) => {
    const items = "insert" === item.type ? resultItems : getItems(keyInfo, resultItems, item.key, groupCount);
    !disableCache && generateDataByKeyMap(keyInfo, items);
    switch (item.type) {
      case "update":
        update(keyInfo, items, item.key, item.data, true, immutable, logError);
        break;
      case "insert":
        insert(keyInfo, items, item.data, useInsertIndex && isDefined(item.index) ? item.index : -1, true, logError, skipCopying);
        break;
      case "remove":
        remove(keyInfo, items, item.key, true, logError);
    }
  });
  return resultItems;
}
function getErrorResult(isBatch, logError, errorCode) {
  return !isBatch ? rejectedPromise(errors.Error(errorCode)) : logError && errors.log(errorCode);
}
function update(keyInfo, array, key, data2, isBatch, immutable, logError) {
  let target;
  const keyExpr = keyInfo.key();
  if (keyExpr) {
    if (hasKey(data2, keyExpr) && !keysEqual(keyExpr, key, keyInfo.keyOf(data2))) {
      return getErrorResult(isBatch, logError, "E4017");
    }
    target = getCacheValue(array, key);
    if (!target) {
      const index2 = indexByKey(keyInfo, array, key);
      if (index2 < 0) {
        return getErrorResult(isBatch, logError, "E4009");
      }
      target = array[index2];
      if (true === immutable && isDefined(target)) {
        const newTarget = createObjectWithChanges(target, data2);
        array[index2] = newTarget;
        return !isBatch && trivialPromise(newTarget, key);
      }
    }
  } else {
    target = key;
  }
  deepExtendArraySafe(target, data2, true);
  if (!isBatch) {
    if (config_default().useLegacyStoreResult) {
      return trivialPromise(key, data2);
    } else {
      return trivialPromise(target, key);
    }
  }
}
function insert(keyInfo, array, data2, index2, isBatch, logError, skipCopying) {
  let keyValue;
  const keyExpr = keyInfo.key();
  const obj = isPlainObject(data2) && !skipCopying ? extend({}, data2) : data2;
  if (keyExpr) {
    keyValue = keyInfo.keyOf(obj);
    if (void 0 === keyValue || "object" === typeof keyValue && isEmptyObject(keyValue)) {
      if (Array.isArray(keyExpr)) {
        throw errors.Error("E4007");
      }
      keyValue = obj[keyExpr] = String(new guid_default());
    } else if (void 0 !== array[indexByKey(keyInfo, array, keyValue)]) {
      return getErrorResult(isBatch, logError, "E4008");
    }
  } else {
    keyValue = obj;
  }
  if (index2 >= 0) {
    array.splice(index2, 0, obj);
  } else {
    array.push(obj);
  }
  setDataByKeyMapValue(array, keyValue, obj);
  if (!isBatch) {
    return trivialPromise(config_default().useLegacyStoreResult ? data2 : obj, keyValue);
  }
}
function remove(keyInfo, array, key, isBatch, logError) {
  const index2 = indexByKey(keyInfo, array, key);
  if (index2 > -1) {
    array.splice(index2, 1);
    setDataByKeyMapValue(array, key, null);
  }
  if (!isBatch) {
    return trivialPromise(key);
  } else if (index2 < 0) {
    return getErrorResult(isBatch, logError, "E4009");
  }
}
function indexByKey(keyInfo, array, key) {
  const keyExpr = keyInfo.key();
  if (!getHasKeyCacheValue(array, key)) {
    return -1;
  }
  for (let i = 0, arrayLength = array.length; i < arrayLength; i++) {
    if (keysEqual(keyExpr, keyInfo.keyOf(array[i]), key)) {
      return i;
    }
  }
  return -1;
}

// ../../../../../../node_modules/devextreme/esm/data/array_query.js
var Iterator2 = class_default.inherit({
  toArray: function() {
    const result2 = [];
    this.reset();
    while (this.next()) {
      result2.push(this.current());
    }
    return result2;
  },
  countable: function() {
    return false;
  }
});
var ArrayIterator = Iterator2.inherit({
  ctor: function(array) {
    this.array = array;
    this.index = -1;
  },
  next: function() {
    if (this.index + 1 < this.array.length) {
      this.index++;
      return true;
    }
    return false;
  },
  current: function() {
    return this.array[this.index];
  },
  reset: function() {
    this.index = -1;
  },
  toArray: function() {
    return this.array.slice(0);
  },
  countable: function() {
    return true;
  },
  count: function() {
    return this.array.length;
  }
});
var WrappedIterator = Iterator2.inherit({
  ctor: function(iter2) {
    this.iter = iter2;
  },
  next: function() {
    return this.iter.next();
  },
  current: function() {
    return this.iter.current();
  },
  reset: function() {
    return this.iter.reset();
  }
});
var MapIterator = WrappedIterator.inherit({
  ctor: function(iter2, mapper) {
    this.callBase(iter2);
    this.index = -1;
    this.mapper = mapper;
  },
  current: function() {
    return this.mapper(this.callBase(), this.index);
  },
  next: function() {
    const hasNext = this.callBase();
    if (hasNext) {
      this.index++;
    }
    return hasNext;
  }
});
var defaultCompare = function(xValue, yValue, options2) {
  if (isString(xValue) && isString(yValue) && (null !== options2 && void 0 !== options2 && options2.locale || null !== options2 && void 0 !== options2 && options2.collatorOptions)) {
    return new Intl.Collator((null === options2 || void 0 === options2 ? void 0 : options2.locale) || void 0, (null === options2 || void 0 === options2 ? void 0 : options2.collatorOptions) || void 0).compare(xValue, yValue);
  }
  xValue = toComparable(xValue, false, options2);
  yValue = toComparable(yValue, false, options2);
  if (null === xValue && null !== yValue) {
    return -1;
  }
  if (null !== xValue && null === yValue) {
    return 1;
  }
  if (void 0 === xValue && void 0 !== yValue) {
    return 1;
  }
  if (void 0 !== xValue && void 0 === yValue) {
    return -1;
  }
  if (xValue < yValue) {
    return -1;
  }
  if (xValue > yValue) {
    return 1;
  }
  return 0;
};
var SortIterator = Iterator2.inherit({
  ctor: function(iter2, getter, desc, compare3) {
    this.langParams = iter2.langParams;
    if (!(iter2 instanceof MapIterator)) {
      iter2 = new MapIterator(iter2, this._wrap);
      iter2.langParams = this.langParams;
    }
    this.iter = iter2;
    this.rules = [{
      getter,
      desc,
      compare: compare3,
      langParams: this.langParams
    }];
  },
  thenBy: function(getter, desc, compare3) {
    const result2 = new SortIterator(this.sortedIter || this.iter, getter, desc, compare3);
    if (!this.sortedIter) {
      result2.rules = this.rules.concat(result2.rules);
    }
    return result2;
  },
  next: function() {
    this._ensureSorted();
    return this.sortedIter.next();
  },
  current: function() {
    this._ensureSorted();
    return this.sortedIter.current();
  },
  reset: function() {
    delete this.sortedIter;
  },
  countable: function() {
    return this.sortedIter || this.iter.countable();
  },
  count: function() {
    if (this.sortedIter) {
      return this.sortedIter.count();
    }
    return this.iter.count();
  },
  _ensureSorted: function() {
    const that = this;
    if (that.sortedIter) {
      return;
    }
    each(that.rules, function() {
      this.getter = compileGetter(this.getter);
    });
    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function(x, y) {
      return that._compare(x, y);
    })), that._unwrap);
  },
  _wrap: function(record, index2) {
    return {
      index: index2,
      value: record
    };
  },
  _unwrap: function(wrappedItem) {
    return wrappedItem.value;
  },
  _getDefaultCompare: (langParams) => (xValue, yValue) => defaultCompare(xValue, yValue, langParams),
  _compare: function(x, y) {
    const xIndex = x.index;
    const yIndex = y.index;
    x = x.value;
    y = y.value;
    if (x === y) {
      return xIndex - yIndex;
    }
    for (let i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
      const rule = this.rules[i];
      const xValue = rule.getter(x);
      const yValue = rule.getter(y);
      const compare3 = rule.compare || this._getDefaultCompare(rule.langParams);
      const compareResult = compare3(xValue, yValue);
      if (compareResult) {
        return rule.desc ? -compareResult : compareResult;
      }
    }
    return xIndex - yIndex;
  }
});
var compileCriteria = function() {
  let langParams = {};
  const _toComparable = (value2) => toComparable(value2, false, langParams);
  const compileGroup = function(crit) {
    if (isUniformEqualsByOr(crit)) {
      return ((crit2) => {
        const getter = compileGetter(crit2[0][0]);
        const filterValues = crit2.reduce((acc, item, i) => {
          if (i % 2 === 0) {
            acc.push(_toComparable(item[2]));
          }
          return acc;
        }, []);
        return (obj) => {
          const value2 = _toComparable(getter(obj));
          return filterValues.some((filterValue) => useStrictComparison(filterValue) ? value2 === filterValue : value2 == filterValue);
        };
      })(crit);
    }
    const ops = [];
    let isConjunctiveOperator2 = false;
    let isConjunctiveNextOperator = false;
    each(crit, function() {
      if (Array.isArray(this) || isFunction(this)) {
        if (ops.length > 1 && isConjunctiveOperator2 !== isConjunctiveNextOperator) {
          throw new errors.Error("E4019");
        }
        ops.push(compileCriteria(this, langParams));
        isConjunctiveOperator2 = isConjunctiveNextOperator;
        isConjunctiveNextOperator = true;
      } else {
        isConjunctiveNextOperator = isConjunctiveOperator(this);
      }
    });
    return function(d) {
      let result2 = isConjunctiveOperator2;
      for (let i = 0; i < ops.length; i++) {
        if (ops[i](d) !== isConjunctiveOperator2) {
          result2 = !isConjunctiveOperator2;
          break;
        }
      }
      return result2;
    };
  };
  const toString = function(value2) {
    var _langParams;
    return isDefined(value2) ? null !== (_langParams = langParams) && void 0 !== _langParams && _langParams.locale ? value2.toLocaleString(langParams.locale) : value2.toString() : "";
  };
  function compileEquals(getter, value2, negate) {
    return function(obj) {
      obj = _toComparable(getter(obj));
      let result2 = useStrictComparison(value2) ? obj === value2 : obj == value2;
      if (negate) {
        result2 = !result2;
      }
      return result2;
    };
  }
  function useStrictComparison(value2) {
    return "" === value2 || 0 === value2 || false === value2;
  }
  return function(crit, options2) {
    langParams = options2 || {};
    if (isFunction(crit)) {
      return crit;
    }
    if (isGroupCriterion(crit)) {
      return compileGroup(crit);
    }
    if (isUnaryOperation(crit)) {
      return function(crit2) {
        const op = crit2[0];
        const criteria = compileCriteria(crit2[1], langParams);
        if ("!" === op) {
          return function(obj) {
            return !criteria(obj);
          };
        }
        throw errors.Error("E4003", op);
      }(crit);
    }
    return function(crit2) {
      crit2 = normalizeBinaryCriterion(crit2);
      const getter = compileGetter(crit2[0]);
      const op = crit2[1];
      let value2 = crit2[2];
      value2 = _toComparable(value2);
      const compare3 = (obj, operatorFn) => {
        obj = _toComparable(getter(obj));
        return (null == value2 || null == obj) && value2 !== obj ? false : operatorFn(obj, value2);
      };
      switch (op.toLowerCase()) {
        case "=":
          return compileEquals(getter, value2);
        case "<>":
          return compileEquals(getter, value2, true);
        case ">":
          return (obj) => compare3(obj, (a, b) => a > b);
        case "<":
          return (obj) => compare3(obj, (a, b) => a < b);
        case ">=":
          return (obj) => compare3(obj, (a, b) => a >= b);
        case "<=":
          return (obj) => compare3(obj, (a, b) => a <= b);
        case "startswith":
          return function(obj) {
            return 0 === _toComparable(toString(getter(obj))).indexOf(value2);
          };
        case "endswith":
          return function(obj) {
            const getterValue = _toComparable(toString(getter(obj)));
            const searchValue = toString(value2);
            if (getterValue.length < searchValue.length) {
              return false;
            }
            const index2 = getterValue.lastIndexOf(value2);
            return -1 !== index2 && index2 === getterValue.length - value2.length;
          };
        case "contains":
          return function(obj) {
            return _toComparable(toString(getter(obj))).indexOf(value2) > -1;
          };
        case "notcontains":
          return function(obj) {
            return -1 === _toComparable(toString(getter(obj))).indexOf(value2);
          };
      }
      throw errors.Error("E4003", op);
    }(crit);
  };
}();
var FilterIterator = WrappedIterator.inherit({
  ctor: function(iter2, criteria) {
    this.callBase(iter2);
    this.langParams = iter2.langParams;
    this.criteria = compileCriteria(criteria, this.langParams);
  },
  next: function() {
    while (this.iter.next()) {
      if (this.criteria(this.current())) {
        return true;
      }
    }
    return false;
  }
});
var GroupIterator = Iterator2.inherit({
  ctor: function(iter2, getter) {
    this.iter = iter2;
    this.getter = getter;
  },
  next: function() {
    this._ensureGrouped();
    return this.groupedIter.next();
  },
  current: function() {
    this._ensureGrouped();
    return this.groupedIter.current();
  },
  reset: function() {
    delete this.groupedIter;
  },
  countable: function() {
    return !!this.groupedIter;
  },
  count: function() {
    return this.groupedIter.count();
  },
  _ensureGrouped: function() {
    if (this.groupedIter) {
      return;
    }
    const hash = {};
    const keys = [];
    const iter2 = this.iter;
    const getter = compileGetter(this.getter);
    iter2.reset();
    while (iter2.next()) {
      const current2 = iter2.current();
      const key = getter(current2);
      if (key in hash) {
        hash[key].push(current2);
      } else {
        hash[key] = [current2];
        keys.push(key);
      }
    }
    this.groupedIter = new ArrayIterator(map(keys, function(key) {
      return {
        key,
        items: hash[key]
      };
    }));
  }
});
var SelectIterator = WrappedIterator.inherit({
  ctor: function(iter2, getter) {
    this.callBase(iter2);
    this.getter = compileGetter(getter);
  },
  current: function() {
    return this.getter(this.callBase());
  },
  countable: function() {
    return this.iter.countable();
  },
  count: function() {
    return this.iter.count();
  }
});
var SliceIterator = WrappedIterator.inherit({
  ctor: function(iter2, skip, take) {
    this.callBase(iter2);
    this.skip = Math.max(0, skip);
    this.take = Math.max(0, take);
    this.pos = 0;
  },
  next: function() {
    if (this.pos >= this.skip + this.take) {
      return false;
    }
    while (this.pos < this.skip && this.iter.next()) {
      this.pos++;
    }
    this.pos++;
    return this.iter.next();
  },
  reset: function() {
    this.callBase();
    this.pos = 0;
  },
  countable: function() {
    return this.iter.countable();
  },
  count: function() {
    return Math.min(this.iter.count() - this.skip, this.take);
  }
});
var arrayQueryImpl = function(iter2, queryOptions) {
  queryOptions = queryOptions || {};
  if (!(iter2 instanceof Iterator2)) {
    iter2 = new ArrayIterator(iter2);
  }
  if (queryOptions.langParams) {
    iter2.langParams = queryOptions.langParams;
  }
  const handleError2 = function(error) {
    const handler = queryOptions.errorHandler;
    if (handler) {
      handler(error);
    }
    handleError(error);
  };
  const aggregateCore = function(aggregator) {
    const d = new Deferred().fail(handleError2);
    let seed;
    const step = aggregator.step;
    const finalize = aggregator.finalize;
    try {
      iter2.reset();
      if ("seed" in aggregator) {
        seed = aggregator.seed;
      } else {
        seed = iter2.next() ? iter2.current() : NaN;
      }
      let accumulator = seed;
      while (iter2.next()) {
        accumulator = step(accumulator, iter2.current());
      }
      d.resolve(finalize ? finalize(accumulator) : accumulator);
    } catch (x) {
      d.reject(x);
    }
    return d.promise();
  };
  const standardAggregate = function(name2) {
    return aggregateCore(aggregators[name2]);
  };
  const select = function(getter) {
    if (!isFunction(getter) && !Array.isArray(getter)) {
      getter = [].slice.call(arguments);
    }
    return chainQuery(new SelectIterator(iter2, getter));
  };
  const selectProp = function(name2) {
    return select(compileGetter(name2));
  };
  function chainQuery(iter3) {
    return arrayQueryImpl(iter3, queryOptions);
  }
  return {
    toArray: function() {
      return iter2.toArray();
    },
    enumerate: function() {
      const d = new Deferred().fail(handleError2);
      try {
        d.resolve(iter2.toArray());
      } catch (x) {
        d.reject(x);
      }
      return d.promise();
    },
    setLangParams(options2) {
      iter2.langParams = options2;
    },
    sortBy: function(getter, desc, compare3) {
      return chainQuery(new SortIterator(iter2, getter, desc, compare3));
    },
    thenBy: function(getter, desc, compare3) {
      if (iter2 instanceof SortIterator) {
        return chainQuery(iter2.thenBy(getter, desc, compare3));
      }
      throw errors.Error("E4004");
    },
    filter: function(criteria) {
      if (!Array.isArray(criteria)) {
        criteria = [].slice.call(arguments);
      }
      return chainQuery(new FilterIterator(iter2, criteria));
    },
    slice: function(skip, take) {
      if (void 0 === take) {
        take = Number.MAX_VALUE;
      }
      return chainQuery(new SliceIterator(iter2, skip, take));
    },
    select,
    groupBy: function(getter) {
      return chainQuery(new GroupIterator(iter2, getter));
    },
    aggregate: function(seed, step, finalize) {
      if (arguments.length < 2) {
        return aggregateCore({
          step: arguments[0]
        });
      }
      return aggregateCore({
        seed,
        step,
        finalize
      });
    },
    count: function() {
      if (iter2.countable()) {
        const d = new Deferred().fail(handleError2);
        try {
          d.resolve(iter2.count());
        } catch (x) {
          d.reject(x);
        }
        return d.promise();
      }
      return standardAggregate("count");
    },
    sum: function(getter) {
      if (getter) {
        return selectProp(getter).sum();
      }
      return standardAggregate("sum");
    },
    min: function(getter) {
      if (getter) {
        return selectProp(getter).min();
      }
      return standardAggregate("min");
    },
    max: function(getter) {
      if (getter) {
        return selectProp(getter).max();
      }
      return standardAggregate("max");
    },
    avg: function(getter) {
      if (getter) {
        return selectProp(getter).avg();
      }
      return standardAggregate("avg");
    }
  };
};
var array_query_default = arrayQueryImpl;

// ../../../../../../node_modules/devextreme/esm/data/store_helper.js
function multiLevelGroup(query2, groupInfo) {
  query2 = query2.groupBy(groupInfo[0].selector);
  if (groupInfo.length > 1) {
    query2 = query2.select(function(g) {
      return extend({}, g, {
        items: multiLevelGroup(array_query_default(g.items), groupInfo.slice(1)).toArray()
      });
    });
  }
  return query2;
}
function arrangeSortingInfo(groupInfo, sortInfo) {
  const filteredGroup = [];
  each(groupInfo, function(_, group) {
    const collision = grep(sortInfo, function(sort2) {
      return group.selector === sort2.selector;
    });
    if (collision.length < 1) {
      filteredGroup.push(group);
    }
  });
  return filteredGroup.concat(sortInfo);
}
function queryByOptions(query2, options2, isCountQuery) {
  var _options;
  options2 = options2 || {};
  const filter = options2.filter;
  if (null !== (_options = options2) && void 0 !== _options && _options.langParams) {
    var _query$setLangParams, _query;
    null === (_query$setLangParams = (_query = query2).setLangParams) || void 0 === _query$setLangParams || _query$setLangParams.call(_query, options2.langParams);
  }
  if (filter) {
    query2 = query2.filter(filter);
  }
  if (isCountQuery) {
    return query2;
  }
  let sort2 = options2.sort;
  const select = options2.select;
  let group = options2.group;
  const skip = options2.skip;
  const take = options2.take;
  if (group) {
    group = normalizeSortingInfo(group);
    group.keepInitialKeyOrder = !!options2.group.keepInitialKeyOrder;
  }
  if (sort2 || group) {
    sort2 = normalizeSortingInfo(sort2 || []);
    if (group && !group.keepInitialKeyOrder) {
      sort2 = arrangeSortingInfo(group, sort2);
    }
    each(sort2, function(index2) {
      query2 = query2[index2 ? "thenBy" : "sortBy"](this.selector, this.desc, this.compare);
    });
  }
  if (select) {
    query2 = query2.select(select);
  }
  if (group) {
    query2 = multiLevelGroup(query2, group);
  }
  if (take || skip) {
    query2 = query2.slice(skip || 0, take);
  }
  return query2;
}
var store_helper_default = {
  multiLevelGroup,
  arrangeSortingInfo,
  queryByOptions
};

// ../../../../../../node_modules/devextreme/esm/data/abstract_store.js
var abstract2 = class_default.abstract;
var queryByOptions2 = store_helper_default.queryByOptions;
var storeImpl = {};
var Store = class_default.inherit({
  _langParams: {},
  ctor: function(options2) {
    const that = this;
    options2 = options2 || {};
    this._eventsStrategy = new EventsStrategy(this);
    each(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onPush", "onRemoved", "onRemoving", "onModified", "onModifying"], function(_, optionName) {
      if (optionName in options2) {
        that.on(optionName.slice(2).toLowerCase(), options2[optionName]);
      }
    });
    this._key = options2.key;
    this._errorHandler = options2.errorHandler;
    this._useDefaultSearch = true;
  },
  _clearCache: noop2,
  _customLoadOptions: function() {
    return null;
  },
  key: function() {
    return this._key;
  },
  keyOf: function(obj) {
    if (!this._keyGetter) {
      this._keyGetter = compileGetter(this.key());
    }
    return this._keyGetter(obj);
  },
  _requireKey: function() {
    if (!this.key()) {
      throw errors.Error("E4005");
    }
  },
  load: function(options2) {
    const that = this;
    options2 = options2 || {};
    this._eventsStrategy.fireEvent("loading", [options2]);
    return this._withLock(this._loadImpl(options2)).done(function(result2) {
      that._eventsStrategy.fireEvent("loaded", [result2, options2]);
    });
  },
  _loadImpl: function(options2) {
    if (!isEmptyObject(this._langParams)) {
      options2 = options2 || {};
      options2._langParams = _extends({}, this._langParams, options2._langParams);
    }
    return queryByOptions2(this.createQuery(options2), options2).enumerate();
  },
  _withLock: function(task) {
    const result2 = new Deferred();
    task.done(function() {
      const that = this;
      const args = arguments;
      processRequestResultLock.promise().done(function() {
        result2.resolveWith(that, args);
      });
    }).fail(function() {
      result2.rejectWith(this, arguments);
    });
    return result2;
  },
  createQuery: abstract2,
  totalCount: function(options2) {
    return this._totalCountImpl(options2);
  },
  _totalCountImpl: function(options2) {
    return queryByOptions2(this.createQuery(options2), options2, true).count();
  },
  byKey: function(key, extraOptions) {
    return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)));
  },
  _byKeyImpl: abstract2,
  insert: function(values) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("inserting", [values]);
    return that._addFailHandlers(that._insertImpl(values).done(function(callbackValues, callbackKey) {
      that._eventsStrategy.fireEvent("inserted", [callbackValues, callbackKey]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _insertImpl: abstract2,
  update: function(key, values) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("updating", [key, values]);
    return that._addFailHandlers(that._updateImpl(key, values).done(function() {
      that._eventsStrategy.fireEvent("updated", [key, values]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _updateImpl: abstract2,
  push: function(changes) {
    const beforePushArgs = {
      changes,
      waitFor: []
    };
    this._eventsStrategy.fireEvent("beforePushAggregation", [beforePushArgs]);
    when(...beforePushArgs.waitFor).done(() => {
      this._pushImpl(changes);
      this._eventsStrategy.fireEvent("beforePush", [{
        changes
      }]);
      this._eventsStrategy.fireEvent("push", [changes]);
    });
  },
  _pushImpl: noop2,
  remove: function(key) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("removing", [key]);
    return that._addFailHandlers(that._removeImpl(key).done(function(callbackKey) {
      that._eventsStrategy.fireEvent("removed", [callbackKey]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _removeImpl: abstract2,
  _addFailHandlers: function(deferred) {
    return deferred.fail(this._errorHandler).fail(handleError);
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
Store.create = function(alias, options2) {
  if (!(alias in storeImpl)) {
    throw errors.Error("E4020", alias);
  }
  return new storeImpl[alias](options2);
};
Store.registerClass = function(type2, alias) {
  if (alias) {
    storeImpl[alias] = type2;
  }
  return type2;
};
Store.inherit = function(inheritor) {
  return function(members, alias) {
    const type2 = inheritor.apply(this, [members]);
    Store.registerClass(type2, alias);
    return type2;
  };
}(Store.inherit);
var abstract_store_default = Store;

// ../../../../../../node_modules/devextreme/esm/data/custom_store.js
var TOTAL_COUNT = "totalCount";
var LOAD = "load";
var BY_KEY = "byKey";
var INSERT = "insert";
var UPDATE = "update";
var REMOVE = "remove";
function isPromise2(obj) {
  return obj && isFunction(obj.then);
}
function trivialPromise2(value2) {
  return new Deferred().resolve(value2).promise();
}
function ensureRequiredFuncOption(name2, obj) {
  if (!isFunction(obj)) {
    throw errors.Error("E4011", name2);
  }
}
function throwInvalidUserFuncResult(name2) {
  throw errors.Error("E4012", name2);
}
function createUserFuncFailureHandler(pendingDeferred) {
  return function(arg) {
    let error;
    if (arg instanceof Error) {
      error = arg;
    } else {
      error = new Error(function(promiseArguments) {
        const xhr = promiseArguments[0];
        const textStatus = promiseArguments[1];
        if (!xhr || !xhr.getResponseHeader) {
          return null;
        }
        return errorMessageFromXhr(xhr, textStatus);
      }(arguments) || arg && String(arg) || "Unknown error");
    }
    if (error.message !== XHR_ERROR_UNLOAD) {
      pendingDeferred.reject(error);
    }
  };
}
function invokeUserLoad(store, options2) {
  const userFunc = store._loadFunc;
  let userResult;
  ensureRequiredFuncOption(LOAD, userFunc);
  userResult = userFunc.apply(store, [options2]);
  if (Array.isArray(userResult)) {
    userResult = trivialPromise2(userResult);
  } else if (null === userResult || void 0 === userResult) {
    userResult = trivialPromise2([]);
  } else if (!isPromise2(userResult)) {
    throwInvalidUserFuncResult(LOAD);
  }
  return fromPromise(userResult);
}
function invokeUserTotalCountFunc(store, options2) {
  const userFunc = store._totalCountFunc;
  let userResult;
  if (!isFunction(userFunc)) {
    throw errors.Error("E4021");
  }
  userResult = userFunc.apply(store, [options2]);
  if (!isPromise2(userResult)) {
    userResult = Number(userResult);
    if (!isFinite(userResult)) {
      throwInvalidUserFuncResult(TOTAL_COUNT);
    }
    userResult = trivialPromise2(userResult);
  }
  return fromPromise(userResult);
}
function invokeUserByKeyFunc(store, key, extraOptions) {
  const userFunc = store._byKeyFunc;
  let userResult;
  ensureRequiredFuncOption(BY_KEY, userFunc);
  userResult = userFunc.apply(store, [key, extraOptions]);
  if (!isPromise2(userResult)) {
    userResult = trivialPromise2(userResult);
  }
  return fromPromise(userResult);
}
function runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {
  if (store.__rawData) {
    continuation(store.__rawData);
  } else {
    const loadPromise = store.__rawDataPromise || invokeUserLoad(store, userFuncOptions);
    if (store._cacheRawData) {
      store.__rawDataPromise = loadPromise;
    }
    loadPromise.always(function() {
      delete store.__rawDataPromise;
    }).done(function(rawData) {
      if (store._cacheRawData) {
        store.__rawData = rawData;
      }
      continuation(rawData);
    }).fail((error) => {
      var _store$_errorHandler;
      const userFuncFailureHandler = createUserFuncFailureHandler(pendingDeferred);
      null === (_store$_errorHandler = store._errorHandler) || void 0 === _store$_errorHandler || _store$_errorHandler.call(store, error);
      userFuncFailureHandler(error);
    });
  }
}
function runRawLoadWithQuery(pendingDeferred, store, options2, countOnly) {
  options2 = options2 || {};
  const userFuncOptions = {};
  if ("userData" in options2) {
    userFuncOptions.userData = options2.userData;
  }
  runRawLoad(pendingDeferred, store, userFuncOptions, function(rawData) {
    const rawDataQuery = array_query_default(rawData, {
      errorHandler: store._errorHandler
    });
    let itemsQuery;
    let totalCountQuery;
    const waitList = [];
    let items;
    let totalCount;
    if (!countOnly) {
      itemsQuery = store_helper_default.queryByOptions(rawDataQuery, options2);
      if (itemsQuery === rawDataQuery) {
        items = rawData.slice(0);
      } else {
        waitList.push(itemsQuery.enumerate().done(function(asyncResult) {
          items = asyncResult;
        }));
      }
    }
    if (options2.requireTotalCount || countOnly) {
      totalCountQuery = store_helper_default.queryByOptions(rawDataQuery, options2, true);
      if (totalCountQuery === rawDataQuery) {
        totalCount = rawData.length;
      } else {
        waitList.push(totalCountQuery.count().done(function(asyncResult) {
          totalCount = asyncResult;
        }));
      }
    }
    when.apply(renderer_default, waitList).done(function() {
      if (countOnly) {
        pendingDeferred.resolve(totalCount);
      } else if (options2.requireTotalCount) {
        pendingDeferred.resolve(items, {
          totalCount
        });
      } else {
        pendingDeferred.resolve(items);
      }
    }).fail(function(x) {
      pendingDeferred.reject(x);
    });
  });
}
function runRawLoadWithKey(pendingDeferred, store, key) {
  runRawLoad(pendingDeferred, store, {}, function(rawData) {
    const keyExpr = store.key();
    let item;
    for (let i = 0, len = rawData.length; i < len; i++) {
      item = rawData[i];
      if (keysEqual(keyExpr, store.keyOf(rawData[i]), key)) {
        pendingDeferred.resolve(item);
        return;
      }
    }
    pendingDeferred.reject(errors.Error("E4009"));
  });
}
var CustomStore = abstract_store_default.inherit({
  ctor: function(options2) {
    options2 = options2 || {};
    this.callBase(options2);
    this._useDefaultSearch = !!options2.useDefaultSearch || "raw" === options2.loadMode;
    this._loadMode = options2.loadMode;
    this._cacheRawData = false !== options2.cacheRawData;
    this._loadFunc = options2[LOAD];
    this._totalCountFunc = options2[TOTAL_COUNT];
    this._byKeyFunc = options2[BY_KEY];
    this._insertFunc = options2[INSERT];
    this._updateFunc = options2[UPDATE];
    this._removeFunc = options2[REMOVE];
  },
  _clearCache() {
    delete this.__rawData;
  },
  createQuery: function() {
    throw errors.Error("E4010");
  },
  clearRawDataCache: function() {
    this._clearCache();
  },
  _totalCountImpl: function(options2) {
    let d = new Deferred();
    if ("raw" === this._loadMode && !this._totalCountFunc) {
      runRawLoadWithQuery(d, this, options2, true);
    } else {
      invokeUserTotalCountFunc(this, options2).done(function(count) {
        d.resolve(Number(count));
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _pushImpl: function(changes) {
    if (this.__rawData) {
      applyBatch({
        keyInfo: this,
        data: this.__rawData,
        changes
      });
    }
  },
  _loadImpl: function(options2) {
    let d = new Deferred();
    if ("raw" === this._loadMode) {
      runRawLoadWithQuery(d, this, options2, false);
    } else {
      invokeUserLoad(this, options2).done(function(data2, extra) {
        d.resolve(data2, extra);
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _byKeyImpl: function(key, extraOptions) {
    const d = new Deferred();
    if (this._byKeyViaLoad()) {
      this._requireKey();
      runRawLoadWithKey(d, this, key);
    } else {
      invokeUserByKeyFunc(this, key, extraOptions).done(function(obj) {
        d.resolve(obj);
      }).fail(createUserFuncFailureHandler(d));
    }
    return d.promise();
  },
  _byKeyViaLoad: function() {
    return "raw" === this._loadMode && !this._byKeyFunc;
  },
  _insertImpl: function(values) {
    const that = this;
    const userFunc = that._insertFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(INSERT, userFunc);
    userResult = userFunc.apply(that, [values]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2(userResult);
    }
    fromPromise(userResult).done(function(serverResponse) {
      if (config_default().useLegacyStoreResult) {
        d.resolve(values, serverResponse);
      } else {
        d.resolve(serverResponse || values, that.keyOf(serverResponse));
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _updateImpl: function(key, values) {
    const userFunc = this._updateFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(UPDATE, userFunc);
    userResult = userFunc.apply(this, [key, values]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2(userResult);
    }
    fromPromise(userResult).done(function(serverResponse) {
      if (config_default().useLegacyStoreResult) {
        d.resolve(key, values);
      } else {
        d.resolve(serverResponse || values, key);
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _removeImpl: function(key) {
    const userFunc = this._removeFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(REMOVE, userFunc);
    userResult = userFunc.apply(this, [key]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2();
    }
    fromPromise(userResult).done(function() {
      d.resolve(key);
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  }
});
var custom_store_default = CustomStore;

// ../../../../../../node_modules/devextreme/esm/core/utils/queue.js
function createQueue2(discardPendingTasks) {
  let _tasks = [];
  let _busy = false;
  function exec() {
    while (_tasks.length) {
      _busy = true;
      const task = _tasks.shift();
      const result2 = task();
      if (void 0 === result2) {
        continue;
      }
      if (result2.then) {
        when(result2).always(exec);
        return;
      }
      throw errors_default.Error("E0015");
    }
    _busy = false;
  }
  return {
    add: function(task, removeTaskCallback) {
      if (!discardPendingTasks) {
        _tasks.push(task);
      } else {
        if (_tasks[0] && removeTaskCallback) {
          removeTaskCallback(_tasks[0]);
        }
        _tasks = [task];
      }
      if (!_busy) {
        exec();
      }
    },
    busy: function() {
      return _busy;
    }
  };
}
var enqueue = createQueue2().add;

// ../../../../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r)
    return {};
  var t = {};
  for (var n in r)
    if ({}.hasOwnProperty.call(r, n)) {
      if (e.includes(n))
        continue;
      t[n] = r[n];
    }
  return t;
}

// ../../../../../../node_modules/devextreme/esm/core/http_request.js
var window8 = getWindow();
var nativeXMLHttpRequest = {
  getXhr: function() {
    return new window8.XMLHttpRequest();
  }
};
var http_request_default = dependency_injector_default(nativeXMLHttpRequest);

// ../../../../../../node_modules/devextreme/esm/core/utils/ajax_utils.js
var window9 = getWindow();
var createScript = function(options2) {
  const script = dom_adapter_default.createElement("script");
  for (const name2 in options2) {
    script[name2] = options2[name2];
  }
  return script;
};
var appendToHead = function(element) {
  return dom_adapter_default.getHead().appendChild(element);
};
var removeScript = function(scriptNode) {
  scriptNode.parentNode.removeChild(scriptNode);
};
var evalScript = function(code) {
  const script = createScript({
    text: code
  });
  appendToHead(script);
  removeScript(script);
};
var evalCrossDomainScript = function(url) {
  const script = createScript({
    src: url
  });
  return new Promise(function(resolve, reject) {
    const events = {
      load: resolve,
      error: reject
    };
    const loadHandler = function(e) {
      events[e.type]();
      removeScript(script);
    };
    for (const event in events) {
      dom_adapter_default.listen(script, event, loadHandler);
    }
    appendToHead(script);
  });
};
function getMethod(options2) {
  return (options2.method || "GET").toUpperCase();
}
var paramsConvert = function(params) {
  const result2 = [];
  for (const name2 in params) {
    let value2 = params[name2];
    if (void 0 === value2) {
      continue;
    }
    if (null === value2) {
      value2 = "";
    }
    if ("function" === typeof value2) {
      value2 = value2();
    }
    result2.push(encodeURIComponent(name2) + "=" + encodeURIComponent(value2));
  }
  return result2.join("&");
};
var getContentTypeHeader = function(options2) {
  let defaultContentType;
  if (options2.data && !options2.upload && "GET" !== getMethod(options2)) {
    defaultContentType = "application/x-www-form-urlencoded;charset=utf-8";
  }
  return options2.contentType || defaultContentType;
};
var getAcceptHeader = function(options2) {
  const dataType = options2.dataType || "*";
  const scriptAccept = "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript";
  const accepts = {
    "*": "*/*",
    text: "text/plain",
    html: "text/html",
    xml: "application/xml, text/xml",
    json: "application/json, text/javascript",
    jsonp: scriptAccept,
    script: scriptAccept
  };
  extendFromObject(accepts, options2.accepts, true);
  return accepts[dataType] ? accepts[dataType] + ("*" !== dataType ? ", */*; q=0.01" : "") : accepts["*"];
};
var getRequestHeaders = function(options2) {
  const headers = options2.headers || {};
  headers["Content-Type"] = headers["Content-Type"] || getContentTypeHeader(options2);
  headers.Accept = headers.Accept || getAcceptHeader(options2);
  if (!options2.crossDomain && !headers["X-Requested-With"]) {
    headers["X-Requested-With"] = "XMLHttpRequest";
  }
  return headers;
};
var getJsonpOptions = function(options2) {
  if ("jsonp" === options2.dataType) {
    const random = Math.random().toString().replace(/\D/g, "");
    const callbackName = options2.jsonpCallback || "dxCallback" + Date.now() + "_" + random;
    const callbackParameter = options2.jsonp || "callback";
    options2.data = options2.data || {};
    options2.data[callbackParameter] = callbackName;
    return callbackName;
  }
};
var getRequestOptions = function(options2, headers) {
  let params = options2.data;
  const paramsAlreadyString = "string" === typeof params;
  let url = options2.url || window9.location.href;
  if (!paramsAlreadyString && !options2.cache) {
    params = params || {};
    params._ = Date.now();
  }
  if (params && !options2.upload) {
    if (!paramsAlreadyString) {
      params = paramsConvert(params);
    }
    if ("GET" === getMethod(options2)) {
      if ("" !== params) {
        url += (url.indexOf("?") > -1 ? "&" : "?") + params;
      }
      params = null;
    } else if (headers["Content-Type"] && headers["Content-Type"].indexOf("application/x-www-form-urlencoded") > -1) {
      params = params.replace(/%20/g, "+");
    }
  }
  return {
    url,
    parameters: params
  };
};
var isCrossDomain = function(url) {
  if (!hasWindow()) {
    return true;
  }
  let crossDomain = false;
  const originAnchor = dom_adapter_default.createElement("a");
  const urlAnchor = dom_adapter_default.createElement("a");
  originAnchor.href = window9.location.href;
  try {
    urlAnchor.href = url;
    urlAnchor.href = urlAnchor.href;
    crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
  } catch (e) {
    crossDomain = true;
  }
  return crossDomain;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/ajax.js
var window10 = getWindow();
var SUCCESS = "success";
var ERROR = "error";
var TIMEOUT = "timeout";
var NO_CONTENT = "nocontent";
var PARSER_ERROR = "parsererror";
var isStatusSuccess = function(status) {
  return 200 <= status && status < 300;
};
var hasContent = function(status) {
  return 204 !== status;
};
var getDataFromResponse = function(xhr) {
  return xhr.responseType && "text" !== xhr.responseType || "string" !== typeof xhr.responseText ? xhr.response : xhr.responseText;
};
var postProcess = function(deferred, xhr, dataType) {
  const data2 = getDataFromResponse(xhr);
  switch (dataType) {
    case "jsonp":
      evalScript(data2);
      break;
    case "script":
      evalScript(data2);
      deferred.resolve(data2, SUCCESS, xhr);
      break;
    case "json":
      try {
        deferred.resolve(JSON.parse(data2), SUCCESS, xhr);
      } catch (e) {
        deferred.reject(xhr, PARSER_ERROR, e);
      }
      break;
    default:
      deferred.resolve(data2, SUCCESS, xhr);
  }
};
var setHttpTimeout = function(timeout, xhr) {
  return timeout && setTimeout(function() {
    xhr.customStatus = TIMEOUT;
    xhr.abort();
  }, timeout);
};
var sendRequest = function(options2) {
  const xhr = http_request_default.getXhr();
  const d = new Deferred();
  const result2 = d.promise();
  const async = isDefined(options2.async) ? options2.async : true;
  const dataType = options2.dataType;
  const timeout = options2.timeout || 0;
  let timeoutId;
  options2.crossDomain = isCrossDomain(options2.url);
  const needScriptEvaluation = "jsonp" === dataType || "script" === dataType;
  if (void 0 === options2.cache) {
    options2.cache = !needScriptEvaluation;
  }
  const callbackName = getJsonpOptions(options2);
  const headers = getRequestHeaders(options2);
  const requestOptions = getRequestOptions(options2, headers);
  const url = requestOptions.url;
  const parameters = requestOptions.parameters;
  if (callbackName) {
    window10[callbackName] = function(data2) {
      d.resolve(data2, SUCCESS, xhr);
    };
  }
  if (options2.crossDomain && needScriptEvaluation) {
    const reject = function() {
      d.reject(xhr, ERROR);
    };
    const resolve = function() {
      if ("jsonp" === dataType) {
        return;
      }
      d.resolve(null, SUCCESS, xhr);
    };
    evalCrossDomainScript(url).then(resolve, reject);
    return result2;
  }
  if (options2.crossDomain && !("withCredentials" in xhr)) {
    d.reject(xhr, ERROR);
    return result2;
  }
  xhr.open(getMethod(options2), url, async, options2.username, options2.password);
  if (async) {
    xhr.timeout = timeout;
    timeoutId = setHttpTimeout(timeout, xhr);
  }
  xhr.onreadystatechange = function(e) {
    if (4 === xhr.readyState) {
      clearTimeout(timeoutId);
      if (isStatusSuccess(xhr.status)) {
        if (hasContent(xhr.status)) {
          postProcess(d, xhr, dataType);
        } else {
          d.resolve(null, NO_CONTENT, xhr);
        }
      } else {
        d.reject(xhr, xhr.customStatus || ERROR);
      }
    }
  };
  if (options2.upload) {
    xhr.upload.onprogress = options2.upload.onprogress;
    xhr.upload.onloadstart = options2.upload.onloadstart;
    xhr.upload.onabort = options2.upload.onabort;
  }
  if (options2.xhrFields) {
    for (const field in options2.xhrFields) {
      xhr[field] = options2.xhrFields[field];
    }
  }
  if ("arraybuffer" === options2.responseType) {
    xhr.responseType = options2.responseType;
  }
  for (const name2 in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name2) && isDefined(headers[name2])) {
      xhr.setRequestHeader(name2, headers[name2]);
    }
  }
  if (options2.beforeSend) {
    options2.beforeSend(xhr);
  }
  xhr.send(parameters);
  result2.abort = function() {
    xhr.abort();
  };
  return result2;
};
var ajax_default = dependency_injector_default({
  sendRequest
});

// ../../../../../../node_modules/devextreme/esm/data/query_adapters.js
var query_adapters_default = {};

// ../../../../../../node_modules/devextreme/esm/data/remote_query.js
var remoteQueryImpl = function(url, queryOptions, tasks) {
  tasks = tasks || [];
  queryOptions = queryOptions || {};
  const createTask = function(name2, args) {
    return {
      name: name2,
      args
    };
  };
  const exec = function(executorTask) {
    const d = new Deferred();
    let _adapterFactory;
    let _adapter;
    let _taskQueue;
    let _currentTask;
    let _mergedSortArgs;
    const rejectWithNotify = function(error) {
      const handler = queryOptions.errorHandler;
      if (handler) {
        handler(error);
      }
      handleError(error);
      d.reject(error);
    };
    function mergeSortTask(task) {
      switch (task.name) {
        case "sortBy":
          _mergedSortArgs = [task.args];
          return true;
        case "thenBy":
          if (!_mergedSortArgs) {
            throw errors.Error("E4004");
          }
          _mergedSortArgs.push(task.args);
          return true;
      }
      return false;
    }
    try {
      _adapterFactory = queryOptions.adapter;
      if (!isFunction(_adapterFactory)) {
        _adapterFactory = query_adapters_default[_adapterFactory];
      }
      _adapter = _adapterFactory(queryOptions);
      _taskQueue = [].concat(tasks).concat(executorTask);
      const optimize = _adapter.optimize;
      if (optimize) {
        optimize(_taskQueue);
      }
      while (_taskQueue.length) {
        _currentTask = _taskQueue[0];
        if (!mergeSortTask(_currentTask)) {
          if (_mergedSortArgs) {
            _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
            _mergedSortArgs = null;
            continue;
          }
          if ("enumerate" !== String(_currentTask.name)) {
            if (!_adapter[_currentTask.name] || false === _adapter[_currentTask.name].apply(_adapter, _currentTask.args)) {
              break;
            }
          }
        }
        _taskQueue.shift();
      }
      !function() {
        const head = _taskQueue[0];
        const unmergedTasks = [];
        if (head && "multiSort" === head.name) {
          _taskQueue.shift();
          each(head.args[0], function() {
            unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this));
          });
        }
        _taskQueue = unmergedTasks.concat(_taskQueue);
      }();
      _adapter.exec(url).done(function(result2, extra) {
        if (!_taskQueue.length) {
          d.resolve(result2, extra);
        } else {
          let clientChain = array_query_default(result2, {
            errorHandler: queryOptions.errorHandler
          });
          each(_taskQueue, function() {
            clientChain = clientChain[this.name].apply(clientChain, this.args);
          });
          clientChain.done(d.resolve).fail(d.reject);
        }
      }).fail(rejectWithNotify);
    } catch (x) {
      rejectWithNotify(x);
    }
    return d.promise();
  };
  const query2 = {};
  each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
    const name2 = String(this);
    query2[name2] = function() {
      return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name2, arguments)));
    };
  });
  each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
    const name2 = String(this);
    query2[name2] = function() {
      return exec.call(this, createTask(name2, arguments));
    };
  });
  return query2;
};
var remote_query_default = remoteQueryImpl;

// ../../../../../../node_modules/devextreme/esm/data/query_implementation.js
var queryImpl = {
  array: array_query_default,
  remote: remote_query_default
};

// ../../../../../../node_modules/devextreme/esm/data/query.js
var query = function() {
  const impl = Array.isArray(arguments[0]) ? "array" : "remote";
  return queryImpl[impl].apply(this, arguments);
};
var query_default = query;

// ../../../../../../node_modules/devextreme/esm/data/array_store.js
var ArrayStore = abstract_store_default.inherit({
  ctor: function(options2) {
    if (Array.isArray(options2)) {
      options2 = {
        data: options2
      };
    } else {
      options2 = options2 || {};
    }
    this.callBase(options2);
    const initialArray = options2.data;
    if (initialArray && !Array.isArray(initialArray)) {
      throw errors.Error("E4006");
    }
    this._array = initialArray || [];
  },
  createQuery: function() {
    return query_default(this._array, {
      errorHandler: this._errorHandler
    });
  },
  _byKeyImpl: function(key) {
    const index2 = indexByKey(this, this._array, key);
    if (-1 === index2) {
      return rejectedPromise(errors.Error("E4009"));
    }
    return trivialPromise(this._array[index2]);
  },
  _insertImpl: function(values) {
    return insert(this, this._array, values);
  },
  _pushImpl: function(changes) {
    applyBatch({
      keyInfo: this,
      data: this._array,
      changes
    });
  },
  _updateImpl: function(key, values) {
    return update(this, this._array, key, values);
  },
  _removeImpl: function(key) {
    return remove(this, this._array, key);
  },
  clear: function() {
    this._eventsStrategy.fireEvent("modifying");
    this._array = [];
    this._eventsStrategy.fireEvent("modified");
  }
}, "array");
var array_store_default = ArrayStore;

// ../../../../../../node_modules/devextreme/esm/data/data_source/utils.js
var _excluded = ["items"];
var CANCELED_TOKEN = "canceled";
var isPending = (deferred) => "pending" === deferred.state();
var normalizeStoreLoadOptionAccessorArguments = (originalArguments) => {
  switch (originalArguments.length) {
    case 0:
      return;
    case 1:
      return originalArguments[0];
  }
  return [].slice.call(originalArguments);
};
var mapGroup = (group, level, mapper) => map(group, (item) => {
  const restItem = _objectWithoutPropertiesLoose(item, _excluded);
  return _extends({}, restItem, {
    items: mapRecursive(item.items, level - 1, mapper)
  });
});
var mapRecursive = (items, level, mapper) => {
  if (!Array.isArray(items)) {
    return items;
  }
  return level ? mapGroup(items, level, mapper) : map(items, mapper);
};
var mapDataRespectingGrouping = (items, mapper, groupInfo) => {
  const level = groupInfo ? normalizeSortingInfo(groupInfo).length : 0;
  return mapRecursive(items, level, mapper);
};
var normalizeLoadResult = (data2, extra) => {
  var _data;
  if (null !== (_data = data2) && void 0 !== _data && _data.data) {
    extra = data2;
    data2 = data2.data;
  }
  if (!Array.isArray(data2)) {
    data2 = [data2];
  }
  return {
    data: data2,
    extra
  };
};
var createCustomStoreFromLoadFunc = (options2) => {
  const storeConfig = {};
  each(["useDefaultSearch", "key", "load", "loadMode", "cacheRawData", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
    storeConfig[this] = options2[this];
    delete options2[this];
  });
  return new custom_store_default(storeConfig);
};
var createStoreFromConfig = (storeConfig) => {
  const alias = storeConfig.type;
  delete storeConfig.type;
  return abstract_store_default.create(alias, storeConfig);
};
var createCustomStoreFromUrl = (url, normalizationOptions) => new custom_store_default({
  load: () => ajax_default.sendRequest({
    url,
    dataType: "json"
  }),
  loadMode: null === normalizationOptions || void 0 === normalizationOptions ? void 0 : normalizationOptions.fromUrlLoadMode
});
var normalizeDataSourceOptions = (options2, normalizationOptions) => {
  let store;
  if ("string" === typeof options2) {
    options2 = {
      paginate: false,
      store: createCustomStoreFromUrl(options2, normalizationOptions)
    };
  }
  if (void 0 === options2) {
    options2 = [];
  }
  if (Array.isArray(options2) || options2 instanceof abstract_store_default) {
    options2 = {
      store: options2
    };
  } else {
    options2 = extend({}, options2);
  }
  if (void 0 === options2.store) {
    options2.store = [];
  }
  store = options2.store;
  if ("load" in options2) {
    store = createCustomStoreFromLoadFunc(options2);
  } else if (Array.isArray(store)) {
    store = new array_store_default(store);
  } else if (isPlainObject(store)) {
    store = createStoreFromConfig(extend({}, store));
  }
  options2.store = store;
  return options2;
};

// ../../../../../../node_modules/devextreme/esm/data/data_source/operation_manager.js
var OperationManager = class {
  constructor() {
    this._counter = -1;
    this._deferreds = {};
  }
  add(deferred) {
    this._counter++;
    this._deferreds[this._counter] = deferred;
    return this._counter;
  }
  remove(operationId) {
    return delete this._deferreds[operationId];
  }
  cancel(operationId) {
    if (operationId in this._deferreds) {
      this._deferreds[operationId].reject(CANCELED_TOKEN);
      return true;
    }
    return false;
  }
  cancelAll() {
    while (this._counter > -1) {
      this.cancel(this._counter);
      this._counter--;
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/data/data_source/data_source.js
var DataSource = class_default.inherit({
  ctor(options2) {
    options2 = normalizeDataSourceOptions(options2);
    this._eventsStrategy = new EventsStrategy(this, {
      syncStrategy: true
    });
    this._store = options2.store;
    this._changedTime = 0;
    const needThrottling = 0 !== options2.pushAggregationTimeout;
    if (needThrottling) {
      const throttlingTimeout = void 0 === options2.pushAggregationTimeout ? () => 5 * this._changedTime : options2.pushAggregationTimeout;
      let pushDeferred;
      let lastPushWaiters;
      const throttlingPushHandler = throttleChanges((changes) => {
        pushDeferred.resolve();
        const storePushPending = when(...lastPushWaiters);
        storePushPending.done(() => this._onPush(changes));
        lastPushWaiters = void 0;
        pushDeferred = void 0;
      }, throttlingTimeout);
      this._onPushHandler = (args) => {
        this._aggregationTimeoutId = throttlingPushHandler(args.changes);
        if (!pushDeferred) {
          pushDeferred = new Deferred();
        }
        lastPushWaiters = args.waitFor;
        args.waitFor.push(pushDeferred.promise());
      };
      this._store.on("beforePushAggregation", this._onPushHandler);
    } else {
      this._onPushHandler = (changes) => this._onPush(changes);
      this._store.on("push", this._onPushHandler);
    }
    this._storeLoadOptions = this._extractLoadOptions(options2);
    this._mapFunc = options2.map;
    this._postProcessFunc = options2.postProcess;
    this._pageIndex = void 0 !== options2.pageIndex ? options2.pageIndex : 0;
    this._pageSize = void 0 !== options2.pageSize ? options2.pageSize : 20;
    this._loadingCount = 0;
    this._loadQueue = this._createLoadQueue();
    this._searchValue = "searchValue" in options2 ? options2.searchValue : null;
    this._searchOperation = options2.searchOperation || "contains";
    this._searchExpr = options2.searchExpr;
    this._paginate = options2.paginate;
    this._reshapeOnPush = options2.reshapeOnPush ?? false;
    each(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], (_, optionName) => {
      if (optionName in options2) {
        this.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options2[optionName]);
      }
    });
    this._operationManager = new OperationManager();
    this._init();
  },
  _init() {
    this._items = [];
    this._userData = {};
    this._totalCount = -1;
    this._isLoaded = false;
    if (!isDefined(this._paginate)) {
      this._paginate = !this.group();
    }
    this._isLastPage = !this._paginate;
  },
  dispose() {
    var _this$_delayedLoadTas;
    this._store.off("beforePushAggregation", this._onPushHandler);
    this._store.off("push", this._onPushHandler);
    this._eventsStrategy.dispose();
    clearTimeout(this._aggregationTimeoutId);
    null === (_this$_delayedLoadTas = this._delayedLoadTask) || void 0 === _this$_delayedLoadTas || _this$_delayedLoadTas.abort();
    this._operationManager.cancelAll();
    delete this._store;
    delete this._items;
    delete this._delayedLoadTask;
    this._disposed = true;
  },
  _extractLoadOptions(options2) {
    const result2 = {};
    let names = ["sort", "filter", "langParams", "select", "group", "requireTotalCount"];
    const customNames = this._store._customLoadOptions();
    if (customNames) {
      names = names.concat(customNames);
    }
    each(names, function() {
      result2[this] = options2[this];
    });
    return result2;
  },
  loadOptions() {
    return this._storeLoadOptions;
  },
  items() {
    return this._items;
  },
  pageIndex(newIndex) {
    if (!isNumeric(newIndex)) {
      return this._pageIndex;
    }
    this._pageIndex = newIndex;
    this._isLastPage = !this._paginate;
  },
  paginate(value2) {
    if (!isBoolean(value2)) {
      return this._paginate;
    }
    if (this._paginate !== value2) {
      this._paginate = value2;
      this.pageIndex(0);
    }
  },
  pageSize(value2) {
    if (!isNumeric(value2)) {
      return this._pageSize;
    }
    this._pageSize = value2;
  },
  isLastPage() {
    return this._isLastPage;
  },
  generateStoreLoadOptionAccessor(optionName) {
    return (args) => {
      const normalizedArgs = normalizeStoreLoadOptionAccessorArguments(args);
      if (void 0 === normalizedArgs) {
        return this._storeLoadOptions[optionName];
      }
      this._storeLoadOptions[optionName] = normalizedArgs;
    };
  },
  sort() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.generateStoreLoadOptionAccessor("sort")(args);
  },
  filter() {
    const newFilter = normalizeStoreLoadOptionAccessorArguments(arguments);
    if (void 0 === newFilter) {
      return this._storeLoadOptions.filter;
    }
    this._storeLoadOptions.filter = newFilter;
    this.pageIndex(0);
  },
  group() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.generateStoreLoadOptionAccessor("group")(args);
  },
  select() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.generateStoreLoadOptionAccessor("select")(args);
  },
  requireTotalCount(value2) {
    if (!isBoolean(value2)) {
      return this._storeLoadOptions.requireTotalCount;
    }
    this._storeLoadOptions.requireTotalCount = value2;
  },
  searchValue(value2) {
    if (arguments.length < 1) {
      return this._searchValue;
    }
    this._searchValue = value2;
    this.pageIndex(0);
  },
  searchOperation(op) {
    if (!isString(op)) {
      return this._searchOperation;
    }
    this._searchOperation = op;
    this.pageIndex(0);
  },
  searchExpr(expr) {
    const argc = arguments.length;
    if (0 === argc) {
      return this._searchExpr;
    }
    if (argc > 1) {
      expr = [].slice.call(arguments);
    }
    this._searchExpr = expr;
    this.pageIndex(0);
  },
  store() {
    return this._store;
  },
  key() {
    var _this$_store;
    return null === (_this$_store = this._store) || void 0 === _this$_store ? void 0 : _this$_store.key();
  },
  totalCount() {
    return this._totalCount;
  },
  isLoaded() {
    return this._isLoaded;
  },
  isLoading() {
    return this._loadingCount > 0;
  },
  beginLoading() {
    this._changeLoadingCount(1);
  },
  endLoading() {
    this._changeLoadingCount(-1);
  },
  _createLoadQueue: () => createQueue2(),
  _changeLoadingCount(increment) {
    const oldLoading = this.isLoading();
    this._loadingCount += increment;
    const newLoading = this.isLoading();
    if (oldLoading ^ newLoading) {
      this._eventsStrategy.fireEvent("loadingChanged", [newLoading]);
    }
  },
  _scheduleLoadCallbacks(deferred) {
    this.beginLoading();
    deferred.always(() => {
      this.endLoading();
    });
  },
  _scheduleFailCallbacks(deferred) {
    var _this = this;
    deferred.fail(function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      if (args[0] === CANCELED_TOKEN) {
        return;
      }
      _this._eventsStrategy.fireEvent("loadError", args);
    });
  },
  _fireChanged(args) {
    const date = /* @__PURE__ */ new Date();
    this._eventsStrategy.fireEvent("changed", args);
    this._changedTime = /* @__PURE__ */ new Date() - date;
  },
  _scheduleChangedCallbacks(deferred) {
    deferred.done(() => this._fireChanged());
  },
  loadSingle(propName, propValue) {
    const d = new Deferred();
    const key = this.key();
    const store = this._store;
    const options2 = this._createStoreLoadOptions();
    this._scheduleFailCallbacks(d);
    if (arguments.length < 2) {
      propValue = propName;
      propName = key;
    }
    delete options2.skip;
    delete options2.group;
    delete options2.refresh;
    delete options2.pageIndex;
    delete options2.searchString;
    (() => {
      if (propName === key || store instanceof custom_store_default && !store._byKeyViaLoad()) {
        return store.byKey(propValue, options2);
      }
      options2.take = 1;
      options2.filter = options2.filter ? [options2.filter, [propName, propValue]] : [propName, propValue];
      return store.load(options2);
    })().fail(d.reject).done((data2) => {
      const isEmptyArray = Array.isArray(data2) && !data2.length;
      if (!isDefined(data2) || isEmptyArray) {
        d.reject(new errors.Error("E4009"));
      } else {
        if (!Array.isArray(data2)) {
          data2 = [data2];
        }
        d.resolve(this._applyMapFunction(data2)[0]);
      }
    });
    return d.promise();
  },
  load() {
    const d = new Deferred();
    const loadTask = () => {
      if (this._disposed) {
        return;
      }
      if (!isPending(d)) {
        return;
      }
      return this._loadFromStore(loadOperation, d);
    };
    this._scheduleLoadCallbacks(d);
    this._scheduleFailCallbacks(d);
    this._scheduleChangedCallbacks(d);
    const loadOperation = this._createLoadOperation(d);
    this._eventsStrategy.fireEvent("customizeStoreLoadOptions", [loadOperation]);
    this._loadQueue.add(() => {
      if ("number" === typeof loadOperation.delay) {
        this._delayedLoadTask = executeAsync(loadTask, loadOperation.delay);
      } else {
        loadTask();
      }
      return d.promise();
    });
    return d.promise({
      operationId: loadOperation.operationId
    });
  },
  _onPush(changes) {
    if (this._reshapeOnPush) {
      this.load();
    } else {
      const changingArgs = {
        changes
      };
      this._eventsStrategy.fireEvent("changing", [changingArgs]);
      const group = this.group();
      const items = this.items();
      let groupLevel = 0;
      let dataSourceChanges = this.paginate() || group ? changes.filter((item) => "update" === item.type) : changes;
      if (group) {
        groupLevel = Array.isArray(group) ? group.length : 1;
      }
      if (this._mapFunc) {
        dataSourceChanges.forEach((item) => {
          if ("insert" === item.type) {
            item.data = this._mapFunc(item.data);
          }
        });
      }
      if (changingArgs.postProcessChanges) {
        dataSourceChanges = changingArgs.postProcessChanges(dataSourceChanges);
      }
      applyBatch({
        keyInfo: this.store(),
        data: items,
        changes: dataSourceChanges,
        groupCount: groupLevel,
        useInsertIndex: true
      });
      this._fireChanged([{
        changes
      }]);
    }
  },
  _createLoadOperation(deferred) {
    const operationId = this._operationManager.add(deferred);
    const storeLoadOptions = this._createStoreLoadOptions();
    if (this._store && !isEmptyObject(null === storeLoadOptions || void 0 === storeLoadOptions ? void 0 : storeLoadOptions.langParams)) {
      this._store._langParams = _extends({}, this._store._langParams, storeLoadOptions.langParams);
    }
    deferred.always(() => this._operationManager.remove(operationId));
    return {
      operationId,
      storeLoadOptions
    };
  },
  reload() {
    const store = this.store();
    store._clearCache();
    this._init();
    return this.load();
  },
  cancel(operationId) {
    return this._operationManager.cancel(operationId);
  },
  cancelAll() {
    return this._operationManager.cancelAll();
  },
  _addSearchOptions(storeLoadOptions) {
    if (this._disposed) {
      return;
    }
    if (this.store()._useDefaultSearch) {
      this._addSearchFilter(storeLoadOptions);
    } else {
      storeLoadOptions.searchOperation = this._searchOperation;
      storeLoadOptions.searchValue = this._searchValue;
      storeLoadOptions.searchExpr = this._searchExpr;
    }
  },
  _createStoreLoadOptions() {
    const result2 = extend({}, this._storeLoadOptions);
    this._addSearchOptions(result2);
    if (this._paginate) {
      if (this._pageSize) {
        result2.skip = this._pageIndex * this._pageSize;
        result2.take = this._pageSize;
      }
    }
    result2.userData = this._userData;
    return result2;
  },
  _addSearchFilter(storeLoadOptions) {
    const value2 = this._searchValue;
    const op = this._searchOperation;
    let selector = this._searchExpr;
    const searchFilter = [];
    if (!value2) {
      return;
    }
    if (!selector) {
      selector = "this";
    }
    if (!Array.isArray(selector)) {
      selector = [selector];
    }
    each(selector, function(i, item) {
      if (searchFilter.length) {
        searchFilter.push("or");
      }
      searchFilter.push([item, op, value2]);
    });
    if (storeLoadOptions.filter) {
      storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter];
    } else {
      storeLoadOptions.filter = searchFilter;
    }
  },
  _loadFromStore(loadOptions, pendingDeferred) {
    const handleSuccess = (data2, extra) => {
      if (this._disposed) {
        return;
      }
      if (!isPending(pendingDeferred)) {
        return;
      }
      const loadResult = extend(normalizeLoadResult(data2, extra), loadOptions);
      this._eventsStrategy.fireEvent("customizeLoadResult", [loadResult]);
      when(loadResult.data).done((data3) => {
        loadResult.data = data3;
        this._processStoreLoadResult(loadResult, pendingDeferred);
      }).fail(pendingDeferred.reject);
    };
    if (loadOptions.data) {
      return new Deferred().resolve(loadOptions.data).done(handleSuccess);
    }
    return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject);
  },
  _processStoreLoadResult(loadResult, pendingDeferred) {
    let data2 = loadResult.data;
    let extra = loadResult.extra;
    const storeLoadOptions = loadResult.storeLoadOptions;
    const resolvePendingDeferred = () => {
      this._isLoaded = true;
      this._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
      return pendingDeferred.resolve(data2, extra);
    };
    const proceedLoadingTotalCount = () => {
      this.store().totalCount(storeLoadOptions).done(function(count) {
        extra.totalCount = count;
        resolvePendingDeferred();
      }).fail(pendingDeferred.reject);
    };
    if (this._disposed) {
      return;
    }
    data2 = this._applyPostProcessFunction(this._applyMapFunction(data2));
    if (!isObject(extra)) {
      extra = {};
    }
    this._items = data2;
    if (!data2.length || !this._paginate || this._pageSize && data2.length < this._pageSize) {
      this._isLastPage = true;
    }
    if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
      proceedLoadingTotalCount();
    } else {
      resolvePendingDeferred();
    }
  },
  _applyMapFunction(data2) {
    if (this._mapFunc) {
      return mapDataRespectingGrouping(data2, this._mapFunc, this.group());
    }
    return data2;
  },
  _applyPostProcessFunction(data2) {
    if (this._postProcessFunc) {
      return this._postProcessFunc(data2);
    }
    return data2;
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_data_controller.js
var DataControllerMock = {
  load: () => Deferred().reject(),
  loadSingle: () => Deferred().reject(),
  loadFromStore: () => Deferred().reject(),
  loadNextPage: () => Deferred().reject(),
  loadOptions: noop2,
  userData: noop2,
  cancel: noop2,
  cancelAll: noop2,
  filter: noop2,
  addSearchFilter: noop2,
  group: noop2,
  paginate: noop2,
  pageSize: noop2,
  pageIndex: noop2,
  resetDataSourcePageIndex: noop2,
  totalCount: noop2,
  isLastPage: noop2,
  isLoading: noop2,
  isLoaded: noop2,
  searchValue: noop2,
  searchOperation: noop2,
  searchExpr: noop2,
  select: noop2,
  key: noop2,
  keyOf: noop2,
  store: noop2,
  items: noop2,
  applyMapFunction: noop2,
  getDataSource: noop2,
  reload: noop2,
  on: noop2,
  off: noop2
};
var DataController = class {
  constructor(dataSource) {
    if (!dataSource) {
      return DataControllerMock;
    }
    this._dataSource = dataSource;
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(propName, propValue) {
    if (arguments.length < 2) {
      propValue = propName;
      propName = this.key();
    }
    return this._dataSource.loadSingle(propName, propValue);
  }
  loadFromStore(loadOptions) {
    return this.store().load(loadOptions);
  }
  loadNextPage() {
    this.pageIndex(1 + this.pageIndex());
    return this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(operationId) {
    this._dataSource.cancel(operationId);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(filter) {
    return this._dataSource.filter(filter);
  }
  addSearchFilter(storeLoadOptions) {
    this._dataSource._addSearchFilter(storeLoadOptions);
  }
  group(group) {
    return this._dataSource.group(group);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(pageIndex) {
    return this._dataSource.pageIndex(pageIndex);
  }
  resetDataSourcePageIndex() {
    if (this.pageIndex()) {
      this.pageIndex(0);
      this.load();
    }
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(value2) {
    if (!arguments.length) {
      return this._dataSource.searchValue();
    }
    return this._dataSource.searchValue(value2);
  }
  searchOperation(operation) {
    return this._dataSource.searchOperation(operation);
  }
  searchExpr(expr) {
    if (!arguments.length) {
      return this._dataSource.searchExpr();
    }
    return this._dataSource.searchExpr(expr);
  }
  select() {
    return this._dataSource.select(...arguments);
  }
  key() {
    return this._dataSource.key();
  }
  keyOf(item) {
    return this.store().keyOf(item);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    return this._dataSource.items();
  }
  applyMapFunction(data2) {
    return this._dataSource._applyMapFunction(data2);
  }
  getDataSource() {
    return this._dataSource || null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(event, handler) {
    this._dataSource.on(event, handler);
  }
  off(event, handler) {
    this._dataSource.off(event, handler);
  }
};
var m_data_controller_default = DataController;

// ../../../../../../node_modules/devextreme/esm/data_helper.js
var DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler";
var SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
var NORMALIZE_DATA_SOURCE = "_normalizeDataSource";
var DataHelperMixin = {
  postCtor: function() {
    this.on("disposing", (function() {
      this._disposeDataSource();
    }).bind(this));
  },
  _refreshDataSource: function() {
    this._initDataSource();
    this._loadDataSource();
  },
  _initDataSource: function() {
    let dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
    let widgetDataSourceOptions;
    let dataSourceType;
    this._disposeDataSource();
    if (dataSourceOptions) {
      if (dataSourceOptions instanceof DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = "_dataSourceOptions" in this ? this._dataSourceOptions() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
        dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
          fromUrlLoadMode: "_dataSourceFromUrlLoadMode" in this && this._dataSourceFromUrlLoadMode()
        });
        this._dataSource = new dataSourceType(extend(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }
      if (NORMALIZE_DATA_SOURCE in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource);
      }
      this._addDataSourceHandlers();
      this._initDataController();
    }
  },
  _initDataController: function() {
    var _this$option;
    const dataController = null === (_this$option = this.option) || void 0 === _this$option ? void 0 : _this$option.call(this, "_dataController");
    const dataSource = this._dataSource;
    if (dataController) {
      this._dataController = dataController;
    } else {
      this._dataController = new m_data_controller_default(dataSource);
    }
  },
  _addDataSourceHandlers: function() {
    if (DATA_SOURCE_CHANGED_METHOD in this) {
      this._addDataSourceChangeHandler();
    }
    if ("_dataSourceLoadErrorHandler" in this) {
      this._addDataSourceLoadErrorHandler();
    }
    if ("_dataSourceLoadingChangedHandler" in this) {
      this._addDataSourceLoadingChangedHandler();
    }
    this._addReadyWatcher();
  },
  _addReadyWatcher: function() {
    this.readyWatcher = (function(isLoading) {
      this._ready && this._ready(!isLoading);
    }).bind(this);
    this._dataSource.on("loadingChanged", this.readyWatcher);
  },
  _addDataSourceChangeHandler: function() {
    const dataSource = this._dataSource;
    this._proxiedDataSourceChangedHandler = (function(e) {
      this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e);
    }).bind(this);
    dataSource.on("changed", this._proxiedDataSourceChangedHandler);
  },
  _addDataSourceLoadErrorHandler: function() {
    this._proxiedDataSourceLoadErrorHandler = this._dataSourceLoadErrorHandler.bind(this);
    this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
  },
  _addDataSourceLoadingChangedHandler: function() {
    this._proxiedDataSourceLoadingChangedHandler = this._dataSourceLoadingChangedHandler.bind(this);
    this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
  },
  _loadDataSource: function() {
    const dataSource = this._dataSource;
    if (dataSource) {
      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  },
  _loadSingle: function(key, value2) {
    key = "this" === key ? this._dataSource.key() || "this" : key;
    return this._dataSource.loadSingle(key, value2);
  },
  _isLastPage: function() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  },
  _isDataSourceLoading: function() {
    return this._dataSource && this._dataSource.isLoading();
  },
  _disposeDataSource: function() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
        if (this._dataSource._eventsStrategy) {
          this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher);
        }
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  },
  getDataSource: function() {
    return this._dataSource || null;
  }
};
var data_helper_default = DataHelperMixin;

// ../../../../../../node_modules/devextreme/esm/localization/utils.js
var DECIMAL_BASE = 10;
function roundByAbs(value2) {
  const valueSign = sign(value2);
  return valueSign * Math.round(Math.abs(value2));
}
function adjustValue(value2, precision) {
  const precisionMultiplier = Math.pow(DECIMAL_BASE, precision);
  const intermediateValue = multiplyInExponentialForm(value2, precision);
  return roundByAbs(intermediateValue) / precisionMultiplier;
}
function toFixed(value2, precision) {
  const valuePrecision = precision || 0;
  const adjustedValue = valuePrecision > 0 ? adjustValue(...arguments) : value2;
  return adjustedValue.toFixed(valuePrecision);
}

// ../../../../../../node_modules/devextreme/esm/localization/ldml/number.js
var DEFAULT_CONFIG = {
  thousandsSeparator: ",",
  decimalSeparator: "."
};
var ESCAPING_CHAR = "'";
function getGroupSizes(formatString) {
  return formatString.split(",").slice(1).map(function(str) {
    let singleQuotesLeft = 0;
    return str.split("").filter(function(char, index2) {
      singleQuotesLeft += "'" === char;
      const isDigit = "#" === char || "0" === char;
      const isInStub = singleQuotesLeft % 2;
      return isDigit && !isInStub;
    }).length;
  });
}
function getSignParts(format2) {
  const signParts = format2.split(";");
  if (1 === signParts.length) {
    signParts.push("-" + signParts[0]);
  }
  return signParts;
}
function reverseString(str) {
  return str.toString().split("").reverse().join("");
}
function isPercentFormat(format2) {
  return -1 !== format2.indexOf("%") && !format2.match(/'[^']*%[^']*'/g);
}
function removeStubs(str) {
  return str.replace(/'.+'/g, "");
}
function getNonRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  const format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[#]/g, "").length;
}
function getRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  const format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[0]/g, "").length;
}
function normalizeValueString(valuePart, minDigitCount, maxDigitCount) {
  if (!valuePart) {
    return "";
  }
  if (valuePart.length > maxDigitCount) {
    valuePart = valuePart.substr(0, maxDigitCount);
  }
  while (valuePart.length > minDigitCount && "0" === valuePart.slice(-1)) {
    valuePart = valuePart.substr(0, valuePart.length - 1);
  }
  while (valuePart.length < minDigitCount) {
    valuePart += "0";
  }
  return valuePart;
}
function applyGroups(valueString, groupSizes, thousandsSeparator) {
  if (!groupSizes.length) {
    return valueString;
  }
  const groups = [];
  let index2 = 0;
  while (valueString) {
    const groupSize = groupSizes[index2];
    if (!groupSize) {
      break;
    }
    groups.push(valueString.slice(0, groupSize));
    valueString = valueString.slice(groupSize);
    if (index2 < groupSizes.length - 1) {
      index2++;
    }
  }
  return groups.join(thousandsSeparator);
}
function formatNumberPart(format2, valueString) {
  return format2.split(ESCAPING_CHAR).map(function(formatPart, escapeIndex) {
    const isEscape = escapeIndex % 2;
    if (!formatPart && isEscape) {
      return ESCAPING_CHAR;
    }
    return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString);
  }).join("");
}
function getFloatPointIndex(format2) {
  let isEscape = false;
  for (let index2 = 0; index2 < format2.length; index2++) {
    if ("'" === format2[index2]) {
      isEscape = !isEscape;
    }
    if ("." === format2[index2] && !isEscape) {
      return index2;
    }
  }
  return format2.length;
}
function getFormatter2(format2, config3) {
  config3 = config3 || DEFAULT_CONFIG;
  return function(value2) {
    if ("number" !== typeof value2 || isNaN(value2)) {
      return "";
    }
    const signFormatParts = getSignParts(format2);
    const isPositiveZero = 1 / value2 === 1 / 0;
    const isPositive = value2 > 0 || isPositiveZero;
    const numberFormat = signFormatParts[isPositive ? 0 : 1];
    const floatPointIndex = getFloatPointIndex(numberFormat);
    const floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];
    const minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);
    const maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);
    if (isPercentFormat(numberFormat)) {
      value2 = multiplyInExponentialForm(value2, 2);
    }
    if (!isPositive) {
      value2 = -value2;
    }
    const minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);
    const maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config3.unlimitedIntegerDigits ? void 0 : minIntegerPrecision;
    const integerLength = Math.floor(value2).toString().length;
    const floatPrecision = fitIntoRange(maxFloatPrecision, 0, 15 - integerLength);
    const groupSizes = getGroupSizes(floatFormatParts[0]).reverse();
    const valueParts = toFixed(value2, floatPrecision < 0 ? 0 : floatPrecision).split(".");
    let valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);
    const valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);
    valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config3.thousandsSeparator);
    const integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));
    const floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : "";
    const result2 = integerString + (floatString.match(/\d/) ? config3.decimalSeparator : "") + floatString;
    return result2;
  };
}
function parseValue(text, isPercent, isNegative) {
  const value2 = (isPercent ? 0.01 : 1) * parseFloat(text) || 0;
  return isNegative ? -value2 : value2;
}
function prepareValueText(valueText, formatter, isPercent, isIntegerPart) {
  let nextValueText = valueText;
  let char;
  let text;
  let nextText;
  do {
    if (nextText) {
      char = text.length === nextText.length ? "0" : "1";
      valueText = isIntegerPart ? char + valueText : valueText + char;
    }
    text = nextText || formatter(parseValue(nextValueText, isPercent));
    nextValueText = isIntegerPart ? "1" + nextValueText : nextValueText + "1";
    nextText = formatter(parseValue(nextValueText, isPercent));
  } while (text !== nextText && (isIntegerPart ? text.length === nextText.length : text.length <= nextText.length));
  if (isIntegerPart && nextText.length > text.length) {
    const hasGroups = -1 === formatter(12345).indexOf("12345");
    do {
      valueText = "1" + valueText;
    } while (hasGroups && parseValue(valueText, isPercent) < 1e5);
  }
  return valueText;
}
function getFormatByValueText(valueText, formatter, isPercent, isNegative) {
  let format2 = formatter(parseValue(valueText, isPercent, isNegative));
  const valueTextParts = valueText.split(".");
  const valueTextWithModifiedFloat = valueTextParts[0] + ".3" + valueTextParts[1].slice(1);
  const valueWithModifiedFloat = parseValue(valueTextWithModifiedFloat, isPercent, isNegative);
  const decimalSeparatorIndex = formatter(valueWithModifiedFloat).indexOf("3") - 1;
  format2 = format2.replace(/(\d)\D(\d)/g, "$1,$2");
  if (decimalSeparatorIndex >= 0) {
    format2 = format2.slice(0, decimalSeparatorIndex) + "." + format2.slice(decimalSeparatorIndex + 1);
  }
  format2 = format2.replace(/1+/, "1").replace(/1/g, "#");
  if (!isPercent) {
    format2 = format2.replace(/%/g, "'%'");
  }
  return format2;
}
function getFormat(formatter) {
  let valueText = ".";
  const isPercent = formatter(1).indexOf("100") >= 0;
  valueText = prepareValueText(valueText, formatter, isPercent, true);
  valueText = prepareValueText(valueText, formatter, isPercent, false);
  const positiveFormat = getFormatByValueText(valueText, formatter, isPercent, false);
  const negativeFormat = getFormatByValueText(valueText, formatter, isPercent, true);
  return negativeFormat === "-" + positiveFormat ? positiveFormat : positiveFormat + ";" + negativeFormat;
}

// ../../../../../../node_modules/devextreme/esm/localization/currency.js
var currency_default = {
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("currency" === format2) {
      formatConfig.precision = formatConfig.precision || 0;
      let result2 = this.format(value2, extend({}, formatConfig, {
        type: "fixedpoint"
      }));
      const currencyPart = this.getCurrencySymbol().symbol.replace(/\$/g, "$$$$");
      result2 = result2.replace(/^(\D*)(\d.*)/, "$1" + currencyPart + "$2");
      return result2;
    }
    return this.callBase.apply(this, arguments);
  },
  getCurrencySymbol: function() {
    return {
      symbol: "$"
    };
  },
  getOpenXmlCurrencyFormat: function() {
    return "$#,##0{0}_);\\($#,##0{0}\\)";
  }
};

// ../../../../../../node_modules/devextreme/esm/localization/cldr-data/parent_locales.js
var parent_locales_default = {
  "en-150": "en-001",
  "en-AG": "en-001",
  "en-AI": "en-001",
  "en-AU": "en-001",
  "en-BB": "en-001",
  "en-BM": "en-001",
  "en-BS": "en-001",
  "en-BW": "en-001",
  "en-BZ": "en-001",
  "en-CC": "en-001",
  "en-CK": "en-001",
  "en-CM": "en-001",
  "en-CX": "en-001",
  "en-CY": "en-001",
  "en-DG": "en-001",
  "en-DM": "en-001",
  "en-ER": "en-001",
  "en-FJ": "en-001",
  "en-FK": "en-001",
  "en-FM": "en-001",
  "en-GB": "en-001",
  "en-GD": "en-001",
  "en-GG": "en-001",
  "en-GH": "en-001",
  "en-GI": "en-001",
  "en-GM": "en-001",
  "en-GY": "en-001",
  "en-HK": "en-001",
  "en-IE": "en-001",
  "en-IL": "en-001",
  "en-IM": "en-001",
  "en-IN": "en-001",
  "en-IO": "en-001",
  "en-JE": "en-001",
  "en-JM": "en-001",
  "en-KE": "en-001",
  "en-KI": "en-001",
  "en-KN": "en-001",
  "en-KY": "en-001",
  "en-LC": "en-001",
  "en-LR": "en-001",
  "en-LS": "en-001",
  "en-MG": "en-001",
  "en-MO": "en-001",
  "en-MS": "en-001",
  "en-MT": "en-001",
  "en-MU": "en-001",
  "en-MV": "en-001",
  "en-MW": "en-001",
  "en-MY": "en-001",
  "en-NA": "en-001",
  "en-NF": "en-001",
  "en-NG": "en-001",
  "en-NR": "en-001",
  "en-NU": "en-001",
  "en-NZ": "en-001",
  "en-PG": "en-001",
  "en-PK": "en-001",
  "en-PN": "en-001",
  "en-PW": "en-001",
  "en-RW": "en-001",
  "en-SB": "en-001",
  "en-SC": "en-001",
  "en-SD": "en-001",
  "en-SG": "en-001",
  "en-SH": "en-001",
  "en-SL": "en-001",
  "en-SS": "en-001",
  "en-SX": "en-001",
  "en-SZ": "en-001",
  "en-TC": "en-001",
  "en-TK": "en-001",
  "en-TO": "en-001",
  "en-TT": "en-001",
  "en-TV": "en-001",
  "en-TZ": "en-001",
  "en-UG": "en-001",
  "en-VC": "en-001",
  "en-VG": "en-001",
  "en-VU": "en-001",
  "en-WS": "en-001",
  "en-ZA": "en-001",
  "en-ZM": "en-001",
  "en-ZW": "en-001",
  "en-AT": "en-150",
  "en-BE": "en-150",
  "en-CH": "en-150",
  "en-DE": "en-150",
  "en-DK": "en-150",
  "en-FI": "en-150",
  "en-NL": "en-150",
  "en-SE": "en-150",
  "en-SI": "en-150",
  "hi-Latn": "en-IN",
  "es-AR": "es-419",
  "es-BO": "es-419",
  "es-BR": "es-419",
  "es-BZ": "es-419",
  "es-CL": "es-419",
  "es-CO": "es-419",
  "es-CR": "es-419",
  "es-CU": "es-419",
  "es-DO": "es-419",
  "es-EC": "es-419",
  "es-GT": "es-419",
  "es-HN": "es-419",
  "es-MX": "es-419",
  "es-NI": "es-419",
  "es-PA": "es-419",
  "es-PE": "es-419",
  "es-PR": "es-419",
  "es-PY": "es-419",
  "es-SV": "es-419",
  "es-US": "es-419",
  "es-UY": "es-419",
  "es-VE": "es-419",
  nb: "no",
  nn: "no",
  "pt-AO": "pt-PT",
  "pt-CH": "pt-PT",
  "pt-CV": "pt-PT",
  "pt-FR": "pt-PT",
  "pt-GQ": "pt-PT",
  "pt-GW": "pt-PT",
  "pt-LU": "pt-PT",
  "pt-MO": "pt-PT",
  "pt-MZ": "pt-PT",
  "pt-ST": "pt-PT",
  "pt-TL": "pt-PT",
  "az-Arab": "und",
  "az-Cyrl": "und",
  "bal-Latn": "und",
  "blt-Latn": "und",
  "bm-Nkoo": "und",
  "bs-Cyrl": "und",
  "byn-Latn": "und",
  "cu-Glag": "und",
  "dje-Arab": "und",
  "dyo-Arab": "und",
  "en-Dsrt": "und",
  "en-Shaw": "und",
  "ff-Adlm": "und",
  "ff-Arab": "und",
  "ha-Arab": "und",
  "iu-Latn": "und",
  "kk-Arab": "und",
  "ks-Deva": "und",
  "ku-Arab": "und",
  "ky-Arab": "und",
  "ky-Latn": "und",
  "ml-Arab": "und",
  "mn-Mong": "und",
  "mni-Mtei": "und",
  "ms-Arab": "und",
  "pa-Arab": "und",
  "sat-Deva": "und",
  "sd-Deva": "und",
  "sd-Khoj": "und",
  "sd-Sind": "und",
  "shi-Latn": "und",
  "so-Arab": "und",
  "sr-Latn": "und",
  "sw-Arab": "und",
  "tg-Arab": "und",
  "ug-Cyrl": "und",
  "uz-Arab": "und",
  "uz-Cyrl": "und",
  "vai-Latn": "und",
  "wo-Arab": "und",
  "yo-Arab": "und",
  "yue-Hans": "und",
  "zh-Hant": "und",
  "zh-Hant-MO": "zh-Hant-HK"
};

// ../../../../../../node_modules/devextreme/esm/localization/parentLocale.js
var parentLocale_default = (parentLocales, locale) => {
  const parentLocale = parentLocales[locale];
  if (parentLocale) {
    return "root" !== parentLocale && parentLocale;
  }
  return locale.substr(0, locale.lastIndexOf("-"));
};

// ../../../../../../node_modules/devextreme/esm/localization/core.js
var core_default = dependency_injector_default({
  locale: (() => {
    let currentLocale = "en";
    return (locale) => {
      if (!locale) {
        return currentLocale;
      }
      currentLocale = locale;
    };
  })(),
  getValueByClosestLocale: function(getter) {
    let locale = this.locale();
    let value2 = getter(locale);
    let isRootLocale;
    while (!value2 && !isRootLocale) {
      locale = parentLocale_default(parent_locales_default, locale);
      if (locale) {
        value2 = getter(locale);
      } else {
        isRootLocale = true;
      }
    }
    if (void 0 === value2 && "en" !== locale) {
      return getter("en");
    }
    return value2;
  }
});

// ../../../../../../node_modules/devextreme/esm/localization/open_xml_currency_format.js
var open_xml_currency_format_default = (currencySymbol, accountingFormat) => {
  if (!accountingFormat) {
    return;
  }
  let encodedCurrencySymbol = currencySymbol;
  if ("string" === typeof currencySymbol) {
    encodedCurrencySymbol = "";
    for (let i = 0; i < currencySymbol.length; i++) {
      if ("$" !== currencySymbol[i]) {
        encodedCurrencySymbol += "\\";
      }
      encodedCurrencySymbol += currencySymbol[i];
    }
  }
  const encodeSymbols = {
    ".00": "{0}",
    "'": "\\'",
    "\\(": "\\(",
    "\\)": "\\)",
    " ": "\\ ",
    '"': "&quot;",
    "\\¤": encodedCurrencySymbol
  };
  const result2 = accountingFormat.split(";");
  for (let i = 0; i < result2.length; i++) {
    for (const symbol in encodeSymbols) {
      if (Object.prototype.hasOwnProperty.call(encodeSymbols, symbol)) {
        result2[i] = result2[i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol]);
      }
    }
  }
  return 2 === result2.length ? result2[0] + "_);" + result2[1] : result2[0];
};

// ../../../../../../node_modules/devextreme/esm/localization/cldr-data/accounting_formats.js
var accounting_formats_default = {
  af: "¤#,##0.00;(¤#,##0.00)",
  "af-NA": "¤#,##0.00;(¤#,##0.00)",
  agq: "#,##0.00¤",
  ak: "¤#,##0.00",
  am: "¤#,##0.00;(¤#,##0.00)",
  ar: "¤#,##0.00;(¤#,##0.00)",
  "ar-AE": "¤#,##0.00;(¤#,##0.00)",
  "ar-BH": "¤#,##0.00;(¤#,##0.00)",
  "ar-DJ": "¤#,##0.00;(¤#,##0.00)",
  "ar-DZ": "¤#,##0.00;(¤#,##0.00)",
  "ar-EG": "¤#,##0.00;(¤#,##0.00)",
  "ar-EH": "¤#,##0.00;(¤#,##0.00)",
  "ar-ER": "¤#,##0.00;(¤#,##0.00)",
  "ar-IL": "¤#,##0.00;(¤#,##0.00)",
  "ar-IQ": "¤#,##0.00;(¤#,##0.00)",
  "ar-JO": "¤#,##0.00;(¤#,##0.00)",
  "ar-KM": "¤#,##0.00;(¤#,##0.00)",
  "ar-KW": "¤#,##0.00;(¤#,##0.00)",
  "ar-LB": "¤#,##0.00;(¤#,##0.00)",
  "ar-LY": "¤#,##0.00;(¤#,##0.00)",
  "ar-MA": "¤#,##0.00;(¤#,##0.00)",
  "ar-MR": "¤#,##0.00;(¤#,##0.00)",
  "ar-OM": "¤#,##0.00;(¤#,##0.00)",
  "ar-PS": "¤#,##0.00;(¤#,##0.00)",
  "ar-QA": "¤#,##0.00;(¤#,##0.00)",
  "ar-SA": "¤#,##0.00;(¤#,##0.00)",
  "ar-SD": "¤#,##0.00;(¤#,##0.00)",
  "ar-SO": "¤#,##0.00;(¤#,##0.00)",
  "ar-SS": "¤#,##0.00;(¤#,##0.00)",
  "ar-SY": "¤#,##0.00;(¤#,##0.00)",
  "ar-TD": "¤#,##0.00;(¤#,##0.00)",
  "ar-TN": "¤#,##0.00;(¤#,##0.00)",
  "ar-YE": "¤#,##0.00;(¤#,##0.00)",
  as: "¤ #,##,##0.00",
  asa: "#,##0.00 ¤",
  ast: "#,##0.00 ¤",
  az: "#,##0.00 ¤",
  "az-Cyrl": "#,##0.00 ¤",
  "az-Latn": "#,##0.00 ¤",
  bas: "#,##0.00 ¤",
  be: "#,##0.00 ¤",
  "be-tarask": "#,##0.00 ¤",
  bem: "¤#,##0.00;(¤#,##0.00)",
  bez: "#,##0.00¤",
  bg: "0.00 ¤;(0.00 ¤)",
  bm: "¤#,##0.00;(¤#,##0.00)",
  bn: "#,##,##0.00¤;(#,##,##0.00¤)",
  "bn-IN": "#,##,##0.00¤;(#,##,##0.00¤)",
  bo: "¤ #,##0.00",
  "bo-IN": "¤ #,##0.00",
  br: "#,##0.00 ¤",
  brx: "¤ #,##,##0.00",
  bs: "#,##0.00 ¤",
  "bs-Cyrl": "#,##0.00 ¤",
  "bs-Latn": "#,##0.00 ¤",
  ca: "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-AD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-ES-valencia": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-FR": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-IT": "#,##0.00 ¤;(#,##0.00 ¤)",
  ccp: "#,##,##0.00¤;(#,##,##0.00¤)",
  "ccp-IN": "#,##,##0.00¤;(#,##,##0.00¤)",
  ce: "#,##0.00 ¤",
  ceb: "¤#,##0.00;(¤#,##0.00)",
  cgg: "¤#,##0.00",
  chr: "¤#,##0.00;(¤#,##0.00)",
  ckb: "¤ #,##0.00",
  "ckb-IR": "¤ #,##0.00",
  cs: "#,##0.00 ¤",
  cy: "¤#,##0.00;(¤#,##0.00)",
  da: "#,##0.00 ¤",
  "da-GL": "#,##0.00 ¤",
  dav: "¤#,##0.00;(¤#,##0.00)",
  de: "#,##0.00 ¤",
  "de-AT": "#,##0.00 ¤",
  "de-BE": "#,##0.00 ¤",
  "de-CH": "#,##0.00 ¤",
  "de-IT": "#,##0.00 ¤",
  "de-LI": "#,##0.00 ¤",
  "de-LU": "#,##0.00 ¤",
  dje: "#,##0.00¤",
  doi: "¤#,##0.00",
  dsb: "#,##0.00 ¤",
  dua: "#,##0.00 ¤",
  dyo: "#,##0.00 ¤",
  dz: "¤#,##,##0.00",
  ebu: "¤#,##0.00;(¤#,##0.00)",
  ee: "¤#,##0.00;(¤#,##0.00)",
  "ee-TG": "¤#,##0.00;(¤#,##0.00)",
  el: "#,##0.00 ¤",
  "el-CY": "#,##0.00 ¤",
  en: "¤#,##0.00;(¤#,##0.00)",
  "en-001": "¤#,##0.00;(¤#,##0.00)",
  "en-150": "#,##0.00 ¤",
  "en-AE": "¤#,##0.00;(¤#,##0.00)",
  "en-AG": "¤#,##0.00;(¤#,##0.00)",
  "en-AI": "¤#,##0.00;(¤#,##0.00)",
  "en-AS": "¤#,##0.00;(¤#,##0.00)",
  "en-AT": "¤ #,##0.00",
  "en-AU": "¤#,##0.00;(¤#,##0.00)",
  "en-BB": "¤#,##0.00;(¤#,##0.00)",
  "en-BE": "#,##0.00 ¤",
  "en-BI": "¤#,##0.00;(¤#,##0.00)",
  "en-BM": "¤#,##0.00;(¤#,##0.00)",
  "en-BS": "¤#,##0.00;(¤#,##0.00)",
  "en-BW": "¤#,##0.00;(¤#,##0.00)",
  "en-BZ": "¤#,##0.00;(¤#,##0.00)",
  "en-CA": "¤#,##0.00;(¤#,##0.00)",
  "en-CC": "¤#,##0.00;(¤#,##0.00)",
  "en-CH": "¤ #,##0.00;¤-#,##0.00",
  "en-CK": "¤#,##0.00;(¤#,##0.00)",
  "en-CM": "¤#,##0.00;(¤#,##0.00)",
  "en-CX": "¤#,##0.00;(¤#,##0.00)",
  "en-CY": "¤#,##0.00;(¤#,##0.00)",
  "en-DE": "#,##0.00 ¤",
  "en-DG": "¤#,##0.00;(¤#,##0.00)",
  "en-DK": "#,##0.00 ¤",
  "en-DM": "¤#,##0.00;(¤#,##0.00)",
  "en-ER": "¤#,##0.00;(¤#,##0.00)",
  "en-FI": "#,##0.00 ¤",
  "en-FJ": "¤#,##0.00;(¤#,##0.00)",
  "en-FK": "¤#,##0.00;(¤#,##0.00)",
  "en-FM": "¤#,##0.00;(¤#,##0.00)",
  "en-GB": "¤#,##0.00;(¤#,##0.00)",
  "en-GD": "¤#,##0.00;(¤#,##0.00)",
  "en-GG": "¤#,##0.00;(¤#,##0.00)",
  "en-GH": "¤#,##0.00;(¤#,##0.00)",
  "en-GI": "¤#,##0.00;(¤#,##0.00)",
  "en-GM": "¤#,##0.00;(¤#,##0.00)",
  "en-GU": "¤#,##0.00;(¤#,##0.00)",
  "en-GY": "¤#,##0.00;(¤#,##0.00)",
  "en-HK": "¤#,##0.00;(¤#,##0.00)",
  "en-IE": "¤#,##0.00;(¤#,##0.00)",
  "en-IL": "¤#,##0.00;(¤#,##0.00)",
  "en-IM": "¤#,##0.00;(¤#,##0.00)",
  "en-IN": "¤#,##0.00;(¤#,##0.00)",
  "en-IO": "¤#,##0.00;(¤#,##0.00)",
  "en-JE": "¤#,##0.00;(¤#,##0.00)",
  "en-JM": "¤#,##0.00;(¤#,##0.00)",
  "en-KE": "¤#,##0.00;(¤#,##0.00)",
  "en-KI": "¤#,##0.00;(¤#,##0.00)",
  "en-KN": "¤#,##0.00;(¤#,##0.00)",
  "en-KY": "¤#,##0.00;(¤#,##0.00)",
  "en-LC": "¤#,##0.00;(¤#,##0.00)",
  "en-LR": "¤#,##0.00;(¤#,##0.00)",
  "en-LS": "¤#,##0.00;(¤#,##0.00)",
  "en-MG": "¤#,##0.00;(¤#,##0.00)",
  "en-MH": "¤#,##0.00;(¤#,##0.00)",
  "en-MO": "¤#,##0.00;(¤#,##0.00)",
  "en-MP": "¤#,##0.00;(¤#,##0.00)",
  "en-MS": "¤#,##0.00;(¤#,##0.00)",
  "en-MT": "¤#,##0.00;(¤#,##0.00)",
  "en-MU": "¤#,##0.00;(¤#,##0.00)",
  "en-MV": "¤ #,##0.00",
  "en-MW": "¤#,##0.00;(¤#,##0.00)",
  "en-MY": "¤#,##0.00;(¤#,##0.00)",
  "en-NA": "¤#,##0.00;(¤#,##0.00)",
  "en-NF": "¤#,##0.00;(¤#,##0.00)",
  "en-NG": "¤#,##0.00;(¤#,##0.00)",
  "en-NL": "¤ #,##0.00;(¤ #,##0.00)",
  "en-NR": "¤#,##0.00;(¤#,##0.00)",
  "en-NU": "¤#,##0.00;(¤#,##0.00)",
  "en-NZ": "¤#,##0.00;(¤#,##0.00)",
  "en-PG": "¤#,##0.00;(¤#,##0.00)",
  "en-PH": "¤#,##0.00;(¤#,##0.00)",
  "en-PK": "¤#,##0.00;(¤#,##0.00)",
  "en-PN": "¤#,##0.00;(¤#,##0.00)",
  "en-PR": "¤#,##0.00;(¤#,##0.00)",
  "en-PW": "¤#,##0.00;(¤#,##0.00)",
  "en-RW": "¤#,##0.00;(¤#,##0.00)",
  "en-SB": "¤#,##0.00;(¤#,##0.00)",
  "en-SC": "¤#,##0.00;(¤#,##0.00)",
  "en-SD": "¤#,##0.00;(¤#,##0.00)",
  "en-SE": "#,##0.00 ¤",
  "en-SG": "¤#,##0.00;(¤#,##0.00)",
  "en-SH": "¤#,##0.00;(¤#,##0.00)",
  "en-SI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "en-SL": "¤#,##0.00;(¤#,##0.00)",
  "en-SS": "¤#,##0.00;(¤#,##0.00)",
  "en-SX": "¤#,##0.00;(¤#,##0.00)",
  "en-SZ": "¤#,##0.00;(¤#,##0.00)",
  "en-TC": "¤#,##0.00;(¤#,##0.00)",
  "en-TK": "¤#,##0.00;(¤#,##0.00)",
  "en-TO": "¤#,##0.00;(¤#,##0.00)",
  "en-TT": "¤#,##0.00;(¤#,##0.00)",
  "en-TV": "¤#,##0.00;(¤#,##0.00)",
  "en-TZ": "¤#,##0.00;(¤#,##0.00)",
  "en-UG": "¤#,##0.00;(¤#,##0.00)",
  "en-UM": "¤#,##0.00;(¤#,##0.00)",
  "en-VC": "¤#,##0.00;(¤#,##0.00)",
  "en-VG": "¤#,##0.00;(¤#,##0.00)",
  "en-VI": "¤#,##0.00;(¤#,##0.00)",
  "en-VU": "¤#,##0.00;(¤#,##0.00)",
  "en-WS": "¤#,##0.00;(¤#,##0.00)",
  "en-ZA": "¤#,##0.00;(¤#,##0.00)",
  "en-ZM": "¤#,##0.00;(¤#,##0.00)",
  "en-ZW": "¤#,##0.00;(¤#,##0.00)",
  eo: "¤ #,##0.00",
  es: "#,##0.00 ¤",
  "es-419": "¤#,##0.00",
  "es-AR": "¤ #,##0.00;(¤ #,##0.00)",
  "es-BO": "¤#,##0.00",
  "es-BR": "¤#,##0.00",
  "es-BZ": "¤#,##0.00",
  "es-CL": "¤#,##0.00",
  "es-CO": "¤#,##0.00",
  "es-CR": "¤#,##0.00",
  "es-CU": "¤#,##0.00",
  "es-DO": "¤#,##0.00;(¤#,##0.00)",
  "es-EA": "#,##0.00 ¤",
  "es-EC": "¤#,##0.00",
  "es-GQ": "#,##0.00 ¤",
  "es-GT": "¤#,##0.00",
  "es-HN": "¤#,##0.00",
  "es-IC": "#,##0.00 ¤",
  "es-MX": "¤#,##0.00",
  "es-NI": "¤#,##0.00",
  "es-PA": "¤#,##0.00",
  "es-PE": "¤#,##0.00",
  "es-PH": "#,##0.00 ¤",
  "es-PR": "¤#,##0.00",
  "es-PY": "¤#,##0.00",
  "es-SV": "¤#,##0.00",
  "es-US": "¤#,##0.00",
  "es-UY": "¤ #,##0.00;(¤ #,##0.00)",
  "es-VE": "¤#,##0.00",
  et: "#,##0.00 ¤;(#,##0.00 ¤)",
  eu: "#,##0.00 ¤;(#,##0.00 ¤)",
  ewo: "#,##0.00 ¤",
  fa: "‎¤ #,##0.00;‎(¤ #,##0.00)",
  "fa-AF": "¤ #,##0.00;‎(¤ #,##0.00)",
  ff: "#,##0.00 ¤",
  "ff-Adlm": "¤ #,##0.00",
  "ff-Adlm-BF": "¤ #,##0.00",
  "ff-Adlm-CM": "¤ #,##0.00",
  "ff-Adlm-GH": "¤ #,##0.00",
  "ff-Adlm-GM": "¤ #,##0.00",
  "ff-Adlm-GW": "¤ #,##0.00",
  "ff-Adlm-LR": "¤ #,##0.00",
  "ff-Adlm-MR": "¤ #,##0.00",
  "ff-Adlm-NE": "¤ #,##0.00",
  "ff-Adlm-NG": "¤ #,##0.00",
  "ff-Adlm-SL": "¤ #,##0.00",
  "ff-Adlm-SN": "¤ #,##0.00",
  "ff-Latn": "#,##0.00 ¤",
  "ff-Latn-BF": "#,##0.00 ¤",
  "ff-Latn-CM": "#,##0.00 ¤",
  "ff-Latn-GH": "#,##0.00 ¤",
  "ff-Latn-GM": "#,##0.00 ¤",
  "ff-Latn-GN": "#,##0.00 ¤",
  "ff-Latn-GW": "#,##0.00 ¤",
  "ff-Latn-LR": "#,##0.00 ¤",
  "ff-Latn-MR": "#,##0.00 ¤",
  "ff-Latn-NE": "#,##0.00 ¤",
  "ff-Latn-NG": "#,##0.00 ¤",
  "ff-Latn-SL": "#,##0.00 ¤",
  fi: "#,##0.00 ¤",
  fil: "¤#,##0.00;(¤#,##0.00)",
  fo: "#,##0.00 ¤;(#,##0.00 ¤)",
  "fo-DK": "#,##0.00 ¤;(#,##0.00 ¤)",
  fr: "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BJ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BL": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CH": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-DJ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-DZ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GP": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-HT": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-KM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-LU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-ML": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MR": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-NC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-NE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-PF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-PM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-RE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-RW": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SY": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-VU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-WF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-YT": "#,##0.00 ¤;(#,##0.00 ¤)",
  fur: "¤ #,##0.00",
  fy: "¤ #,##0.00;(¤ #,##0.00)",
  ga: "¤#,##0.00;(¤#,##0.00)",
  "ga-GB": "¤#,##0.00;(¤#,##0.00)",
  gd: "¤#,##0.00;(¤#,##0.00)",
  gl: "#,##0.00 ¤",
  gsw: "#,##0.00 ¤",
  "gsw-FR": "#,##0.00 ¤",
  "gsw-LI": "#,##0.00 ¤",
  gu: "¤#,##,##0.00;(¤#,##,##0.00)",
  guz: "¤#,##0.00;(¤#,##0.00)",
  gv: "¤#,##0.00",
  ha: "¤ #,##0.00",
  "ha-GH": "¤ #,##0.00",
  "ha-NE": "¤ #,##0.00",
  haw: "¤#,##0.00;(¤#,##0.00)",
  he: "#,##0.00 ¤",
  hi: "¤#,##,##0.00",
  "hi-Latn": "¤#,##,##0.00",
  hr: "#,##0.00 ¤",
  "hr-BA": "#,##0.00 ¤",
  hsb: "#,##0.00 ¤",
  hu: "#,##0.00 ¤",
  hy: "#,##0.00 ¤",
  ia: "¤ #,##0.00;(¤ #,##0.00)",
  id: "¤#,##0.00",
  ig: "¤#,##0.00;(¤#,##0.00)",
  ii: "¤ #,##0.00",
  is: "#,##0.00 ¤",
  it: "#,##0.00 ¤",
  "it-CH": "#,##0.00 ¤",
  "it-SM": "#,##0.00 ¤",
  "it-VA": "#,##0.00 ¤",
  ja: "¤#,##0.00;(¤#,##0.00)",
  jgo: "¤ #,##0.00",
  jmc: "¤#,##0.00",
  jv: "¤ #,##0.00",
  ka: "#,##0.00 ¤",
  kab: "#,##0.00¤",
  kam: "¤#,##0.00;(¤#,##0.00)",
  kde: "¤#,##0.00;(¤#,##0.00)",
  kea: "#,##0.00 ¤;(#,##0.00 ¤)",
  kgp: "¤ #,##0.00",
  khq: "#,##0.00¤",
  ki: "¤#,##0.00;(¤#,##0.00)",
  kk: "#,##0.00 ¤",
  kkj: "¤ #,##0.00",
  kl: "¤#,##0.00;¤-#,##0.00",
  kln: "¤#,##0.00;(¤#,##0.00)",
  km: "#,##0.00¤;(#,##0.00¤)",
  kn: "¤#,##0.00;(¤#,##0.00)",
  ko: "¤#,##0.00;(¤#,##0.00)",
  "ko-KP": "¤#,##0.00;(¤#,##0.00)",
  kok: "¤#,##0.00;(¤#,##0.00)",
  ks: "¤#,##0.00",
  "ks-Arab": "¤#,##0.00",
  "ks-Deva": "¤ #,##0.00",
  ksb: "#,##0.00¤",
  ksf: "#,##0.00 ¤",
  ksh: "#,##0.00 ¤",
  ku: "#,##0.00 ¤;(#,##0.00 ¤)",
  kw: "¤#,##0.00",
  ky: "#,##0.00 ¤",
  lag: "¤ #,##0.00",
  lb: "#,##0.00 ¤",
  lg: "#,##0.00¤",
  lkt: "¤ #,##0.00",
  ln: "#,##0.00 ¤",
  "ln-AO": "#,##0.00 ¤",
  "ln-CF": "#,##0.00 ¤",
  "ln-CG": "#,##0.00 ¤",
  lo: "¤#,##0.00;¤-#,##0.00",
  lrc: "¤ #,##0.00",
  "lrc-IQ": "¤ #,##0.00",
  lt: "#,##0.00 ¤",
  lu: "#,##0.00¤",
  luo: "#,##0.00¤",
  luy: "¤#,##0.00;¤- #,##0.00",
  lv: "#,##0.00 ¤",
  mai: "¤ #,##0.00",
  mas: "¤#,##0.00;(¤#,##0.00)",
  "mas-TZ": "¤#,##0.00;(¤#,##0.00)",
  mer: "¤#,##0.00;(¤#,##0.00)",
  mfe: "¤ #,##0.00",
  mg: "¤#,##0.00",
  mgh: "¤ #,##0.00",
  mgo: "¤ #,##0.00",
  mi: "¤ #,##0.00",
  mk: "#,##0.00 ¤",
  ml: "¤#,##0.00;(¤#,##0.00)",
  mn: "¤ #,##0.00",
  mni: "¤ #,##0.00",
  "mni-Beng": "¤ #,##0.00",
  mr: "¤#,##0.00;(¤#,##0.00)",
  ms: "¤#,##0.00;(¤#,##0.00)",
  "ms-BN": "¤#,##0.00;(¤#,##0.00)",
  "ms-ID": "¤#,##0.00",
  "ms-SG": "¤#,##0.00;(¤#,##0.00)",
  mt: "¤#,##0.00",
  mua: "¤#,##0.00;(¤#,##0.00)",
  my: "¤ #,##0.00",
  mzn: "¤ #,##0.00",
  naq: "¤#,##0.00",
  nb: "¤ #,##0.00;(¤ #,##0.00)",
  "nb-SJ": "¤ #,##0.00;(¤ #,##0.00)",
  nd: "¤#,##0.00;(¤#,##0.00)",
  nds: "¤ #,##0.00",
  "nds-NL": "¤ #,##0.00",
  ne: "¤ #,##,##0.00",
  "ne-IN": "¤ #,##,##0.00",
  nl: "¤ #,##0.00;(¤ #,##0.00)",
  "nl-AW": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-BE": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-BQ": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-CW": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-SR": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-SX": "¤ #,##0.00;(¤ #,##0.00)",
  nmg: "#,##0.00 ¤",
  nn: "#,##0.00 ¤",
  nnh: "¤ #,##0.00",
  no: "¤ #,##0.00;(¤ #,##0.00)",
  nus: "¤#,##0.00;(¤#,##0.00)",
  nyn: "¤#,##0.00",
  om: "¤#,##0.00",
  "om-KE": "¤#,##0.00",
  or: "¤#,##0.00;(¤#,##0.00)",
  os: "¤ #,##0.00",
  "os-RU": "¤ #,##0.00",
  pa: "¤ #,##0.00",
  "pa-Arab": "¤ #,##0.00",
  "pa-Guru": "¤ #,##0.00",
  pcm: "¤#,##0.00",
  pl: "#,##0.00 ¤;(#,##0.00 ¤)",
  ps: "¤#,##0.00;(¤#,##0.00)",
  "ps-PK": "¤#,##0.00;(¤#,##0.00)",
  pt: "¤ #,##0.00",
  "pt-AO": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-CH": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-CV": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-GQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-GW": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-LU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-MO": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-MZ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-PT": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-ST": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-TL": "#,##0.00 ¤;(#,##0.00 ¤)",
  qu: "¤ #,##0.00",
  "qu-BO": "¤ #,##0.00",
  "qu-EC": "¤ #,##0.00",
  rm: "#,##0.00 ¤",
  rn: "#,##0.00¤",
  ro: "#,##0.00 ¤;(#,##0.00 ¤)",
  "ro-MD": "#,##0.00 ¤;(#,##0.00 ¤)",
  rof: "¤#,##0.00",
  ru: "#,##0.00 ¤",
  "ru-BY": "#,##0.00 ¤",
  "ru-KG": "#,##0.00 ¤",
  "ru-KZ": "#,##0.00 ¤",
  "ru-MD": "#,##0.00 ¤",
  "ru-UA": "#,##0.00 ¤",
  rw: "¤ #,##0.00",
  rwk: "#,##0.00¤",
  sa: "¤ #,##0.00",
  sah: "#,##0.00 ¤",
  saq: "¤#,##0.00;(¤#,##0.00)",
  sat: "¤ #,##0.00",
  "sat-Olck": "¤ #,##0.00",
  sbp: "#,##0.00¤",
  sc: "#,##0.00 ¤",
  sd: "¤ #,##0.00",
  "sd-Arab": "¤ #,##0.00",
  "sd-Deva": "¤ #,##0.00",
  se: "#,##0.00 ¤",
  "se-FI": "#,##0.00 ¤",
  "se-SE": "#,##0.00 ¤",
  seh: "#,##0.00¤",
  ses: "#,##0.00¤",
  sg: "¤#,##0.00;¤-#,##0.00",
  shi: "#,##0.00¤",
  "shi-Latn": "#,##0.00¤",
  "shi-Tfng": "#,##0.00¤",
  si: "¤#,##0.00;(¤#,##0.00)",
  sk: "#,##0.00 ¤;(#,##0.00 ¤)",
  sl: "#,##0.00 ¤;(#,##0.00 ¤)",
  smn: "#,##0.00 ¤",
  sn: "¤#,##0.00;(¤#,##0.00)",
  so: "¤#,##0.00;(¤#,##0.00)",
  "so-DJ": "¤#,##0.00;(¤#,##0.00)",
  "so-ET": "¤#,##0.00;(¤#,##0.00)",
  "so-KE": "¤#,##0.00;(¤#,##0.00)",
  sq: "#,##0.00 ¤;(#,##0.00 ¤)",
  "sq-MK": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sq-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  sr: "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-BA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-ME": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-BA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-ME": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  su: "¤#,##0.00",
  "su-Latn": "¤#,##0.00",
  sv: "#,##0.00 ¤",
  "sv-AX": "#,##0.00 ¤",
  "sv-FI": "#,##0.00 ¤",
  sw: "¤ #,##0.00",
  "sw-CD": "¤ #,##0.00",
  "sw-KE": "¤ #,##0.00",
  "sw-UG": "¤ #,##0.00",
  ta: "¤#,##0.00;(¤#,##0.00)",
  "ta-LK": "¤#,##0.00;(¤#,##0.00)",
  "ta-MY": "¤#,##0.00;(¤#,##0.00)",
  "ta-SG": "¤#,##0.00;(¤#,##0.00)",
  te: "¤#,##0.00;(¤#,##0.00)",
  teo: "¤#,##0.00;(¤#,##0.00)",
  "teo-KE": "¤#,##0.00;(¤#,##0.00)",
  tg: "#,##0.00 ¤",
  th: "¤#,##0.00;(¤#,##0.00)",
  ti: "¤#,##0.00",
  "ti-ER": "¤#,##0.00",
  tk: "#,##0.00 ¤",
  to: "¤ #,##0.00",
  tr: "¤#,##0.00;(¤#,##0.00)",
  "tr-CY": "¤#,##0.00;(¤#,##0.00)",
  tt: "#,##0.00 ¤",
  twq: "#,##0.00¤",
  tzm: "#,##0.00 ¤",
  ug: "¤#,##0.00;(¤#,##0.00)",
  uk: "#,##0.00 ¤",
  und: "¤ #,##0.00",
  ur: "¤#,##0.00;(¤#,##0.00)",
  "ur-IN": "¤#,##0.00;(¤#,##0.00)",
  uz: "#,##0.00 ¤",
  "uz-Arab": "¤ #,##0.00",
  "uz-Cyrl": "#,##0.00 ¤",
  "uz-Latn": "#,##0.00 ¤",
  vai: "¤#,##0.00;(¤#,##0.00)",
  "vai-Latn": "¤#,##0.00;(¤#,##0.00)",
  "vai-Vaii": "¤#,##0.00;(¤#,##0.00)",
  vi: "#,##0.00 ¤",
  vun: "¤#,##0.00",
  wae: "¤ #,##0.00",
  wo: "¤ #,##0.00",
  xh: "¤#,##0.00",
  xog: "#,##0.00 ¤",
  yav: "#,##0.00 ¤;(#,##0.00 ¤)",
  yi: "¤ #,##0.00",
  yo: "¤#,##0.00;(¤#,##0.00)",
  "yo-BJ": "¤#,##0.00;(¤#,##0.00)",
  yrl: "¤ #,##0.00",
  "yrl-CO": "¤ #,##0.00",
  "yrl-VE": "¤ #,##0.00",
  yue: "¤#,##0.00;(¤#,##0.00)",
  "yue-Hans": "¤#,##0.00;(¤#,##0.00)",
  "yue-Hant": "¤#,##0.00;(¤#,##0.00)",
  zgh: "#,##0.00¤",
  zh: "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-HK": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-MO": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-SG": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant-HK": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant-MO": "¤#,##0.00;(¤#,##0.00)",
  zu: "¤#,##0.00;(¤#,##0.00)"
};

// ../../../../../../node_modules/devextreme/esm/localization/intl/number.js
var CURRENCY_STYLES = ["standard", "accounting"];
var detectCurrencySymbolRegex = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/;
var formattersCache = {};
var getFormatter3 = (format2) => {
  const key = core_default.locale() + "/" + JSON.stringify(format2);
  if (!formattersCache[key]) {
    formattersCache[key] = new Intl.NumberFormat(core_default.locale(), format2).format;
  }
  return formattersCache[key];
};
var getCurrencyFormatter = (currency) => new Intl.NumberFormat(core_default.locale(), {
  style: "currency",
  currency
});
var number_default = {
  engine: function() {
    return "intl";
  },
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("exponential" === format2) {
      return this.callBase.apply(this, arguments);
    }
    return getFormatter3(this._normalizeFormatConfig(format2, formatConfig, value2))(value2);
  },
  _normalizeFormatConfig: function(format2, formatConfig, value2) {
    let config3;
    if ("decimal" === format2) {
      const fractionDigits = String(value2).split(".")[1];
      config3 = {
        minimumIntegerDigits: formatConfig.precision || void 0,
        useGrouping: false,
        maximumFractionDigits: fractionDigits && fractionDigits.length,
        round: value2 < 0 ? "ceil" : "floor"
      };
    } else {
      config3 = this._getPrecisionConfig(formatConfig.precision);
    }
    if ("percent" === format2) {
      config3.style = "percent";
    } else if ("currency" === format2) {
      const useAccountingStyle = formatConfig.useCurrencyAccountingStyle ?? config_default().defaultUseCurrencyAccountingStyle;
      config3.style = "currency";
      config3.currency = formatConfig.currency || config_default().defaultCurrency;
      config3.currencySign = CURRENCY_STYLES[+useAccountingStyle];
    }
    return config3;
  },
  _getPrecisionConfig: function(precision) {
    let config3;
    if (null === precision) {
      config3 = {
        minimumFractionDigits: 0,
        maximumFractionDigits: 20
      };
    } else {
      config3 = {
        minimumFractionDigits: precision || 0,
        maximumFractionDigits: precision || 0
      };
    }
    return config3;
  },
  format: function(value2, format2) {
    if ("number" !== typeof value2) {
      return value2;
    }
    format2 = this._normalizeFormat(format2);
    if ("default" === format2.currency) {
      format2.currency = config_default().defaultCurrency;
    }
    if (!format2 || "function" !== typeof format2 && !format2.type && !format2.formatter) {
      return getFormatter3(format2)(value2);
    }
    return this.callBase.apply(this, arguments);
  },
  _getCurrencySymbolInfo: function(currency) {
    const formatter = getCurrencyFormatter(currency);
    return this._extractCurrencySymbolInfo(formatter.format(0));
  },
  _extractCurrencySymbolInfo: function(currencyValueString) {
    const match2 = detectCurrencySymbolRegex.exec(currencyValueString) || [];
    const position3 = match2[1] ? "before" : "after";
    const symbol = match2[1] || match2[4] || "";
    const delimiter = match2[2] || match2[3] || "";
    return {
      position: position3,
      symbol,
      delimiter
    };
  },
  getCurrencySymbol: function(currency) {
    if (!currency) {
      currency = config_default().defaultCurrency;
    }
    const symbolInfo = this._getCurrencySymbolInfo(currency);
    return {
      symbol: symbolInfo.symbol
    };
  },
  getOpenXmlCurrencyFormat: function(currency) {
    const targetCurrency = currency || config_default().defaultCurrency;
    const currencySymbol = this._getCurrencySymbolInfo(targetCurrency).symbol;
    const closestAccountingFormat = core_default.getValueByClosestLocale((locale) => accounting_formats_default[locale]);
    return open_xml_currency_format_default(currencySymbol, closestAccountingFormat);
  }
};

// ../../../../../../node_modules/devextreme/esm/localization/number.js
var hasIntl = "undefined" !== typeof Intl;
var NUMERIC_FORMATS = ["currency", "fixedpoint", "exponential", "percent", "decimal"];
var LargeNumberFormatPostfixes = {
  1: "K",
  2: "M",
  3: "B",
  4: "T"
};
var LargeNumberFormatPowers = {
  largenumber: "auto",
  thousands: 1,
  millions: 2,
  billions: 3,
  trillions: 4
};
var numberLocalization = dependency_injector_default({
  engine: function() {
    return "base";
  },
  numericFormats: NUMERIC_FORMATS,
  defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
  _parseNumberFormatString: function(formatType) {
    const formatObject = {};
    if (!formatType || "string" !== typeof formatType) {
      return;
    }
    const formatList = formatType.toLowerCase().split(" ");
    each(formatList, (index2, value2) => {
      if (NUMERIC_FORMATS.includes(value2)) {
        formatObject.formatType = value2;
      } else if (value2 in LargeNumberFormatPowers) {
        formatObject.power = LargeNumberFormatPowers[value2];
      }
    });
    if (formatObject.power && !formatObject.formatType) {
      formatObject.formatType = "fixedpoint";
    }
    if (formatObject.formatType) {
      return formatObject;
    }
  },
  _calculateNumberPower: function(value2, base2, minPower, maxPower) {
    let number = Math.abs(value2);
    let power = 0;
    if (number > 1) {
      while (number && number >= base2 && (void 0 === maxPower || power < maxPower)) {
        power++;
        number /= base2;
      }
    } else if (number > 0 && number < 1) {
      while (number < 1 && (void 0 === minPower || power > minPower)) {
        power--;
        number *= base2;
      }
    }
    return power;
  },
  _getNumberByPower: function(number, power, base2) {
    let result2 = number;
    while (power > 0) {
      result2 /= base2;
      power--;
    }
    while (power < 0) {
      result2 *= base2;
      power++;
    }
    return result2;
  },
  _formatNumber: function(value2, formatObject, formatConfig) {
    if ("auto" === formatObject.power) {
      formatObject.power = this._calculateNumberPower(value2, 1e3, 0, 4);
    }
    if (formatObject.power) {
      value2 = this._getNumberByPower(value2, formatObject.power, 1e3);
    }
    const powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || "";
    let result2 = this._formatNumberCore(value2, formatObject.formatType, formatConfig);
    result2 = result2.replace(/(\d|.$)(\D*)$/, "$1" + powerPostfix + "$2");
    return result2;
  },
  _formatNumberExponential: function(value2, formatConfig) {
    let power = this._calculateNumberPower(value2, 10);
    let number = this._getNumberByPower(value2, power, 10);
    if (void 0 === formatConfig.precision) {
      formatConfig.precision = 1;
    }
    if (number.toFixed(formatConfig.precision || 0) >= 10) {
      power++;
      number /= 10;
    }
    const powString = (power >= 0 ? "+" : "") + power.toString();
    return this._formatNumberCore(number, "fixedpoint", formatConfig) + "E" + powString;
  },
  _addZeroes: function(value2, precision) {
    const multiplier = Math.pow(10, precision);
    const sign2 = value2 < 0 ? "-" : "";
    value2 = (Math.abs(value2) * multiplier >>> 0) / multiplier;
    let result2 = value2.toString();
    while (result2.length < precision) {
      result2 = "0" + result2;
    }
    return sign2 + result2;
  },
  _addGroupSeparators: function(value2) {
    const parts = value2.toString().split(".");
    return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, config_default().thousandsSeparator) + (parts[1] ? config_default().decimalSeparator + parts[1] : "");
  },
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("exponential" === format2) {
      return this._formatNumberExponential(value2, formatConfig);
    }
    if ("decimal" !== format2 && null !== formatConfig.precision) {
      formatConfig.precision = formatConfig.precision || 0;
    }
    if ("percent" === format2) {
      value2 *= 100;
    }
    if (void 0 !== formatConfig.precision) {
      if ("decimal" === format2) {
        value2 = this._addZeroes(value2, formatConfig.precision);
      } else {
        value2 = null === formatConfig.precision ? value2.toPrecision() : toFixed(value2, formatConfig.precision);
      }
    }
    if ("decimal" !== format2) {
      value2 = this._addGroupSeparators(value2);
    } else {
      value2 = value2.toString().replace(".", config_default().decimalSeparator);
    }
    if ("percent" === format2) {
      value2 += "%";
    }
    return value2;
  },
  _normalizeFormat: function(format2) {
    if (!format2) {
      return {};
    }
    if ("function" === typeof format2) {
      return format2;
    }
    if (!isPlainObject(format2)) {
      format2 = {
        type: format2
      };
    }
    return format2;
  },
  _getSeparators: function() {
    return {
      decimalSeparator: this.getDecimalSeparator(),
      thousandsSeparator: this.getThousandsSeparator()
    };
  },
  getThousandsSeparator: function() {
    return this.format(1e4, "fixedPoint")[2];
  },
  getDecimalSeparator: function() {
    return this.format(1.2, {
      type: "fixedPoint",
      precision: 1
    })[1];
  },
  convertDigits: function(value2, toStandard) {
    const digits = this.format(90, "decimal");
    if ("string" !== typeof value2 || "0" === digits[1]) {
      return value2;
    }
    const fromFirstDigit = toStandard ? digits[1] : "0";
    const toFirstDigit = toStandard ? "0" : digits[1];
    const fromLastDigit = toStandard ? digits[0] : "9";
    const regExp = new RegExp("[" + fromFirstDigit + "-" + fromLastDigit + "]", "g");
    return value2.replace(regExp, (char) => String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0))));
  },
  getNegativeEtalonRegExp: function(format2) {
    const separators = this._getSeparators();
    const digitalRegExp = new RegExp("[0-9" + escapeRegExp(separators.decimalSeparator + separators.thousandsSeparator) + "]+", "g");
    let negativeEtalon = this.format(-1, format2).replace(digitalRegExp, "1");
    ["\\", "(", ")", "[", "]", "*", "+", "$", "^", "?", "|", "{", "}"].forEach((char) => {
      negativeEtalon = negativeEtalon.replace(new RegExp(`\\${char}`, "g"), `\\${char}`);
    });
    negativeEtalon = negativeEtalon.replace(/ /g, "\\s");
    negativeEtalon = negativeEtalon.replace(/1/g, ".*");
    return new RegExp(negativeEtalon, "g");
  },
  getSign: function(text, format2) {
    if (!format2) {
      if ("-" === text.replace(/[^0-9-]/g, "").charAt(0)) {
        return -1;
      }
      return 1;
    }
    const negativeEtalon = this.getNegativeEtalonRegExp(format2);
    return text.match(negativeEtalon) ? -1 : 1;
  },
  format: function(value2, format2) {
    if ("number" !== typeof value2) {
      return value2;
    }
    if ("number" === typeof format2) {
      return value2;
    }
    format2 = format2 && format2.formatter || format2;
    if ("function" === typeof format2) {
      return format2(value2);
    }
    format2 = this._normalizeFormat(format2);
    if (!format2.type) {
      format2.type = "decimal";
    }
    const numberConfig = this._parseNumberFormatString(format2.type);
    if (!numberConfig) {
      const formatterConfig = this._getSeparators();
      formatterConfig.unlimitedIntegerDigits = format2.unlimitedIntegerDigits;
      return this.convertDigits(getFormatter2(format2.type, formatterConfig)(value2));
    }
    return this._formatNumber(value2, numberConfig, format2);
  },
  parse: function(text, format2) {
    if (!text) {
      return;
    }
    if (format2 && format2.parser) {
      return format2.parser(text);
    }
    text = this.convertDigits(text, true);
    if (format2 && "string" !== typeof format2) {
      errors_default.log("W0011");
    }
    const decimalSeparator = this.getDecimalSeparator();
    const regExp = new RegExp("[^0-9" + escapeRegExp(decimalSeparator) + "]", "g");
    const cleanedText = text.replace(regExp, "").replace(decimalSeparator, ".").replace(/\.$/g, "");
    if ("." === cleanedText || "" === cleanedText) {
      return null;
    }
    if (this._calcSignificantDigits(cleanedText) > 15) {
      return NaN;
    }
    let parsed = +cleanedText * this.getSign(text, format2);
    format2 = this._normalizeFormat(format2);
    const formatConfig = this._parseNumberFormatString(format2.type);
    let power = null === formatConfig || void 0 === formatConfig ? void 0 : formatConfig.power;
    if (power) {
      if ("auto" === power) {
        const match2 = text.match(/\d(K|M|B|T)/);
        if (match2) {
          power = Object.keys(LargeNumberFormatPostfixes).find((power2) => LargeNumberFormatPostfixes[power2] === match2[1]);
        }
      }
      parsed *= Math.pow(10, 3 * power);
    }
    if ("percent" === (null === formatConfig || void 0 === formatConfig ? void 0 : formatConfig.formatType)) {
      parsed /= 100;
    }
    return parsed;
  },
  _calcSignificantDigits: function(text) {
    const [integer, fractional] = text.split(".");
    const calcDigitsAfterLeadingZeros = (digits) => {
      let index2 = -1;
      for (let i = 0; i < digits.length; i++) {
        if ("0" !== digits[i]) {
          index2 = i;
          break;
        }
      }
      return index2 > -1 ? digits.length - index2 : 0;
    };
    let result2 = 0;
    if (integer) {
      result2 += calcDigitsAfterLeadingZeros(integer.split(""));
    }
    if (fractional) {
      result2 += calcDigitsAfterLeadingZeros(fractional.split("").reverse());
    }
    return result2;
  }
});
numberLocalization.inject(currency_default);
if (hasIntl) {
  numberLocalization.inject(number_default);
}
var number_default2 = numberLocalization;

// ../../../../../../node_modules/devextreme/esm/localization/ldml/date.format.js
var FORMAT_SEPARATORS = " .,:;/\\<>()-[]،";
var checkDigit = function(char) {
  const code = char && number_default2.convertDigits(char, false).charCodeAt(0);
  const zeroCode = number_default2.convertDigits("0", false).charCodeAt(0);
  return zeroCode <= code && code < zeroCode + 10;
};
var checkPatternContinue = function(text, patterns, index2, isDigit) {
  const char = text[index2];
  const nextChar = text[index2 + 1];
  if (!isDigit) {
    if ("." === char || " " === char && ". m." === text.slice(index2 - 1, index2 + 3)) {
      return true;
    }
    if ("-" === char && !checkDigit(nextChar)) {
      return true;
    }
  }
  const isDigitChanged = isDigit && patterns.some((pattern) => text[index2] !== pattern[index2]);
  return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char) && (!isDigit || isDigitChanged);
};
var getPatternStartIndex = function(defaultPattern, index2) {
  if (!checkDigit(defaultPattern[index2])) {
    while (index2 > 0 && !checkDigit(defaultPattern[index2 - 1]) && ("." === defaultPattern[index2 - 1] || FORMAT_SEPARATORS.indexOf(defaultPattern[index2 - 1]) < 0)) {
      index2--;
    }
  }
  return index2;
};
var getDifference = function(defaultPattern, patterns, processedIndexes, isDigit) {
  let i = 0;
  const result2 = [];
  const patternsFilter = function(pattern) {
    return defaultPattern[i] !== pattern[i] && (void 0 === isDigit || checkDigit(defaultPattern[i]) === isDigit);
  };
  if (!Array.isArray(patterns)) {
    patterns = [patterns];
  }
  for (i = 0; i < defaultPattern.length; i++) {
    if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {
      i = getPatternStartIndex(defaultPattern, i);
      do {
        isDigit = checkDigit(defaultPattern[i]);
        if (!result2.length && !isDigit && checkDigit(patterns[0][i])) {
          break;
        }
        result2.push(i);
        processedIndexes.unshift(i);
        i++;
      } while (defaultPattern[i] && checkPatternContinue(defaultPattern, patterns, i, isDigit));
      break;
    }
  }
  if (1 === result2.length && ("0" === defaultPattern[processedIndexes[0] - 1] || "٠" === defaultPattern[processedIndexes[0] - 1])) {
    processedIndexes.unshift(processedIndexes[0] - 1);
  }
  return result2;
};
var replaceCharsCore = function(pattern, indexes, char, patternPositions) {
  const baseCharIndex = indexes[0];
  const patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;
  indexes.forEach(function(_, index2) {
    pattern = pattern.substr(0, patternIndex + index2) + (char.length > 1 ? char[index2] : char) + pattern.substr(patternIndex + index2 + 1);
  });
  if (1 === indexes.length) {
    pattern = pattern.replace("0" + char, char + char);
    pattern = pattern.replace("٠" + char, char + char);
  }
  return pattern;
};
var replaceChars = function(pattern, indexes, char, patternPositions) {
  let i;
  let index2;
  let patternIndex;
  if (!checkDigit(pattern[indexes[0]] || "0")) {
    const letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);
    while (indexes.length > letterCount) {
      index2 = indexes.pop();
      patternIndex = patternPositions[index2];
      patternPositions[index2] = -1;
      for (i = index2 + 1; i < patternPositions.length; i++) {
        patternPositions[i]--;
      }
      pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1);
    }
    index2 = indexes[indexes.length - 1] + 1, patternIndex = index2 < patternPositions.length ? patternPositions[index2] : index2;
    while (indexes.length < letterCount) {
      indexes.push(indexes[indexes.length - 1] + 1);
      for (i = index2; i < patternPositions.length; i++) {
        patternPositions[i]++;
      }
      pattern = pattern.substr(0, patternIndex) + " " + pattern.substr(patternIndex);
    }
  }
  pattern = replaceCharsCore(pattern, indexes, char, patternPositions);
  return pattern;
};
var formatValue = function(value2, formatter) {
  if (Array.isArray(value2)) {
    return value2.map(function(value3) {
      return (formatter(value3) || "").toString();
    });
  }
  return (formatter(value2) || "").toString();
};
var ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;
var escapeChars = function(pattern, defaultPattern, processedIndexes, patternPositions) {
  const escapeIndexes = defaultPattern.split("").map(function(char, index2) {
    if (processedIndexes.indexOf(index2) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || "'" === char)) {
      return patternPositions[index2];
    }
    return -1;
  });
  pattern = pattern.split("").map(function(char, index2) {
    let result2 = char;
    const isCurrentCharEscaped = escapeIndexes.indexOf(index2) >= 0;
    const isPrevCharEscaped = index2 > 0 && escapeIndexes.indexOf(index2 - 1) >= 0;
    const isNextCharEscaped = escapeIndexes.indexOf(index2 + 1) >= 0;
    if (isCurrentCharEscaped) {
      if (!isPrevCharEscaped) {
        result2 = "'" + result2;
      }
      if (!isNextCharEscaped) {
        result2 += "'";
      }
    }
    return result2;
  }).join("");
  return pattern;
};
var getFormat2 = function(formatter) {
  const processedIndexes = [];
  const defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter);
  const patternPositions = defaultPattern.split("").map(function(_, index2) {
    return index2;
  });
  let result2 = defaultPattern;
  const replacedPatterns = {};
  const datePatterns = [{
    date: new Date(2009, 8, 8, 6, 5, 4, 111),
    pattern: "S"
  }, {
    date: new Date(2009, 8, 8, 6, 5, 2),
    pattern: "s"
  }, {
    date: new Date(2009, 8, 8, 6, 2, 4),
    pattern: "m"
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: "H",
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 2, 5, 4),
    pattern: "h",
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: "a",
    isDigit: false
  }, {
    date: new Date(2009, 8, 1, 6, 5, 4),
    pattern: "d"
  }, {
    date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],
    pattern: "E"
  }, {
    date: new Date(2009, 9, 6, 6, 5, 4),
    pattern: "M"
  }, {
    date: new Date(1998, 8, 8, 6, 5, 4),
    pattern: "y"
  }];
  if (!result2) {
    return;
  }
  datePatterns.forEach(function(test) {
    const diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit);
    const pattern = "M" === test.pattern && !replacedPatterns.d ? "L" : test.pattern;
    result2 = replaceChars(result2, diff, pattern, patternPositions);
    replacedPatterns[pattern] = diff.length;
  });
  result2 = escapeChars(result2, defaultPattern, processedIndexes, patternPositions);
  if (processedIndexes.length) {
    return result2;
  }
};

// ../../../../../../node_modules/devextreme/esm/localization/ldml/date.parser.js
var FORMAT_TYPES2 = {
  3: "abbreviated",
  4: "wide",
  5: "narrow"
};
var monthRegExpGenerator = function(count, dateParts) {
  if (count > 2) {
    return Object.keys(FORMAT_TYPES2).map(function(count2) {
      return ["format", "standalone"].map(function(type2) {
        return dateParts.getMonthNames(FORMAT_TYPES2[count2], type2).join("|");
      }).join("|");
    }).join("|");
  }
  return 2 === count ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
};
var PATTERN_REGEXPS = {
  ":": function(count, dateParts) {
    const countSuffix = count > 1 ? `{${count}}` : "";
    let timeSeparator = escapeRegExp(dateParts.getTimeSeparator());
    ":" !== timeSeparator && (timeSeparator = `${timeSeparator}|:`);
    return `${timeSeparator}${countSuffix}`;
  },
  y: function(count) {
    return 2 === count ? `[0-9]{${count}}` : "[0-9]+?";
  },
  M: monthRegExpGenerator,
  L: monthRegExpGenerator,
  Q: function(count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES2[count], "format").join("|");
    }
    return "0?[1-4]";
  },
  E: function(count, dateParts) {
    return "\\D*";
  },
  a: function(count, dateParts) {
    return dateParts.getPeriodNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format").join("|");
  },
  d: function(count) {
    return 2 === count ? "3[01]|[12][0-9]|0?[1-9]" : "0??[1-9]|[12][0-9]|3[01]";
  },
  H: function(count) {
    return 2 === count ? "2[0-3]|1[0-9]|0?[0-9]" : "0??[0-9]|1[0-9]|2[0-3]";
  },
  h: function(count) {
    return 2 === count ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
  },
  m: function(count) {
    return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  s: function(count) {
    return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  S: function(count) {
    return `[0-9]{1,${count}}`;
  },
  w: function(count) {
    return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  x: function(count) {
    return 3 === count ? "[+-](?:2[0-3]|[01][0-9]):(?:[0-5][0-9])|Z" : "[+-](?:2[0-3]|[01][0-9])(?:[0-5][0-9])|Z";
  }
};
var parseNumber = Number;
var caseInsensitiveIndexOf = function(array, value2) {
  return array.map((item) => item.toLowerCase()).indexOf(value2.toLowerCase());
};
var monthPatternParser = function(text, count, dateParts) {
  if (count > 2) {
    return ["format", "standalone"].map(function(type2) {
      return Object.keys(FORMAT_TYPES2).map(function(count2) {
        const monthNames = dateParts.getMonthNames(FORMAT_TYPES2[count2], type2);
        return caseInsensitiveIndexOf(monthNames, text);
      });
    }).reduce(function(a, b) {
      return a.concat(b);
    }).filter(function(index2) {
      return index2 >= 0;
    })[0];
  }
  return parseNumber(text) - 1;
};
var PATTERN_PARSERS = {
  y: function(text, count) {
    const year = parseNumber(text);
    if (2 === count) {
      return year < 30 ? 2e3 + year : 1900 + year;
    }
    return year;
  },
  M: monthPatternParser,
  L: monthPatternParser,
  Q: function(text, count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES2[count], "format").indexOf(text);
    }
    return parseNumber(text) - 1;
  },
  E: function(text, count, dateParts) {
    const dayNames = dateParts.getDayNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format");
    return caseInsensitiveIndexOf(dayNames, text);
  },
  a: function(text, count, dateParts) {
    const periodNames = dateParts.getPeriodNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format");
    return caseInsensitiveIndexOf(periodNames, text);
  },
  d: parseNumber,
  H: parseNumber,
  h: parseNumber,
  m: parseNumber,
  s: parseNumber,
  S: function(text, count) {
    count = Math.max(count, 3);
    text = text.slice(0, 3);
    while (count < 3) {
      text += "0";
      count++;
    }
    return parseNumber(text);
  }
};
var ORDERED_PATTERNS = ["y", "M", "d", "h", "m", "s", "S"];
var PATTERN_SETTERS = {
  y: "setFullYear",
  M: "setMonth",
  L: "setMonth",
  a: function(date, value2, datePartValues) {
    let hours = date.getHours();
    const hourPartValue = datePartValues.h;
    if (void 0 !== hourPartValue && hourPartValue !== hours) {
      hours--;
    }
    if (!value2 && 12 === hours) {
      hours = 0;
    } else if (value2 && 12 !== hours) {
      hours += 12;
    }
    date.setHours(hours);
  },
  d: "setDate",
  H: "setHours",
  h: "setHours",
  m: "setMinutes",
  s: "setSeconds",
  S: "setMilliseconds"
};
var getSameCharCount = function(text, index2) {
  const char = text[index2];
  if (!char) {
    return 0;
  }
  let count = 0;
  do {
    index2++;
    count++;
  } while (text[index2] === char);
  return count;
};
var createPattern = function(char, count) {
  let result2 = "";
  for (let i = 0; i < count; i++) {
    result2 += char;
  }
  return result2;
};
var getRegExpInfo = function(format2, dateParts) {
  let regexpText = "";
  let stubText = "";
  let isEscaping;
  const patterns = [];
  const addPreviousStub = function() {
    if (stubText) {
      patterns.push(`'${stubText}'`);
      regexpText += `${escapeRegExp(stubText)})`;
      stubText = "";
    }
  };
  for (let i = 0; i < format2.length; i++) {
    const char = format2[i];
    const isEscapeChar = "'" === char;
    const regexpPart = PATTERN_REGEXPS[char];
    if (isEscapeChar) {
      isEscaping = !isEscaping;
      if ("'" !== format2[i - 1]) {
        continue;
      }
    }
    if (regexpPart && !isEscaping) {
      const count = getSameCharCount(format2, i);
      const pattern = createPattern(char, count);
      addPreviousStub();
      patterns.push(pattern);
      regexpText += `(${regexpPart(count, dateParts)})`;
      i += count - 1;
    } else {
      if (!stubText) {
        regexpText += "(";
      }
      stubText += char;
    }
  }
  addPreviousStub();
  if (!isPossibleForParsingFormat(patterns)) {
    logger.warn(`The following format may be parsed incorrectly: ${format2}.`);
  }
  return {
    patterns,
    regexp: new RegExp(`^${regexpText}$`, "i")
  };
};
var digitFieldSymbols = ["d", "H", "h", "m", "s", "w", "M", "L", "Q"];
var isPossibleForParsingFormat = function(patterns) {
  const isDigitPattern = (pattern) => {
    if (!pattern) {
      return false;
    }
    const char = pattern[0];
    return ["y", "S"].includes(char) || digitFieldSymbols.includes(char) && pattern.length < 3;
  };
  let possibleForParsing = true;
  let ambiguousDigitPatternsCount = 0;
  return patterns.every((pattern, index2, patterns2) => {
    if (isDigitPattern(pattern)) {
      if (((pattern2) => "S" !== pattern2[0] && 2 !== pattern2.length)(pattern)) {
        possibleForParsing = ++ambiguousDigitPatternsCount < 2;
      }
      if (!isDigitPattern(patterns2[index2 + 1])) {
        ambiguousDigitPatternsCount = 0;
      }
    }
    return possibleForParsing;
  });
};
var getPatternSetters = function() {
  return PATTERN_SETTERS;
};
var setPatternPart = function(date, pattern, text, dateParts, datePartValues) {
  const patternChar = pattern[0];
  const partSetter = PATTERN_SETTERS[patternChar];
  const partParser = PATTERN_PARSERS[patternChar];
  if (partSetter && partParser) {
    const value2 = partParser(text, pattern.length, dateParts);
    datePartValues[pattern] = value2;
    if (date[partSetter]) {
      date[partSetter](value2);
    } else {
      partSetter(date, value2, datePartValues);
    }
  }
};
var setPatternPartFromNow = function(date, pattern, now) {
  const setterName = PATTERN_SETTERS[pattern];
  const getterName = "g" + setterName.substr(1);
  const value2 = now[getterName]();
  date[setterName](value2);
};
var getShortPatterns = function(fullPatterns) {
  return fullPatterns.map(function(pattern) {
    if ("'" === pattern[0]) {
      return "";
    } else {
      return "H" === pattern[0] ? "h" : pattern[0];
    }
  });
};
var getMaxOrderedPatternIndex = function(patterns) {
  const indexes = patterns.map(function(pattern) {
    return ORDERED_PATTERNS.indexOf(pattern);
  });
  return Math.max.apply(Math, indexes);
};
var getOrderedFormatPatterns = function(formatPatterns) {
  const otherPatterns = formatPatterns.filter(function(pattern) {
    return ORDERED_PATTERNS.indexOf(pattern) < 0;
  });
  return ORDERED_PATTERNS.concat(otherPatterns);
};
var getParser = function(format2, dateParts) {
  const regExpInfo = getRegExpInfo(format2, dateParts);
  return function(text) {
    const regExpResult = regExpInfo.regexp.exec(text);
    if (regExpResult) {
      const now = /* @__PURE__ */ new Date();
      const date = new Date(now.getFullYear(), 0, 1);
      const formatPatterns = getShortPatterns(regExpInfo.patterns);
      const maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);
      const orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);
      const datePartValues = {};
      orderedFormatPatterns.forEach(function(pattern, index2) {
        if (!pattern || index2 < ORDERED_PATTERNS.length && index2 > maxPatternIndex) {
          return;
        }
        const patternIndex = formatPatterns.indexOf(pattern);
        if (patternIndex >= 0) {
          const regExpPattern = regExpInfo.patterns[patternIndex];
          const regExpText = regExpResult[patternIndex + 1];
          setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues);
        } else {
          setPatternPartFromNow(date, pattern, now);
        }
      });
      return date;
    }
    return null;
  };
};

// ../../../../../../node_modules/devextreme/esm/localization/cldr-data/first_day_of_week_data.js
var first_day_of_week_data_default = {
  "af-NA": 1,
  agq: 1,
  ak: 1,
  ar: 6,
  "ar-EH": 1,
  "ar-ER": 1,
  "ar-KM": 1,
  "ar-LB": 1,
  "ar-MA": 1,
  "ar-MR": 1,
  "ar-PS": 1,
  "ar-SO": 1,
  "ar-SS": 1,
  "ar-TD": 1,
  "ar-TN": 1,
  asa: 1,
  ast: 1,
  az: 1,
  "az-Cyrl": 1,
  bas: 1,
  be: 1,
  bem: 1,
  bez: 1,
  bg: 1,
  bm: 1,
  br: 1,
  bs: 1,
  "bs-Cyrl": 1,
  ca: 1,
  ce: 1,
  cgg: 1,
  ckb: 6,
  cs: 1,
  cy: 1,
  da: 1,
  de: 1,
  dje: 1,
  dsb: 1,
  dua: 1,
  dyo: 1,
  ee: 1,
  el: 1,
  "en-001": 1,
  "en-AE": 6,
  "en-BI": 1,
  "en-MP": 1,
  "en-MV": 5,
  "en-SD": 6,
  eo: 1,
  es: 1,
  et: 1,
  eu: 1,
  ewo: 1,
  fa: 6,
  ff: 1,
  "ff-Adlm": 1,
  fi: 1,
  fo: 1,
  fr: 1,
  "fr-DJ": 6,
  "fr-DZ": 6,
  "fr-SY": 6,
  fur: 1,
  fy: 1,
  ga: 1,
  gd: 1,
  gl: 1,
  gsw: 1,
  gv: 1,
  ha: 1,
  hr: 1,
  hsb: 1,
  hu: 1,
  hy: 1,
  ia: 1,
  ig: 1,
  is: 1,
  it: 1,
  jgo: 1,
  jmc: 1,
  ka: 1,
  kab: 6,
  kde: 1,
  kea: 1,
  khq: 1,
  kk: 1,
  kkj: 1,
  kl: 1,
  "ko-KP": 1,
  ksb: 1,
  ksf: 1,
  ksh: 1,
  ku: 1,
  kw: 1,
  ky: 1,
  lag: 1,
  lb: 1,
  lg: 1,
  ln: 1,
  lrc: 6,
  lt: 1,
  lu: 1,
  lv: 1,
  "mas-TZ": 1,
  mfe: 1,
  mg: 1,
  mgo: 1,
  mi: 1,
  mk: 1,
  mn: 1,
  ms: 1,
  mua: 1,
  mzn: 6,
  naq: 1,
  nds: 1,
  nl: 1,
  nmg: 1,
  nnh: 1,
  no: 1,
  nus: 1,
  nyn: 1,
  os: 1,
  pcm: 1,
  pl: 1,
  ps: 6,
  "pt-AO": 1,
  "pt-CH": 1,
  "pt-CV": 1,
  "pt-GQ": 1,
  "pt-GW": 1,
  "pt-LU": 1,
  "pt-ST": 1,
  "pt-TL": 1,
  "qu-BO": 1,
  "qu-EC": 1,
  rm: 1,
  rn: 1,
  ro: 1,
  rof: 1,
  ru: 1,
  rw: 1,
  rwk: 1,
  sah: 1,
  sbp: 1,
  sc: 1,
  se: 1,
  ses: 1,
  sg: 1,
  shi: 1,
  "shi-Latn": 1,
  si: 1,
  sk: 1,
  sl: 1,
  smn: 1,
  so: 1,
  "so-DJ": 6,
  sq: 1,
  sr: 1,
  "sr-Latn": 1,
  sv: 1,
  sw: 1,
  "ta-LK": 1,
  "ta-MY": 1,
  teo: 1,
  tg: 1,
  "ti-ER": 1,
  tk: 1,
  to: 1,
  tr: 1,
  tt: 1,
  twq: 1,
  tzm: 1,
  uk: 1,
  uz: 1,
  "uz-Arab": 6,
  "uz-Cyrl": 1,
  vai: 1,
  "vai-Latn": 1,
  vi: 1,
  vun: 1,
  wae: 1,
  wo: 1,
  xog: 1,
  yav: 1,
  yi: 1,
  yo: 1,
  zgh: 1
};

// ../../../../../../node_modules/devextreme/esm/localization/intl/date.js
var SYMBOLS_TO_REMOVE_REGEX = /[\u200E\u200F]/g;
var NARROW_NO_BREAK_SPACE_REGEX = /[\u202F]/g;
var getIntlFormatter = (format2) => (date) => {
  if (!format2.timeZoneName) {
    const year = date.getFullYear();
    const recognizableAsTwentyCentury = String(year).length < 3;
    const safeYearShift = 400;
    const temporaryYearValue = recognizableAsTwentyCentury ? year + safeYearShift : year;
    const utcDate = new Date(Date.UTC(temporaryYearValue, date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
    if (recognizableAsTwentyCentury) {
      utcDate.setFullYear(year);
    }
    const utcFormat = extend({
      timeZone: "UTC"
    }, format2);
    return formatDateTime(utcDate, utcFormat);
  }
  return formatDateTime(date, format2);
};
var formattersCache2 = {};
var getFormatter4 = (format2) => {
  const key = core_default.locale() + "/" + JSON.stringify(format2);
  if (!formattersCache2[key]) {
    formattersCache2[key] = new Intl.DateTimeFormat(core_default.locale(), format2).format;
  }
  return formattersCache2[key];
};
function formatDateTime(date, format2) {
  return getFormatter4(format2)(date).replace(SYMBOLS_TO_REMOVE_REGEX, "").replace(NARROW_NO_BREAK_SPACE_REGEX, " ");
}
var formatNumber = (number) => new Intl.NumberFormat(core_default.locale()).format(number);
var getAlternativeNumeralsMap = (() => {
  const numeralsMapCache = {};
  return (locale) => {
    if (!(locale in numeralsMapCache)) {
      if ("0" === formatNumber(0)) {
        numeralsMapCache[locale] = false;
        return false;
      }
      numeralsMapCache[locale] = {};
      for (let i = 0; i < 10; ++i) {
        numeralsMapCache[locale][formatNumber(i)] = i;
      }
    }
    return numeralsMapCache[locale];
  };
})();
var normalizeNumerals = (dateString) => {
  const alternativeNumeralsMap = getAlternativeNumeralsMap(core_default.locale());
  if (!alternativeNumeralsMap) {
    return dateString;
  }
  return dateString.split("").map((sign2) => sign2 in alternativeNumeralsMap ? String(alternativeNumeralsMap[sign2]) : sign2).join("");
};
var removeLeadingZeroes = (str) => str.replace(/(\D)0+(\d)/g, "$1$2");
var dateStringEquals = (actual, expected) => removeLeadingZeroes(actual) === removeLeadingZeroes(expected);
var normalizeMonth = (text) => text.replace("d’", "de ");
var intlFormats = {
  day: {
    day: "numeric"
  },
  date: {
    year: "numeric",
    month: "long",
    day: "numeric"
  },
  dayofweek: {
    weekday: "long"
  },
  longdate: {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  },
  longdatelongtime: {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  },
  longtime: {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  },
  month: {
    month: "long"
  },
  monthandday: {
    month: "long",
    day: "numeric"
  },
  monthandyear: {
    year: "numeric",
    month: "long"
  },
  shortdate: {},
  shorttime: {
    hour: "numeric",
    minute: "numeric"
  },
  shortyear: {
    year: "2-digit"
  },
  year: {
    year: "numeric"
  }
};
Object.defineProperty(intlFormats, "shortdateshorttime", {
  get: function() {
    const defaultOptions3 = Intl.DateTimeFormat(core_default.locale()).resolvedOptions();
    return {
      year: defaultOptions3.year,
      month: defaultOptions3.month,
      day: defaultOptions3.day,
      hour: "numeric",
      minute: "numeric"
    };
  }
});
var getIntlFormat = (format2) => "string" === typeof format2 && intlFormats[format2.toLowerCase()];
var monthNameStrategies = {
  standalone: function(monthIndex, monthFormat) {
    const date = new Date(1999, monthIndex, 13, 1);
    const dateString = getIntlFormatter({
      month: monthFormat
    })(date);
    return dateString;
  },
  format: function(monthIndex, monthFormat) {
    const date = new Date(0, monthIndex, 13, 1);
    const dateString = normalizeMonth(getIntlFormatter({
      day: "numeric",
      month: monthFormat
    })(date));
    const parts = dateString.split(" ").filter((part) => part.indexOf("13") < 0);
    if (1 === parts.length) {
      return parts[0];
    } else if (2 === parts.length) {
      return parts[0].length > parts[1].length ? parts[0] : parts[1];
    }
    return monthNameStrategies.standalone(monthIndex, monthFormat);
  }
};
var date_default2 = {
  engine: function() {
    return "intl";
  },
  getMonthNames: function(format2, type2) {
    const monthFormat = {
      wide: "long",
      abbreviated: "short",
      narrow: "narrow"
    }[format2 || "wide"];
    type2 = "format" === type2 ? type2 : "standalone";
    return Array.apply(null, new Array(12)).map((_, monthIndex) => monthNameStrategies[type2](monthIndex, monthFormat));
  },
  getDayNames: function(format2) {
    const result2 = ((format3) => Array.apply(null, new Array(7)).map((_, dayIndex) => getIntlFormatter({
      weekday: format3
    })(new Date(0, 0, dayIndex))))({
      wide: "long",
      abbreviated: "short",
      short: "narrow",
      narrow: "narrow"
    }[format2 || "wide"]);
    return result2;
  },
  getPeriodNames: function() {
    const hour12Formatter = getIntlFormatter({
      hour: "numeric",
      hour12: true
    });
    return [1, 13].map((hours) => {
      const hourNumberText = formatNumber(1);
      const timeParts = hour12Formatter(new Date(0, 0, 1, hours)).split(hourNumberText);
      if (2 !== timeParts.length) {
        return "";
      }
      const biggerPart = timeParts[0].length > timeParts[1].length ? timeParts[0] : timeParts[1];
      return biggerPart.trim();
    });
  },
  format: function(date, format2) {
    if (!date) {
      return;
    }
    if (!format2) {
      return date;
    }
    if ("function" !== typeof format2 && !format2.formatter) {
      format2 = format2.type || format2;
    }
    const intlFormat = getIntlFormat(format2);
    if (intlFormat) {
      return getIntlFormatter(intlFormat)(date);
    }
    const formatType = typeof format2;
    if (format2.formatter || "function" === formatType || "string" === formatType) {
      return this.callBase.apply(this, arguments);
    }
    return getIntlFormatter(format2)(date);
  },
  parse: function(dateString, format2) {
    let formatter;
    if (format2 && !format2.parser && "string" === typeof dateString) {
      dateString = normalizeMonth(dateString);
      formatter = (date) => normalizeMonth(this.format(date, format2));
    }
    return this.callBase(dateString, formatter || format2);
  },
  _parseDateBySimpleFormat: function(dateString, format2) {
    dateString = normalizeNumerals(dateString);
    const formatParts = this.getFormatParts(format2);
    const dateParts = dateString.split(/\D+/).filter((part) => part.length > 0);
    if (formatParts.length !== dateParts.length) {
      return;
    }
    const dateArgs = this._generateDateArgs(formatParts, dateParts);
    const constructValidDate = (ampmShift) => {
      const parsedDate = ((dateArgs2, ampmShift2) => {
        const hoursShift = ampmShift2 ? 12 : 0;
        return new Date(dateArgs2.year, dateArgs2.month, dateArgs2.day, (dateArgs2.hours + hoursShift) % 24, dateArgs2.minutes, dateArgs2.seconds);
      })(dateArgs, ampmShift);
      if (dateStringEquals(normalizeNumerals(this.format(parsedDate, format2)), dateString)) {
        return parsedDate;
      }
    };
    return constructValidDate(false) || constructValidDate(true);
  },
  _generateDateArgs: function(formatParts, dateParts) {
    const currentDate = /* @__PURE__ */ new Date();
    const dateArgs = {
      year: currentDate.getFullYear(),
      month: currentDate.getMonth(),
      day: currentDate.getDate(),
      hours: 0,
      minutes: 0,
      seconds: 0
    };
    formatParts.forEach((formatPart, index2) => {
      const datePart = dateParts[index2];
      let parsed = parseInt(datePart, 10);
      if ("month" === formatPart) {
        parsed -= 1;
      }
      dateArgs[formatPart] = parsed;
    });
    return dateArgs;
  },
  formatUsesMonthName: function(format2) {
    if ("object" === typeof format2 && !(format2.type || format2.format)) {
      return "long" === format2.month;
    }
    return this.callBase.apply(this, arguments);
  },
  formatUsesDayName: function(format2) {
    if ("object" === typeof format2 && !(format2.type || format2.format)) {
      return "long" === format2.weekday;
    }
    return this.callBase.apply(this, arguments);
  },
  getTimeSeparator: function() {
    return normalizeNumerals(formatDateTime(new Date(2001, 1, 1, 11, 11), {
      hour: "numeric",
      minute: "numeric",
      hour12: false
    })).replace(/\d/g, "");
  },
  getFormatParts: function(format2) {
    if ("string" === typeof format2) {
      return this.callBase(format2);
    }
    const intlFormat = extend({}, intlFormats[format2.toLowerCase()]);
    const date = new Date(2001, 2, 4, 5, 6, 7);
    let formattedDate = getIntlFormatter(intlFormat)(date);
    formattedDate = normalizeNumerals(formattedDate);
    return [{
      name: "year",
      value: 1
    }, {
      name: "month",
      value: 3
    }, {
      name: "day",
      value: 4
    }, {
      name: "hours",
      value: 5
    }, {
      name: "minutes",
      value: 6
    }, {
      name: "seconds",
      value: 7
    }].map((part) => ({
      name: part.name,
      index: formattedDate.indexOf(part.value)
    })).filter((part) => part.index > -1).sort((a, b) => a.index - b.index).map((part) => part.name);
  }
};

// ../../../../../../node_modules/devextreme/esm/localization/date.js
var hasIntl2 = "undefined" !== typeof Intl;
var FORMATS_TO_PATTERN_MAP = {
  shortdate: "M/d/y",
  shorttime: "h:mm a",
  longdate: "EEEE, MMMM d, y",
  longtime: "h:mm:ss a",
  monthandday: "MMMM d",
  monthandyear: "MMMM y",
  quarterandyear: "QQQ y",
  day: "d",
  year: "y",
  shortdateshorttime: "M/d/y, h:mm a",
  longdatelongtime: "EEEE, MMMM d, y, h:mm:ss a",
  month: "LLLL",
  shortyear: "yy",
  dayofweek: "EEEE",
  quarter: "QQQ",
  hour: "HH",
  minute: "mm",
  second: "ss",
  millisecond: "SSS",
  "datetime-local": "yyyy-MM-ddTHH':'mm':'ss"
};
var possiblePartPatterns = {
  year: ["y", "yy", "yyyy"],
  day: ["d", "dd"],
  month: ["M", "MM", "MMM", "MMMM"],
  hours: ["H", "HH", "h", "hh", "ah"],
  minutes: ["m", "mm"],
  seconds: ["s", "ss"],
  milliseconds: ["S", "SS", "SSS"]
};
var dateLocalization = dependency_injector_default({
  engine: function() {
    return "base";
  },
  _getPatternByFormat: function(format2) {
    return FORMATS_TO_PATTERN_MAP[format2.toLowerCase()];
  },
  _expandPattern: function(pattern) {
    return this._getPatternByFormat(pattern) || pattern;
  },
  formatUsesMonthName: function(format2) {
    return -1 !== this._expandPattern(format2).indexOf("MMMM");
  },
  formatUsesDayName: function(format2) {
    return -1 !== this._expandPattern(format2).indexOf("EEEE");
  },
  getFormatParts: function(format2) {
    const pattern = this._getPatternByFormat(format2) || format2;
    const result2 = [];
    each(pattern.split(/\W+/), (_, formatPart) => {
      each(possiblePartPatterns, (partName, possiblePatterns) => {
        if (possiblePatterns.includes(formatPart)) {
          result2.push(partName);
        }
      });
    });
    return result2;
  },
  getMonthNames: function(format2) {
    return default_date_names_default.getMonthNames(format2);
  },
  getDayNames: function(format2) {
    return default_date_names_default.getDayNames(format2);
  },
  getQuarterNames: function(format2) {
    return default_date_names_default.getQuarterNames(format2);
  },
  getPeriodNames: function(format2) {
    return default_date_names_default.getPeriodNames(format2);
  },
  getTimeSeparator: function() {
    return ":";
  },
  is24HourFormat: function(format2) {
    const amTime = new Date(2017, 0, 20, 11, 0, 0, 0);
    const pmTime = new Date(2017, 0, 20, 23, 0, 0, 0);
    const amTimeFormatted = this.format(amTime, format2);
    const pmTimeFormatted = this.format(pmTime, format2);
    for (let i = 0; i < amTimeFormatted.length; i++) {
      if (amTimeFormatted[i] !== pmTimeFormatted[i]) {
        return !isNaN(parseInt(amTimeFormatted[i]));
      }
    }
  },
  format: function(date, format2) {
    if (!date) {
      return;
    }
    if (!format2) {
      return date;
    }
    let formatter;
    if ("function" === typeof format2) {
      formatter = format2;
    } else if (format2.formatter) {
      formatter = format2.formatter;
    } else {
      format2 = format2.type || format2;
      if (isString(format2)) {
        format2 = FORMATS_TO_PATTERN_MAP[format2.toLowerCase()] || format2;
        return number_default2.convertDigits(getFormatter(format2, this)(date));
      }
    }
    if (!formatter) {
      return;
    }
    return formatter(date);
  },
  parse: function(text, format2) {
    const that = this;
    let ldmlFormat;
    let formatter;
    if (!text) {
      return;
    }
    if (!format2) {
      return this.parse(text, "shortdate");
    }
    if (format2.parser) {
      return format2.parser(text);
    }
    if ("string" === typeof format2 && !FORMATS_TO_PATTERN_MAP[format2.toLowerCase()]) {
      ldmlFormat = format2;
    } else {
      formatter = (value2) => {
        const text2 = that.format(value2, format2);
        return number_default2.convertDigits(text2, true);
      };
      try {
        ldmlFormat = getFormat2(formatter);
      } catch (e) {
      }
    }
    if (ldmlFormat) {
      text = number_default2.convertDigits(text, true);
      return getParser(ldmlFormat, this)(text);
    }
    errors_default.log("W0012");
    const result2 = new Date(text);
    if (!result2 || isNaN(result2.getTime())) {
      return;
    }
    return result2;
  },
  firstDayOfWeekIndex: function() {
    const index2 = core_default.getValueByClosestLocale((locale) => first_day_of_week_data_default[locale]);
    return void 0 === index2 ? 0 : index2;
  }
});
if (hasIntl2) {
  dateLocalization.inject(date_default2);
}
var date_default3 = dateLocalization;

// ../../../../../../node_modules/devextreme/esm/localization/default_messages.js
var defaultMessages = {
  en: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    Close: "Close",
    Clear: "Clear",
    Done: "Done",
    Loading: "Loading...",
    Select: "Select...",
    Search: "Search",
    Back: "Back",
    OK: "OK",
    "dxCollectionWidget-noDataText": "No data to display",
    "dxDropDownEditor-selectLabel": "Select",
    "validation-required": "Required",
    "validation-required-formatted": "{0} is required",
    "validation-numeric": "Value must be a number",
    "validation-numeric-formatted": "{0} must be a number",
    "validation-range": "Value is out of range",
    "validation-range-formatted": "{0} is out of range",
    "validation-stringLength": "The length of the value is not correct",
    "validation-stringLength-formatted": "The length of {0} is not correct",
    "validation-custom": "Value is invalid",
    "validation-custom-formatted": "{0} is invalid",
    "validation-async": "Value is invalid",
    "validation-async-formatted": "{0} is invalid",
    "validation-compare": "Values do not match",
    "validation-compare-formatted": "{0} does not match",
    "validation-pattern": "Value does not match pattern",
    "validation-pattern-formatted": "{0} does not match pattern",
    "validation-email": "Email is invalid",
    "validation-email-formatted": "{0} is invalid",
    "validation-mask": "Value is invalid",
    "dxLookup-searchPlaceholder": "Minimum character number: {0}",
    "dxList-pullingDownText": "Pull down to refresh...",
    "dxList-pulledDownText": "Release to refresh...",
    "dxList-refreshingText": "Refreshing...",
    "dxList-pageLoadingText": "Loading...",
    "dxList-nextButtonText": "More",
    "dxList-selectAll": "Select All",
    "dxList-listAriaLabel": "Items",
    "dxList-listAriaLabel-deletable": "Deletable items",
    "dxListEditDecorator-delete": "Delete",
    "dxListEditDecorator-more": "More",
    "dxScrollView-pullingDownText": "Pull down to refresh...",
    "dxScrollView-pulledDownText": "Release to refresh...",
    "dxScrollView-refreshingText": "Refreshing...",
    "dxScrollView-reachBottomText": "Loading...",
    "dxDateBox-simulatedDataPickerTitleTime": "Select time",
    "dxDateBox-simulatedDataPickerTitleDate": "Select date",
    "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
    "dxDateBox-validation-datetime": "Value must be a date or time",
    "dxDateRangeBox-invalidStartDateMessage": "Start value must be a date",
    "dxDateRangeBox-invalidEndDateMessage": "End value must be a date",
    "dxDateRangeBox-startDateOutOfRangeMessage": "Start date is out of range",
    "dxDateRangeBox-endDateOutOfRangeMessage": "End date is out of range",
    "dxDateRangeBox-startDateLabel": "Start Date",
    "dxDateRangeBox-endDateLabel": "End Date",
    "dxFileUploader-selectFile": "Select a file",
    "dxFileUploader-dropFile": "or Drop a file here",
    "dxFileUploader-bytes": "bytes",
    "dxFileUploader-kb": "KB",
    "dxFileUploader-Mb": "MB",
    "dxFileUploader-Gb": "GB",
    "dxFileUploader-upload": "Upload",
    "dxFileUploader-uploaded": "Uploaded",
    "dxFileUploader-readyToUpload": "Ready to upload",
    "dxFileUploader-uploadAbortedMessage": "Upload cancelled",
    "dxFileUploader-uploadFailedMessage": "Upload failed",
    "dxFileUploader-invalidFileExtension": "File type is not allowed",
    "dxFileUploader-invalidMaxFileSize": "File is too large",
    "dxFileUploader-invalidMinFileSize": "File is too small",
    "dxRangeSlider-ariaFrom": "From",
    "dxRangeSlider-ariaTill": "Till",
    "dxSwitch-switchedOnText": "ON",
    "dxSwitch-switchedOffText": "OFF",
    "dxForm-optionalMark": "optional",
    "dxForm-requiredMessage": "{0} is required",
    "dxNumberBox-invalidValueMessage": "Value must be a number",
    "dxNumberBox-noDataText": "No data",
    "dxDataGrid-emptyHeaderWithColumnChooserText": "Use {0} to display columns",
    "dxDataGrid-emptyHeaderWithGroupPanelText": "Drag a column from the group panel here",
    "dxDataGrid-emptyHeaderWithColumnChooserAndGroupPanelText": "Use {0} or drag a column from the group panel",
    "dxDataGrid-emptyHeaderColumnChooserText": "column chooser",
    "dxDataGrid-columnChooserTitle": "Column Chooser",
    "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
    "dxDataGrid-groupContinuesMessage": "Continues on the next page",
    "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
    "dxDataGrid-groupHeaderText": "Group by This Column",
    "dxDataGrid-ungroupHeaderText": "Ungroup",
    "dxDataGrid-ungroupAllText": "Ungroup All",
    "dxDataGrid-editingEditRow": "Edit",
    "dxDataGrid-editingSaveRowChanges": "Save",
    "dxDataGrid-editingCancelRowChanges": "Cancel",
    "dxDataGrid-editingDeleteRow": "Delete",
    "dxDataGrid-editingUndeleteRow": "Undelete",
    "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
    "dxDataGrid-validationCancelChanges": "Cancel changes",
    "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
    "dxDataGrid-noDataText": "No data",
    "dxDataGrid-searchPanelPlaceholder": "Search...",
    "dxDataGrid-filterRowShowAllText": "(All)",
    "dxDataGrid-filterRowResetOperationText": "Reset",
    "dxDataGrid-filterRowOperationEquals": "Equals",
    "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
    "dxDataGrid-filterRowOperationLess": "Less than",
    "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
    "dxDataGrid-filterRowOperationGreater": "Greater than",
    "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
    "dxDataGrid-filterRowOperationStartsWith": "Starts with",
    "dxDataGrid-filterRowOperationContains": "Contains",
    "dxDataGrid-filterRowOperationNotContains": "Does not contain",
    "dxDataGrid-filterRowOperationEndsWith": "Ends with",
    "dxDataGrid-filterRowOperationBetween": "Between",
    "dxDataGrid-filterRowOperationBetweenStartText": "Start",
    "dxDataGrid-filterRowOperationBetweenEndText": "End",
    "dxDataGrid-ariaSearchBox": "Search box",
    "dxDataGrid-applyFilterText": "Apply filter",
    "dxDataGrid-trueText": "true",
    "dxDataGrid-falseText": "false",
    "dxDataGrid-sortingAscendingText": "Sort Ascending",
    "dxDataGrid-sortingDescendingText": "Sort Descending",
    "dxDataGrid-sortingClearText": "Clear Sorting",
    "dxDataGrid-ariaNotSortedColumn": "Not sorted column",
    "dxDataGrid-ariaSortedAscendingColumn": "Column sorted in ascending order",
    "dxDataGrid-ariaSortedDescendingColumn": "Column sorted in descending order",
    "dxDataGrid-ariaSortIndex": "Sort index {0}",
    "dxDataGrid-editingSaveAllChanges": "Save changes",
    "dxDataGrid-editingCancelAllChanges": "Discard changes",
    "dxDataGrid-editingAddRow": "Add a row",
    "dxDataGrid-summaryMin": "Min: {0}",
    "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
    "dxDataGrid-summaryMax": "Max: {0}",
    "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
    "dxDataGrid-summaryAvg": "Avg: {0}",
    "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
    "dxDataGrid-summarySum": "Sum: {0}",
    "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
    "dxDataGrid-summaryCount": "Count: {0}",
    "dxDataGrid-columnFixingFix": "Fix",
    "dxDataGrid-columnFixingUnfix": "Unfix",
    "dxDataGrid-columnFixingLeftPosition": "To the left",
    "dxDataGrid-columnFixingRightPosition": "To the right",
    "dxDataGrid-exportTo": "Export",
    "dxDataGrid-exportToExcel": "Export to Excel file",
    "dxDataGrid-exporting": "Exporting...",
    "dxDataGrid-excelFormat": "Excel file",
    "dxDataGrid-selectedRows": "Selected rows",
    "dxDataGrid-exportSelectedRows": "Export selected rows to {0}",
    "dxDataGrid-exportAll": "Export all data to {0}",
    "dxDataGrid-headerFilterLabel": "Filter options",
    "dxDataGrid-headerFilterIndicatorLabel": "Show filter options for column '{0}'",
    "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
    "dxDataGrid-headerFilterOK": "OK",
    "dxDataGrid-headerFilterCancel": "Cancel",
    "dxDataGrid-ariaAdaptiveCollapse": "Hide additional data",
    "dxDataGrid-ariaAdaptiveExpand": "Display additional data",
    "dxDataGrid-ariaColumn": "Column",
    "dxDataGrid-ariaColumnHeader": "Column header",
    "dxDataGrid-ariaValue": "Value",
    "dxDataGrid-ariaError": "Error",
    "dxDataGrid-ariaRevertButton": "Press Escape to discard the changes",
    "dxDataGrid-ariaFilterCell": "Filter cell",
    "dxDataGrid-ariaCollapse": "Collapse",
    "dxDataGrid-ariaModifiedCell": "Modified",
    "dxDataGrid-ariaDeletedCell": "Deleted",
    "dxDataGrid-ariaEditableCell": "Editable",
    "dxDataGrid-ariaExpand": "Expand",
    "dxDataGrid-ariaCollapsedRow": "Collapsed row",
    "dxDataGrid-ariaExpandedRow": "Expanded row",
    "dxDataGrid-ariaDataGrid": "Data grid with {0} rows and {1} columns",
    "dxDataGrid-ariaSearchInGrid": "Search in the data grid",
    "dxDataGrid-ariaSelectAll": "Select all",
    "dxDataGrid-ariaSelectRow": "Select row",
    "dxDataGrid-ariaToolbar": "Data grid toolbar",
    "dxDataGrid-ariaEditForm": "Edit form",
    "dxDataGrid-filterBuilderPopupTitle": "Filter Builder",
    "dxDataGrid-filterPanelCreateFilter": "Create Filter",
    "dxDataGrid-filterPanelClearFilter": "Clear",
    "dxDataGrid-filterPanelFilterEnabledHint": "Enable the filter",
    "dxDataGrid-masterDetail": "Cell with details",
    "dxTreeList-ariaTreeList": "Tree list with {0} rows and {1} columns",
    "dxTreeList-ariaSearchInGrid": "Search in the tree list",
    "dxTreeList-ariaToolbar": "Tree list toolbar",
    "dxTreeList-editingAddRowToNode": "Add",
    "dxPager-infoText": "Page {0} of {1} ({2} items)",
    "dxPager-pagesCountText": "of",
    "dxPager-pageSize": "Items per page: {0}",
    "dxPager-pageSizesAllText": "All",
    "dxPager-page": "Page {0}",
    "dxPager-prevPage": "Previous Page",
    "dxPager-nextPage": "Next Page",
    "dxPager-ariaLabel": "Page Navigation",
    "dxPager-ariaPageSize": "Page size",
    "dxPager-ariaPageNumber": "Page number",
    "dxPivotGrid-grandTotal": "Grand Total",
    "dxPivotGrid-total": "{0} Total",
    "dxPivotGrid-fieldChooserTitle": "Field Chooser",
    "dxPivotGrid-showFieldChooser": "Show Field Chooser",
    "dxPivotGrid-expandAll": "Expand All",
    "dxPivotGrid-collapseAll": "Collapse All",
    "dxPivotGrid-sortColumnBySummary": 'Sort "{0}" by This Column',
    "dxPivotGrid-sortRowBySummary": 'Sort "{0}" by This Row',
    "dxPivotGrid-removeAllSorting": "Remove All Sorting",
    "dxPivotGrid-dataNotAvailable": "N/A",
    "dxPivotGrid-rowFields": "Row Fields",
    "dxPivotGrid-columnFields": "Column Fields",
    "dxPivotGrid-dataFields": "Data Fields",
    "dxPivotGrid-filterFields": "Filter Fields",
    "dxPivotGrid-allFields": "All Fields",
    "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
    "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
    "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
    "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
    "dxScheduler-editorLabelTitle": "Subject",
    "dxScheduler-editorLabelStartDate": "Start Date",
    "dxScheduler-editorLabelEndDate": "End Date",
    "dxScheduler-editorLabelDescription": "Description",
    "dxScheduler-editorLabelRecurrence": "Repeat",
    "dxScheduler-openAppointment": "Open appointment",
    "dxScheduler-recurrenceNever": "Never",
    "dxScheduler-recurrenceMinutely": "Every minute",
    "dxScheduler-recurrenceHourly": "Hourly",
    "dxScheduler-recurrenceDaily": "Daily",
    "dxScheduler-recurrenceWeekly": "Weekly",
    "dxScheduler-recurrenceMonthly": "Monthly",
    "dxScheduler-recurrenceYearly": "Yearly",
    "dxScheduler-recurrenceRepeatEvery": "Repeat Every",
    "dxScheduler-recurrenceRepeatOn": "Repeat On",
    "dxScheduler-recurrenceEnd": "End repeat",
    "dxScheduler-recurrenceAfter": "After",
    "dxScheduler-recurrenceOn": "On",
    "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
    "dxScheduler-recurrenceRepeatHourly": "hour(s)",
    "dxScheduler-recurrenceRepeatDaily": "day(s)",
    "dxScheduler-recurrenceRepeatWeekly": "week(s)",
    "dxScheduler-recurrenceRepeatMonthly": "month(s)",
    "dxScheduler-recurrenceRepeatYearly": "year(s)",
    "dxScheduler-switcherDay": "Day",
    "dxScheduler-switcherWeek": "Week",
    "dxScheduler-switcherWorkWeek": "Work Week",
    "dxScheduler-switcherMonth": "Month",
    "dxScheduler-switcherAgenda": "Agenda",
    "dxScheduler-switcherTimelineDay": "Timeline Day",
    "dxScheduler-switcherTimelineWeek": "Timeline Week",
    "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
    "dxScheduler-switcherTimelineMonth": "Timeline Month",
    "dxScheduler-recurrenceRepeatOnDate": "on date",
    "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
    "dxScheduler-allDay": "All day",
    "dxScheduler-confirmRecurrenceEditTitle": "Edit Recurring Appointment",
    "dxScheduler-confirmRecurrenceDeleteTitle": "Delete Recurring Appointment",
    "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
    "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
    "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
    "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
    "dxScheduler-noTimezoneTitle": "No timezone",
    "dxScheduler-moreAppointments": "{0} more",
    "dxCalendar-currentDay": "Today",
    "dxCalendar-currentMonth": "Current month",
    "dxCalendar-currentYear": "Current year",
    "dxCalendar-currentYearRange": "Current year range",
    "dxCalendar-todayButtonText": "Today",
    "dxCalendar-ariaWidgetName": "Calendar",
    "dxCalendar-previousMonthButtonLabel": "Previous month",
    "dxCalendar-previousYearButtonLabel": "Previous year",
    "dxCalendar-previousDecadeButtonLabel": "Previous decade",
    "dxCalendar-previousCenturyButtonLabel": "Previous century",
    "dxCalendar-nextMonthButtonLabel": "Next month",
    "dxCalendar-nextYearButtonLabel": "Next year",
    "dxCalendar-nextDecadeButtonLabel": "Next decade",
    "dxCalendar-nextCenturyButtonLabel": "Next century",
    "dxCalendar-captionMonthLabel": "Month selection",
    "dxCalendar-captionYearLabel": "Year selection",
    "dxCalendar-captionDecadeLabel": "Decade selection",
    "dxCalendar-captionCenturyLabel": "Century selection",
    "dxCalendar-selectedDate": "The selected date is {0}",
    "dxCalendar-selectedDateRange": "The selected date range is from {0} to {1}",
    "dxColorView-ariaRed": "Red",
    "dxColorView-ariaGreen": "Green",
    "dxColorView-ariaBlue": "Blue",
    "dxColorView-ariaAlpha": "Transparency",
    "dxColorView-ariaHex": "Color code",
    "dxTagBox-selected": "{0} selected",
    "dxTagBox-allSelected": "All selected ({0})",
    "dxTagBox-moreSelected": "{0} more",
    "dxTagBox-tagRoleDescription": "Tag. Press the delete button to remove this tag",
    "vizExport-printingButtonText": "Print",
    "vizExport-titleMenuText": "Exporting/Printing",
    "vizExport-exportButtonText": "{0} file",
    "dxFilterBuilder-and": "And",
    "dxFilterBuilder-or": "Or",
    "dxFilterBuilder-notAnd": "Not And",
    "dxFilterBuilder-notOr": "Not Or",
    "dxFilterBuilder-addCondition": "Add Condition",
    "dxFilterBuilder-addGroup": "Add Group",
    "dxFilterBuilder-enterValueText": "<enter a value>",
    "dxFilterBuilder-filterOperationEquals": "Equals",
    "dxFilterBuilder-filterOperationNotEquals": "Does not equal",
    "dxFilterBuilder-filterOperationLess": "Is less than",
    "dxFilterBuilder-filterOperationLessOrEquals": "Is less than or equal to",
    "dxFilterBuilder-filterOperationGreater": "Is greater than",
    "dxFilterBuilder-filterOperationGreaterOrEquals": "Is greater than or equal to",
    "dxFilterBuilder-filterOperationStartsWith": "Starts with",
    "dxFilterBuilder-filterOperationContains": "Contains",
    "dxFilterBuilder-filterOperationNotContains": "Does not contain",
    "dxFilterBuilder-filterOperationEndsWith": "Ends with",
    "dxFilterBuilder-filterOperationIsBlank": "Is blank",
    "dxFilterBuilder-filterOperationIsNotBlank": "Is not blank",
    "dxFilterBuilder-filterOperationBetween": "Is between",
    "dxFilterBuilder-filterOperationAnyOf": "Is any of",
    "dxFilterBuilder-filterOperationNoneOf": "Is none of",
    "dxHtmlEditor-dialogColorCaption": "Change Font Color",
    "dxHtmlEditor-dialogBackgroundCaption": "Change Background Color",
    "dxHtmlEditor-dialogLinkCaption": "Add Link",
    "dxHtmlEditor-dialogLinkUrlField": "URL",
    "dxHtmlEditor-dialogLinkTextField": "Text",
    "dxHtmlEditor-dialogLinkTargetField": "Open link in new window",
    "dxHtmlEditor-dialogImageCaption": "Add Image",
    "dxHtmlEditor-dialogImageUrlField": "URL",
    "dxHtmlEditor-dialogImageAltField": "Alternate text",
    "dxHtmlEditor-dialogImageWidthField": "Width (px)",
    "dxHtmlEditor-dialogImageHeightField": "Height (px)",
    "dxHtmlEditor-dialogInsertTableRowsField": "Rows",
    "dxHtmlEditor-dialogInsertTableColumnsField": "Columns",
    "dxHtmlEditor-dialogInsertTableCaption": "Insert Table",
    "dxHtmlEditor-dialogUpdateImageCaption": "Update Image",
    "dxHtmlEditor-dialogImageUpdateButton": "Update",
    "dxHtmlEditor-dialogImageAddButton": "Add",
    "dxHtmlEditor-dialogImageSpecifyUrl": "From the Web",
    "dxHtmlEditor-dialogImageSelectFile": "From This Device",
    "dxHtmlEditor-dialogImageKeepAspectRatio": "Keep Aspect Ratio",
    "dxHtmlEditor-dialogImageEncodeToBase64": "Encode to Base64",
    "dxHtmlEditor-heading": "Heading",
    "dxHtmlEditor-normalText": "Normal text",
    "dxHtmlEditor-background": "Background Color",
    "dxHtmlEditor-bold": "Bold",
    "dxHtmlEditor-color": "Font Color",
    "dxHtmlEditor-font": "Font",
    "dxHtmlEditor-italic": "Italic",
    "dxHtmlEditor-link": "Add Link",
    "dxHtmlEditor-image": "Add Image",
    "dxHtmlEditor-size": "Size",
    "dxHtmlEditor-strike": "Strikethrough",
    "dxHtmlEditor-subscript": "Subscript",
    "dxHtmlEditor-superscript": "Superscript",
    "dxHtmlEditor-underline": "Underline",
    "dxHtmlEditor-blockquote": "Blockquote",
    "dxHtmlEditor-header": "Header",
    "dxHtmlEditor-increaseIndent": "Increase Indent",
    "dxHtmlEditor-decreaseIndent": "Decrease Indent",
    "dxHtmlEditor-orderedList": "Ordered List",
    "dxHtmlEditor-bulletList": "Bullet List",
    "dxHtmlEditor-alignLeft": "Align Left",
    "dxHtmlEditor-alignCenter": "Align Center",
    "dxHtmlEditor-alignRight": "Align Right",
    "dxHtmlEditor-alignJustify": "Align Justify",
    "dxHtmlEditor-codeBlock": "Code Block",
    "dxHtmlEditor-variable": "Add Variable",
    "dxHtmlEditor-undo": "Undo",
    "dxHtmlEditor-redo": "Redo",
    "dxHtmlEditor-clear": "Clear Formatting",
    "dxHtmlEditor-insertTable": "Insert Table",
    "dxHtmlEditor-insertHeaderRow": "Insert Header Row",
    "dxHtmlEditor-insertRowAbove": "Insert Row Above",
    "dxHtmlEditor-insertRowBelow": "Insert Row Below",
    "dxHtmlEditor-insertColumnLeft": "Insert Column Left",
    "dxHtmlEditor-insertColumnRight": "Insert Column Right",
    "dxHtmlEditor-deleteColumn": "Delete Column",
    "dxHtmlEditor-deleteRow": "Delete Row",
    "dxHtmlEditor-deleteTable": "Delete Table",
    "dxHtmlEditor-cellProperties": "Cell Properties",
    "dxHtmlEditor-tableProperties": "Table Properties",
    "dxHtmlEditor-insert": "Insert",
    "dxHtmlEditor-delete": "Delete",
    "dxHtmlEditor-border": "Border",
    "dxHtmlEditor-style": "Style",
    "dxHtmlEditor-width": "Width",
    "dxHtmlEditor-height": "Height",
    "dxHtmlEditor-borderColor": "Color",
    "dxHtmlEditor-borderWidth": "Border Width",
    "dxHtmlEditor-tableBackground": "Background",
    "dxHtmlEditor-dimensions": "Dimensions",
    "dxHtmlEditor-alignment": "Alignment",
    "dxHtmlEditor-horizontal": "Horizontal",
    "dxHtmlEditor-vertical": "Vertical",
    "dxHtmlEditor-paddingVertical": "Vertical Padding",
    "dxHtmlEditor-paddingHorizontal": "Horizontal Padding",
    "dxHtmlEditor-pixels": "Pixels",
    "dxHtmlEditor-list": "List",
    "dxHtmlEditor-ordered": "Ordered",
    "dxHtmlEditor-bullet": "Bullet",
    "dxHtmlEditor-align": "Align",
    "dxHtmlEditor-center": "Center",
    "dxHtmlEditor-left": "Left",
    "dxHtmlEditor-right": "Right",
    "dxHtmlEditor-indent": "Indent",
    "dxHtmlEditor-justify": "Justify",
    "dxHtmlEditor-borderStyleNone": "none",
    "dxHtmlEditor-borderStyleHidden": "hidden",
    "dxHtmlEditor-borderStyleDotted": "dotted",
    "dxHtmlEditor-borderStyleDashed": "dashed",
    "dxHtmlEditor-borderStyleSolid": "solid",
    "dxHtmlEditor-borderStyleDouble": "double",
    "dxHtmlEditor-borderStyleGroove": "groove",
    "dxHtmlEditor-borderStyleRidge": "ridge",
    "dxHtmlEditor-borderStyleInset": "inset",
    "dxHtmlEditor-borderStyleOutset": "outset",
    "dxFileManager-newDirectoryName": "Untitled directory",
    "dxFileManager-rootDirectoryName": "Files",
    "dxFileManager-errorNoAccess": "Access Denied. Operation could not be completed.",
    "dxFileManager-errorDirectoryExistsFormat": "Directory '{0}' already exists.",
    "dxFileManager-errorFileExistsFormat": "File '{0}' already exists.",
    "dxFileManager-errorFileNotFoundFormat": "File '{0}' not found.",
    "dxFileManager-errorDirectoryNotFoundFormat": "Directory '{0}' not found.",
    "dxFileManager-errorWrongFileExtension": "File extension is not allowed.",
    "dxFileManager-errorMaxFileSizeExceeded": "File size exceeds the maximum allowed size.",
    "dxFileManager-errorInvalidSymbols": "This name contains invalid characters.",
    "dxFileManager-errorDefault": "Unspecified error.",
    "dxFileManager-errorDirectoryOpenFailed": "The directory cannot be opened",
    "dxFileManager-commandCreate": "New directory",
    "dxFileManager-commandRename": "Rename",
    "dxFileManager-commandMove": "Move to",
    "dxFileManager-commandCopy": "Copy to",
    "dxFileManager-commandDelete": "Delete",
    "dxFileManager-commandDownload": "Download",
    "dxFileManager-commandUpload": "Upload files",
    "dxFileManager-commandRefresh": "Refresh",
    "dxFileManager-commandThumbnails": "Thumbnails View",
    "dxFileManager-commandDetails": "Details View",
    "dxFileManager-commandClearSelection": "Clear selection",
    "dxFileManager-commandShowNavPane": "Toggle navigation pane",
    "dxFileManager-dialogDirectoryChooserMoveTitle": "Move to",
    "dxFileManager-dialogDirectoryChooserMoveButtonText": "Move",
    "dxFileManager-dialogDirectoryChooserCopyTitle": "Copy to",
    "dxFileManager-dialogDirectoryChooserCopyButtonText": "Copy",
    "dxFileManager-dialogRenameItemTitle": "Rename",
    "dxFileManager-dialogRenameItemButtonText": "Save",
    "dxFileManager-dialogCreateDirectoryTitle": "New directory",
    "dxFileManager-dialogCreateDirectoryButtonText": "Create",
    "dxFileManager-dialogDeleteItemTitle": "Delete",
    "dxFileManager-dialogDeleteItemButtonText": "Delete",
    "dxFileManager-dialogDeleteItemSingleItemConfirmation": "Are you sure you want to delete {0}?",
    "dxFileManager-dialogDeleteItemMultipleItemsConfirmation": "Are you sure you want to delete {0} items?",
    "dxFileManager-dialogButtonCancel": "Cancel",
    "dxFileManager-editingCreateSingleItemProcessingMessage": "Creating a directory inside {0}",
    "dxFileManager-editingCreateSingleItemSuccessMessage": "Created a directory inside {0}",
    "dxFileManager-editingCreateSingleItemErrorMessage": "Directory was not created",
    "dxFileManager-editingCreateCommonErrorMessage": "Directory was not created",
    "dxFileManager-editingRenameSingleItemProcessingMessage": "Renaming an item inside {0}",
    "dxFileManager-editingRenameSingleItemSuccessMessage": "Renamed an item inside {0}",
    "dxFileManager-editingRenameSingleItemErrorMessage": "Item was not renamed",
    "dxFileManager-editingRenameCommonErrorMessage": "Item was not renamed",
    "dxFileManager-editingDeleteSingleItemProcessingMessage": "Deleting an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsProcessingMessage": "Deleting {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemSuccessMessage": "Deleted an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsSuccessMessage": "Deleted {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemErrorMessage": "Item was not deleted",
    "dxFileManager-editingDeleteMultipleItemsErrorMessage": "{0} items were not deleted",
    "dxFileManager-editingDeleteCommonErrorMessage": "Some items were not deleted",
    "dxFileManager-editingMoveSingleItemProcessingMessage": "Moving an item to {0}",
    "dxFileManager-editingMoveMultipleItemsProcessingMessage": "Moving {0} items to {1}",
    "dxFileManager-editingMoveSingleItemSuccessMessage": "Moved an item to {0}",
    "dxFileManager-editingMoveMultipleItemsSuccessMessage": "Moved {0} items to {1}",
    "dxFileManager-editingMoveSingleItemErrorMessage": "Item was not moved",
    "dxFileManager-editingMoveMultipleItemsErrorMessage": "{0} items were not moved",
    "dxFileManager-editingMoveCommonErrorMessage": "Some items were not moved",
    "dxFileManager-editingCopySingleItemProcessingMessage": "Copying an item to {0}",
    "dxFileManager-editingCopyMultipleItemsProcessingMessage": "Copying {0} items to {1}",
    "dxFileManager-editingCopySingleItemSuccessMessage": "Copied an item to {0}",
    "dxFileManager-editingCopyMultipleItemsSuccessMessage": "Copied {0} items to {1}",
    "dxFileManager-editingCopySingleItemErrorMessage": "Item was not copied",
    "dxFileManager-editingCopyMultipleItemsErrorMessage": "{0} items were not copied",
    "dxFileManager-editingCopyCommonErrorMessage": "Some items were not copied",
    "dxFileManager-editingUploadSingleItemProcessingMessage": "Uploading an item to {0}",
    "dxFileManager-editingUploadMultipleItemsProcessingMessage": "Uploading {0} items to {1}",
    "dxFileManager-editingUploadSingleItemSuccessMessage": "Uploaded an item to {0}",
    "dxFileManager-editingUploadMultipleItemsSuccessMessage": "Uploaded {0} items to {1}",
    "dxFileManager-editingUploadSingleItemErrorMessage": "Item was not uploaded",
    "dxFileManager-editingUploadMultipleItemsErrorMessage": "{0} items were not uploaded",
    "dxFileManager-editingUploadCanceledMessage": "Canceled",
    "dxFileManager-editingDownloadSingleItemErrorMessage": "Item was not downloaded",
    "dxFileManager-editingDownloadMultipleItemsErrorMessage": "{0} items were not downloaded",
    "dxFileManager-listDetailsColumnCaptionName": "Name",
    "dxFileManager-listDetailsColumnCaptionDateModified": "Date Modified",
    "dxFileManager-listDetailsColumnCaptionFileSize": "File Size",
    "dxFileManager-listThumbnailsTooltipTextSize": "Size",
    "dxFileManager-listThumbnailsTooltipTextDateModified": "Date Modified",
    "dxFileManager-notificationProgressPanelTitle": "Progress",
    "dxFileManager-notificationProgressPanelEmptyListText": "No operations",
    "dxFileManager-notificationProgressPanelOperationCanceled": "Canceled",
    "dxDiagram-categoryGeneral": "General",
    "dxDiagram-categoryFlowchart": "Flowchart",
    "dxDiagram-categoryOrgChart": "Org Chart",
    "dxDiagram-categoryContainers": "Containers",
    "dxDiagram-categoryCustom": "Custom",
    "dxDiagram-commandExportToSvg": "Export to SVG",
    "dxDiagram-commandExportToPng": "Export to PNG",
    "dxDiagram-commandExportToJpg": "Export to JPEG",
    "dxDiagram-commandUndo": "Undo",
    "dxDiagram-commandRedo": "Redo",
    "dxDiagram-commandFontName": "Font Name",
    "dxDiagram-commandFontSize": "Font Size",
    "dxDiagram-commandBold": "Bold",
    "dxDiagram-commandItalic": "Italic",
    "dxDiagram-commandUnderline": "Underline",
    "dxDiagram-commandTextColor": "Font Color",
    "dxDiagram-commandLineColor": "Line Color",
    "dxDiagram-commandLineWidth": "Line Width",
    "dxDiagram-commandLineStyle": "Line Style",
    "dxDiagram-commandLineStyleSolid": "Solid",
    "dxDiagram-commandLineStyleDotted": "Dotted",
    "dxDiagram-commandLineStyleDashed": "Dashed",
    "dxDiagram-commandFillColor": "Fill Color",
    "dxDiagram-commandAlignLeft": "Align Left",
    "dxDiagram-commandAlignCenter": "Align Center",
    "dxDiagram-commandAlignRight": "Align Right",
    "dxDiagram-commandConnectorLineType": "Connector Line Type",
    "dxDiagram-commandConnectorLineStraight": "Straight",
    "dxDiagram-commandConnectorLineOrthogonal": "Orthogonal",
    "dxDiagram-commandConnectorLineStart": "Connector Line Start",
    "dxDiagram-commandConnectorLineEnd": "Connector Line End",
    "dxDiagram-commandConnectorLineNone": "None",
    "dxDiagram-commandConnectorLineArrow": "Arrow",
    "dxDiagram-commandFullscreen": "Full Screen",
    "dxDiagram-commandUnits": "Units",
    "dxDiagram-commandPageSize": "Page Size",
    "dxDiagram-commandPageOrientation": "Page Orientation",
    "dxDiagram-commandPageOrientationLandscape": "Landscape",
    "dxDiagram-commandPageOrientationPortrait": "Portrait",
    "dxDiagram-commandPageColor": "Page Color",
    "dxDiagram-commandShowGrid": "Show Grid",
    "dxDiagram-commandSnapToGrid": "Snap to Grid",
    "dxDiagram-commandGridSize": "Grid Size",
    "dxDiagram-commandZoomLevel": "Zoom Level",
    "dxDiagram-commandAutoZoom": "Auto Zoom",
    "dxDiagram-commandFitToContent": "Fit to Content",
    "dxDiagram-commandFitToWidth": "Fit to Width",
    "dxDiagram-commandAutoZoomByContent": "Auto Zoom by Content",
    "dxDiagram-commandAutoZoomByWidth": "Auto Zoom by Width",
    "dxDiagram-commandSimpleView": "Simple View",
    "dxDiagram-commandCut": "Cut",
    "dxDiagram-commandCopy": "Copy",
    "dxDiagram-commandPaste": "Paste",
    "dxDiagram-commandSelectAll": "Select All",
    "dxDiagram-commandDelete": "Delete",
    "dxDiagram-commandBringToFront": "Bring to Front",
    "dxDiagram-commandSendToBack": "Send to Back",
    "dxDiagram-commandLock": "Lock",
    "dxDiagram-commandUnlock": "Unlock",
    "dxDiagram-commandInsertShapeImage": "Insert Image...",
    "dxDiagram-commandEditShapeImage": "Change Image...",
    "dxDiagram-commandDeleteShapeImage": "Delete Image",
    "dxDiagram-commandLayoutLeftToRight": "Left-to-right",
    "dxDiagram-commandLayoutRightToLeft": "Right-to-left",
    "dxDiagram-commandLayoutTopToBottom": "Top-to-bottom",
    "dxDiagram-commandLayoutBottomToTop": "Bottom-to-top",
    "dxDiagram-unitIn": "in",
    "dxDiagram-unitCm": "cm",
    "dxDiagram-unitPx": "px",
    "dxDiagram-dialogButtonOK": "OK",
    "dxDiagram-dialogButtonCancel": "Cancel",
    "dxDiagram-dialogInsertShapeImageTitle": "Insert Image",
    "dxDiagram-dialogEditShapeImageTitle": "Change Image",
    "dxDiagram-dialogEditShapeImageSelectButton": "Select image",
    "dxDiagram-dialogEditShapeImageLabelText": "or drop a file here",
    "dxDiagram-uiExport": "Export",
    "dxDiagram-uiProperties": "Properties",
    "dxDiagram-uiSettings": "Settings",
    "dxDiagram-uiShowToolbox": "Show Toolbox",
    "dxDiagram-uiSearch": "Search",
    "dxDiagram-uiStyle": "Style",
    "dxDiagram-uiLayout": "Layout",
    "dxDiagram-uiLayoutTree": "Tree",
    "dxDiagram-uiLayoutLayered": "Layered",
    "dxDiagram-uiDiagram": "Diagram",
    "dxDiagram-uiText": "Text",
    "dxDiagram-uiObject": "Object",
    "dxDiagram-uiConnector": "Connector",
    "dxDiagram-uiPage": "Page",
    "dxDiagram-shapeText": "Text",
    "dxDiagram-shapeRectangle": "Rectangle",
    "dxDiagram-shapeEllipse": "Ellipse",
    "dxDiagram-shapeCross": "Cross",
    "dxDiagram-shapeTriangle": "Triangle",
    "dxDiagram-shapeDiamond": "Diamond",
    "dxDiagram-shapeHeart": "Heart",
    "dxDiagram-shapePentagon": "Pentagon",
    "dxDiagram-shapeHexagon": "Hexagon",
    "dxDiagram-shapeOctagon": "Octagon",
    "dxDiagram-shapeStar": "Star",
    "dxDiagram-shapeArrowLeft": "Left Arrow",
    "dxDiagram-shapeArrowUp": "Up Arrow",
    "dxDiagram-shapeArrowRight": "Right Arrow",
    "dxDiagram-shapeArrowDown": "Down Arrow",
    "dxDiagram-shapeArrowUpDown": "Up Down Arrow",
    "dxDiagram-shapeArrowLeftRight": "Left Right Arrow",
    "dxDiagram-shapeProcess": "Process",
    "dxDiagram-shapeDecision": "Decision",
    "dxDiagram-shapeTerminator": "Terminator",
    "dxDiagram-shapePredefinedProcess": "Predefined Process",
    "dxDiagram-shapeDocument": "Document",
    "dxDiagram-shapeMultipleDocuments": "Multiple Documents",
    "dxDiagram-shapeManualInput": "Manual Input",
    "dxDiagram-shapePreparation": "Preparation",
    "dxDiagram-shapeData": "Data",
    "dxDiagram-shapeDatabase": "Database",
    "dxDiagram-shapeHardDisk": "Hard Disk",
    "dxDiagram-shapeInternalStorage": "Internal Storage",
    "dxDiagram-shapePaperTape": "Paper Tape",
    "dxDiagram-shapeManualOperation": "Manual Operation",
    "dxDiagram-shapeDelay": "Delay",
    "dxDiagram-shapeStoredData": "Stored Data",
    "dxDiagram-shapeDisplay": "Display",
    "dxDiagram-shapeMerge": "Merge",
    "dxDiagram-shapeConnector": "Connector",
    "dxDiagram-shapeOr": "Or",
    "dxDiagram-shapeSummingJunction": "Summing Junction",
    "dxDiagram-shapeContainerDefaultText": "Container",
    "dxDiagram-shapeVerticalContainer": "Vertical Container",
    "dxDiagram-shapeHorizontalContainer": "Horizontal Container",
    "dxDiagram-shapeCardDefaultText": "Person's Name",
    "dxDiagram-shapeCardWithImageOnLeft": "Card with Image on the Left",
    "dxDiagram-shapeCardWithImageOnTop": "Card with Image on the Top",
    "dxDiagram-shapeCardWithImageOnRight": "Card with Image on the Right",
    "dxGantt-dialogTitle": "Title",
    "dxGantt-dialogStartTitle": "Start",
    "dxGantt-dialogEndTitle": "End",
    "dxGantt-dialogProgressTitle": "Progress",
    "dxGantt-dialogResourcesTitle": "Resources",
    "dxGantt-dialogResourceManagerTitle": "Resource Manager",
    "dxGantt-dialogTaskDetailsTitle": "Task Details",
    "dxGantt-dialogEditResourceListHint": "Edit Resource List",
    "dxGantt-dialogEditNoResources": "No resources",
    "dxGantt-dialogButtonAdd": "Add",
    "dxGantt-contextMenuNewTask": "New Task",
    "dxGantt-contextMenuNewSubtask": "New Subtask",
    "dxGantt-contextMenuDeleteTask": "Delete Task",
    "dxGantt-contextMenuDeleteDependency": "Delete Dependency",
    "dxGantt-dialogTaskDeleteConfirmation": "Deleting a task also deletes all its dependencies and subtasks. Are you sure you want to delete this task?",
    "dxGantt-dialogDependencyDeleteConfirmation": "Are you sure you want to delete the dependency from the task?",
    "dxGantt-dialogResourcesDeleteConfirmation": "Deleting a resource also deletes it from tasks to which this resource is assigned. Are you sure you want to delete these resources? Resources: {0}",
    "dxGantt-dialogConstraintCriticalViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. How would you like to proceed?",
    "dxGantt-dialogCancelOperationMessage": "Cancel the operation",
    "dxGantt-dialogDeleteDependencyMessage": "Delete the dependency",
    "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "Move the task and keep the dependency",
    "dxGantt-dialogConstraintCriticalViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. How would you like to proceed?",
    "dxGantt-dialogDeleteDependenciesMessage": "Delete the dependency relations",
    "dxGantt-dialogMoveTaskAndKeepDependenciesMessage": "Move the task and keep the dependencies",
    "dxGantt-undo": "Undo",
    "dxGantt-redo": "Redo",
    "dxGantt-expandAll": "Expand All",
    "dxGantt-collapseAll": "Collapse All",
    "dxGantt-addNewTask": "Add New Task",
    "dxGantt-deleteSelectedTask": "Delete Selected Task",
    "dxGantt-zoomIn": "Zoom In",
    "dxGantt-zoomOut": "Zoom Out",
    "dxGantt-fullScreen": "Full Screen",
    "dxGantt-quarter": "Q{0}",
    "dxGantt-sortingAscendingText": "Sort Ascending",
    "dxGantt-sortingDescendingText": "Sort Descending",
    "dxGantt-sortingClearText": "Clear Sorting",
    "dxGantt-showResources": "Show Resources",
    "dxGantt-showDependencies": "Show Dependencies",
    "dxGantt-dialogStartDateValidation": "Start date must be after {0}",
    "dxGantt-dialogEndDateValidation": "End date must be after {0}",
    "dxGallery-itemName": "Gallery item",
    "dxMultiView-elementAriaRoleDescription": "MultiView",
    "dxMultiView-elementAriaLabel": "Use the arrow keys or swipe to navigate between views",
    "dxMultiView-itemAriaRoleDescription": "View",
    "dxMultiView-itemAriaLabel": "{0} of {1}",
    "dxSplitter-resizeHandleAriaLabel": "Split bar"
  }
};

// ../../../../../../node_modules/devextreme/esm/localization/message.js
var baseDictionary = extend(true, {}, defaultMessages);
var getDataByLocale = (localeData, locale) => {
  var _Object$entries$find;
  return localeData[locale] || (null === locale || void 0 === locale ? void 0 : locale.toLowerCase) && (null === (_Object$entries$find = Object.entries(localeData).find((_ref) => {
    let [key] = _ref;
    return key.toLowerCase() === locale.toLowerCase();
  })) || void 0 === _Object$entries$find ? void 0 : _Object$entries$find[1]) || {};
};
var newMessages = {};
var messageLocalization = dependency_injector_default({
  engine: function() {
    return "base";
  },
  _dictionary: baseDictionary,
  load: function(messages) {
    extend(true, this._dictionary, messages);
  },
  _localizablePrefix: "@",
  setup: function(localizablePrefix) {
    this._localizablePrefix = localizablePrefix;
  },
  localizeString: function(text) {
    const that = this;
    const regex = new RegExp("(^|[^a-zA-Z_0-9" + that._localizablePrefix + "-]+)(" + that._localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g");
    const escapeString = that._localizablePrefix + that._localizablePrefix;
    return text.replace(regex, (str, prefix, escape, localizationKey) => {
      const defaultResult = that._localizablePrefix + localizationKey;
      let result2;
      if (escape !== escapeString) {
        result2 = that.format(localizationKey);
      }
      if (!result2) {
        newMessages[localizationKey] = humanize(localizationKey);
      }
      return prefix + (result2 || defaultResult);
    });
  },
  getMessagesByLocales: function() {
    return this._dictionary;
  },
  getDictionary: function(onlyNew) {
    if (onlyNew) {
      return newMessages;
    }
    return extend({}, newMessages, this.getMessagesByLocales()[core_default.locale()]);
  },
  getFormatter: function(key) {
    return this._getFormatterBase(key) || this._getFormatterBase(key, "en");
  },
  _getFormatterBase: function(key, locale) {
    const message = core_default.getValueByClosestLocale((locale2) => getDataByLocale(this._dictionary, locale2)[key]);
    if (message) {
      return function() {
        const args = 1 === arguments.length && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
        args.unshift(message);
        return format.apply(this, args);
      };
    }
  },
  format: function(key) {
    const formatter = this.getFormatter(key);
    const values = Array.prototype.slice.call(arguments, 1);
    return formatter && formatter.apply(this, values) || "";
  }
});
var message_default = messageLocalization;

// ../../../../../../node_modules/devextreme/esm/core/action.js
var Action = class _Action {
  constructor(action, config3) {
    config3 = config3 || {};
    this._action = action;
    this._context = config3.context || getWindow();
    this._beforeExecute = config3.beforeExecute;
    this._afterExecute = config3.afterExecute;
    this._component = config3.component;
    this._validatingTargetName = config3.validatingTargetName;
    const excludeValidators = this._excludeValidators = {};
    if (config3.excludeValidators) {
      for (let i = 0; i < config3.excludeValidators.length; i++) {
        excludeValidators[config3.excludeValidators[i]] = true;
      }
    }
  }
  execute() {
    const e = {
      action: this._action,
      args: Array.prototype.slice.call(arguments),
      context: this._context,
      component: this._component,
      validatingTargetName: this._validatingTargetName,
      cancel: false,
      handled: false
    };
    const beforeExecute = this._beforeExecute;
    const afterExecute = this._afterExecute;
    const argsBag = e.args[0] || {};
    if (!this._validateAction(e)) {
      return;
    }
    null === beforeExecute || void 0 === beforeExecute || beforeExecute.call(this._context, e);
    if (e.cancel) {
      return;
    }
    const result2 = this._executeAction(e);
    if (argsBag.cancel) {
      return;
    }
    null === afterExecute || void 0 === afterExecute || afterExecute.call(this._context, e);
    return result2;
  }
  _validateAction(e) {
    const excludeValidators = this._excludeValidators;
    const {
      executors
    } = _Action;
    for (const name2 in executors) {
      if (!excludeValidators[name2]) {
        var _executor$validate;
        const executor = executors[name2];
        null === (_executor$validate = executor.validate) || void 0 === _executor$validate || _executor$validate.call(executor, e);
        if (e.cancel) {
          return false;
        }
      }
    }
    return true;
  }
  _executeAction(e) {
    let result2;
    const {
      executors
    } = _Action;
    for (const name2 in executors) {
      var _executor$execute;
      const executor = executors[name2];
      null === (_executor$execute = executor.execute) || void 0 === _executor$execute || _executor$execute.call(executor, e);
      if (e.handled) {
        result2 = e.result;
        break;
      }
    }
    return result2;
  }
  static registerExecutor(name2, executor) {
    if (isPlainObject(name2)) {
      each(name2, _Action.registerExecutor);
      return;
    }
    _Action.executors[name2] = executor;
  }
  static unregisterExecutor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    each(args, function() {
      delete _Action.executors[this];
    });
  }
};
Action.executors = {};
var createValidatorByTargetElement = (condition) => (e) => {
  if (!e.args.length) {
    return;
  }
  const args = e.args[0];
  const element = args[e.validatingTargetName] || args.element;
  if (element && condition(renderer_default(element))) {
    e.cancel = true;
  }
};
Action.registerExecutor({
  disabled: {
    validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-disabled, .dx-state-disabled *"))
  },
  readOnly: {
    validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-readonly, .dx-state-readonly *:not(.dx-state-independent)"))
  },
  undefined: {
    execute: (e) => {
      if (!e.action) {
        e.result = void 0;
        e.handled = true;
      }
    }
  },
  func: {
    execute: (e) => {
      if (isFunction(e.action)) {
        e.result = e.action.call(e.context, e.args[0]);
        e.handled = true;
      }
    }
  }
});

// ../../../../../../node_modules/devextreme/esm/animation/translator.js
var TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/;
var TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
var locate = function($element) {
  $element = renderer_default($element);
  const translate = getTranslate($element);
  return {
    left: translate.x,
    top: translate.y
  };
};
function isPercentValue(value2) {
  return "string" === type(value2) && "%" === value2[value2.length - 1];
}
function cacheTranslate($element, translate) {
  if ($element.length) {
    data($element.get(0), "dxTranslator", translate);
  }
}
var clearCache = function($element) {
  if ($element.length) {
    removeData($element.get(0), "dxTranslator");
  }
};
var getTranslateCss = function(translate) {
  translate.x = translate.x || 0;
  translate.y = translate.y || 0;
  const xValueString = isPercentValue(translate.x) ? translate.x : translate.x + "px";
  const yValueString = isPercentValue(translate.y) ? translate.y : translate.y + "px";
  return "translate(" + xValueString + ", " + yValueString + ")";
};
var getTranslate = function($element) {
  let result2 = $element.length ? data($element.get(0), "dxTranslator") : null;
  if (!result2) {
    const transformValue = $element.css("transform") || getTranslateCss({
      x: 0,
      y: 0
    });
    let matrix = transformValue.match(TRANSFORM_MATRIX_REGEX);
    const is3D = matrix && matrix[1];
    if (matrix) {
      matrix = matrix[2].split(",");
      if ("3d" === is3D) {
        matrix = matrix.slice(12, 15);
      } else {
        matrix.push(0);
        matrix = matrix.slice(4, 7);
      }
    } else {
      matrix = [0, 0, 0];
    }
    result2 = {
      x: parseFloat(matrix[0]),
      y: parseFloat(matrix[1]),
      z: parseFloat(matrix[2])
    };
    cacheTranslate($element, result2);
  }
  return result2;
};
var move = function($element, position3) {
  $element = renderer_default($element);
  const left = position3.left;
  const top = position3.top;
  let translate;
  if (void 0 === left) {
    translate = getTranslate($element);
    translate.y = top || 0;
  } else if (void 0 === top) {
    translate = getTranslate($element);
    translate.x = left || 0;
  } else {
    translate = {
      x: left || 0,
      y: top || 0,
      z: 0
    };
    cacheTranslate($element, translate);
  }
  $element.css({
    transform: getTranslateCss(translate)
  });
  if (isPercentValue(left) || isPercentValue(top)) {
    clearCache($element);
  }
};
var resetPosition = function($element, finishTransition) {
  $element = renderer_default($element);
  let originalTransition;
  const stylesConfig = {
    left: 0,
    top: 0,
    transform: "none"
  };
  if (finishTransition) {
    originalTransition = $element.css("transition");
    stylesConfig.transition = "none";
  }
  $element.css(stylesConfig);
  clearCache($element);
  if (finishTransition) {
    $element.get(0).offsetHeight;
    $element.css("transition", originalTransition);
  }
};
var parseTranslate = function(translateString) {
  let result2 = translateString.match(TRANSLATE_REGEX);
  if (!result2 || !result2[1]) {
    return;
  }
  result2 = result2[1].split(",");
  result2 = {
    x: parseFloat(result2[0]),
    y: parseFloat(result2[1]),
    z: parseFloat(result2[2])
  };
  return result2;
};

// ../../../../../../node_modules/devextreme/esm/animation/easing.js
var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/;
var TransitionTimingFuncMap = {
  linear: "cubic-bezier(0, 0, 1, 1)",
  swing: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
  ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
  "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
  "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
};
var polynomBezier = function(x1, y1, x2, y2) {
  const Cx = 3 * x1;
  const Bx = 3 * (x2 - x1) - Cx;
  const Ax = 1 - Cx - Bx;
  const Cy = 3 * y1;
  const By = 3 * (y2 - y1) - Cy;
  const Ay = 1 - Cy - By;
  const bezierX = function(t) {
    return t * (Cx + t * (Bx + t * Ax));
  };
  const derivativeX = function(t) {
    return Cx + t * (2 * Bx + 3 * t * Ax);
  };
  return function(t) {
    return function(t2) {
      return t2 * (Cy + t2 * (By + t2 * Ay));
    }(function(t2) {
      let x = t2;
      let i = 0;
      let z;
      while (i < 14) {
        z = bezierX(x) - t2;
        if (Math.abs(z) < 1e-3) {
          break;
        }
        x -= z / derivativeX(x);
        i++;
      }
      return x;
    }(t));
  };
};
var easing = {};
var convertTransitionTimingFuncToEasing = function(cssTransitionEasing) {
  cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
  let coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
  let forceName;
  if (!coeffs) {
    forceName = "linear";
    coeffs = TransitionTimingFuncMap[forceName].match(CSS_TRANSITION_EASING_REGEX);
  }
  coeffs = coeffs.slice(1, 5);
  for (let i = 0; i < coeffs.length; i++) {
    coeffs[i] = parseFloat(coeffs[i]);
  }
  const easingName = forceName || "cubicbezier_" + coeffs.join("_").replace(/\./g, "p");
  if (!isFunction(easing[easingName])) {
    easing[easingName] = function(x, t, b, c, d) {
      return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b;
    };
  }
  return easingName;
};
function getEasing(name2) {
  return easing[name2];
}

// ../../../../../../node_modules/devextreme/esm/animation/frame.js
var window11 = hasWindow() ? getWindow() : {};
var FRAME_ANIMATION_STEP_TIME = 1e3 / 60;
var request = function(callback) {
  return setTimeout(callback, 16.666666666666668);
};
var cancel = function(requestID) {
  clearTimeout(requestID);
};
var setAnimationFrameMethods = call_once_default(function() {
  const nativeRequest = window11.requestAnimationFrame || window11.webkitRequestAnimationFrame || window11.mozRequestAnimationFrame || window11.oRequestAnimationFrame || window11.msRequestAnimationFrame;
  const nativeCancel = window11.cancelAnimationFrame || window11.webkitCancelAnimationFrame || window11.mozCancelAnimationFrame || window11.oCancelAnimationFrame || window11.msCancelAnimationFrame;
  if (nativeRequest && nativeCancel) {
    request = nativeRequest;
    cancel = nativeCancel;
  }
});
function requestAnimationFrame() {
  setAnimationFrameMethods();
  return request.apply(window11, arguments);
}
function cancelAnimationFrame() {
  setAnimationFrameMethods();
  cancel.apply(window11, arguments);
}

// ../../../../../../node_modules/devextreme/esm/core/utils/support.js
var support_exports = {};
__export(support_exports, {
  animation: () => animation,
  inputType: () => inputType,
  nativeScrolling: () => nativeScrolling,
  pointerEvents: () => pointerEvents,
  styleProp: () => styleProp,
  stylePropPrefix: () => stylePropPrefix,
  supportProp: () => supportProp,
  touch: () => touch,
  touchEvents: () => touchEvents,
  transition: () => transition,
  transitionEndEventName: () => transitionEndEventName
});
var {
  maxTouchPoints
} = getNavigator();
var transitionEndEventNames = {
  webkitTransition: "webkitTransitionEnd",
  MozTransition: "transitionend",
  OTransition: "oTransitionEnd",
  transition: "transitionend"
};
var supportProp = function(prop) {
  return !!styleProp(prop);
};
var isNativeScrollingSupported = function() {
  const {
    platform,
    mac: isMac
  } = devices_default.real();
  const isNativeScrollDevice = "ios" === platform || "android" === platform || isMac;
  return isNativeScrollDevice;
};
var inputType = function(type2) {
  if ("text" === type2) {
    return true;
  }
  const input = dom_adapter_default.createElement("input");
  try {
    input.setAttribute("type", type2);
    input.value = "wrongValue";
    return !input.value;
  } catch (e) {
    return false;
  }
};
var detectTouchEvents = function(hasWindowProperty, maxTouchPoints2) {
  return (hasWindowProperty("ontouchstart") || !!maxTouchPoints2) && !hasWindowProperty("callPhantom");
};
var detectPointerEvent = function(hasWindowProperty) {
  return hasWindowProperty("PointerEvent");
};
var touchEvents = detectTouchEvents(hasProperty, maxTouchPoints);
var pointerEvents = detectPointerEvent(hasProperty);
var touchPointersPresent = !!maxTouchPoints;
var touch = touchEvents || pointerEvents && touchPointersPresent;
var transition = call_once_default(function() {
  return supportProp("transition");
});
var transitionEndEventName = call_once_default(function() {
  return transitionEndEventNames[styleProp("transition")];
});
var animation = call_once_default(function() {
  return supportProp("animation");
});
var nativeScrolling = isNativeScrollingSupported();

// ../../../../../../node_modules/devextreme/esm/core/utils/browser.js
var navigator = getNavigator();
var webkitRegExp = /(webkit)[ /]([\w.]+)/;
var mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
var browserFromUA = (ua) => {
  ua = ua.toLowerCase();
  const result2 = {};
  const matches = webkitRegExp.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || [];
  let browserName = matches[1];
  let browserVersion = matches[2];
  if ("webkit" === browserName) {
    result2.webkit = true;
    if (ua.indexOf("chrome") >= 0 || ua.indexOf("crios") >= 0) {
      browserName = "chrome";
      browserVersion = /(?:chrome|crios)\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf("fxios") >= 0) {
      browserName = "mozilla";
      browserVersion = /fxios\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf("safari") >= 0 && /version|phantomjs/.test(ua)) {
      browserName = "safari";
      browserVersion = /(?:version|phantomjs)\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else {
      browserName = "unknown";
      browserVersion = /applewebkit\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    }
  }
  if (browserName) {
    result2[browserName] = true;
    result2.version = browserVersion;
  }
  return result2;
};
var browser_default = extend({
  _fromUA: browserFromUA
}, browserFromUA(navigator.userAgent));

// ../../../../../../node_modules/devextreme/esm/animation/position.js
var window12 = getWindow();
var horzRe = /left|right/;
var vertRe = /top|bottom/;
var collisionRe = /fit|flip|none/;
var scaleRe = /scale\(.+?\)/;
var IS_SAFARI = browser_default.safari;
var normalizeAlign = function(raw) {
  const result2 = {
    h: "center",
    v: "center"
  };
  const pair = splitPair(raw);
  if (pair) {
    each(pair, function() {
      const w = String(this).toLowerCase();
      if (horzRe.test(w)) {
        result2.h = w;
      } else if (vertRe.test(w)) {
        result2.v = w;
      }
    });
  }
  return result2;
};
var normalizeOffset = function(raw, preventRound) {
  return pairToObject(raw, preventRound);
};
var normalizeCollision = function(raw) {
  const pair = splitPair(raw);
  let h2 = String(pair && pair[0]).toLowerCase();
  let v = String(pair && pair[1]).toLowerCase();
  if (!collisionRe.test(h2)) {
    h2 = "none";
  }
  if (!collisionRe.test(v)) {
    v = h2;
  }
  return {
    h: h2,
    v
  };
};
var getAlignFactor = function(align) {
  switch (align) {
    case "center":
      return 0.5;
    case "right":
    case "bottom":
      return 1;
    default:
      return 0;
  }
};
var inverseAlign = function(align) {
  switch (align) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    default:
      return align;
  }
};
var calculateOversize = function(data2, bounds) {
  let oversize = 0;
  if (data2.myLocation < bounds.min) {
    oversize += bounds.min - data2.myLocation;
  }
  if (data2.myLocation > bounds.max) {
    oversize += data2.myLocation - bounds.max;
  }
  return oversize;
};
var collisionSide = function(direction, data2, bounds) {
  if (data2.myLocation < bounds.min) {
    return "h" === direction ? "left" : "top";
  }
  if (data2.myLocation > bounds.max) {
    return "h" === direction ? "right" : "bottom";
  }
  return "none";
};
var initMyLocation = function(data2) {
  data2.myLocation = data2.atLocation + getAlignFactor(data2.atAlign) * data2.atSize - getAlignFactor(data2.myAlign) * data2.mySize + data2.offset;
};
var collisionResolvers = {
  fit: function(data2, bounds) {
    let result2 = false;
    if (data2.myLocation > bounds.max) {
      data2.myLocation = bounds.max;
      result2 = true;
    }
    if (data2.myLocation < bounds.min) {
      data2.myLocation = bounds.min;
      result2 = true;
    }
    data2.fit = result2;
  },
  flip: function(data2, bounds) {
    data2.flip = false;
    if ("center" === data2.myAlign && "center" === data2.atAlign) {
      return;
    }
    if (data2.myLocation < bounds.min || data2.myLocation > bounds.max) {
      const inverseData = extend({}, data2, {
        myAlign: inverseAlign(data2.myAlign),
        atAlign: inverseAlign(data2.atAlign),
        offset: -data2.offset
      });
      initMyLocation(inverseData);
      inverseData.oversize = calculateOversize(inverseData, bounds);
      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data2.oversize > inverseData.oversize) {
        data2.myLocation = inverseData.myLocation;
        data2.oversize = inverseData.oversize;
        data2.flip = true;
      }
    }
  },
  flipfit: function(data2, bounds) {
    this.flip(data2, bounds);
    this.fit(data2, bounds);
  },
  none: function(data2) {
    data2.oversize = 0;
  }
};
var scrollbarWidth;
var calculateScrollbarWidth = function() {
  const $scrollDiv = renderer_default("<div>").css({
    width: 100,
    height: 100,
    overflow: "scroll",
    position: "absolute",
    top: -9999
  }).appendTo(renderer_default("body"));
  const result2 = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
  $scrollDiv.remove();
  scrollbarWidth = result2;
};
var defaultPositionResult = {
  h: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  },
  v: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  }
};
var calculatePosition = function(what, options2) {
  const $what = renderer_default(what);
  const currentOffset = $what.offset();
  const result2 = extend(true, {}, defaultPositionResult, {
    h: {
      location: currentOffset.left
    },
    v: {
      location: currentOffset.top
    }
  });
  if (!options2) {
    return result2;
  }
  const my = normalizeAlign(options2.my);
  const at = normalizeAlign(options2.at);
  let of = renderer_default(options2.of).length && options2.of || window12;
  const offset2 = normalizeOffset(options2.offset, options2.precise);
  const collision = normalizeCollision(options2.collision);
  const boundary = options2.boundary;
  const boundaryOffset = normalizeOffset(options2.boundaryOffset, options2.precise);
  const h2 = {
    mySize: getOuterWidth($what),
    myAlign: my.h,
    atAlign: at.h,
    offset: offset2.h,
    collision: collision.h,
    boundaryOffset: boundaryOffset.h
  };
  const v = {
    mySize: getOuterHeight($what),
    myAlign: my.v,
    atAlign: at.v,
    offset: offset2.v,
    collision: collision.v,
    boundaryOffset: boundaryOffset.v
  };
  if (of.preventDefault) {
    h2.atLocation = of.pageX;
    v.atLocation = of.pageY;
    h2.atSize = 0;
    v.atSize = 0;
  } else {
    of = renderer_default(of);
    if (isWindow(of[0])) {
      h2.atLocation = of.scrollLeft();
      v.atLocation = of.scrollTop();
      if ("phone" === devices_default.real().deviceType && of[0].visualViewport) {
        h2.atLocation = Math.max(h2.atLocation, of[0].visualViewport.offsetLeft);
        v.atLocation = Math.max(v.atLocation, of[0].visualViewport.offsetTop);
        h2.atSize = of[0].visualViewport.width;
        v.atSize = of[0].visualViewport.height;
      } else {
        h2.atSize = of[0].innerWidth > of[0].outerWidth ? of[0].innerWidth : getWidth(of);
        v.atSize = of[0].innerHeight > of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : getHeight(of);
      }
    } else if (9 === of[0].nodeType) {
      h2.atLocation = 0;
      v.atLocation = 0;
      h2.atSize = getWidth(of);
      v.atSize = getHeight(of);
    } else {
      const ofRect = getBoundingRect(of.get(0));
      const o = getOffsetWithoutScale(of);
      h2.atLocation = o.left;
      v.atLocation = o.top;
      h2.atSize = Math.max(ofRect.width, getOuterWidth(of));
      v.atSize = Math.max(ofRect.height, getOuterHeight(of));
    }
  }
  initMyLocation(h2);
  initMyLocation(v);
  const bounds = function() {
    const win = renderer_default(window12);
    const windowWidth = getWidth(win);
    const windowHeight = getHeight(win);
    let left = win.scrollLeft();
    let top = win.scrollTop();
    const documentElement = dom_adapter_default.getDocumentElement();
    const hZoomLevel = touch ? documentElement.clientWidth / windowWidth : 1;
    const vZoomLevel = touch ? documentElement.clientHeight / windowHeight : 1;
    if (void 0 === scrollbarWidth) {
      calculateScrollbarWidth();
    }
    let boundaryWidth = windowWidth;
    let boundaryHeight = windowHeight;
    if (boundary && !isWindow(boundary)) {
      const $boundary = renderer_default(boundary);
      const boundaryPosition = $boundary.offset();
      left = boundaryPosition.left;
      top = boundaryPosition.top;
      boundaryWidth = getWidth($boundary);
      boundaryHeight = getHeight($boundary);
    }
    return {
      h: {
        min: left + h2.boundaryOffset,
        max: left + boundaryWidth / hZoomLevel - h2.mySize - h2.boundaryOffset
      },
      v: {
        min: top + v.boundaryOffset,
        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
      }
    };
  }();
  h2.oversize = calculateOversize(h2, bounds.h);
  v.oversize = calculateOversize(v, bounds.v);
  h2.collisionSide = collisionSide("h", h2, bounds.h);
  v.collisionSide = collisionSide("v", v, bounds.v);
  if (collisionResolvers[h2.collision]) {
    collisionResolvers[h2.collision](h2, bounds.h);
  }
  if (collisionResolvers[v.collision]) {
    collisionResolvers[v.collision](v, bounds.v);
  }
  const preciser = function(number) {
    return options2.precise ? number : Math.round(number);
  };
  extend(true, result2, {
    h: {
      location: preciser(h2.myLocation),
      oversize: preciser(h2.oversize),
      fit: h2.fit,
      flip: h2.flip,
      collisionSide: h2.collisionSide
    },
    v: {
      location: preciser(v.myLocation),
      oversize: preciser(v.oversize),
      fit: v.fit,
      flip: v.flip,
      collisionSide: v.collisionSide
    },
    precise: options2.precise
  });
  return result2;
};
var setScaleProperty = function(element, scale, styleAttr, isEmpty2) {
  const stylePropIsValid = isDefined(element.style) && !dom_adapter_default.isNode(element.style);
  const newStyleValue = isEmpty2 ? styleAttr.replace(scale, "") : styleAttr;
  if (stylePropIsValid) {
    setStyle(element, newStyleValue, false);
  } else {
    const styleAttributeNode = dom_adapter_default.createAttribute("style");
    styleAttributeNode.value = newStyleValue;
    element.setAttributeNode(styleAttributeNode);
  }
};
var getOffsetWithoutScale = function($startElement) {
  var _currentElement$getAt, _style$match;
  let $currentElement = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : $startElement;
  const currentElement = $currentElement.get(0);
  if (!currentElement) {
    return $startElement.offset();
  }
  const style = (null === (_currentElement$getAt = currentElement.getAttribute) || void 0 === _currentElement$getAt ? void 0 : _currentElement$getAt.call(currentElement, "style")) || "";
  const scale = null === (_style$match = style.match(scaleRe)) || void 0 === _style$match ? void 0 : _style$match[0];
  let offset2;
  if (scale) {
    setScaleProperty(currentElement, scale, style, true);
    offset2 = getOffsetWithoutScale($startElement, $currentElement.parent());
    setScaleProperty(currentElement, scale, style, false);
  } else {
    offset2 = getOffsetWithoutScale($startElement, $currentElement.parent());
  }
  return offset2;
};
var position = function(what, options2) {
  const $what = renderer_default(what);
  if (!options2) {
    return $what.offset();
  }
  resetPosition($what, true);
  const offset2 = getOffsetWithoutScale($what);
  const targetPosition = options2.h && options2.v ? options2 : calculatePosition($what, options2);
  const preciser = function(number) {
    return options2.precise ? number : Math.round(number);
  };
  move($what, {
    left: targetPosition.h.location - preciser(offset2.left),
    top: targetPosition.v.location - preciser(offset2.top)
  });
  return targetPosition;
};
var offset = function(element) {
  element = renderer_default(element).get(0);
  if (isWindow(element)) {
    return null;
  } else if (element && "pageY" in element && "pageX" in element) {
    return {
      top: element.pageY,
      left: element.pageX
    };
  }
  return renderer_default(element).offset();
};
if (!position.inverseAlign) {
  position.inverseAlign = inverseAlign;
}
if (!position.normalizeAlign) {
  position.normalizeAlign = normalizeAlign;
}
var position_default = {
  calculateScrollbarWidth,
  calculate: calculatePosition,
  setup: position,
  offset
};

// ../../../../../../node_modules/devextreme/esm/events/utils/add_namespace.js
var addNamespace = (eventNames, namespace) => {
  if (!namespace) {
    throw errors_default.Error("E0017");
  }
  if (Array.isArray(eventNames)) {
    return eventNames.map((eventName) => addNamespace(eventName, namespace)).join(" ");
  }
  if (-1 !== eventNames.indexOf(" ")) {
    return addNamespace(eventNames.split(/\s+/g), namespace);
  }
  return `${eventNames}.${namespace}`;
};
var add_namespace_default = addNamespace;

// ../../../../../../node_modules/devextreme/esm/ui/widget/selectors.js
var focusableFn = function(element, tabIndex) {
  if (!visible(element)) {
    return false;
  }
  const nodeName = element.nodeName.toLowerCase();
  const isTabIndexNotNaN = !isNaN(tabIndex);
  const isDisabled = element.disabled;
  const isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName);
  const isHyperlink = "a" === nodeName;
  let isFocusable;
  const isContentEditable = element.isContentEditable;
  if (isDefaultFocus || isContentEditable) {
    isFocusable = !isDisabled;
  } else if (isHyperlink) {
    isFocusable = element.href || isTabIndexNotNaN;
  } else {
    isFocusable = isTabIndexNotNaN;
  }
  return isFocusable;
};
function visible(element) {
  const $element = renderer_default(element);
  return $element.is(":visible") && "hidden" !== $element.css("visibility") && "hidden" !== $element.parents().css("visibility");
}
var focusable = function(index2, element) {
  return focusableFn(element, renderer_default(element).attr("tabIndex"));
};
var tabbable = function(index2, element) {
  const tabIndex = renderer_default(element).attr("tabIndex");
  return (isNaN(tabIndex) || tabIndex >= 0) && focusableFn(element, tabIndex);
};
var focused = function($element) {
  const element = renderer_default($element).get(0);
  return dom_adapter_default.getActiveElement(element) === element;
};

// ../../../../../../node_modules/devextreme/esm/events/utils/index.js
var KEY_MAP = {
  backspace: "backspace",
  tab: "tab",
  enter: "enter",
  escape: "escape",
  pageup: "pageUp",
  pagedown: "pageDown",
  end: "end",
  home: "home",
  arrowleft: "leftArrow",
  arrowup: "upArrow",
  arrowright: "rightArrow",
  arrowdown: "downArrow",
  delete: "del",
  " ": "space",
  f: "F",
  a: "A",
  "*": "asterisk",
  "-": "minus",
  alt: "alt",
  control: "control",
  shift: "shift"
};
var LEGACY_KEY_CODES = {
  8: "backspace",
  9: "tab",
  13: "enter",
  27: "escape",
  33: "pageUp",
  34: "pageDown",
  35: "end",
  36: "home",
  37: "leftArrow",
  38: "upArrow",
  39: "rightArrow",
  40: "downArrow",
  46: "del",
  32: "space",
  70: "F",
  65: "A",
  106: "asterisk",
  109: "minus",
  189: "minus",
  173: "minus",
  16: "shift",
  17: "control",
  18: "alt"
};
var EVENT_SOURCES_REGEX = {
  dx: /^dx/i,
  mouse: /(mouse|wheel)/i,
  touch: /^touch/i,
  keyboard: /^key/i,
  pointer: /^(ms)?pointer/i
};
var fixMethod = (e) => e;
var copyEvent = (originalEvent) => fixMethod(events_engine_default.Event(originalEvent, originalEvent), originalEvent);
var isDxEvent = (e) => "dx" === eventSource(e);
var isNativeMouseEvent = (e) => "mouse" === eventSource(e);
var isNativeTouchEvent = (e) => "touch" === eventSource(e);
var eventSource = (_ref) => {
  let {
    type: type2
  } = _ref;
  let result2 = "other";
  each(EVENT_SOURCES_REGEX, function(key) {
    if (this.test(type2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
};
var isPointerEvent = (e) => "pointer" === eventSource(e);
var isMouseEvent = (e) => isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "mouse" === e.pointerType;
var isDxMouseWheelEvent = (e) => e && "dxmousewheel" === e.type;
var isTouchEvent = (e) => isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "touch" === e.pointerType;
var isFakeClickEvent = (_ref2) => {
  let {
    screenX,
    offsetX,
    pageX
  } = _ref2;
  return 0 === screenX && !offsetX && 0 === pageX;
};
var eventData = (_ref3) => {
  let {
    pageX,
    pageY,
    timeStamp
  } = _ref3;
  return {
    x: pageX,
    y: pageY,
    time: timeStamp
  };
};
var eventDelta = (from, to) => ({
  x: to.x - from.x,
  y: to.y - from.y,
  time: to.time - from.time || 1
});
var hasTouches = (e) => {
  const {
    originalEvent,
    pointers
  } = e;
  if (isNativeTouchEvent(e)) {
    return (originalEvent.touches || []).length;
  }
  if (isDxEvent(e)) {
    return (pointers || []).length;
  }
  return 0;
};
var skipEvents = false;
var needSkipEvent = (e) => {
  if (skipEvents) {
    return true;
  }
  const {
    target
  } = e;
  const $target = renderer_default(target);
  const isContentEditable = (null === target || void 0 === target ? void 0 : target.isContentEditable) || (null === target || void 0 === target ? void 0 : target.hasAttribute("contenteditable"));
  const touchInEditable = $target.is("input, textarea, select") || isContentEditable;
  if (isDxMouseWheelEvent(e)) {
    const isTextArea = $target.is("textarea") && $target.hasClass("dx-texteditor-input");
    if (isTextArea || isContentEditable) {
      return false;
    }
    const isInputFocused = $target.is("input[type='number'], textarea, select") && $target.is(":focus");
    return isInputFocused;
  }
  if (isMouseEvent(e)) {
    return touchInEditable || e.which > 1;
  }
  if (isTouchEvent(e)) {
    return touchInEditable && focused($target);
  }
};
var createEvent = (originalEvent, args) => {
  const event = copyEvent(originalEvent);
  args && extend(event, args);
  return event;
};
var fireEvent = (props) => {
  const {
    originalEvent,
    delegateTarget
  } = props;
  const event = createEvent(originalEvent, props);
  events_engine_default.trigger(delegateTarget || event.target, event);
  return event;
};
var normalizeKeyName = (_ref4) => {
  let {
    key,
    which
  } = _ref4;
  const normalizedKey = KEY_MAP[null === key || void 0 === key ? void 0 : key.toLowerCase()] || key;
  const normalizedKeyFromWhich = LEGACY_KEY_CODES[which];
  if (normalizedKeyFromWhich && normalizedKey === key) {
    return normalizedKeyFromWhich;
  } else if (!normalizedKey && which) {
    return String.fromCharCode(which);
  }
  return normalizedKey;
};
var getChar = (_ref5) => {
  let {
    key,
    which
  } = _ref5;
  return key || String.fromCharCode(which);
};
var addNamespace2 = add_namespace_default;
var isCommandKeyPressed = (_ref6) => {
  let {
    ctrlKey,
    metaKey
  } = _ref6;
  return ctrlKey || metaKey;
};

// ../../../../../../node_modules/devextreme/esm/animation/fx.js
var window13 = getWindow();
var removeEventName = addNamespace2(removeEvent, "dxFX");
var RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;
var ANIM_DATA_KEY = "dxAnimData";
var ANIM_QUEUE_KEY = "dxAnimQueue";
var TransitionAnimationStrategy = {
  initAnimation: function($element, config3) {
    $element.css({
      transitionProperty: "none"
    });
    if ("string" === typeof config3.from) {
      $element.addClass(config3.from);
    } else {
      setProps($element, config3.from);
    }
    const that = this;
    const deferred = new Deferred();
    const cleanupWhen = config3.cleanupWhen;
    config3.transitionAnimation = {
      deferred,
      finish: function() {
        that._finishTransition($element);
        if (cleanupWhen) {
          when(deferred, cleanupWhen).always(function() {
            that._cleanup($element, config3);
          });
        } else {
          that._cleanup($element, config3);
        }
        deferred.resolveWith($element, [config3, $element]);
      }
    };
    this._completeAnimationCallback($element, config3).done(function() {
      config3.transitionAnimation.finish();
    }).fail(function() {
      deferred.rejectWith($element, [config3, $element]);
    });
    if (!config3.duration) {
      config3.transitionAnimation.finish();
    }
    $element.css("transform");
  },
  animate: function($element, config3) {
    this._startAnimation($element, config3);
    return config3.transitionAnimation.deferred.promise();
  },
  _completeAnimationCallback: function($element, config3) {
    const that = this;
    const startTime = Date.now() + config3.delay;
    const deferred = new Deferred();
    const transitionEndFired = new Deferred();
    const simulatedTransitionEndFired = new Deferred();
    let simulatedEndEventTimer;
    const transitionEndEventFullName = transitionEndEventName() + ".dxFX";
    config3.transitionAnimation.cleanup = function() {
      clearTimeout(simulatedEndEventTimer);
      clearTimeout(waitForJSCompleteTimer);
      events_engine_default.off($element, transitionEndEventFullName);
      events_engine_default.off($element, removeEventName);
    };
    events_engine_default.one($element, transitionEndEventFullName, function() {
      if (Date.now() - startTime >= config3.duration) {
        transitionEndFired.reject();
      }
    });
    events_engine_default.off($element, removeEventName);
    events_engine_default.on($element, removeEventName, function() {
      that.stop($element, config3);
      deferred.reject();
    });
    const waitForJSCompleteTimer = setTimeout(function() {
      simulatedEndEventTimer = setTimeout(function() {
        simulatedTransitionEndFired.reject();
      }, config3.duration + config3.delay + fx._simulatedTransitionEndDelay);
      when(transitionEndFired, simulatedTransitionEndFired).fail((function() {
        deferred.resolve();
      }).bind(this));
    });
    return deferred.promise();
  },
  _startAnimation: function($element, config3) {
    $element.css({
      transitionProperty: "all",
      transitionDelay: config3.delay + "ms",
      transitionDuration: config3.duration + "ms",
      transitionTimingFunction: config3.easing
    });
    if ("string" === typeof config3.to) {
      $element[0].className += " " + config3.to;
    } else if (config3.to) {
      setProps($element, config3.to);
    }
  },
  _finishTransition: function($element) {
    $element.css("transition", "none");
  },
  _cleanup: function($element, config3) {
    config3.transitionAnimation.cleanup();
    if ("string" === typeof config3.from) {
      $element.removeClass(config3.from);
      $element.removeClass(config3.to);
    }
  },
  stop: function($element, config3, jumpToEnd) {
    if (!config3) {
      return;
    }
    if (jumpToEnd) {
      config3.transitionAnimation.finish();
    } else {
      if (isPlainObject(config3.to)) {
        each(config3.to, function(key) {
          $element.css(key, $element.css(key));
        });
      }
      this._finishTransition($element);
      this._cleanup($element, config3);
    }
  }
};
var FrameAnimationStrategy = {
  initAnimation: function($element, config3) {
    setProps($element, config3.from);
  },
  animate: function($element, config3) {
    const deferred = new Deferred();
    const that = this;
    if (!config3) {
      return deferred.reject().promise();
    }
    each(config3.to, function(prop) {
      if (void 0 === config3.from[prop]) {
        config3.from[prop] = that._normalizeValue($element.css(prop));
      }
    });
    if (config3.to.transform) {
      config3.from.transform = that._parseTransform(config3.from.transform);
      config3.to.transform = that._parseTransform(config3.to.transform);
    }
    config3.frameAnimation = {
      to: config3.to,
      from: config3.from,
      currentValue: config3.from,
      easing: convertTransitionTimingFuncToEasing(config3.easing),
      duration: config3.duration,
      startTime: (/* @__PURE__ */ new Date()).valueOf(),
      finish: function() {
        this.currentValue = this.to;
        this.draw();
        cancelAnimationFrame(config3.frameAnimation.animationFrameId);
        deferred.resolve();
      },
      draw: function() {
        if (config3.draw) {
          config3.draw(this.currentValue);
          return;
        }
        const currentValue = extend({}, this.currentValue);
        if (currentValue.transform) {
          currentValue.transform = map(currentValue.transform, function(value2, prop) {
            if ("translate" === prop) {
              return getTranslateCss(value2);
            } else if ("scale" === prop) {
              return "scale(" + value2 + ")";
            } else if ("rotate" === prop.substr(0, prop.length - 1)) {
              return prop + "(" + value2 + "deg)";
            }
          }).join(" ");
        }
        $element.css(currentValue);
      }
    };
    if (config3.delay) {
      config3.frameAnimation.startTime += config3.delay;
      config3.frameAnimation.delayTimeout = setTimeout(function() {
        that._startAnimation($element, config3);
      }, config3.delay);
    } else {
      that._startAnimation($element, config3);
    }
    return deferred.promise();
  },
  _startAnimation: function($element, config3) {
    events_engine_default.off($element, removeEventName);
    events_engine_default.on($element, removeEventName, function() {
      if (config3.frameAnimation) {
        cancelAnimationFrame(config3.frameAnimation.animationFrameId);
      }
    });
    this._animationStep($element, config3);
  },
  _parseTransform: function(transformString) {
    const result2 = {};
    each(transformString.match(/\w+\d*\w*\([^)]*\)\s*/g), function(i, part) {
      const translateData = parseTranslate(part);
      const scaleData = part.match(/scale\((.+?)\)/);
      const rotateData = part.match(/(rotate.)\((.+)deg\)/);
      if (translateData) {
        result2.translate = translateData;
      }
      if (scaleData && scaleData[1]) {
        result2.scale = parseFloat(scaleData[1]);
      }
      if (rotateData && rotateData[1]) {
        result2[rotateData[1]] = parseFloat(rotateData[2]);
      }
    });
    return result2;
  },
  stop: function($element, config3, jumpToEnd) {
    const frameAnimation = config3 && config3.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    cancelAnimationFrame(frameAnimation.animationFrameId);
    clearTimeout(frameAnimation.delayTimeout);
    if (jumpToEnd) {
      frameAnimation.finish();
    }
    delete config3.frameAnimation;
  },
  _animationStep: function($element, config3) {
    const frameAnimation = config3 && config3.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    const now = (/* @__PURE__ */ new Date()).valueOf();
    if (now >= frameAnimation.startTime + frameAnimation.duration) {
      frameAnimation.finish();
      return;
    }
    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
    frameAnimation.draw();
    const that = this;
    frameAnimation.animationFrameId = requestAnimationFrame(function() {
      that._animationStep($element, config3);
    });
  },
  _calcStepValue: function(frameAnimation, currentDuration) {
    const calcValueRecursively = function(from, to) {
      const result2 = Array.isArray(to) ? [] : {};
      each(to, function(propName, endPropValue) {
        if ("string" === typeof endPropValue && false === parseFloat(endPropValue)) {
          return true;
        }
        result2[propName] = "object" === typeof endPropValue ? calcValueRecursively(from[propName], endPropValue) : function(propName2) {
          const x = currentDuration / frameAnimation.duration;
          const t = currentDuration;
          const b = 1 * from[propName2];
          const c = to[propName2] - from[propName2];
          const d = frameAnimation.duration;
          return getEasing(frameAnimation.easing)(x, t, b, c, d);
        }(propName);
      });
      return result2;
    };
    return calcValueRecursively(frameAnimation.from, frameAnimation.to);
  },
  _normalizeValue: function(value2) {
    const numericValue = parseFloat(value2);
    if (false === numericValue) {
      return value2;
    }
    return numericValue;
  }
};
var FallbackToNoAnimationStrategy = {
  initAnimation: function() {
  },
  animate: function() {
    return new Deferred().resolve().promise();
  },
  stop: noop2,
  isSynchronous: true
};
var getAnimationStrategy = function(config3) {
  config3 = config3 || {};
  const animationStrategies = {
    transition: transition() ? TransitionAnimationStrategy : FrameAnimationStrategy,
    frame: FrameAnimationStrategy,
    noAnimation: FallbackToNoAnimationStrategy
  };
  let strategy4 = config3.strategy || "transition";
  if ("css" === config3.type && !transition()) {
    strategy4 = "noAnimation";
  }
  return animationStrategies[strategy4];
};
var baseConfigValidator = function(config3, animationType, validate, typeMessage) {
  each(["from", "to"], function() {
    if (!validate(config3[this])) {
      throw errors_default.Error("E0010", animationType, this, typeMessage);
    }
  });
};
var isObjectConfigValidator = function(config3, animationType) {
  return baseConfigValidator(config3, animationType, function(target) {
    return isPlainObject(target);
  }, "a plain object");
};
var isStringConfigValidator = function(config3, animationType) {
  return baseConfigValidator(config3, animationType, function(target) {
    return "string" === typeof target;
  }, "a string");
};
var CustomAnimationConfigurator = {
  setup: function() {
  }
};
var CssAnimationConfigurator = {
  validateConfig: function(config3) {
    isStringConfigValidator(config3, "css");
  },
  setup: function() {
  }
};
var positionAliases = {
  top: {
    my: "bottom center",
    at: "top center"
  },
  bottom: {
    my: "top center",
    at: "bottom center"
  },
  right: {
    my: "left center",
    at: "right center"
  },
  left: {
    my: "right center",
    at: "left center"
  }
};
var SlideAnimationConfigurator = {
  validateConfig: function(config3) {
    isObjectConfigValidator(config3, "slide");
  },
  setup: function($element, config3) {
    const location = locate($element);
    if ("slide" !== config3.type) {
      const positioningConfig = "slideIn" === config3.type ? config3.from : config3.to;
      positioningConfig.position = extend({
        of: window13
      }, positionAliases[config3.direction]);
      setupPosition($element, positioningConfig);
    }
    this._setUpConfig(location, config3.from);
    this._setUpConfig(location, config3.to);
    clearCache($element);
  },
  _setUpConfig: function(location, config3) {
    config3.left = "left" in config3 ? config3.left : "+=0";
    config3.top = "top" in config3 ? config3.top : "+=0";
    this._initNewPosition(location, config3);
  },
  _initNewPosition: function(location, config3) {
    const position3 = {
      left: config3.left,
      top: config3.top
    };
    delete config3.left;
    delete config3.top;
    let relativeValue = this._getRelativeValue(position3.left);
    if (void 0 !== relativeValue) {
      position3.left = relativeValue + location.left;
    } else {
      config3.left = 0;
    }
    relativeValue = this._getRelativeValue(position3.top);
    if (void 0 !== relativeValue) {
      position3.top = relativeValue + location.top;
    } else {
      config3.top = 0;
    }
    config3.transform = getTranslateCss({
      x: position3.left,
      y: position3.top
    });
  },
  _getRelativeValue: function(value2) {
    let relativeValue;
    if ("string" === typeof value2 && (relativeValue = RELATIVE_VALUE_REGEX.exec(value2))) {
      return parseInt(relativeValue[1] + "1") * relativeValue[2];
    }
  }
};
var FadeAnimationConfigurator = {
  setup: function($element, config3) {
    const from = config3.from;
    const to = config3.to;
    const defaultFromOpacity = "fadeOut" === config3.type ? 1 : 0;
    const defaultToOpacity = "fadeOut" === config3.type ? 0 : 1;
    let fromOpacity = isPlainObject(from) ? String(from.opacity ?? defaultFromOpacity) : String(from);
    let toOpacity = isPlainObject(to) ? String(to.opacity ?? defaultToOpacity) : String(to);
    if (!config3.skipElementInitialStyles) {
      fromOpacity = $element.css("opacity");
    }
    switch (config3.type) {
      case "fadeIn":
        toOpacity = 1;
        break;
      case "fadeOut":
        toOpacity = 0;
    }
    config3.from = {
      visibility: "visible",
      opacity: fromOpacity
    };
    config3.to = {
      opacity: toOpacity
    };
  }
};
var PopAnimationConfigurator = {
  validateConfig: function(config3) {
    isObjectConfigValidator(config3, "pop");
  },
  setup: function($element, config3) {
    const from = config3.from;
    const to = config3.to;
    const fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity");
    const toOpacity = "opacity" in to ? to.opacity : 1;
    const fromScale = "scale" in from ? from.scale : 0;
    const toScale = "scale" in to ? to.scale : 1;
    config3.from = {
      opacity: fromOpacity
    };
    const translate = getTranslate($element);
    config3.from.transform = this._getCssTransform(translate, fromScale);
    config3.to = {
      opacity: toOpacity
    };
    config3.to.transform = this._getCssTransform(translate, toScale);
  },
  _getCssTransform: function(translate, scale) {
    return getTranslateCss(translate) + "scale(" + scale + ")";
  }
};
var animationConfigurators = {
  custom: CustomAnimationConfigurator,
  slide: SlideAnimationConfigurator,
  slideIn: SlideAnimationConfigurator,
  slideOut: SlideAnimationConfigurator,
  fade: FadeAnimationConfigurator,
  fadeIn: FadeAnimationConfigurator,
  fadeOut: FadeAnimationConfigurator,
  pop: PopAnimationConfigurator,
  css: CssAnimationConfigurator
};
var getAnimationConfigurator = function(config3) {
  const result2 = animationConfigurators[config3.type];
  if (!result2) {
    throw errors_default.Error("E0011", config3.type);
  }
  return result2;
};
var defaultJSConfig = {
  type: "custom",
  from: {},
  to: {},
  duration: 400,
  start: noop2,
  complete: noop2,
  easing: "ease",
  delay: 0
};
var defaultCssConfig = {
  duration: 400,
  easing: "ease",
  delay: 0
};
function setupAnimationOnElement() {
  const $element = this.element;
  const config3 = this.config;
  setupPosition($element, config3.from);
  setupPosition($element, config3.to);
  this.configurator.setup($element, config3);
  $element.data(ANIM_DATA_KEY, this);
  if (fx.off) {
    config3.duration = 0;
    config3.delay = 0;
  }
  this.strategy.initAnimation($element, config3);
  if (config3.start) {
    const element = getPublicElement($element);
    config3.start.apply(this, [element, config3]);
  }
}
var onElementAnimationComplete = function(animation3) {
  const $element = animation3.element;
  const config3 = animation3.config;
  $element.removeData(ANIM_DATA_KEY);
  if (config3.complete) {
    const element = getPublicElement($element);
    config3.complete.apply(this, [element, config3]);
  }
  animation3.deferred.resolveWith(this, [$element, config3]);
};
var startAnimationOnElement = function() {
  const animation3 = this;
  const $element = animation3.element;
  const config3 = animation3.config;
  animation3.isStarted = true;
  return animation3.strategy.animate($element, config3).done(function() {
    onElementAnimationComplete(animation3);
  }).fail(function() {
    animation3.deferred.rejectWith(this, [$element, config3]);
  });
};
var stopAnimationOnElement = function(jumpToEnd) {
  const animation3 = this;
  const $element = animation3.element;
  const config3 = animation3.config;
  clearTimeout(animation3.startTimeout);
  if (!animation3.isStarted) {
    animation3.start();
  }
  animation3.strategy.stop($element, config3, jumpToEnd);
};
var scopedRemoveEvent = addNamespace2(removeEvent, "dxFXStartAnimation");
var subscribeToRemoveEvent = function(animation3) {
  events_engine_default.off(animation3.element, scopedRemoveEvent);
  events_engine_default.on(animation3.element, scopedRemoveEvent, function() {
    fx.stop(animation3.element);
  });
  animation3.deferred.always(function() {
    events_engine_default.off(animation3.element, scopedRemoveEvent);
  });
};
var createAnimation = function(element, initialConfig) {
  const defaultConfig = "css" === initialConfig.type ? defaultCssConfig : defaultJSConfig;
  const config3 = extend(true, {}, defaultConfig, initialConfig);
  const configurator = getAnimationConfigurator(config3);
  const strategy4 = getAnimationStrategy(config3);
  const animation3 = {
    element: renderer_default(element),
    config: config3,
    configurator,
    strategy: strategy4,
    isSynchronous: strategy4.isSynchronous,
    setup: setupAnimationOnElement,
    start: startAnimationOnElement,
    stop: stopAnimationOnElement,
    deferred: new Deferred()
  };
  if (isFunction(configurator.validateConfig)) {
    configurator.validateConfig(config3);
  }
  subscribeToRemoveEvent(animation3);
  return animation3;
};
var animate = function(element, config3) {
  const $element = renderer_default(element);
  if (!$element.length) {
    return new Deferred().resolve().promise();
  }
  const animation3 = createAnimation($element, config3);
  pushInAnimationQueue($element, animation3);
  return animation3.deferred.promise();
};
function pushInAnimationQueue($element, animation3) {
  const queueData = getAnimQueueData($element);
  writeAnimQueueData($element, queueData);
  queueData.push(animation3);
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
}
function getAnimQueueData($element) {
  return $element.data(ANIM_QUEUE_KEY) || [];
}
function writeAnimQueueData($element, queueData) {
  $element.data(ANIM_QUEUE_KEY, queueData);
}
var destroyAnimQueueData = function($element) {
  $element.removeData(ANIM_QUEUE_KEY);
};
function isAnimating($element) {
  return !!$element.data(ANIM_DATA_KEY);
}
function shiftFromAnimationQueue($element, queueData) {
  queueData = getAnimQueueData($element);
  if (!queueData.length) {
    return;
  }
  const animation3 = queueData.shift();
  if (0 === queueData.length) {
    destroyAnimQueueData($element);
  }
  executeAnimation(animation3).done(function() {
    if (!isAnimating($element)) {
      shiftFromAnimationQueue($element);
    }
  });
}
function executeAnimation(animation3) {
  animation3.setup();
  if (fx.off || animation3.isSynchronous) {
    animation3.start();
  } else {
    animation3.startTimeout = setTimeout(function() {
      animation3.start();
    });
  }
  return animation3.deferred.promise();
}
function setupPosition($element, config3) {
  if (!config3 || !config3.position) {
    return;
  }
  const win = renderer_default(window13);
  let left = 0;
  let top = 0;
  const position3 = position_default.calculate($element, config3.position);
  const offset2 = $element.offset();
  const currentPosition = $element.position();
  if (currentPosition.top > offset2.top) {
    top = win.scrollTop();
  }
  if (currentPosition.left > offset2.left) {
    left = win.scrollLeft();
  }
  extend(config3, {
    left: position3.h.location - offset2.left + currentPosition.left - left,
    top: position3.v.location - offset2.top + currentPosition.top - top
  });
  delete config3.position;
}
function setProps($element, props) {
  each(props, function(key, value2) {
    try {
      $element.css(key, isFunction(value2) ? value2() : value2);
    } catch (e) {
    }
  });
}
var stop = function(element, jumpToEnd) {
  const $element = renderer_default(element);
  const queueData = getAnimQueueData($element);
  each(queueData, function(_, animation4) {
    animation4.config.delay = 0;
    animation4.config.duration = 0;
    animation4.isSynchronous = true;
  });
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
  const animation3 = $element.data(ANIM_DATA_KEY);
  if (animation3) {
    animation3.stop(jumpToEnd);
  }
  $element.removeData(ANIM_DATA_KEY);
  destroyAnimQueueData($element);
};
var fx = {
  off: false,
  animationTypes: animationConfigurators,
  animate,
  createAnimation,
  isAnimating,
  stop,
  _simulatedTransitionEndDelay: 100
};
var fx_default = fx;

// ../../../../../../node_modules/devextreme/esm/ui/themes_callback.js
var themeReadyCallback = callbacks_default();

// ../../../../../../node_modules/devextreme/esm/ui/widget/ui.errors.js
var ui_errors_default = error_default(errors_default.ERROR_MESSAGES, {
  E1001: "Module '{0}'. Controller '{1}' is already registered",
  E1002: "Module '{0}'. Controller '{1}' does not inherit from DevExpress.ui.dxDataGrid.Controller",
  E1003: "Module '{0}'. View '{1}' is already registered",
  E1004: "Module '{0}'. View '{1}' does not inherit from DevExpress.ui.dxDataGrid.View",
  E1005: "Public method '{0}' is already registered",
  E1006: "Public method '{0}.{1}' does not exist",
  E1007: "State storing cannot be provided due to the restrictions of the browser",
  E1010: "The template does not contain the TextBox widget",
  E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',
  E1012: "Editing type '{0}' with the name '{1}' is unsupported",
  E1016: "Unexpected type of data source is provided for a lookup column",
  E1018: "The 'collapseAll' method cannot be called if you use a remote data source",
  E1019: "Search mode '{0}' is unavailable",
  E1020: "The type cannot be changed after initialization",
  E1021: "{0} '{1}' you are trying to remove does not exist",
  E1022: 'The "markers" option is given an invalid value. Assign an array instead',
  E1023: 'The "routes" option is given an invalid value. Assign an array instead',
  E1025: "This layout is too complex to render",
  E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',
  E1031: "Unknown subscription in the Scheduler widget: '{0}'",
  E1032: "Unknown start date in an appointment: '{0}'",
  E1033: "Unknown step in the date navigator: '{0}'",
  E1034: "The browser does not implement an API for saving files",
  E1035: "The editor cannot be created: {0}",
  E1037: "Invalid structure of grouped data",
  E1038: "The browser does not support local storages for local web pages",
  E1039: "A cell's position cannot be calculated",
  E1040: "The '{0}' key value is not unique within the data array",
  E1041: "The '{0}' script is referenced after the DevExtreme scripts or not referenced at all",
  E1042: "{0} requires the key field to be specified",
  E1043: "Changes cannot be processed due to the incorrectly set key",
  E1044: "The key field specified by the keyExpr option does not match the key field specified in the data store",
  E1045: "Editing requires the key field to be specified in the data store",
  E1046: "The '{0}' key field is not found in data objects",
  E1047: 'The "{0}" field is not found in the fields array',
  E1048: 'The "{0}" operation is not found in the filterOperations array',
  E1049: "Column '{0}': filtering is allowed but the 'dataField' or 'name' option is not specified",
  E1050: "The validationRules option does not apply to third-party editors defined in the editCellTemplate",
  E1051: `HtmlEditor's valueType is "{0}", but the {0} converter was not imported.`,
  E1052: '{0} should have the "dataSource" option specified',
  E1053: 'The "buttons" option accepts an array that contains only objects or string values',
  E1054: "All text editor buttons must have names",
  E1055: 'One or several text editor buttons have invalid or non-unique "name" values',
  E1056: 'The {0} widget does not support buttons of the "{1}" type',
  E1058: 'The "startDayHour" and "endDayHour" options must be integers in the [0, 24] range, with "endDayHour" being greater than "startDayHour".',
  E1059: "The following column names are not unique: {0}",
  E1060: "All editable columns must have names",
  E1061: 'The "offset" option must be an integer in the [-1440, 1440] range, divisible by 5 without a remainder.',
  E1062: 'The "cellDuration" must be a positive integer, evenly dividing the ("endDayHour" - "startDayHour") interval into minutes.',
  W1001: 'The "key" option cannot be modified after initialization',
  W1002: "An item with the key '{0}' does not exist",
  W1003: "A group with the key '{0}' in which you are trying to select items does not exist",
  W1004: "The item '{0}' you are trying to select in the group '{1}' does not exist",
  W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.",
  W1006: "The map service returned the following error: '{0}'",
  W1007: "No item with key {0} was found in the data source, but this key was used as the parent key for item {1}",
  W1008: "Cannot scroll to the '{0}' date because it does not exist on the current view",
  W1009: "Searching works only if data is specified using the dataSource option",
  W1010: "The capability to select all items works with source data of plain structure only",
  W1011: 'The "keyExpr" option is not applied when dataSource is not an array',
  W1012: "The '{0}' key field is not found in data objects",
  W1013: 'The "message" field in the dialog component was renamed to "messageHtml". Change your code correspondingly. In addition, if you used HTML code in the message, make sure that it is secure',
  W1014: "The Floating Action Button exceeds the recommended speed dial action count. If you need to display more speed dial actions, increase the maxSpeedDialActionCount option value in the global config.",
  W1016: "The '{0}' field in the HTML Editor toolbar item configuration was renamed to '{1}'. Please make a corresponding change in your code.",
  W1017: "The 'key' property is not specified for a lookup data source. Please specify it to prevent requests for the entire dataset when users filter data.",
  W1018: "Infinite scrolling may not work properly with multiple selection. To use these features together, set 'selection.deferred' to true or set 'selection.selectAllMode' to 'page'.",
  W1019: "Filter query string exceeds maximum length limit of {0} characters.",
  W1020: "hideEvent is ignored when the shading property is true",
  W1021: `The '{0}' is not rendered because none of the DOM elements match the value of the "container" property.`,
  W1022: "{0} JSON parsing error: '{1}'",
  W1023: "Appointments require unique keys. Otherwise, the agenda view may not work correctly.",
  W1024: "The client-side export is enabled. Implement the 'onExporting' function.",
  W1025: "'scrolling.mode' is set to 'virtual' or 'infinite'. Specify the height of the component."
});

// ../../../../../../node_modules/devextreme/esm/ui/themes.js
var window14 = getWindow();
var ready3 = ready_callbacks_default.add;
var viewPort = value;
var viewPortChanged = changeCallback;
var initDeferred = new Deferred();
var DX_LINK_SELECTOR = "link[rel=dx-theme]";
var THEME_ATTR = "data-theme";
var ACTIVE_ATTR = "data-active";
var DX_HAIRLINES_CLASS = "dx-hairlines";
var ANY_THEME = "any";
var context;
var $activeThemeLink;
var knownThemes;
var currentThemeName;
var pendingThemeName;
var defaultTimeout = 15e3;
var THEME_MARKER_PREFIX = "dx.";
function readThemeMarker() {
  if (!hasWindow()) {
    return null;
  }
  const element = renderer_default("<div>", context).addClass("dx-theme-marker").appendTo(context.documentElement);
  let result2;
  try {
    result2 = window14.getComputedStyle(element.get(0)).fontFamily;
    if (!result2) {
      return null;
    }
    result2 = result2.replace(/["']/g, "");
    if (result2.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {
      return null;
    }
    return result2.substr(THEME_MARKER_PREFIX.length);
  } finally {
    element.remove();
  }
}
function waitForThemeLoad(themeName) {
  let waitStartTime;
  let timerId;
  let intervalCleared = true;
  pendingThemeName = themeName;
  function handleLoaded() {
    pendingThemeName = null;
    clearInterval(timerId);
    intervalCleared = true;
    themeReadyCallback.fire();
    themeReadyCallback.empty();
    initDeferred.resolve();
  }
  if (isPendingThemeLoaded() || !defaultTimeout) {
    handleLoaded();
  } else {
    if (!intervalCleared) {
      if (pendingThemeName) {
        pendingThemeName = themeName;
      }
      return;
    }
    waitStartTime = Date.now();
    intervalCleared = false;
    timerId = setInterval(function() {
      const isLoaded = isPendingThemeLoaded();
      const isTimeout = !isLoaded && Date.now() - waitStartTime > defaultTimeout;
      if (isTimeout) {
        ui_errors_default.log("W0004", pendingThemeName);
      }
      if (isLoaded || isTimeout) {
        handleLoaded();
      }
    }, 10);
  }
}
function isPendingThemeLoaded() {
  if (!pendingThemeName) {
    return true;
  }
  const anyThemePending = pendingThemeName === ANY_THEME;
  if ("resolved" === initDeferred.state() && anyThemePending) {
    return true;
  }
  const themeMarker = readThemeMarker();
  if (themeMarker && anyThemePending) {
    return true;
  }
  return themeMarker === pendingThemeName;
}
function processMarkup() {
  const $allThemeLinks = renderer_default(DX_LINK_SELECTOR, context);
  if (!$allThemeLinks.length) {
    return;
  }
  knownThemes = {};
  $activeThemeLink = renderer_default(parseHTML("<link rel=stylesheet>"), context);
  $allThemeLinks.each(function() {
    const link = renderer_default(this, context);
    const fullThemeName = link.attr(THEME_ATTR);
    const url = link.attr("href");
    const isActive = "true" === link.attr(ACTIVE_ATTR);
    knownThemes[fullThemeName] = {
      url,
      isActive
    };
  });
  $allThemeLinks.last().after($activeThemeLink);
  $allThemeLinks.remove();
}
function resolveFullThemeName(desiredThemeName) {
  const desiredThemeParts = desiredThemeName ? desiredThemeName.split(".") : [];
  let result2 = null;
  if (knownThemes) {
    if (desiredThemeName in knownThemes) {
      return desiredThemeName;
    }
    each(knownThemes, function(knownThemeName, themeData) {
      const knownThemeParts = knownThemeName.split(".");
      if (desiredThemeParts[0] && knownThemeParts[0] !== desiredThemeParts[0]) {
        return;
      }
      if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
        return;
      }
      if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
        return;
      }
      if (!result2 || themeData.isActive) {
        result2 = knownThemeName;
      }
      if (themeData.isActive) {
        return false;
      }
    });
  }
  return result2;
}
function initContext(newContext) {
  try {
    if (newContext !== context) {
      knownThemes = null;
    }
  } catch (x) {
    knownThemes = null;
  }
  context = newContext;
}
function init(options2) {
  options2 = options2 || {};
  initContext(options2.context || dom_adapter_default.getDocument());
  if (!context) {
    return;
  }
  processMarkup();
  currentThemeName = void 0;
  current(options2);
}
function current(options2) {
  if (!arguments.length) {
    currentThemeName = currentThemeName || readThemeMarker();
    return currentThemeName;
  }
  detachCssClasses(viewPort());
  options2 = options2 || {};
  if ("string" === typeof options2) {
    options2 = {
      theme: options2
    };
  }
  const isAutoInit = options2._autoInit;
  const loadCallback = options2.loadCallback;
  let currentThemeData;
  currentThemeName = resolveFullThemeName(options2.theme || currentThemeName);
  if (currentThemeName) {
    currentThemeData = knownThemes[currentThemeName];
  }
  if (loadCallback) {
    themeReadyCallback.add(loadCallback);
  }
  if (currentThemeData) {
    $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
    if (themeReadyCallback.has() || "resolved" !== initDeferred.state() || options2._forceTimeout) {
      waitForThemeLoad(currentThemeName);
    }
  } else if (isAutoInit) {
    if (hasWindow()) {
      waitForThemeLoad(ANY_THEME);
    }
    themeReadyCallback.fire();
    themeReadyCallback.empty();
  } else {
    throw ui_errors_default.Error("E0021", currentThemeName);
  }
  initDeferred.done(() => attachCssClasses(originalViewPort(), currentThemeName));
}
function getCssClasses(themeName) {
  themeName = themeName || current();
  const result2 = [];
  const themeNameParts = themeName && themeName.split(".");
  if (themeNameParts) {
    result2.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
    if (themeNameParts.length > 1) {
      result2.push("dx-color-scheme-" + themeNameParts[1] + (isMaterialBased(themeName) ? "-" + themeNameParts[2] : ""));
    }
  }
  return result2;
}
var themeClasses;
function attachCssClasses(element, themeName) {
  themeClasses = getCssClasses(themeName).join(" ");
  renderer_default(element).addClass(themeClasses);
  !function() {
    const pixelRatio = hasWindow() && window14.devicePixelRatio;
    if (!pixelRatio || pixelRatio < 2) {
      return;
    }
    const $tester = renderer_default("<div>");
    $tester.css("border", ".5px solid transparent");
    renderer_default("body").append($tester);
    if (1 === getOuterHeight($tester)) {
      renderer_default(element).addClass(DX_HAIRLINES_CLASS);
      themeClasses += " " + DX_HAIRLINES_CLASS;
    }
    $tester.remove();
  }();
}
function detachCssClasses(element) {
  renderer_default(element).removeClass(themeClasses);
}
function isTheme(themeRegExp, themeName) {
  if (!themeName) {
    themeName = currentThemeName || readThemeMarker();
  }
  return new RegExp(themeRegExp).test(themeName);
}
function isMaterialBased(themeName) {
  return isMaterial(themeName) || isFluent(themeName);
}
function isMaterial(themeName) {
  return isTheme("material", themeName);
}
function isFluent(themeName) {
  return isTheme("fluent", themeName);
}
function isGeneric(themeName) {
  return isTheme("generic", themeName);
}
function isCompact(themeName) {
  return isTheme("compact", themeName);
}
function isWebFontLoaded(text, fontWeight) {
  const document2 = dom_adapter_default.getDocument();
  const testElement = document2.createElement("span");
  testElement.style.position = "absolute";
  testElement.style.top = "-9999px";
  testElement.style.left = "-9999px";
  testElement.style.visibility = "hidden";
  testElement.style.fontFamily = "Arial";
  testElement.style.fontSize = "250px";
  testElement.style.fontWeight = fontWeight;
  testElement.innerHTML = text;
  document2.body.appendChild(testElement);
  const etalonFontWidth = testElement.offsetWidth;
  testElement.style.fontFamily = "Roboto, RobotoFallback, Arial";
  const testedFontWidth = testElement.offsetWidth;
  testElement.parentNode.removeChild(testElement);
  return etalonFontWidth !== testedFontWidth;
}
function waitWebFont(text, fontWeight) {
  return new Promise((resolve) => {
    const clear = () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
      resolve();
    };
    const intervalId = setInterval(() => {
      if (isWebFontLoaded(text, fontWeight)) {
        clear();
      }
    }, 15);
    const timeoutId = setTimeout(clear, 2e3);
  });
}
function autoInit() {
  init({
    _autoInit: true,
    _forceTimeout: true
  });
  if (renderer_default(DX_LINK_SELECTOR, context).length) {
    throw ui_errors_default.Error("E0022");
  }
}
if (hasWindow()) {
  autoInit();
} else {
  ready3(autoInit);
}
viewPortChanged.add(function(viewPort2, prevViewPort) {
  initDeferred.done(function() {
    detachCssClasses(prevViewPort);
    attachCssClasses(viewPort2);
  });
});
devices_default.changed.add(function() {
  init({
    _autoInit: true
  });
});

// ../../../../../../node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.js
var SelectionStrategy = class {
  constructor(options2) {
    this.options = options2;
    this._setOption("disabledItemKeys", []);
    this._clearItemKeys();
  }
  _clearItemKeys() {
    this._setOption("addedItemKeys", []);
    this._setOption("removedItemKeys", []);
    this._setOption("removedItems", []);
    this._setOption("addedItems", []);
  }
  validate() {
  }
  _setOption(name2, value2) {
    this.options[name2] = value2;
  }
  onSelectionChanged() {
    const {
      addedItemKeys
    } = this.options;
    const {
      removedItemKeys
    } = this.options;
    const {
      addedItems
    } = this.options;
    const {
      removedItems
    } = this.options;
    const {
      selectedItems
    } = this.options;
    const {
      selectedItemKeys
    } = this.options;
    const onSelectionChanged = this.options.onSelectionChanged || noop2;
    this._clearItemKeys();
    onSelectionChanged({
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems
    });
  }
  equalKeys(key1, key2) {
    if (this.options.equalByReference) {
      if (isObject(key1) && isObject(key2)) {
        return key1 === key2;
      }
    }
    return equalByValue(key1, key2);
  }
  getSelectableItems(items) {
    return items.filter((item) => !(null !== item && void 0 !== item && item.disabled));
  }
  _clearSelection(keys, preserve, isDeselect, isSelectAll) {
    keys = keys || [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll);
  }
  _removeTemplateProperty(remoteFilter) {
    if (Array.isArray(remoteFilter)) {
      return remoteFilter.map((f) => this._removeTemplateProperty(f));
    }
    if (isObject(remoteFilter)) {
      delete remoteFilter.template;
    }
    return remoteFilter;
  }
  _loadFilteredData(remoteFilter, localFilter, select, isSelectAll) {
    const filterLength = encodeURI(JSON.stringify(this._removeTemplateProperty(remoteFilter))).length;
    const needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest;
    const deferred = Deferred();
    const loadOptions = {
      filter: needLoadAllData ? void 0 : remoteFilter,
      select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
    };
    if (remoteFilter && 0 === remoteFilter.length) {
      deferred.resolve([]);
    } else {
      this.options.load(loadOptions).done((items) => {
        let filteredItems = isPlainObject(items) ? items.data : items;
        if (localFilter && !isSelectAll) {
          filteredItems = filteredItems.filter(localFilter);
        } else if (needLoadAllData) {
          filteredItems = query_default(filteredItems).filter(remoteFilter).toArray();
        }
        deferred.resolve(filteredItems);
      }).fail(deferred.reject.bind(deferred));
    }
    return deferred;
  }
  updateSelectedItemKeyHash(keys) {
    for (let i = 0; i < keys.length; i++) {
      const keyHash = getKeyHash(keys[i]);
      if (!isObject(keyHash)) {
        this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
        const keyIndices = this.options.keyHashIndices[keyHash];
        keyIndices.push(i);
      }
    }
  }
  _isAnyItemSelected(items) {
    for (let i = 0; i < items.length; i++) {
      if (this.options.isItemSelected(items[i])) {
        return;
      }
    }
    return false;
  }
  _getFullSelectAllState() {
    const items = this.options.plainItems();
    const dataFilter = this.options.filter();
    let selectedItems = this.options.ignoreDisabledItems ? this.options.selectedItems : this.options.selectedItems.filter((item) => !(null !== item && void 0 !== item && item.disabled));
    if (dataFilter) {
      selectedItems = query_default(selectedItems).filter(dataFilter).toArray();
    }
    const selectedItemsLength = selectedItems.length;
    const disabledItemsLength = items.length - this.getSelectableItems(items).length;
    if (!selectedItemsLength) {
      return this._isAnyItemSelected(items);
    }
    if (selectedItemsLength >= this.options.totalCount() - disabledItemsLength) {
      return true;
    }
    return;
  }
  _getVisibleSelectAllState() {
    const items = this.getSelectableItems(this.options.plainItems());
    let hasSelectedItems = false;
    let hasUnselectedItems = false;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const itemData = this.options.getItemData(item);
      const key = this.options.keyOf(itemData);
      if (this.options.isSelectableItem(item)) {
        if (this.isItemKeySelected(key)) {
          hasSelectedItems = true;
        } else {
          hasUnselectedItems = true;
        }
      }
    }
    if (hasSelectedItems) {
      return !hasUnselectedItems ? true : void 0;
    }
    return false;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.deferred.js
var DeferredStrategy = class extends SelectionStrategy {
  getSelectedItems() {
    return this._loadFilteredData(this.options.selectionFilter);
  }
  getSelectedItemKeys() {
    const d = Deferred();
    const that = this;
    const key = this.options.key();
    const select = isString(key) ? [key] : key;
    this._loadFilteredData(this.options.selectionFilter, null, select).done((items) => {
      const keys = items.map((item) => that.options.keyOf(item));
      d.resolve(keys);
    }).fail(d.reject);
    return d.promise();
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll) {
    if (isSelectAll) {
      const filter = this.options.filter();
      const needResetSelectionFilter = !filter || JSON.stringify(filter) === JSON.stringify(this.options.selectionFilter) && isDeselect;
      if (needResetSelectionFilter) {
        this._setOption("selectionFilter", isDeselect ? [] : null);
      } else {
        this._addSelectionFilter(isDeselect, filter, isSelectAll);
      }
    } else {
      if (!preserve) {
        this._setOption("selectionFilter", []);
      }
      for (let i = 0; i < keys.length; i++) {
        if (isDeselect) {
          this.removeSelectedItem(keys[i]);
        } else {
          this.addSelectedItem(keys[i], isSelectAll, !preserve);
        }
      }
    }
    this.onSelectionChanged();
    return Deferred().resolve();
  }
  setSelectedItems(keys) {
    this._setOption("selectionFilter", null);
    for (let i = 0; i < keys.length; i++) {
      this.addSelectedItem(keys[i]);
    }
  }
  isItemDataSelected(itemData) {
    return this.isItemKeySelected(itemData);
  }
  isItemKeySelected(itemData) {
    const {
      selectionFilter,
      sensitivity
    } = this.options;
    if (!selectionFilter) {
      return true;
    }
    const queryParams = {
      langParams: {
        collatorOptions: {
          sensitivity
        }
      }
    };
    return !!query_default([itemData], queryParams).filter(selectionFilter).toArray().length;
  }
  _getKeyExpr() {
    const keyField = this.options.key();
    if (Array.isArray(keyField) && 1 === keyField.length) {
      return keyField[0];
    }
    return keyField;
  }
  _normalizeKey(key) {
    const keyExpr = this.options.key();
    if (Array.isArray(keyExpr) && 1 === keyExpr.length) {
      return key[keyExpr[0]];
    }
    return key;
  }
  _getFilterByKey(key) {
    const keyField = this._getKeyExpr();
    let filter = [keyField, "=", this._normalizeKey(key)];
    if (Array.isArray(keyField)) {
      filter = [];
      for (let i = 0; i < keyField.length; i++) {
        filter.push([keyField[i], "=", key[keyField[i]]]);
        if (i !== keyField.length - 1) {
          filter.push("and");
        }
      }
    }
    return filter;
  }
  addSelectedItem(key, isSelectAll, skipFilter) {
    const filter = this._getFilterByKey(key);
    this._addSelectionFilter(false, filter, isSelectAll, skipFilter);
  }
  removeSelectedItem(key) {
    const filter = this._getFilterByKey(key);
    this._addSelectionFilter(true, filter);
  }
  validate() {
    const {
      key
    } = this.options;
    if (key && void 0 === key()) {
      throw ui_errors_default.Error("E1042", "Deferred selection");
    }
  }
  _findSubFilter(selectionFilter, filter) {
    if (!selectionFilter) {
      return -1;
    }
    const filterString = JSON.stringify(filter);
    for (let index2 = 0; index2 < selectionFilter.length; index2++) {
      const subFilter = selectionFilter[index2];
      if (subFilter && JSON.stringify(subFilter) === filterString) {
        return index2;
      }
    }
    return -1;
  }
  _isLastSubFilter(selectionFilter, filter) {
    if (selectionFilter && filter) {
      return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || 0 === this._findSubFilter([selectionFilter], filter);
    }
    return false;
  }
  _addFilterOperator(selectionFilter, filterOperator) {
    if (selectionFilter.length > 1 && isString(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
      selectionFilter = [selectionFilter];
    }
    if (selectionFilter.length) {
      selectionFilter.push(filterOperator);
    }
    return selectionFilter;
  }
  _denormalizeFilter(filter) {
    if (filter && isString(filter[0])) {
      filter = [filter];
    }
    return filter;
  }
  _isOnlyNegativeFiltersLeft(filters) {
    return filters.every((filterItem, i) => {
      if (i % 2 === 0) {
        return Array.isArray(filterItem) && "!" === filterItem[0];
      }
      return "and" === filterItem;
    });
  }
  _addSelectionFilter(isDeselect, filter, isSelectAll, skipFilter) {
    var _selectionFilter;
    const that = this;
    const currentFilter = isDeselect ? ["!", filter] : filter;
    const currentOperation = isDeselect ? "and" : "or";
    let needAddFilter = true;
    let selectionFilter = that.options.selectionFilter || [];
    selectionFilter = that._denormalizeFilter(selectionFilter);
    if (null !== (_selectionFilter = selectionFilter) && void 0 !== _selectionFilter && _selectionFilter.length && !skipFilter) {
      const removedIndex = that._removeSameFilter(selectionFilter, filter, isDeselect, isSelectAll);
      const filterIndex = that._removeSameFilter(selectionFilter, filter, !isDeselect);
      const shouldCleanFilter = isDeselect && (-1 !== removedIndex || -1 !== filterIndex) && this._isOnlyNegativeFiltersLeft(selectionFilter);
      if (shouldCleanFilter) {
        selectionFilter = [];
      }
      const isKeyOperatorsAfterRemoved = this._isKeyFilter(filter) && this._hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex);
      needAddFilter = filter.length && !isKeyOperatorsAfterRemoved;
    }
    if (needAddFilter) {
      selectionFilter = that._addFilterOperator(selectionFilter, currentOperation);
      selectionFilter.push(currentFilter);
    }
    selectionFilter = that._normalizeFilter(selectionFilter);
    that._setOption("selectionFilter", !isDeselect && !selectionFilter.length ? null : selectionFilter);
  }
  _normalizeFilter(filter) {
    if (filter && 1 === filter.length) {
      filter = filter[0];
    }
    return filter;
  }
  _removeFilterByIndex(filter, filterIndex, isSelectAll) {
    const operation = filter[1];
    if (filterIndex > 0) {
      filter.splice(filterIndex - 1, 2);
    } else {
      filter.splice(filterIndex, 2);
    }
    if (isSelectAll && "and" === operation) {
      filter.splice(0, filter.length);
    }
  }
  _isSimpleKeyFilter(filter, key) {
    return 3 === filter.length && filter[0] === key && "=" === filter[1];
  }
  _isKeyFilter(filter) {
    if (2 === filter.length && "!" === filter[0]) {
      return this._isKeyFilter(filter[1]);
    }
    const keyField = this._getKeyExpr();
    if (Array.isArray(keyField)) {
      if (filter.length !== 2 * keyField.length - 1) {
        return false;
      }
      for (let i = 0; i < keyField.length; i++) {
        if (i > 0 && "and" !== filter[2 * i - 1]) {
          return false;
        }
        if (!this._isSimpleKeyFilter(filter[2 * i], keyField[i])) {
          return false;
        }
      }
      return true;
    }
    return this._isSimpleKeyFilter(filter, keyField);
  }
  _hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex) {
    if (filterIndex >= 0) {
      for (let i = filterIndex; i < selectionFilter.length; i++) {
        if ("string" !== typeof selectionFilter[i] && !this._isKeyFilter(selectionFilter[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  _removeSameFilter(selectionFilter, filter, inverted, isSelectAll) {
    filter = inverted ? ["!", filter] : filter;
    if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
      selectionFilter.splice(0, selectionFilter.length);
      return 0;
    }
    const filterIndex = this._findSubFilter(selectionFilter, filter);
    if (filterIndex >= 0) {
      this._removeFilterByIndex(selectionFilter, filterIndex, isSelectAll);
      return filterIndex;
    }
    for (let i = 0; i < selectionFilter.length; i++) {
      if (Array.isArray(selectionFilter[i]) && selectionFilter[i].length > 2) {
        const filterIndex2 = this._removeSameFilter(selectionFilter[i], filter, false, isSelectAll);
        if (filterIndex2 >= 0) {
          if (!selectionFilter[i].length) {
            this._removeFilterByIndex(selectionFilter, i, isSelectAll);
          } else if (1 === selectionFilter[i].length) {
            selectionFilter[i] = selectionFilter[i][0];
          }
          return filterIndex2;
        }
      }
    }
    return -1;
  }
  getSelectAllState() {
    const filter = this.options.filter();
    let {
      selectionFilter
    } = this.options;
    if (!selectionFilter) {
      return true;
    }
    if (!selectionFilter.length) {
      return false;
    }
    if (!filter || !filter.length) {
      return;
    }
    selectionFilter = this._denormalizeFilter(selectionFilter);
    if (this._isLastSubFilter(selectionFilter, filter)) {
      return true;
    }
    if (this._isLastSubFilter(selectionFilter, ["!", filter])) {
      return false;
    }
    return;
  }
  loadSelectedItemsWithFilter() {
    const componentFilter = this.options.filter();
    const {
      selectionFilter
    } = this.options;
    const filter = componentFilter ? [componentFilter, "and", selectionFilter] : selectionFilter;
    return this._loadFilteredData(filter);
  }
};

// ../../../../../../node_modules/devextreme/esm/core/utils/array.js
function createOccurrenceMap(array) {
  return array.reduce((map2, value2) => {
    const count = (map2.get(value2) ?? 0) + 1;
    map2.set(value2, count);
    return map2;
  }, /* @__PURE__ */ new Map());
}
var wrapToArray = function(item) {
  return Array.isArray(item) ? item : [item];
};
var getUniqueValues = function(values) {
  return [...new Set(values)];
};
var getIntersection = function(firstArray, secondArray) {
  const toRemoveMap = createOccurrenceMap(secondArray);
  return firstArray.filter((value2) => {
    const occurrencesCount = toRemoveMap.get(value2);
    occurrencesCount && toRemoveMap.set(value2, occurrencesCount - 1);
    return occurrencesCount;
  });
};
var removeDuplicates = function() {
  let from = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  let toRemove = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
  const toRemoveMap = createOccurrenceMap(toRemove);
  return from.filter((value2) => {
    const occurrencesCount = toRemoveMap.get(value2);
    occurrencesCount && toRemoveMap.set(value2, occurrencesCount - 1);
    return !occurrencesCount;
  });
};
var normalizeIndexes = function(items, indexPropName, currentItem, needIndexCallback) {
  const indexedItems = {};
  const {
    useLegacyVisibleIndex
  } = config_default();
  let currentIndex = 0;
  const shouldUpdateIndex = (item) => !isDefined(item[indexPropName]) && (!needIndexCallback || needIndexCallback(item));
  items.forEach((item) => {
    const index2 = item[indexPropName];
    if (index2 >= 0) {
      indexedItems[index2] = indexedItems[index2] || [];
      if (item === currentItem) {
        indexedItems[index2].unshift(item);
      } else {
        indexedItems[index2].push(item);
      }
    } else {
      item[indexPropName] = void 0;
    }
  });
  if (!useLegacyVisibleIndex) {
    items.forEach((item) => {
      if (shouldUpdateIndex(item)) {
        while (indexedItems[currentIndex]) {
          currentIndex++;
        }
        indexedItems[currentIndex] = [item];
        currentIndex++;
      }
    });
  }
  currentIndex = 0;
  orderEach(indexedItems, function(index2, items2) {
    items2.forEach((item) => {
      if (index2 >= 0) {
        item[indexPropName] = currentIndex++;
      }
    });
  });
  if (useLegacyVisibleIndex) {
    items.forEach((item) => {
      if (shouldUpdateIndex(item)) {
        item[indexPropName] = currentIndex++;
      }
    });
  }
};
var groupBy = (array, getGroupName) => array.reduce((groupedResult, item) => {
  const groupName = getGroupName(item);
  groupedResult[groupName] = groupedResult[groupName] ?? [];
  groupedResult[groupName].push(item);
  return groupedResult;
}, {});

// ../../../../../../node_modules/devextreme/esm/core/utils/array_compare.js
var getKeyWrapper = function(item, getKey) {
  const key = getKey(item);
  if (isObject(key)) {
    try {
      return JSON.stringify(key);
    } catch (e) {
      return key;
    }
  }
  return key;
};
var getSameNewByOld = function(oldItem, newItems, newIndexByKey, getKey) {
  const key = getKeyWrapper(oldItem, getKey);
  return newItems[newIndexByKey[key]];
};
var isKeysEqual = function(oldKeys, newKeys) {
  if (oldKeys.length !== newKeys.length) {
    return false;
  }
  for (let i = 0; i < newKeys.length; i++) {
    if (oldKeys[i] !== newKeys[i]) {
      return false;
    }
  }
  return true;
};
var findChanges = function(oldItems, newItems, getKey, isItemEquals) {
  const oldIndexByKey = {};
  const newIndexByKey = {};
  let addedCount = 0;
  let removeCount = 0;
  const result2 = [];
  oldItems.forEach(function(item, index2) {
    const key = getKeyWrapper(item, getKey);
    oldIndexByKey[key] = index2;
  });
  newItems.forEach(function(item, index2) {
    const key = getKeyWrapper(item, getKey);
    newIndexByKey[key] = index2;
  });
  const itemCount = Math.max(oldItems.length, newItems.length);
  for (let index2 = 0; index2 < itemCount + addedCount; index2++) {
    const newItem = newItems[index2];
    const oldNextIndex = index2 - addedCount + removeCount;
    const nextOldItem = oldItems[oldNextIndex];
    const isRemoved = !newItem || nextOldItem && !getSameNewByOld(nextOldItem, newItems, newIndexByKey, getKey);
    if (isRemoved) {
      if (nextOldItem) {
        result2.push({
          type: "remove",
          key: getKey(nextOldItem),
          index: index2,
          oldItem: nextOldItem
        });
        removeCount++;
        index2--;
      }
    } else {
      const key = getKeyWrapper(newItem, getKey);
      const oldIndex = oldIndexByKey[key];
      const oldItem = oldItems[oldIndex];
      if (!oldItem) {
        addedCount++;
        result2.push({
          type: "insert",
          data: newItem,
          index: index2
        });
      } else if (oldIndex === oldNextIndex) {
        if (!isItemEquals(oldItem, newItem)) {
          result2.push({
            type: "update",
            data: newItem,
            key: getKey(newItem),
            index: index2,
            oldItem
          });
        }
      } else {
        return;
      }
    }
  }
  return result2;
};

// ../../../../../../node_modules/devextreme/esm/core/utils/selection_filter.js
var SelectionFilterCreator = function(selectedItemKeys, isSelectAll) {
  this.getLocalFilter = function(keyGetter, equalKeys, equalByReference, keyExpr) {
    equalKeys = void 0 === equalKeys ? equalByValue : equalKeys;
    return functionFilter.bind(this, equalKeys, keyGetter, equalByReference, keyExpr);
  };
  this.getExpr = function(keyExpr) {
    if (!keyExpr) {
      return;
    }
    let filterExpr;
    selectedItemKeys.forEach(function(key, index2) {
      filterExpr = filterExpr || [];
      let filterExprPart;
      if (index2 > 0) {
        filterExpr.push(isSelectAll ? "and" : "or");
      }
      if (isString(keyExpr)) {
        filterExprPart = getFilterForPlainKey(keyExpr, key);
      } else {
        filterExprPart = function(keyExpr2, itemKeyValue) {
          const filterExpr2 = [];
          for (let i = 0, length = keyExpr2.length; i < length; i++) {
            const currentKeyExpr = keyExpr2[i];
            const keyValueGetter = compileGetter(currentKeyExpr);
            const currentKeyValue = itemKeyValue && keyValueGetter(itemKeyValue);
            const filterExprPart2 = getFilterForPlainKey(currentKeyExpr, currentKeyValue);
            if (!filterExprPart2) {
              break;
            }
            if (i > 0) {
              filterExpr2.push(isSelectAll ? "or" : "and");
            }
            filterExpr2.push(filterExprPart2);
          }
          return filterExpr2;
        }(keyExpr, key);
      }
      filterExpr.push(filterExprPart);
    });
    if (filterExpr && 1 === filterExpr.length) {
      filterExpr = filterExpr[0];
    }
    return filterExpr;
  };
  this.getCombinedFilter = function(keyExpr, dataSourceFilter) {
    let forceCombinedFilter = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    const filterExpr = this.getExpr(keyExpr);
    let combinedFilter = filterExpr;
    if ((forceCombinedFilter || isSelectAll) && dataSourceFilter) {
      if (filterExpr) {
        combinedFilter = [];
        combinedFilter.push(filterExpr);
        combinedFilter.push(dataSourceFilter);
      } else {
        combinedFilter = dataSourceFilter;
      }
    }
    return combinedFilter;
  };
  let selectedItemKeyHashesMap;
  const getSelectedItemKeyHashesMap = function(keyOf, keyExpr) {
    if (!selectedItemKeyHashesMap) {
      selectedItemKeyHashesMap = {};
      const normalizedKeys = normalizeKeys(selectedItemKeys, keyOf, keyExpr);
      for (let i = 0; i < normalizedKeys.length; i++) {
        selectedItemKeyHashesMap[getKeyHash(normalizedKeys[i])] = true;
      }
    }
    return selectedItemKeyHashesMap;
  };
  const normalizeKeys = function(keys, keyOf, keyExpr) {
    return Array.isArray(keyExpr) ? keys.map((key) => keyOf(key)) : keys;
  };
  function functionFilter(equalKeys, keyOf, equalByReference, keyExpr, item) {
    const key = keyOf(item);
    let keyHash;
    let i;
    if (!equalByReference) {
      keyHash = getKeyHash(key);
      if (!isObject(keyHash)) {
        const selectedKeyHashesMap = getSelectedItemKeyHashesMap(keyOf, keyExpr);
        if (selectedKeyHashesMap[keyHash]) {
          return !isSelectAll;
        }
        return !!isSelectAll;
      }
    }
    for (i = 0; i < selectedItemKeys.length; i++) {
      if (equalKeys(selectedItemKeys[i], key)) {
        return !isSelectAll;
      }
    }
    return !!isSelectAll;
  }
  function getFilterForPlainKey(keyExpr, keyValue) {
    if (void 0 === keyValue) {
      return;
    }
    return [keyExpr, isSelectAll ? "<>" : "=", keyValue];
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.standard.js
var StandardStrategy = class extends SelectionStrategy {
  constructor(options2) {
    super(options2);
    this._initSelectedItemKeyHash();
  }
  _initSelectedItemKeyHash() {
    this._setOption("keyHashIndices", this.options.equalByReference ? null : {});
  }
  getSelectedItemKeys() {
    return this.options.selectedItemKeys.slice(0);
  }
  getSelectedItems() {
    return this.options.selectedItems.slice(0);
  }
  _preserveSelectionUpdate(items, isDeselect) {
    const {
      keyOf
    } = this.options;
    let keyIndicesToRemoveMap;
    let keyIndex;
    let i;
    if (!keyOf) {
      return;
    }
    const isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;
    if (isBatchDeselect) {
      keyIndicesToRemoveMap = {};
    }
    for (i = 0; i < items.length; i++) {
      const item = items[i];
      const key = keyOf(item);
      if (isDeselect) {
        keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap, null === item || void 0 === item ? void 0 : item.disabled);
        if (keyIndicesToRemoveMap && keyIndex >= 0) {
          keyIndicesToRemoveMap[keyIndex] = true;
        }
      } else {
        this.addSelectedItem(key, item);
      }
    }
    if (isBatchDeselect) {
      this._batchRemoveSelectedItems(keyIndicesToRemoveMap);
    }
  }
  _batchRemoveSelectedItems(keyIndicesToRemoveMap) {
    const selectedItemKeys = this.options.selectedItemKeys.slice(0);
    const selectedItems = this.options.selectedItems.slice(0);
    this.options.selectedItemKeys.length = 0;
    this.options.selectedItems.length = 0;
    for (let i = 0; i < selectedItemKeys.length; i++) {
      if (!keyIndicesToRemoveMap[i]) {
        this.options.selectedItemKeys.push(selectedItemKeys[i]);
        this.options.selectedItems.push(selectedItems[i]);
      }
    }
    this._initSelectedItemKeyHash();
    this.updateSelectedItemKeyHash(this.options.selectedItemKeys);
  }
  _loadSelectedItemsCore(keys, isDeselect, isSelectAll, filter) {
    let forceCombinedFilter = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    let deferred = Deferred();
    const key = this.options.key();
    if (!keys.length && !isSelectAll) {
      deferred.resolve([]);
      return deferred;
    }
    if (isSelectAll && isDeselect && !filter) {
      deferred.resolve(this.getSelectedItems());
      return deferred;
    }
    const selectionFilterCreator = new SelectionFilterCreator(keys, isSelectAll);
    const combinedFilter = selectionFilterCreator.getCombinedFilter(key, filter, forceCombinedFilter);
    let deselectedItems = [];
    if (isDeselect) {
      const {
        selectedItems
      } = this.options;
      deselectedItems = combinedFilter && keys.length !== selectedItems.length ? query_default(selectedItems).filter(combinedFilter).toArray() : selectedItems.slice(0);
    }
    let filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems(true).filter(this.options.isSelectableItem).map(this.options.getItemData);
    const localFilter = selectionFilterCreator.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, key);
    filteredItems = filteredItems.filter(localFilter);
    if (deselectedItems.length || !isSelectAll && filteredItems.length === keys.length) {
      deferred.resolve(filteredItems);
    } else {
      deferred = this._loadFilteredData(combinedFilter, localFilter, null, isSelectAll);
    }
    return deferred;
  }
  _replaceSelectionUpdate(items) {
    const internalKeys = [];
    const {
      keyOf
    } = this.options;
    if (!keyOf) {
      return;
    }
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const key = keyOf(item);
      internalKeys.push(key);
    }
    this.setSelectedItems(internalKeys, items);
  }
  _warnOnIncorrectKeys(keys) {
    const {
      allowNullValue
    } = this.options;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if ((!allowNullValue || null !== key) && !this.isItemKeySelected(key)) {
        ui_errors_default.log("W1002", key);
      }
    }
  }
  _isMultiSelectEnabled() {
    const {
      mode
    } = this.options;
    return "all" === mode || "multiple" === mode;
  }
  _requestInProgress() {
    var _this$_lastLoadDeferr;
    return "pending" === (null === (_this$_lastLoadDeferr = this._lastLoadDeferred) || void 0 === _this$_lastLoadDeferr ? void 0 : _this$_lastLoadDeferr.state());
  }
  _concatRequestsItems(keys, isDeselect, oldRequestItems, updatedKeys) {
    let selectedItems;
    const deselectedItems = isDeselect ? keys : [];
    if (updatedKeys) {
      selectedItems = updatedKeys;
    } else {
      selectedItems = removeDuplicates(keys, this.options.selectedItemKeys);
    }
    return {
      addedItems: oldRequestItems.added.concat(selectedItems),
      removedItems: oldRequestItems.removed.concat(deselectedItems),
      keys
    };
  }
  _collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys) {
    const isDeselectAll = isDeselect && isSelectAll;
    const oldRequestItems = {
      added: [],
      removed: []
    };
    const multiSelectEnabled = this._isMultiSelectEnabled();
    let lastRequestData = multiSelectEnabled ? this._lastRequestData : {};
    if (multiSelectEnabled) {
      if (this._shouldMergeWithLastRequest) {
        if (isDeselectAll) {
          this._lastLoadDeferred.reject();
          lastRequestData = {};
        } else if (!isKeysEqual(keys, this.options.selectedItemKeys)) {
          oldRequestItems.added = lastRequestData.addedItems;
          oldRequestItems.removed = lastRequestData.removedItems;
          if (!isDeselect) {
            this._lastLoadDeferred.reject();
          }
        }
      }
      lastRequestData = this._concatRequestsItems(keys, isDeselect, oldRequestItems, this._shouldMergeWithLastRequest ? void 0 : updatedKeys);
    }
    return lastRequestData;
  }
  _updateKeysByLastRequestData(keys, isDeselect, isSelectAll) {
    let currentKeys = keys;
    if (this._isMultiSelectEnabled() && this._shouldMergeWithLastRequest && !isDeselect && !isSelectAll) {
      var _this$_lastRequestDat, _this$_lastRequestDat2;
      currentKeys = removeDuplicates(keys.concat(null === (_this$_lastRequestDat = this._lastRequestData) || void 0 === _this$_lastRequestDat ? void 0 : _this$_lastRequestDat.addedItems), null === (_this$_lastRequestDat2 = this._lastRequestData) || void 0 === _this$_lastRequestDat2 ? void 0 : _this$_lastRequestDat2.removedItems);
      currentKeys = getUniqueValues(currentKeys);
    }
    return currentKeys;
  }
  _loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys) {
    let forceCombinedFilter = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    const that = this;
    const deferred = Deferred();
    const filter = that.options.filter();
    this._shouldMergeWithLastRequest = this._requestInProgress();
    this._lastRequestData = this._collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys);
    when(that._lastLoadDeferred).always(() => {
      const currentKeys = that._updateKeysByLastRequestData(keys, isDeselect, isSelectAll);
      that._shouldMergeWithLastRequest = false;
      that._loadSelectedItemsCore(currentKeys, isDeselect, isSelectAll, filter, forceCombinedFilter).done(deferred.resolve).fail(deferred.reject);
    });
    that._lastLoadDeferred = deferred;
    return deferred;
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    let forceCombinedFilter = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : false;
    const that = this;
    const deferred = that._loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys, forceCombinedFilter);
    deferred.done((items) => {
      if (preserve) {
        that._preserveSelectionUpdate(items, isDeselect);
      } else {
        that._replaceSelectionUpdate(items);
      }
      that.onSelectionChanged();
    });
    return deferred;
  }
  addSelectedItem(key, itemData) {
    if (isDefined(itemData) && !this.options.ignoreDisabledItems && itemData.disabled) {
      if (-1 === this.options.disabledItemKeys.indexOf(key)) {
        this.options.disabledItemKeys.push(key);
      }
      return;
    }
    const keyHash = this._getKeyHash(key);
    if (-1 === this._indexOfSelectedItemKey(keyHash)) {
      if (!isObject(keyHash) && this.options.keyHashIndices) {
        this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length];
      }
      this.options.selectedItemKeys.push(key);
      this.options.addedItemKeys.push(key);
      this.options.addedItems.push(itemData);
      this.options.selectedItems.push(itemData);
    }
  }
  _getSelectedIndexByKey(key, ignoreIndicesMap) {
    const {
      selectedItemKeys
    } = this.options;
    for (let index2 = 0; index2 < selectedItemKeys.length; index2++) {
      if ((!ignoreIndicesMap || !ignoreIndicesMap[index2]) && this.equalKeys(selectedItemKeys[index2], key)) {
        return index2;
      }
    }
    return -1;
  }
  _getSelectedIndexByHash(key, ignoreIndicesMap) {
    let indices = this.options.keyHashIndices[key];
    if (indices && indices.length > 1 && ignoreIndicesMap) {
      indices = indices.filter((index2) => !ignoreIndicesMap[index2]);
    }
    return indices && indices[0] >= 0 ? indices[0] : -1;
  }
  _indexOfSelectedItemKey(key, ignoreIndicesMap) {
    let selectedIndex;
    if (this.options.equalByReference) {
      selectedIndex = this.options.selectedItemKeys.indexOf(key);
    } else if (isObject(key)) {
      selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap);
    } else {
      selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap);
    }
    return selectedIndex;
  }
  _shiftSelectedKeyIndices(keyIndex) {
    for (let currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
      const currentKey = this.options.selectedItemKeys[currentKeyIndex];
      const currentKeyHash = getKeyHash(currentKey);
      const currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
      if (!currentKeyIndices) {
        continue;
      }
      for (let i = 0; i < currentKeyIndices.length; i++) {
        if (currentKeyIndices[i] > keyIndex) {
          currentKeyIndices[i]--;
        }
      }
    }
  }
  removeSelectedItem(key, keyIndicesToRemoveMap, isDisabled) {
    if (!this.options.ignoreDisabledItems && isDisabled) {
      return;
    }
    const keyHash = this._getKeyHash(key);
    const isBatchDeselect = !!keyIndicesToRemoveMap;
    const keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);
    if (keyIndex < 0) {
      return keyIndex;
    }
    this.options.removedItemKeys.push(key);
    this.options.removedItems.push(this.options.selectedItems[keyIndex]);
    if (isBatchDeselect) {
      return keyIndex;
    }
    this.options.selectedItemKeys.splice(keyIndex, 1);
    this.options.selectedItems.splice(keyIndex, 1);
    if (isObject(keyHash) || !this.options.keyHashIndices) {
      return keyIndex;
    }
    const keyIndices = this.options.keyHashIndices[keyHash];
    if (!keyIndices) {
      return keyIndex;
    }
    keyIndices.shift();
    if (!keyIndices.length) {
      delete this.options.keyHashIndices[keyHash];
    }
    this._shiftSelectedKeyIndices(keyIndex);
    return keyIndex;
  }
  _updateAddedItemKeys(keys, items) {
    for (let i = 0; i < keys.length; i++) {
      if (!this.isItemKeySelected(keys[i])) {
        this.options.addedItemKeys.push(keys[i]);
        this.options.addedItems.push(items[i]);
      }
    }
  }
  _updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems) {
    for (let i = 0; i < oldSelectedKeys.length; i++) {
      if (!this.isItemKeySelected(oldSelectedKeys[i])) {
        this.options.removedItemKeys.push(oldSelectedKeys[i]);
        this.options.removedItems.push(oldSelectedItems[i]);
      }
    }
  }
  _isItemSelectionInProgress(key, checkPending) {
    const shouldCheckPending = checkPending && this._lastRequestData && this._requestInProgress();
    if (shouldCheckPending) {
      const addedItems = this._lastRequestData.addedItems ?? [];
      return addedItems.includes(key);
    }
    return false;
  }
  _getKeyHash(key) {
    return this.options.equalByReference ? key : getKeyHash(key);
  }
  setSelectedItems(keys, items) {
    this._updateAddedItemKeys(keys, items);
    const oldSelectedKeys = this.options.selectedItemKeys;
    const oldSelectedItems = this.options.selectedItems;
    if (!this.options.equalByReference) {
      this._initSelectedItemKeyHash();
      this.updateSelectedItemKeyHash(keys);
    }
    this._setOption("selectedItemKeys", keys);
    this._setOption("selectedItems", items);
    this._updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems);
  }
  isItemDataSelected(itemData) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const key = this.options.keyOf(itemData);
    return this.isItemKeySelected(key, options2);
  }
  isItemKeySelected(key) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    let result2 = this._isItemSelectionInProgress(key, options2.checkPending);
    if (!result2) {
      const keyHash = this._getKeyHash(key);
      const index2 = this._indexOfSelectedItemKey(keyHash);
      result2 = -1 !== index2;
    }
    return result2;
  }
  getSelectAllState(visibleOnly) {
    if (visibleOnly) {
      return this._getVisibleSelectAllState();
    }
    return this._getFullSelectAllState();
  }
  loadSelectedItemsWithFilter() {
    const keyExpr = this.options.key();
    const keys = this.getSelectedItemKeys();
    const filter = this.options.filter();
    if (!keys.length) {
      return Deferred().resolve([]);
    }
    const selectionFilterCreator = new SelectionFilterCreator(keys);
    const combinedFilter = selectionFilterCreator.getCombinedFilter(keyExpr, filter, true);
    return this._loadFilteredData(combinedFilter);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/selection/m_selection.js
var Selection = class {
  constructor(options2) {
    this.options = extend(this._getDefaultOptions(), options2, {
      selectedItemKeys: options2.selectedKeys || []
    });
    this._selectionStrategy = this.options.deferred ? new DeferredStrategy(this.options) : new StandardStrategy(this.options);
    this._focusedItemIndex = -1;
    if (!this.options.equalByReference) {
      this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys);
    }
  }
  _getDefaultOptions() {
    return {
      allowNullValue: false,
      deferred: false,
      equalByReference: false,
      mode: "multiple",
      selectedItems: [],
      selectionFilter: [],
      maxFilterLengthInRequest: 0,
      onSelectionChanged: noop2,
      key: noop2,
      keyOf: (item) => item,
      load: () => Deferred().resolve([]),
      totalCount: () => -1,
      isSelectableItem: () => true,
      isItemSelected: () => false,
      getItemData: (item) => item,
      dataFields: noop2,
      filter: noop2
    };
  }
  validate() {
    this._selectionStrategy.validate();
  }
  getSelectedItemKeys() {
    return this._selectionStrategy.getSelectedItemKeys();
  }
  getSelectedItems() {
    return this._selectionStrategy.getSelectedItems();
  }
  selectionFilter(value2) {
    if (void 0 === value2) {
      return this.options.selectionFilter;
    }
    const filterIsChanged = this.options.selectionFilter !== value2 && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value2);
    this.options.selectionFilter = value2;
    filterIsChanged && this.onSelectionChanged();
  }
  setSelection(keys, updatedKeys) {
    return this.selectedItemKeys(keys, false, false, false, updatedKeys);
  }
  select(keys) {
    return this.selectedItemKeys(keys, true);
  }
  deselect(keys) {
    return this.selectedItemKeys(keys, true, true);
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    keys = keys ?? [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys);
  }
  clearSelection() {
    return this.selectedItemKeys([]);
  }
  _addSelectedItem(itemData, key) {
    this._selectionStrategy.addSelectedItem(key, itemData);
  }
  _removeSelectedItem(key) {
    this._selectionStrategy.removeSelectedItem(key);
  }
  _setSelectedItems(keys, items) {
    this._selectionStrategy.setSelectedItems(keys, items);
  }
  onSelectionChanged() {
    this._selectionStrategy.onSelectionChanged();
  }
  changeItemSelection(itemIndex, keys, setFocusOnly) {
    var _this$options$allowLo, _this$options;
    let isSelectedItemsChanged;
    const items = this.options.plainItems();
    const item = items[itemIndex];
    let deferred;
    const {
      isVirtualPaging
    } = this.options;
    const allowLoadByRange = null === (_this$options$allowLo = (_this$options = this.options).allowLoadByRange) || void 0 === _this$options$allowLo ? void 0 : _this$options$allowLo.call(_this$options);
    const {
      alwaysSelectByShift
    } = this.options;
    let indexOffset;
    let focusedItemNotInLoadedRange = false;
    let shiftFocusedItemNotInLoadedRange = false;
    const itemIsNotInLoadedRange = (index2) => index2 >= 0 && !items.filter((it) => it.loadIndex === index2).length;
    if (isVirtualPaging && isDefined(item)) {
      if (allowLoadByRange) {
        indexOffset = item.loadIndex - itemIndex;
        itemIndex = item.loadIndex;
      }
      focusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._focusedItemIndex);
      if (isDefined(this._shiftFocusedItemIndex)) {
        shiftFocusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._shiftFocusedItemIndex);
      }
    }
    if (!this.isSelectable() || !this.isDataItem(item)) {
      return false;
    }
    const itemData = this.options.getItemData(item);
    const itemKey = this.options.keyOf(itemData);
    keys = keys || {};
    let allowSelectByShift = keys.shift;
    if (false === alwaysSelectByShift && allowSelectByShift) {
      allowSelectByShift = false !== allowLoadByRange || !focusedItemNotInLoadedRange && !shiftFocusedItemNotInLoadedRange;
    }
    if (allowSelectByShift && "multiple" === this.options.mode && this._focusedItemIndex >= 0) {
      if (allowLoadByRange && (focusedItemNotInLoadedRange || shiftFocusedItemNotInLoadedRange)) {
        isSelectedItemsChanged = itemIndex !== this._shiftFocusedItemIndex || this._focusedItemIndex !== this._shiftFocusedItemIndex;
        if (isSelectedItemsChanged) {
          deferred = this.changeItemSelectionWhenShiftKeyInVirtualPaging(itemIndex);
        }
      } else {
        isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset);
      }
    } else if (keys.control) {
      this._resetItemSelectionWhenShiftKeyPressed();
      if (!setFocusOnly) {
        const isSelected = this._selectionStrategy.isItemDataSelected(itemData);
        if ("single" === this.options.mode) {
          this.clearSelectedItems();
        }
        if (isSelected) {
          this._removeSelectedItem(itemKey);
        } else {
          this._addSelectedItem(itemData, itemKey);
        }
      }
      isSelectedItemsChanged = true;
    } else {
      this._resetItemSelectionWhenShiftKeyPressed();
      const isKeysEqual2 = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);
      if (1 !== this.options.selectedItemKeys.length || !isKeysEqual2) {
        this._setSelectedItems([itemKey], [itemData]);
        isSelectedItemsChanged = true;
      }
    }
    if (isSelectedItemsChanged) {
      when(deferred).done(() => {
        this._focusedItemIndex = itemIndex;
        !setFocusOnly && this.onSelectionChanged();
      });
      return true;
    }
  }
  isDataItem(item) {
    return this.options.isSelectableItem(item);
  }
  isSelectable() {
    return "single" === this.options.mode || "multiple" === this.options.mode;
  }
  isItemDataSelected(data2) {
    return this._selectionStrategy.isItemDataSelected(data2, {
      checkPending: true
    });
  }
  isItemSelected(arg, options2) {
    return this._selectionStrategy.isItemKeySelected(arg, options2);
  }
  _resetItemSelectionWhenShiftKeyPressed() {
    delete this._shiftFocusedItemIndex;
  }
  _resetFocusedItemIndex() {
    this._focusedItemIndex = -1;
  }
  changeItemSelectionWhenShiftKeyInVirtualPaging(loadIndex) {
    const loadOptions = this.options.getLoadOptions(loadIndex, this._focusedItemIndex, this._shiftFocusedItemIndex);
    const deferred = Deferred();
    const indexOffset = loadOptions.skip;
    this.options.load(loadOptions).done((items) => {
      this.changeItemSelectionWhenShiftKeyPressed(loadIndex, items, indexOffset);
      deferred.resolve();
    });
    return deferred.promise();
  }
  changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset) {
    let isSelectedItemsChanged = false;
    let itemIndexStep;
    const indexOffsetDefined = isDefined(indexOffset);
    let index2 = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
    const {
      keyOf
    } = this.options;
    const focusedItem = items[index2];
    const focusedData = this.options.getItemData(focusedItem);
    const focusedKey = keyOf(focusedData);
    const isFocusedItemSelected = focusedItem && this.isItemDataSelected(focusedData);
    if (!isDefined(this._shiftFocusedItemIndex)) {
      this._shiftFocusedItemIndex = this._focusedItemIndex;
    }
    let data2;
    let itemKey;
    let startIndex;
    let endIndex;
    if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
      itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index2 = startIndex; index2 !== endIndex; index2 += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index2])) {
          itemKey = keyOf(this.options.getItemData(items[index2]));
          this._removeSelectedItem(itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if (itemIndex !== this._shiftFocusedItemIndex) {
      itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? itemIndex - indexOffset : itemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index2 = startIndex; index2 !== endIndex; index2 += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index2])) {
          data2 = this.options.getItemData(items[index2]);
          itemKey = keyOf(data2);
          this._addSelectedItem(data2, itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if ((indexOffsetDefined || this.isDataItem(focusedItem)) && !isFocusedItemSelected) {
      this._addSelectedItem(focusedData, focusedKey);
      isSelectedItemsChanged = true;
    }
    return isSelectedItemsChanged;
  }
  clearSelectedItems() {
    this._setSelectedItems([], []);
  }
  selectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._onePageSelectAll(false);
    }
    return this.selectedItemKeys([], true, false, true);
  }
  deselectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._onePageSelectAll(true);
    }
    return this.selectedItemKeys([], true, true, true);
  }
  _onePageSelectAll(isDeselect) {
    const items = this._selectionStrategy.getSelectableItems(this.options.plainItems());
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (this.isDataItem(item)) {
        const itemData = this.options.getItemData(item);
        const itemKey = this.options.keyOf(itemData);
        const isSelected = this.isItemSelected(itemKey);
        if (!isSelected && !isDeselect) {
          this._addSelectedItem(itemData, itemKey);
        }
        if (isSelected && isDeselect) {
          this._removeSelectedItem(itemKey);
        }
      }
    }
    this.onSelectionChanged();
    return Deferred().resolve();
  }
  getSelectAllState(visibleOnly) {
    return this._selectionStrategy.getSelectAllState(visibleOnly);
  }
  loadSelectedItemsWithFilter() {
    return this._selectionStrategy.loadSelectedItemsWithFilter();
  }
};

// ../../../../../../node_modules/devextreme/esm/core/templates/child_default_template.js
var ChildDefaultTemplate = class extends TemplateBase {
  constructor(name2) {
    super();
    this.name = name2;
  }
};

// ../../../../../../node_modules/devextreme/esm/core/templates/template_engine_registry.js
var templateEngines = {};
var currentTemplateEngine;
function registerTemplateEngine(name2, templateEngine) {
  templateEngines[name2] = templateEngine;
}
function setTemplateEngine(templateEngine) {
  if (isString(templateEngine)) {
    currentTemplateEngine = templateEngines[templateEngine];
    if (!currentTemplateEngine) {
      throw errors_default.Error("E0020", templateEngine);
    }
  } else {
    currentTemplateEngine = templateEngine;
  }
}
function getCurrentTemplateEngine() {
  return currentTemplateEngine;
}

// ../../../../../../node_modules/devextreme/esm/core/templates/template.js
registerTemplateEngine("default", {
  compile: (element) => normalizeTemplateElement(element),
  render: (template, model, index2) => template.clone()
});
setTemplateEngine("default");
var Template = class extends TemplateBase {
  constructor(element) {
    super();
    this._element = element;
  }
  _renderCore(options2) {
    const transclude = options2.transclude;
    if (!transclude && !this._compiledTemplate) {
      this._compiledTemplate = getCurrentTemplateEngine().compile(this._element);
    }
    return renderer_default("<div>").append(transclude ? this._element : getCurrentTemplateEngine().render(this._compiledTemplate, options2.model, options2.index)).contents();
  }
  source() {
    return renderer_default(this._element).clone();
  }
};

// ../../../../../../node_modules/devextreme/esm/core/utils/template_manager.js
var findTemplates = (element, name2) => {
  const templates = renderer_default(element).contents().filter(`[data-options*="${name2}"]`);
  return [].slice.call(templates).map((element2) => {
    const optionsString = renderer_default(element2).attr("data-options") || "";
    return {
      element: element2,
      options: config_default().optionsParser(optionsString)[name2]
    };
  }).filter((template) => !!template.options);
};
var suitableTemplatesByName = (rawTemplates) => {
  const templatesMap = groupBy(rawTemplates, (template) => template.options.name);
  if (templatesMap[void 0]) {
    throw errors_default.Error("E0023");
  }
  const result2 = {};
  Object.keys(templatesMap).forEach((name2) => {
    var _findBestMatches$;
    const suitableTemplate = null === (_findBestMatches$ = findBestMatches(devices_default.current(), templatesMap[name2], (template) => template.options)[0]) || void 0 === _findBestMatches$ ? void 0 : _findBestMatches$.element;
    if (suitableTemplate) {
      result2[name2] = suitableTemplate;
    }
  });
  return result2;
};
var addOneRenderedCall = (template) => {
  const render4 = template.render.bind(template);
  return extend({}, template, {
    render(options2) {
      const templateResult = render4(options2);
      options2 && options2.onRendered && options2.onRendered();
      return templateResult;
    }
  });
};
var addPublicElementNormalization = (template) => {
  const render4 = template.render.bind(template);
  return extend({}, template, {
    render(options2) {
      const $container = renderer_default(options2.container);
      return render4(_extends({}, options2, {
        container: getPublicElement($container)
      }));
    }
  });
};
var getNormalizedTemplateArgs = (options2) => {
  const args = [];
  if ("model" in options2) {
    args.push(options2.model);
  }
  if ("index" in options2) {
    args.push(options2.index);
  }
  args.push(options2.container);
  return args;
};
var validateTemplateSource = (templateSource) => "string" === typeof templateSource ? normalizeTemplateElement(templateSource) : templateSource;
var templateKey = (templateSource) => isRenderer(templateSource) && templateSource[0] || templateSource;
var defaultCreateElement = (element) => new Template(element);
var acquireIntegrationTemplate = (templateSource, templates, isAsyncTemplate, skipTemplates) => {
  let integrationTemplate = null;
  if (!skipTemplates || -1 === skipTemplates.indexOf(templateSource)) {
    integrationTemplate = templates[templateSource];
    if (integrationTemplate && !(integrationTemplate instanceof TemplateBase)) {
      if (isFunction(integrationTemplate.render)) {
        integrationTemplate = addPublicElementNormalization(integrationTemplate);
      }
      if (!isAsyncTemplate) {
        integrationTemplate = addOneRenderedCall(integrationTemplate);
      }
    }
  }
  return integrationTemplate;
};
var acquireTemplate = (templateSource, createTemplate, templates, isAsyncTemplate, skipTemplates, defaultTemplates) => {
  if (null == templateSource) {
    return new EmptyTemplate();
  }
  if (templateSource instanceof ChildDefaultTemplate) {
    return defaultTemplates[templateSource.name];
  }
  if (templateSource instanceof TemplateBase) {
    return templateSource;
  }
  if (isFunction(templateSource.render) && !isRenderer(templateSource)) {
    return isAsyncTemplate ? templateSource : addOneRenderedCall(templateSource);
  }
  if (templateSource.nodeType || isRenderer(templateSource)) {
    return createTemplate(renderer_default(templateSource));
  }
  return acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) || defaultTemplates[templateSource] || createTemplate(templateSource);
};

// ../../../../../../node_modules/devextreme/esm/events/utils/event_nodes_disposing.js
function nodesByEvent(event) {
  return event && [event.target, event.delegateTarget, event.relatedTarget, event.currentTarget].filter((node) => !!node);
}
var subscribeNodesDisposing = (event, callback) => {
  events_engine_default.one(nodesByEvent(event), removeEvent, callback);
};
var unsubscribeNodesDisposing = (event, callback) => {
  events_engine_default.off(nodesByEvent(event), removeEvent, callback);
};

// ../../../../../../node_modules/devextreme/esm/events/pointer/base.js
var BaseStrategy = class_default.inherit({
  ctor: function(eventName, originalEvents) {
    this._eventName = eventName;
    this._originalEvents = addNamespace2(originalEvents, "dxPointerEvents");
    this._handlerCount = 0;
    this.noBubble = this._isNoBubble();
  },
  _isNoBubble: function() {
    const eventName = this._eventName;
    return "dxpointerenter" === eventName || "dxpointerleave" === eventName;
  },
  _handler: function(e) {
    const delegateTarget = this._getDelegateTarget(e);
    const event = {
      type: this._eventName,
      pointerType: e.pointerType || eventSource(e),
      originalEvent: e,
      delegateTarget,
      timeStamp: browser_default.mozilla ? (/* @__PURE__ */ new Date()).getTime() : e.timeStamp
    };
    const target = getEventTarget(e);
    event.target = target;
    return this._fireEvent(event);
  },
  _getDelegateTarget: function(e) {
    let delegateTarget;
    if (this.noBubble) {
      delegateTarget = e.delegateTarget;
    }
    return delegateTarget;
  },
  _fireEvent: function(args) {
    return fireEvent(args);
  },
  _setSelector: function(handleObj) {
    this._selector = this.noBubble && handleObj ? handleObj.selector : null;
  },
  _getSelector: function() {
    return this._selector;
  },
  setup: function() {
    return true;
  },
  add: function(element, handleObj) {
    if (this._handlerCount <= 0 || this.noBubble) {
      element = this.noBubble ? element : dom_adapter_default.getDocument();
      this._setSelector(handleObj);
      const that = this;
      events_engine_default.on(element, this._originalEvents, this._getSelector(), function(e) {
        that._handler(e);
      });
    }
    if (!this.noBubble) {
      this._handlerCount++;
    }
  },
  remove: function(handleObj) {
    this._setSelector(handleObj);
    if (!this.noBubble) {
      this._handlerCount--;
    }
  },
  teardown: function(element) {
    if (this._handlerCount && !this.noBubble) {
      return;
    }
    element = this.noBubble ? element : dom_adapter_default.getDocument();
    if (".dxPointerEvents" !== this._originalEvents) {
      events_engine_default.off(element, this._originalEvents, this._getSelector());
    }
  },
  dispose: function(element) {
    element = this.noBubble ? element : dom_adapter_default.getDocument();
    events_engine_default.off(element, this._originalEvents);
  }
});
var base_default = BaseStrategy;

// ../../../../../../node_modules/devextreme/esm/events/pointer/touch.js
var eventMap = {
  dxpointerdown: "touchstart",
  dxpointermove: "touchmove",
  dxpointerup: "touchend",
  dxpointercancel: "touchcancel",
  dxpointerover: "",
  dxpointerout: "",
  dxpointerenter: "",
  dxpointerleave: ""
};
var normalizeTouchEvent = function(e) {
  const pointers = [];
  each(e.touches, function(_, touch2) {
    pointers.push(extend({
      pointerId: touch2.identifier
    }, touch2));
  });
  return {
    pointers,
    pointerId: e.changedTouches[0].identifier
  };
};
var skipTouchWithSameIdentifier = function(pointerEvent) {
  return "ios" === devices_default.real().platform && ("dxpointerdown" === pointerEvent || "dxpointerup" === pointerEvent);
};
var TouchStrategy = base_default.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    this._pointerId = 0;
  },
  _handler: function(e) {
    if (skipTouchWithSameIdentifier(this._eventName)) {
      const touch2 = e.changedTouches[0];
      if (this._pointerId === touch2.identifier && 0 !== this._pointerId) {
        return;
      }
      this._pointerId = touch2.identifier;
    }
    return this.callBase.apply(this, arguments);
  },
  _fireEvent: function(args) {
    return this.callBase(extend(normalizeTouchEvent(args.originalEvent), args));
  }
});
TouchStrategy.map = eventMap;
TouchStrategy.normalize = normalizeTouchEvent;
var touch_default = TouchStrategy;

// ../../../../../../node_modules/devextreme/esm/events/pointer/observer.js
var addEventsListener = function(events, handler) {
  ready_callbacks_default.add(function() {
    events.split(" ").forEach(function(event) {
      dom_adapter_default.listen(dom_adapter_default.getDocument(), event, handler, true);
    });
  });
};
var Observer = function(eventMap4, pointerEquals, onPointerAdding) {
  onPointerAdding = onPointerAdding || function() {
  };
  let pointers = [];
  const getPointerIndex = function(e) {
    let index2 = -1;
    each(pointers, function(i, pointer2) {
      if (!pointerEquals(e, pointer2)) {
        return true;
      }
      index2 = i;
      return false;
    });
    return index2;
  };
  const removePointer = function(e) {
    const index2 = getPointerIndex(e);
    if (index2 > -1) {
      pointers.splice(index2, 1);
    }
  };
  addEventsListener(eventMap4.dxpointerdown, function(e) {
    if (-1 === getPointerIndex(e)) {
      onPointerAdding(e);
      pointers.push(e);
    }
  });
  addEventsListener(eventMap4.dxpointermove, function(e) {
    pointers[getPointerIndex(e)] = e;
  });
  addEventsListener(eventMap4.dxpointerup, removePointer);
  addEventsListener(eventMap4.dxpointercancel, removePointer);
  this.pointers = function() {
    return pointers;
  };
  this.reset = function() {
    pointers = [];
  };
};
var observer_default = Observer;

// ../../../../../../node_modules/devextreme/esm/events/pointer/mouse.js
var eventMap2 = {
  dxpointerdown: "mousedown",
  dxpointermove: "mousemove",
  dxpointerup: "mouseup",
  dxpointercancel: "",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
var normalizeMouseEvent = function(e) {
  e.pointerId = 1;
  return {
    pointers: observer.pointers(),
    pointerId: 1
  };
};
var observer;
var activated = false;
var activateStrategy = function() {
  if (activated) {
    return;
  }
  observer = new observer_default(eventMap2, function() {
    return true;
  });
  activated = true;
};
var MouseStrategy = base_default.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _fireEvent: function(args) {
    return this.callBase(extend(normalizeMouseEvent(args.originalEvent), args));
  }
});
MouseStrategy.map = eventMap2;
MouseStrategy.normalize = normalizeMouseEvent;
MouseStrategy.activate = activateStrategy;
MouseStrategy.resetObserver = function() {
  observer.reset();
};
var mouse_default = MouseStrategy;

// ../../../../../../node_modules/devextreme/esm/events/pointer/mouse_and_touch.js
var eventMap3 = {
  dxpointerdown: "touchstart mousedown",
  dxpointermove: "touchmove mousemove",
  dxpointerup: "touchend mouseup",
  dxpointercancel: "touchcancel",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
var activated2 = false;
var activateStrategy2 = function() {
  if (activated2) {
    return;
  }
  mouse_default.activate();
  activated2 = true;
};
var MouseAndTouchStrategy = base_default.inherit({
  EVENT_LOCK_TIMEOUT: 100,
  ctor: function() {
    this.callBase.apply(this, arguments);
    activateStrategy2();
  },
  _handler: function(e) {
    const isMouse = isMouseEvent(e);
    if (!isMouse) {
      this._skipNextEvents = true;
    }
    if (isMouse && this._mouseLocked) {
      return;
    }
    if (isMouse && this._skipNextEvents) {
      this._skipNextEvents = false;
      this._mouseLocked = true;
      clearTimeout(this._unlockMouseTimer);
      const that = this;
      this._unlockMouseTimer = setTimeout(function() {
        that._mouseLocked = false;
      }, this.EVENT_LOCK_TIMEOUT);
      return;
    }
    return this.callBase(e);
  },
  _fireEvent: function(args) {
    const normalizer = isMouseEvent(args.originalEvent) ? mouse_default.normalize : touch_default.normalize;
    return this.callBase(extend(normalizer(args.originalEvent), args));
  },
  dispose: function() {
    this.callBase();
    this._skipNextEvents = false;
    this._mouseLocked = false;
    clearTimeout(this._unlockMouseTimer);
  }
});
MouseAndTouchStrategy.map = eventMap3;
MouseAndTouchStrategy.resetObserver = mouse_default.resetObserver;
var mouse_and_touch_default = MouseAndTouchStrategy;

// ../../../../../../node_modules/devextreme/esm/events/pointer.js
var getStrategy = (support, _ref) => {
  let {
    tablet,
    phone
  } = _ref;
  const pointerEventStrategy = getStrategyFromGlobalConfig();
  if (pointerEventStrategy) {
    return pointerEventStrategy;
  }
  if (support.touch && !(tablet || phone)) {
    return mouse_and_touch_default;
  }
  if (support.touch) {
    return touch_default;
  }
  return mouse_default;
};
var EventStrategy = getStrategy(support_exports, devices_default.real());
each(EventStrategy.map, (pointerEvent, originalEvents) => {
  event_registrator_default(pointerEvent, new EventStrategy(pointerEvent, originalEvents));
});
var pointer = {
  down: "dxpointerdown",
  up: "dxpointerup",
  move: "dxpointermove",
  cancel: "dxpointercancel",
  enter: "dxpointerenter",
  leave: "dxpointerleave",
  over: "dxpointerover",
  out: "dxpointerout"
};
function getStrategyFromGlobalConfig() {
  const eventStrategyName = config_default().pointerEventStrategy;
  return {
    "mouse-and-touch": mouse_and_touch_default,
    touch: touch_default,
    mouse: mouse_default
  }[eventStrategyName];
}
var pointer_default = pointer;

// ../../../../../../node_modules/devextreme/esm/events/core/emitter.js
var Emitter = class_default.inherit({
  ctor: function(element) {
    this._$element = renderer_default(element);
    this._cancelCallback = callbacks_default();
    this._acceptCallback = callbacks_default();
  },
  getElement: function() {
    return this._$element;
  },
  validate: function(e) {
    return !isDxMouseWheelEvent(e);
  },
  validatePointers: function(e) {
    return 1 === hasTouches(e);
  },
  allowInterruptionByMouseWheel: function() {
    return true;
  },
  configure: function(data2) {
    extend(this, data2);
  },
  addCancelCallback: function(callback) {
    this._cancelCallback.add(callback);
  },
  removeCancelCallback: function() {
    this._cancelCallback.empty();
  },
  _cancel: function(e) {
    this._cancelCallback.fire(this, e);
  },
  addAcceptCallback: function(callback) {
    this._acceptCallback.add(callback);
  },
  removeAcceptCallback: function() {
    this._acceptCallback.empty();
  },
  _accept: function(e) {
    this._acceptCallback.fire(this, e);
  },
  _requestAccept: function(e) {
    this._acceptRequestEvent = e;
  },
  _forgetAccept: function() {
    this._accept(this._acceptRequestEvent);
    this._acceptRequestEvent = null;
  },
  start: noop2,
  move: noop2,
  end: noop2,
  cancel: noop2,
  reset: function() {
    if (this._acceptRequestEvent) {
      this._accept(this._acceptRequestEvent);
    }
  },
  _fireEvent: function(eventName, e, params) {
    const eventData2 = extend({
      type: eventName,
      originalEvent: e,
      target: this._getEmitterTarget(e),
      delegateTarget: this.getElement().get(0)
    }, params);
    e = fireEvent(eventData2);
    if (e.cancel) {
      this._cancel(e);
    }
    return e;
  },
  _getEmitterTarget: function(e) {
    return (this.delegateSelector ? renderer_default(e.target).closest(this.delegateSelector) : this.getElement()).get(0);
  },
  dispose: noop2
});
var emitter_default = Emitter;

// ../../../../../../node_modules/devextreme/esm/events/core/wheel.js
var EVENT_NAME = "dxmousewheel";
var wheel = {
  setup: function(element) {
    const $element = renderer_default(element);
    events_engine_default.on($element, addNamespace2("wheel", "dxWheel"), wheel._wheelHandler.bind(wheel));
  },
  teardown: function(element) {
    events_engine_default.off(element, ".dxWheel");
  },
  _wheelHandler: function(e) {
    const {
      deltaMode,
      deltaY,
      deltaX,
      deltaZ
    } = e.originalEvent;
    fireEvent({
      type: EVENT_NAME,
      originalEvent: e,
      delta: this._normalizeDelta(deltaY, deltaMode),
      deltaX,
      deltaY,
      deltaZ,
      deltaMode,
      pointerType: "mouse"
    });
    e.stopPropagation();
  },
  _normalizeDelta(delta) {
    let deltaMode = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (0 === deltaMode) {
      return -delta;
    } else {
      return -30 * delta;
    }
  }
};
event_registrator_default(EVENT_NAME, wheel);

// ../../../../../../node_modules/devextreme/esm/events/core/emitter_registrator.js
var MANAGER_EVENT = "dxEventManager";
var EventManager = class_default.inherit({
  ctor: function() {
    this._attachHandlers();
    this.reset();
    this._proxiedCancelHandler = this._cancelHandler.bind(this);
    this._proxiedAcceptHandler = this._acceptHandler.bind(this);
  },
  _attachHandlers: function() {
    ready_callbacks_default.add((function() {
      const document2 = dom_adapter_default.getDocument();
      events_engine_default.subscribeGlobal(document2, addNamespace2(pointer_default.down, MANAGER_EVENT), this._pointerDownHandler.bind(this));
      events_engine_default.subscribeGlobal(document2, addNamespace2(pointer_default.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this));
      events_engine_default.subscribeGlobal(document2, addNamespace2([pointer_default.up, pointer_default.cancel].join(" "), MANAGER_EVENT), this._pointerUpHandler.bind(this));
      events_engine_default.subscribeGlobal(document2, addNamespace2(EVENT_NAME, MANAGER_EVENT), this._mouseWheelHandler.bind(this));
    }).bind(this));
  },
  _eachEmitter: function(callback) {
    const activeEmitters = this._activeEmitters || [];
    let i = 0;
    while (activeEmitters.length > i) {
      const emitter = activeEmitters[i];
      if (false === callback(emitter)) {
        break;
      }
      if (activeEmitters[i] === emitter) {
        i++;
      }
    }
  },
  _applyToEmitters: function(method, arg) {
    this._eachEmitter(function(emitter) {
      emitter[method].call(emitter, arg);
    });
  },
  reset: function() {
    this._eachEmitter(this._proxiedCancelHandler);
    this._activeEmitters = [];
  },
  resetEmitter: function(emitter) {
    this._proxiedCancelHandler(emitter);
  },
  _pointerDownHandler: function(e) {
    if (isMouseEvent(e) && e.which > 1) {
      return;
    }
    this._updateEmitters(e);
  },
  _updateEmitters: function(e) {
    if (!this._isSetChanged(e)) {
      return;
    }
    this._cleanEmitters(e);
    this._fetchEmitters(e);
  },
  _isSetChanged: function(e) {
    const currentSet = this._closestEmitter(e);
    const previousSet = this._emittersSet || [];
    let setChanged = currentSet.length !== previousSet.length;
    each(currentSet, function(index2, emitter) {
      setChanged = setChanged || previousSet[index2] !== emitter;
      return !setChanged;
    });
    this._emittersSet = currentSet;
    return setChanged;
  },
  _closestEmitter: function(e) {
    const that = this;
    const result2 = [];
    let $element = renderer_default(e.target);
    function handleEmitter(_, emitter) {
      if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
        emitter.addCancelCallback(that._proxiedCancelHandler);
        emitter.addAcceptCallback(that._proxiedAcceptHandler);
        result2.push(emitter);
      }
    }
    while ($element.length) {
      const emitters = data($element.get(0), "dxEmitter") || [];
      each(emitters, handleEmitter);
      $element = $element.parent();
    }
    return result2;
  },
  _acceptHandler: function(acceptedEmitter, e) {
    const that = this;
    this._eachEmitter(function(emitter) {
      if (emitter !== acceptedEmitter) {
        that._cancelEmitter(emitter, e);
      }
    });
  },
  _cancelHandler: function(canceledEmitter, e) {
    this._cancelEmitter(canceledEmitter, e);
  },
  _cancelEmitter: function(emitter, e) {
    const activeEmitters = this._activeEmitters;
    if (e) {
      emitter.cancel(e);
    } else {
      emitter.reset();
    }
    emitter.removeCancelCallback();
    emitter.removeAcceptCallback();
    const emitterIndex = activeEmitters.indexOf(emitter);
    if (emitterIndex > -1) {
      activeEmitters.splice(emitterIndex, 1);
    }
  },
  _cleanEmitters: function(e) {
    this._applyToEmitters("end", e);
    this.reset(e);
  },
  _fetchEmitters: function(e) {
    this._activeEmitters = this._emittersSet.slice();
    this._applyToEmitters("start", e);
  },
  _pointerMoveHandler: function(e) {
    this._applyToEmitters("move", e);
  },
  _pointerUpHandler: function(e) {
    this._updateEmitters(e);
  },
  _mouseWheelHandler: function(e) {
    if (!this._allowInterruptionByMouseWheel()) {
      return;
    }
    e.pointers = [null];
    this._pointerDownHandler(e);
    this._adjustWheelEvent(e);
    this._pointerMoveHandler(e);
    e.pointers = [];
    this._pointerUpHandler(e);
  },
  _allowInterruptionByMouseWheel: function() {
    let allowInterruption = true;
    this._eachEmitter(function(emitter) {
      allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
      return allowInterruption;
    });
    return allowInterruption;
  },
  _adjustWheelEvent: function(e) {
    let closestGestureEmitter = null;
    this._eachEmitter(function(emitter) {
      if (!emitter.gesture) {
        return;
      }
      const direction2 = emitter.getDirection(e);
      if ("horizontal" !== direction2 && !e.shiftKey || "vertical" !== direction2 && e.shiftKey) {
        closestGestureEmitter = emitter;
        return false;
      }
    });
    if (!closestGestureEmitter) {
      return;
    }
    const direction = closestGestureEmitter.getDirection(e);
    const verticalGestureDirection = "both" === direction && !e.shiftKey || "vertical" === direction;
    const prop = verticalGestureDirection ? "pageY" : "pageX";
    e[prop] += e.delta;
  },
  isActive: function(element) {
    let result2 = false;
    this._eachEmitter(function(emitter) {
      result2 = result2 || emitter.getElement().is(element);
    });
    return result2;
  }
});
var eventManager = new EventManager();
var registerEmitter = function(emitterConfig) {
  const emitterClass = emitterConfig.emitter;
  const emitterName = emitterConfig.events[0];
  const emitterEvents = emitterConfig.events;
  each(emitterEvents, function(_, eventName) {
    event_registrator_default(eventName, {
      noBubble: !emitterConfig.bubble,
      setup: function(element) {
        const subscriptions = data(element, "dxEmitterSubscription") || {};
        const emitters = data(element, "dxEmitter") || {};
        const emitter = emitters[emitterName] || new emitterClass(element);
        subscriptions[eventName] = true;
        emitters[emitterName] = emitter;
        data(element, "dxEmitter", emitters);
        data(element, "dxEmitterSubscription", subscriptions);
      },
      add: function(element, handleObj) {
        const emitters = data(element, "dxEmitter");
        const emitter = emitters[emitterName];
        emitter.configure(extend({
          delegateSelector: handleObj.selector
        }, handleObj.data), handleObj.type);
      },
      teardown: function(element) {
        const subscriptions = data(element, "dxEmitterSubscription");
        const emitters = data(element, "dxEmitter");
        const emitter = emitters[emitterName];
        delete subscriptions[eventName];
        let disposeEmitter = true;
        each(emitterEvents, function(_2, eventName2) {
          disposeEmitter = disposeEmitter && !subscriptions[eventName2];
          return disposeEmitter;
        });
        if (disposeEmitter) {
          if (eventManager.isActive(element)) {
            eventManager.resetEmitter(emitter);
          }
          emitter && emitter.dispose();
          delete emitters[emitterName];
        }
      }
    });
  });
};
var emitter_registrator_default = registerEmitter;

// ../../../../../../node_modules/devextreme/esm/events/click.js
var CLICK_EVENT_NAME = "dxclick";
var prevented = null;
var lastFiredEvent = null;
var onNodeRemove = () => {
  lastFiredEvent = null;
};
var clickHandler = function(e) {
  const originalEvent = e.originalEvent;
  const eventAlreadyFired = lastFiredEvent === originalEvent || originalEvent && originalEvent.DXCLICK_FIRED;
  const leftButton = !e.which || 1 === e.which;
  if (leftButton && !prevented && !eventAlreadyFired) {
    if (originalEvent) {
      originalEvent.DXCLICK_FIRED = true;
    }
    unsubscribeNodesDisposing(lastFiredEvent, onNodeRemove);
    lastFiredEvent = originalEvent;
    subscribeNodesDisposing(lastFiredEvent, onNodeRemove);
    fireEvent({
      type: "dxclick",
      originalEvent: e
    });
  }
};
var ClickEmitter = emitter_default.inherit({
  ctor: function(element) {
    this.callBase(element);
    events_engine_default.on(this.getElement(), "click", clickHandler);
  },
  start: function(e) {
    prevented = null;
  },
  cancel: function() {
    prevented = true;
  },
  dispose: function() {
    events_engine_default.off(this.getElement(), "click", clickHandler);
  }
});
!function() {
  const desktopDevice = devices_default.real().generic;
  if (!desktopDevice) {
    let startTarget = null;
    let blurPrevented = false;
    const isInput = function(element) {
      return renderer_default(element).is("input, textarea, select, button ,:focus, :focus *");
    };
    const pointerDownHandler = function(e) {
      startTarget = e.target;
      blurPrevented = e.isDefaultPrevented();
    };
    const getTarget = function(e) {
      const target = getEventTarget(e);
      return renderer_default(target);
    };
    const clickHandler2 = function(e) {
      const $target = getTarget(e);
      if (!blurPrevented && startTarget && !$target.is(startTarget) && !renderer_default(startTarget).is("label") && isInput($target)) {
        resetActiveElement();
      }
      startTarget = null;
      blurPrevented = false;
    };
    const NATIVE_CLICK_FIXER_NAMESPACE = "NATIVE_CLICK_FIXER";
    const document2 = dom_adapter_default.getDocument();
    events_engine_default.subscribeGlobal(document2, addNamespace2(pointer_default.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler);
    events_engine_default.subscribeGlobal(document2, addNamespace2("click", NATIVE_CLICK_FIXER_NAMESPACE), clickHandler2);
  }
}();
emitter_registrator_default({
  emitter: ClickEmitter,
  bubble: true,
  events: ["dxclick"]
});

// ../../../../../../node_modules/devextreme/esm/events/hold.js
var abs = Math.abs;
var HoldEmitter = emitter_default.inherit({
  start: function(e) {
    this._startEventData = eventData(e);
    this._startTimer(e);
  },
  _startTimer: function(e) {
    const holdTimeout = "timeout" in this ? this.timeout : 750;
    this._holdTimer = setTimeout((function() {
      this._requestAccept(e);
      this._fireEvent("dxhold", e, {
        target: e.target
      });
      this._forgetAccept();
    }).bind(this), holdTimeout);
  },
  move: function(e) {
    if (this._touchWasMoved(e)) {
      this._cancel(e);
    }
  },
  _touchWasMoved: function(e) {
    const delta = eventDelta(this._startEventData, eventData(e));
    return abs(delta.x) > 5 || abs(delta.y) > 5;
  },
  end: function() {
    this._stopTimer();
  },
  _stopTimer: function() {
    clearTimeout(this._holdTimer);
  },
  cancel: function() {
    this._stopTimer();
  },
  dispose: function() {
    this._stopTimer();
  }
});
emitter_registrator_default({
  emitter: HoldEmitter,
  bubble: true,
  events: ["dxhold"]
});
var hold_default = {
  name: "dxhold"
};

// ../../../../../../node_modules/devextreme/esm/events/contextmenu.js
var CONTEXTMENU_NAMESPACED_EVENT_NAME = addNamespace2("contextmenu", "dxContexMenu");
var HOLD_NAMESPACED_EVENT_NAME = addNamespace2(hold_default.name, "dxContexMenu");
var ContextMenu = class_default.inherit({
  setup: function(element) {
    const $element = renderer_default(element);
    events_engine_default.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
    if (touch || devices_default.isSimulator()) {
      events_engine_default.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this));
    }
  },
  _holdHandler: function(e) {
    if (isMouseEvent(e) && !devices_default.isSimulator()) {
      return;
    }
    this._fireContextMenu(e);
  },
  _contextMenuHandler: function(e) {
    this._fireContextMenu(e);
  },
  _fireContextMenu: function(e) {
    return fireEvent({
      type: "dxcontextmenu",
      originalEvent: e
    });
  },
  teardown: function(element) {
    events_engine_default.off(element, ".dxContexMenu");
  }
});
event_registrator_default("dxcontextmenu", new ContextMenu());
var name = "dxcontextmenu";

// ../../../../../../node_modules/devextreme/esm/core/utils/comparator.js
var hasNegation = function(oldValue, newValue) {
  return 1 / oldValue === 1 / newValue;
};
var equals = function(oldValue, newValue) {
  oldValue = toComparable(oldValue, true);
  newValue = toComparable(newValue, true);
  if (oldValue && newValue && isRenderer(oldValue) && isRenderer(newValue)) {
    return newValue.is(oldValue);
  }
  const oldValueIsNaN = oldValue !== oldValue;
  const newValueIsNaN = newValue !== newValue;
  if (oldValueIsNaN && newValueIsNaN) {
    return true;
  }
  if (0 === oldValue && 0 === newValue) {
    return hasNegation(oldValue, newValue);
  }
  if (null === oldValue || "object" !== typeof oldValue || dom_adapter_default.isElementNode(oldValue)) {
    return oldValue === newValue;
  }
  return false;
};

// ../../../../../../node_modules/devextreme/esm/core/options/utils.js
var cachedGetters = {};
var convertRulesToOptions = (rules) => {
  const currentDevice = devices_default.current();
  return rules.reduce((options2, _ref) => {
    let {
      device,
      options: ruleOptions
    } = _ref;
    const deviceFilter = device || {};
    const match2 = isFunction(deviceFilter) ? deviceFilter(currentDevice) : deviceMatch(currentDevice, deviceFilter);
    if (match2) {
      extend(true, options2, ruleOptions);
    }
    return options2;
  }, {});
};
var normalizeOptions = (options2, value2) => "string" !== typeof options2 ? options2 : {
  [options2]: value2
};
var deviceMatch = (device, filter) => isEmptyObject(filter) || findBestMatches(device, [filter]).length > 0;
var getFieldName = (fullName) => fullName.substr(fullName.lastIndexOf(".") + 1);
var getParentName = (fullName) => fullName.substr(0, fullName.lastIndexOf("."));
var getNestedOptionValue = function(optionsObject, name2) {
  cachedGetters[name2] = cachedGetters[name2] || compileGetter(name2);
  return cachedGetters[name2](optionsObject, {
    functionsAsIs: true
  });
};
var createDefaultOptionRules = function() {
  let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  return options2;
};

// ../../../../../../node_modules/devextreme/esm/core/options/option_manager.js
var cachedGetters2 = {};
var cachedSetters = {};
var OptionManager = class {
  constructor(options2, optionsByReference) {
    this._options = options2;
    this._optionsByReference = optionsByReference;
    this._changingCallback;
    this._changedCallback;
    this._namePreparedCallbacks;
  }
  _setByReference(options2, rulesOptions) {
    extend(true, options2, rulesOptions);
    for (const fieldName in this._optionsByReference) {
      if (Object.prototype.hasOwnProperty.call(rulesOptions, fieldName)) {
        options2[fieldName] = rulesOptions[fieldName];
      }
    }
  }
  _setPreparedValue(name2, value2, merge, silent) {
    const previousValue = this.get(this._options, name2, false);
    if (!equals(previousValue, value2)) {
      const path = getPathParts(name2);
      !silent && this._changingCallback(name2, previousValue, value2);
      cachedSetters[name2] = cachedSetters[name2] || compileSetter(name2);
      cachedSetters[name2](this._options, value2, {
        functionsAsIs: true,
        merge: isDefined(merge) ? merge : !this._optionsByReference[name2],
        unwrapObservables: path.length > 1 && !!this._optionsByReference[path[0]]
      });
      !silent && this._changedCallback(name2, value2, previousValue);
    }
  }
  _prepareRelevantNames(options2, name2, value2, silent) {
    if (isPlainObject(value2)) {
      for (const valueName in value2) {
        this._prepareRelevantNames(options2, `${name2}.${valueName}`, value2[valueName]);
      }
    }
    this._namePreparedCallbacks(options2, name2, value2, silent);
  }
  get() {
    let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._options;
    let name2 = arguments.length > 1 ? arguments[1] : void 0;
    let unwrapObservables = arguments.length > 2 ? arguments[2] : void 0;
    cachedGetters2[name2] = cachedGetters2[name2] || compileGetter(name2);
    return cachedGetters2[name2](options2, {
      functionsAsIs: true,
      unwrapObservables
    });
  }
  set(options2, value2, merge, silent) {
    options2 = normalizeOptions(options2, value2);
    for (const name2 in options2) {
      this._prepareRelevantNames(options2, name2, options2[name2], silent);
    }
    for (const name2 in options2) {
      this._setPreparedValue(name2, options2[name2], merge, silent);
    }
  }
  onRelevantNamesPrepared(callBack) {
    this._namePreparedCallbacks = callBack;
  }
  onChanging(callBack) {
    this._changingCallback = callBack;
  }
  onChanged(callBack) {
    this._changedCallback = callBack;
  }
  dispose() {
    this._changingCallback = noop2;
    this._changedCallback = noop2;
  }
};

// ../../../../../../node_modules/devextreme/esm/core/options/index.js
var Options = class {
  constructor(options2, defaultOptions3, optionsByReference, deprecatedOptions) {
    this._deprecatedCallback;
    this._startChangeCallback;
    this._endChangeCallback;
    this._default = defaultOptions3;
    this._deprecated = deprecatedOptions;
    this._deprecatedNames = [];
    this._initDeprecatedNames();
    this._optionManager = new OptionManager(options2, optionsByReference);
    this._optionManager.onRelevantNamesPrepared((options3, name2, value2, silent) => this._setRelevantNames(options3, name2, value2, silent));
    this._cachedOptions = {};
    this._rules = [];
  }
  set _initial(value2) {
    this._initialOptions = value2;
  }
  get _initial() {
    if (!this._initialOptions) {
      const rulesOptions = this._getByRules(this.silent("defaultOptionsRules"));
      this._initialOptions = this._default;
      this._optionManager._setByReference(this._initialOptions, rulesOptions);
    }
    return this._initialOptions;
  }
  _initDeprecatedNames() {
    for (const optionName in this._deprecated) {
      this._deprecatedNames.push(optionName);
    }
  }
  _getByRules(rules) {
    rules = Array.isArray(rules) ? this._rules.concat(rules) : this._rules;
    return convertRulesToOptions(rules);
  }
  _notifyDeprecated(option) {
    const info = this._deprecated[option];
    if (info) {
      this._deprecatedCallback(option, info);
    }
  }
  _setRelevantNames(options2, name2, value2, silent) {
    if (name2) {
      const normalizedName = this._normalizeName(name2, silent);
      if (normalizedName && normalizedName !== name2) {
        this._setField(options2, normalizedName, value2);
        this._clearField(options2, name2);
      }
    }
  }
  _setField(options2, fullName, value2) {
    let fieldName = "";
    let fieldObject = null;
    do {
      fieldName = fieldName ? `.${fieldName}` : "";
      fieldName = getFieldName(fullName) + fieldName;
      fullName = getParentName(fullName);
      fieldObject = fullName ? this._optionManager.get(options2, fullName, false) : options2;
    } while (!fieldObject);
    fieldObject[fieldName] = value2;
  }
  _clearField(options2, name2) {
    delete options2[name2];
    const previousFieldName = getParentName(name2);
    const fieldObject = previousFieldName ? this._optionManager.get(options2, previousFieldName, false) : options2;
    if (fieldObject) {
      delete fieldObject[getFieldName(name2)];
    }
  }
  _normalizeName(name2, silent) {
    if (this._deprecatedNames.length && name2) {
      for (let i = 0; i < this._deprecatedNames.length; i++) {
        if (this._deprecatedNames[i] === name2) {
          const deprecate = this._deprecated[name2];
          if (deprecate) {
            !silent && this._notifyDeprecated(name2);
            return deprecate.alias || name2;
          }
        }
      }
    }
    return name2;
  }
  addRules(rules) {
    this._rules = rules.concat(this._rules);
  }
  applyRules(rules) {
    const options2 = this._getByRules(rules);
    this.silent(options2);
  }
  dispose() {
    this._deprecatedCallback = noop2;
    this._startChangeCallback = noop2;
    this._endChangeCallback = noop2;
    this._optionManager.dispose();
  }
  onChanging(callBack) {
    this._optionManager.onChanging(callBack);
  }
  onChanged(callBack) {
    this._optionManager.onChanged(callBack);
  }
  onDeprecated(callBack) {
    this._deprecatedCallback = callBack;
  }
  onStartChange(callBack) {
    this._startChangeCallback = callBack;
  }
  onEndChange(callBack) {
    this._endChangeCallback = callBack;
  }
  isInitial(name2) {
    const value2 = this.silent(name2);
    const initialValue = this.initial(name2);
    const areFunctions = isFunction(value2) && isFunction(initialValue);
    return areFunctions ? value2.toString() === initialValue.toString() : equalByValue(value2, initialValue);
  }
  initial(name2) {
    return getNestedOptionValue(this._initial, name2);
  }
  option(options2, value2) {
    const isGetter = arguments.length < 2 && "object" !== type(options2);
    if (isGetter) {
      return this._optionManager.get(void 0, this._normalizeName(options2));
    } else {
      this._startChangeCallback();
      try {
        this._optionManager.set(options2, value2);
      } finally {
        this._endChangeCallback();
      }
    }
  }
  silent(options2, value2) {
    const isGetter = arguments.length < 2 && "object" !== type(options2);
    if (isGetter) {
      return this._optionManager.get(void 0, options2, void 0, true);
    } else {
      this._optionManager.set(options2, value2, void 0, true);
    }
  }
  reset(name2) {
    if (name2) {
      const fullPath = getPathParts(name2);
      const value2 = fullPath.reduce((value3, field) => value3 ? value3[field] : this.initial(field), null);
      const defaultValue = isObject(value2) ? _extends({}, value2) : value2;
      this._optionManager.set(name2, defaultValue, false);
    }
  }
  getAliasesByName(name2) {
    return Object.keys(this._deprecated).filter((aliasName) => name2 === this._deprecated[aliasName].alias);
  }
  isDeprecated(name2) {
    return Object.prototype.hasOwnProperty.call(this._deprecated, name2);
  }
  cache(name2, options2) {
    const isGetter = arguments.length < 2;
    if (isGetter) {
      return this._cachedOptions[name2];
    } else {
      this._cachedOptions[name2] = extend(this._cachedOptions[name2], options2);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/core/postponed_operations.js
var PostponedOperations = class {
  constructor() {
    this._postponedOperations = {};
  }
  add(key, fn, postponedPromise) {
    if (key in this._postponedOperations) {
      postponedPromise && this._postponedOperations[key].promises.push(postponedPromise);
    } else {
      const completePromise = new Deferred();
      this._postponedOperations[key] = {
        fn,
        completePromise,
        promises: postponedPromise ? [postponedPromise] : []
      };
    }
    return this._postponedOperations[key].completePromise.promise();
  }
  callPostponedOperations() {
    for (const key in this._postponedOperations) {
      const operation = this._postponedOperations[key];
      if (isDefined(operation)) {
        if (operation.promises && operation.promises.length) {
          when(...operation.promises).done(operation.fn).then(operation.completePromise.resolve);
        } else {
          operation.fn().done(operation.completePromise.resolve);
        }
      }
    }
    this._postponedOperations = {};
  }
};

// ../../../../../../node_modules/devextreme/esm/core/component.js
var getEventName = (actionName) => actionName.charAt(2).toLowerCase() + actionName.substr(3);
var isInnerOption = (optionName) => 0 === optionName.indexOf("_", 0);
var Component = class_default.inherit({
  _setDeprecatedOptions() {
    this._deprecatedOptions = {};
  },
  _getDeprecatedOptions() {
    return this._deprecatedOptions;
  },
  _getDefaultOptions: () => ({
    onInitialized: null,
    onOptionChanged: null,
    onDisposing: null,
    defaultOptionsRules: null
  }),
  _defaultOptionsRules: () => [],
  _setOptionsByDevice(rules) {
    this._options.applyRules(rules);
  },
  _convertRulesToOptions: (rules) => convertRulesToOptions(rules),
  _isInitialOptionValue(name2) {
    return this._options.isInitial(name2);
  },
  _setOptionsByReference() {
    this._optionsByReference = {};
  },
  _getOptionsByReference() {
    return this._optionsByReference;
  },
  ctor() {
    let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const {
      _optionChangedCallbacks,
      _disposingCallbacks
    } = options2;
    this.NAME = getName(this.constructor);
    this._eventsStrategy = EventsStrategy.create(this, options2.eventsStrategy);
    this._updateLockCount = 0;
    this._optionChangedCallbacks = _optionChangedCallbacks || callbacks_default();
    this._disposingCallbacks = _disposingCallbacks || callbacks_default();
    this.postponedOperations = new PostponedOperations();
    this._createOptions(options2);
  },
  _createOptions(options2) {
    this.beginUpdate();
    try {
      this._setOptionsByReference();
      this._setDeprecatedOptions();
      this._options = new Options(this._getDefaultOptions(), this._getDefaultOptions(), this._getOptionsByReference(), this._getDeprecatedOptions());
      this._options.onChanging((name2, previousValue, value2) => this._initialized && this._optionChanging(name2, previousValue, value2));
      this._options.onDeprecated((option, info) => this._logDeprecatedOptionWarning(option, info));
      this._options.onChanged((name2, value2, previousValue) => this._notifyOptionChanged(name2, value2, previousValue));
      this._options.onStartChange(() => this.beginUpdate());
      this._options.onEndChange(() => this.endUpdate());
      this._options.addRules(this._defaultOptionsRules());
      if (options2 && options2.onInitializing) {
        options2.onInitializing.apply(this, [options2]);
      }
      this._setOptionsByDevice(options2.defaultOptionsRules);
      this._initOptions(options2);
    } finally {
      this.endUpdate();
    }
  },
  _initOptions(options2) {
    this.option(options2);
  },
  _init() {
    this._createOptionChangedAction();
    this.on("disposing", (args) => {
      this._disposingCallbacks.fireWith(this, [args]);
    });
  },
  _logDeprecatedOptionWarning(option, info) {
    const message = info.message || `Use the '${info.alias}' option instead`;
    errors_default.log("W0001", this.NAME, option, info.since, message);
  },
  _logDeprecatedComponentWarning(since, alias) {
    errors_default.log("W0000", this.NAME, since, `Use the '${alias}' widget instead`);
  },
  _createOptionChangedAction() {
    this._optionChangedAction = this._createActionByOption("onOptionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _createDisposingAction() {
    this._disposingAction = this._createActionByOption("onDisposing", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _optionChanged(args) {
    switch (args.name) {
      case "onDisposing":
      case "onInitialized":
      case "defaultOptionsRules":
        break;
      case "onOptionChanged":
        this._createOptionChangedAction();
    }
  },
  _dispose() {
    this._optionChangedCallbacks.empty();
    this._createDisposingAction();
    this._disposingAction();
    this._eventsStrategy.dispose();
    this._options.dispose();
    this._disposed = true;
  },
  _lockUpdate() {
    this._updateLockCount++;
  },
  _unlockUpdate() {
    this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
  },
  _isUpdateAllowed() {
    return 0 === this._updateLockCount;
  },
  _isInitializingRequired() {
    return !this._initializing && !this._initialized;
  },
  isInitialized() {
    return this._initialized;
  },
  _commitUpdate() {
    this.postponedOperations.callPostponedOperations();
    this._isInitializingRequired() && this._initializeComponent();
  },
  _initializeComponent() {
    this._initializing = true;
    try {
      this._init();
    } finally {
      this._initializing = false;
      this._lockUpdate();
      this._createActionByOption("onInitialized", {
        excludeValidators: ["disabled", "readOnly"]
      })();
      this._unlockUpdate();
      this._initialized = true;
    }
  },
  instance() {
    return this;
  },
  beginUpdate: function() {
    this._lockUpdate();
  },
  endUpdate: function() {
    this._unlockUpdate();
    this._isUpdateAllowed() && this._commitUpdate();
  },
  _optionChanging: noop2,
  _notifyOptionChanged(option, value2, previousValue) {
    if (this._initialized) {
      const optionNames = [option].concat(this._options.getAliasesByName(option));
      for (let i = 0; i < optionNames.length; i++) {
        const name2 = optionNames[i];
        const args = {
          name: getPathParts(name2)[0],
          fullName: name2,
          value: value2,
          previousValue
        };
        if (!isInnerOption(name2)) {
          this._optionChangedCallbacks.fireWith(this, [extend(this._defaultActionArgs(), args)]);
          this._optionChangedAction(extend({}, args));
        }
        if (!this._disposed && this._cancelOptionChange !== name2) {
          this._optionChanged(args);
        }
      }
    }
  },
  initialOption(name2) {
    return this._options.initial(name2);
  },
  _defaultActionConfig() {
    return {
      context: this,
      component: this
    };
  },
  _defaultActionArgs() {
    return {
      component: this
    };
  },
  _createAction(actionSource, config3) {
    let action;
    return (e) => {
      if (!isDefined(e)) {
        e = {};
      }
      if (!isPlainObject(e)) {
        e = {
          actionValue: e
        };
      }
      action = action || new Action(actionSource, extend({}, config3, this._defaultActionConfig()));
      return action.execute.call(action, extend(e, this._defaultActionArgs()));
    };
  },
  _createActionByOption(optionName, config3) {
    var _this = this;
    let action;
    let eventName;
    let actionFunc;
    config3 = extend({}, config3);
    const result2 = function() {
      if (!eventName) {
        config3 = config3 || {};
        if ("string" !== typeof optionName) {
          throw errors_default.Error("E0008");
        }
        if (0 === optionName.indexOf("on")) {
          eventName = getEventName(optionName);
        }
        actionFunc = _this.option(optionName);
      }
      if (!action && !actionFunc && !config3.beforeExecute && !config3.afterExecute && !_this._eventsStrategy.hasEvent(eventName)) {
        return;
      }
      if (!action) {
        const beforeExecute = config3.beforeExecute;
        config3.beforeExecute = function() {
          for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            props[_key2] = arguments[_key2];
          }
          beforeExecute && beforeExecute.apply(_this, props);
          _this._eventsStrategy.fireEvent(eventName, props[0].args);
        };
        action = _this._createAction(actionFunc, config3);
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (config_default().wrapActionsBeforeExecute) {
        const beforeActionExecute = _this.option("beforeActionExecute") || noop2;
        const wrappedAction = beforeActionExecute(_this, action, config3) || action;
        return wrappedAction.apply(_this, args);
      }
      return action.apply(_this, args);
    };
    if (config_default().wrapActionsBeforeExecute) {
      return result2;
    }
    const onActionCreated = this.option("onActionCreated") || noop2;
    return onActionCreated(this, result2, config3) || result2;
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  },
  hasActionSubscription: function(actionName) {
    return !!this._options.silent(actionName) || this._eventsStrategy.hasEvent(getEventName(actionName));
  },
  isOptionDeprecated(name2) {
    return this._options.isDeprecated(name2);
  },
  _setOptionWithoutOptionChange(name2, value2) {
    this._cancelOptionChange = name2;
    this.option(name2, value2);
    this._cancelOptionChange = false;
  },
  _getOptionValue(name2, context2) {
    const value2 = this.option(name2);
    if (isFunction(value2)) {
      return value2.bind(context2)();
    }
    return value2;
  },
  option() {
    return this._options.option(...arguments);
  },
  resetOption(name2) {
    this.beginUpdate();
    this._options.reset(name2);
    this.endUpdate();
  }
});

// ../../../../../../node_modules/devextreme/esm/core/templates/function_template.js
var FunctionTemplate = class extends TemplateBase {
  constructor(render4) {
    super();
    this._render = render4;
  }
  _renderCore(options2) {
    return normalizeTemplateElement(this._render(options2));
  }
};

// ../../../../../../node_modules/devextreme/esm/core/template_manager.js
var DX_POLYMORPH_WIDGET_TEMPLATE = new FunctionTemplate((_ref) => {
  let {
    model,
    parent
  } = _ref;
  const widgetName = model.widget;
  if (!widgetName) {
    return renderer_default();
  }
  const widgetElement = renderer_default("<div>");
  const widgetOptions = model.options || {};
  if (parent) {
    parent._createComponent(widgetElement, widgetName, widgetOptions);
  } else {
    widgetElement[widgetName](widgetOptions);
  }
  return widgetElement;
});
var TemplateManager = class {
  constructor(createElement2, anonymousTemplateName) {
    this._tempTemplates = [];
    this._defaultTemplates = {};
    this._anonymousTemplateName = anonymousTemplateName || "template";
    this._createElement = createElement2 || defaultCreateElement;
    this._createTemplateIfNeeded = this._createTemplateIfNeeded.bind(this);
  }
  static createDefaultOptions() {
    return {
      integrationOptions: {
        watchMethod: function(fn, callback) {
          let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          if (!options2.skipImmediate) {
            callback(fn());
          }
          return noop2;
        },
        templates: {
          "dx-polymorph-widget": DX_POLYMORPH_WIDGET_TEMPLATE
        },
        useDeferUpdateForTemplates: true
      }
    };
  }
  get anonymousTemplateName() {
    return this._anonymousTemplateName;
  }
  addDefaultTemplates(templates) {
    this._defaultTemplates = extend({}, this._defaultTemplates, templates);
  }
  dispose() {
    this._tempTemplates.forEach((tempTemplate) => {
      tempTemplate.template.dispose && tempTemplate.template.dispose();
    });
    this._tempTemplates = [];
  }
  extractTemplates($el) {
    const templates = this._extractTemplates($el);
    const anonymousTemplateMeta = this._extractAnonymousTemplate($el);
    return {
      templates,
      anonymousTemplateMeta
    };
  }
  _extractTemplates($el) {
    const templates = findTemplates($el, "dxTemplate");
    const suitableTemplates = suitableTemplatesByName(templates);
    templates.forEach((_ref2) => {
      let {
        element,
        options: {
          name: name2
        }
      } = _ref2;
      if (element === suitableTemplates[name2]) {
        renderer_default(element).addClass("dx-template-wrapper").detach();
      } else {
        renderer_default(element).remove();
      }
    });
    return Object.keys(suitableTemplates).map((name2) => ({
      name: name2,
      template: this._createTemplate(suitableTemplates[name2])
    }));
  }
  _extractAnonymousTemplate($el) {
    const $anonymousTemplate = $el.contents().detach();
    const $notJunkTemplateContent = $anonymousTemplate.filter((_, element) => {
      const isTextNode = 3 === element.nodeType;
      const isEmptyText = renderer_default(element).text().trim().length < 1;
      return !(isTextNode && isEmptyText);
    });
    return $notJunkTemplateContent.length > 0 ? {
      template: this._createTemplate($anonymousTemplate),
      name: this._anonymousTemplateName
    } : {};
  }
  _createTemplateIfNeeded(templateSource) {
    const cachedTemplate = this._tempTemplates.filter((tempTemplate) => tempTemplate.source === templateKey(templateSource))[0];
    if (cachedTemplate) {
      return cachedTemplate.template;
    }
    const template = this._createTemplate(templateSource);
    this._tempTemplates.push({
      template,
      source: templateKey(templateSource)
    });
    return template;
  }
  _createTemplate(templateSource) {
    return this._createElement(validateTemplateSource(templateSource));
  }
  getTemplate(templateSource, templates, _ref3, context2) {
    let {
      isAsyncTemplate,
      skipTemplates
    } = _ref3;
    if (!isFunction(templateSource)) {
      return acquireTemplate(templateSource, this._createTemplateIfNeeded, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
    }
    return new FunctionTemplate((options2) => {
      const templateSourceResult = templateSource.apply(context2, getNormalizedTemplateArgs(options2));
      if (!isDefined(templateSourceResult)) {
        return new EmptyTemplate();
      }
      let dispose = false;
      const template = acquireTemplate(templateSourceResult, (templateSource2) => {
        if (templateSource2.nodeType || isRenderer(templateSource2) && !renderer_default(templateSource2).is("script")) {
          return new FunctionTemplate(() => templateSource2);
        }
        dispose = true;
        return this._createTemplate(templateSource2);
      }, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
      const result2 = template.render(options2);
      dispose && template.dispose && template.dispose();
      return result2;
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/events/core/keyboard_processor.js
var NAMESPACE = "KeyboardProcessor";
var createKeyDownOptions = (e) => ({
  keyName: normalizeKeyName(e),
  key: e.key,
  code: e.code,
  ctrl: e.ctrlKey,
  location: e.location,
  metaKey: e.metaKey,
  shift: e.shiftKey,
  alt: e.altKey,
  which: e.which,
  originalEvent: e
});
var KeyboardProcessor = class_default.inherit({
  _keydown: addNamespace2("keydown", NAMESPACE),
  _compositionStart: addNamespace2("compositionstart", NAMESPACE),
  _compositionEnd: addNamespace2("compositionend", NAMESPACE),
  ctor: function(options2) {
    options2 = options2 || {};
    if (options2.element) {
      this._element = renderer_default(options2.element);
    }
    if (options2.focusTarget) {
      this._focusTarget = options2.focusTarget;
    }
    this._handler = options2.handler;
    if (this._element) {
      this._processFunction = (e) => {
        const focusTargets = renderer_default(this._focusTarget).toArray();
        const isNotFocusTarget = this._focusTarget && this._focusTarget !== e.target && !focusTargets.includes(e.target);
        const shouldSkipProcessing = this._isComposingJustFinished && 229 === e.which || this._isComposing || isNotFocusTarget;
        this._isComposingJustFinished = false;
        if (!shouldSkipProcessing) {
          this.process(e);
        }
      };
      this._toggleProcessingWithContext = this.toggleProcessing.bind(this);
      events_engine_default.on(this._element, this._keydown, this._processFunction);
      events_engine_default.on(this._element, this._compositionStart, this._toggleProcessingWithContext);
      events_engine_default.on(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
  },
  dispose: function() {
    if (this._element) {
      events_engine_default.off(this._element, this._keydown, this._processFunction);
      events_engine_default.off(this._element, this._compositionStart, this._toggleProcessingWithContext);
      events_engine_default.off(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
    this._element = void 0;
    this._handler = void 0;
  },
  process: function(e) {
    this._handler(createKeyDownOptions(e));
  },
  toggleProcessing: function(_ref) {
    let {
      type: type2
    } = _ref;
    this._isComposing = "compositionstart" === type2;
    this._isComposingJustFinished = !this._isComposing;
  }
});
KeyboardProcessor.createKeyDownOptions = createKeyDownOptions;
var keyboard_processor_default = KeyboardProcessor;

// ../../../../../../node_modules/devextreme/esm/events/short.js
function addNamespace3(event, namespace) {
  return namespace ? addNamespace2(event, namespace) : event;
}
function executeAction(action, args) {
  return "function" === typeof action ? action(args) : action.execute(args);
}
var active = {
  on: ($el, active2, inactive, opts) => {
    const {
      selector,
      showTimeout,
      hideTimeout,
      namespace
    } = opts;
    events_engine_default.on($el, addNamespace3("dxactive", namespace), selector, {
      timeout: showTimeout
    }, (event) => executeAction(active2, {
      event,
      element: event.currentTarget
    }));
    events_engine_default.on($el, addNamespace3("dxinactive", namespace), selector, {
      timeout: hideTimeout
    }, (event) => executeAction(inactive, {
      event,
      element: event.currentTarget
    }));
  },
  off: ($el, _ref) => {
    let {
      namespace,
      selector
    } = _ref;
    events_engine_default.off($el, addNamespace3("dxactive", namespace), selector);
    events_engine_default.off($el, addNamespace3("dxinactive", namespace), selector);
  }
};
var resize = {
  on: function($el, resize2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    events_engine_default.on($el, addNamespace3("dxresize", namespace), resize2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    events_engine_default.off($el, addNamespace3("dxresize", namespace));
  }
};
var hover = {
  on: ($el, start, end, _ref2) => {
    let {
      selector,
      namespace
    } = _ref2;
    events_engine_default.on($el, addNamespace3("dxhoverend", namespace), selector, (event) => end(event));
    events_engine_default.on($el, addNamespace3("dxhoverstart", namespace), selector, (event) => executeAction(start, {
      element: event.target,
      event
    }));
  },
  off: ($el, _ref3) => {
    let {
      selector,
      namespace
    } = _ref3;
    events_engine_default.off($el, addNamespace3("dxhoverstart", namespace), selector);
    events_engine_default.off($el, addNamespace3("dxhoverend", namespace), selector);
  }
};
var visibility = {
  on: ($el, shown, hiding, _ref4) => {
    let {
      namespace
    } = _ref4;
    events_engine_default.on($el, addNamespace3("dxhiding", namespace), hiding);
    events_engine_default.on($el, addNamespace3("dxshown", namespace), shown);
  },
  off: ($el, _ref5) => {
    let {
      namespace
    } = _ref5;
    events_engine_default.off($el, addNamespace3("dxhiding", namespace));
    events_engine_default.off($el, addNamespace3("dxshown", namespace));
  }
};
var focus = {
  on: ($el, focusIn, focusOut, _ref6) => {
    let {
      namespace
    } = _ref6;
    events_engine_default.on($el, addNamespace3("focusin", namespace), focusIn);
    events_engine_default.on($el, addNamespace3("focusout", namespace), focusOut);
  },
  off: ($el, _ref7) => {
    let {
      namespace
    } = _ref7;
    events_engine_default.off($el, addNamespace3("focusin", namespace));
    events_engine_default.off($el, addNamespace3("focusout", namespace));
  },
  trigger: ($el) => events_engine_default.trigger($el, "focus")
};
var dxClick = {
  on: function($el, click2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    events_engine_default.on($el, addNamespace3("dxclick", namespace), click2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    events_engine_default.off($el, addNamespace3("dxclick", namespace));
  }
};
var click = {
  on: function($el, click2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    events_engine_default.on($el, addNamespace3("click", namespace), click2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    events_engine_default.off($el, addNamespace3("click", namespace));
  }
};
var index = 0;
var keyboardProcessors = {};
var generateListenerId = () => "keyboardProcessorId" + index++;
var keyboard = {
  on: (element, focusTarget, handler) => {
    const listenerId = generateListenerId();
    keyboardProcessors[listenerId] = new keyboard_processor_default({
      element,
      focusTarget,
      handler
    });
    return listenerId;
  },
  off: (listenerId) => {
    if (listenerId && keyboardProcessors[listenerId]) {
      keyboardProcessors[listenerId].dispose();
      delete keyboardProcessors[listenerId];
    }
  },
  _getProcessor: (listenerId) => keyboardProcessors[listenerId]
};

// ../../../../../../node_modules/devextreme/esm/__internal/utils/version.js
var assertedVersions = [];
var VERSION_SPLITTER = ".";
function stringifyVersion(version3) {
  const {
    major,
    minor,
    patch: patch2
  } = version3;
  return [major, minor, patch2].join(VERSION_SPLITTER);
}
function parseVersion(version3) {
  const [major, minor, patch2] = version3.split(".").map(Number);
  return {
    major,
    minor,
    patch: patch2
  };
}
function stringifyVersionList(assertedVersionList) {
  return assertedVersionList.map((assertedVersion) => `${assertedVersion.packageName}: ${assertedVersion.version}`).join("\n");
}
function versionsEqual(versionA, versionB) {
  return versionA.major === versionB.major && versionA.minor === versionB.minor && versionA.patch === versionB.patch;
}
function getPreviousMajorVersion(_ref) {
  let {
    major,
    minor,
    patch: patch2
  } = _ref;
  const previousMajorVersion = 1 === minor ? {
    major: major - 1,
    minor: 2,
    patch: patch2
  } : {
    major,
    minor: minor - 1,
    patch: patch2
  };
  return previousMajorVersion;
}
function assertedVersionsCompatible(currentVersion) {
  const mismatchingVersions = assertedVersions.filter((assertedVersion) => !versionsEqual(parseVersion(assertedVersion.version), currentVersion));
  if (mismatchingVersions.length) {
    errors_default.log("W0023", stringifyVersionList([{
      packageName: "devextreme",
      version: stringifyVersion(currentVersion)
    }, ...mismatchingVersions]));
    return false;
  }
  return true;
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/byte_utils.js
function base64ToBytes(base64) {
  return new Uint8Array(atob(base64).split("").map((s) => s.charCodeAt(0)));
}
function hexToBytes(string) {
  var _string$match;
  return new Uint8Array((null === (_string$match = string.match(/.{1,2}/g)) || void 0 === _string$match ? void 0 : _string$match.map((byte) => parseInt(byte, 16))) ?? []);
}
function stringToBytes(string) {
  const bytes = new Uint8Array(string.length);
  for (let k = 0; k < string.length; k += 1) {
    bytes[k] = 255 & string.charCodeAt(k);
  }
  return bytes;
}
function wordsToBytes(words) {
  const bytes = new Uint8Array(4 * words.length);
  for (let k = 0; k < bytes.length; k += 1) {
    bytes[k] = words[k >> 2] >>> 8 * (3 - k % 4);
  }
  return bytes;
}
function bytesToWords(bytes) {
  const words = new Uint32Array(1 + (bytes.length - 1 >> 2));
  for (let k = 0; k < bytes.length; k += 1) {
    words[k >> 2] |= bytes[k] << 8 * (3 - k % 4);
  }
  return words;
}
function leftRotate(x, n) {
  return (x << n | x >>> 32 - n) >>> 0;
}
function concatBytes(a, b) {
  const result2 = new Uint8Array(a.length + b.length);
  result2.set(a, 0);
  result2.set(b, a.length);
  return result2;
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/key.js
var PUBLIC_KEY = {
  e: 65537,
  n: new Uint8Array([200, 219, 153, 203, 140, 7, 228, 253, 193, 243, 62, 137, 139, 60, 68, 242, 48, 142, 113, 88, 185, 235, 253, 105, 80, 74, 32, 170, 96, 74, 111, 250, 7, 205, 154, 3, 146, 115, 153, 53, 45, 132, 123, 56, 61, 208, 184, 201, 63, 24, 109, 223, 0, 179, 169, 102, 139, 224, 73, 233, 45, 173, 138, 66, 98, 88, 69, 76, 177, 111, 113, 218, 192, 33, 101, 152, 25, 134, 34, 173, 32, 82, 230, 44, 247, 200, 253, 170, 192, 246, 30, 12, 96, 205, 100, 249, 181, 93, 0, 231])
};
var INTERNAL_USAGE_ID = "ppJtlS56r0az1kqUjWJs-g";

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/pkcs1.js
var ASN1_SHA1 = "3021300906052b0e03021a05000414";
function pad(hash) {
  const dataLength = (8 * PUBLIC_KEY.n.length + 6) / 8;
  const data2 = concatBytes(hexToBytes(ASN1_SHA1), hash);
  if (data2.length + 10 > dataLength) {
    throw Error("Key is too short for SHA1 signing algorithm");
  }
  const padding = new Uint8Array(dataLength - data2.length);
  padding.fill(255, 0, padding.length - 1);
  padding[0] = 0;
  padding[1] = 1;
  padding[padding.length - 1] = 0;
  return concatBytes(padding, data2);
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/rsa_bigint.js
function compareSignatures(args) {
  try {
    const zero = BigInt(0);
    const one2 = BigInt(1);
    const eight = BigInt(8);
    const modExp = (base2, exponent2, modulus2) => {
      let result2 = one2;
      let b = base2;
      let e = exponent2;
      while (e) {
        if (e & one2) {
          result2 = result2 * b % modulus2;
        }
        b = b * b % modulus2;
        e >>= one2;
      }
      return result2;
    };
    const bigIntFromBytes = (bytes) => bytes.reduce((acc, cur) => (acc << eight) + BigInt(cur), zero);
    const actual = bigIntFromBytes(args.actual);
    const signature = bigIntFromBytes(args.signature);
    const exponent = BigInt(args.key.e);
    const modulus = bigIntFromBytes(args.key.n);
    const expected = modExp(signature, exponent, modulus);
    return expected === actual;
  } catch {
    return true;
  }
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/sha1.js
function preprocess(text) {
  const bytes = new Uint8Array(text.length + 1);
  bytes.set(stringToBytes(text));
  bytes[bytes.length - 1] = 128;
  const words = bytesToWords(new Uint8Array(bytes));
  const result2 = new Uint32Array(16 * Math.ceil((words.length + 2) / 16));
  result2.set(words, 0);
  result2[result2.length - 1] = 8 * (bytes.length - 1);
  return result2;
}
function sha1(text) {
  const message = preprocess(text);
  const h2 = new Uint32Array([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
  for (let i = 0; i < message.length; i += 16) {
    const w = new Uint32Array(80);
    for (let j = 0; j < 16; j += 1) {
      w[j] = message[i + j];
    }
    for (let j = 16; j < 80; j += 1) {
      const n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
      w[j] = n << 1 | n >>> 31;
    }
    let a = h2[0];
    let b = h2[1];
    let c = h2[2];
    let d = h2[3];
    let e = h2[4];
    for (let j = 0; j < 80; j += 1) {
      const [f, k] = j < 20 ? [b & c | ~b & d, 1518500249] : j < 40 ? [b ^ c ^ d, 1859775393] : j < 60 ? [b & c | b & d | c & d, 2400959708] : [b ^ c ^ d, 3395469782];
      const temp = leftRotate(a, 5) + f + e + k + w[j];
      e = d;
      d = c;
      c = leftRotate(b, 30);
      b = a;
      a = temp;
    }
    h2[0] += a;
    h2[1] += b;
    h2[2] += c;
    h2[3] += d;
    h2[4] += e;
  }
  return wordsToBytes(h2);
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/trial_panel.client.js
var isClient = () => "undefined" !== typeof HTMLElement;
var SafeHTMLElement = isClient() ? HTMLElement : class {
};
var componentNames2 = {
  trigger: "dx-license-trigger",
  panel: "dx-license"
};
var attributeNames = {
  buyNow: "buy-now",
  version: "version"
};
var commonStyles = {
  opacity: "1",
  visibility: "visible",
  "clip-path": "none",
  filter: "none"
};
var contentStyles = _extends({}, commonStyles, {
  width: "100%",
  height: "auto",
  "line-height": "normal",
  display: "block",
  "z-index": "1500",
  position: "static",
  transform: "translate(0px, 0px)",
  "background-color": "#FF7200",
  border: "none",
  margin: "auto",
  "box-sizing": "border-box",
  "text-align": "center"
});
var containerStyles = _extends({}, contentStyles, {
  display: "flex",
  "align-items": "center",
  "flex-direction": "row",
  position: "relative",
  top: "0px",
  left: "0px",
  padding: "0.5rem"
});
var buttonStyles = {
  width: "1rem",
  cursor: "pointer",
  height: "1rem"
};
var textStyles = _extends({}, commonStyles, {
  display: "inline",
  position: "static",
  padding: "0px",
  margin: "0px",
  color: "white",
  "font-family": "'Segoe UI','Open Sans Condensed',-apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,Cantarell,Ubuntu,roboto,noto,arial,sans-serif",
  "font-size": "0.875rem",
  "font-wight": "600"
});
function createImportantStyles(defaultStyles, customStyles) {
  const styles = customStyles ? _extends({}, defaultStyles, customStyles) : defaultStyles;
  return Object.keys(styles).reduce((cssString, currentKey) => `${cssString}${[currentKey, `${styles[currentKey]} !important;`].join(": ")}`, "");
}
var DxLicense = class _DxLicense extends SafeHTMLElement {
  constructor() {
    var _DxLicense$customStyl, _DxLicense$customStyl2, _DxLicense$customStyl3, _DxLicense$customStyl4, _DxLicense$customStyl5;
    super();
    this._observer = null;
    this._inReassign = false;
    this._hidden = false;
    this._spanStyles = createImportantStyles(textStyles, null === (_DxLicense$customStyl = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl ? void 0 : _DxLicense$customStyl.textStyles);
    this._linkStyles = createImportantStyles(textStyles, null === (_DxLicense$customStyl2 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl2 ? void 0 : _DxLicense$customStyl2.linkStyles);
    this._containerStyles = createImportantStyles(containerStyles, null === (_DxLicense$customStyl3 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl3 ? void 0 : _DxLicense$customStyl3.containerStyles);
    this._contentStyles = createImportantStyles(contentStyles, null === (_DxLicense$customStyl4 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl4 ? void 0 : _DxLicense$customStyl4.contentStyles);
    this._buttonStyles = createImportantStyles(buttonStyles, null === (_DxLicense$customStyl5 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl5 ? void 0 : _DxLicense$customStyl5.contentStyles);
  }
  _createSpan(text) {
    const span = document.createElement("span");
    span.innerText = text;
    span.style.cssText = this._spanStyles;
    return span;
  }
  _createLink(text, href) {
    const link = document.createElement("a");
    link.innerText = text;
    link.style.cssText = this._linkStyles;
    link.href = href;
    link.target = "_blank";
    return link;
  }
  _createButton() {
    const button = document.createElement("div");
    button.style.cssText = this._buttonStyles;
    const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    polygon.setAttribute("points", "13.4 12.7 8.7 8 13.4 3.4 12.6 2.6 8 7.3 3.4 2.6 2.6 3.4 7.3 8 2.6 12.6 3.4 13.4 8 8.7 12.7 13.4 13.4 12.7");
    polygon.style.cssText = createImportantStyles({
      fill: "#fff",
      opacity: ".5",
      "stroke-width": "0px"
    });
    svg.setAttribute("id", "Layer_1");
    svg.setAttribute("data-name", "Layer 1");
    svg.setAttribute("version", "1.1");
    svg.setAttribute("viewBox", "0 0 16 16");
    svg.style.cssText = createImportantStyles({
      "vertical-align": "baseline"
    });
    svg.appendChild(polygon);
    button.appendChild(svg);
    button.onclick = () => {
      this._hidden = true;
      this.style.cssText = createImportantStyles({
        display: "none"
      });
    };
    return button;
  }
  _createContentContainer() {
    const contentContainer = document.createElement("div");
    contentContainer.style.cssText = this._contentStyles;
    contentContainer.append(this._createSpan("For evaluation purposes only. Redistribution not authorized. Please "), this._createLink("purchase a license", this.getAttribute(attributeNames.buyNow)), this._createSpan(` to continue use of DevExpress product libraries (v${this.getAttribute(attributeNames.version)}).`));
    return contentContainer;
  }
  _reassignComponent() {
    this.innerHTML = "";
    this.style.cssText = this._containerStyles;
    this.append(this._createContentContainer(), this._createButton());
  }
  connectedCallback() {
    this._reassignComponent();
    if (!this._observer) {
      this._observer = new MutationObserver(() => {
        if (this._hidden) {
          var _this$_observer;
          null === (_this$_observer = this._observer) || void 0 === _this$_observer || _this$_observer.disconnect();
          return;
        }
        if (this._inReassign) {
          this._inReassign = false;
        } else {
          this._inReassign = true;
          this._reassignComponent();
        }
      });
      this._observer.observe(this, {
        childList: true,
        attributes: true,
        subtree: true
      });
    }
  }
  disconnectedCallback() {
    setTimeout(() => {
      const licensePanel = document.getElementsByTagName(componentNames2.panel);
      if (!licensePanel.length) {
        document.body.prepend(this);
      }
    }, 100);
  }
};
DxLicense.customStyles = void 0;
var DxLicenseTrigger = class extends SafeHTMLElement {
  connectedCallback() {
    this.style.cssText = createImportantStyles({
      display: "none"
    });
    const licensePanel = document.getElementsByTagName(componentNames2.panel);
    if (!licensePanel.length) {
      const license = document.createElement(componentNames2.panel);
      license.setAttribute(attributeNames.version, this.getAttribute(attributeNames.version));
      license.setAttribute(attributeNames.buyNow, this.getAttribute(attributeNames.buyNow));
      license.setAttribute("data-permanent", "true");
      document.body.prepend(license);
    }
  }
};
function registerCustomComponents(customStyles) {
  if (!customElements.get(componentNames2.trigger)) {
    DxLicense.customStyles = customStyles;
    customElements.define(componentNames2.trigger, DxLicenseTrigger);
    customElements.define(componentNames2.panel, DxLicense);
  }
}
function renderTrialPanel(buyNowUrl, version3, customStyles) {
  registerCustomComponents(customStyles);
  const trialPanelTrigger = document.createElement(componentNames2.trigger);
  trialPanelTrigger.setAttribute(attributeNames.buyNow, buyNowUrl);
  trialPanelTrigger.setAttribute(attributeNames.version, version3);
  document.body.appendChild(trialPanelTrigger);
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/trial_panel.js
function showTrialPanel(buyNowUrl, version3, customStyles) {
  if (isClient()) {
    renderTrialPanel(buyNowUrl, version3, customStyles);
  }
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/types.js
var TokenKind;
!function(TokenKind2) {
  TokenKind2.corrupted = "corrupted";
  TokenKind2.verified = "verified";
  TokenKind2.internal = "internal";
}(TokenKind || (TokenKind = {}));

// ../../../../../../node_modules/devextreme/esm/__internal/core/license/license_validation.js
var _excluded2 = ["customerId", "maxVersionAllowed", "format", "internalUsageId"];
var FORMAT = 1;
var RTM_MIN_PATCH_VERSION = 3;
var KEY_SPLITTER = ".";
var BUY_NOW_LINK = "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeJQuery.aspx";
var GENERAL_ERROR = {
  kind: TokenKind.corrupted,
  error: "general"
};
var VERIFICATION_ERROR = {
  kind: TokenKind.corrupted,
  error: "verification"
};
var DECODING_ERROR = {
  kind: TokenKind.corrupted,
  error: "decoding"
};
var DESERIALIZATION_ERROR = {
  kind: TokenKind.corrupted,
  error: "deserialization"
};
var PAYLOAD_ERROR = {
  kind: TokenKind.corrupted,
  error: "payload"
};
var VERSION_ERROR = {
  kind: TokenKind.corrupted,
  error: "version"
};
var validationPerformed = false;
function verifySignature(_ref) {
  let {
    text,
    signature: encodedSignature
  } = _ref;
  return compareSignatures({
    key: PUBLIC_KEY,
    signature: base64ToBytes(encodedSignature),
    actual: pad(sha1(text))
  });
}
function parseLicenseKey(encodedKey) {
  if (void 0 === encodedKey) {
    return GENERAL_ERROR;
  }
  const parts = encodedKey.split(KEY_SPLITTER);
  if (2 !== parts.length || 0 === parts[0].length || 0 === parts[1].length) {
    return GENERAL_ERROR;
  }
  if (!verifySignature({
    text: parts[0],
    signature: parts[1]
  })) {
    return VERIFICATION_ERROR;
  }
  let decodedPayload = "";
  try {
    decodedPayload = atob(parts[0]);
  } catch {
    return DECODING_ERROR;
  }
  let payload = {};
  try {
    payload = JSON.parse(decodedPayload);
  } catch {
    return DESERIALIZATION_ERROR;
  }
  const {
    customerId,
    maxVersionAllowed,
    format: format2,
    internalUsageId
  } = payload, rest = _objectWithoutPropertiesLoose(payload, _excluded2);
  if (void 0 !== internalUsageId) {
    return {
      kind: TokenKind.internal,
      internalUsageId
    };
  }
  if (void 0 === customerId || void 0 === maxVersionAllowed || void 0 === format2) {
    return PAYLOAD_ERROR;
  }
  if (format2 !== FORMAT) {
    return VERSION_ERROR;
  }
  return {
    kind: TokenKind.verified,
    payload: _extends({
      customerId,
      maxVersionAllowed
    }, rest)
  };
}
function isPreview(patch2) {
  return isNaN(patch2) || patch2 < RTM_MIN_PATCH_VERSION;
}
function getLicenseCheckParams(_ref2) {
  let {
    licenseKey,
    version: version3
  } = _ref2;
  let preview = false;
  try {
    preview = isPreview(version3.patch);
    const {
      major,
      minor
    } = preview ? getPreviousMajorVersion(version3) : version3;
    if (!licenseKey) {
      return {
        preview,
        error: "W0019"
      };
    }
    const license = parseLicenseKey(licenseKey);
    if (license.kind === TokenKind.corrupted) {
      return {
        preview,
        error: "W0021"
      };
    }
    if (license.kind === TokenKind.internal) {
      return {
        preview,
        internal: true,
        error: license.internalUsageId === INTERNAL_USAGE_ID ? void 0 : "W0020"
      };
    }
    if (!(major && minor)) {
      return {
        preview,
        error: "W0021"
      };
    }
    if (10 * major + minor > license.payload.maxVersionAllowed) {
      return {
        preview,
        error: "W0020"
      };
    }
    return {
      preview,
      error: void 0
    };
  } catch {
    return {
      preview,
      error: "W0021"
    };
  }
}
function validateLicense(licenseKey) {
  let versionStr = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : fullVersion;
  if (validationPerformed) {
    return;
  }
  validationPerformed = true;
  const version3 = parseVersion(versionStr);
  const versionsCompatible = assertedVersionsCompatible(version3);
  const {
    internal,
    error
  } = getLicenseCheckParams({
    licenseKey,
    version: version3
  });
  if (!versionsCompatible && internal) {
    return;
  }
  if (error && !internal) {
    showTrialPanel(config_default().buyNowLink ?? BUY_NOW_LINK, fullVersion);
  }
  const preview = isPreview(version3.patch);
  if (error) {
    errors_default.log(preview ? "W0022" : error);
    return;
  }
  if (preview && !internal) {
    errors_default.log("W0022");
  }
}
function peekValidationPerformed() {
  return validationPerformed;
}
var license_validation_default = {
  validateLicense
};

// ../../../../../../node_modules/devextreme/esm/core/dom_component.js
var {
  abstract: abstract3
} = Component;
var DOMComponent = Component.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      width: void 0,
      height: void 0,
      rtlEnabled: config_default().rtlEnabled,
      elementAttr: {},
      disabled: false,
      integrationOptions: {}
    }, this._useTemplates() ? TemplateManager.createDefaultOptions() : {});
  },
  ctor(element, options2) {
    this._customClass = null;
    this._createElement(element);
    attachInstanceToElement(this._$element, this, this._dispose);
    this.callBase(options2);
    const validationAlreadyPerformed = peekValidationPerformed();
    license_validation_default.validateLicense(config_default().licenseKey);
    if (!validationAlreadyPerformed && peekValidationPerformed()) {
      config_default({
        licenseKey: ""
      });
    }
  },
  _createElement(element) {
    this._$element = renderer_default(element);
  },
  _getSynchronizableOptionsForCreateComponent: () => ["rtlEnabled", "disabled", "templatesRenderAsynchronously"],
  _checkFunctionValueDeprecation: function(optionNames) {
    if (!this.option("_ignoreFunctionValueDeprecation")) {
      optionNames.forEach((optionName) => {
        if (isFunction(this.option(optionName))) {
          errors_default.log("W0017", optionName);
        }
      });
    }
  },
  _visibilityChanged: abstract3,
  _dimensionChanged: abstract3,
  _init() {
    this.callBase();
    this._checkFunctionValueDeprecation(["width", "height", "maxHeight", "maxWidth", "minHeight", "minWidth", "popupHeight", "popupWidth"]);
    this._attachWindowResizeCallback();
    this._initTemplateManager();
  },
  _setOptionsByDevice(instanceCustomRules) {
    this.callBase([].concat(this.constructor._classCustomRules || [], instanceCustomRules || []));
  },
  _isInitialOptionValue(name2) {
    const isCustomOption = this.constructor._classCustomRules && Object.prototype.hasOwnProperty.call(this._convertRulesToOptions(this.constructor._classCustomRules), name2);
    return !isCustomOption && this.callBase(name2);
  },
  _attachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      const windowResizeCallBack = this._windowResizeCallBack = this._dimensionChanged.bind(this);
      resize_callbacks_default.add(windowResizeCallBack);
    }
  },
  _isDimensionChangeSupported() {
    return this._dimensionChanged !== abstract3;
  },
  _renderComponent() {
    addShadowDomStyles(this.$element());
    this._initMarkup();
    hasWindow() && this._render();
  },
  _initMarkup() {
    const {
      rtlEnabled
    } = this.option() || {};
    this._renderElementAttributes();
    this._toggleRTLDirection(rtlEnabled);
    this._renderVisibilityChange();
    this._renderDimensions();
  },
  _render() {
    this._attachVisibilityChangeHandlers();
  },
  _renderElementAttributes() {
    const {
      elementAttr
    } = this.option() || {};
    const attributes = extend({}, elementAttr);
    const classNames = attributes.class;
    delete attributes.class;
    this.$element().attr(attributes).removeClass(this._customClass).addClass(classNames);
    this._customClass = classNames;
  },
  _renderVisibilityChange() {
    if (this._isDimensionChangeSupported()) {
      this._attachDimensionChangeHandlers();
    }
    if (this._isVisibilityChangeSupported()) {
      const $element = this.$element();
      $element.addClass("dx-visibility-change-handler");
    }
  },
  _renderDimensions() {
    const $element = this.$element();
    const element = $element.get(0);
    const width = this._getOptionValue("width", element);
    const height = this._getOptionValue("height", element);
    if (this._isCssUpdateRequired(element, height, width)) {
      $element.css({
        width: null === width ? "" : width,
        height: null === height ? "" : height
      });
    }
  },
  _isCssUpdateRequired: (element, height, width) => !!(isDefined(width) || isDefined(height) || element.style.width || element.style.height),
  _attachDimensionChangeHandlers() {
    const $el = this.$element();
    const namespace = `${this.NAME}VisibilityChange`;
    resize.off($el, {
      namespace
    });
    resize.on($el, () => this._dimensionChanged(), {
      namespace
    });
  },
  _attachVisibilityChangeHandlers() {
    if (this._isVisibilityChangeSupported()) {
      const $el = this.$element();
      const namespace = `${this.NAME}VisibilityChange`;
      this._isHidden = !this._isVisible();
      visibility.off($el, {
        namespace
      });
      visibility.on($el, () => this._checkVisibilityChanged("shown"), () => this._checkVisibilityChanged("hiding"), {
        namespace
      });
    }
  },
  _isVisible() {
    const $element = this.$element();
    return $element.is(":visible");
  },
  _checkVisibilityChanged(action) {
    const isVisible2 = this._isVisible();
    if (isVisible2) {
      if ("hiding" === action && !this._isHidden) {
        this._visibilityChanged(false);
        this._isHidden = true;
      } else if ("shown" === action && this._isHidden) {
        this._isHidden = false;
        this._visibilityChanged(true);
      }
    }
  },
  _isVisibilityChangeSupported() {
    return this._visibilityChanged !== abstract3 && hasWindow();
  },
  _clean: noop2,
  _modelByElement() {
    const {
      modelByElement
    } = this.option();
    const $element = this.$element();
    return modelByElement ? modelByElement($element) : void 0;
  },
  _invalidate() {
    if (this._isUpdateAllowed()) {
      throw errors_default.Error("E0007");
    }
    this._requireRefresh = true;
  },
  _refresh() {
    this._clean();
    this._renderComponent();
  },
  _dispose() {
    this._templateManager && this._templateManager.dispose();
    this.callBase();
    this._clean();
    this._detachWindowResizeCallback();
  },
  _detachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      resize_callbacks_default.remove(this._windowResizeCallBack);
    }
  },
  _toggleRTLDirection(rtl) {
    const $element = this.$element();
    $element.toggleClass("dx-rtl", rtl);
  },
  _createComponent(element, component) {
    let config3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    const synchronizableOptions = grep(this._getSynchronizableOptionsForCreateComponent(), (value2) => !(value2 in config3));
    const {
      integrationOptions
    } = this.option();
    let {
      nestedComponentOptions
    } = this.option();
    nestedComponentOptions = nestedComponentOptions || noop2;
    const nestedComponentConfig = extend({
      integrationOptions
    }, nestedComponentOptions(this));
    synchronizableOptions.forEach((optionName) => nestedComponentConfig[optionName] = this.option(optionName));
    this._extendConfig(config3, nestedComponentConfig);
    let instance;
    if (isString(component)) {
      const $element = renderer_default(element)[component](config3);
      instance = $element[component]("instance");
    } else if (element) {
      instance = component.getInstance(element);
      if (instance) {
        instance.option(config3);
      } else {
        instance = new component(element, config3);
      }
    }
    if (instance) {
      const optionChangedHandler = (_ref) => {
        let {
          name: name2,
          value: value2
        } = _ref;
        if (synchronizableOptions.includes(name2)) {
          instance.option(name2, value2);
        }
      };
      this.on("optionChanged", optionChangedHandler);
      instance.on("disposing", () => this.off("optionChanged", optionChangedHandler));
    }
    return instance;
  },
  _extendConfig(config3, extendConfig) {
    each(extendConfig, (key, value2) => {
      !Object.prototype.hasOwnProperty.call(config3, key) && (config3[key] = value2);
    });
  },
  _defaultActionConfig() {
    const $element = this.$element();
    const context2 = this._modelByElement($element);
    return extend(this.callBase(), {
      context: context2
    });
  },
  _defaultActionArgs() {
    const $element = this.$element();
    const model = this._modelByElement($element);
    const element = this.element();
    return extend(this.callBase(), {
      element,
      model
    });
  },
  _optionChanged(args) {
    switch (args.name) {
      case "width":
      case "height":
        this._renderDimensions();
        break;
      case "rtlEnabled":
        this._invalidate();
        break;
      case "elementAttr":
        this._renderElementAttributes();
        break;
      case "disabled":
      case "integrationOptions":
        break;
      default:
        this.callBase(args);
    }
  },
  _removeAttributes(element) {
    const attrs = element.attributes;
    for (let i = attrs.length - 1; i >= 0; i--) {
      const attr = attrs[i];
      if (attr) {
        const {
          name: name2
        } = attr;
        if (!name2.indexOf("aria-") || -1 !== name2.indexOf("dx-") || "role" === name2 || "style" === name2 || "tabindex" === name2) {
          element.removeAttribute(name2);
        }
      }
    }
  },
  _removeClasses(element) {
    element.className = element.className.split(" ").filter((cssClass) => 0 !== cssClass.lastIndexOf("dx-", 0)).join(" ");
  },
  _updateDOMComponent(renderRequired) {
    if (renderRequired) {
      this._renderComponent();
    } else if (this._requireRefresh) {
      this._requireRefresh = false;
      this._refresh();
    }
  },
  endUpdate() {
    const renderRequired = this._isInitializingRequired();
    this.callBase();
    this._isUpdateAllowed() && this._updateDOMComponent(renderRequired);
  },
  $element() {
    return this._$element;
  },
  element() {
    const $element = this.$element();
    return getPublicElement($element);
  },
  dispose() {
    const element = this.$element().get(0);
    cleanDataRecursive(element, true);
    element.textContent = "";
    this._removeAttributes(element);
    this._removeClasses(element);
  },
  resetOption(optionName) {
    this.callBase(optionName);
    if ("width" === optionName || "height" === optionName) {
      const initialOption = this.initialOption(optionName);
      !isDefined(initialOption) && this.$element().css(optionName, "");
    }
  },
  _getAnonymousTemplateName() {
    return;
  },
  _initTemplateManager() {
    if (this._templateManager || !this._useTemplates()) {
      return;
    }
    const {
      integrationOptions = {}
    } = this.option();
    const {
      createTemplate
    } = integrationOptions;
    this._templateManager = new TemplateManager(createTemplate, this._getAnonymousTemplateName());
    this._initTemplates();
  },
  _initTemplates() {
    const {
      templates,
      anonymousTemplateMeta
    } = this._templateManager.extractTemplates(this.$element());
    const anonymousTemplate = this.option(`integrationOptions.templates.${anonymousTemplateMeta.name}`);
    templates.forEach((_ref2) => {
      let {
        name: name2,
        template
      } = _ref2;
      this._options.silent(`integrationOptions.templates.${name2}`, template);
    });
    if (anonymousTemplateMeta.name && !anonymousTemplate) {
      this._options.silent(`integrationOptions.templates.${anonymousTemplateMeta.name}`, anonymousTemplateMeta.template);
      this._options.silent("_hasAnonymousTemplateContent", true);
    }
  },
  _getTemplateByOption(optionName) {
    return this._getTemplate(this.option(optionName));
  },
  _getTemplate(templateSource) {
    const templates = this.option("integrationOptions.templates");
    const isAsyncTemplate = this.option("templatesRenderAsynchronously");
    const skipTemplates = this.option("integrationOptions.skipTemplates");
    return this._templateManager.getTemplate(templateSource, templates, {
      isAsyncTemplate,
      skipTemplates
    }, this);
  },
  _saveTemplate(name2, template) {
    this._setOptionWithoutOptionChange("integrationOptions.templates." + name2, this._templateManager._createTemplate(template));
  },
  _useTemplates: () => true
});
DOMComponent.getInstance = function(element) {
  return getInstanceByElement(renderer_default(element), this);
};
DOMComponent.defaultOptions = function(rule) {
  this._classCustomRules = this._classCustomRules || [];
  this._classCustomRules.push(rule);
};
var dom_component_default = DOMComponent;

// ../../../../../../node_modules/devextreme/esm/core/utils/version.js
function compare(x, y, maxLevel) {
  function normalizeArg(value2) {
    if ("string" === typeof value2) {
      return value2.split(".");
    }
    if ("number" === typeof value2) {
      return [value2];
    }
    return value2;
  }
  x = normalizeArg(x);
  y = normalizeArg(y);
  let length = Math.max(x.length, y.length);
  if (isFinite(maxLevel)) {
    length = Math.min(length, maxLevel);
  }
  for (let i = 0; i < length; i++) {
    const xItem = parseInt(x[i] || 0, 10);
    const yItem = parseInt(y[i] || 0, 10);
    if (xItem < yItem) {
      return -1;
    }
    if (xItem > yItem) {
      return 1;
    }
  }
  return 0;
}

// ../../../../../../node_modules/devextreme/esm/events/core/emitter.feedback.js
var ACTIVE_EVENT_NAME = "dxactive";
var FeedbackEvent = class_default.inherit({
  ctor: function(timeout, fire) {
    this._timeout = timeout;
    this._fire = fire;
  },
  start: function() {
    const that = this;
    this._schedule(function() {
      that.force();
    });
  },
  _schedule: function(fn) {
    this.stop();
    this._timer = setTimeout(fn, this._timeout);
  },
  stop: function() {
    clearTimeout(this._timer);
  },
  force: function() {
    if (this._fired) {
      return;
    }
    this.stop();
    this._fire();
    this._fired = true;
  },
  fired: function() {
    return this._fired;
  }
});
var activeFeedback;
var FeedbackEmitter = emitter_default.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    this._active = new FeedbackEvent(0, noop2);
    this._inactive = new FeedbackEvent(0, noop2);
  },
  configure: function(data2, eventName) {
    switch (eventName) {
      case "dxactive":
        data2.activeTimeout = data2.timeout;
        break;
      case "dxinactive":
        data2.inactiveTimeout = data2.timeout;
    }
    this.callBase(data2);
  },
  start: function(e) {
    if (activeFeedback) {
      const activeChildExists = contains2(this.getElement().get(0), activeFeedback.getElement().get(0));
      const childJustActivated = !activeFeedback._active.fired();
      if (activeChildExists && childJustActivated) {
        this._cancel();
        return;
      }
      activeFeedback._inactive.force();
    }
    activeFeedback = this;
    this._initEvents(e);
    this._active.start();
  },
  _initEvents: function(e) {
    const that = this;
    const eventTarget = this._getEmitterTarget(e);
    const mouseEvent = isMouseEvent(e);
    const isSimulator = devices_default.isSimulator();
    const deferFeedback = isSimulator || !mouseEvent;
    const activeTimeout = ensureDefined(this.activeTimeout, 30);
    const inactiveTimeout = ensureDefined(this.inactiveTimeout, 400);
    this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, function() {
      that._fireEvent("dxactive", e, {
        target: eventTarget
      });
    });
    this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, function() {
      that._fireEvent("dxinactive", e, {
        target: eventTarget
      });
      activeFeedback = null;
    });
  },
  cancel: function(e) {
    this.end(e);
  },
  end: function(e) {
    const skipTimers = e.type !== pointer_default.up;
    if (skipTimers) {
      this._active.stop();
    } else {
      this._active.force();
    }
    this._inactive.start();
    if (skipTimers) {
      this._inactive.force();
    }
  },
  dispose: function() {
    this._active.stop();
    this._inactive.stop();
    if (activeFeedback === this) {
      activeFeedback = null;
    }
    this.callBase();
  },
  lockInactive: function() {
    this._active.force();
    this._inactive.stop();
    activeFeedback = null;
    this._cancel();
    return this._inactive.force.bind(this._inactive);
  }
});
FeedbackEmitter.lock = function(deferred) {
  const lockInactive = activeFeedback ? activeFeedback.lockInactive() : noop2;
  deferred.done(lockInactive);
};
emitter_registrator_default({
  emitter: FeedbackEmitter,
  events: ["dxactive", "dxinactive"]
});
var lock = FeedbackEmitter.lock;

// ../../../../../../node_modules/devextreme/esm/events/hover.js
var HOVERSTART = "dxhoverstart";
var POINTERENTER_NAMESPACED_EVENT_NAME = addNamespace2(pointer_default.enter, "dxHoverStart");
var HOVEREND = "dxhoverend";
var POINTERLEAVE_NAMESPACED_EVENT_NAME = addNamespace2(pointer_default.leave, "dxHoverEnd");
var Hover = class_default.inherit({
  noBubble: true,
  ctor: function() {
    this._handlerArrayKeyPath = this._eventNamespace + "_HandlerStore";
  },
  setup: function(element) {
    data(element, this._handlerArrayKeyPath, {});
  },
  add: function(element, handleObj) {
    const that = this;
    const handler = function(e) {
      that._handler(e);
    };
    events_engine_default.on(element, this._originalEventName, handleObj.selector, handler);
    data(element, this._handlerArrayKeyPath)[handleObj.guid] = handler;
  },
  _handler: function(e) {
    if (isTouchEvent(e) || devices_default.isSimulator()) {
      return;
    }
    fireEvent({
      type: this._eventName,
      originalEvent: e,
      delegateTarget: e.delegateTarget
    });
  },
  remove: function(element, handleObj) {
    const handler = data(element, this._handlerArrayKeyPath)[handleObj.guid];
    events_engine_default.off(element, this._originalEventName, handleObj.selector, handler);
  },
  teardown: function(element) {
    removeData(element, this._handlerArrayKeyPath);
  }
});
var HoverStart = Hover.inherit({
  ctor: function() {
    this._eventNamespace = "dxHoverStart";
    this._eventName = HOVERSTART;
    this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
    this.callBase();
  },
  _handler: function(e) {
    const pointers = e.pointers || [];
    if (!pointers.length) {
      this.callBase(e);
    }
  }
});
var HoverEnd = Hover.inherit({
  ctor: function() {
    this._eventNamespace = "dxHoverEnd";
    this._eventName = HOVEREND;
    this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
    this.callBase();
  }
});
event_registrator_default(HOVERSTART, new HoverStart());
event_registrator_default(HOVEREND, new HoverEnd());

// ../../../../../../node_modules/devextreme/esm/ui/widget/ui.widget.js
function setAttribute(name2, value2, target) {
  name2 = "role" === name2 || "id" === name2 ? name2 : `aria-${name2}`;
  value2 = isDefined(value2) ? value2.toString() : null;
  target.attr(name2, value2);
}
var Widget = dom_component_default.inherit({
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  _supportedKeys: () => ({}),
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoveredElement: null,
      isActive: false,
      disabled: false,
      visible: true,
      hint: void 0,
      activeStateEnabled: false,
      onContentReady: null,
      hoverStateEnabled: false,
      focusStateEnabled: false,
      tabIndex: 0,
      accessKey: void 0,
      onFocusIn: null,
      onFocusOut: null,
      onKeyboardHandled: null,
      ignoreParentReadOnly: false,
      useResizeObserver: true
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: function() {
        const device = devices_default.real();
        const platform = device.platform;
        const version3 = device.version;
        return "ios" === platform && compare(version3, "13.3") <= 0;
      },
      options: {
        useResizeObserver: false
      }
    }]);
  },
  _init() {
    this.callBase();
    this._initContentReadyAction();
  },
  _innerWidgetOptionChanged: function(innerWidget, args) {
    const options2 = Widget.getOptionsFromContainer(args);
    innerWidget && innerWidget.option(options2);
    this._options.cache(args.name, options2);
  },
  _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    const syncOptions = () => this._options.silent(optionsContainer, extend({}, innerWidget.option()));
    syncOptions();
    innerWidget.on("optionChanged", syncOptions);
  },
  _getAriaTarget() {
    return this._focusTarget();
  },
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption("onContentReady", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _initMarkup() {
    const {
      disabled,
      visible: visible2
    } = this.option();
    this.$element().addClass("dx-widget");
    this._toggleDisabledState(disabled);
    this._toggleVisibility(visible2);
    this._renderHint();
    this._isFocusable() && this._renderFocusTarget();
    this.callBase();
  },
  _render() {
    this.callBase();
    this._renderContent();
    this._renderFocusState();
    this._attachFeedbackEvents();
    this._attachHoverEvents();
    this._toggleIndependentState();
  },
  _renderHint() {
    const {
      hint
    } = this.option();
    this.$element().attr("title", hint || null);
  },
  _renderContent() {
    deferRender(() => !this._disposed ? this._renderContentImpl() : void 0).done(() => !this._disposed ? this._fireContentReadyAction() : void 0);
  },
  _renderContentImpl: noop2,
  _fireContentReadyAction: deferRenderer(function() {
    return this._contentReadyAction();
  }),
  _dispose() {
    this._contentReadyAction = null;
    this._detachKeyboardEvents();
    this.callBase();
  },
  _resetActiveState() {
    this._toggleActiveState(this._eventBindingTarget(), false);
  },
  _clean() {
    this._cleanFocusState();
    this._resetActiveState();
    this.callBase();
    this.$element().empty();
  },
  _toggleVisibility(visible2) {
    this.$element().toggleClass("dx-state-invisible", !visible2);
  },
  _renderFocusState() {
    this._attachKeyboardEvents();
    if (this._isFocusable()) {
      this._renderFocusTarget();
      this._attachFocusEvents();
      this._renderAccessKey();
    }
  },
  _renderAccessKey() {
    const $el = this._focusTarget();
    const {
      accessKey
    } = this.option();
    $el.attr("accesskey", accessKey);
  },
  _isFocusable() {
    const {
      focusStateEnabled,
      disabled
    } = this.option();
    return focusStateEnabled && !disabled;
  },
  _eventBindingTarget() {
    return this.$element();
  },
  _focusTarget() {
    return this._getActiveElement();
  },
  _isFocusTarget: function(element) {
    const focusTargets = renderer_default(this._focusTarget()).toArray();
    return focusTargets.includes(element);
  },
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit).not(".dx-state-disabled");
  },
  _getActiveElement() {
    const activeElement = this._eventBindingTarget();
    if (this._activeStateUnit) {
      return this._findActiveTarget(activeElement);
    }
    return activeElement;
  },
  _renderFocusTarget() {
    const {
      tabIndex
    } = this.option();
    this._focusTarget().attr("tabIndex", tabIndex);
  },
  _keyboardEventBindingTarget() {
    return this._eventBindingTarget();
  },
  _refreshFocusEvent() {
    this._detachFocusEvents();
    this._attachFocusEvents();
  },
  _focusEventTarget() {
    return this._focusTarget();
  },
  _focusInHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption("onFocusIn", {
        beforeExecute: () => this._updateFocusState(event, true),
        excludeValidators: ["readOnly"]
      })({
        event
      });
    }
  },
  _focusOutHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption("onFocusOut", {
        beforeExecute: () => this._updateFocusState(event, false),
        excludeValidators: ["readOnly", "disabled"]
      })({
        event
      });
    }
  },
  _updateFocusState(_ref, isFocused) {
    let {
      target
    } = _ref;
    if (this._isFocusTarget(target)) {
      this._toggleFocusClass(isFocused, renderer_default(target));
    }
  },
  _toggleFocusClass(isFocused, $element) {
    const $focusTarget = $element && $element.length ? $element : this._focusTarget();
    $focusTarget.toggleClass("dx-state-focused", isFocused);
  },
  _hasFocusClass(element) {
    const $focusTarget = renderer_default(element || this._focusTarget());
    return $focusTarget.hasClass("dx-state-focused");
  },
  _isFocused() {
    return this._hasFocusClass();
  },
  _getKeyboardListeners: () => [],
  _attachKeyboardEvents() {
    this._detachKeyboardEvents();
    const {
      focusStateEnabled,
      onKeyboardHandled
    } = this.option();
    const hasChildListeners = this._getKeyboardListeners().length;
    const hasKeyboardEventHandler = !!onKeyboardHandled;
    const shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;
    if (shouldAttach) {
      this._keyboardListenerId = keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), (opts) => this._keyboardHandler(opts));
    }
  },
  _keyboardHandler(options2, onlyChildProcessing) {
    if (!onlyChildProcessing) {
      const {
        originalEvent,
        keyName,
        which
      } = options2;
      const keys = this._supportedKeys(originalEvent);
      const func = keys[keyName] || keys[which];
      if (void 0 !== func) {
        const handler = func.bind(this);
        const result2 = handler(originalEvent, options2);
        if (!result2) {
          return false;
        }
      }
    }
    const keyboardListeners = this._getKeyboardListeners();
    const {
      onKeyboardHandled
    } = this.option();
    keyboardListeners.forEach((listener) => listener && listener._keyboardHandler(options2));
    onKeyboardHandled && onKeyboardHandled(options2);
    return true;
  },
  _refreshFocusState() {
    this._cleanFocusState();
    this._renderFocusState();
  },
  _cleanFocusState() {
    const $element = this._focusTarget();
    $element.removeAttr("tabIndex");
    this._toggleFocusClass(false);
    this._detachFocusEvents();
    this._detachKeyboardEvents();
  },
  _detachKeyboardEvents() {
    keyboard.off(this._keyboardListenerId);
    this._keyboardListenerId = null;
  },
  _attachHoverEvents() {
    const {
      hoverStateEnabled
    } = this.option();
    const selector = this._activeStateUnit;
    const $el = this._eventBindingTarget();
    hover.off($el, {
      selector,
      namespace: "UIFeedback"
    });
    if (hoverStateEnabled) {
      hover.on($el, new Action((_ref2) => {
        let {
          event,
          element
        } = _ref2;
        this._hoverStartHandler(event);
        this.option("hoveredElement", renderer_default(element));
      }, {
        excludeValidators: ["readOnly"]
      }), (event) => {
        this.option("hoveredElement", null);
        this._hoverEndHandler(event);
      }, {
        selector,
        namespace: "UIFeedback"
      });
    }
  },
  _attachFeedbackEvents() {
    const {
      activeStateEnabled
    } = this.option();
    const selector = this._activeStateUnit;
    const $el = this._eventBindingTarget();
    active.off($el, {
      namespace: "UIFeedback",
      selector
    });
    if (activeStateEnabled) {
      active.on($el, new Action((_ref3) => {
        let {
          event,
          element
        } = _ref3;
        return this._toggleActiveState(renderer_default(element), true, event);
      }), new Action((_ref4) => {
        let {
          event,
          element
        } = _ref4;
        return this._toggleActiveState(renderer_default(element), false, event);
      }, {
        excludeValidators: ["disabled", "readOnly"]
      }), {
        showTimeout: this._feedbackShowTimeout,
        hideTimeout: this._feedbackHideTimeout,
        selector,
        namespace: "UIFeedback"
      });
    }
  },
  _detachFocusEvents() {
    const $el = this._focusEventTarget();
    focus.off($el, {
      namespace: `${this.NAME}Focus`
    });
  },
  _attachFocusEvents() {
    const $el = this._focusEventTarget();
    focus.on($el, (e) => this._focusInHandler(e), (e) => this._focusOutHandler(e), {
      namespace: `${this.NAME}Focus`,
      isFocusable: (index2, el) => renderer_default(el).is(focusable)
    });
  },
  _hoverStartHandler: noop2,
  _hoverEndHandler: noop2,
  _toggleActiveState($element, value2) {
    this.option("isActive", value2);
    $element.toggleClass("dx-state-active", value2);
  },
  _updatedHover() {
    const hoveredElement = this._options.silent("hoveredElement");
    this._hover(hoveredElement, hoveredElement);
  },
  _findHoverTarget($el) {
    return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget());
  },
  _hover($el, $previous) {
    const {
      hoverStateEnabled,
      disabled,
      isActive
    } = this.option();
    $previous = this._findHoverTarget($previous);
    $previous && $previous.toggleClass("dx-state-hover", false);
    if ($el && hoverStateEnabled && !disabled && !isActive) {
      const newHoveredElement = this._findHoverTarget($el);
      newHoveredElement && newHoveredElement.toggleClass("dx-state-hover", true);
    }
  },
  _toggleDisabledState(value2) {
    this.$element().toggleClass("dx-state-disabled", Boolean(value2));
    this.setAria("disabled", value2 || void 0);
  },
  _toggleIndependentState() {
    this.$element().toggleClass("dx-state-independent", this.option("ignoreParentReadOnly"));
  },
  _setWidgetOption(widgetName, args) {
    if (!this[widgetName]) {
      return;
    }
    if (isPlainObject(args[0])) {
      each(args[0], (option, value3) => this._setWidgetOption(widgetName, [option, value3]));
      return;
    }
    const optionName = args[0];
    let value2 = args[1];
    if (1 === args.length) {
      value2 = this.option(optionName);
    }
    const widgetOptionMap = this[`${widgetName}OptionMap`];
    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value2);
  },
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "disabled":
        this._toggleDisabledState(value2);
        this._updatedHover();
        this._refreshFocusState();
        break;
      case "hint":
        this._renderHint();
        break;
      case "ignoreParentReadOnly":
        this._toggleIndependentState();
        break;
      case "activeStateEnabled":
        this._attachFeedbackEvents();
        break;
      case "hoverStateEnabled":
        this._attachHoverEvents();
        this._updatedHover();
        break;
      case "tabIndex":
      case "focusStateEnabled":
        this._refreshFocusState();
        break;
      case "onFocusIn":
      case "onFocusOut":
      case "useResizeObserver":
        break;
      case "accessKey":
        this._renderAccessKey();
        break;
      case "hoveredElement":
        this._hover(value2, previousValue);
        break;
      case "isActive":
        this._updatedHover();
        break;
      case "visible":
        this._toggleVisibility(value2);
        if (this._isVisibilityChangeSupported()) {
          this._checkVisibilityChanged(value2 ? "shown" : "hiding");
        }
        break;
      case "onKeyboardHandled":
        this._attachKeyboardEvents();
        break;
      case "onContentReady":
        this._initContentReadyAction();
        break;
      default:
        this.callBase(args);
    }
  },
  _isVisible() {
    const {
      visible: visible2
    } = this.option();
    return this.callBase() && visible2;
  },
  beginUpdate() {
    this._ready(false);
    this.callBase();
  },
  endUpdate() {
    this.callBase();
    if (this._initialized) {
      this._ready(true);
    }
  },
  _ready(value2) {
    if (0 === arguments.length) {
      return this._isReady;
    }
    this._isReady = value2;
  },
  setAria() {
    if (!isPlainObject(arguments.length <= 0 ? void 0 : arguments[0])) {
      setAttribute(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], (arguments.length <= 2 ? void 0 : arguments[2]) || this._getAriaTarget());
    } else {
      const target = (arguments.length <= 1 ? void 0 : arguments[1]) || this._getAriaTarget();
      each(arguments.length <= 0 ? void 0 : arguments[0], (name2, value2) => setAttribute(name2, value2, target));
    }
  },
  isReady() {
    return this._ready();
  },
  repaint() {
    this._refresh();
  },
  focus() {
    focus.trigger(this._focusTarget());
  },
  registerKeyHandler(key, handler) {
    const currentKeys = this._supportedKeys();
    this._supportedKeys = () => extend(currentKeys, {
      [key]: handler
    });
  }
});
Widget.getOptionsFromContainer = (_ref5) => {
  let {
    name: name2,
    fullName,
    value: value2
  } = _ref5;
  let options2 = {};
  if (name2 === fullName) {
    options2 = value2;
  } else {
    const option = fullName.split(".").pop();
    options2[option] = value2;
  }
  return options2;
};
var ui_widget_default = Widget;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_item.js
var forcibleWatcher = function(watchMethod, fn, callback) {
  const filteredCallback = function() {
    let oldValue;
    return function(value2) {
      if (oldValue !== value2) {
        callback(value2, oldValue);
        oldValue = value2;
      }
    };
  }();
  return {
    dispose: watchMethod(fn, filteredCallback),
    force() {
      filteredCallback(fn());
    }
  };
};
var CollectionItem = class_default.inherit({
  ctor($element, options2, rawData) {
    this._$element = $element;
    this._options = options2;
    this._rawData = rawData;
    attachInstanceToElement($element, this, this._dispose);
    this._render();
  },
  _render() {
    const $placeholder = renderer_default("<div>").addClass("dx-item-content-placeholder");
    this._$element.append($placeholder);
    this._watchers = [];
    this._renderWatchers();
  },
  _renderWatchers() {
    this._startWatcher("disabled", this._renderDisabled.bind(this));
    this._startWatcher("visible", this._renderVisible.bind(this));
  },
  _startWatcher(field, render4) {
    const rawData = this._rawData;
    const exprGetter = this._options.fieldGetter(field);
    const watcher = forcibleWatcher(this._options.watchMethod(), () => exprGetter(rawData), (value2, oldValue) => {
      this._dirty = true;
      render4(value2, oldValue);
    });
    this._watchers.push(watcher);
  },
  setDataField() {
    this._dirty = false;
    each(this._watchers, (_, watcher) => {
      watcher.force();
    });
    if (this._dirty) {
      return true;
    }
  },
  _renderDisabled(value2, oldValue) {
    this._$element.toggleClass("dx-state-disabled", !!value2);
    this._$element.attr("aria-disabled", !!value2);
    this._updateOwnerFocus(value2);
  },
  _updateOwnerFocus(isDisabled) {
    const ownerComponent = this._options.owner;
    if (ownerComponent && isDisabled) {
      ownerComponent._resetItemFocus(this._$element);
    }
  },
  _renderVisible(value2, oldValue) {
    this._$element.toggleClass("dx-state-invisible", void 0 !== value2 && !value2);
  },
  _dispose() {
    each(this._watchers, (_, watcher) => {
      watcher.dispose();
    });
  }
});
CollectionItem.getInstance = function($element) {
  return getInstanceByElement($element, this);
};
var m_item_default = CollectionItem;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.base.js
var ITEM_CLASS = "dx-item";
var EMPTY_COLLECTION = "dx-empty-collection";
var ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
var CollectionWidget = ui_widget_default.inherit({
  _activeStateUnit: `.${ITEM_CLASS}`,
  _supportedKeys() {
    const move2 = function(location, e) {
      if (!isCommandKeyPressed(e)) {
        e.preventDefault();
        e.stopPropagation();
        this._moveFocus(location, e);
      }
    };
    return extend(this.callBase(), {
      space: function(e) {
        e.preventDefault();
        this._enterKeyHandler(e);
      },
      enter: this._enterKeyHandler,
      leftArrow: move2.bind(this, "left"),
      rightArrow: move2.bind(this, "right"),
      upArrow: move2.bind(this, "up"),
      downArrow: move2.bind(this, "down"),
      pageUp: move2.bind(this, "up"),
      pageDown: move2.bind(this, "down"),
      home: move2.bind(this, "first"),
      end: move2.bind(this, "last")
    });
  },
  _enterKeyHandler(e) {
    const $itemElement = renderer_default(this.option("focusedElement"));
    if (!$itemElement.length) {
      return;
    }
    const itemData = this._getItemData($itemElement);
    if (null !== itemData && void 0 !== itemData && itemData.onClick) {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    }
    this._itemClickHandler(extend({}, e, {
      target: $itemElement.get(0),
      currentTarget: $itemElement.get(0)
    }));
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      selectOnFocus: false,
      loopItemFocus: true,
      items: [],
      itemTemplate: "item",
      onItemRendered: null,
      onItemClick: null,
      onItemHold: null,
      itemHoldTimeout: 750,
      onItemContextMenu: null,
      onFocusedItemChanged: null,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      encodeNoDataText: false,
      dataSource: null,
      _dataController: null,
      _itemAttributes: {},
      itemTemplateProperty: "template",
      focusOnSelectedItem: true,
      focusedElement: null,
      displayExpr: void 0,
      disabledExpr: (data2) => data2 ? data2.disabled : void 0,
      visibleExpr: (data2) => data2 ? data2.visible : void 0
    });
  },
  _init() {
    this._compileDisplayGetter();
    this._initDataController();
    this.callBase();
    this._cleanRenderedItems();
    this._refreshDataSource();
  },
  _compileDisplayGetter() {
    const displayExpr = this.option("displayExpr");
    this._displayGetter = displayExpr ? compileGetter(this.option("displayExpr")) : void 0;
  },
  _initTemplates() {
    this._initItemsFromMarkup();
    this._initDefaultItemTemplate();
    this.callBase();
  },
  _getAnonymousTemplateName: () => "item",
  _initDefaultItemTemplate() {
    const fieldsMap = this._getFieldsMap();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data2) => {
        if (isPlainObject(data2)) {
          this._prepareDefaultItemTemplate(data2, $container);
        } else {
          if (fieldsMap && isFunction(fieldsMap.text)) {
            data2 = fieldsMap.text(data2);
          }
          $container.text(String(ensureDefined(data2, "")));
        }
      }, this._getBindableFields(), this.option("integrationOptions.watchMethod"), fieldsMap)
    });
  },
  _getBindableFields: () => ["text", "html"],
  _getFieldsMap() {
    if (this._displayGetter) {
      return {
        text: this._displayGetter
      };
    }
  },
  _prepareDefaultItemTemplate(data2, $container) {
    if (isDefined(data2.text)) {
      $container.text(data2.text);
    }
    if (isDefined(data2.html)) {
      $container.html(data2.html);
    }
  },
  _initItemsFromMarkup() {
    const rawItems = findTemplates(this.$element(), "dxItem");
    if (!rawItems.length || this.option("items").length) {
      return;
    }
    const items = rawItems.map((_ref) => {
      let {
        element,
        options: options2
      } = _ref;
      const isTemplateRequired = /\S/.test(element.innerHTML) && !options2.template;
      if (isTemplateRequired) {
        options2.template = this._prepareItemTemplate(element);
      } else {
        renderer_default(element).remove();
      }
      return options2;
    });
    this.option("items", items);
  },
  _prepareItemTemplate(item) {
    const templateId = "tmpl-" + new guid_default();
    const $template = renderer_default(item).detach().clone().removeAttr("data-options").addClass("dx-template-wrapper");
    this._saveTemplate(templateId, $template);
    return templateId;
  },
  _dataSourceOptions: () => ({
    paginate: false
  }),
  _cleanRenderedItems() {
    this._renderedItemsCount = 0;
  },
  _focusTarget() {
    return this.$element();
  },
  _focusInHandler(e) {
    this.callBase.apply(this, arguments);
    if (!this._isFocusTarget(e.target)) {
      return;
    }
    const $focusedElement = renderer_default(this.option("focusedElement"));
    if ($focusedElement.length) {
      this._setFocusedItem($focusedElement);
    } else {
      const $activeItem = this._getActiveItem();
      if ($activeItem.length) {
        this.option("focusedElement", getPublicElement($activeItem));
      }
    }
  },
  _focusOutHandler() {
    this.callBase.apply(this, arguments);
    const $target = renderer_default(this.option("focusedElement"));
    this._updateFocusedItemState($target, false);
  },
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit);
  },
  _getActiveItem(last) {
    const $focusedElement = renderer_default(this.option("focusedElement"));
    if ($focusedElement.length) {
      return $focusedElement;
    }
    let index2 = this.option("focusOnSelectedItem") ? this.option("selectedIndex") : 0;
    const activeElements = this._getActiveElement();
    const lastIndex = activeElements.length - 1;
    if (index2 < 0) {
      index2 = last ? lastIndex : 0;
    }
    return activeElements.eq(index2);
  },
  _moveFocus(location) {
    const $items = this._getAvailableItems();
    let $newTarget;
    switch (location) {
      case "pageup":
      case "up":
        $newTarget = this._prevItem($items);
        break;
      case "pagedown":
      case "down":
        $newTarget = this._nextItem($items);
        break;
      case "right":
        $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
        break;
      case "left":
        $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
        break;
      case "first":
        $newTarget = $items.first();
        break;
      case "last":
        $newTarget = $items.last();
        break;
      default:
        return false;
    }
    if (0 !== $newTarget.length) {
      this.option("focusedElement", getPublicElement($newTarget));
    }
  },
  _getVisibleItems($itemElements) {
    $itemElements = $itemElements || this._itemElements();
    return $itemElements.filter(":visible");
  },
  _getAvailableItems($itemElements) {
    return this._getVisibleItems($itemElements);
  },
  _prevItem($items) {
    const $target = this._getActiveItem();
    const targetIndex = $items.index($target);
    const $last = $items.last();
    let $item = renderer_default($items[targetIndex - 1]);
    const loop = this.option("loopItemFocus");
    if (0 === $item.length && loop) {
      $item = $last;
    }
    return $item;
  },
  _nextItem($items) {
    const $target = this._getActiveItem(true);
    const targetIndex = $items.index($target);
    const $first = $items.first();
    let $item = renderer_default($items[targetIndex + 1]);
    const loop = this.option("loopItemFocus");
    if (0 === $item.length && loop) {
      $item = $first;
    }
    return $item;
  },
  _selectFocusedItem($target) {
    this.selectItem($target);
  },
  _updateFocusedItemState(target, isFocused, needCleanItemId) {
    const $target = renderer_default(target);
    if ($target.length) {
      this._refreshActiveDescendant();
      this._refreshItemId($target, needCleanItemId);
      this._toggleFocusClass(isFocused, $target);
    }
    this._updateParentActiveDescendant();
  },
  _refreshActiveDescendant($target) {
    this.setAria("activedescendant", isDefined(this.option("focusedElement")) ? this.getFocusedItemId() : null, $target);
  },
  _refreshItemId($target, needCleanItemId) {
    if (!needCleanItemId && this.option("focusedElement")) {
      this.setAria("id", this.getFocusedItemId(), $target);
    } else {
      this.setAria("id", null, $target);
    }
  },
  _isDisabled: ($element) => $element && "true" === renderer_default($element).attr("aria-disabled"),
  _setFocusedItem($target) {
    if (!$target || !$target.length) {
      return;
    }
    this._updateFocusedItemState($target, true);
    this.onFocusedItemChanged(this.getFocusedItemId());
    const {
      selectOnFocus
    } = this.option();
    const isTargetDisabled = this._isDisabled($target);
    if (selectOnFocus && !isTargetDisabled) {
      this._selectFocusedItem($target);
    }
  },
  _findItemElementByItem(item) {
    let result2 = renderer_default();
    const that = this;
    this.itemElements().each(function() {
      const $item = renderer_default(this);
      if ($item.data(that._itemDataKey()) === item) {
        result2 = $item;
        return false;
      }
    });
    return result2;
  },
  _getIndexByItem(item) {
    return this.option("items").indexOf(item);
  },
  _itemOptionChanged(item, property, value2, oldValue) {
    const $item = this._findItemElementByItem(item);
    if (!$item.length) {
      return;
    }
    if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value2)) {
      this._refreshItem($item, item);
    }
    const isDisabling = "disabled" === property && value2;
    if (isDisabling) {
      this._resetItemFocus($item);
    }
  },
  _resetItemFocus($item) {
    if ($item.is(this.option("focusedElement"))) {
      this.option("focusedElement", null);
    }
  },
  _refreshItem($item) {
    const itemData = this._getItemData($item);
    const index2 = $item.data(this._itemIndexKey());
    this._renderItem(this._renderedItemsCount + index2, itemData, null, $item);
  },
  _updateParentActiveDescendant: noop2,
  _optionChanged(args) {
    if ("items" === args.name) {
      const matches = args.fullName.match(ITEM_PATH_REGEX);
      if (matches && matches.length) {
        const property = matches[matches.length - 1];
        const itemPath = args.fullName.replace(`.${property}`, "");
        const item = this.option(itemPath);
        this._itemOptionChanged(item, property, args.value, args.previousValue);
        return;
      }
    }
    switch (args.name) {
      case "items":
      case "_itemAttributes":
      case "itemTemplateProperty":
      case "useItemTextAsTitle":
        this._cleanRenderedItems();
        this._invalidate();
        break;
      case "dataSource":
        this._refreshDataSource();
        this._renderEmptyMessage();
        break;
      case "noDataText":
      case "encodeNoDataText":
        this._renderEmptyMessage();
        break;
      case "itemTemplate":
      case "visibleExpr":
      case "disabledExpr":
        this._invalidate();
        break;
      case "onItemRendered":
        this._createItemRenderAction();
        break;
      case "onItemClick":
      case "selectOnFocus":
      case "loopItemFocus":
      case "focusOnSelectedItem":
        break;
      case "onItemHold":
      case "itemHoldTimeout":
        this._attachHoldEvent();
        break;
      case "onItemContextMenu":
        this._attachContextMenuEvent();
        break;
      case "onFocusedItemChanged":
        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
        break;
      case "focusedElement":
        this._updateFocusedItemState(args.previousValue, false, true);
        this._setFocusedItem(renderer_default(args.value));
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._initDefaultItemTemplate();
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  },
  _invalidate() {
    this.option("focusedElement", null);
    return this.callBase.apply(this, arguments);
  },
  _loadNextPage() {
    this._expectNextPageLoading();
    return this._dataController.loadNextPage();
  },
  _expectNextPageLoading() {
    this._startIndexForAppendedItems = 0;
  },
  _expectLastItemLoading() {
    this._startIndexForAppendedItems = -1;
  },
  _forgetNextPageLoading() {
    this._startIndexForAppendedItems = null;
  },
  _dataSourceChangedHandler(newItems) {
    const items = this.option("items");
    if (this._initialized && items && this._shouldAppendItems()) {
      this._renderedItemsCount = items.length;
      if (!this._isLastPage() || -1 !== this._startIndexForAppendedItems) {
        this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems));
      }
      this._forgetNextPageLoading();
      this._refreshContent();
    } else {
      this.option("items", newItems.slice());
    }
  },
  _refreshContent() {
    this._prepareContent();
    this._renderContent();
  },
  _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading();
    this.option("items", this.option("items"));
  },
  _shouldAppendItems() {
    return null != this._startIndexForAppendedItems && this._allowDynamicItemsAppend();
  },
  _allowDynamicItemsAppend: () => false,
  _clean() {
    this._cleanFocusState();
    this._cleanItemContainer();
    this._inkRipple && delete this._inkRipple;
    this._resetActiveState();
  },
  _cleanItemContainer() {
    renderer_default(this._itemContainer()).empty();
  },
  _dispose() {
    this.callBase();
    clearTimeout(this._itemFocusTimeout);
  },
  _refresh() {
    this._cleanRenderedItems();
    this.callBase.apply(this, arguments);
  },
  _itemContainer() {
    return this.$element();
  },
  _itemClass: () => ITEM_CLASS,
  _itemContentClass() {
    return this._itemClass() + "-content";
  },
  _selectedItemClass: () => "dx-item-selected",
  _itemResponseWaitClass: () => "dx-item-response-wait",
  _itemSelector() {
    return `.${this._itemClass()}`;
  },
  _itemDataKey: () => "dxItemData",
  _itemIndexKey: () => "dxItemIndex",
  _itemElements() {
    return this._itemContainer().find(this._itemSelector());
  },
  _initMarkup() {
    this.callBase();
    this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
    this.$element().addClass("dx-collection");
    this._prepareContent();
  },
  _prepareContent: deferRenderer(function() {
    this._renderContentImpl();
  }),
  _renderContent() {
    this._fireContentReadyAction();
  },
  _render() {
    this.callBase();
    this._attachClickEvent();
    this._attachHoldEvent();
    this._attachContextMenuEvent();
  },
  _getPointerEvent: () => pointer_default.down,
  _attachClickEvent() {
    const itemSelector = this._itemSelector();
    const pointerEvent = this._getPointerEvent();
    const clickEventNamespace = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const pointerEventNamespace = addNamespace2(pointerEvent, this.NAME);
    const pointerAction = new Action((args) => {
      const {
        event
      } = args;
      this._itemPointerDownHandler(event);
    });
    events_engine_default.off(this._itemContainer(), clickEventNamespace, itemSelector);
    events_engine_default.off(this._itemContainer(), pointerEventNamespace, itemSelector);
    events_engine_default.on(this._itemContainer(), clickEventNamespace, itemSelector, (e) => this._itemClickHandler(e));
    events_engine_default.on(this._itemContainer(), pointerEventNamespace, itemSelector, (e) => {
      pointerAction.execute({
        element: renderer_default(e.target),
        event: e
      });
    });
  },
  _itemClickHandler(e, args, config3) {
    this._itemDXEventHandler(e, "onItemClick", args, config3);
  },
  _itemPointerDownHandler(e) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    this._itemFocusHandler = (function() {
      clearTimeout(this._itemFocusTimeout);
      this._itemFocusHandler = null;
      if (e.isDefaultPrevented()) {
        return;
      }
      const $target = renderer_default(e.target);
      const $closestItem = $target.closest(this._itemElements());
      const $closestFocusable = this._closestFocusable($target);
      if ($closestItem.length && this._isFocusTarget(null === $closestFocusable || void 0 === $closestFocusable ? void 0 : $closestFocusable.get(0))) {
        this.option("focusedElement", getPublicElement($closestItem));
      }
    }).bind(this);
    this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this));
  },
  _closestFocusable($target) {
    if ($target.is(focusable)) {
      return $target;
    }
    $target = $target.parent();
    while ($target.length && !dom_adapter_default.isDocument($target.get(0)) && !dom_adapter_default.isDocumentFragment($target.get(0))) {
      if ($target.is(focusable)) {
        return $target;
      }
      $target = $target.parent();
    }
  },
  _forcePointerDownFocus() {
    this._itemFocusHandler && this._itemFocusHandler();
  },
  _updateFocusState() {
    this.callBase.apply(this, arguments);
    this._forcePointerDownFocus();
  },
  _attachHoldEvent() {
    const $itemContainer = this._itemContainer();
    const itemSelector = this._itemSelector();
    const eventName = addNamespace2(hold_default.name, this.NAME);
    events_engine_default.off($itemContainer, eventName, itemSelector);
    events_engine_default.on($itemContainer, eventName, itemSelector, {
      timeout: this._getHoldTimeout()
    }, this._itemHoldHandler.bind(this));
  },
  _getHoldTimeout() {
    return this.option("itemHoldTimeout");
  },
  _shouldFireHoldEvent() {
    return this.hasActionSubscription("onItemHold");
  },
  _itemHoldHandler(e) {
    if (this._shouldFireHoldEvent()) {
      this._itemDXEventHandler(e, "onItemHold");
    } else {
      e.cancel = true;
    }
  },
  _attachContextMenuEvent() {
    const $itemContainer = this._itemContainer();
    const itemSelector = this._itemSelector();
    const eventName = addNamespace2(name, this.NAME);
    events_engine_default.off($itemContainer, eventName, itemSelector);
    events_engine_default.on($itemContainer, eventName, itemSelector, this._itemContextMenuHandler.bind(this));
  },
  _shouldFireContextMenuEvent() {
    return this.hasActionSubscription("onItemContextMenu");
  },
  _itemContextMenuHandler(e) {
    if (this._shouldFireContextMenuEvent()) {
      this._itemDXEventHandler(e, "onItemContextMenu");
    } else {
      e.cancel = true;
    }
  },
  _renderContentImpl() {
    const items = this.option("items") || [];
    if (this._renderedItemsCount) {
      this._renderItems(items.slice(this._renderedItemsCount));
    } else {
      this._renderItems(items);
    }
  },
  _renderItems(items) {
    if (items.length) {
      each(items, (index2, itemData) => {
        this._renderItem(this._renderedItemsCount + index2, itemData);
      });
    }
    this._renderEmptyMessage();
  },
  _getItemsContainer() {
    return this._itemContainer();
  },
  _setAttributes($element) {
    const attributes = _extends({}, this.option("_itemAttributes"));
    const {
      class: customClassValue
    } = attributes;
    if (customClassValue) {
      const currentClassValue = $element.get(0).className;
      attributes.class = [currentClassValue, customClassValue].join(" ");
    }
    $element.attr(attributes);
  },
  _renderItem(index2, itemData, $container, $itemToReplace) {
    const itemIndex = (null === index2 || void 0 === index2 ? void 0 : index2.item) ?? index2;
    $container = $container || this._getItemsContainer();
    const $itemFrame = this._renderItemFrame(itemIndex, itemData, $container, $itemToReplace);
    this._setElementData($itemFrame, itemData, itemIndex);
    this._setAttributes($itemFrame);
    this._attachItemClickEvent(itemData, $itemFrame);
    const $itemContent = this._getItemContent($itemFrame);
    const renderContentPromise = this._renderItemContent({
      index: itemIndex,
      itemData,
      container: getPublicElement($itemContent),
      contentClass: this._itemContentClass(),
      defaultTemplateName: this.option("itemTemplate")
    });
    const that = this;
    when(renderContentPromise).done(($itemContent2) => {
      that._postprocessRenderItem({
        itemElement: $itemFrame,
        itemContent: $itemContent2,
        itemData,
        itemIndex
      });
      that._executeItemRenderAction(index2, itemData, getPublicElement($itemFrame));
    });
    return $itemFrame;
  },
  _getItemContent($itemFrame) {
    const $itemContent = $itemFrame.find(".dx-item-content-placeholder");
    $itemContent.removeClass("dx-item-content-placeholder");
    return $itemContent;
  },
  _attachItemClickEvent(itemData, $itemElement) {
    if (!itemData || !itemData.onClick) {
      return;
    }
    events_engine_default.on($itemElement, CLICK_EVENT_NAME, (e) => {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    });
  },
  _renderItemContent(args) {
    const itemTemplateName = this._getItemTemplateName(args);
    const itemTemplate = this._getTemplate(itemTemplateName);
    this._addItemContentClasses(args);
    const $templateResult = renderer_default(this._createItemByTemplate(itemTemplate, args));
    if (!$templateResult.hasClass("dx-template-wrapper")) {
      return args.container;
    }
    return this._renderItemContentByNode(args, $templateResult);
  },
  _renderItemContentByNode(args, $node) {
    renderer_default(args.container).replaceWith($node);
    args.container = getPublicElement($node);
    this._addItemContentClasses(args);
    return $node;
  },
  _addItemContentClasses(args) {
    const classes = [ITEM_CLASS + "-content", args.contentClass];
    renderer_default(args.container).addClass(classes.join(" "));
  },
  _appendItemToContainer($container, $itemFrame, index2) {
    $itemFrame.appendTo($container);
  },
  _renderItemFrame(index2, itemData, $container, $itemToReplace) {
    const $itemFrame = renderer_default("<div>");
    new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});
    if ($itemToReplace && $itemToReplace.length) {
      $itemToReplace.replaceWith($itemFrame);
    } else {
      this._appendItemToContainer.call(this, $container, $itemFrame, index2);
    }
    if (this.option("useItemTextAsTitle")) {
      const displayValue = this._displayGetter ? this._displayGetter(itemData) : itemData;
      $itemFrame.attr("title", displayValue);
    }
    return $itemFrame;
  },
  _itemOptions() {
    const that = this;
    return {
      watchMethod: () => that.option("integrationOptions.watchMethod"),
      owner: that,
      fieldGetter(field) {
        const expr = that.option(`${field}Expr`);
        const getter = compileGetter(expr);
        return getter;
      }
    };
  },
  _postprocessRenderItem: noop2,
  _executeItemRenderAction(index2, itemData, itemElement) {
    this._getItemRenderAction()({
      itemElement,
      itemIndex: index2,
      itemData
    });
  },
  _setElementData(element, data2, index2) {
    element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data2).data(this._itemIndexKey(), index2);
  },
  _createItemRenderAction() {
    return this._itemRenderAction = this._createActionByOption("onItemRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
  },
  _getItemRenderAction() {
    return this._itemRenderAction || this._createItemRenderAction();
  },
  _getItemTemplateName(args) {
    const data2 = args.itemData;
    const templateProperty = args.templateProperty || this.option("itemTemplateProperty");
    const template = data2 && data2[templateProperty];
    return template || args.defaultTemplateName;
  },
  _createItemByTemplate(itemTemplate, renderArgs) {
    return itemTemplate.render({
      model: renderArgs.itemData,
      container: renderArgs.container,
      index: renderArgs.index,
      onRendered: this._onItemTemplateRendered(itemTemplate, renderArgs)
    });
  },
  _onItemTemplateRendered: () => noop2,
  _emptyMessageContainer() {
    return this._itemContainer();
  },
  _renderEmptyMessage(items) {
    items = items || this.option("items");
    const noDataText = this.option("noDataText");
    const hideNoData = !noDataText || items && items.length || this._dataController.isLoading();
    if (hideNoData && this._$noData) {
      this._$noData.remove();
      this._$noData = null;
      this.setAria("label", void 0);
    }
    if (!hideNoData) {
      this._$noData = this._$noData || renderer_default("<div>").addClass("dx-empty-message");
      this._$noData.appendTo(this._emptyMessageContainer());
      if (this.option("encodeNoDataText")) {
        this._$noData.text(noDataText);
      } else {
        this._$noData.html(noDataText);
      }
    }
    this.$element().toggleClass(EMPTY_COLLECTION, !hideNoData);
  },
  _itemDXEventHandler(dxEvent, handlerOptionName, actionArgs, actionConfig) {
    this._itemEventHandler(dxEvent.target, handlerOptionName, extend(actionArgs, {
      event: dxEvent
    }), actionConfig);
  },
  _itemEventHandler(initiator, handlerOptionName, actionArgs, actionConfig) {
    const action = this._createActionByOption(handlerOptionName, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  },
  _itemEventHandlerByHandler(initiator, handler, actionArgs, actionConfig) {
    const action = this._createAction(handler, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  },
  _itemEventHandlerImpl(initiator, action, actionArgs) {
    const $itemElement = this._closestItemElement(renderer_default(initiator));
    const args = extend({}, actionArgs);
    return action(extend(actionArgs, this._extendActionArgs($itemElement), args));
  },
  _extendActionArgs($itemElement) {
    return {
      itemElement: getPublicElement($itemElement),
      itemIndex: this._itemElements().index($itemElement),
      itemData: this._getItemData($itemElement)
    };
  },
  _closestItemElement($element) {
    return renderer_default($element).closest(this._itemSelector());
  },
  _getItemData(itemElement) {
    return renderer_default(itemElement).data(this._itemDataKey());
  },
  _getSummaryItemsSize(dimension, items, includeMargin) {
    let result2 = 0;
    if (items) {
      each(items, (_, item) => {
        if ("width" === dimension) {
          result2 += getOuterWidth(item, includeMargin || false);
        } else if ("height" === dimension) {
          result2 += getOuterHeight(item, includeMargin || false);
        }
      });
    }
    return result2;
  },
  getFocusedItemId() {
    if (!this._focusedItemId) {
      this._focusedItemId = `dx-${new guid_default()}`;
    }
    return this._focusedItemId;
  },
  itemElements() {
    return this._itemElements();
  },
  itemsContainer() {
    return this._itemContainer();
  }
}).include(data_helper_default);
CollectionWidget.ItemClass = m_item_default;
var m_collection_widget_base_default = CollectionWidget;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.strategy.js
var {
  abstract: abstract4
} = class_default;
var EditStrategy = class_default.inherit({
  ctor(collectionWidget) {
    this._collectionWidget = collectionWidget;
  },
  getIndexByItemData: abstract4,
  getItemDataByIndex: abstract4,
  getKeysByItems: abstract4,
  getItemsByKeys: abstract4,
  itemsGetter: abstract4,
  getKeyByIndex(index2) {
    const resultIndex = this._denormalizeItemIndex(index2);
    return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0];
  },
  _equalKeys(key1, key2) {
    if (this._collectionWidget._isKeySpecified()) {
      return equalByValue(key1, key2);
    }
    return key1 === key2;
  },
  beginCache() {
    this._cache = {};
  },
  endCache() {
    this._cache = null;
  },
  getIndexByKey: abstract4,
  getNormalizedIndex(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return value2;
    }
    if (this._isItemIndex(value2)) {
      return this._normalizeItemIndex(value2);
    }
    if (this._isNode(value2)) {
      return this._getNormalizedItemIndex(value2);
    }
    return this._normalizeItemIndex(this.getIndexByItemData(value2));
  },
  getIndex(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._denormalizeItemIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return value2;
    }
    if (this._isNode(value2)) {
      return this._denormalizeItemIndex(this._getNormalizedItemIndex(value2));
    }
    return this.getIndexByItemData(value2);
  },
  getItemElement(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._getItemByNormalizedIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return this._getItemByNormalizedIndex(this._normalizeItemIndex(value2));
    }
    if (this._isNode(value2)) {
      return renderer_default(value2);
    }
    const normalizedItemIndex = this._normalizeItemIndex(this.getIndexByItemData(value2));
    return this._getItemByNormalizedIndex(normalizedItemIndex);
  },
  _isNode: (el) => dom_adapter_default.isNode(el && isRenderer(el) ? el.get(0) : el),
  deleteItemAtIndex: abstract4,
  itemPlacementFunc(movingIndex, destinationIndex) {
    return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before";
  },
  moveItemAtIndexToIndex: abstract4,
  _isNormalizedItemIndex: (index2) => "number" === typeof index2 && Math.round(index2) === index2,
  _isItemIndex: abstract4,
  _getNormalizedItemIndex: abstract4,
  _normalizeItemIndex: abstract4,
  _denormalizeItemIndex: abstract4,
  _getItemByNormalizedIndex: abstract4,
  _itemsFromSameParent: abstract4
});
var m_collection_widget_edit_strategy_default = EditStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.strategy.plain.js
var PlainEditStrategy = m_collection_widget_edit_strategy_default.inherit({
  _getPlainItems() {
    return this._collectionWidget.option("items") || [];
  },
  getIndexByItemData(itemData) {
    const keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    if (keyOf) {
      return this.getIndexByKey(keyOf(itemData));
    }
    return this._getPlainItems().indexOf(itemData);
  },
  getItemDataByIndex(index2) {
    return this._getPlainItems()[index2];
  },
  deleteItemAtIndex(index2) {
    this._getPlainItems().splice(index2, 1);
  },
  itemsGetter() {
    return this._getPlainItems();
  },
  getKeysByItems(items) {
    const keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    let result2 = items;
    if (keyOf) {
      result2 = [];
      for (let i = 0; i < items.length; i++) {
        result2.push(keyOf(items[i]));
      }
    }
    return result2;
  },
  getIndexByKey(key) {
    const cache = this._cache;
    const keys = cache && cache.keys || this.getKeysByItems(this._getPlainItems());
    if (cache && !cache.keys) {
      cache.keys = keys;
    }
    if ("object" === typeof key) {
      for (let i = 0, {
        length
      } = keys; i < length; i++) {
        if (this._equalKeys(key, keys[i])) {
          return i;
        }
      }
    } else {
      return keys.indexOf(key);
    }
    return -1;
  },
  getItemsByKeys: (keys, items) => (items || keys).slice(),
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    const items = this._getPlainItems();
    const movedItemData = items[movingIndex];
    items.splice(movingIndex, 1);
    items.splice(destinationIndex, 0, movedItemData);
  },
  _isItemIndex: (index2) => "number" === typeof index2 && Math.round(index2) === index2,
  _getNormalizedItemIndex(itemElement) {
    return this._collectionWidget._itemElements().index(itemElement);
  },
  _normalizeItemIndex: (index2) => index2,
  _denormalizeItemIndex: (index2) => index2,
  _getItemByNormalizedIndex(index2) {
    return index2 > -1 ? this._collectionWidget._itemElements().eq(index2) : null;
  },
  _itemsFromSameParent: () => true
});
var m_collection_widget_edit_strategy_plain_default = PlainEditStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.js
var indexExists = function(index2) {
  return -1 !== index2;
};
var CollectionWidget2 = m_collection_widget_base_default.inherit({
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      selectedItem: true
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      selectionMode: "none",
      selectionRequired: false,
      selectByClick: true,
      selectedItems: [],
      selectedItemKeys: [],
      maxFilterLengthInRequest: 1500,
      keyExpr: null,
      selectedIndex: -1,
      selectedItem: null,
      onSelectionChanged: null,
      onItemReordered: null,
      onItemDeleting: null,
      onItemDeleted: null
    });
  },
  ctor(element, options2) {
    this._userOptions = options2 || {};
    this.callBase(element, options2);
  },
  _init() {
    this._initEditStrategy();
    this.callBase();
    this._initKeyGetter();
    this._initSelectionModule();
  },
  _initKeyGetter() {
    this._keyGetter = compileGetter(this.option("keyExpr"));
  },
  _getKeysByItems(selectedItems) {
    return this._editStrategy.getKeysByItems(selectedItems);
  },
  _getItemsByKeys(selectedItemKeys, selectedItems) {
    return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems);
  },
  _getKeyByIndex(index2) {
    return this._editStrategy.getKeyByIndex(index2);
  },
  _getIndexByKey(key) {
    return this._editStrategy.getIndexByKey(key);
  },
  _getIndexByItemData(itemData) {
    return this._editStrategy.getIndexByItemData(itemData);
  },
  _isKeySpecified() {
    return !!this._dataController.key();
  },
  _getCombinedFilter() {
    return this._dataController.filter();
  },
  key() {
    if (this.option("keyExpr")) {
      return this.option("keyExpr");
    }
    return this._dataController.key();
  },
  keyOf(item) {
    let key = item;
    if (this.option("keyExpr")) {
      key = this._keyGetter(item);
    } else if (this._dataController.store()) {
      key = this._dataController.keyOf(item);
    }
    return key;
  },
  _nullValueSelectionSupported: () => false,
  _initSelectionModule() {
    const that = this;
    const {
      itemsGetter
    } = that._editStrategy;
    this._selection = new Selection({
      allowNullValue: this._nullValueSelectionSupported(),
      mode: this.option("selectionMode"),
      maxFilterLengthInRequest: this.option("maxFilterLengthInRequest"),
      equalByReference: !this._isKeySpecified(),
      onSelectionChanged(args) {
        if (args.addedItemKeys.length || args.removedItemKeys.length) {
          that.option("selectedItems", that._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
          that._updateSelectedItems(args);
        }
      },
      filter: that._getCombinedFilter.bind(that),
      totalCount() {
        const items = that.option("items");
        const totalCount = that._dataController.totalCount();
        return totalCount >= 0 ? totalCount : that._getItemsCount(items);
      },
      key: that.key.bind(that),
      keyOf: that.keyOf.bind(that),
      load(options2) {
        var _dataController$loadO;
        const dataController = that._dataController;
        options2.customQueryParams = null === (_dataController$loadO = dataController.loadOptions()) || void 0 === _dataController$loadO ? void 0 : _dataController$loadO.customQueryParams;
        options2.userData = dataController.userData();
        if (dataController.store()) {
          return dataController.loadFromStore(options2).done((loadResult) => {
            if (that._disposed) {
              return;
            }
            const items = normalizeLoadResult(loadResult).data;
            dataController.applyMapFunction(items);
          });
        }
        return Deferred().resolve(this.plainItems());
      },
      dataFields: () => that._dataController.select(),
      plainItems: itemsGetter.bind(that._editStrategy)
    });
  },
  _getItemsCount(items) {
    return items.reduce((itemsCount, item) => itemsCount + (item.items ? this._getItemsCount(item.items) : 1), 0);
  },
  _initEditStrategy() {
    const Strategy = m_collection_widget_edit_strategy_plain_default;
    this._editStrategy = new Strategy(this);
  },
  _getSelectedItemIndices(keys) {
    const that = this;
    const indices = [];
    keys = keys || this._selection.getSelectedItemKeys();
    that._editStrategy.beginCache();
    each(keys, (_, key) => {
      const selectedIndex = that._getIndexByKey(key);
      if (indexExists(selectedIndex)) {
        indices.push(selectedIndex);
      }
    });
    that._editStrategy.endCache();
    return indices;
  },
  _initMarkup() {
    this._rendering = true;
    if (!this._dataController.isLoading()) {
      this._syncSelectionOptions().done(() => this._normalizeSelectedItems());
    }
    this.callBase();
  },
  _render() {
    this.callBase();
    this._rendering = false;
  },
  _fireContentReadyAction() {
    this._rendering = false;
    this._rendered = true;
    this.callBase.apply(this, arguments);
  },
  _syncSelectionOptions(byOption) {
    byOption = byOption || this._chooseSelectOption();
    let selectedItem;
    let selectedIndex;
    let selectedItemKeys;
    let selectedItems;
    switch (byOption) {
      case "selectedIndex":
        selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedItem", selectedItem);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedItem", null);
        }
        break;
      case "selectedItems":
        selectedItems = this.option("selectedItems") || [];
        selectedIndex = selectedItems.length ? this._editStrategy.getIndexByItemData(selectedItems[0]) : -1;
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        this._setOptionWithoutOptionChange("selectedItem", selectedItems[0]);
        this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
        this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems(selectedItems));
        break;
      case "selectedItem":
        selectedItem = this.option("selectedItem");
        selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedIndex", -1);
        }
        break;
      case "selectedItemKeys":
        selectedItemKeys = this.option("selectedItemKeys");
        if (this.option("selectionRequired")) {
          const selectedItemIndex = this._getIndexByKey(selectedItemKeys[0]);
          if (!indexExists(selectedItemIndex)) {
            return this._syncSelectionOptions("selectedIndex");
          }
        }
        return this._selection.setSelection(selectedItemKeys);
    }
    return Deferred().resolve().promise();
  },
  _chooseSelectOption() {
    let optionName = "selectedIndex";
    const isOptionDefined = (function(optionName2) {
      const optionValue = this.option(optionName2);
      const length = isDefined(optionValue) && optionValue.length;
      return length || optionName2 in this._userOptions;
    }).bind(this);
    if (isOptionDefined("selectedItems")) {
      optionName = "selectedItems";
    } else if (isOptionDefined("selectedItem")) {
      optionName = "selectedItem";
    } else if (isOptionDefined("selectedItemKeys")) {
      optionName = "selectedItemKeys";
    }
    return optionName;
  },
  _compareKeys(oldKeys, newKeys) {
    if (oldKeys.length !== newKeys.length) {
      return false;
    }
    for (let i = 0; i < newKeys.length; i++) {
      if (oldKeys[i] !== newKeys[i]) {
        return false;
      }
    }
    return true;
  },
  _normalizeSelectedItems() {
    if ("none" === this.option("selectionMode")) {
      this._setOptionWithoutOptionChange("selectedItems", []);
      this._syncSelectionOptions("selectedItems");
    } else if ("single" === this.option("selectionMode")) {
      const newSelection = this.option("selectedItems");
      if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && this.option("items") && this.option("items").length) {
        const currentSelection = this._selection.getSelectedItems();
        let normalizedSelection = void 0 === newSelection[0] ? currentSelection[0] : newSelection[0];
        if (void 0 === normalizedSelection) {
          normalizedSelection = this._editStrategy.itemsGetter()[0];
        }
        if (this.option("grouped") && normalizedSelection && normalizedSelection.items) {
          normalizedSelection.items = [normalizedSelection.items[0]];
        }
        this._selection.setSelection(this._getKeysByItems([normalizedSelection]));
        this._setOptionWithoutOptionChange("selectedItems", [normalizedSelection]);
        return this._syncSelectionOptions("selectedItems");
      }
      this._selection.setSelection(this._getKeysByItems(newSelection));
    } else {
      const newKeys = this._getKeysByItems(this.option("selectedItems"));
      const oldKeys = this._selection.getSelectedItemKeys();
      if (!this._compareKeys(oldKeys, newKeys)) {
        this._selection.setSelection(newKeys);
      }
    }
    return Deferred().resolve().promise();
  },
  _itemClickHandler(e) {
    let itemSelectPromise = Deferred().resolve();
    const {
      callBase
    } = this;
    this._createAction((e2) => {
      itemSelectPromise = this._itemSelectHandler(e2.event) ?? itemSelectPromise;
    }, {
      validatingTargetName: "itemElement"
    })({
      itemElement: renderer_default(e.currentTarget),
      event: e
    });
    itemSelectPromise.always(() => {
      callBase.apply(this, arguments);
    });
  },
  _itemSelectHandler(e) {
    var _itemSelectPromise;
    let itemSelectPromise;
    if (!this.option("selectByClick")) {
      return;
    }
    const $itemElement = e.currentTarget;
    if (this.isItemSelected($itemElement)) {
      this.unselectItem(e.currentTarget);
    } else {
      itemSelectPromise = this.selectItem(e.currentTarget);
    }
    return null === (_itemSelectPromise = itemSelectPromise) || void 0 === _itemSelectPromise ? void 0 : _itemSelectPromise.promise();
  },
  _selectedItemElement(index2) {
    return this._itemElements().eq(index2);
  },
  _postprocessRenderItem(args) {
    if ("none" !== this.option("selectionMode")) {
      const $itemElement = renderer_default(args.itemElement);
      const normalizedItemIndex = this._editStrategy.getNormalizedIndex($itemElement);
      const isItemSelected = this._isItemSelected(normalizedItemIndex);
      this._processSelectableItem($itemElement, isItemSelected);
    }
  },
  _processSelectableItem($itemElement, isSelected) {
    $itemElement.toggleClass(this._selectedItemClass(), isSelected);
    this._setAriaSelectionAttribute($itemElement, String(isSelected));
  },
  _updateSelectedItems(args) {
    const that = this;
    const {
      addedItemKeys
    } = args;
    const {
      removedItemKeys
    } = args;
    if (that._rendered && (addedItemKeys.length || removedItemKeys.length)) {
      const selectionChangePromise = that._selectionChangePromise;
      if (!that._rendering) {
        const addedSelection = [];
        let normalizedIndex;
        const removedSelection = [];
        that._editStrategy.beginCache();
        for (let i = 0; i < addedItemKeys.length; i++) {
          normalizedIndex = that._getIndexByKey(addedItemKeys[i]);
          addedSelection.push(normalizedIndex);
          that._addSelection(normalizedIndex);
        }
        for (let i = 0; i < removedItemKeys.length; i++) {
          normalizedIndex = that._getIndexByKey(removedItemKeys[i]);
          removedSelection.push(normalizedIndex);
          that._removeSelection(normalizedIndex);
        }
        that._editStrategy.endCache();
        that._updateSelection(addedSelection, removedSelection);
      }
      when(selectionChangePromise).done(() => {
        that._fireSelectionChangeEvent(args.addedItems, args.removedItems);
      });
    }
  },
  _fireSelectionChangeEvent(addedItems, removedItems) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems,
      removedItems
    });
  },
  _updateSelection: noop2,
  _setAriaSelectionAttribute($target, value2) {
    this.setAria("selected", value2, $target);
  },
  _removeSelection(normalizedIndex) {
    const $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, false);
      events_engine_default.triggerHandler($itemElement, "stateChanged", false);
    }
  },
  _addSelection(normalizedIndex) {
    const $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, true);
      events_engine_default.triggerHandler($itemElement, "stateChanged", true);
    }
  },
  _isItemSelected(index2) {
    const key = this._getKeyByIndex(index2);
    return this._selection.isItemSelected(key, {
      checkPending: true
    });
  },
  _optionChanged(args) {
    switch (args.name) {
      case "selectionMode":
        this._invalidate();
        break;
      case "dataSource":
        if (!args.value || Array.isArray(args.value) && !args.value.length) {
          this.option("selectedItemKeys", []);
        }
        this.callBase(args);
        break;
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
      case "selectedItemKeys":
        this._syncSelectionOptions(args.name).done(() => this._normalizeSelectedItems());
        break;
      case "keyExpr":
        this._initKeyGetter();
        break;
      case "selectionRequired":
        this._normalizeSelectedItems();
        break;
      case "selectByClick":
      case "onSelectionChanged":
      case "onItemDeleting":
      case "onItemDeleted":
      case "onItemReordered":
      case "maxFilterLengthInRequest":
        break;
      default:
        this.callBase(args);
    }
  },
  _clearSelectedItems() {
    this._setOptionWithoutOptionChange("selectedItems", []);
    this._syncSelectionOptions("selectedItems");
  },
  _waitDeletingPrepare($itemElement) {
    if ($itemElement.data("dxItemDeleting")) {
      return Deferred().resolve().promise();
    }
    $itemElement.data("dxItemDeleting", true);
    const deferred = Deferred();
    const deletingActionArgs = {
      cancel: false
    };
    const deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", deletingActionArgs, {
      excludeValidators: ["disabled", "readOnly"]
    });
    when(deletePromise).always(function(value2) {
      const deletePromiseExists = !deletePromise;
      const deletePromiseResolved = !deletePromiseExists && "resolved" === deletePromise.state();
      const argumentsSpecified = !!arguments.length;
      const shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value2;
      when(fromPromise(deletingActionArgs.cancel)).always(() => {
        $itemElement.data("dxItemDeleting", false);
      }).done((cancel2) => {
        shouldDelete && !cancel2 ? deferred.resolve() : deferred.reject();
      }).fail(deferred.reject);
    });
    return deferred.promise();
  },
  _deleteItemFromDS($item) {
    const dataController = this._dataController;
    const deferred = Deferred();
    const disabledState = this.option("disabled");
    const dataStore = dataController.store();
    if (!dataStore) {
      return Deferred().resolve().promise();
    }
    if (!dataStore.remove) {
      throw ui_errors_default.Error("E1011");
    }
    this.option("disabled", true);
    dataStore.remove(dataController.keyOf(this._getItemData($item))).done((key) => {
      if (void 0 !== key) {
        deferred.resolve();
      } else {
        deferred.reject();
      }
    }).fail(() => {
      deferred.reject();
    });
    deferred.always(() => {
      this.option("disabled", disabledState);
    });
    return deferred;
  },
  _tryRefreshLastPage() {
    const deferred = Deferred();
    if (this._isLastPage() || this.option("grouped")) {
      deferred.resolve();
    } else {
      this._refreshLastPage().done(() => {
        deferred.resolve();
      });
    }
    return deferred.promise();
  },
  _refreshLastPage() {
    this._expectLastItemLoading();
    return this._dataController.load();
  },
  _updateSelectionAfterDelete(index2) {
    const key = this._getKeyByIndex(index2);
    this._selection.deselect([key]);
  },
  _updateIndicesAfterIndex(index2) {
    const itemElements = this._itemElements();
    for (let i = index2 + 1; i < itemElements.length; i++) {
      renderer_default(itemElements[i]).data(this._itemIndexKey(), i - 1);
    }
  },
  _simulateOptionChange(optionName) {
    const optionValue = this.option(optionName);
    if (optionValue instanceof DataSource) {
      return;
    }
    this._optionChangedAction({
      name: optionName,
      fullName: optionName,
      value: optionValue
    });
  },
  isItemSelected(itemElement) {
    return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement));
  },
  selectItem(itemElement) {
    if ("none" === this.option("selectionMode")) {
      return;
    }
    const itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return;
    }
    const key = this._getKeyByIndex(itemIndex);
    if (this._selection.isItemSelected(key)) {
      return;
    }
    if ("single" === this.option("selectionMode")) {
      return this._selection.setSelection([key]);
    }
    const selectedItemKeys = this.option("selectedItemKeys") || [];
    return this._selection.setSelection([...selectedItemKeys, key], [key]);
  },
  unselectItem(itemElement) {
    const itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return;
    }
    const selectedItemKeys = this._selection.getSelectedItemKeys();
    if (this.option("selectionRequired") && selectedItemKeys.length <= 1) {
      return;
    }
    const key = this._getKeyByIndex(itemIndex);
    if (!this._selection.isItemSelected(key, {
      checkPending: true
    })) {
      return;
    }
    this._selection.deselect([key]);
  },
  _deleteItemElementByIndex(index2) {
    this._updateSelectionAfterDelete(index2);
    this._updateIndicesAfterIndex(index2);
    this._editStrategy.deleteItemAtIndex(index2);
  },
  _afterItemElementDeleted($item, deletedActionArgs) {
    const changingOption = this._dataController.getDataSource() ? "dataSource" : "items";
    this._simulateOptionChange(changingOption);
    this._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
      beforeExecute() {
        $item.remove();
      },
      excludeValidators: ["disabled", "readOnly"]
    });
    this._renderEmptyMessage();
  },
  deleteItem(itemElement) {
    const that = this;
    const deferred = Deferred();
    const $item = this._editStrategy.getItemElement(itemElement);
    const index2 = this._editStrategy.getNormalizedIndex(itemElement);
    const itemResponseWaitClass = this._itemResponseWaitClass();
    if (indexExists(index2)) {
      this._waitDeletingPrepare($item).done(() => {
        $item.addClass(itemResponseWaitClass);
        const deletedActionArgs = that._extendActionArgs($item);
        that._deleteItemFromDS($item).done(() => {
          that._deleteItemElementByIndex(index2);
          that._afterItemElementDeleted($item, deletedActionArgs);
          that._tryRefreshLastPage().done(() => {
            deferred.resolveWith(that);
          });
        }).fail(() => {
          $item.removeClass(itemResponseWaitClass);
          deferred.rejectWith(that);
        });
      }).fail(() => {
        deferred.rejectWith(that);
      });
    } else {
      deferred.rejectWith(that);
    }
    return deferred.promise();
  },
  reorderItem(itemElement, toItemElement) {
    const deferred = Deferred();
    const that = this;
    const strategy4 = this._editStrategy;
    const $movingItem = strategy4.getItemElement(itemElement);
    const $destinationItem = strategy4.getItemElement(toItemElement);
    const movingIndex = strategy4.getNormalizedIndex(itemElement);
    const destinationIndex = strategy4.getNormalizedIndex(toItemElement);
    const changingOption = this._dataController.getDataSource() ? "dataSource" : "items";
    const canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;
    if (canMoveItems) {
      deferred.resolveWith(this);
    } else {
      deferred.rejectWith(this);
    }
    return deferred.promise().done(function() {
      $destinationItem[strategy4.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
      strategy4.moveItemAtIndexToIndex(movingIndex, destinationIndex);
      this._updateIndicesAfterIndex(movingIndex);
      that.option("selectedItems", that._getItemsByKeys(that._selection.getSelectedItemKeys(), that._selection.getSelectedItems()));
      if ("items" === changingOption) {
        that._simulateOptionChange(changingOption);
      }
      that._itemEventHandler($movingItem, "onItemReordered", {
        fromIndex: strategy4.getIndex(movingIndex),
        toIndex: strategy4.getIndex(destinationIndex)
      }, {
        excludeValidators: ["disabled", "readOnly"]
      });
    });
  }
});
var m_collection_widget_edit_default = CollectionWidget2;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.async.js
var AsyncCollectionWidget = m_collection_widget_edit_default.inherit({
  _initMarkup() {
    this._deferredItems = [];
    this.callBase();
  },
  _renderItemContent(args) {
    const renderContentDeferred = Deferred();
    const itemDeferred = Deferred();
    this._deferredItems[args.index] = itemDeferred;
    const $itemContent = this.callBase.call(this, args);
    itemDeferred.done(() => {
      renderContentDeferred.resolve($itemContent);
    });
    return renderContentDeferred.promise();
  },
  _onItemTemplateRendered(itemTemplate, renderArgs) {
    return () => {
      this._deferredItems[renderArgs.index].resolve();
    };
  },
  _postProcessRenderItems: noop2,
  _renderItemsAsync() {
    const d = Deferred();
    when.apply(this, this._deferredItems).done(() => {
      this._postProcessRenderItems();
      d.resolve();
    });
    return d.promise();
  },
  _clean() {
    this.callBase();
    this._deferredItems = [];
  }
});
var m_collection_widget_async_default = AsyncCollectionWidget;

// ../../../../../../node_modules/devextreme/esm/ui/collection/ui.collection_widget.async.js
var ui_collection_widget_async_default = m_collection_widget_async_default;

// ../../../../../../node_modules/devextreme/esm/ui/collection/ui.collection_widget.edit.js
var ui_collection_widget_edit_default = m_collection_widget_edit_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/widget.js
var TypedWidget = ui_widget_default;
var widget_default = TypedWidget;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/edit.js
var TypedCollectionWidget = ui_collection_widget_edit_default;
var edit_default = TypedCollectionWidget;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/async.js
var TypedCollectionWidget2 = ui_collection_widget_async_default;
var async_default = TypedCollectionWidget2;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/m_constants.js
var TOOLBAR_CLASS = "dx-toolbar";

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.base.js
var TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey";
var ToolbarBase = class extends async_default {
  _getSynchronizableOptionsForCreateComponent() {
    return super._getSynchronizableOptionsForCreateComponent().filter((item) => "disabled" !== item);
  }
  _initTemplates() {
    super._initTemplates();
    const template = new BindableTemplate(($container, data2, rawModel) => {
      if (isPlainObject(data2)) {
        const {
          text,
          html,
          widget
        } = data2;
        if (text) {
          $container.text(text).wrapInner("<div>");
        }
        if (html) {
          $container.html(html);
        }
        if ("dxDropDownButton" === widget) {
          data2.options = data2.options ?? {};
          if (!isDefined(data2.options.stylingMode)) {
            data2.options.stylingMode = this.option("useFlatButtons") ? "text" : "contained";
          }
        }
        if ("dxButton" === widget) {
          if (this.option("useFlatButtons")) {
            data2.options = data2.options ?? {};
            data2.options.stylingMode = data2.options.stylingMode ?? "text";
          }
          if (this.option("useDefaultButtons")) {
            data2.options = data2.options ?? {};
            data2.options.type = data2.options.type ?? "default";
          }
        }
      } else {
        $container.text(String(data2));
      }
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: rawModel,
        parent: this
      });
    }, ["text", "html", "widget", "options"], this.option("integrationOptions.watchMethod"));
    this._templateManager.addDefaultTemplates({
      item: template,
      menuItem: template
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      renderAs: "topToolbar",
      grouped: false,
      useFlatButtons: false,
      useDefaultButtons: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => isMaterialBased(),
      options: {
        useFlatButtons: true
      }
    }]);
  }
  _itemContainer() {
    return this._$toolbarItemsContainer.find([".dx-toolbar-before", ".dx-toolbar-center", ".dx-toolbar-after"].join(","));
  }
  _itemClass() {
    return "dx-toolbar-item";
  }
  _itemDataKey() {
    return TOOLBAR_ITEM_DATA_KEY;
  }
  _dimensionChanged(dimension) {
    if (this._disposed) {
      return;
    }
    this._arrangeItems();
    this._applyCompactMode();
  }
  _initMarkup() {
    this._renderToolbar();
    this._renderSections();
    super._initMarkup();
  }
  _render() {
    super._render();
    this._renderItemsAsync();
    this._updateDimensionsInMaterial();
  }
  _postProcessRenderItems() {
    this._arrangeItems();
  }
  _renderToolbar() {
    this.$element().addClass(TOOLBAR_CLASS);
    this._$toolbarItemsContainer = renderer_default("<div>").addClass("dx-toolbar-items-container").appendTo(this.$element());
    this.setAria("role", "toolbar");
  }
  _renderSections() {
    const $container = this._$toolbarItemsContainer;
    each(["before", "center", "after"], (_, section) => {
      const sectionClass = `dx-toolbar-${section}`;
      const $section = $container.find(`.${sectionClass}`);
      if (!$section.length) {
        this[`_$${section}Section`] = renderer_default("<div>").addClass(sectionClass).attr("role", "presentation").appendTo($container);
      }
    });
  }
  _arrangeItems(width) {
    var _this$_$beforeSection, _this$_$afterSection;
    const elementWidth = width ?? getWidth(this.$element());
    this._$centerSection.css({
      margin: "0 auto",
      float: "none"
    });
    const beforeRect = getBoundingRect(null === (_this$_$beforeSection = this._$beforeSection) || void 0 === _this$_$beforeSection ? void 0 : _this$_$beforeSection.get(0));
    const afterRect = getBoundingRect(null === (_this$_$afterSection = this._$afterSection) || void 0 === _this$_$afterSection ? void 0 : _this$_$afterSection.get(0));
    this._alignCenterSection(beforeRect, afterRect, elementWidth);
    const $label = this._$toolbarItemsContainer.find(".dx-toolbar-label").eq(0);
    const $section = $label.parent();
    if (!$label.length) {
      return;
    }
    const labelOffset = beforeRect.width ? beforeRect.width : $label.position().left;
    const widthBeforeSection = $section.hasClass("dx-toolbar-before") ? 0 : labelOffset;
    const widthAfterSection = $section.hasClass("dx-toolbar-after") ? 0 : afterRect.width;
    let elemsAtSectionWidth = 0;
    $section.children().not(".dx-toolbar-label").each((index2, element) => {
      elemsAtSectionWidth += getOuterWidth(element);
    });
    const freeSpace = elementWidth - elemsAtSectionWidth;
    const sectionMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection, 0);
    if ($section.hasClass("dx-toolbar-before")) {
      this._alignSection(this._$beforeSection, sectionMaxWidth);
    } else {
      const labelPaddings = getOuterWidth($label) - getWidth($label);
      $label.css("maxWidth", sectionMaxWidth - labelPaddings);
    }
  }
  _alignCenterSection(beforeRect, afterRect, elementWidth) {
    var _this$_$centerSection;
    this._alignSection(this._$centerSection, elementWidth - beforeRect.width - afterRect.width);
    const isRTL = this.option("rtlEnabled");
    const leftRect = isRTL ? afterRect : beforeRect;
    const rightRect = isRTL ? beforeRect : afterRect;
    const centerRect = getBoundingRect(null === (_this$_$centerSection = this._$centerSection) || void 0 === _this$_$centerSection ? void 0 : _this$_$centerSection.get(0));
    if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {
      this._$centerSection.css({
        marginLeft: leftRect.width,
        marginRight: rightRect.width,
        float: leftRect.width > rightRect.width ? "none" : "right"
      });
    }
  }
  _alignSection($section, maxWidth) {
    const $labels = $section.find(".dx-toolbar-label");
    let labels = $labels.toArray();
    maxWidth -= this._getCurrentLabelsPaddings(labels);
    const currentWidth = this._getCurrentLabelsWidth(labels);
    const difference = Math.abs(currentWidth - maxWidth);
    if (maxWidth < currentWidth) {
      labels = labels.reverse();
      this._alignSectionLabels(labels, difference, false);
    } else {
      this._alignSectionLabels(labels, difference, true);
    }
  }
  _alignSectionLabels(labels, difference, expanding) {
    const getRealLabelWidth = function(label) {
      return getBoundingRect(label).width;
    };
    for (let i = 0; i < labels.length; i++) {
      const $label = renderer_default(labels[i]);
      const currentLabelWidth = Math.ceil(getRealLabelWidth(labels[i]));
      let labelMaxWidth;
      if (expanding) {
        $label.css("maxWidth", "inherit");
      }
      const possibleLabelWidth = Math.ceil(expanding ? getRealLabelWidth(labels[i]) : currentLabelWidth);
      if (possibleLabelWidth < difference) {
        labelMaxWidth = expanding ? possibleLabelWidth : 0;
        difference -= possibleLabelWidth;
      } else {
        labelMaxWidth = expanding ? currentLabelWidth + difference : currentLabelWidth - difference;
        $label.css("maxWidth", labelMaxWidth);
        break;
      }
      $label.css("maxWidth", labelMaxWidth);
    }
  }
  _applyCompactMode() {
    const $element = renderer_default(this.element());
    $element.removeClass("dx-toolbar-compact");
    if (this.option("compactMode") && this._getSummaryItemsSize("width", this._itemElements(), true) > getWidth($element)) {
      $element.addClass("dx-toolbar-compact");
    }
  }
  _getCurrentLabelsWidth(labels) {
    let width = 0;
    labels.forEach((label) => {
      width += getOuterWidth(label);
    });
    return width;
  }
  _getCurrentLabelsPaddings(labels) {
    let padding = 0;
    labels.forEach((label) => {
      padding += getOuterWidth(label) - getWidth(label);
    });
    return padding;
  }
  _renderItem(index2, item, itemContainer, $after) {
    const location = item.location ?? "center";
    const container = itemContainer ?? this[`_$${location}Section`];
    const itemHasText = !!(item.text ?? item.html);
    const itemElement = super._renderItem(index2, item, container, $after);
    itemElement.toggleClass("dx-toolbar-button", !itemHasText).toggleClass("dx-toolbar-label", itemHasText).addClass(item.cssClass);
    return itemElement;
  }
  _renderGroupedItems() {
    each(this.option("items"), (groupIndex, group) => {
      const groupItems = group.items;
      const $container = renderer_default("<div>").addClass("dx-toolbar-group");
      const location = group.location ?? "center";
      if (!groupItems || !groupItems.length) {
        return;
      }
      each(groupItems, (itemIndex, item) => {
        this._renderItem(itemIndex, item, $container, null);
      });
      this._$toolbarItemsContainer.find(`.dx-toolbar-${location}`).append($container);
    });
  }
  _renderItems(items) {
    const grouped = this.option("grouped") && items.length && items[0].items;
    grouped ? this._renderGroupedItems() : super._renderItems(items);
  }
  _getToolbarItems() {
    return this.option("items") ?? [];
  }
  _renderContentImpl() {
    const items = this._getToolbarItems();
    this.$element().toggleClass("dx-toolbar-mini", 0 === items.length);
    if (this._renderedItemsCount) {
      this._renderItems(items.slice(this._renderedItemsCount));
    } else {
      this._renderItems(items);
    }
    this._applyCompactMode();
  }
  _renderEmptyMessage() {
  }
  _clean() {
    this._$toolbarItemsContainer.children().empty();
    this.$element().empty();
    delete this._$beforeSection;
    delete this._$centerSection;
    delete this._$afterSection;
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._arrangeItems();
    }
  }
  _isVisible() {
    return getWidth(this.$element()) > 0 && getHeight(this.$element()) > 0;
  }
  _getIndexByItem(item) {
    return this._getToolbarItems().indexOf(item);
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    super._itemOptionChanged(item, property, value2, prevValue);
    this._arrangeItems();
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "width":
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "renderAs":
      case "useFlatButtons":
      case "useDefaultButtons":
        this._invalidate();
        break;
      case "compactMode":
        this._applyCompactMode();
        break;
      case "grouped":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dispose() {
    super._dispose();
    clearTimeout(this._waitParentAnimationTimeout);
  }
  _updateDimensionsInMaterial() {
    if (isMaterial()) {
      const _waitParentAnimationFinished = () => new Promise((resolve) => {
        const check = () => {
          let readyToResolve = true;
          this.$element().parents().each((_, parent) => {
            if (fx_default.isAnimating(renderer_default(parent))) {
              readyToResolve = false;
              return false;
            }
          });
          if (readyToResolve) {
            resolve();
          }
          return readyToResolve;
        };
        const runCheck = () => {
          clearTimeout(this._waitParentAnimationTimeout);
          this._waitParentAnimationTimeout = setTimeout(() => check() || runCheck(), 15);
        };
        runCheck();
      });
      const _checkWebFontForLabelsLoaded = () => {
        const $labels = this.$element().find(".dx-toolbar-label");
        const promises = [];
        $labels.each((_, label) => {
          const text = renderer_default(label).text();
          const fontWeight = renderer_default(label).css("fontWeight");
          promises.push(waitWebFont(text, fontWeight));
        });
        return Promise.all(promises);
      };
      Promise.all([_waitParentAnimationFinished(), _checkWebFontForLabelsLoaded()]).then(() => {
        this._dimensionChanged();
      });
    }
  }
};
component_registrator_default("dxToolbarBase", ToolbarBase);
var m_toolbar_base_default = ToolbarBase;

// ../../../../../../node_modules/devextreme/esm/core/resize_observer.js
var window15 = getWindow();
var ResizeObserverMock = {
  observe: noop2,
  unobserve: noop2,
  disconnect: noop2
};
var ResizeObserverSingleton = class {
  constructor() {
    if (!hasWindow() || !window15.ResizeObserver) {
      return ResizeObserverMock;
    }
    this._callbacksMap = /* @__PURE__ */ new Map();
    this._observer = new window15.ResizeObserver((entries) => {
      entries.forEach((entry) => {
        var _this$_callbacksMap$g;
        null === (_this$_callbacksMap$g = this._callbacksMap.get(entry.target)) || void 0 === _this$_callbacksMap$g || _this$_callbacksMap$g(entry);
      });
    });
  }
  observe(element, callback) {
    this._callbacksMap.set(element, callback);
    this._observer.observe(element);
  }
  unobserve(element) {
    this._callbacksMap.delete(element);
    this._observer.unobserve(element);
  }
  disconnect() {
    this._callbacksMap.clear();
    this._observer.disconnect();
  }
};
var resizeObserverSingleton = new ResizeObserverSingleton();
var resize_observer_default = resizeObserverSingleton;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_validation_engine.js
var EMAIL_VALIDATION_REGEX = /^[\d\w.+_-]+@[\d\w._-]+\.[\w]+$/i;
var STATUS = {
  valid: "valid",
  invalid: "invalid",
  pending: "pending"
};
var BaseRuleValidator = class {
  constructor() {
    this.NAME = "base";
  }
  defaultMessage(value2) {
    return message_default.getFormatter(`validation-${this.NAME}`)(value2);
  }
  defaultFormattedMessage(value2) {
    return message_default.getFormatter(`validation-${this.NAME}-formatted`)(value2);
  }
  _isValueEmpty(value2) {
    return !rulesValidators.required.validate(value2, {});
  }
  validate(value2, rule) {
    const valueArray = Array.isArray(value2) ? value2 : [value2];
    let result2 = true;
    if (valueArray.length) {
      valueArray.every((itemValue) => {
        result2 = this._validate(itemValue, rule);
        return result2;
      });
    } else {
      result2 = this._validate(null, rule);
    }
    return result2;
  }
};
var RequiredRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "required";
  }
  _validate(value2, rule) {
    if (!isDefined(value2)) {
      return false;
    }
    if (false === value2) {
      return false;
    }
    value2 = String(value2);
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    return "" !== value2;
  }
};
var NumericRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "numeric";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    if (rule.useCultureSettings && isString(value2)) {
      return !isNaN(number_default2.parse(value2));
    }
    return isNumeric(value2);
  }
};
var RangeRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "range";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const validNumber = rulesValidators.numeric.validate(value2, rule);
    const validValue = isDefined(value2) && "" !== value2;
    const number = validNumber ? parseFloat(value2) : validValue && value2.valueOf();
    const {
      min
    } = rule;
    const {
      max
    } = rule;
    if (!(validNumber || isDate(value2)) && !validValue) {
      return false;
    }
    if (isDefined(min)) {
      if (isDefined(max)) {
        return number >= min && number <= max;
      }
      return number >= min;
    }
    if (isDefined(max)) {
      return number <= max;
    }
    throw errors_default.Error("E0101");
  }
};
var StringLengthRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "stringLength";
  }
  _validate(value2, rule) {
    value2 = String(value2 ?? "");
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.range.validate(value2.length, extend({}, rule));
  }
};
var CustomRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "custom";
  }
  validate(value2, rule) {
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
    const extraParams = isFunction(dataGetter) && dataGetter();
    const params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    return rule.validationCallback(params);
  }
};
var AsyncRuleValidator = class extends CustomRuleValidator {
  constructor() {
    super();
    this.NAME = "async";
  }
  validate(value2, rule) {
    if (!isDefined(rule.reevaluate)) {
      extend(rule, {
        reevaluate: true
      });
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
    const extraParams = isFunction(dataGetter) && dataGetter();
    const params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    const callbackResult = rule.validationCallback(params);
    if (!isPromise(callbackResult)) {
      throw errors_default.Error("E0103");
    }
    return this._getWrappedPromise(fromPromise(callbackResult).promise());
  }
  _getWrappedPromise(promise) {
    const deferred = Deferred();
    promise.then((res) => {
      deferred.resolve(res);
    }, (err) => {
      const res = {
        isValid: false
      };
      if (isDefined(err)) {
        if (isString(err)) {
          res.message = err;
        } else if (isObject(err) && isDefined(err.message) && isString(err.message)) {
          res.message = err.message;
        }
      }
      deferred.resolve(res);
    });
    return deferred.promise();
  }
};
var CompareRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "compare";
  }
  _validate(value2, rule) {
    if (!rule.comparisonTarget) {
      throw errors_default.Error("E0102");
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    extend(rule, {
      reevaluate: true
    });
    const otherValue = rule.comparisonTarget();
    const type2 = rule.comparisonType || "==";
    switch (type2) {
      case "==":
        return value2 == otherValue;
      case "!=":
        return value2 != otherValue;
      case "===":
        return value2 === otherValue;
      case "!==":
        return value2 !== otherValue;
      case ">":
        return value2 > otherValue;
      case ">=":
        return value2 >= otherValue;
      case "<":
        return value2 < otherValue;
      case "<=":
        return value2 <= otherValue;
    }
  }
};
var PatternRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "pattern";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    let {
      pattern
    } = rule;
    if (isString(pattern)) {
      pattern = new RegExp(pattern);
    }
    return pattern.test(value2);
  }
};
var EmailRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "email";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.pattern.validate(value2, extend({}, rule, {
      pattern: EMAIL_VALIDATION_REGEX
    }));
  }
};
var rulesValidators = {
  required: new RequiredRuleValidator(),
  numeric: new NumericRuleValidator(),
  range: new RangeRuleValidator(),
  stringLength: new StringLengthRuleValidator(),
  custom: new CustomRuleValidator(),
  async: new AsyncRuleValidator(),
  compare: new CompareRuleValidator(),
  pattern: new PatternRuleValidator(),
  email: new EmailRuleValidator()
};
var GroupConfig = class_default.inherit({
  ctor(group, isRemovable) {
    this.group = group;
    this.validators = [];
    this._isRemovable = isRemovable;
    this._pendingValidators = [];
    this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);
    this._resetValidationInfo();
    this._eventsStrategy = new EventsStrategy(this);
  },
  validate() {
    const result2 = {
      isValid: true,
      brokenRules: [],
      validators: [],
      status: STATUS.valid,
      complete: null
    };
    this._unsubscribeFromAllChangeEvents();
    this._pendingValidators = [];
    this._resetValidationInfo();
    each(this.validators, (_, validator) => {
      const validatorResult = validator.validate();
      result2.isValid = result2.isValid && validatorResult.isValid;
      if (validatorResult.brokenRules) {
        result2.brokenRules = result2.brokenRules.concat(validatorResult.brokenRules);
      }
      result2.validators.push(validator);
      if (validatorResult.status === STATUS.pending) {
        this._addPendingValidator(validator);
      }
      this._subscribeToChangeEvents(validator);
    });
    if (this._pendingValidators.length) {
      result2.status = STATUS.pending;
    } else {
      result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
      this._unsubscribeFromAllChangeEvents();
      this._raiseValidatedEvent(result2);
    }
    this._updateValidationInfo(result2);
    return extend({}, this._validationInfo.result);
  },
  _subscribeToChangeEvents(validator) {
    validator.on("validating", this._onValidatorStatusChanged);
    validator.on("validated", this._onValidatorStatusChanged);
  },
  _unsubscribeFromChangeEvents(validator) {
    validator.off("validating", this._onValidatorStatusChanged);
    validator.off("validated", this._onValidatorStatusChanged);
  },
  _unsubscribeFromAllChangeEvents() {
    each(this.validators, (_, validator) => {
      this._unsubscribeFromChangeEvents(validator);
    });
  },
  _updateValidationInfo(result2) {
    this._validationInfo.result = result2;
    if (result2.status !== STATUS.pending) {
      return;
    }
    if (!this._validationInfo.deferred) {
      this._validationInfo.deferred = Deferred();
      this._validationInfo.result.complete = this._validationInfo.deferred.promise();
    }
  },
  _addPendingValidator(validator) {
    const foundValidator = grep(this._pendingValidators, (val) => val === validator)[0];
    if (!foundValidator) {
      this._pendingValidators.push(validator);
    }
  },
  _removePendingValidator(validator) {
    const index2 = this._pendingValidators.indexOf(validator);
    if (index2 >= 0) {
      this._pendingValidators.splice(index2, 1);
    }
  },
  _orderBrokenRules(brokenRules) {
    let orderedRules = [];
    each(this.validators, (_, validator) => {
      const foundRules = grep(brokenRules, (rule) => rule.validator === validator);
      if (foundRules.length) {
        orderedRules = orderedRules.concat(foundRules);
      }
    });
    return orderedRules;
  },
  _updateBrokenRules(result2) {
    if (!this._validationInfo.result) {
      return;
    }
    let {
      brokenRules
    } = this._validationInfo.result;
    const rules = grep(brokenRules, (rule) => rule.validator !== result2.validator);
    if (result2.brokenRules) {
      brokenRules = rules.concat(result2.brokenRules);
    }
    this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);
  },
  _onValidatorStatusChanged(result2) {
    if (result2.status === STATUS.pending) {
      this._addPendingValidator(result2.validator);
      return;
    }
    this._resolveIfComplete(result2);
  },
  _resolveIfComplete(result2) {
    this._removePendingValidator(result2.validator);
    this._updateBrokenRules(result2);
    if (!this._pendingValidators.length) {
      this._unsubscribeFromAllChangeEvents();
      if (!this._validationInfo.result) {
        return;
      }
      this._validationInfo.result.status = 0 === this._validationInfo.result.brokenRules.length ? STATUS.valid : STATUS.invalid;
      this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;
      const res = extend({}, this._validationInfo.result, {
        complete: null
      });
      const {
        deferred
      } = this._validationInfo;
      this._validationInfo.deferred = null;
      this._raiseValidatedEvent(res);
      deferred && setTimeout(() => {
        deferred.resolve(res);
      });
    }
  },
  _raiseValidatedEvent(result2) {
    this._eventsStrategy.fireEvent("validated", [result2]);
  },
  _resetValidationInfo() {
    this._validationInfo = {
      result: null,
      deferred: null
    };
  },
  _synchronizeValidationInfo() {
    if (this._validationInfo.result) {
      this._validationInfo.result.validators = this.validators;
    }
  },
  removeRegisteredValidator(validator) {
    const index2 = this.validators.indexOf(validator);
    if (index2 > -1) {
      this.validators.splice(index2, 1);
      this._synchronizeValidationInfo();
      this._resolveIfComplete({
        validator
      });
    }
  },
  registerValidator(validator) {
    if (!this.validators.includes(validator)) {
      this.validators.push(validator);
      this._synchronizeValidationInfo();
    }
  },
  reset() {
    each(this.validators, (_, validator) => {
      validator.reset();
    });
    this._pendingValidators = [];
    this._resetValidationInfo();
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
var ValidationEngine = {
  groups: [],
  getGroupConfig(group) {
    const result2 = grep(this.groups, (config3) => config3.group === group);
    if (result2.length) {
      return result2[0];
    }
  },
  findGroup($element, model) {
    var _$element$data;
    const hasValidationGroup = null === (_$element$data = $element.data()) || void 0 === _$element$data || null === (_$element$data = _$element$data.dxComponents) || void 0 === _$element$data ? void 0 : _$element$data.includes("dxValidationGroup");
    const validationGroup = hasValidationGroup && $element.dxValidationGroup("instance");
    if (validationGroup) {
      return validationGroup;
    }
    const $dxGroup = $element.parents(".dx-validationgroup").first();
    if ($dxGroup.length) {
      return $dxGroup.dxValidationGroup("instance");
    }
    return model;
  },
  initGroups() {
    this.groups = [];
    this.addGroup(void 0, false);
  },
  addGroup(group) {
    let isRemovable = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
    let config3 = this.getGroupConfig(group);
    if (!config3) {
      config3 = new GroupConfig(group, isRemovable);
      this.groups.push(config3);
    }
    return config3;
  },
  removeGroup(group) {
    const config3 = this.getGroupConfig(group);
    const index2 = this.groups.indexOf(config3);
    if (index2 > -1) {
      this.groups.splice(index2, 1);
    }
    return config3;
  },
  _setDefaultMessage(info) {
    const {
      rule,
      validator,
      name: name2
    } = info;
    if (!isDefined(rule.message)) {
      if (validator.defaultFormattedMessage && isDefined(name2)) {
        rule.message = validator.defaultFormattedMessage(name2);
      } else {
        rule.message = validator.defaultMessage();
      }
    }
  },
  _addBrokenRule(info) {
    const {
      result: result2,
      rule
    } = info;
    if (!result2.brokenRule) {
      result2.brokenRule = rule;
    }
    if (!result2.brokenRules) {
      result2.brokenRules = [];
    }
    result2.brokenRules.push(rule);
  },
  validate(value2, rules, name2) {
    var _rules$;
    let result2 = {
      name: name2,
      value: value2,
      brokenRule: null,
      brokenRules: null,
      isValid: true,
      validationRules: rules,
      pendingRules: null,
      status: STATUS.valid,
      complete: null
    };
    const validator = null === rules || void 0 === rules || null === (_rules$ = rules[0]) || void 0 === _rules$ ? void 0 : _rules$.validator;
    const asyncRuleItems = [];
    each(rules || [], (_, rule) => {
      const ruleValidator = rulesValidators[rule.type];
      let ruleValidationResult;
      if (ruleValidator) {
        if (isDefined(rule.isValid) && rule.value === value2 && !rule.reevaluate) {
          if (!rule.isValid) {
            result2.isValid = false;
            this._addBrokenRule({
              result: result2,
              rule
            });
            return false;
          }
          return true;
        }
        rule.value = value2;
        if ("async" === rule.type) {
          asyncRuleItems.push({
            rule,
            ruleValidator
          });
          return true;
        }
        ruleValidationResult = ruleValidator.validate(value2, rule);
        rule.isValid = ruleValidationResult;
        if (!ruleValidationResult) {
          result2.isValid = false;
          this._setDefaultMessage({
            rule,
            validator: ruleValidator,
            name: name2
          });
          this._addBrokenRule({
            result: result2,
            rule
          });
        }
        if (!rule.isValid) {
          return false;
        }
      } else {
        throw errors_default.Error("E0100");
      }
    });
    if (result2.isValid && !result2.brokenRules && asyncRuleItems.length) {
      result2 = this._validateAsyncRules({
        value: value2,
        items: asyncRuleItems,
        result: result2,
        name: name2
      });
    }
    this._synchronizeGroupValidationInfo(validator, result2);
    result2.status = result2.pendingRules ? STATUS.pending : result2.isValid ? STATUS.valid : STATUS.invalid;
    return result2;
  },
  _synchronizeGroupValidationInfo(validator, result2) {
    if (!validator) {
      return;
    }
    const groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);
    groupConfig._updateBrokenRules.call(groupConfig, {
      validator,
      brokenRules: result2.brokenRules ?? []
    });
  },
  _validateAsyncRules(_ref) {
    let {
      result: result2,
      value: value2,
      items,
      name: name2
    } = _ref;
    const asyncResults = [];
    each(items, (_, item) => {
      const validateResult = item.ruleValidator.validate(value2, item.rule);
      if (!isPromise(validateResult)) {
        this._updateRuleConfig({
          rule: item.rule,
          ruleResult: this._getPatchedRuleResult(validateResult),
          validator: item.ruleValidator,
          name: name2
        });
      } else {
        if (!result2.pendingRules) {
          result2.pendingRules = [];
        }
        result2.pendingRules.push(item.rule);
        const asyncResult = validateResult.then((res) => {
          const ruleResult = this._getPatchedRuleResult(res);
          this._updateRuleConfig({
            rule: item.rule,
            ruleResult,
            validator: item.ruleValidator,
            name: name2
          });
          return ruleResult;
        });
        asyncResults.push(asyncResult);
      }
    });
    if (asyncResults.length) {
      result2.complete = Promise.all(asyncResults).then((values) => this._getAsyncRulesResult({
        result: result2,
        values
      }));
    }
    return result2;
  },
  _updateRuleConfig(_ref2) {
    let {
      rule,
      ruleResult,
      validator,
      name: name2
    } = _ref2;
    rule.isValid = ruleResult.isValid;
    if (!ruleResult.isValid) {
      if (isDefined(ruleResult.message) && isString(ruleResult.message) && ruleResult.message.length) {
        rule.message = ruleResult.message;
      } else {
        this._setDefaultMessage({
          rule,
          validator,
          name: name2
        });
      }
    }
  },
  _getPatchedRuleResult(ruleResult) {
    let result2;
    if (isObject(ruleResult)) {
      result2 = extend({}, ruleResult);
      if (!isDefined(result2.isValid)) {
        result2.isValid = true;
      }
    } else {
      result2 = {
        isValid: isBoolean(ruleResult) ? ruleResult : true
      };
    }
    return result2;
  },
  _getAsyncRulesResult(_ref3) {
    let {
      values,
      result: result2
    } = _ref3;
    each(values, (index2, val) => {
      if (false === val.isValid) {
        result2.isValid = val.isValid;
        const rule = result2.pendingRules[index2];
        this._addBrokenRule({
          result: result2,
          rule
        });
      }
    });
    result2.pendingRules = null;
    result2.complete = null;
    result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
    return result2;
  },
  registerValidatorInGroup(group, validator) {
    const groupConfig = ValidationEngine.addGroup(group);
    groupConfig.registerValidator.call(groupConfig, validator);
  },
  removeRegisteredValidator(group, validator) {
    const config3 = ValidationEngine.getGroupConfig(group);
    if (config3) {
      config3.removeRegisteredValidator.call(config3, validator);
      const validatorsInGroup = config3.validators;
      const isRemovable = config3._isRemovable;
      const shouldRemoveGroup = 0 === validatorsInGroup.length && isRemovable;
      if (shouldRemoveGroup) {
        this.removeGroup(group);
      }
    }
  },
  initValidationOptions(options2) {
    const initedOptions = {};
    if (options2) {
      const syncOptions = ["isValid", "validationStatus", "validationError", "validationErrors"];
      syncOptions.forEach((prop) => {
        if (prop in options2) {
          extend(initedOptions, this.synchronizeValidationOptions({
            name: prop,
            value: options2[prop]
          }, options2));
        }
      });
    }
    return initedOptions;
  },
  synchronizeValidationOptions(_ref4, options2) {
    let {
      name: name2,
      value: value2
    } = _ref4;
    switch (name2) {
      case "validationStatus": {
        const isValid = value2 === STATUS.valid || value2 === STATUS.pending;
        return options2.isValid !== isValid ? {
          isValid
        } : {};
      }
      case "isValid": {
        const {
          validationStatus
        } = options2;
        let newStatus = validationStatus;
        if (value2 && validationStatus === STATUS.invalid) {
          newStatus = STATUS.valid;
        } else if (!value2 && validationStatus !== STATUS.invalid) {
          newStatus = STATUS.invalid;
        }
        return newStatus !== validationStatus ? {
          validationStatus: newStatus
        } : {};
      }
      case "validationErrors": {
        const validationError = !value2 || !value2.length ? null : value2[0];
        return options2.validationError !== validationError ? {
          validationError
        } : {};
      }
      case "validationError": {
        const {
          validationErrors
        } = options2;
        if (!value2 && validationErrors) {
          return {
            validationErrors: null
          };
        }
        if (value2 && !validationErrors) {
          return {
            validationErrors: [value2]
          };
        }
        if (value2 && validationErrors && value2 !== validationErrors[0]) {
          validationErrors[0] = value2;
          return {
            validationErrors: validationErrors.slice()
          };
        }
      }
    }
    return {};
  },
  validateGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors_default.Error("E0110");
    }
    return groupConfig.validate();
  },
  resetGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors_default.Error("E0110");
    }
    return groupConfig.reset();
  }
};
ValidationEngine.initGroups();
var m_validation_engine_default = ValidationEngine;

// ../../../../../../node_modules/devextreme/esm/ui/validation_engine.js
var validation_engine_default = m_validation_engine_default;

// ../../../../../../node_modules/inferno/dist/index.esm.js
var isArray = Array.isArray;
function isStringOrNumber(o) {
  var type2 = typeof o;
  return type2 === "string" || type2 === "number";
}
function isNullOrUndef(o) {
  return o === void 0 || o === null;
}
function isInvalid(o) {
  return o === null || o === false || o === true || o === void 0;
}
function isFunction2(o) {
  return typeof o === "function";
}
function isString2(o) {
  return typeof o === "string";
}
function isNumber(o) {
  return typeof o === "number";
}
function isNull(o) {
  return o === null;
}
function isUndefined(o) {
  return o === void 0;
}
function combineFrom(first, second) {
  var out = {};
  if (first) {
    for (var key in first) {
      out[key] = first[key];
    }
  }
  if (second) {
    for (var key$1 in second) {
      out[key$1] = second[key$1];
    }
  }
  return out;
}
function isLinkEventObject(o) {
  return !isNull(o) && typeof o === "object";
}
var EMPTY_OBJ = {};
var Fragment = "$F";
function normalizeEventName(name2) {
  return name2.substr(2).toLowerCase();
}
function appendChild(parentDOM, dom) {
  parentDOM.appendChild(dom);
}
function insertOrAppend(parentDOM, newNode, nextNode) {
  if (isNull(nextNode)) {
    appendChild(parentDOM, newNode);
  } else {
    parentDOM.insertBefore(newNode, nextNode);
  }
}
function documentCreateElement(tag, isSVG) {
  if (isSVG) {
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
  }
  return document.createElement(tag);
}
function replaceChild(parentDOM, newDom, lastDom) {
  parentDOM.replaceChild(newDom, lastDom);
}
function removeChild(parentDOM, childNode) {
  parentDOM.removeChild(childNode);
}
function callAll(arrayFn) {
  for (var i = 0; i < arrayFn.length; i++) {
    arrayFn[i]();
  }
}
function findChildVNode(vNode, startEdge, flags) {
  var children = vNode.children;
  if (flags & 4) {
    return children.$LI;
  }
  if (flags & 8192) {
    return vNode.childFlags === 2 ? children : children[startEdge ? 0 : children.length - 1];
  }
  return children;
}
function findDOMfromVNode(vNode, startEdge) {
  var flags;
  while (vNode) {
    flags = vNode.flags;
    if (flags & 2033) {
      return vNode.dom;
    }
    vNode = findChildVNode(vNode, startEdge, flags);
  }
  return null;
}
function removeVNodeDOM(vNode, parentDOM) {
  do {
    var flags = vNode.flags;
    if (flags & 2033) {
      removeChild(parentDOM, vNode.dom);
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      vNode = children.$LI;
    }
    if (flags & 8) {
      vNode = children;
    }
    if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          removeVNodeDOM(children[i], parentDOM);
        }
        return;
      }
    }
  } while (vNode);
}
function moveVNodeDOM(vNode, parentDOM, nextNode) {
  do {
    var flags = vNode.flags;
    if (flags & 2033) {
      insertOrAppend(parentDOM, vNode.dom, nextNode);
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      vNode = children.$LI;
    }
    if (flags & 8) {
      vNode = children;
    }
    if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          moveVNodeDOM(children[i], parentDOM, nextNode);
        }
        return;
      }
    }
  } while (vNode);
}
function createDerivedState(instance, nextProps, state) {
  if (instance.constructor.getDerivedStateFromProps) {
    return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));
  }
  return state;
}
var renderCheck = {
  v: false
};
var options = {
  componentComparator: null,
  createVNode: null,
  renderComplete: null
};
function setTextContent(dom, children) {
  dom.textContent = children;
}
function isLastValueSameLinkEvent(lastValue, nextValue) {
  return isLinkEventObject(lastValue) && lastValue.event === nextValue.event && lastValue.data === nextValue.data;
}
function mergeUnsetProperties(to, from) {
  for (var propName in from) {
    if (isUndefined(to[propName])) {
      to[propName] = from[propName];
    }
  }
  return to;
}
function safeCall1(method, arg1) {
  return !!isFunction2(method) && (method(arg1), true);
}
var keyPrefix = "$";
function V(childFlags, children, className, flags, key, props, ref, type2) {
  this.childFlags = childFlags;
  this.children = children;
  this.className = className;
  this.dom = null;
  this.flags = flags;
  this.key = key === void 0 ? null : key;
  this.props = props === void 0 ? null : props;
  this.ref = ref === void 0 ? null : ref;
  this.type = type2;
}
function createVNode(flags, type2, className, children, childFlags, props, key, ref) {
  var childFlag = childFlags === void 0 ? 1 : childFlags;
  var vNode = new V(childFlag, children, className, flags, key, props, ref, type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  if (childFlag === 0) {
    normalizeChildren(vNode, vNode.children);
  }
  return vNode;
}
function mergeDefaultHooks(flags, type2, ref) {
  if (flags & 4) {
    return ref;
  }
  var defaultHooks = (flags & 32768 ? type2.render : type2).defaultHooks;
  if (isNullOrUndef(defaultHooks)) {
    return ref;
  }
  if (isNullOrUndef(ref)) {
    return defaultHooks;
  }
  return mergeUnsetProperties(ref, defaultHooks);
}
function mergeDefaultProps(flags, type2, props) {
  var defaultProps = (flags & 32768 ? type2.render : type2).defaultProps;
  if (isNullOrUndef(defaultProps)) {
    return props;
  }
  if (isNullOrUndef(props)) {
    return combineFrom(defaultProps, null);
  }
  return mergeUnsetProperties(props, defaultProps);
}
function resolveComponentFlags(flags, type2) {
  if (flags & 12) {
    return flags;
  }
  if (type2.prototype && type2.prototype.render) {
    return 4;
  }
  if (type2.render) {
    return 32776;
  }
  return 8;
}
function createComponentVNode(flags, type2, props, key, ref) {
  flags = resolveComponentFlags(flags, type2);
  var vNode = new V(1, null, null, flags, key, mergeDefaultProps(flags, type2, props), mergeDefaultHooks(flags, type2, ref), type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  return vNode;
}
function createTextVNode(text, key) {
  return new V(1, isNullOrUndef(text) || text === true || text === false ? "" : text, null, 16, key, null, null, null);
}
function createFragment(children, childFlags, key) {
  var fragment = createVNode(8192, 8192, null, children, childFlags, null, key, null);
  switch (fragment.childFlags) {
    case 1:
      fragment.children = createVoidVNode();
      fragment.childFlags = 2;
      break;
    case 16:
      fragment.children = [createTextVNode(children)];
      fragment.childFlags = 4;
      break;
  }
  return fragment;
}
function normalizeProps(vNode) {
  var props = vNode.props;
  if (props) {
    var flags = vNode.flags;
    if (flags & 481) {
      if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
        normalizeChildren(vNode, props.children);
      }
      if (props.className !== void 0) {
        if (isNullOrUndef(vNode.className)) {
          vNode.className = props.className || null;
        }
        props.className = void 0;
      }
    }
    if (props.key !== void 0) {
      vNode.key = props.key;
      props.key = void 0;
    }
    if (props.ref !== void 0) {
      if (flags & 8) {
        vNode.ref = combineFrom(vNode.ref, props.ref);
      } else {
        vNode.ref = props.ref;
      }
      props.ref = void 0;
    }
  }
  return vNode;
}
function cloneFragment(vNodeToClone) {
  var oldChildren = vNodeToClone.children;
  var childFlags = vNodeToClone.childFlags;
  return createFragment(childFlags === 2 ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);
}
function directClone(vNodeToClone) {
  var flags = vNodeToClone.flags & -16385;
  var props = vNodeToClone.props;
  if (flags & 14) {
    if (!isNull(props)) {
      var propsToClone = props;
      props = {};
      for (var key in propsToClone) {
        props[key] = propsToClone[key];
      }
    }
  }
  if ((flags & 8192) === 0) {
    return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
  }
  return cloneFragment(vNodeToClone);
}
function createVoidVNode() {
  return createTextVNode("", null);
}
function _normalizeVNodes(nodes, result2, index2, currentKey) {
  for (var len = nodes.length; index2 < len; index2++) {
    var n = nodes[index2];
    if (!isInvalid(n)) {
      var newKey = currentKey + keyPrefix + index2;
      if (isArray(n)) {
        _normalizeVNodes(n, result2, 0, newKey);
      } else {
        if (isStringOrNumber(n)) {
          n = createTextVNode(n, newKey);
        } else {
          var oldKey = n.key;
          var isPrefixedKey = isString2(oldKey) && oldKey[0] === keyPrefix;
          if (n.flags & 81920 || isPrefixedKey) {
            n = directClone(n);
          }
          n.flags |= 65536;
          if (!isPrefixedKey) {
            if (isNull(oldKey)) {
              n.key = newKey;
            } else {
              n.key = currentKey + oldKey;
            }
          } else if (oldKey.substring(0, currentKey.length) !== currentKey) {
            n.key = currentKey + oldKey;
          }
        }
        result2.push(n);
      }
    }
  }
}
function getFlagsForElementVnode(type2) {
  switch (type2) {
    case "svg":
      return 32;
    case "input":
      return 64;
    case "select":
      return 256;
    case "textarea":
      return 128;
    case Fragment:
      return 8192;
    default:
      return 1;
  }
}
function normalizeChildren(vNode, children) {
  var newChildren;
  var newChildFlags = 1;
  if (isInvalid(children)) {
    newChildren = children;
  } else if (isStringOrNumber(children)) {
    newChildFlags = 16;
    newChildren = children;
  } else if (isArray(children)) {
    var len = children.length;
    for (var i = 0; i < len; ++i) {
      var n = children[i];
      if (isInvalid(n) || isArray(n)) {
        newChildren = newChildren || children.slice(0, i);
        _normalizeVNodes(children, newChildren, i, "");
        break;
      } else if (isStringOrNumber(n)) {
        newChildren = newChildren || children.slice(0, i);
        newChildren.push(createTextVNode(n, keyPrefix + i));
      } else {
        var key = n.key;
        var needsCloning = (n.flags & 81920) > 0;
        var isNullKey = isNull(key);
        var isPrefixed = isString2(key) && key[0] === keyPrefix;
        if (needsCloning || isNullKey || isPrefixed) {
          newChildren = newChildren || children.slice(0, i);
          if (needsCloning || isPrefixed) {
            n = directClone(n);
          }
          if (isNullKey || isPrefixed) {
            n.key = keyPrefix + i;
          }
          newChildren.push(n);
        } else if (newChildren) {
          newChildren.push(n);
        }
        n.flags |= 65536;
      }
    }
    newChildren = newChildren || children;
    if (newChildren.length === 0) {
      newChildFlags = 1;
    } else {
      newChildFlags = 8;
    }
  } else {
    newChildren = children;
    newChildren.flags |= 65536;
    if (children.flags & 81920) {
      newChildren = directClone(children);
    }
    newChildFlags = 2;
  }
  vNode.children = newChildren;
  vNode.childFlags = newChildFlags;
  return vNode;
}
function normalizeRoot(input) {
  if (isInvalid(input) || isStringOrNumber(input)) {
    return createTextVNode(input, null);
  }
  if (isArray(input)) {
    return createFragment(input, 0, null);
  }
  return input.flags & 16384 ? directClone(input) : input;
}
var xlinkNS = "http://www.w3.org/1999/xlink";
var xmlNS = "http://www.w3.org/XML/1998/namespace";
var namespaces = {
  "xlink:actuate": xlinkNS,
  "xlink:arcrole": xlinkNS,
  "xlink:href": xlinkNS,
  "xlink:role": xlinkNS,
  "xlink:show": xlinkNS,
  "xlink:title": xlinkNS,
  "xlink:type": xlinkNS,
  "xml:base": xmlNS,
  "xml:lang": xmlNS,
  "xml:space": xmlNS
};
function getDelegatedEventObject(v) {
  return {
    onClick: v,
    onDblClick: v,
    onFocusIn: v,
    onFocusOut: v,
    onKeyDown: v,
    onKeyPress: v,
    onKeyUp: v,
    onMouseDown: v,
    onMouseMove: v,
    onMouseUp: v,
    onTouchEnd: v,
    onTouchMove: v,
    onTouchStart: v
  };
}
var attachedEventCounts = getDelegatedEventObject(0);
var attachedEvents = getDelegatedEventObject(null);
var syntheticEvents = getDelegatedEventObject(true);
function updateOrAddSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (!eventsObject) {
    eventsObject = dom.$EV = getDelegatedEventObject(null);
  }
  if (!eventsObject[name2]) {
    if (++attachedEventCounts[name2] === 1) {
      attachedEvents[name2] = attachEventToDocument(name2);
    }
  }
  return eventsObject;
}
function unmountSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (eventsObject && eventsObject[name2]) {
    if (--attachedEventCounts[name2] === 0) {
      document.removeEventListener(normalizeEventName(name2), attachedEvents[name2]);
      attachedEvents[name2] = null;
    }
    eventsObject[name2] = null;
  }
}
function handleSyntheticEvent(name2, lastEvent, nextEvent, dom) {
  if (isFunction2(nextEvent)) {
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else if (isLinkEventObject(nextEvent)) {
    if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {
      return;
    }
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else {
    unmountSyntheticEvent(name2, dom);
  }
}
function getTargetNode(event) {
  return isFunction2(event.composedPath) ? event.composedPath()[0] : event.target;
}
function dispatchEvents(event, isClick, name2, eventData2) {
  var dom = getTargetNode(event);
  do {
    if (isClick && dom.disabled) {
      return;
    }
    var eventsObject = dom.$EV;
    if (eventsObject) {
      var currentEvent = eventsObject[name2];
      if (currentEvent) {
        eventData2.dom = dom;
        currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);
        if (event.cancelBubble) {
          return;
        }
      }
    }
    dom = dom.parentNode;
  } while (!isNull(dom));
}
function stopPropagation() {
  this.cancelBubble = true;
  if (!this.immediatePropagationStopped) {
    this.stopImmediatePropagation();
  }
}
function isDefaultPrevented() {
  return this.defaultPrevented;
}
function isPropagationStopped() {
  return this.cancelBubble;
}
function extendEventProperties(event) {
  var eventData2 = {
    dom: document
  };
  event.isDefaultPrevented = isDefaultPrevented;
  event.isPropagationStopped = isPropagationStopped;
  event.stopPropagation = stopPropagation;
  Object.defineProperty(event, "currentTarget", {
    configurable: true,
    get: function get() {
      return eventData2.dom;
    }
  });
  return eventData2;
}
function rootClickEvent(name2) {
  return function(event) {
    if (event.button !== 0) {
      event.stopPropagation();
      return;
    }
    dispatchEvents(event, true, name2, extendEventProperties(event));
  };
}
function rootEvent(name2) {
  return function(event) {
    dispatchEvents(event, false, name2, extendEventProperties(event));
  };
}
function attachEventToDocument(name2) {
  var attachedEvent = name2 === "onClick" || name2 === "onDblClick" ? rootClickEvent(name2) : rootEvent(name2);
  document.addEventListener(normalizeEventName(name2), attachedEvent);
  return attachedEvent;
}
function isSameInnerHTML(dom, innerHTML) {
  var tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function triggerEventListener(props, methodName, e) {
  if (props[methodName]) {
    var listener = props[methodName];
    if (listener.event) {
      listener.event(listener.data, e);
    } else {
      listener(e);
    }
  } else {
    var nativeListenerName = methodName.toLowerCase();
    if (props[nativeListenerName]) {
      props[nativeListenerName](e);
    }
  }
}
function createWrappedFunction(methodName, applyValue) {
  var fnMethod = function(e) {
    var vNode = this.$V;
    if (!vNode) {
      return;
    }
    var props = vNode.props || EMPTY_OBJ;
    var dom = vNode.dom;
    if (isString2(methodName)) {
      triggerEventListener(props, methodName, e);
    } else {
      for (var i = 0; i < methodName.length; ++i) {
        triggerEventListener(props, methodName[i], e);
      }
    }
    if (isFunction2(applyValue)) {
      var newVNode = this.$V;
      var newProps = newVNode.props || EMPTY_OBJ;
      applyValue(newProps, dom, false, newVNode);
    }
  };
  Object.defineProperty(fnMethod, "wrapped", {
    configurable: false,
    enumerable: false,
    value: true,
    writable: false
  });
  return fnMethod;
}
function attachEvent(dom, eventName, handler) {
  var previousKey = "$" + eventName;
  var previousArgs = dom[previousKey];
  if (previousArgs) {
    if (previousArgs[1].wrapped) {
      return;
    }
    dom.removeEventListener(previousArgs[0], previousArgs[1]);
    dom[previousKey] = null;
  }
  if (isFunction2(handler)) {
    dom.addEventListener(eventName, handler);
    dom[previousKey] = [eventName, handler];
  }
}
function isCheckedType(type2) {
  return type2 === "checkbox" || type2 === "radio";
}
var onTextInputChange = createWrappedFunction("onInput", applyValueInput);
var wrappedOnChange = createWrappedFunction(["onClick", "onChange"], applyValueInput);
function emptywrapper(event) {
  event.stopPropagation();
}
emptywrapper.wrapped = true;
function inputEvents(dom, nextPropsOrEmpty) {
  if (isCheckedType(nextPropsOrEmpty.type)) {
    attachEvent(dom, "change", wrappedOnChange);
    attachEvent(dom, "click", emptywrapper);
  } else {
    attachEvent(dom, "input", onTextInputChange);
  }
}
function applyValueInput(nextPropsOrEmpty, dom) {
  var type2 = nextPropsOrEmpty.type;
  var value2 = nextPropsOrEmpty.value;
  var checked = nextPropsOrEmpty.checked;
  var multiple = nextPropsOrEmpty.multiple;
  var defaultValue = nextPropsOrEmpty.defaultValue;
  var hasValue = !isNullOrUndef(value2);
  if (type2 && type2 !== dom.type) {
    dom.setAttribute("type", type2);
  }
  if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
    dom.multiple = multiple;
  }
  if (!isNullOrUndef(defaultValue) && !hasValue) {
    dom.defaultValue = defaultValue + "";
  }
  if (isCheckedType(type2)) {
    if (hasValue) {
      dom.value = value2;
    }
    if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  } else {
    if (hasValue && dom.value !== value2) {
      dom.defaultValue = value2;
      dom.value = value2;
    } else if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  }
}
function updateChildOptions(vNode, value2) {
  if (vNode.type === "option") {
    updateChildOption(vNode, value2);
  } else {
    var children = vNode.children;
    var flags = vNode.flags;
    if (flags & 4) {
      updateChildOptions(children.$LI, value2);
    } else if (flags & 8) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags === 2) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags & 12) {
      for (var i = 0, len = children.length; i < len; ++i) {
        updateChildOptions(children[i], value2);
      }
    }
  }
}
function updateChildOption(vNode, value2) {
  var props = vNode.props || EMPTY_OBJ;
  var dom = vNode.dom;
  dom.value = props.value;
  if (props.value === value2 || isArray(value2) && value2.indexOf(props.value) !== -1) {
    dom.selected = true;
  } else if (!isNullOrUndef(value2) || !isNullOrUndef(props.selected)) {
    dom.selected = props.selected || false;
  }
}
var onSelectChange = createWrappedFunction("onChange", applyValueSelect);
function selectEvents(dom) {
  attachEvent(dom, "change", onSelectChange);
}
function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
  var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
  if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
    dom.multiple = multiplePropInBoolean;
  }
  var index2 = nextPropsOrEmpty.selectedIndex;
  if (index2 === -1) {
    dom.selectedIndex = -1;
  }
  var childFlags = vNode.childFlags;
  if (childFlags !== 1) {
    var value2 = nextPropsOrEmpty.value;
    if (isNumber(index2) && index2 > -1 && dom.options[index2]) {
      value2 = dom.options[index2].value;
    }
    if (mounting && isNullOrUndef(value2)) {
      value2 = nextPropsOrEmpty.defaultValue;
    }
    updateChildOptions(vNode, value2);
  }
}
var onTextareaInputChange = createWrappedFunction("onInput", applyValueTextArea);
var wrappedOnChange$1 = createWrappedFunction("onChange");
function textAreaEvents(dom, nextPropsOrEmpty) {
  attachEvent(dom, "input", onTextareaInputChange);
  if (nextPropsOrEmpty.onChange) {
    attachEvent(dom, "change", wrappedOnChange$1);
  }
}
function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
  var value2 = nextPropsOrEmpty.value;
  var domValue = dom.value;
  if (isNullOrUndef(value2)) {
    if (mounting) {
      var defaultValue = nextPropsOrEmpty.defaultValue;
      if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
        dom.defaultValue = defaultValue;
        dom.value = defaultValue;
      }
    }
  } else if (domValue !== value2) {
    dom.defaultValue = value2;
    dom.value = value2;
  }
}
function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
  if (flags & 64) {
    applyValueInput(nextPropsOrEmpty, dom);
  } else if (flags & 256) {
    applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
  } else if (flags & 128) {
    applyValueTextArea(nextPropsOrEmpty, dom, mounting);
  }
  if (isControlled) {
    dom.$V = vNode;
  }
}
function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
  if (flags & 64) {
    inputEvents(dom, nextPropsOrEmpty);
  } else if (flags & 256) {
    selectEvents(dom);
  } else if (flags & 128) {
    textAreaEvents(dom, nextPropsOrEmpty);
  }
}
function isControlledFormElement(nextPropsOrEmpty) {
  return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
}
function createRef() {
  return {
    current: null
  };
}
function unmountRef(ref) {
  if (ref) {
    if (!safeCall1(ref, null) && ref.current) {
      ref.current = null;
    }
  }
}
function mountRef(ref, value2, lifecycle) {
  if (ref && (isFunction2(ref) || ref.current !== void 0)) {
    lifecycle.push(function() {
      if (!safeCall1(ref, value2) && ref.current !== void 0) {
        ref.current = value2;
      }
    });
  }
}
function remove2(vNode, parentDOM) {
  unmount(vNode);
  removeVNodeDOM(vNode, parentDOM);
}
function unmount(vNode) {
  var flags = vNode.flags;
  var children = vNode.children;
  var ref;
  if (flags & 481) {
    ref = vNode.ref;
    var props = vNode.props;
    unmountRef(ref);
    var childFlags = vNode.childFlags;
    if (!isNull(props)) {
      var keys = Object.keys(props);
      for (var i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        if (syntheticEvents[key]) {
          unmountSyntheticEvent(key, vNode.dom);
        }
      }
    }
    if (childFlags & 12) {
      unmountAllChildren(children);
    } else if (childFlags === 2) {
      unmount(children);
    }
  } else if (children) {
    if (flags & 4) {
      if (isFunction2(children.componentWillUnmount)) {
        children.componentWillUnmount();
      }
      unmountRef(vNode.ref);
      children.$UN = true;
      unmount(children.$LI);
    } else if (flags & 8) {
      ref = vNode.ref;
      if (!isNullOrUndef(ref) && isFunction2(ref.onComponentWillUnmount)) {
        ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
      }
      unmount(children);
    } else if (flags & 1024) {
      remove2(children, vNode.ref);
    } else if (flags & 8192) {
      if (vNode.childFlags & 12) {
        unmountAllChildren(children);
      }
    }
  }
}
function unmountAllChildren(children) {
  for (var i = 0, len = children.length; i < len; ++i) {
    unmount(children[i]);
  }
}
function clearDOM(dom) {
  dom.textContent = "";
}
function removeAllChildren(dom, vNode, children) {
  unmountAllChildren(children);
  if (vNode.flags & 8192) {
    removeVNodeDOM(vNode, dom);
  } else {
    clearDOM(dom);
  }
}
function wrapLinkEvent(nextValue) {
  var ev = nextValue.event;
  return function(e) {
    ev(nextValue.data, e);
  };
}
function patchEvent(name2, lastValue, nextValue, dom) {
  if (isLinkEventObject(nextValue)) {
    if (isLastValueSameLinkEvent(lastValue, nextValue)) {
      return;
    }
    nextValue = wrapLinkEvent(nextValue);
  }
  attachEvent(dom, normalizeEventName(name2), nextValue);
}
function patchStyle(lastAttrValue, nextAttrValue, dom) {
  if (isNullOrUndef(nextAttrValue)) {
    dom.removeAttribute("style");
    return;
  }
  var domStyle = dom.style;
  var style;
  var value2;
  if (isString2(nextAttrValue)) {
    domStyle.cssText = nextAttrValue;
    return;
  }
  if (!isNullOrUndef(lastAttrValue) && !isString2(lastAttrValue)) {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      if (value2 !== lastAttrValue[style]) {
        domStyle.setProperty(style, value2);
      }
    }
    for (style in lastAttrValue) {
      if (isNullOrUndef(nextAttrValue[style])) {
        domStyle.removeProperty(style);
      }
    }
  } else {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      domStyle.setProperty(style, value2);
    }
  }
}
function patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {
  var lastHtml = lastValue && lastValue.__html || "";
  var nextHtml = nextValue && nextValue.__html || "";
  if (lastHtml !== nextHtml) {
    if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
      if (!isNull(lastVNode)) {
        if (lastVNode.childFlags & 12) {
          unmountAllChildren(lastVNode.children);
        } else if (lastVNode.childFlags === 2) {
          unmount(lastVNode.children);
        }
        lastVNode.children = null;
        lastVNode.childFlags = 1;
      }
      dom.innerHTML = nextHtml;
    }
  }
}
function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {
  switch (prop) {
    case "children":
    case "childrenType":
    case "className":
    case "defaultValue":
    case "key":
    case "multiple":
    case "ref":
    case "selectedIndex":
      break;
    case "autoFocus":
      dom.autofocus = !!nextValue;
      break;
    case "allowfullscreen":
    case "autoplay":
    case "capture":
    case "checked":
    case "controls":
    case "default":
    case "disabled":
    case "hidden":
    case "indeterminate":
    case "loop":
    case "muted":
    case "novalidate":
    case "open":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "selected":
      dom[prop] = !!nextValue;
      break;
    case "defaultChecked":
    case "value":
    case "volume":
      if (hasControlledValue && prop === "value") {
        break;
      }
      var value2 = isNullOrUndef(nextValue) ? "" : nextValue;
      if (dom[prop] !== value2) {
        dom[prop] = value2;
      }
      break;
    case "style":
      patchStyle(lastValue, nextValue, dom);
      break;
    case "dangerouslySetInnerHTML":
      patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);
      break;
    default:
      if (syntheticEvents[prop]) {
        handleSyntheticEvent(prop, lastValue, nextValue, dom);
      } else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {
        patchEvent(prop, lastValue, nextValue, dom);
      } else if (isNullOrUndef(nextValue)) {
        dom.removeAttribute(prop);
      } else if (isSVG && namespaces[prop]) {
        dom.setAttributeNS(namespaces[prop], prop, nextValue);
      } else {
        dom.setAttribute(prop, nextValue);
      }
      break;
  }
}
function mountProps(vNode, flags, props, dom, isSVG) {
  var hasControlledValue = false;
  var isFormElement = (flags & 448) > 0;
  if (isFormElement) {
    hasControlledValue = isControlledFormElement(props);
    if (hasControlledValue) {
      addFormElementEventHandlers(flags, dom, props);
    }
  }
  for (var prop in props) {
    patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);
  }
  if (isFormElement) {
    processElement(flags, vNode, dom, props, true, hasControlledValue);
  }
}
function renderNewInput(instance, props, context2) {
  var nextInput = normalizeRoot(instance.render(props, instance.state, context2));
  var childContext = context2;
  if (isFunction2(instance.getChildContext)) {
    childContext = combineFrom(context2, instance.getChildContext());
  }
  instance.$CX = childContext;
  return nextInput;
}
function createClassComponentInstance(vNode, Component4, props, context2, isSVG, lifecycle) {
  var instance = new Component4(props, context2);
  var usesNewAPI = instance.$N = Boolean(Component4.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate);
  instance.$SVG = isSVG;
  instance.$L = lifecycle;
  vNode.children = instance;
  instance.$BS = false;
  instance.context = context2;
  if (instance.props === EMPTY_OBJ) {
    instance.props = props;
  }
  if (!usesNewAPI) {
    if (isFunction2(instance.componentWillMount)) {
      instance.$BR = true;
      instance.componentWillMount();
      var pending = instance.$PS;
      if (!isNull(pending)) {
        var state = instance.state;
        if (isNull(state)) {
          instance.state = pending;
        } else {
          for (var key in pending) {
            state[key] = pending[key];
          }
        }
        instance.$PS = null;
      }
      instance.$BR = false;
    }
  } else {
    instance.state = createDerivedState(instance, props, instance.state);
  }
  instance.$LI = renderNewInput(instance, props, context2);
  return instance;
}
function renderFunctionalComponent(vNode, context2) {
  var props = vNode.props || EMPTY_OBJ;
  return vNode.flags & 32768 ? vNode.type.render(props, vNode.ref, context2) : vNode.type(props, context2);
}
function mount(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var flags = vNode.flags |= 16384;
  if (flags & 481) {
    mountElement(vNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (flags & 4) {
    mountClassComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (flags & 8) {
    mountFunctionalComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle);
    mountFunctionalComponentCallbacks(vNode, lifecycle);
  } else if (flags & 512 || flags & 16) {
    mountText(vNode, parentDOM, nextNode);
  } else if (flags & 8192) {
    mountFragment(vNode, context2, parentDOM, isSVG, nextNode, lifecycle);
  } else if (flags & 1024) {
    mountPortal(vNode, context2, parentDOM, nextNode, lifecycle);
  } else
    ;
}
function mountPortal(vNode, context2, parentDOM, nextNode, lifecycle) {
  mount(vNode.children, vNode.ref, context2, false, null, lifecycle);
  var placeHolderVNode = createVoidVNode();
  mountText(placeHolderVNode, parentDOM, nextNode);
  vNode.dom = placeHolderVNode.dom;
}
function mountFragment(vNode, context2, parentDOM, isSVG, nextNode, lifecycle) {
  var children = vNode.children;
  var childFlags = vNode.childFlags;
  if (childFlags & 12 && children.length === 0) {
    childFlags = vNode.childFlags = 2;
    children = vNode.children = createVoidVNode();
  }
  if (childFlags === 2) {
    mount(children, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else {
    mountArrayChildren(children, parentDOM, context2, isSVG, nextNode, lifecycle);
  }
}
function mountText(vNode, parentDOM, nextNode) {
  var dom = vNode.dom = document.createTextNode(vNode.children);
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
}
function mountElement(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var flags = vNode.flags;
  var props = vNode.props;
  var className = vNode.className;
  var childFlags = vNode.childFlags;
  var dom = vNode.dom = documentCreateElement(vNode.type, isSVG = isSVG || (flags & 32) > 0);
  var children = vNode.children;
  if (!isNullOrUndef(className) && className !== "") {
    if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
  }
  if (childFlags === 16) {
    setTextContent(dom, children);
  } else if (childFlags !== 1) {
    var childrenIsSVG = isSVG && vNode.type !== "foreignObject";
    if (childFlags === 2) {
      if (children.flags & 16384) {
        vNode.children = children = directClone(children);
      }
      mount(children, dom, context2, childrenIsSVG, null, lifecycle);
    } else if (childFlags === 8 || childFlags === 4) {
      mountArrayChildren(children, dom, context2, childrenIsSVG, null, lifecycle);
    }
  }
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
  if (!isNull(props)) {
    mountProps(vNode, flags, props, dom, isSVG);
  }
  mountRef(vNode.ref, dom, lifecycle);
}
function mountArrayChildren(children, dom, context2, isSVG, nextNode, lifecycle) {
  for (var i = 0; i < children.length; ++i) {
    var child = children[i];
    if (child.flags & 16384) {
      children[i] = child = directClone(child);
    }
    mount(child, dom, context2, isSVG, nextNode, lifecycle);
  }
}
function mountClassComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context2, isSVG, lifecycle);
  mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
  mountClassComponentCallbacks(vNode.ref, instance, lifecycle);
}
function mountFunctionalComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  mount(vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context2)), parentDOM, context2, isSVG, nextNode, lifecycle);
}
function createClassMountCallback(instance) {
  return function() {
    instance.componentDidMount();
  };
}
function mountClassComponentCallbacks(ref, instance, lifecycle) {
  mountRef(ref, instance, lifecycle);
  if (isFunction2(instance.componentDidMount)) {
    lifecycle.push(createClassMountCallback(instance));
  }
}
function createOnMountCallback(ref, vNode) {
  return function() {
    ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
  };
}
function mountFunctionalComponentCallbacks(vNode, lifecycle) {
  var ref = vNode.ref;
  if (!isNullOrUndef(ref)) {
    safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);
    if (isFunction2(ref.onComponentDidMount)) {
      lifecycle.push(createOnMountCallback(ref, vNode));
    }
  }
}
function replaceWithNewNode(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle) {
  unmount(lastVNode);
  if ((nextVNode.flags & lastVNode.flags & 2033) !== 0) {
    mount(nextVNode, null, context2, isSVG, null, lifecycle);
    replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);
  } else {
    mount(nextVNode, parentDOM, context2, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);
    removeVNodeDOM(lastVNode, parentDOM);
  }
}
function patch(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var nextFlags = nextVNode.flags |= 16384;
  if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048) {
    if (lastVNode.flags & 16384) {
      replaceWithNewNode(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle);
    } else {
      mount(nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle);
    }
  } else if (nextFlags & 481) {
    patchElement(lastVNode, nextVNode, context2, isSVG, nextFlags, lifecycle);
  } else if (nextFlags & 4) {
    patchClassComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (nextFlags & 8) {
    patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (nextFlags & 16) {
    patchText(lastVNode, nextVNode);
  } else if (nextFlags & 512) {
    nextVNode.dom = lastVNode.dom;
  } else if (nextFlags & 8192) {
    patchFragment(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle);
  } else {
    patchPortal(lastVNode, nextVNode, context2, lifecycle);
  }
}
function patchSingleTextChild(lastChildren, nextChildren, parentDOM) {
  if (lastChildren !== nextChildren) {
    if (lastChildren !== "") {
      parentDOM.firstChild.nodeValue = nextChildren;
    } else {
      setTextContent(parentDOM, nextChildren);
    }
  }
}
function patchContentEditableChildren(dom, nextChildren) {
  if (dom.textContent !== nextChildren) {
    dom.textContent = nextChildren;
  }
}
function patchFragment(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle) {
  var lastChildren = lastVNode.children;
  var nextChildren = nextVNode.children;
  var lastChildFlags = lastVNode.childFlags;
  var nextChildFlags = nextVNode.childFlags;
  var nextNode = null;
  if (nextChildFlags & 12 && nextChildren.length === 0) {
    nextChildFlags = nextVNode.childFlags = 2;
    nextChildren = nextVNode.children = createVoidVNode();
  }
  var nextIsSingle = (nextChildFlags & 2) !== 0;
  if (lastChildFlags & 12) {
    var lastLen = lastChildren.length;
    if (
      // It uses keyed algorithm
      lastChildFlags & 8 && nextChildFlags & 8 || // It transforms from many to single
      nextIsSingle || // It will append more nodes
      !nextIsSingle && nextChildren.length > lastLen
    ) {
      nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;
    }
  }
  patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, lastVNode, lifecycle);
}
function patchPortal(lastVNode, nextVNode, context2, lifecycle) {
  var lastContainer = lastVNode.ref;
  var nextContainer = nextVNode.ref;
  var nextChildren = nextVNode.children;
  patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context2, false, null, lastVNode, lifecycle);
  nextVNode.dom = lastVNode.dom;
  if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
    var node = nextChildren.dom;
    removeChild(lastContainer, node);
    appendChild(nextContainer, node);
  }
}
function patchElement(lastVNode, nextVNode, context2, isSVG, nextFlags, lifecycle) {
  var dom = nextVNode.dom = lastVNode.dom;
  var lastProps = lastVNode.props;
  var nextProps = nextVNode.props;
  var isFormElement = false;
  var hasControlledValue = false;
  var nextPropsOrEmpty;
  isSVG = isSVG || (nextFlags & 32) > 0;
  if (lastProps !== nextProps) {
    var lastPropsOrEmpty = lastProps || EMPTY_OBJ;
    nextPropsOrEmpty = nextProps || EMPTY_OBJ;
    if (nextPropsOrEmpty !== EMPTY_OBJ) {
      isFormElement = (nextFlags & 448) > 0;
      if (isFormElement) {
        hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
      }
      for (var prop in nextPropsOrEmpty) {
        var lastValue = lastPropsOrEmpty[prop];
        var nextValue = nextPropsOrEmpty[prop];
        if (lastValue !== nextValue) {
          patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);
        }
      }
    }
    if (lastPropsOrEmpty !== EMPTY_OBJ) {
      for (var prop$1 in lastPropsOrEmpty) {
        if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {
          patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);
        }
      }
    }
  }
  var nextChildren = nextVNode.children;
  var nextClassName = nextVNode.className;
  if (lastVNode.className !== nextClassName) {
    if (isNullOrUndef(nextClassName)) {
      dom.removeAttribute("class");
    } else if (isSVG) {
      dom.setAttribute("class", nextClassName);
    } else {
      dom.className = nextClassName;
    }
  }
  if (nextFlags & 4096) {
    patchContentEditableChildren(dom, nextChildren);
  } else {
    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context2, isSVG && nextVNode.type !== "foreignObject", null, lastVNode, lifecycle);
  }
  if (isFormElement) {
    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
  }
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, dom, lifecycle);
  }
}
function replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context2, isSVG, lifecycle) {
  unmount(lastChildren);
  mountArrayChildren(nextChildren, parentDOM, context2, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);
  removeVNodeDOM(lastChildren, parentDOM);
}
function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, parentVNode, lifecycle) {
  switch (lastChildFlags) {
    case 2:
      switch (nextChildFlags) {
        case 2:
          patch(lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          remove2(lastChildren, parentDOM);
          break;
        case 16:
          unmount(lastChildren);
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context2, isSVG, lifecycle);
          break;
      }
      break;
    case 1:
      switch (nextChildFlags) {
        case 2:
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          break;
        case 16:
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
      }
      break;
    case 16:
      switch (nextChildFlags) {
        case 16:
          patchSingleTextChild(lastChildren, nextChildren, parentDOM);
          break;
        case 2:
          clearDOM(parentDOM);
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          clearDOM(parentDOM);
          break;
        default:
          clearDOM(parentDOM);
          mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
      }
      break;
    default:
      switch (nextChildFlags) {
        case 16:
          unmountAllChildren(lastChildren);
          setTextContent(parentDOM, nextChildren);
          break;
        case 2:
          removeAllChildren(parentDOM, parentVNode, lastChildren);
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          removeAllChildren(parentDOM, parentVNode, lastChildren);
          break;
        default:
          var lastLength = lastChildren.length | 0;
          var nextLength = nextChildren.length | 0;
          if (lastLength === 0) {
            if (nextLength > 0) {
              mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
            }
          } else if (nextLength === 0) {
            removeAllChildren(parentDOM, parentVNode, lastChildren);
          } else if (nextChildFlags === 8 && lastChildFlags === 8) {
            patchKeyedChildren(lastChildren, nextChildren, parentDOM, context2, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);
          } else {
            patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context2, isSVG, lastLength, nextLength, nextNode, lifecycle);
          }
          break;
      }
      break;
  }
}
function createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {
  lifecycle.push(function() {
    instance.componentDidUpdate(lastProps, lastState, snapshot);
  });
}
function updateClassComponent(instance, nextState, nextProps, parentDOM, context2, isSVG, force, nextNode, lifecycle) {
  var lastState = instance.state;
  var lastProps = instance.props;
  var usesNewAPI = Boolean(instance.$N);
  var hasSCU = isFunction2(instance.shouldComponentUpdate);
  if (usesNewAPI) {
    nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);
  }
  if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context2)) {
    if (!usesNewAPI && isFunction2(instance.componentWillUpdate)) {
      instance.componentWillUpdate(nextProps, nextState, context2);
    }
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context2;
    var snapshot = null;
    var nextInput = renderNewInput(instance, nextProps, context2);
    if (usesNewAPI && isFunction2(instance.getSnapshotBeforeUpdate)) {
      snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);
    }
    patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
    instance.$LI = nextInput;
    if (isFunction2(instance.componentDidUpdate)) {
      createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);
    }
  } else {
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context2;
  }
}
function patchClassComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var instance = nextVNode.children = lastVNode.children;
  if (isNull(instance)) {
    return;
  }
  instance.$L = lifecycle;
  var nextProps = nextVNode.props || EMPTY_OBJ;
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  var nextState = instance.state;
  if (!instance.$N) {
    if (isFunction2(instance.componentWillReceiveProps)) {
      instance.$BR = true;
      instance.componentWillReceiveProps(nextProps, context2);
      if (instance.$UN) {
        return;
      }
      instance.$BR = false;
    }
    if (!isNull(instance.$PS)) {
      nextState = combineFrom(nextState, instance.$PS);
      instance.$PS = null;
    }
  }
  updateClassComponent(instance, nextState, nextProps, parentDOM, context2, isSVG, false, nextNode, lifecycle);
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, instance, lifecycle);
  }
}
function patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var shouldUpdate = true;
  var nextProps = nextVNode.props || EMPTY_OBJ;
  var nextRef = nextVNode.ref;
  var lastProps = lastVNode.props;
  var nextHooksDefined = !isNullOrUndef(nextRef);
  var lastInput = lastVNode.children;
  if (nextHooksDefined && isFunction2(nextRef.onComponentShouldUpdate)) {
    shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);
  }
  if (shouldUpdate !== false) {
    if (nextHooksDefined && isFunction2(nextRef.onComponentWillUpdate)) {
      nextRef.onComponentWillUpdate(lastProps, nextProps);
    }
    var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context2));
    patch(lastInput, nextInput, parentDOM, context2, isSVG, nextNode, lifecycle);
    nextVNode.children = nextInput;
    if (nextHooksDefined && isFunction2(nextRef.onComponentDidUpdate)) {
      nextRef.onComponentDidUpdate(lastProps, nextProps);
    }
  } else {
    nextVNode.children = lastInput;
  }
}
function patchText(lastVNode, nextVNode) {
  var nextText = nextVNode.children;
  var dom = nextVNode.dom = lastVNode.dom;
  if (nextText !== lastVNode.children) {
    dom.nodeValue = nextText;
  }
}
function patchNonKeyedChildren(lastChildren, nextChildren, dom, context2, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {
  var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
  var i = 0;
  var nextChild;
  var lastChild;
  for (; i < commonLength; ++i) {
    nextChild = nextChildren[i];
    lastChild = lastChildren[i];
    if (nextChild.flags & 16384) {
      nextChild = nextChildren[i] = directClone(nextChild);
    }
    patch(lastChild, nextChild, dom, context2, isSVG, nextNode, lifecycle);
    lastChildren[i] = nextChild;
  }
  if (lastChildrenLength < nextChildrenLength) {
    for (i = commonLength; i < nextChildrenLength; ++i) {
      nextChild = nextChildren[i];
      if (nextChild.flags & 16384) {
        nextChild = nextChildren[i] = directClone(nextChild);
      }
      mount(nextChild, dom, context2, isSVG, nextNode, lifecycle);
    }
  } else if (lastChildrenLength > nextChildrenLength) {
    for (i = commonLength; i < lastChildrenLength; ++i) {
      remove2(lastChildren[i], dom);
    }
  }
}
function patchKeyedChildren(a, b, dom, context2, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {
  var aEnd = aLength - 1;
  var bEnd = bLength - 1;
  var j = 0;
  var aNode = a[j];
  var bNode = b[j];
  var nextPos;
  var nextNode;
  outer: {
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[j] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
      a[j] = bNode;
      ++j;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[j];
      bNode = b[j];
    }
    aNode = a[aEnd];
    bNode = b[bEnd];
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[bEnd] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
      a[aEnd] = bNode;
      aEnd--;
      bEnd--;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[aEnd];
      bNode = b[bEnd];
    }
  }
  if (j > aEnd) {
    if (j <= bEnd) {
      nextPos = bEnd + 1;
      nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;
      while (j <= bEnd) {
        bNode = b[j];
        if (bNode.flags & 16384) {
          b[j] = bNode = directClone(bNode);
        }
        ++j;
        mount(bNode, dom, context2, isSVG, nextNode, lifecycle);
      }
    }
  } else if (j > bEnd) {
    while (j <= aEnd) {
      remove2(a[j++], dom);
    }
  } else {
    patchKeyedChildrenComplex(a, b, context2, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);
  }
}
function patchKeyedChildrenComplex(a, b, context2, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {
  var aNode;
  var bNode;
  var nextPos;
  var i = 0;
  var aStart = j;
  var bStart = j;
  var aLeft = aEnd - j + 1;
  var bLeft = bEnd - j + 1;
  var sources = new Int32Array(bLeft + 1);
  var canRemoveWholeContent = aLeft === aLength;
  var moved = false;
  var pos = 0;
  var patched = 0;
  if (bLength < 4 || (aLeft | bLeft) < 32) {
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        for (j = bStart; j <= bEnd; j++) {
          bNode = b[j];
          if (aNode.key === bNode.key) {
            sources[j - bStart] = i + 1;
            if (canRemoveWholeContent) {
              canRemoveWholeContent = false;
              while (aStart < i) {
                remove2(a[aStart++], dom);
              }
            }
            if (pos > j) {
              moved = true;
            } else {
              pos = j;
            }
            if (bNode.flags & 16384) {
              b[j] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
            ++patched;
            break;
          }
        }
        if (!canRemoveWholeContent && j > bEnd) {
          remove2(aNode, dom);
        }
      } else if (!canRemoveWholeContent) {
        remove2(aNode, dom);
      }
    }
  } else {
    var keyIndex = {};
    for (i = bStart; i <= bEnd; ++i) {
      keyIndex[b[i].key] = i;
    }
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        j = keyIndex[aNode.key];
        if (j !== void 0) {
          if (canRemoveWholeContent) {
            canRemoveWholeContent = false;
            while (i > aStart) {
              remove2(a[aStart++], dom);
            }
          }
          sources[j - bStart] = i + 1;
          if (pos > j) {
            moved = true;
          } else {
            pos = j;
          }
          bNode = b[j];
          if (bNode.flags & 16384) {
            b[j] = bNode = directClone(bNode);
          }
          patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
          ++patched;
        } else if (!canRemoveWholeContent) {
          remove2(aNode, dom);
        }
      } else if (!canRemoveWholeContent) {
        remove2(aNode, dom);
      }
    }
  }
  if (canRemoveWholeContent) {
    removeAllChildren(dom, parentVNode, a);
    mountArrayChildren(b, dom, context2, isSVG, outerEdge, lifecycle);
  } else if (moved) {
    var seq = lis_algorithm(sources);
    j = seq.length - 1;
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount(bNode, dom, context2, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
      } else if (j < 0 || i !== seq[j]) {
        pos = i + bStart;
        bNode = b[pos];
        nextPos = pos + 1;
        moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);
      } else {
        j--;
      }
    }
  } else if (patched !== bLeft) {
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount(bNode, dom, context2, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
      }
    }
  }
}
var result;
var p;
var maxLen = 0;
function lis_algorithm(arr) {
  var arrI = 0;
  var i = 0;
  var j = 0;
  var k = 0;
  var u = 0;
  var v = 0;
  var c = 0;
  var len = arr.length;
  if (len > maxLen) {
    maxLen = len;
    result = new Int32Array(len);
    p = new Int32Array(len);
  }
  for (; i < len; ++i) {
    arrI = arr[i];
    if (arrI !== 0) {
      j = result[k];
      if (arr[j] < arrI) {
        p[i] = j;
        result[++k] = i;
        continue;
      }
      u = 0;
      v = k;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = k + 1;
  var seq = new Int32Array(u);
  v = result[u - 1];
  while (u-- > 0) {
    seq[u] = v;
    v = p[v];
    result[u] = 0;
  }
  return seq;
}
var hasDocumentAvailable = typeof document !== "undefined";
if (hasDocumentAvailable) {
  if (window.Node) {
    Node.prototype.$EV = null;
    Node.prototype.$V = null;
  }
}
function __render(input, parentDOM, callback, context2) {
  var lifecycle = [];
  var rootInput = parentDOM.$V;
  renderCheck.v = true;
  if (isNullOrUndef(rootInput)) {
    if (!isNullOrUndef(input)) {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      mount(input, parentDOM, context2, false, null, lifecycle);
      parentDOM.$V = input;
      rootInput = input;
    }
  } else {
    if (isNullOrUndef(input)) {
      remove2(rootInput, parentDOM);
      parentDOM.$V = null;
    } else {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      patch(rootInput, input, parentDOM, context2, false, null, lifecycle);
      rootInput = parentDOM.$V = input;
    }
  }
  callAll(lifecycle);
  renderCheck.v = false;
  if (isFunction2(callback)) {
    callback();
  }
  if (isFunction2(options.renderComplete)) {
    options.renderComplete(rootInput, parentDOM);
  }
}
function render(input, parentDOM, callback, context2) {
  if (callback === void 0)
    callback = null;
  if (context2 === void 0)
    context2 = EMPTY_OBJ;
  __render(input, parentDOM, callback, context2);
}
var QUEUE = [];
var nextTick = typeof Promise !== "undefined" ? Promise.resolve().then.bind(Promise.resolve()) : function(a) {
  window.setTimeout(a, 0);
};
var microTaskPending = false;
function queueStateChanges(component, newState, callback, force) {
  var pending = component.$PS;
  if (isFunction2(newState)) {
    newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);
  }
  if (isNullOrUndef(pending)) {
    component.$PS = newState;
  } else {
    for (var stateKey in newState) {
      pending[stateKey] = newState[stateKey];
    }
  }
  if (!component.$BR) {
    if (!renderCheck.v) {
      if (QUEUE.length === 0) {
        applyState(component, force);
        if (isFunction2(callback)) {
          callback.call(component);
        }
        return;
      }
    }
    if (QUEUE.indexOf(component) === -1) {
      QUEUE.push(component);
    }
    if (force) {
      component.$F = true;
    }
    if (!microTaskPending) {
      microTaskPending = true;
      nextTick(rerender);
    }
    if (isFunction2(callback)) {
      var QU = component.$QU;
      if (!QU) {
        QU = component.$QU = [];
      }
      QU.push(callback);
    }
  } else if (isFunction2(callback)) {
    component.$L.push(callback.bind(component));
  }
}
function callSetStateCallbacks(component) {
  var queue = component.$QU;
  for (var i = 0; i < queue.length; ++i) {
    queue[i].call(component);
  }
  component.$QU = null;
}
function rerender() {
  var component;
  microTaskPending = false;
  while (component = QUEUE.shift()) {
    if (!component.$UN) {
      var force = component.$F;
      component.$F = false;
      applyState(component, force);
      if (component.$QU) {
        callSetStateCallbacks(component);
      }
    }
  }
}
function applyState(component, force) {
  if (force || !component.$BR) {
    var pendingState = component.$PS;
    component.$PS = null;
    var lifecycle = [];
    renderCheck.v = true;
    updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);
    callAll(lifecycle);
    renderCheck.v = false;
  } else {
    component.state = component.$PS;
    component.$PS = null;
  }
}
var Component2 = function Component3(props, context2) {
  this.state = null;
  this.$BR = false;
  this.$BS = true;
  this.$PS = null;
  this.$LI = null;
  this.$UN = false;
  this.$CX = null;
  this.$QU = null;
  this.$N = false;
  this.$L = null;
  this.$SVG = false;
  this.$F = false;
  this.props = props || EMPTY_OBJ;
  this.context = context2 || EMPTY_OBJ;
};
Component2.prototype.forceUpdate = function forceUpdate(callback) {
  if (this.$UN) {
    return;
  }
  queueStateChanges(this, {}, callback, true);
};
Component2.prototype.setState = function setState(newState, callback) {
  if (this.$UN) {
    return;
  }
  if (!this.$BS) {
    queueStateChanges(this, newState, callback, false);
  }
};
Component2.prototype.render = function render2(_nextProps, _nextState, _nextContext) {
  return null;
};

// ../../../../../../node_modules/inferno/index.esm.js
if (true) {
  console.warn("You are running production build of Inferno in development mode. Use dev:module entry point.");
}

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/effect_host.js
var InfernoEffectHost = {
  lockCount: 0,
  lock() {
    this.lockCount++;
  },
  callbacks: [],
  callEffects() {
    this.lockCount--;
    if (this.lockCount < 0) {
      throw new Error("Unexpected Effect Call");
    }
    if (this.lockCount === 0) {
      const effects = this.callbacks;
      this.callbacks = [];
      effects.forEach((callback) => callback());
    }
  }
};

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/base_component.js
var areObjectsEqual = (firstObject, secondObject) => {
  const bothAreObjects = firstObject instanceof Object && secondObject instanceof Object;
  if (!bothAreObjects) {
    return firstObject === secondObject;
  }
  const firstObjectKeys = Object.keys(firstObject);
  const secondObjectKeys = Object.keys(secondObject);
  if (firstObjectKeys.length !== secondObjectKeys.length) {
    return false;
  }
  const hasDifferentElement = firstObjectKeys.some((key) => firstObject[key] !== secondObject[key]);
  return !hasDifferentElement;
};
var BaseInfernoComponent = class extends Component2 {
  constructor() {
    super(...arguments);
    this._pendingContext = this.context;
  }
  componentWillReceiveProps(_, context2) {
    this._pendingContext = context2 !== null && context2 !== void 0 ? context2 : {};
  }
  shouldComponentUpdate(nextProps, nextState) {
    return !areObjectsEqual(this.props, nextProps) || !areObjectsEqual(this.state, nextState) || !areObjectsEqual(this.context, this._pendingContext);
  }
};
var InfernoComponent = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this._effects = [];
  }
  createEffects() {
    return [];
  }
  updateEffects() {
  }
  componentWillMount() {
    InfernoEffectHost.lock();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  componentWillUpdate(_nextProps, _nextState, _context) {
    InfernoEffectHost.lock();
  }
  componentDidMount() {
    InfernoEffectHost.callbacks.push(() => {
      this._effects = this.createEffects();
    });
    InfernoEffectHost.callEffects();
  }
  componentDidUpdate() {
    InfernoEffectHost.callbacks.push(() => this.updateEffects());
    InfernoEffectHost.callEffects();
  }
  destroyEffects() {
    this._effects.forEach((e) => e.dispose());
  }
  componentWillUnmount() {
    this.destroyEffects();
  }
};
var InfernoWrapperComponent = class extends InfernoComponent {
  constructor() {
    super(...arguments);
    this.vDomElement = null;
  }
  vDomUpdateClasses() {
    const el = this.vDomElement;
    const currentClasses = el.className.length ? el.className.split(" ") : [];
    const addedClasses = currentClasses.filter((className) => el.dxClasses.previous.indexOf(className) < 0);
    const removedClasses = el.dxClasses.previous.filter((className) => currentClasses.indexOf(className) < 0);
    addedClasses.forEach((value2) => {
      const indexInRemoved = el.dxClasses.removed.indexOf(value2);
      if (indexInRemoved > -1) {
        el.dxClasses.removed.splice(indexInRemoved, 1);
      } else if (!el.dxClasses.added.includes(value2)) {
        el.dxClasses.added.push(value2);
      }
    });
    removedClasses.forEach((value2) => {
      const indexInAdded = el.dxClasses.added.indexOf(value2);
      if (indexInAdded > -1) {
        el.dxClasses.added.splice(indexInAdded, 1);
      } else if (!el.dxClasses.removed.includes(value2)) {
        el.dxClasses.removed.push(value2);
      }
    });
  }
  componentDidMount() {
    const el = findDOMfromVNode(this.$LI, true);
    this.vDomElement = el;
    super.componentDidMount();
    el.dxClasses = el.dxClasses || {
      removed: [],
      added: [],
      previous: []
    };
    el.dxClasses.previous = (el === null || el === void 0 ? void 0 : el.className.length) ? el.className.split(" ") : [];
  }
  componentDidUpdate() {
    super.componentDidUpdate();
    const el = this.vDomElement;
    if (el !== null) {
      el.dxClasses.added.forEach((className) => el.classList.add(className));
      el.dxClasses.removed.forEach((className) => el.classList.remove(className));
      el.dxClasses.previous = el.className.length ? el.className.split(" ") : [];
    }
  }
  shouldComponentUpdate(nextProps, nextState) {
    const shouldUpdate = super.shouldComponentUpdate(nextProps, nextState);
    if (shouldUpdate) {
      this.vDomUpdateClasses();
    }
    return shouldUpdate;
  }
};

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/create_context.js
var contextId = 0;
var createContext = function(defaultValue) {
  const id = contextId++;
  return {
    id,
    defaultValue,
    Provider: class extends Component2 {
      getChildContext() {
        return Object.assign(Object.assign({}, this.context), { [id]: this.props.value || defaultValue });
      }
      render() {
        return this.props.children;
      }
    }
  };
};

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/effect.js
var InfernoEffect = class {
  constructor(effect, dependency) {
    this.dependency = dependency;
    this.effect = effect;
    this.destroy = effect();
  }
  update(dependency) {
    const currentDependency = this.dependency;
    if (dependency) {
      this.dependency = dependency;
    }
    if (!dependency || dependency.some((d, i) => currentDependency[i] !== d)) {
      this.dispose();
      this.destroy = this.effect();
    }
  }
  dispose() {
    if (this.destroy) {
      this.destroy();
    }
  }
};

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/re_render_effect.js
var createReRenderEffect = () => new InfernoEffect(() => {
  rerender();
}, []);

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/mocked/shared.js
var ERROR_MSG = "a runtime error occured! Use Inferno in development environment to find the error.";
function isNullOrUndef2(o) {
  return o === void 0 || o === null;
}
function isInvalid2(o) {
  return o === null || o === false || o === true || o === void 0;
}
function isFunction3(o) {
  return typeof o === "function";
}
function isNull2(o) {
  return o === null;
}
function throwError(message) {
  if (!message) {
    message = ERROR_MSG;
  }
  throw new Error(`Inferno Error: ${message}`);
}

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/mocked/hydrate.js
function isSameInnerHTML2(dom, innerHTML) {
  const tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function findLastDOMFromVNode(vNode) {
  let flags;
  let children;
  while (vNode) {
    flags = vNode.flags;
    if (flags & 2033) {
      return vNode.dom;
    }
    children = vNode.children;
    if (flags & 8192) {
      vNode = vNode.childFlags === 2 ? children : children[children.length - 1];
    } else if (flags & 4) {
      vNode = children.$LI;
    } else {
      vNode = children;
    }
  }
  return null;
}
function isSamePropsInnerHTML(dom, props) {
  return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML2(dom, props.dangerouslySetInnerHTML.__html));
}
function hydrateComponent(vNode, parentDOM, dom, context2, isSVG, isClass, lifecycle) {
  const type2 = vNode.type;
  const ref = vNode.ref;
  const props = vNode.props || EMPTY_OBJ;
  let currentNode;
  if (isClass) {
    const instance = createClassComponentInstance(vNode, type2, props, context2, isSVG, lifecycle);
    const input = instance.$LI;
    currentNode = hydrateVNode(input, parentDOM, dom, instance.$CX, isSVG, lifecycle);
    mountClassComponentCallbacks(ref, instance, lifecycle);
  } else {
    const input = normalizeRoot(renderFunctionalComponent(vNode, context2));
    currentNode = hydrateVNode(input, parentDOM, dom, context2, isSVG, lifecycle);
    vNode.children = input;
    mountFunctionalComponentCallbacks(vNode, lifecycle);
  }
  return currentNode;
}
function hydrateChildren(parentVNode, parentNode, currentNode, context2, isSVG, lifecycle) {
  const childFlags = parentVNode.childFlags;
  const children = parentVNode.children;
  const props = parentVNode.props;
  const flags = parentVNode.flags;
  if (childFlags !== 1) {
    if (childFlags === 2) {
      if (isNull2(currentNode)) {
        mount(children, parentNode, context2, isSVG, null, lifecycle);
      } else {
        currentNode = hydrateVNode(children, parentNode, currentNode, context2, isSVG, lifecycle);
        currentNode = currentNode ? currentNode.nextSibling : null;
      }
    } else if (childFlags === 16) {
      if (isNull2(currentNode)) {
        parentNode.appendChild(document.createTextNode(children));
      } else if (parentNode.childNodes.length !== 1 || currentNode.nodeType !== 3) {
        parentNode.textContent = children;
      } else if (currentNode.nodeValue !== children) {
        currentNode.nodeValue = children;
      }
      currentNode = null;
    } else if (childFlags & 12) {
      let prevVNodeIsTextNode = false;
      for (let i = 0, len = children.length; i < len; ++i) {
        const child = children[i];
        if (isNull2(currentNode) || prevVNodeIsTextNode && (child.flags & 16) > 0) {
          mount(child, parentNode, context2, isSVG, currentNode, lifecycle);
        } else {
          currentNode = hydrateVNode(child, parentNode, currentNode, context2, isSVG, lifecycle);
          currentNode = currentNode ? currentNode.nextSibling : null;
        }
        prevVNodeIsTextNode = (child.flags & 16) > 0;
      }
    }
    if ((flags & 8192) === 0) {
      let nextSibling = null;
      while (currentNode) {
        nextSibling = currentNode.nextSibling;
        parentNode.removeChild(currentNode);
        currentNode = nextSibling;
      }
    }
  } else if (!isNull2(parentNode.firstChild) && !isSamePropsInnerHTML(parentNode, props)) {
    parentNode.textContent = "";
    if (flags & 448) {
      parentNode.defaultValue = "";
    }
  }
}
function hydrateElement(vNode, parentDOM, dom, context2, isSVG, lifecycle) {
  const props = vNode.props;
  const className = vNode.className;
  const flags = vNode.flags;
  const ref = vNode.ref;
  isSVG = isSVG || (flags & 32) > 0;
  if (dom.nodeType !== 1) {
    mountElement(vNode, null, context2, isSVG, null, lifecycle);
    parentDOM.replaceChild(vNode.dom, dom);
  } else {
    vNode.dom = dom;
    hydrateChildren(vNode, dom, dom.firstChild, context2, isSVG, lifecycle);
    if (!isNull2(props)) {
      mountProps(vNode, flags, props, dom, isSVG);
    }
    if (isNullOrUndef2(className)) {
      if (dom.className !== "") {
        dom.removeAttribute("class");
      }
    } else if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
    mountRef(ref, dom, lifecycle);
  }
  return vNode.dom;
}
function hydrateText(vNode, parentDOM, dom) {
  if (dom.nodeType !== 3) {
    parentDOM.replaceChild(vNode.dom = document.createTextNode(vNode.children), dom);
  } else {
    const text = vNode.children;
    if (dom.nodeValue !== text) {
      dom.nodeValue = text;
    }
    vNode.dom = dom;
  }
  return vNode.dom;
}
function hydrateFragment(vNode, parentDOM, dom, context2, isSVG, lifecycle) {
  const children = vNode.children;
  if (vNode.childFlags === 2) {
    hydrateText(children, parentDOM, dom);
    return children.dom;
  }
  hydrateChildren(vNode, parentDOM, dom, context2, isSVG, lifecycle);
  return findLastDOMFromVNode(children[children.length - 1]);
}
function hydrateVNode(vNode, parentDOM, currentDom, context2, isSVG, lifecycle) {
  const flags = vNode.flags |= 16384;
  if (flags & 14) {
    return hydrateComponent(vNode, parentDOM, currentDom, context2, isSVG, (flags & 4) > 0, lifecycle);
  }
  if (flags & 481) {
    return hydrateElement(vNode, parentDOM, currentDom, context2, isSVG, lifecycle);
  }
  if (flags & 16) {
    return hydrateText(vNode, parentDOM, currentDom);
  }
  if (flags & 512) {
    return vNode.dom = currentDom;
  }
  if (flags & 8192) {
    return hydrateFragment(vNode, parentDOM, currentDom, context2, isSVG, lifecycle);
  }
  throwError();
  return null;
}
function hydrate(input, parentDOM, callback) {
  let dom = parentDOM.firstChild;
  if (isNull2(dom)) {
    render(input, parentDOM, callback);
  } else {
    const lifecycle = [];
    if (!isInvalid2(input)) {
      dom = hydrateVNode(input, parentDOM, dom, {}, false, lifecycle);
    }
    while (dom && (dom = dom.nextSibling)) {
      parentDOM.removeChild(dom);
    }
    if (lifecycle.length > 0) {
      let listener;
      while ((listener = lifecycle.shift()) !== void 0) {
        listener();
      }
    }
  }
  parentDOM.$V = input;
  if (isFunction3(callback)) {
    callback();
  }
}

// ../../../../../../node_modules/inferno-create-element/dist/index.esm.js
function isNullOrUndef3(o) {
  return o === void 0 || o === null;
}
function isString3(o) {
  return typeof o === "string";
}
function isUndefined2(o) {
  return o === void 0;
}
var componentHooks = {
  onComponentDidMount: 1,
  onComponentDidUpdate: 1,
  onComponentShouldUpdate: 1,
  onComponentWillMount: 1,
  onComponentWillUnmount: 1,
  onComponentWillUpdate: 1
};
function createElement(type2, props, _children) {
  var arguments$1 = arguments;
  var children;
  var ref = null;
  var key = null;
  var className = null;
  var flags = 0;
  var newProps;
  var childLen = arguments.length - 2;
  if (childLen === 1) {
    children = _children;
  } else if (childLen > 1) {
    children = [];
    while (childLen-- > 0) {
      children[childLen] = arguments$1[childLen + 2];
    }
  }
  if (isString3(type2)) {
    flags = getFlagsForElementVnode(type2);
    if (!isNullOrUndef3(props)) {
      newProps = {};
      for (var prop in props) {
        if (prop === "className" || prop === "class") {
          className = props[prop];
        } else if (prop === "key") {
          key = props.key;
        } else if (prop === "children" && isUndefined2(children)) {
          children = props.children;
        } else if (prop === "ref") {
          ref = props.ref;
        } else {
          if (prop === "contenteditable") {
            flags |= 4096;
          }
          newProps[prop] = props[prop];
        }
      }
    }
  } else {
    flags = 2;
    if (!isUndefined2(children)) {
      if (!props) {
        props = {};
      }
      props.children = children;
    }
    if (!isNullOrUndef3(props)) {
      newProps = {};
      for (var prop$1 in props) {
        if (prop$1 === "key") {
          key = props.key;
        } else if (prop$1 === "ref") {
          ref = props.ref;
        } else if (componentHooks[prop$1] === 1) {
          if (!ref) {
            ref = {};
          }
          ref[prop$1] = props[prop$1];
        } else {
          newProps[prop$1] = props[prop$1];
        }
      }
    }
    return createComponentVNode(flags, type2, newProps, key, ref);
  }
  if (flags & 8192) {
    return createFragment(childLen === 1 ? [children] : children, 0, key);
  }
  return createVNode(flags, type2, className, children, 0, newProps, key, ref);
}

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/render_template.js
var getContainer = (props) => {
  var _a, _b;
  return ((_a = props.container) === null || _a === void 0 ? void 0 : _a.get(0)) || ((_b = props.item) === null || _b === void 0 ? void 0 : _b.get(0));
};
function renderTemplate(template, props, _component) {
  setTimeout(() => {
    render(createElement(template, props), getContainer(props));
  }, 0);
}
var hasTemplate = (name2, properties, _component) => {
  const value2 = properties[name2];
  return !!value2 && typeof value2 !== "string";
};

// ../../../../../../node_modules/@devextreme/runtime/esm/inferno/normalize_styles.js
var NUMBER_STYLES = /* @__PURE__ */ new Set([
  "animationIterationCount",
  "borderImageOutset",
  "borderImageSlice",
  "border-imageWidth",
  "boxFlex",
  "boxFlexGroup",
  "boxOrdinalGroup",
  "columnCount",
  "fillOpacity",
  "flex",
  "flexGrow",
  "flexNegative",
  "flexOrder",
  "flexPositive",
  "flexShrink",
  "floodOpacity",
  "fontWeight",
  "gridColumn",
  "gridRow",
  "lineClamp",
  "lineHeight",
  "opacity",
  "order",
  "orphans",
  "stopOpacity",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "tabSize",
  "widows",
  "zIndex",
  "zoom"
]);
var isNumeric2 = (value2) => {
  if (typeof value2 === "number")
    return true;
  return !Number.isNaN(Number(value2));
};
var getNumberStyleValue = (style, value2) => NUMBER_STYLES.has(style) ? value2 : `${value2}px`;
var uppercasePattern = /[A-Z]/g;
var kebabCase = (str) => str.replace(uppercasePattern, "-$&").toLowerCase();
function normalizeStyles(styles) {
  if (!(styles instanceof Object)) {
    return void 0;
  }
  return Object.entries(styles).reduce((acc, [key, value2]) => {
    acc[kebabCase(key)] = isNumeric2(value2) ? getNumberStyleValue(key, value2) : value2;
    return acc;
  }, {});
}

// ../../../../../../node_modules/devextreme/esm/core/inferno_renderer.js
var remove3 = (element) => {
  const {
    parentNode
  } = element;
  if (parentNode) {
    const nextSibling = element.nextSibling;
    cleanDataRecursive(element);
    parentNode.$V = element.$V;
    render(null, parentNode);
    parentNode.insertBefore(element, nextSibling);
    element.innerHTML = "";
    delete parentNode.$V;
  }
  delete element.$V;
};
var inferno_renderer_default = dependency_injector_default({
  createElement: (component, props) => createElement(component, props),
  remove: remove3,
  onAfterRender: () => {
    InfernoEffectHost.callEffects();
  },
  onPreRender: () => {
    InfernoEffectHost.lock();
  },
  render: (component, props, container, replace) => {
    if (!replace) {
      const {
        parentNode
      } = container;
      const nextNode = null === container || void 0 === container ? void 0 : container.nextSibling;
      const rootNode = dom_adapter_default.createElement("div");
      rootNode.appendChild(container);
      const mountNode = dom_adapter_default.createDocumentFragment().appendChild(rootNode);
      const vNodeAlreadyExists = !!container.$V;
      vNodeAlreadyExists && remove3(container);
      hydrate(createElement(component, props), mountNode);
      container.$V = mountNode.$V;
      if (parentNode) {
        parentNode.insertBefore(container, nextNode);
      }
    } else {
      render(createElement(component, props), container);
    }
  }
});

// ../../../../../../node_modules/devextreme/esm/renovation/utils/shallow_equals.js
var shallowEquals = (firstObject, secondObject) => {
  if (Object.keys(firstObject).length !== Object.keys(secondObject).length) {
    return false;
  }
  return Object.keys(firstObject).every((key) => firstObject[key] === secondObject[key]);
};

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/common/template_wrapper.js
var _excluded3 = ["isEqual"];
function isDxElementWrapper(element) {
  return !!element.toArray;
}
function buildTemplateArgs(model, template) {
  const args = {
    template,
    model: _extends({}, model)
  };
  const _ref = model.data ?? {}, {
    isEqual: isEqual2
  } = _ref, data2 = _objectWithoutPropertiesLoose(_ref, _excluded3);
  if (isEqual2) {
    args.model.data = data2;
    args.isEqual = isEqual2;
  }
  return args;
}
function renderTemplateContent(props, container) {
  const {
    data: data2,
    index: index2
  } = props.model ?? {
    data: {}
  };
  if (data2) {
    Object.keys(data2).forEach((name2) => {
      if (data2[name2] && dom_adapter_default.isNode(data2[name2])) {
        data2[name2] = getPublicElement(renderer_default(data2[name2]));
      }
    });
  }
  const rendered = props.template.render(_extends({
    container,
    transclude: props.transclude
  }, {
    renovated: props.renovated
  }, !props.transclude ? {
    model: data2
  } : {}, !props.transclude && Number.isFinite(index2) ? {
    index: index2
  } : {}));
  if (void 0 === rendered) {
    return [];
  }
  return isDxElementWrapper(rendered) ? rendered.toArray() : [renderer_default(rendered).get(0)];
}
function removeDifferentElements(oldChildren, newChildren) {
  newChildren.forEach((newElement) => {
    const hasOldChild = !!oldChildren.find((oldElement) => newElement === oldElement);
    if (!hasOldChild && newElement.parentNode) {
      renderer_default(newElement).remove();
    }
  });
}
var TemplateWrapper = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.renderTemplate = this.renderTemplate.bind(this);
  }
  renderTemplate() {
    const node = findDOMfromVNode(this.$LI, true);
    if (!(null !== node && void 0 !== node && node.parentNode)) {
      return () => {
      };
    }
    const container = node.parentNode;
    const $container = renderer_default(container);
    const $oldContainerContent = $container.contents().toArray();
    const content = renderTemplateContent(this.props, getPublicElement($container));
    replaceWith(renderer_default(node), renderer_default(content));
    return () => {
      const $actualContainerContent = renderer_default(container).contents().toArray();
      removeDifferentElements($oldContainerContent, $actualContainerContent);
      container.appendChild(node);
    };
  }
  shouldComponentUpdate(nextProps) {
    const {
      model,
      template
    } = this.props;
    const {
      isEqual: isEqual2,
      model: nextModel,
      template: nextTemplate
    } = nextProps;
    const equalityComparer = isEqual2 ?? shallowEquals;
    if (template !== nextTemplate) {
      return true;
    }
    if (!isDefined(model) || !isDefined(nextModel)) {
      return model !== nextModel;
    }
    const {
      data: data2,
      index: index2
    } = model;
    const {
      data: nextData,
      index: nextIndex
    } = nextModel;
    if (index2 !== nextIndex) {
      return true;
    }
    return !equalityComparer(data2, nextData);
  }
  createEffects() {
    return [new InfernoEffect(this.renderTemplate, [this.props.template, this.props.model])];
  }
  updateEffects() {
    this._effects[0].update([this.props.template, this.props.model]);
  }
  componentWillUnmount() {
  }
  render() {
    return null;
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/utils/update_props_immutable.js
function cloneObjectValue(value2) {
  return Array.isArray(value2) ? [...value2] : _extends({}, value2);
}
function cloneObjectProp(value2, prevValue, fullNameParts) {
  const result2 = fullNameParts.length > 0 && prevValue && value2 !== prevValue ? cloneObjectValue(prevValue) : cloneObjectValue(value2);
  const name2 = fullNameParts[0];
  if (fullNameParts.length > 1) {
    result2[name2] = cloneObjectProp(value2[name2], null === prevValue || void 0 === prevValue ? void 0 : prevValue[name2], fullNameParts.slice(1));
  } else if (name2) {
    if (isPlainObject(value2[name2])) {
      result2[name2] = cloneObjectValue(value2[name2]);
    } else {
      result2[name2] = value2[name2];
    }
  }
  return result2;
}
function updatePropsImmutable(props, option, name2, fullName) {
  const currentPropsValue = option[name2];
  const prevPropsValue = props[name2];
  const result2 = props;
  if (isPlainObject(currentPropsValue) || name2 !== fullName && Array.isArray(currentPropsValue)) {
    result2[name2] = cloneObjectProp(currentPropsValue, prevPropsValue, getPathParts(fullName).slice(1));
  } else {
    result2[name2] = currentPropsValue;
  }
}

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/common/component.js
var setDefaultOptionValue = (options2, defaultValueGetter) => (name2) => {
  if (Object.prototype.hasOwnProperty.call(options2, name2) && void 0 === options2[name2]) {
    options2[name2] = defaultValueGetter(name2);
  }
};
var ComponentWrapper = class extends dom_component_default {
  get _propsInfo() {
    return {
      allowNull: [],
      twoWay: [],
      elements: [],
      templates: [],
      props: []
    };
  }
  constructor(element, options2) {
    super(element, options2);
    this._shouldRaiseContentReady = false;
    this.validateKeyDownHandler();
  }
  validateKeyDownHandler() {
    const supportedKeyNames = this.getSupportedKeyNames();
    const hasComponentDefaultKeyHandlers = supportedKeyNames.length > 0;
    const hasComponentKeyDownMethod = "function" === typeof this._viewComponent.prototype.keyDown;
    if (hasComponentDefaultKeyHandlers && !hasComponentKeyDownMethod) {
      throw Error("Component's declaration must have 'keyDown' method.");
    }
  }
  get viewRef() {
    var _this$_viewRef;
    return null === (_this$_viewRef = this._viewRef) || void 0 === _this$_viewRef ? void 0 : _this$_viewRef.current;
  }
  _checkContentReadyOption(fullName) {
    const contentReadyOptions = this._getContentReadyOptions().reduce((options2, name2) => {
      options2[name2] = true;
      return options2;
    }, {});
    this._checkContentReadyOption = (optionName) => !!contentReadyOptions[optionName];
    return this._checkContentReadyOption(fullName);
  }
  _getContentReadyOptions() {
    return ["rtlEnabled"];
  }
  _fireContentReady() {
    this._actionsMap.onContentReady({});
  }
  _getDefaultOptions() {
    const viewDefaultProps = this._getViewComponentDefaultProps();
    return extend(true, super._getDefaultOptions(), viewDefaultProps, this._propsInfo.twoWay.reduce((options2, _ref) => {
      let [name2, defaultName, eventName] = _ref;
      return _extends({}, options2, {
        [name2]: viewDefaultProps[defaultName],
        [eventName]: (value2) => this.option(name2, value2)
      });
    }, {}), this._propsInfo.templates.reduce((options2, name2) => _extends({}, options2, {
      [name2]: null
    }), {}));
  }
  _getUnwrappedOption() {
    const unwrappedProps = {};
    Object.keys(this.option()).forEach((key) => {
      unwrappedProps[key] = this.option(key);
    });
    return unwrappedProps;
  }
  _initializeComponent() {
    var _this$_templateManage;
    super._initializeComponent();
    null === (_this$_templateManage = this._templateManager) || void 0 === _this$_templateManage || _this$_templateManage.addDefaultTemplates(this.getDefaultTemplates());
    const optionProxy = this._getUnwrappedOption();
    this._props = this._optionsWithDefaultTemplates(optionProxy);
    this._propsInfo.templates.forEach((template) => {
      this._componentTemplates[template] = this._createTemplateComponent(this._props[template]);
    });
    Object.keys(this._getActionConfigsFull()).forEach((name2) => this._addAction(name2));
    this._viewRef = createRef();
    this.defaultKeyHandlers = this._createDefaultKeyHandlers();
  }
  _initMarkup() {
    const props = this.getProps();
    this._renderWrapper(props);
  }
  _renderWrapper(props) {
    const containerNode = this.$element()[0];
    if (!this._isNodeReplaced) {
      inferno_renderer_default.onPreRender();
    }
    inferno_renderer_default.render(this._viewComponent, props, containerNode, this._isNodeReplaced);
    if (!this._isNodeReplaced) {
      this._isNodeReplaced = true;
      inferno_renderer_default.onAfterRender();
      this._shouldRaiseContentReady = true;
    }
    if (this._shouldRaiseContentReady) {
      this._fireContentReady();
      this._shouldRaiseContentReady = false;
    }
  }
  _silent(name2, value2) {
    this._options.silent(name2, value2);
  }
  _render() {
  }
  _removeWidget() {
    inferno_renderer_default.remove(this.$element()[0]);
  }
  _dispose() {
    this._removeWidget();
    super._dispose();
  }
  get elementAttr() {
    const element = this.$element()[0];
    if (!this._elementAttr) {
      const {
        attributes
      } = element;
      const attrs = Array.from(attributes).filter((attr) => {
        var _attributes$attr$name;
        return !this._propsInfo.templates.includes(attr.name) && (null === (_attributes$attr$name = attributes[attr.name]) || void 0 === _attributes$attr$name ? void 0 : _attributes$attr$name.specified);
      }).reduce((result2, _ref2) => {
        let {
          name: name2,
          value: value2
        } = _ref2;
        const updatedAttributes = result2;
        const isDomAttr = name2 in element;
        updatedAttributes[name2] = "" === value2 && isDomAttr ? element[name2] : value2;
        return updatedAttributes;
      }, {});
      this._elementAttr = attrs;
      this._storedClasses = element.getAttribute("class") || "";
    }
    const elemStyle = element.style;
    const style = {};
    for (let i = 0; i < elemStyle.length; i += 1) {
      style[elemStyle[i]] = elemStyle.getPropertyValue(elemStyle[i]);
    }
    this._elementAttr.style = style;
    this._elementAttr.class = this._storedClasses;
    return this._elementAttr;
  }
  _getAdditionalActionConfigs() {
    return {
      onContentReady: {
        excludeValidators: ["disabled", "readOnly"]
      }
    };
  }
  _getAdditionalProps() {
    return [];
  }
  _patchOptionValues(options2) {
    const {
      allowNull,
      elements,
      props,
      twoWay
    } = this._propsInfo;
    const viewDefaultProps = this._getViewComponentDefaultProps();
    const defaultWidgetPropsKeys = Object.keys(viewDefaultProps);
    const defaultOptions3 = this._getDefaultOptions();
    const {
      children,
      onKeyboardHandled,
      ref
    } = options2;
    const onKeyDown = onKeyboardHandled ? (_, event_options) => {
      onKeyboardHandled(event_options);
    } : void 0;
    const widgetProps = {
      ref,
      children,
      onKeyDown
    };
    [...props, ...this._getAdditionalProps()].forEach((propName) => {
      if (Object.prototype.hasOwnProperty.call(options2, propName)) {
        widgetProps[propName] = options2[propName];
      }
    });
    allowNull.forEach(setDefaultOptionValue(widgetProps, () => null));
    defaultWidgetPropsKeys.forEach(setDefaultOptionValue(widgetProps, (name2) => defaultOptions3[name2]));
    twoWay.forEach((_ref3) => {
      let [name2, defaultName] = _ref3;
      setDefaultOptionValue(widgetProps, () => defaultOptions3[defaultName])(name2);
    });
    elements.forEach((name2) => {
      if (name2 in widgetProps) {
        const value2 = widgetProps[name2];
        if (isRenderer(value2)) {
          widgetProps[name2] = this._patchElementParam(value2);
        }
      }
    });
    return widgetProps;
  }
  getSupportedKeyNames() {
    return [];
  }
  prepareStyleProp(props) {
    if ("string" === typeof props.style) {
      return _extends({}, props, {
        style: {},
        cssText: props.style
      });
    }
    return props;
  }
  getProps() {
    const {
      elementAttr
    } = this.option();
    const options2 = this._patchOptionValues(_extends({}, this._props, {
      ref: this._viewRef,
      children: this._extractDefaultSlot(),
      aria: this._aria
    }));
    this._propsInfo.templates.forEach((template) => {
      options2[template] = this._componentTemplates[template];
    });
    return this.prepareStyleProp(_extends({}, options2, this.elementAttr, elementAttr, {
      className: [...(this.elementAttr.class ?? "").split(" "), ...((null === elementAttr || void 0 === elementAttr ? void 0 : elementAttr.class) ?? "").split(" ")].filter((c, i, a) => c && a.indexOf(c) === i).join(" ").trim(),
      class: ""
    }, this._actionsMap));
  }
  _getActionConfigs() {
    return {};
  }
  _getActionConfigsFull() {
    return _extends({}, this._getActionConfigs(), this._getAdditionalActionConfigs());
  }
  getDefaultTemplates() {
    const defaultTemplates = Object.values(this._templatesInfo);
    const result2 = {};
    defaultTemplates.forEach((template) => {
      result2[template] = "dx-renovation-template-mock";
    });
    return result2;
  }
  get _templatesInfo() {
    return {};
  }
  _optionsWithDefaultTemplates(options2) {
    const templateOptions = Object.entries(this._templatesInfo).reduce((result2, _ref4) => {
      let [templateName, templateValue] = _ref4;
      return _extends({}, result2, {
        [templateName]: options2[templateName] ?? templateValue
      });
    }, {});
    return _extends({}, options2, templateOptions);
  }
  _init() {
    super._init();
    this.customKeyHandlers = {};
    this._actionsMap = {};
    this._aria = {};
    this._componentTemplates = {};
  }
  _createDefaultKeyHandlers() {
    const result2 = {};
    const keys = this.getSupportedKeyNames();
    keys.forEach((key) => {
      result2[key] = (e) => this.viewRef.keyDown(keyboard_processor_default.createKeyDownOptions(e));
    });
    return result2;
  }
  _addAction(event, actionToAdd) {
    let action = actionToAdd;
    if (!action) {
      const actionByOption = this._createActionByOption(event, this._getActionConfigsFull()[event]);
      action = (actArgs) => {
        Object.keys(actArgs).forEach((name2) => {
          if (isDefined(actArgs[name2]) && dom_adapter_default.isNode(actArgs[name2])) {
            actArgs[name2] = getPublicElement(renderer_default(actArgs[name2]));
          }
        });
        return actionByOption(actArgs);
      };
    }
    this._actionsMap[event] = action;
  }
  _optionChanged(option) {
    const {
      fullName,
      name: name2,
      previousValue,
      value: value2
    } = option;
    updatePropsImmutable(this._props, this.option(), name2, fullName);
    if (this._propsInfo.templates.includes(name2) && value2 !== previousValue) {
      this._componentTemplates[name2] = this._createTemplateComponent(value2);
    }
    if (name2 && this._getActionConfigsFull()[name2]) {
      this._addAction(name2);
    }
    this._shouldRaiseContentReady = this._shouldRaiseContentReady || this._checkContentReadyOption(fullName);
    super._optionChanged(option);
    this._invalidate();
  }
  _extractDefaultSlot() {
    if (this.option("_hasAnonymousTemplateContent")) {
      return inferno_renderer_default.createElement(TemplateWrapper, {
        template: this._getTemplate(this._templateManager.anonymousTemplateName),
        transclude: true,
        renovated: true
      });
    }
    return null;
  }
  _createTemplateComponent(templateOption) {
    if (!templateOption) {
      return;
    }
    const template = this._getTemplate(templateOption);
    if (isString(template) && "dx-renovation-template-mock" === template) {
      return;
    }
    return (model) => inferno_renderer_default.createElement(TemplateWrapper, buildTemplateArgs(model, template));
  }
  _wrapKeyDownHandler(initialHandler) {
    return (options2) => {
      const {
        keyName,
        originalEvent,
        which
      } = options2;
      const keys = this.customKeyHandlers;
      const func = keys[keyName] || keys[which];
      if (void 0 !== func) {
        const handler = func.bind(this);
        const result2 = handler(originalEvent, options2);
        if (!result2) {
          originalEvent.cancel = true;
          return originalEvent;
        }
      }
      return null === initialHandler || void 0 === initialHandler ? void 0 : initialHandler(originalEvent, options2);
    };
  }
  _toPublicElement(element) {
    return getPublicElement(renderer_default(element));
  }
  _patchElementParam(value2) {
    try {
      const result2 = renderer_default(value2);
      const element = null === result2 || void 0 === result2 ? void 0 : result2.get(0);
      return null !== element && void 0 !== element && element.nodeType ? element : value2;
    } catch (error) {
      return value2;
    }
  }
  repaint() {
    this._isNodeReplaced = false;
    this._shouldRaiseContentReady = true;
    this._removeWidget();
    this._refresh();
  }
  _supportedKeys() {
    return _extends({}, this.defaultKeyHandlers, this.customKeyHandlers);
  }
  registerKeyHandler(key, handler) {
    this.customKeyHandlers[key] = handler;
  }
  setAria(name2, value2) {
    this._aria[name2] = value2;
    this._initMarkup();
  }
  _getViewComponentDefaultProps() {
    return this._viewComponent.defaultProps || {};
  }
};
ComponentWrapper.IS_RENOVATED_WIDGET = false;
var component_default = ComponentWrapper;
ComponentWrapper.IS_RENOVATED_WIDGET = true;

// ../../../../../../node_modules/devextreme/esm/core/utils/icon.js
var getImageSourceType = (source) => {
  if (!source || "string" !== typeof source) {
    return false;
  }
  if (/^\s*<svg[^>]*>(.|\r?\n)*?<\/svg>\s*$/i.test(source)) {
    return "svg";
  }
  if (/data:.*base64|\.|[^<\s]\/{1,1}/.test(source)) {
    return "image";
  }
  if (/^[\w-_]+$/.test(source)) {
    return "dxIcon";
  }
  if (/^\s?([\w-_:]\s?)+$/.test(source)) {
    return "fontIcon";
  }
  return false;
};
var getImageContainer = (source) => {
  switch (getImageSourceType(source)) {
    case "image":
      return renderer_default("<img>").attr("src", source).addClass("dx-icon");
    case "fontIcon":
      return renderer_default("<i>").addClass(`dx-icon ${source}`);
    case "dxIcon":
      return renderer_default("<i>").addClass(`dx-icon dx-icon-${source}`);
    case "svg":
      return renderer_default("<i>").addClass("dx-icon dx-svg-icon").append(source);
    default:
      return null;
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/button.js
var ButtonWrapper = class extends component_default {
  get _validationGroupConfig() {
    return validation_engine_default.getGroupConfig(this._findGroup());
  }
  getDefaultTemplateNames() {
    return ["content"];
  }
  getSupportedKeyNames() {
    return ["space", "enter"];
  }
  getProps() {
    const props = super.getProps();
    props.onClick = (_ref) => {
      let {
        event
      } = _ref;
      this._clickAction({
        event,
        validationGroup: this._validationGroupConfig
      });
    };
    const iconType = getImageSourceType(props.icon);
    if ("svg" === iconType) {
      props.iconTemplate = this._createTemplateComponent(() => props.icon);
    }
    return props;
  }
  get _templatesInfo() {
    return {
      template: "content"
    };
  }
  _toggleActiveState(_, value2) {
    const button = this.viewRef;
    value2 ? button.activate() : button.deactivate();
  }
  _getSubmitAction() {
    let needValidate = true;
    let validationStatus = "valid";
    return this._createAction((_ref2) => {
      let {
        event,
        submitInput
      } = _ref2;
      if (needValidate) {
        const validationGroup = this._validationGroupConfig;
        if (void 0 !== validationGroup && "" !== validationGroup) {
          const validationResult = validationGroup.validate();
          validationStatus = validationResult.status;
          if ("pending" === validationResult.status) {
            needValidate = false;
            this.option("disabled", true);
            validationResult.complete.then((_ref3) => {
              let {
                status
              } = _ref3;
              this.option("disabled", false);
              validationStatus = status;
              "valid" === validationStatus && submitInput.click();
              needValidate = true;
            });
          }
        }
      }
      "valid" !== validationStatus && event.preventDefault();
      event.stopPropagation();
    });
  }
  _initializeComponent() {
    super._initializeComponent();
    this._addAction("onSubmit", this._getSubmitAction());
    this._clickAction = this._createClickAction();
  }
  _initMarkup() {
    super._initMarkup();
    const $content = this.$element().find(".dx-button-content").first();
    const $template = $content.children().filter(".dx-template-wrapper");
    const $input = $content.children().filter(".dx-button-submit-input");
    if ($template.length) {
      $template.addClass("dx-button-content");
      $template.append($input);
      $content.replaceWith($template);
    }
  }
  _patchOptionValues(options2) {
    return super._patchOptionValues(_extends({}, options2, {
      templateData: options2._templateData
    }));
  }
  _findGroup() {
    const $element = this.$element();
    const validationGroup = this.option("validationGroup");
    return void 0 !== validationGroup && "" !== validationGroup ? validationGroup : validation_engine_default.findGroup($element, this._modelByElement($element));
  }
  _createClickAction() {
    return this._createActionByOption("onClick", {
      excludeValidators: ["readOnly"]
    });
  }
  _optionChanged(option) {
    if ("onClick" === option.name) {
      this._clickAction = this._createClickAction();
    }
    super._optionChanged(option);
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/utils/combine_classes.js
function combineClasses(classesMap) {
  return Object.keys(classesMap).filter((p2) => classesMap[p2]).join(" ");
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/icon.js
var _excluded4 = ["iconTemplate", "position", "source"];
var viewFunction = (_ref) => {
  let {
    iconClassName,
    props: {
      iconTemplate: IconTemplate,
      source
    },
    sourceType
  } = _ref;
  return createFragment(["dxIcon" === sourceType && createVNode(1, "i", iconClassName), "fontIcon" === sourceType && createVNode(1, "i", iconClassName), "image" === sourceType && createVNode(1, "img", iconClassName, null, 1, {
    alt: "",
    src: source
  }), IconTemplate && createVNode(1, "i", iconClassName, IconTemplate({}), 0)], 0);
};
var IconProps = {
  position: "left",
  source: ""
};
var getTemplate = (TemplateProp) => TemplateProp && (TemplateProp.defaultProps ? (props) => normalizeProps(createComponentVNode(2, TemplateProp, _extends({}, props))) : TemplateProp);
var Icon = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }
  get sourceType() {
    return getImageSourceType(this.props.source);
  }
  get cssClass() {
    return "left" !== this.props.position ? "dx-icon-right" : "";
  }
  get iconClassName() {
    const generalClasses = {
      "dx-icon": true,
      [this.cssClass]: !!this.cssClass
    };
    const {
      source
    } = this.props;
    if ("dxIcon" === this.sourceType) {
      return combineClasses(_extends({}, generalClasses, {
        [`dx-icon-${source}`]: true
      }));
    }
    if ("fontIcon" === this.sourceType) {
      return combineClasses(_extends({}, generalClasses, {
        [String(source)]: !!source
      }));
    }
    if ("image" === this.sourceType) {
      return combineClasses(generalClasses);
    }
    if ("svg" === this.sourceType) {
      return combineClasses(_extends({}, generalClasses, {
        "dx-svg-icon": true
      }));
    }
    return "";
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded4);
    return restProps;
  }
  render() {
    const props = this.props;
    return viewFunction({
      props: _extends({}, props, {
        iconTemplate: getTemplate(props.iconTemplate)
      }),
      sourceType: this.sourceType,
      cssClass: this.cssClass,
      iconClassName: this.iconClassName,
      restAttributes: this.restAttributes
    });
  }
};
Icon.defaultProps = IconProps;

// ../../../../../../node_modules/devextreme/esm/ui/widget/utils.ink_ripple.js
var INKRIPPLE_SHOWING_CLASS = "dx-inkripple-showing";
var INKRIPPLE_HIDING_CLASS = "dx-inkripple-hiding";
var initConfig = function() {
  let config3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  const {
    useHoldAnimation,
    waveSizeCoefficient,
    isCentered,
    wavesNumber
  } = config3;
  return {
    waveSizeCoefficient: waveSizeCoefficient || 2,
    isCentered: isCentered || false,
    wavesNumber: wavesNumber || 1,
    durations: getDurations(useHoldAnimation ?? true)
  };
};
var render3 = function(args) {
  const config3 = initConfig(args);
  return {
    showWave: showWave.bind(this, config3),
    hideWave: hideWave.bind(this, config3)
  };
};
var getInkRipple = function(element) {
  let result2 = element.children(".dx-inkripple");
  if (0 === result2.length) {
    result2 = renderer_default("<div>").addClass("dx-inkripple").appendTo(element);
  }
  return result2;
};
var getWaves = function(element, wavesNumber) {
  const inkRipple = getInkRipple(renderer_default(element));
  const result2 = inkRipple.children(".dx-inkripple-wave").toArray();
  for (let i = result2.length; i < wavesNumber; i++) {
    const $currentWave = renderer_default("<div>").appendTo(inkRipple).addClass("dx-inkripple-wave");
    result2.push($currentWave[0]);
  }
  return renderer_default(result2);
};
var getWaveStyleConfig = function(args, config3) {
  const element = renderer_default(config3.element);
  const elementWidth = getOuterWidth(element);
  const elementHeight = getOuterHeight(element);
  const elementDiagonal = parseInt(Math.sqrt(elementWidth * elementWidth + elementHeight * elementHeight));
  const waveSize = Math.min(4e3, parseInt(elementDiagonal * args.waveSizeCoefficient));
  let left;
  let top;
  if (args.isCentered) {
    left = (elementWidth - waveSize) / 2;
    top = (elementHeight - waveSize) / 2;
  } else {
    const event = config3.event;
    const position3 = element.offset();
    const x = event.pageX - position3.left;
    const y = event.pageY - position3.top;
    left = x - waveSize / 2;
    top = y - waveSize / 2;
  }
  return {
    left,
    top,
    height: waveSize,
    width: waveSize
  };
};
function showWave(args, config3) {
  const $wave = getWaves(config3.element, args.wavesNumber).eq(config3.wave || 0);
  args.hidingTimeout && clearTimeout(args.hidingTimeout);
  hideSelectedWave($wave);
  $wave.css(getWaveStyleConfig(args, config3));
  args.showingTimeout = setTimeout(showingWaveHandler.bind(this, args, $wave), 0);
}
function showingWaveHandler(args, $wave) {
  const durationCss = args.durations.showingScale + "ms";
  $wave.addClass(INKRIPPLE_SHOWING_CLASS).css("transitionDuration", durationCss);
}
function getDurations(useHoldAnimation) {
  return {
    showingScale: useHoldAnimation ? 1e3 : 300,
    hidingScale: 300,
    hidingOpacity: 300
  };
}
function hideSelectedWave($wave) {
  $wave.removeClass(INKRIPPLE_HIDING_CLASS).css("transitionDuration", "");
}
function hideWave(args, config3) {
  args.showingTimeout && clearTimeout(args.showingTimeout);
  const $wave = getWaves(config3.element, config3.wavesNumber).eq(config3.wave || 0);
  const durations = args.durations;
  const durationCss = durations.hidingScale + "ms, " + durations.hidingOpacity + "ms";
  $wave.addClass(INKRIPPLE_HIDING_CLASS).removeClass(INKRIPPLE_SHOWING_CLASS).css("transitionDuration", durationCss);
  const animationDuration = Math.max(durations.hidingScale, durations.hidingOpacity);
  args.hidingTimeout = setTimeout(hideSelectedWave.bind(this, $wave), animationDuration);
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/ink_ripple.js
var _excluded5 = ["config"];
var viewFunction2 = (model) => normalizeProps(createVNode(1, "div", "dx-inkripple", null, 1, _extends({}, model.restAttributes)));
var InkRippleProps = {
  config: Object.freeze({})
};
var InkRipple = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.__getterCache = {};
    this.hideWave = this.hideWave.bind(this);
    this.showWave = this.showWave.bind(this);
  }
  get getConfig() {
    if (void 0 !== this.__getterCache.getConfig) {
      return this.__getterCache.getConfig;
    }
    return this.__getterCache.getConfig = (() => {
      const {
        config: config3
      } = this.props;
      return initConfig(config3);
    })();
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded5);
    return restProps;
  }
  hideWave(opts) {
    hideWave(this.getConfig, opts);
  }
  showWave(opts) {
    showWave(this.getConfig, opts);
  }
  componentWillUpdate(nextProps, nextState, context2) {
    if (this.props.config !== nextProps.config) {
      this.__getterCache.getConfig = void 0;
    }
  }
  render() {
    const props = this.props;
    return viewFunction2({
      props: _extends({}, props),
      getConfig: this.getConfig,
      restAttributes: this.restAttributes
    });
  }
};
InkRipple.defaultProps = InkRippleProps;

// ../../../../../../node_modules/devextreme/esm/events/gesture/emitter.gesture.js
var ready4 = ready_callbacks_default.add;
var abs2 = Math.abs;
var TOUCH_BOUNDARY = 10;
var supportPointerEvents = function() {
  return styleProp("pointer-events");
};
var setGestureCover = call_once_default(function() {
  const isDesktop = "desktop" === devices_default.real().deviceType;
  if (!supportPointerEvents() || !isDesktop) {
    return noop2;
  }
  const $cover = renderer_default("<div>").addClass("dx-gesture-cover").css("pointerEvents", "none");
  events_engine_default.subscribeGlobal($cover, "dxmousewheel", function(e) {
    e.preventDefault();
  });
  ready4(function() {
    $cover.appendTo("body");
  });
  return function(toggle, cursor) {
    $cover.css("pointerEvents", toggle ? "all" : "none");
    toggle && $cover.css("cursor", cursor);
  };
});
var gestureCover = function(toggle, cursor) {
  const gestureCoverStrategy = setGestureCover();
  gestureCoverStrategy(toggle, cursor);
};
var GestureEmitter = emitter_default.inherit({
  gesture: true,
  configure: function(data2) {
    this.getElement().css("msTouchAction", data2.immediate ? "pinch-zoom" : "");
    this.callBase(data2);
  },
  allowInterruptionByMouseWheel: function() {
    return 2 !== this._stage;
  },
  getDirection: function() {
    return this.direction;
  },
  _cancel: function() {
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
    this._stage = 0;
  },
  start: function(e) {
    if (e._needSkipEvent || needSkipEvent(e)) {
      this._cancel(e);
      return;
    }
    this._startEvent = createEvent(e);
    this._startEventData = eventData(e);
    this._stage = 1;
    this._init(e);
    this._setupImmediateTimer();
  },
  _setupImmediateTimer: function() {
    clearTimeout(this._immediateTimer);
    this._immediateAccepted = false;
    if (!this.immediate) {
      return;
    }
    if (0 === this.immediateTimeout) {
      this._immediateAccepted = true;
      return;
    }
    this._immediateTimer = setTimeout((function() {
      this._immediateAccepted = true;
    }).bind(this), this.immediateTimeout ?? 180);
  },
  move: function(e) {
    if (1 === this._stage && this._directionConfirmed(e)) {
      this._stage = 2;
      this._resetActiveElement();
      this._toggleGestureCover(true);
      this._clearSelection(e);
      this._adjustStartEvent(e);
      this._start(this._startEvent);
      if (0 === this._stage) {
        return;
      }
      this._requestAccept(e);
      this._move(e);
      this._forgetAccept();
    } else if (2 === this._stage) {
      this._clearSelection(e);
      this._move(e);
    }
  },
  _directionConfirmed: function(e) {
    const touchBoundary = this._getTouchBoundary(e);
    const delta = eventDelta(this._startEventData, eventData(e));
    const deltaX = abs2(delta.x);
    const deltaY = abs2(delta.y);
    const horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);
    const verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
    const direction = this.getDirection(e);
    const bothAccepted = "both" === direction && (horizontalMove || verticalMove);
    const horizontalAccepted = "horizontal" === direction && horizontalMove;
    const verticalAccepted = "vertical" === direction && verticalMove;
    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;
  },
  _validateMove: function(touchBoundary, mainAxis, crossAxis) {
    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);
  },
  _getTouchBoundary: function(e) {
    return this.immediate || isDxMouseWheelEvent(e) ? 0 : TOUCH_BOUNDARY;
  },
  _adjustStartEvent: function(e) {
    const touchBoundary = this._getTouchBoundary(e);
    const delta = eventDelta(this._startEventData, eventData(e));
    this._startEvent.pageX += sign(delta.x) * touchBoundary;
    this._startEvent.pageY += sign(delta.y) * touchBoundary;
  },
  _resetActiveElement: function() {
    if ("ios" === devices_default.real().platform && this.getElement().find(":focus").length) {
      resetActiveElement();
    }
  },
  _toggleGestureCover: function(toggle) {
    this._toggleGestureCoverImpl(toggle);
  },
  _toggleGestureCoverImpl: function(toggle) {
    const isStarted = 2 === this._stage;
    if (isStarted) {
      gestureCover(toggle, this.getElement().css("cursor"));
    }
  },
  _clearSelection: function(e) {
    if (isDxMouseWheelEvent(e) || isTouchEvent(e)) {
      return;
    }
    clearSelection();
  },
  end: function(e) {
    this._toggleGestureCover(false);
    if (2 === this._stage) {
      this._end(e);
    } else if (1 === this._stage) {
      this._stop(e);
    }
    this._stage = 0;
  },
  dispose: function() {
    clearTimeout(this._immediateTimer);
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
  },
  _init: noop2,
  _start: noop2,
  _move: noop2,
  _stop: noop2,
  _end: noop2
});
GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
GestureEmitter.touchBoundary = function(newBoundary) {
  if (isDefined(newBoundary)) {
    TOUCH_BOUNDARY = newBoundary;
    return;
  }
  return TOUCH_BOUNDARY;
};
var emitter_gesture_default = GestureEmitter;

// ../../../../../../node_modules/devextreme/esm/events/gesture/emitter.gesture.scroll.js
var abstract5 = class_default.abstract;
var realDevice = devices_default.real();
var Locker = class_default.inherit(function() {
  const NAMESPACED_SCROLL_EVENT = addNamespace2("scroll", "dxScrollEmitter");
  return {
    ctor: function(element) {
      this._element = element;
      this._locked = false;
      this._proxiedScroll = (e) => {
        if (!this._disposed) {
          this._scroll(e);
        }
      };
      events_engine_default.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    },
    _scroll: abstract5,
    check: function(e, callback) {
      if (this._locked) {
        callback();
      }
    },
    dispose: function() {
      this._disposed = true;
      events_engine_default.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    }
  };
}());
var TimeoutLocker = Locker.inherit({
  ctor: function(element, timeout) {
    this.callBase(element);
    this._timeout = timeout;
  },
  _scroll: function() {
    this._prepare();
    this._forget();
  },
  _prepare: function() {
    if (this._timer) {
      this._clearTimer();
    }
    this._locked = true;
  },
  _clearTimer: function() {
    clearTimeout(this._timer);
    this._locked = false;
    this._timer = null;
  },
  _forget: function() {
    const that = this;
    this._timer = setTimeout(function() {
      that._clearTimer();
    }, this._timeout);
  },
  dispose: function() {
    this.callBase();
    this._clearTimer();
  }
});
var WheelLocker = TimeoutLocker.inherit({
  ctor: function(element) {
    this.callBase(element, 400);
    this._lastWheelDirection = null;
  },
  check: function(e, callback) {
    this._checkDirectionChanged(e);
    this.callBase(e, callback);
  },
  _checkDirectionChanged: function(e) {
    if (!isDxMouseWheelEvent(e)) {
      this._lastWheelDirection = null;
      return;
    }
    const direction = e.shiftKey || false;
    const directionChange = null !== this._lastWheelDirection && direction !== this._lastWheelDirection;
    this._lastWheelDirection = direction;
    this._locked = this._locked && !directionChange;
  }
});
var PointerLocker = TimeoutLocker.inherit({
  ctor: function(element) {
    this.callBase(element, 400);
  }
});
!function() {
  const {
    ios: isIos,
    android: isAndroid
  } = realDevice;
  if (!(isIos || isAndroid)) {
    return;
  }
  PointerLocker = Locker.inherit({
    _scroll: function() {
      this._locked = true;
      const that = this;
      cancelAnimationFrame(this._scrollFrame);
      this._scrollFrame = requestAnimationFrame(function() {
        that._locked = false;
      });
    },
    check: function(e, callback) {
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
      const that = this;
      const callBase = this.callBase;
      this._checkFrame = requestAnimationFrame(function() {
        callBase.call(that, e, callback);
        that._locked = false;
      });
    },
    dispose: function() {
      this.callBase();
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
    }
  });
}();
var ScrollEmitter = emitter_gesture_default.inherit(function() {
  const FRAME_DURATION2 = Math.round(1e3 / 60);
  return {
    ctor: function(element) {
      this.callBase.apply(this, arguments);
      this.direction = "both";
      this._pointerLocker = new PointerLocker(element);
      this._wheelLocker = new WheelLocker(element);
    },
    validate: function() {
      return true;
    },
    configure: function(data2) {
      if (data2.scrollTarget) {
        this._pointerLocker.dispose();
        this._wheelLocker.dispose();
        this._pointerLocker = new PointerLocker(data2.scrollTarget);
        this._wheelLocker = new WheelLocker(data2.scrollTarget);
      }
      this.callBase(data2);
    },
    _init: function(e) {
      this._wheelLocker.check(e, (function() {
        if (isDxMouseWheelEvent(e)) {
          this._accept(e);
        }
      }).bind(this));
      this._pointerLocker.check(e, (function() {
        const skipCheck = this.isNative && isMouseEvent(e);
        if (!isDxMouseWheelEvent(e) && !skipCheck) {
          this._accept(e);
        }
      }).bind(this));
      this._fireEvent("dxscrollinit", e);
      this._prevEventData = eventData(e);
    },
    move: function(e) {
      this.callBase.apply(this, arguments);
      e.isScrollingEvent = this.isNative || e.isScrollingEvent;
    },
    _start: function(e) {
      this._savedEventData = eventData(e);
      this._fireEvent("dxscrollstart", e);
      this._prevEventData = eventData(e);
    },
    _move: function(e) {
      const currentEventData = eventData(e);
      this._fireEvent("dxscroll", e, {
        delta: eventDelta(this._prevEventData, currentEventData)
      });
      const delta = eventDelta(this._savedEventData, currentEventData);
      if (delta.time > 200) {
        this._savedEventData = this._prevEventData;
      }
      this._prevEventData = eventData(e);
    },
    _end: function(e) {
      const endEventDelta = eventDelta(this._prevEventData, eventData(e));
      let velocity = {
        x: 0,
        y: 0
      };
      if (!isDxMouseWheelEvent(e) && endEventDelta.time < 100) {
        const delta = eventDelta(this._savedEventData, this._prevEventData);
        const velocityMultiplier = FRAME_DURATION2 / delta.time;
        velocity = {
          x: delta.x * velocityMultiplier,
          y: delta.y * velocityMultiplier
        };
      }
      this._fireEvent("dxscrollend", e, {
        velocity
      });
    },
    _stop: function(e) {
      this._fireEvent("dxscrollstop", e);
    },
    cancel: function(e) {
      this.callBase.apply(this, arguments);
      this._fireEvent("dxscrollcancel", e);
    },
    dispose: function() {
      this.callBase.apply(this, arguments);
      this._pointerLocker.dispose();
      this._wheelLocker.dispose();
    },
    _clearSelection: function() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    },
    _toggleGestureCover: function() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    }
  };
}());
emitter_registrator_default({
  emitter: ScrollEmitter,
  events: ["dxscrollinit", "dxscrollstart", "dxscroll", "dxscrollend", "dxscrollstop", "dxscrollcancel"]
});
var emitter_gesture_scroll_default = {
  init: "dxscrollinit",
  start: "dxscrollstart",
  move: "dxscroll",
  end: "dxscrollend",
  stop: "dxscrollstop",
  cancel: "dxscrollcancel",
  scroll: "scroll"
};

// ../../../../../../node_modules/devextreme/esm/renovation/utils/subscribe_to_event.js
function subscribeToEvent(eventName) {
  return (element, handler, eventData2, namespace) => {
    const event = namespace ? addNamespace2(eventName, namespace) : eventName;
    if (handler) {
      events_engine_default.on(element, event, eventData2, handler);
      return () => {
        events_engine_default.off(element, event, handler);
      };
    }
    return;
  };
}
var subscribeToClickEvent = subscribeToEvent(CLICK_EVENT_NAME);
var subscribeToScrollEvent = subscribeToEvent(emitter_gesture_scroll_default.scroll);
var subscribeToScrollInitEvent = subscribeToEvent(emitter_gesture_scroll_default.init);
var subscribeToDXScrollStartEvent = subscribeToEvent(emitter_gesture_scroll_default.start);
var subscribeToDXScrollMoveEvent = subscribeToEvent(emitter_gesture_scroll_default.move);
var subscribeToDXScrollEndEvent = subscribeToEvent(emitter_gesture_scroll_default.end);
var subscribeToDXScrollStopEvent = subscribeToEvent(emitter_gesture_scroll_default.stop);
var subscribeToDXScrollCancelEvent = subscribeToEvent(emitter_gesture_scroll_default.cancel);
var subscribeToDXPointerDownEvent = subscribeToEvent(pointer_default.down);
var subscribeToDXPointerUpEvent = subscribeToEvent(pointer_default.up);
var subscribeToDXPointerMoveEvent = subscribeToEvent(pointer_default.move);
var subscribeToMouseEnterEvent = subscribeToEvent("mouseenter");
var subscribeToMouseLeaveEvent = subscribeToEvent("mouseleave");
var subscribeToKeyDownEvent = subscribeToEvent("keydown");
var subscribeToDxActiveEvent = subscribeToEvent("dxactive");
var subscribeToDxInactiveEvent = subscribeToEvent("dxinactive");
var subscribeToDxHoverStartEvent = subscribeToEvent("dxhoverstart");
var subscribeToDxHoverEndEvent = subscribeToEvent("dxhoverend");
var subscribeToDxFocusInEvent = subscribeToEvent("focusin");
var subscribeToDxFocusOutEvent = subscribeToEvent("focusout");

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/base_props.js
var BaseWidgetProps = {
  className: "",
  activeStateEnabled: false,
  disabled: false,
  focusStateEnabled: false,
  hoverStateEnabled: false,
  tabIndex: 0,
  visible: true
};

// ../../../../../../node_modules/devextreme/esm/renovation/common/config_context.js
var ConfigContext = createContext(void 0);

// ../../../../../../node_modules/devextreme/esm/renovation/common/config_provider.js
var _excluded6 = ["children", "rtlEnabled"];
var viewFunction3 = (viewModel) => viewModel.props.children;
var ConfigProviderProps = {};
var ConfigProvider = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.__getterCache = {};
  }
  getChildContext() {
    return _extends({}, this.context, {
      [ConfigContext.id]: this.config || ConfigContext.defaultValue
    });
  }
  get config() {
    if (void 0 !== this.__getterCache.config) {
      return this.__getterCache.config;
    }
    return this.__getterCache.config = (() => ({
      rtlEnabled: this.props.rtlEnabled
    }))();
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded6);
    return restProps;
  }
  componentWillUpdate(nextProps, nextState, context2) {
    if (this.props.rtlEnabled !== nextProps.rtlEnabled) {
      this.__getterCache.config = void 0;
    }
  }
  render() {
    const props = this.props;
    return viewFunction3({
      props: _extends({}, props),
      config: this.config,
      restAttributes: this.restAttributes
    });
  }
};
ConfigProvider.defaultProps = ConfigProviderProps;

// ../../../../../../node_modules/devextreme/esm/renovation/utils/resolve_rtl.js
function resolveRtlEnabled(rtlProp, config3) {
  if (void 0 !== rtlProp) {
    return rtlProp;
  }
  if (void 0 !== (null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled)) {
    return config3.rtlEnabled;
  }
  return config_default().rtlEnabled;
}
function resolveRtlEnabledDefinition(rtlProp, config3) {
  const isPropDefined = isDefined(rtlProp);
  const onlyGlobalDefined = isDefined(config_default().rtlEnabled) && !isPropDefined && !isDefined(null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled);
  return isPropDefined && rtlProp !== (null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled) || onlyGlobalDefined;
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/widget.js
var _excluded7 = ["_feedbackHideTimeout", "_feedbackShowTimeout", "accessKey", "activeStateEnabled", "activeStateUnit", "addWidgetClass", "aria", "children", "className", "classes", "cssText", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "name", "onActive", "onClick", "onDimensionChanged", "onFocusIn", "onFocusOut", "onHoverEnd", "onHoverStart", "onInactive", "onKeyDown", "onRootElementRendered", "onVisibilityChange", "rootElementRef", "rtlEnabled", "tabIndex", "visible", "width"];
var getAria = (args) => Object.keys(args).reduce((r, key) => {
  if (args[key]) {
    return _extends({}, r, {
      ["role" === key || "id" === key ? key : `aria-${key}`]: String(args[key])
    });
  }
  return r;
}, {});
var viewFunction4 = (viewModel) => {
  const widget = normalizeProps(createVNode(1, "div", viewModel.cssClasses, viewModel.props.children, 0, _extends({}, viewModel.attributes, {
    tabIndex: viewModel.tabIndex,
    title: viewModel.props.hint,
    style: normalizeStyles(viewModel.styles)
  }), null, viewModel.widgetElementRef));
  return viewModel.shouldRenderConfigProvider ? createComponentVNode(2, ConfigProvider, {
    rtlEnabled: viewModel.rtlEnabled,
    children: widget
  }) : widget;
};
var WidgetProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(BaseWidgetProps), Object.getOwnPropertyDescriptors({
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  cssText: "",
  aria: Object.freeze({}),
  classes: "",
  name: "",
  addWidgetClass: true
})));
var Widget2 = class extends InfernoWrapperComponent {
  get config() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  constructor(props) {
    super(props);
    this.widgetElementRef = createRef();
    this.state = {
      active: false,
      focused: false,
      hovered: false
    };
    this.setRootElementRef = this.setRootElementRef.bind(this);
    this.activeEffect = this.activeEffect.bind(this);
    this.inactiveEffect = this.inactiveEffect.bind(this);
    this.clickEffect = this.clickEffect.bind(this);
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.activate = this.activate.bind(this);
    this.deactivate = this.deactivate.bind(this);
    this.focusInEffect = this.focusInEffect.bind(this);
    this.focusOutEffect = this.focusOutEffect.bind(this);
    this.hoverStartEffect = this.hoverStartEffect.bind(this);
    this.hoverEndEffect = this.hoverEndEffect.bind(this);
    this.keyboardEffect = this.keyboardEffect.bind(this);
    this.resizeEffect = this.resizeEffect.bind(this);
    this.windowResizeEffect = this.windowResizeEffect.bind(this);
    this.visibilityEffect = this.visibilityEffect.bind(this);
    this.checkDeprecation = this.checkDeprecation.bind(this);
    this.applyCssTextEffect = this.applyCssTextEffect.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.setRootElementRef, []), new InfernoEffect(this.activeEffect, [this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]), new InfernoEffect(this.inactiveEffect, [this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]), new InfernoEffect(this.clickEffect, [this.props.disabled, this.props.name, this.props.onClick]), new InfernoEffect(this.focusInEffect, [this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]), new InfernoEffect(this.focusOutEffect, [this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]), new InfernoEffect(this.hoverStartEffect, [this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]), new InfernoEffect(this.hoverEndEffect, [this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]), new InfernoEffect(this.keyboardEffect, [this.props.focusStateEnabled, this.props.onKeyDown]), new InfernoEffect(this.resizeEffect, [this.props.name, this.props.onDimensionChanged]), new InfernoEffect(this.windowResizeEffect, [this.props.onDimensionChanged]), new InfernoEffect(this.visibilityEffect, [this.props.name, this.props.onVisibilityChange]), new InfernoEffect(this.checkDeprecation, [this.props.height, this.props.width]), new InfernoEffect(this.applyCssTextEffect, [this.props.cssText]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$, _this$_effects$2, _this$_effects$3, _this$_effects$4, _this$_effects$5, _this$_effects$6, _this$_effects$7, _this$_effects$8, _this$_effects$9, _this$_effects$10, _this$_effects$11, _this$_effects$12, _this$_effects$13;
    null === (_this$_effects$ = this._effects[1]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]);
    null === (_this$_effects$2 = this._effects[2]) || void 0 === _this$_effects$2 || _this$_effects$2.update([this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]);
    null === (_this$_effects$3 = this._effects[3]) || void 0 === _this$_effects$3 || _this$_effects$3.update([this.props.disabled, this.props.name, this.props.onClick]);
    null === (_this$_effects$4 = this._effects[4]) || void 0 === _this$_effects$4 || _this$_effects$4.update([this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]);
    null === (_this$_effects$5 = this._effects[5]) || void 0 === _this$_effects$5 || _this$_effects$5.update([this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]);
    null === (_this$_effects$6 = this._effects[6]) || void 0 === _this$_effects$6 || _this$_effects$6.update([this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]);
    null === (_this$_effects$7 = this._effects[7]) || void 0 === _this$_effects$7 || _this$_effects$7.update([this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]);
    null === (_this$_effects$8 = this._effects[8]) || void 0 === _this$_effects$8 || _this$_effects$8.update([this.props.focusStateEnabled, this.props.onKeyDown]);
    null === (_this$_effects$9 = this._effects[9]) || void 0 === _this$_effects$9 || _this$_effects$9.update([this.props.name, this.props.onDimensionChanged]);
    null === (_this$_effects$10 = this._effects[10]) || void 0 === _this$_effects$10 || _this$_effects$10.update([this.props.onDimensionChanged]);
    null === (_this$_effects$11 = this._effects[11]) || void 0 === _this$_effects$11 || _this$_effects$11.update([this.props.name, this.props.onVisibilityChange]);
    null === (_this$_effects$12 = this._effects[12]) || void 0 === _this$_effects$12 || _this$_effects$12.update([this.props.height, this.props.width]);
    null === (_this$_effects$13 = this._effects[13]) || void 0 === _this$_effects$13 || _this$_effects$13.update([this.props.cssText]);
  }
  setRootElementRef() {
    const {
      onRootElementRendered,
      rootElementRef
    } = this.props;
    if (rootElementRef) {
      rootElementRef.current = this.widgetElementRef.current;
    }
    null === onRootElementRendered || void 0 === onRootElementRendered || onRootElementRendered(this.widgetElementRef.current);
  }
  activeEffect() {
    const {
      _feedbackShowTimeout,
      activeStateEnabled,
      activeStateUnit,
      disabled,
      onActive
    } = this.props;
    const selector = activeStateUnit;
    if (activeStateEnabled) {
      if (!disabled) {
        return subscribeToDxActiveEvent(this.widgetElementRef.current, (event) => {
          this.setState((__state_argument) => ({
            active: true
          }));
          null === onActive || void 0 === onActive || onActive(event);
        }, {
          timeout: _feedbackShowTimeout,
          selector
        }, "UIFeedback");
      }
    }
    return;
  }
  inactiveEffect() {
    const {
      _feedbackHideTimeout,
      activeStateEnabled,
      activeStateUnit,
      onInactive
    } = this.props;
    const selector = activeStateUnit;
    if (activeStateEnabled) {
      return subscribeToDxInactiveEvent(this.widgetElementRef.current, (event) => {
        if (this.state.active) {
          this.setState((__state_argument) => ({
            active: false
          }));
          null === onInactive || void 0 === onInactive || onInactive(event);
        }
      }, {
        timeout: _feedbackHideTimeout,
        selector
      }, "UIFeedback");
    }
    return;
  }
  clickEffect() {
    const {
      disabled,
      name: name2,
      onClick
    } = this.props;
    const namespace = name2;
    if (onClick && !disabled) {
      dxClick.on(this.widgetElementRef.current, onClick, {
        namespace
      });
      return () => dxClick.off(this.widgetElementRef.current, {
        namespace
      });
    }
    return;
  }
  focusInEffect() {
    const {
      disabled,
      focusStateEnabled,
      name: name2,
      onFocusIn
    } = this.props;
    const namespace = `${name2}Focus`;
    if (focusStateEnabled) {
      if (!disabled) {
        return subscribeToDxFocusInEvent(this.widgetElementRef.current, (event) => {
          if (!event.isDefaultPrevented()) {
            this.setState((__state_argument) => ({
              focused: true
            }));
            null === onFocusIn || void 0 === onFocusIn || onFocusIn(event);
          }
        }, null, namespace);
      }
    }
    return;
  }
  focusOutEffect() {
    const {
      focusStateEnabled,
      name: name2,
      onFocusOut
    } = this.props;
    const namespace = `${name2}Focus`;
    if (focusStateEnabled) {
      return subscribeToDxFocusOutEvent(this.widgetElementRef.current, (event) => {
        if (!event.isDefaultPrevented() && this.state.focused) {
          this.setState((__state_argument) => ({
            focused: false
          }));
          null === onFocusOut || void 0 === onFocusOut || onFocusOut(event);
        }
      }, null, namespace);
    }
    return;
  }
  hoverStartEffect() {
    const {
      activeStateUnit,
      disabled,
      hoverStateEnabled,
      onHoverStart
    } = this.props;
    const selector = activeStateUnit;
    if (hoverStateEnabled) {
      if (!disabled) {
        return subscribeToDxHoverStartEvent(this.widgetElementRef.current, (event) => {
          !this.state.active && this.setState((__state_argument) => ({
            hovered: true
          }));
          null === onHoverStart || void 0 === onHoverStart || onHoverStart(event);
        }, {
          selector
        }, "UIFeedback");
      }
    }
    return;
  }
  hoverEndEffect() {
    const {
      activeStateUnit,
      hoverStateEnabled,
      onHoverEnd
    } = this.props;
    const selector = activeStateUnit;
    if (hoverStateEnabled) {
      return subscribeToDxHoverEndEvent(this.widgetElementRef.current, (event) => {
        if (this.state.hovered) {
          this.setState((__state_argument) => ({
            hovered: false
          }));
          null === onHoverEnd || void 0 === onHoverEnd || onHoverEnd(event);
        }
      }, {
        selector
      }, "UIFeedback");
    }
    return;
  }
  keyboardEffect() {
    const {
      focusStateEnabled,
      onKeyDown
    } = this.props;
    if (focusStateEnabled && onKeyDown) {
      const id = keyboard.on(this.widgetElementRef.current, this.widgetElementRef.current, (e) => onKeyDown(e));
      return () => keyboard.off(id);
    }
    return;
  }
  resizeEffect() {
    const namespace = `${this.props.name}VisibilityChange`;
    const {
      onDimensionChanged
    } = this.props;
    if (onDimensionChanged) {
      resize.on(this.widgetElementRef.current, onDimensionChanged, {
        namespace
      });
      return () => resize.off(this.widgetElementRef.current, {
        namespace
      });
    }
    return;
  }
  windowResizeEffect() {
    const {
      onDimensionChanged
    } = this.props;
    if (onDimensionChanged) {
      resize_callbacks_default.add(onDimensionChanged);
      return () => {
        resize_callbacks_default.remove(onDimensionChanged);
      };
    }
    return;
  }
  visibilityEffect() {
    const {
      name: name2,
      onVisibilityChange
    } = this.props;
    const namespace = `${name2}VisibilityChange`;
    if (onVisibilityChange) {
      visibility.on(this.widgetElementRef.current, () => onVisibilityChange(true), () => onVisibilityChange(false), {
        namespace
      });
      return () => visibility.off(this.widgetElementRef.current, {
        namespace
      });
    }
    return;
  }
  checkDeprecation() {
    const {
      height,
      width
    } = this.props;
    if (isFunction(width)) {
      errors_default.log("W0017", "width");
    }
    if (isFunction(height)) {
      errors_default.log("W0017", "height");
    }
  }
  applyCssTextEffect() {
    const {
      cssText
    } = this.props;
    if ("" !== cssText) {
      this.widgetElementRef.current.style.cssText = cssText;
    }
  }
  get shouldRenderConfigProvider() {
    const {
      rtlEnabled
    } = this.props;
    return resolveRtlEnabledDefinition(rtlEnabled, this.config);
  }
  get rtlEnabled() {
    const {
      rtlEnabled
    } = this.props;
    return resolveRtlEnabled(rtlEnabled, this.config);
  }
  get attributes() {
    const {
      aria,
      disabled,
      focusStateEnabled,
      visible: visible2
    } = this.props;
    const accessKey = focusStateEnabled && !disabled && this.props.accessKey;
    return _extends({}, extend({}, accessKey && {
      accessKey
    }), getAria(_extends({}, aria, {
      disabled,
      hidden: !visible2
    })), extend({}, this.restAttributes));
  }
  get styles() {
    const {
      height,
      width
    } = this.props;
    const style = this.restAttributes.style || {};
    const computedWidth = normalizeStyleProp("width", isFunction(width) ? width() : width);
    const computedHeight = normalizeStyleProp("height", isFunction(height) ? height() : height);
    return _extends({}, style, {
      height: computedHeight ?? style.height,
      width: computedWidth ?? style.width
    });
  }
  get cssClasses() {
    const {
      activeStateEnabled,
      addWidgetClass,
      className,
      classes,
      disabled,
      focusStateEnabled,
      hoverStateEnabled,
      onVisibilityChange,
      visible: visible2
    } = this.props;
    const isFocusable = !!focusStateEnabled && !disabled;
    const isHoverable = !!hoverStateEnabled && !disabled;
    const canBeActive = !!activeStateEnabled && !disabled;
    const classesMap = {
      "dx-widget": !!addWidgetClass,
      [String(classes)]: !!classes,
      [String(className)]: !!className,
      "dx-state-disabled": !!disabled,
      "dx-state-invisible": !visible2,
      "dx-state-focused": !!this.state.focused && isFocusable,
      "dx-state-active": !!this.state.active && canBeActive,
      "dx-state-hover": !!this.state.hovered && isHoverable && !this.state.active,
      "dx-rtl": !!this.rtlEnabled,
      "dx-visibility-change-handler": !!onVisibilityChange
    };
    return combineClasses(classesMap);
  }
  get tabIndex() {
    const {
      disabled,
      focusStateEnabled,
      tabIndex
    } = this.props;
    const isFocusable = focusStateEnabled && !disabled;
    return isFocusable ? tabIndex : void 0;
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded7);
    return restProps;
  }
  focus() {
    focus.trigger(this.widgetElementRef.current);
  }
  blur() {
    const activeElement = dom_adapter_default.getActiveElement(this.widgetElementRef.current);
    if (this.widgetElementRef.current === activeElement) {
      activeElement.blur();
    }
  }
  activate() {
    this.setState((__state_argument) => ({
      active: true
    }));
  }
  deactivate() {
    this.setState((__state_argument) => ({
      active: false
    }));
  }
  render() {
    const props = this.props;
    return viewFunction4({
      props: _extends({}, props),
      active: this.state.active,
      focused: this.state.focused,
      hovered: this.state.hovered,
      widgetElementRef: this.widgetElementRef,
      config: this.config,
      shouldRenderConfigProvider: this.shouldRenderConfigProvider,
      rtlEnabled: this.rtlEnabled,
      attributes: this.attributes,
      styles: this.styles,
      cssClasses: this.cssClasses,
      tabIndex: this.tabIndex,
      restAttributes: this.restAttributes
    });
  }
};
Widget2.defaultProps = WidgetProps;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/button.js
var _excluded8 = ["accessKey", "activeStateEnabled", "children", "className", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "icon", "iconPosition", "iconTemplate", "onClick", "onKeyDown", "onSubmit", "pressed", "rtlEnabled", "stylingMode", "tabIndex", "template", "templateData", "text", "type", "useInkRipple", "useSubmitBehavior", "visible", "width"];
var stylingModes = ["outlined", "text", "contained"];
var getCssClasses2 = (model) => {
  const {
    icon,
    iconPosition,
    stylingMode,
    text,
    type: type2
  } = model;
  const isValidStylingMode = stylingMode && stylingModes.includes(stylingMode);
  const classesMap = {
    "dx-button": true,
    [`dx-button-mode-${isValidStylingMode ? stylingMode : "contained"}`]: true,
    [`dx-button-${type2 ?? "normal"}`]: true,
    "dx-button-has-text": !!text,
    "dx-button-has-icon": !!icon,
    "dx-button-icon-right": "left" !== iconPosition
  };
  return combineClasses(classesMap);
};
var viewFunction5 = (viewModel) => {
  const {
    children,
    iconPosition,
    iconTemplate: IconTemplate,
    template: ButtonTemplate,
    text
  } = viewModel.props;
  const renderText = !viewModel.props.template && !children && "" !== text;
  const isIconLeft = "left" === iconPosition;
  const iconComponent = !viewModel.props.template && !children && (viewModel.iconSource || viewModel.props.iconTemplate) && createComponentVNode(2, Icon, {
    source: viewModel.iconSource,
    position: iconPosition,
    iconTemplate: IconTemplate
  });
  return normalizeProps(createComponentVNode(2, Widget2, _extends({
    accessKey: viewModel.props.accessKey,
    activeStateEnabled: viewModel.props.activeStateEnabled,
    aria: viewModel.aria,
    className: viewModel.props.className,
    classes: viewModel.cssClasses,
    disabled: viewModel.props.disabled,
    focusStateEnabled: viewModel.props.focusStateEnabled,
    height: viewModel.props.height,
    hint: viewModel.props.hint,
    hoverStateEnabled: viewModel.props.hoverStateEnabled,
    onActive: viewModel.onActive,
    onClick: viewModel.onWidgetClick,
    onInactive: viewModel.onInactive,
    onKeyDown: viewModel.keyDown,
    rtlEnabled: viewModel.props.rtlEnabled,
    tabIndex: viewModel.props.tabIndex,
    visible: viewModel.props.visible,
    width: viewModel.props.width
  }, viewModel.restAttributes, {
    children: createVNode(1, "div", "dx-button-content", [viewModel.props.template && ButtonTemplate({
      data: viewModel.buttonTemplateData
    }), !viewModel.props.template && children, isIconLeft && iconComponent, renderText && createVNode(1, "span", "dx-button-text", text, 0), !isIconLeft && iconComponent, viewModel.props.useSubmitBehavior && createVNode(64, "input", "dx-button-submit-input", null, 1, {
      type: "submit",
      tabIndex: -1
    }, null, viewModel.submitInputRef), viewModel.props.useInkRipple && createComponentVNode(2, InkRipple, {
      config: viewModel.inkRippleConfig
    }, null, viewModel.inkRippleRef)], 0, null, null, viewModel.contentRef)
  }), null, viewModel.widgetRef));
};
var ButtonProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(BaseWidgetProps), Object.getOwnPropertyDescriptors({
  activeStateEnabled: true,
  hoverStateEnabled: true,
  icon: "",
  iconPosition: "left",
  stylingMode: "contained",
  text: "",
  type: "normal",
  useInkRipple: false,
  useSubmitBehavior: false,
  templateData: Object.freeze({})
})));
var defaultOptionRules = createDefaultOptionRules([{
  device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
  options: {
    focusStateEnabled: true
  }
}, {
  device: () => isMaterial(current()),
  options: {
    useInkRipple: true
  }
}]);
var getTemplate2 = (TemplateProp) => TemplateProp && (TemplateProp.defaultProps ? (props) => normalizeProps(createComponentVNode(2, TemplateProp, _extends({}, props))) : TemplateProp);
var Button = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.contentRef = createRef();
    this.inkRippleRef = createRef();
    this.submitInputRef = createRef();
    this.widgetRef = createRef();
    this.__getterCache = {};
    this.focus = this.focus.bind(this);
    this.activate = this.activate.bind(this);
    this.deactivate = this.deactivate.bind(this);
    this.submitEffect = this.submitEffect.bind(this);
    this.onActive = this.onActive.bind(this);
    this.onInactive = this.onInactive.bind(this);
    this.onWidgetClick = this.onWidgetClick.bind(this);
    this.keyDown = this.keyDown.bind(this);
    this.emitClickEvent = this.emitClickEvent.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.submitEffect, [this.props.onSubmit, this.props.useSubmitBehavior]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props.onSubmit, this.props.useSubmitBehavior]);
  }
  submitEffect() {
    const {
      onSubmit,
      useSubmitBehavior
    } = this.props;
    if (useSubmitBehavior && onSubmit) {
      click.on(this.submitInputRef.current, (event) => onSubmit({
        event,
        submitInput: this.submitInputRef.current
      }), {
        namespace: "UIFeedback"
      });
      return () => click.off(this.submitInputRef.current, {
        namespace: "UIFeedback"
      });
    }
    return;
  }
  onActive(event) {
    const {
      useInkRipple
    } = this.props;
    useInkRipple && this.inkRippleRef.current.showWave({
      element: this.contentRef.current,
      event
    });
  }
  onInactive(event) {
    const {
      useInkRipple
    } = this.props;
    useInkRipple && this.inkRippleRef.current.hideWave({
      element: this.contentRef.current,
      event
    });
  }
  onWidgetClick(event) {
    const {
      onClick,
      useSubmitBehavior
    } = this.props;
    null === onClick || void 0 === onClick || onClick({
      event
    });
    useSubmitBehavior && this.submitInputRef.current.click();
  }
  keyDown(e) {
    const {
      onKeyDown
    } = this.props;
    const {
      keyName,
      originalEvent,
      which
    } = e;
    const result2 = null === onKeyDown || void 0 === onKeyDown ? void 0 : onKeyDown(e);
    if (null !== result2 && void 0 !== result2 && result2.cancel) {
      return result2;
    }
    if ("space" === keyName || "space" === which || "enter" === keyName || "enter" === which) {
      originalEvent.preventDefault();
      this.emitClickEvent();
    }
    return;
  }
  emitClickEvent() {
    this.contentRef.current.click();
  }
  get aria() {
    const {
      icon,
      text
    } = this.props;
    let label = text ?? "";
    if (!text && icon) {
      const iconSource = getImageSourceType(icon);
      switch (iconSource) {
        case "image": {
          const notURLRegexp = /^(?!(?:https?:\/\/)|(?:ftp:\/\/)|(?:www\.))[^\s]+$/;
          const isPathToImage = !icon.includes("base64") && notURLRegexp.test(icon);
          label = isPathToImage ? icon.replace(/.+\/([^.]+)\..+$/, "$1") : "";
          break;
        }
        case "dxIcon":
          label = message_default.format(camelize(icon, true)) || icon;
          break;
        case "fontIcon":
          label = icon;
          break;
        case "svg": {
          var _titleRegexp$exec;
          const titleRegexp = /<title>(.*?)<\/title>/;
          const title = (null === (_titleRegexp$exec = titleRegexp.exec(icon)) || void 0 === _titleRegexp$exec ? void 0 : _titleRegexp$exec[1]) ?? "";
          label = title;
          break;
        }
      }
    }
    return _extends({
      role: "button"
    }, label ? {
      label
    } : {});
  }
  get cssClasses() {
    return getCssClasses2(this.props);
  }
  get iconSource() {
    const {
      icon
    } = this.props;
    return icon ?? "";
  }
  get inkRippleConfig() {
    if (void 0 !== this.__getterCache.inkRippleConfig) {
      return this.__getterCache.inkRippleConfig;
    }
    return this.__getterCache.inkRippleConfig = (() => {
      const {
        icon,
        text
      } = this.props;
      return !text && icon ? {
        isCentered: true,
        useHoldAnimation: false,
        waveSizeCoefficient: 1
      } : {};
    })();
  }
  get buttonTemplateData() {
    const {
      icon,
      templateData,
      text
    } = this.props;
    return _extends({
      icon,
      text
    }, templateData);
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded8);
    return restProps;
  }
  focus() {
    this.widgetRef.current.focus();
  }
  activate() {
    this.widgetRef.current.activate();
  }
  deactivate() {
    this.widgetRef.current.deactivate();
  }
  componentWillUpdate(nextProps, nextState, context2) {
    super.componentWillUpdate();
    if (this.props.icon !== nextProps.icon || this.props.text !== nextProps.text) {
      this.__getterCache.inkRippleConfig = void 0;
    }
  }
  render() {
    const props = this.props;
    return viewFunction5({
      props: _extends({}, props, {
        template: getTemplate2(props.template),
        iconTemplate: getTemplate2(props.iconTemplate)
      }),
      contentRef: this.contentRef,
      submitInputRef: this.submitInputRef,
      inkRippleRef: this.inkRippleRef,
      widgetRef: this.widgetRef,
      onActive: this.onActive,
      onInactive: this.onInactive,
      onWidgetClick: this.onWidgetClick,
      keyDown: this.keyDown,
      emitClickEvent: this.emitClickEvent,
      aria: this.aria,
      cssClasses: this.cssClasses,
      iconSource: this.iconSource,
      inkRippleConfig: this.inkRippleConfig,
      buttonTemplateData: this.buttonTemplateData,
      restAttributes: this.restAttributes
    });
  }
};
Button.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(ButtonProps), Object.getOwnPropertyDescriptors(_extends({}, convertRulesToOptions(defaultOptionRules)))));
var __defaultOptionRules = [];
function defaultOptions(rule) {
  __defaultOptionRules.push(rule);
  Button.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(Button.defaultProps), Object.getOwnPropertyDescriptors(convertRulesToOptions(defaultOptionRules)), Object.getOwnPropertyDescriptors(convertRulesToOptions(__defaultOptionRules))));
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/button.j.js
var Button2 = class extends ButtonWrapper {
  getProps() {
    const props = super.getProps();
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    return props;
  }
  focus() {
    var _this$viewRef;
    return null === (_this$viewRef = this.viewRef) || void 0 === _this$viewRef ? void 0 : _this$viewRef.focus(...arguments);
  }
  activate() {
    var _this$viewRef2;
    return null === (_this$viewRef2 = this.viewRef) || void 0 === _this$viewRef2 ? void 0 : _this$viewRef2.activate(...arguments);
  }
  deactivate() {
    var _this$viewRef3;
    return null === (_this$viewRef3 = this.viewRef) || void 0 === _this$viewRef3 ? void 0 : _this$viewRef3.deactivate(...arguments);
  }
  _getActionConfigs() {
    return {
      onClick: {
        excludeValidators: ["readOnly"]
      },
      onSubmit: {}
    };
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: ["onSubmit"],
      templates: ["template", "iconTemplate"],
      props: ["activeStateEnabled", "hoverStateEnabled", "icon", "iconPosition", "onClick", "onSubmit", "pressed", "stylingMode", "template", "iconTemplate", "text", "type", "useInkRipple", "useSubmitBehavior", "templateData", "className", "accessKey", "disabled", "focusStateEnabled", "height", "hint", "onKeyDown", "rtlEnabled", "tabIndex", "visible", "width"]
    };
  }
  get _viewComponent() {
    return Button;
  }
};
component_registrator_default("dxButton", Button2);
Button2.defaultOptions = defaultOptions;

// ../../../../../../node_modules/devextreme/esm/ui/button.js
var button_default = Button2;

// ../../../../../../node_modules/devextreme/esm/events/drag.js
var DRAG_START_EVENT = "dxdragstart";
var DRAG_EVENT = "dxdrag";
var DRAG_END_EVENT = "dxdragend";
var DRAG_ENTER_EVENT = "dxdragenter";
var DRAG_LEAVE_EVENT = "dxdragleave";
var DROP_EVENT = "dxdrop";
var knownDropTargets = [];
var knownDropTargetSelectors = [];
var knownDropTargetConfigs = [];
var dropTargetRegistration = {
  setup: function(element, data2) {
    const knownDropTarget = knownDropTargets.includes(element);
    if (!knownDropTarget) {
      knownDropTargets.push(element);
      knownDropTargetSelectors.push([]);
      knownDropTargetConfigs.push(data2 || {});
    }
  },
  add: function(element, handleObj) {
    const index2 = knownDropTargets.indexOf(element);
    this.updateEventsCounter(element, handleObj.type, 1);
    const selector = handleObj.selector;
    if (!knownDropTargetSelectors[index2].includes(selector)) {
      knownDropTargetSelectors[index2].push(selector);
    }
  },
  updateEventsCounter: function(element, event, value2) {
    if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].indexOf(event) > -1) {
      const eventsCount = data(element, "dxDragEventsCount") || 0;
      data(element, "dxDragEventsCount", Math.max(0, eventsCount + value2));
    }
  },
  remove: function(element, handleObj) {
    this.updateEventsCounter(element, handleObj.type, -1);
  },
  teardown: function(element) {
    const handlersCount = data(element, "dxDragEventsCount");
    if (!handlersCount) {
      const index2 = knownDropTargets.indexOf(element);
      knownDropTargets.splice(index2, 1);
      knownDropTargetSelectors.splice(index2, 1);
      knownDropTargetConfigs.splice(index2, 1);
      removeData(element, "dxDragEventsCount");
    }
  }
};
event_registrator_default(DRAG_ENTER_EVENT, dropTargetRegistration);
event_registrator_default(DRAG_LEAVE_EVENT, dropTargetRegistration);
event_registrator_default(DROP_EVENT, dropTargetRegistration);
var getItemDelegatedTargets = function($element) {
  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  const dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter((selector) => selector);
  let $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
  if (knownDropTargetSelectors[dropTargetIndex].includes(void 0)) {
    $delegatedTargets = $delegatedTargets.add($element);
  }
  return $delegatedTargets;
};
var getItemConfig = function($element) {
  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  return knownDropTargetConfigs[dropTargetIndex];
};
var getItemPosition = function(dropTargetConfig, $element) {
  if (dropTargetConfig.itemPositionFunc) {
    return dropTargetConfig.itemPositionFunc($element);
  } else {
    return $element.offset();
  }
};
var getItemSize = function(dropTargetConfig, $element) {
  if (dropTargetConfig.itemSizeFunc) {
    return dropTargetConfig.itemSizeFunc($element);
  }
  return {
    width: $element.get(0).getBoundingClientRect().width,
    height: $element.get(0).getBoundingClientRect().height
  };
};
var DragEmitter = emitter_gesture_default.inherit({
  ctor: function(element) {
    this.callBase(element);
    this.direction = "both";
  },
  _init: function(e) {
    this._initEvent = e;
  },
  _start: function(e) {
    e = this._fireEvent("dxdragstart", this._initEvent);
    this._maxLeftOffset = e.maxLeftOffset;
    this._maxRightOffset = e.maxRightOffset;
    this._maxTopOffset = e.maxTopOffset;
    this._maxBottomOffset = e.maxBottomOffset;
    if (e.targetElements || null === e.targetElements) {
      const dropTargets = wrapToArray(e.targetElements || []);
      this._dropTargets = map(dropTargets, function(element) {
        return renderer_default(element).get(0);
      });
    } else {
      this._dropTargets = knownDropTargets;
    }
  },
  _move: function(e) {
    const eventData2 = eventData(e);
    const dragOffset = this._calculateOffset(eventData2);
    e = this._fireEvent("dxdrag", e, {
      offset: dragOffset
    });
    this._processDropTargets(e);
    if (!e._cancelPreventDefault) {
      e.preventDefault();
    }
  },
  _calculateOffset: function(eventData2) {
    return {
      x: this._calculateXOffset(eventData2),
      y: this._calculateYOffset(eventData2)
    };
  },
  _calculateXOffset: function(eventData2) {
    if ("vertical" !== this.direction) {
      const offset2 = eventData2.x - this._startEventData.x;
      return this._fitOffset(offset2, this._maxLeftOffset, this._maxRightOffset);
    }
    return 0;
  },
  _calculateYOffset: function(eventData2) {
    if ("horizontal" !== this.direction) {
      const offset2 = eventData2.y - this._startEventData.y;
      return this._fitOffset(offset2, this._maxTopOffset, this._maxBottomOffset);
    }
    return 0;
  },
  _fitOffset: function(offset2, minOffset, maxOffset) {
    if (null != minOffset) {
      offset2 = Math.max(offset2, -minOffset);
    }
    if (null != maxOffset) {
      offset2 = Math.min(offset2, maxOffset);
    }
    return offset2;
  },
  _processDropTargets: function(e) {
    const target = this._findDropTarget(e);
    const sameTarget = target === this._currentDropTarget;
    if (!sameTarget) {
      this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
      this._currentDropTarget = target;
      this._fireDropTargetEvent(e, DRAG_ENTER_EVENT);
    }
  },
  _fireDropTargetEvent: function(event, eventName) {
    if (!this._currentDropTarget) {
      return;
    }
    const eventData2 = {
      type: eventName,
      originalEvent: event,
      draggingElement: this._$element.get(0),
      target: this._currentDropTarget
    };
    fireEvent(eventData2);
  },
  _findDropTarget: function(e) {
    const that = this;
    let result2;
    each(knownDropTargets, function(_, target) {
      if (!that._checkDropTargetActive(target)) {
        return;
      }
      const $target = renderer_default(target);
      each(getItemDelegatedTargets($target), function(_2, delegatedTarget) {
        const $delegatedTarget = renderer_default(delegatedTarget);
        if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, renderer_default(result2), e)) {
          result2 = delegatedTarget;
        }
      });
    });
    return result2;
  },
  _checkDropTargetActive: function(target) {
    let active2 = false;
    each(this._dropTargets, function(_, activeTarget) {
      active2 = active2 || activeTarget === target || contains2(activeTarget, target);
      return !active2;
    });
    return active2;
  },
  _checkDropTarget: function(config3, $target, $prevTarget, e) {
    const isDraggingElement = $target.get(0) === renderer_default(e.target).get(0);
    if (isDraggingElement) {
      return false;
    }
    const targetPosition = getItemPosition(config3, $target);
    if (e.pageX < targetPosition.left) {
      return false;
    }
    if (e.pageY < targetPosition.top) {
      return false;
    }
    const targetSize = getItemSize(config3, $target);
    if (e.pageX > targetPosition.left + targetSize.width) {
      return false;
    }
    if (e.pageY > targetPosition.top + targetSize.height) {
      return false;
    }
    if ($prevTarget.length && $prevTarget.closest($target).length) {
      return false;
    }
    if (config3.checkDropTarget && !config3.checkDropTarget($target, e)) {
      return false;
    }
    return $target;
  },
  _end: function(e) {
    const eventData2 = eventData(e);
    this._fireEvent("dxdragend", e, {
      offset: this._calculateOffset(eventData2)
    });
    this._fireDropTargetEvent(e, DROP_EVENT);
    delete this._currentDropTarget;
  }
});
emitter_registrator_default({
  emitter: DragEmitter,
  events: ["dxdragstart", "dxdrag", "dxdragend"]
});

// ../../../../../../node_modules/devextreme/esm/mobile/hide_callback.js
var hideCallback = function() {
  let callbacks2 = [];
  return {
    add: function(callback) {
      if (!callbacks2.includes(callback)) {
        callbacks2.push(callback);
      }
    },
    remove: function(callback) {
      const indexOfCallback = callbacks2.indexOf(callback);
      if (-1 !== indexOfCallback) {
        callbacks2.splice(indexOfCallback, 1);
      }
    },
    fire: function() {
      const callback = callbacks2.pop();
      const result2 = !!callback;
      if (result2) {
        callback();
      }
      return result2;
    },
    hasCallback: function() {
      return callbacks2.length > 0;
    }
  };
}();

// ../../../../../../node_modules/devextreme/esm/ui/widget/swatch_container.js
var getSwatchContainer = (element) => {
  const $element = renderer_default(element);
  const swatchContainer = $element.closest('[class^="dx-swatch-"], [class*=" dx-swatch-"]');
  const viewport = value();
  if (!swatchContainer.length) {
    return viewport;
  }
  const swatchClassRegex = new RegExp("(\\s|^)(dx-swatch-.*?)(\\s|$)");
  const swatchClass = swatchContainer[0].className.match(swatchClassRegex)[2];
  let viewportSwatchContainer = viewport.children("." + swatchClass);
  if (!viewportSwatchContainer.length) {
    viewportSwatchContainer = renderer_default("<div>").addClass(swatchClass).appendTo(viewport);
  }
  return viewportSwatchContainer;
};
var swatch_container_default = {
  getSwatchContainer
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/overlay/m_overlay_position_controller.js
var window16 = getWindow();
var OVERLAY_POSITION_ALIASES = {
  top: {
    my: "top center",
    at: "top center"
  },
  bottom: {
    my: "bottom center",
    at: "bottom center"
  },
  right: {
    my: "right center",
    at: "right center"
  },
  left: {
    my: "left center",
    at: "left center"
  },
  center: {
    my: "center",
    at: "center"
  },
  "right bottom": {
    my: "right bottom",
    at: "right bottom"
  },
  "right top": {
    my: "right top",
    at: "right top"
  },
  "left bottom": {
    my: "left bottom",
    at: "left bottom"
  },
  "left top": {
    my: "left top",
    at: "left top"
  }
};
var OVERLAY_DEFAULT_BOUNDARY_OFFSET = {
  h: 0,
  v: 0
};
var OverlayPositionController = class {
  constructor(_ref) {
    let {
      position: position3,
      container,
      visualContainer,
      $root,
      $content,
      $wrapper,
      onPositioned,
      onVisualPositionChanged,
      restorePosition,
      _fixWrapperPosition,
      _skipContentPositioning
    } = _ref;
    this._props = {
      position: position3,
      container,
      visualContainer,
      restorePosition,
      onPositioned,
      onVisualPositionChanged,
      _fixWrapperPosition,
      _skipContentPositioning
    };
    this._$root = $root;
    this._$content = $content;
    this._$wrapper = $wrapper;
    this._$markupContainer = void 0;
    this._$visualContainer = void 0;
    this._shouldRenderContentInitialPosition = true;
    this._visualPosition = void 0;
    this._initialPosition = void 0;
    this._previousVisualPosition = void 0;
    this.updateContainer(container);
    this.updatePosition(position3);
    this.updateVisualContainer(visualContainer);
  }
  get $container() {
    this.updateContainer();
    return this._$markupContainer;
  }
  get $visualContainer() {
    return this._$visualContainer;
  }
  get position() {
    return this._position;
  }
  set fixWrapperPosition(fixWrapperPosition) {
    this._props._fixWrapperPosition = fixWrapperPosition;
    this.styleWrapperPosition();
  }
  set restorePosition(restorePosition) {
    this._props.restorePosition = restorePosition;
  }
  restorePositionOnNextRender(value2) {
    this._shouldRenderContentInitialPosition = value2 || !this._visualPosition;
  }
  openingHandled() {
    const shouldRestorePosition = this._props.restorePosition;
    this.restorePositionOnNextRender(shouldRestorePosition);
  }
  updatePosition(positionProp) {
    this._props.position = positionProp;
    this._position = this._normalizePosition(positionProp);
    this.updateVisualContainer();
  }
  updateContainer() {
    let containerProp = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._props.container;
    this._props.container = containerProp;
    this._$markupContainer = containerProp ? renderer_default(containerProp) : swatch_container_default.getSwatchContainer(this._$root);
    this.updateVisualContainer(this._props.visualContainer);
  }
  updateVisualContainer() {
    let visualContainer = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._props.visualContainer;
    this._props.visualContainer = visualContainer;
    this._$visualContainer = this._getVisualContainer();
  }
  detectVisualPositionChange(event) {
    this._updateVisualPositionValue();
    this._raisePositionedEvents(event);
  }
  positionContent() {
    if (this._shouldRenderContentInitialPosition) {
      this._renderContentInitialPosition();
    } else {
      move(this._$content, this._visualPosition);
      this.detectVisualPositionChange();
    }
  }
  positionWrapper() {
    if (this._$visualContainer) {
      position_default.setup(this._$wrapper, {
        my: "top left",
        at: "top left",
        of: this._$visualContainer
      });
    }
  }
  styleWrapperPosition() {
    const useFixed = isWindow(this.$visualContainer.get(0)) || this._props._fixWrapperPosition;
    const positionStyle = useFixed ? "fixed" : "absolute";
    this._$wrapper.css("position", positionStyle);
  }
  _updateVisualPositionValue() {
    this._previousVisualPosition = this._visualPosition;
    this._visualPosition = locate(this._$content);
  }
  _renderContentInitialPosition() {
    this._renderBoundaryOffset();
    resetPosition(this._$content);
    const wrapperOverflow = this._$wrapper.css("overflow");
    this._$wrapper.css("overflow", "hidden");
    if (!this._props._skipContentPositioning) {
      const resultPosition = position_default.setup(this._$content, this._position);
      this._initialPosition = resultPosition;
    }
    this._$wrapper.css("overflow", wrapperOverflow);
    this.detectVisualPositionChange();
  }
  _raisePositionedEvents(event) {
    const previousPosition = this._previousVisualPosition;
    const newPosition = this._visualPosition;
    const isVisualPositionChanged = (null === previousPosition || void 0 === previousPosition ? void 0 : previousPosition.top) !== newPosition.top || (null === previousPosition || void 0 === previousPosition ? void 0 : previousPosition.left) !== newPosition.left;
    if (isVisualPositionChanged) {
      this._props.onVisualPositionChanged({
        previousPosition,
        position: newPosition,
        event
      });
    }
    this._props.onPositioned({
      position: this._initialPosition
    });
  }
  _renderBoundaryOffset() {
    const boundaryOffset = this._position ?? {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    this._$content.css("margin", `${boundaryOffset.v}px ${boundaryOffset.h}px`);
  }
  _getVisualContainer() {
    var _this$_props$position, _this$_props$position2;
    const containerProp = this._props.container;
    const visualContainerProp = this._props.visualContainer;
    const positionOf = isEvent(null === (_this$_props$position = this._props.position) || void 0 === _this$_props$position ? void 0 : _this$_props$position.of) ? this._props.position.of.target : null === (_this$_props$position2 = this._props.position) || void 0 === _this$_props$position2 ? void 0 : _this$_props$position2.of;
    if (visualContainerProp) {
      return renderer_default(visualContainerProp);
    }
    if (containerProp) {
      return renderer_default(containerProp);
    }
    if (positionOf) {
      return renderer_default(positionOf);
    }
    return renderer_default(window16);
  }
  _normalizePosition(positionProp) {
    const defaultPositionConfig = {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    if (isDefined(positionProp)) {
      return extend(true, {}, defaultPositionConfig, this._positionToObject(positionProp));
    }
    return defaultPositionConfig;
  }
  _positionToObject(position3) {
    if (isString(position3)) {
      return extend({}, OVERLAY_POSITION_ALIASES[position3]);
    }
    return position3;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/overlay/m_z_index.js
var baseZIndex = 1500;
var zIndexStack = [];
var base = (ZIndex) => {
  baseZIndex = ensureDefined(ZIndex, baseZIndex);
  return baseZIndex;
};
var create = function() {
  let baseIndex = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : baseZIndex;
  const {
    length
  } = zIndexStack;
  const index2 = (length ? zIndexStack[length - 1] : baseIndex) + 1;
  zIndexStack.push(index2);
  return index2;
};
var remove4 = (zIndex) => {
  const position3 = zIndexStack.indexOf(zIndex);
  if (position3 >= 0) {
    zIndexStack.splice(position3, 1);
  }
};
var isLastZIndexInStack = (zIndex) => zIndexStack.length && zIndexStack[zIndexStack.length - 1] === zIndex;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/overlay/m_overlay.js
var ready5 = ready_callbacks_default.add;
var window17 = getWindow();
var viewPortChanged2 = changeCallback;
var OVERLAY_STACK = [];
ready5(() => {
  events_engine_default.subscribeGlobal(dom_adapter_default.getDocument(), pointer_default.down, (e) => {
    for (let i = OVERLAY_STACK.length - 1; i >= 0; i--) {
      if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
        return;
      }
    }
  });
});
var Overlay = ui_widget_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), {
      escape() {
        this.hide();
      }
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      activeStateEnabled: false,
      visible: false,
      deferRendering: true,
      shading: true,
      shadingColor: "",
      wrapperAttr: {},
      position: extend({}, OVERLAY_POSITION_ALIASES.center),
      width: "80vw",
      minWidth: null,
      maxWidth: null,
      height: "80vh",
      minHeight: null,
      maxHeight: null,
      animation: {
        show: {
          type: "pop",
          duration: 300,
          from: {
            scale: 0.55
          }
        },
        hide: {
          type: "pop",
          duration: 300,
          from: {
            opacity: 1,
            scale: 1
          },
          to: {
            opacity: 0,
            scale: 0.55
          }
        }
      },
      closeOnOutsideClick: false,
      hideOnOutsideClick: false,
      _ignorePreventScrollEventsDeprecation: false,
      onShowing: null,
      onShown: null,
      onHiding: null,
      onHidden: null,
      contentTemplate: "content",
      innerOverlay: false,
      restorePosition: true,
      container: void 0,
      visualContainer: void 0,
      hideTopOverlayHandler: () => {
        this.hide();
      },
      hideOnParentScroll: false,
      preventScrollEvents: true,
      onPositioned: null,
      propagateOutsideClick: false,
      ignoreChildEvents: true,
      _checkParentVisibility: true,
      _hideOnParentScrollTarget: void 0,
      _fixWrapperPosition: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => !hasWindow(),
      options: {
        width: null,
        height: null,
        animation: null,
        _checkParentVisibility: false
      }
    }]);
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      animation: true
    });
  },
  $wrapper() {
    return this._$wrapper;
  },
  _eventBindingTarget() {
    return this._$content;
  },
  _setDeprecatedOptions() {
    this.callBase();
    extend(this._deprecatedOptions, {
      closeOnOutsideClick: {
        since: "22.1",
        alias: "hideOnOutsideClick"
      }
    });
  },
  ctor(element, options2) {
    this.callBase(element, options2);
    if (options2) {
      if ("preventScrollEvents" in options2 && !options2._ignorePreventScrollEventsDeprecation) {
        this._logDeprecatedPreventScrollEventsInfo();
      }
    }
  },
  _logDeprecatedPreventScrollEventsInfo() {
    this._logDeprecatedOptionWarning("preventScrollEvents", {
      since: "23.1",
      message: "If you enable this option, end-users may experience scrolling issues."
    });
  },
  _init() {
    this.callBase();
    this._initActions();
    this._initHideOnOutsideClickHandler();
    this._initTabTerminatorHandler();
    this._customWrapperClass = null;
    this._$wrapper = renderer_default("<div>").addClass("dx-overlay-wrapper");
    this._$content = renderer_default("<div>").addClass("dx-overlay-content");
    this._initInnerOverlayClass();
    const $element = this.$element();
    $element.addClass("dx-overlay");
    this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
    this._toggleViewPortSubscription(true);
    this._initHideTopOverlayHandler(this.option("hideTopOverlayHandler"));
    this._parentsScrollSubscriptionInfo = {
      handler: (e) => {
        this._hideOnParentsScrollHandler(e);
      }
    };
    this.warnPositionAsFunction();
  },
  warnPositionAsFunction() {
    if (isFunction(this.option("position"))) {
      errors_default.log("W0018");
    }
  },
  _initInnerOverlayClass() {
    this._$content.toggleClass("dx-inner-overlay", this.option("innerOverlay"));
  },
  _initHideTopOverlayHandler(handler) {
    this._hideTopOverlayHandler = handler;
  },
  _getActionsList: () => ["onShowing", "onShown", "onHiding", "onHidden", "onPositioned", "onVisualPositionChanged"],
  _initActions() {
    this._actions = {};
    const actions = this._getActionsList();
    each(actions, (_, action) => {
      this._actions[action] = this._createActionByOption(action, {
        excludeValidators: ["disabled", "readOnly"]
      }) || noop2;
    });
  },
  _initHideOnOutsideClickHandler() {
    var _this = this;
    this._proxiedDocumentDownHandler = function() {
      return _this._documentDownHandler(...arguments);
    };
  },
  _initMarkup() {
    this.callBase();
    this._renderWrapperAttributes();
    this._initPositionController();
  },
  _documentDownHandler(e) {
    if (this._showAnimationProcessing) {
      this._stopAnimation();
    }
    const isAttachedTarget = renderer_default(window17.document).is(e.target) || contains2(window17.document, e.target);
    const isInnerOverlay = renderer_default(e.target).closest(".dx-inner-overlay").length;
    const outsideClick = isAttachedTarget && !isInnerOverlay && !(this._$content.is(e.target) || contains2(this._$content.get(0), e.target));
    if (outsideClick && this._shouldHideOnOutsideClick(e)) {
      this._outsideClickHandler(e);
    }
    return this.option("propagateOutsideClick");
  },
  _shouldHideOnOutsideClick(e) {
    const {
      hideOnOutsideClick
    } = this.option();
    if (isFunction(hideOnOutsideClick)) {
      return hideOnOutsideClick(e);
    }
    return hideOnOutsideClick;
  },
  _outsideClickHandler(e) {
    if (this.option("shading")) {
      e.preventDefault();
    }
    this.hide();
  },
  _getAnonymousTemplateName: () => "content",
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new EmptyTemplate()
    });
    this.callBase();
  },
  _isTopOverlay() {
    const overlayStack = this._overlayStack();
    for (let i = overlayStack.length - 1; i >= 0; i--) {
      const tabbableElements = overlayStack[i]._findTabbableBounds();
      if (tabbableElements.first || tabbableElements.last) {
        return overlayStack[i] === this;
      }
    }
    return false;
  },
  _overlayStack: () => OVERLAY_STACK,
  _zIndexInitValue: () => Overlay.baseZIndex(),
  _toggleViewPortSubscription(toggle) {
    var _this2 = this;
    viewPortChanged2.remove(this._viewPortChangeHandle);
    if (toggle) {
      this._viewPortChangeHandle = function() {
        _this2._viewPortChangeHandler(...arguments);
      };
      viewPortChanged2.add(this._viewPortChangeHandle);
    }
  },
  _viewPortChangeHandler() {
    this._positionController.updateContainer(this.option("container"));
    this._refresh();
  },
  _renderWrapperAttributes() {
    const {
      wrapperAttr
    } = this.option();
    const attributes = extend({}, wrapperAttr);
    const classNames = attributes.class;
    delete attributes.class;
    this.$wrapper().attr(attributes).removeClass(this._customWrapperClass).addClass(classNames);
    this._customWrapperClass = classNames;
  },
  _renderVisibilityAnimate(visible2) {
    this._stopAnimation();
    return visible2 ? this._show() : this._hide();
  },
  _getAnimationConfig() {
    return this._getOptionValue("animation", this);
  },
  _toggleBodyScroll: noop2,
  _animateShowing() {
    var _this3 = this;
    const animation3 = this._getAnimationConfig() ?? {};
    const showAnimation = this._normalizeAnimation(animation3.show, "to");
    const startShowAnimation = (null === showAnimation || void 0 === showAnimation ? void 0 : showAnimation.start) ?? noop2;
    const completeShowAnimation = (null === showAnimation || void 0 === showAnimation ? void 0 : showAnimation.complete) ?? noop2;
    this._animate(showAnimation, function() {
      if (_this3._isAnimationPaused) {
        return;
      }
      if (_this3.option("focusStateEnabled")) {
        events_engine_default.trigger(_this3._focusTarget(), "focus");
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      completeShowAnimation.call(_this3, ...args);
      _this3._showAnimationProcessing = false;
      _this3._isHidden = false;
      _this3._actions.onShown();
      _this3._toggleSafariScrolling();
      _this3._showingDeferred.resolve();
    }, function() {
      if (_this3._isAnimationPaused) {
        return;
      }
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      startShowAnimation.call(_this3, ...args);
      _this3._showAnimationProcessing = true;
    });
  },
  _processShowingHidingCancel(cancelArg, applyFunction, cancelFunction) {
    if (isPromise(cancelArg)) {
      cancelArg.then((shouldCancel) => {
        if (shouldCancel) {
          cancelFunction();
        } else {
          applyFunction();
        }
      }).catch(() => applyFunction());
    } else {
      cancelArg ? cancelFunction() : applyFunction();
    }
  },
  _show() {
    this._showingDeferred = Deferred();
    this._parentHidden = this._isParentHidden();
    this._showingDeferred.done(() => {
      delete this._parentHidden;
    });
    if (this._parentHidden) {
      this._isHidden = true;
      return this._showingDeferred.resolve();
    }
    if (this._currentVisible) {
      return Deferred().resolve().promise();
    }
    this._currentVisible = true;
    if (this._isHidingActionCanceled) {
      delete this._isHidingActionCanceled;
      this._showingDeferred.reject();
    } else {
      const show3 = () => {
        this._stopAnimation();
        this._toggleBodyScroll(this.option("enableBodyScroll"));
        this._toggleVisibility(true);
        this._$content.css("visibility", "hidden");
        this._$content.toggleClass("dx-state-invisible", false);
        this._updateZIndexStackPosition(true);
        this._positionController.openingHandled();
        this._renderContent();
        const showingArgs = {
          cancel: false
        };
        this._actions.onShowing(showingArgs);
        this._processShowingHidingCancel(showingArgs.cancel, () => {
          this._$content.css("visibility", "");
          this._renderVisibility(true);
          this._animateShowing();
        }, () => {
          this._toggleVisibility(false);
          this._$content.css("visibility", "");
          this._$content.toggleClass("dx-state-invisible", true);
          this._isShowingActionCanceled = true;
          this._moveFromContainer();
          this._toggleBodyScroll(true);
          this.option("visible", false);
          this._showingDeferred.resolve();
        });
      };
      if (this.option("templatesRenderAsynchronously")) {
        this._stopShowTimer();
        this._asyncShowTimeout = setTimeout(show3);
      } else {
        show3();
      }
    }
    return this._showingDeferred.promise();
  },
  _normalizeAnimation(showHideConfig, direction) {
    if (showHideConfig) {
      showHideConfig = extend({
        type: "slide",
        skipElementInitialStyles: true
      }, showHideConfig);
      if (isObject(showHideConfig[direction])) {
        extend(showHideConfig[direction], {
          position: this._positionController.position
        });
      }
    }
    return showHideConfig;
  },
  _animateHiding() {
    var _this4 = this;
    const animation3 = this._getAnimationConfig() ?? {};
    const hideAnimation = this._normalizeAnimation(animation3.hide, "from");
    const startHideAnimation = (null === hideAnimation || void 0 === hideAnimation ? void 0 : hideAnimation.start) ?? noop2;
    const completeHideAnimation = (null === hideAnimation || void 0 === hideAnimation ? void 0 : hideAnimation.complete) ?? noop2;
    this._animate(hideAnimation, function() {
      var _this4$_actions;
      _this4._$content.css("pointerEvents", "");
      _this4._renderVisibility(false);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      completeHideAnimation.call(_this4, ...args);
      _this4._hideAnimationProcessing = false;
      null === (_this4$_actions = _this4._actions) || void 0 === _this4$_actions || _this4$_actions.onHidden();
      _this4._hidingDeferred.resolve();
    }, function() {
      _this4._$content.css("pointerEvents", "none");
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      startHideAnimation.call(_this4, ...args);
      _this4._hideAnimationProcessing = true;
    });
  },
  _hide() {
    if (!this._currentVisible) {
      return Deferred().resolve().promise();
    }
    this._currentVisible = false;
    this._hidingDeferred = Deferred();
    const hidingArgs = {
      cancel: false
    };
    if (this._isShowingActionCanceled) {
      delete this._isShowingActionCanceled;
      this._hidingDeferred.reject();
    } else {
      this._actions.onHiding(hidingArgs);
      this._toggleSafariScrolling();
      this._toggleBodyScroll(true);
      const cancelHide = () => {
        this._isHidingActionCanceled = true;
        this._toggleBodyScroll(this.option("enableBodyScroll"));
        this.option("visible", true);
        this._hidingDeferred.resolve();
      };
      const applyHide = () => {
        this._forceFocusLost();
        this._toggleShading(false);
        this._toggleSubscriptions(false);
        this._stopShowTimer();
        this._animateHiding();
      };
      this._processShowingHidingCancel(hidingArgs.cancel, applyHide, cancelHide);
    }
    return this._hidingDeferred.promise();
  },
  _forceFocusLost() {
    const activeElement = dom_adapter_default.getActiveElement();
    const shouldResetActiveElement = !!this._$content.find(activeElement).length;
    if (shouldResetActiveElement) {
      resetActiveElement();
    }
  },
  _animate(animation3, completeCallback, startCallback) {
    if (animation3) {
      startCallback = startCallback || animation3.start || noop2;
      fx_default.animate(this._$content, extend({}, animation3, {
        start: startCallback,
        complete: completeCallback
      }));
    } else {
      completeCallback();
    }
  },
  _stopAnimation() {
    fx_default.stop(this._$content, true);
  },
  _renderVisibility(visible2) {
    if (visible2 && this._isParentHidden()) {
      return;
    }
    this._currentVisible = visible2;
    this._stopAnimation();
    if (!visible2) {
      triggerHidingEvent(this._$content);
    }
    if (visible2) {
      this._checkContainerExists();
      this._moveToContainer();
      this._renderGeometry();
      triggerShownEvent(this._$content);
      triggerResizeEvent(this._$content);
    } else {
      this._toggleVisibility(visible2);
      this._$content.toggleClass("dx-state-invisible", !visible2);
      this._updateZIndexStackPosition(visible2);
      this._moveFromContainer();
    }
    this._toggleShading(visible2);
    this._toggleSubscriptions(visible2);
  },
  _updateZIndexStackPosition(pushToStack) {
    const overlayStack = this._overlayStack();
    const index2 = overlayStack.indexOf(this);
    if (pushToStack) {
      if (-1 === index2) {
        this._zIndex = create(this._zIndexInitValue());
        overlayStack.push(this);
      }
      this._$wrapper.css("zIndex", this._zIndex);
      this._$content.css("zIndex", this._zIndex);
    } else if (-1 !== index2) {
      overlayStack.splice(index2, 1);
      remove4(this._zIndex);
    }
  },
  _toggleShading(visible2) {
    this._$wrapper.toggleClass("dx-overlay-shader", visible2 && this.option("shading"));
    this._$wrapper.css("backgroundColor", this.option("shading") ? this.option("shadingColor") : "");
    this._toggleTabTerminator(visible2 && this.option("shading"));
  },
  _initTabTerminatorHandler() {
    var _this5 = this;
    this._proxiedTabTerminatorHandler = function() {
      _this5._tabKeyHandler(...arguments);
    };
  },
  _toggleTabTerminator(enabled) {
    const eventName = addNamespace2("keydown", this.NAME);
    if (enabled) {
      events_engine_default.on(dom_adapter_default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    } else {
      events_engine_default.off(dom_adapter_default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    }
  },
  _findTabbableBounds() {
    const $elements = this._$wrapper.find("*");
    const elementsCount = $elements.length - 1;
    const result2 = {
      first: null,
      last: null
    };
    for (let i = 0; i <= elementsCount; i++) {
      if (!result2.first && $elements.eq(i).is(tabbable)) {
        result2.first = $elements.eq(i);
      }
      if (!result2.last && $elements.eq(elementsCount - i).is(tabbable)) {
        result2.last = $elements.eq(elementsCount - i);
      }
      if (result2.first && result2.last) {
        break;
      }
    }
    return result2;
  },
  _tabKeyHandler(e) {
    if ("tab" !== normalizeKeyName(e) || !this._isTopOverlay()) {
      return;
    }
    const tabbableElements = this._findTabbableBounds();
    const $firstTabbable = tabbableElements.first;
    const $lastTabbable = tabbableElements.last;
    const isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0);
    const isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0);
    const isEmptyTabList = 0 === tabbableElements.length;
    const isOutsideTarget = !contains2(this._$wrapper.get(0), e.target);
    if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
      e.preventDefault();
      const $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;
      events_engine_default.trigger($focusElement, "focusin");
      events_engine_default.trigger($focusElement, "focus");
    }
  },
  _toggleSubscriptions(enabled) {
    if (hasWindow()) {
      this._toggleHideTopOverlayCallback(enabled);
      this._toggleHideOnParentsScrollSubscription(enabled);
    }
  },
  _toggleHideTopOverlayCallback(subscribe) {
    if (!this._hideTopOverlayHandler) {
      return;
    }
    if (subscribe) {
      hideCallback.add(this._hideTopOverlayHandler);
    } else {
      hideCallback.remove(this._hideTopOverlayHandler);
    }
  },
  _toggleHideOnParentsScrollSubscription(needSubscribe) {
    const scrollEvent = addNamespace2("scroll", this.NAME);
    const {
      prevTargets,
      handler
    } = this._parentsScrollSubscriptionInfo ?? {};
    events_engine_default.off(prevTargets, scrollEvent, handler);
    const hideOnScroll = this.option("hideOnParentScroll");
    if (needSubscribe && hideOnScroll) {
      let $parents = this._getHideOnParentScrollTarget().parents();
      if ("desktop" === devices_default.real().deviceType) {
        $parents = $parents.add(window17);
      }
      events_engine_default.on($parents, scrollEvent, handler);
      this._parentsScrollSubscriptionInfo.prevTargets = $parents;
    }
  },
  _hideOnParentsScrollHandler(e) {
    let hideHandled = false;
    const hideOnScroll = this.option("hideOnParentScroll");
    if (isFunction(hideOnScroll)) {
      hideHandled = hideOnScroll(e);
    }
    if (!hideHandled && !this._showAnimationProcessing) {
      this.hide();
    }
  },
  _getHideOnParentScrollTarget() {
    const $hideOnParentScrollTarget = renderer_default(this.option("_hideOnParentScrollTarget"));
    if ($hideOnParentScrollTarget.length) {
      return $hideOnParentScrollTarget;
    }
    return this._$wrapper;
  },
  _render() {
    this.callBase();
    this._appendContentToElement();
    this._renderVisibilityAnimate(this.option("visible"));
  },
  _appendContentToElement() {
    if (!this._$content.parent().is(this.$element())) {
      this._$content.appendTo(this.$element());
    }
  },
  _renderContent() {
    const shouldDeferRendering = !this._currentVisible && this.option("deferRendering");
    const isParentHidden = this.option("visible") && this._isParentHidden();
    if (isParentHidden) {
      this._isHidden = true;
      return;
    }
    if (this._contentAlreadyRendered || shouldDeferRendering) {
      return;
    }
    this._contentAlreadyRendered = true;
    this._appendContentToElement();
    this.callBase();
  },
  _isParentHidden() {
    if (!this.option("_checkParentVisibility")) {
      return false;
    }
    if (void 0 !== this._parentHidden) {
      return this._parentHidden;
    }
    const $parent = this.$element().parent();
    if ($parent.is(":visible")) {
      return false;
    }
    let isHidden = false;
    $parent.add($parent.parents()).each((index2, element) => {
      const $element = renderer_default(element);
      if ("none" === $element.css("display")) {
        isHidden = true;
        return false;
      }
    });
    return isHidden || !dom_adapter_default.getBody().contains($parent.get(0));
  },
  _renderContentImpl() {
    const whenContentRendered = Deferred();
    const contentTemplateOption = this.option("contentTemplate");
    const contentTemplate = this._getTemplate(contentTemplateOption);
    const transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;
    contentTemplate && contentTemplate.render({
      container: getPublicElement(this.$content()),
      noModel: true,
      transclude,
      onRendered: () => {
        whenContentRendered.resolve();
        if (this.option("templatesRenderAsynchronously")) {
          this._dimensionChanged();
        }
      }
    });
    this._toggleWrapperScrollEventsSubscription(this.option("preventScrollEvents"));
    whenContentRendered.done(() => {
      if (this.option("visible")) {
        this._moveToContainer();
      }
    });
    return whenContentRendered.promise();
  },
  _getPositionControllerConfig() {
    const {
      container,
      visualContainer,
      _fixWrapperPosition,
      restorePosition,
      _skipContentPositioning
    } = this.option();
    return {
      container,
      visualContainer,
      $root: this.$element(),
      $content: this._$content,
      $wrapper: this._$wrapper,
      onPositioned: this._actions.onPositioned,
      onVisualPositionChanged: this._actions.onVisualPositionChanged,
      restorePosition,
      _fixWrapperPosition,
      _skipContentPositioning
    };
  },
  _initPositionController() {
    this._positionController = new OverlayPositionController(this._getPositionControllerConfig());
  },
  _toggleWrapperScrollEventsSubscription(enabled) {
    const eventName = addNamespace2(DRAG_EVENT, this.NAME);
    events_engine_default.off(this._$wrapper, eventName);
    if (enabled) {
      events_engine_default.on(this._$wrapper, eventName, {
        validate: () => true,
        getDirection: () => "both",
        _toggleGestureCover(toggle) {
          if (!toggle) {
            this._toggleGestureCoverImpl(toggle);
          }
        },
        _clearSelection: noop2,
        isNative: true
      }, (e) => {
        const {
          originalEvent
        } = e.originalEvent;
        const {
          type: type2
        } = originalEvent || {};
        const isWheel = "wheel" === type2;
        const isMouseMove = "mousemove" === type2;
        const isScrollByWheel = isWheel && !isCommandKeyPressed(e);
        e._cancelPreventDefault = true;
        if (originalEvent && false !== e.cancelable && (!isMouseMove && !isWheel || isScrollByWheel)) {
          e.preventDefault();
        }
      });
    }
  },
  _moveFromContainer() {
    this._$content.appendTo(this.$element());
    this._$wrapper.detach();
  },
  _checkContainerExists() {
    const $wrapperContainer = this._positionController.$container;
    if (void 0 === $wrapperContainer) {
      return;
    }
    const containerExists = $wrapperContainer.length > 0;
    if (!containerExists) {
      ui_errors_default.log("W1021", this.NAME);
    }
  },
  _moveToContainer() {
    const $wrapperContainer = this._positionController.$container;
    this._$wrapper.appendTo($wrapperContainer);
    this._$content.appendTo(this._$wrapper);
  },
  _renderGeometry(options2) {
    const {
      visible: visible2
    } = this.option();
    if (visible2 && hasWindow()) {
      this._stopAnimation();
      this._renderGeometryImpl();
    }
  },
  _renderGeometryImpl() {
    this._positionController.updatePosition(this._getOptionValue("position"));
    this._renderWrapper();
    this._renderDimensions();
    this._renderPosition();
  },
  _renderPosition() {
    this._positionController.positionContent();
  },
  _isAllWindowCovered() {
    return isWindow(this._positionController.$visualContainer.get(0)) && this.option("shading");
  },
  _toggleSafariScrolling() {
    const visible2 = this.option("visible");
    const $body = renderer_default(dom_adapter_default.getBody());
    const isIosSafari = "ios" === devices_default.real().platform && browser_default.safari;
    const isAllWindowCovered = this._isAllWindowCovered();
    const isScrollingPrevented = $body.hasClass("dx-prevent-safari-scrolling");
    const shouldPreventScrolling = !isScrollingPrevented && visible2 && isAllWindowCovered;
    const shouldEnableScrolling = isScrollingPrevented && (!visible2 || !isAllWindowCovered || this._disposed);
    if (isIosSafari) {
      if (shouldEnableScrolling) {
        $body.removeClass("dx-prevent-safari-scrolling");
        window17.scrollTo(0, this._cachedBodyScrollTop);
        this._cachedBodyScrollTop = void 0;
      } else if (shouldPreventScrolling) {
        this._cachedBodyScrollTop = window17.pageYOffset;
        $body.addClass("dx-prevent-safari-scrolling");
      }
    }
  },
  _renderWrapper() {
    this._positionController.styleWrapperPosition();
    this._renderWrapperDimensions();
    this._positionController.positionWrapper();
  },
  _renderWrapperDimensions() {
    const {
      $visualContainer
    } = this._positionController;
    const documentElement = dom_adapter_default.getDocumentElement();
    const isVisualContainerWindow = isWindow($visualContainer.get(0));
    const wrapperWidth = isVisualContainerWindow ? documentElement.clientWidth : getOuterWidth($visualContainer);
    const wrapperHeight = isVisualContainerWindow ? window17.innerHeight : getOuterHeight($visualContainer);
    this._$wrapper.css({
      width: wrapperWidth,
      height: wrapperHeight
    });
  },
  _renderDimensions() {
    const content = this._$content.get(0);
    this._$content.css({
      minWidth: this._getOptionValue("minWidth", content),
      maxWidth: this._getOptionValue("maxWidth", content),
      minHeight: this._getOptionValue("minHeight", content),
      maxHeight: this._getOptionValue("maxHeight", content),
      width: this._getOptionValue("width", content),
      height: this._getOptionValue("height", content)
    });
  },
  _focusTarget() {
    return this._$content;
  },
  _attachKeyboardEvents() {
    this._keyboardListenerId = keyboard.on(this._$content, null, (opts) => this._keyboardHandler(opts));
  },
  _keyboardHandler(options2) {
    const e = options2.originalEvent;
    const $target = renderer_default(e.target);
    if ($target.is(this._$content) || !this.option("ignoreChildEvents")) {
      this.callBase(...arguments);
    }
  },
  _isVisible() {
    return this.option("visible");
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      if (this.option("visible")) {
        this._renderVisibilityAnimate(visible2);
      }
    } else {
      this._renderVisibilityAnimate(visible2);
    }
  },
  _dimensionChanged() {
    this._renderGeometry();
  },
  _clean() {
    const options2 = this.option();
    if (!this._contentAlreadyRendered && !options2.isRenovated) {
      this.$content().empty();
    }
    this._renderVisibility(false);
    this._stopShowTimer();
    this._cleanFocusState();
  },
  _stopShowTimer() {
    if (this._asyncShowTimeout) {
      clearTimeout(this._asyncShowTimeout);
    }
    this._asyncShowTimeout = null;
  },
  _dispose() {
    fx_default.stop(this._$content, false);
    clearTimeout(this._deferShowTimer);
    this._toggleViewPortSubscription(false);
    this._toggleSubscriptions(false);
    this._updateZIndexStackPosition(false);
    this._toggleTabTerminator(false);
    this._actions = null;
    this._parentsScrollSubscriptionInfo = null;
    this.callBase();
    this._toggleSafariScrolling();
    this.option("visible") && remove4(this._zIndex);
    this._$wrapper.remove();
    this._$content.remove();
  },
  _toggleRTLDirection(rtl) {
    this._$content.toggleClass("dx-rtl", rtl);
  },
  _optionChanged(args) {
    const {
      value: value2,
      name: name2
    } = args;
    if (this._getActionsList().includes(name2)) {
      this._initActions();
      return;
    }
    switch (name2) {
      case "animation":
      case "closeOnOutsideClick":
      case "hideOnOutsideClick":
      case "propagateOutsideClick":
        break;
      case "shading":
        this._toggleShading(this.option("visible"));
        this._toggleSafariScrolling();
        break;
      case "shadingColor":
        this._toggleShading(this.option("visible"));
        break;
      case "width":
      case "height":
      case "minWidth":
      case "maxWidth":
      case "minHeight":
      case "maxHeight":
        this._renderGeometry();
        break;
      case "position":
        this._positionController.updatePosition(this.option("position"));
        this._positionController.restorePositionOnNextRender(true);
        this._renderGeometry();
        this._toggleSafariScrolling();
        break;
      case "visible":
        this._renderVisibilityAnimate(value2).done(() => {
          var _this$_animateDeferre;
          return null === (_this$_animateDeferre = this._animateDeferred) || void 0 === _this$_animateDeferre ? void 0 : _this$_animateDeferre.resolveWith(this);
        }).fail(() => {
          var _this$_animateDeferre2;
          return null === (_this$_animateDeferre2 = this._animateDeferred) || void 0 === _this$_animateDeferre2 ? void 0 : _this$_animateDeferre2.reject();
        });
        break;
      case "container":
        this._positionController.updateContainer(value2);
        this._invalidate();
        this._toggleSafariScrolling();
        break;
      case "visualContainer":
        this._positionController.updateVisualContainer(value2);
        this._renderWrapper();
        this._toggleSafariScrolling();
        break;
      case "innerOverlay":
        this._initInnerOverlayClass();
        break;
      case "deferRendering":
      case "contentTemplate":
        this._contentAlreadyRendered = false;
        this._clean();
        this._invalidate();
        break;
      case "hideTopOverlayHandler":
        this._toggleHideTopOverlayCallback(false);
        this._initHideTopOverlayHandler(value2);
        this._toggleHideTopOverlayCallback(this.option("visible"));
        break;
      case "hideOnParentScroll":
      case "_hideOnParentScrollTarget":
        this._toggleHideOnParentsScrollSubscription(this.option("visible"));
        break;
      case "rtlEnabled":
        this._contentAlreadyRendered = false;
        this.callBase(args);
        break;
      case "_fixWrapperPosition":
        this._positionController.fixWrapperPosition = value2;
        break;
      case "wrapperAttr":
        this._renderWrapperAttributes();
        break;
      case "restorePosition":
        this._positionController.restorePosition = value2;
        break;
      case "preventScrollEvents":
        this._logDeprecatedPreventScrollEventsInfo();
        this._toggleWrapperScrollEventsSubscription(value2);
        break;
      default:
        this.callBase(args);
    }
  },
  toggle(showing) {
    showing = void 0 === showing ? !this.option("visible") : showing;
    const result2 = Deferred();
    if (showing === this.option("visible")) {
      return result2.resolveWith(this, [showing]).promise();
    }
    const animateDeferred = Deferred();
    this._animateDeferred = animateDeferred;
    this.option("visible", showing);
    animateDeferred.promise().done(() => {
      delete this._animateDeferred;
      result2.resolveWith(this, [this.option("visible")]);
    }).fail(() => {
      delete this._animateDeferred;
      result2.reject();
    });
    return result2.promise();
  },
  $content() {
    return this._$content;
  },
  show() {
    return this.toggle(true);
  },
  hide() {
    return this.toggle(false);
  },
  content() {
    return getPublicElement(this._$content);
  },
  repaint() {
    if (this._contentAlreadyRendered) {
      this._positionController.restorePositionOnNextRender(true);
      this._renderGeometry({
        forceStopAnimation: true
      });
      triggerResizeEvent(this._$content);
    } else {
      this.callBase();
    }
  }
});
Overlay.baseZIndex = (zIndex) => base(zIndex);
component_registrator_default("dxOverlay", Overlay);
var m_overlay_default = Overlay;

// ../../../../../../node_modules/devextreme/esm/ui/overlay/ui.overlay.js
var ui_overlay_default = m_overlay_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_resizable.js
var RESIZABLE = "dxResizable";
var DRAGSTART_START_EVENT_NAME = addNamespace2(DRAG_START_EVENT, RESIZABLE);
var DRAGSTART_EVENT_NAME = addNamespace2(DRAG_EVENT, RESIZABLE);
var DRAGSTART_END_EVENT_NAME = addNamespace2(DRAG_END_EVENT, RESIZABLE);
var SIDE_BORDER_WIDTH_STYLES = {
  left: "borderLeftWidth",
  top: "borderTopWidth",
  right: "borderRightWidth",
  bottom: "borderBottomWidth"
};
var Resizable = dom_component_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      handles: "all",
      step: "1",
      stepPrecision: "simple",
      area: void 0,
      minWidth: 30,
      maxWidth: 1 / 0,
      minHeight: 30,
      maxHeight: 1 / 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      roundStepValue: true,
      keepAspectRatio: true
    });
  },
  _init() {
    this.callBase();
    this.$element().addClass("dx-resizable");
  },
  _initMarkup() {
    this.callBase();
    this._renderHandles();
  },
  _render() {
    this.callBase();
    this._renderActions();
  },
  _renderActions() {
    this._resizeStartAction = this._createActionByOption("onResizeStart");
    this._resizeEndAction = this._createActionByOption("onResizeEnd");
    this._resizeAction = this._createActionByOption("onResize");
  },
  _renderHandles() {
    this._handles = [];
    const handles = this.option("handles");
    if ("none" === handles || !handles) {
      return;
    }
    const directions = "all" === handles ? ["top", "bottom", "left", "right"] : handles.split(" ");
    const activeHandlesMap = {};
    each(directions, (index2, handleName) => {
      activeHandlesMap[handleName] = true;
      this._renderHandle(handleName);
    });
    activeHandlesMap.bottom && activeHandlesMap.right && this._renderHandle("corner-bottom-right");
    activeHandlesMap.bottom && activeHandlesMap.left && this._renderHandle("corner-bottom-left");
    activeHandlesMap.top && activeHandlesMap.right && this._renderHandle("corner-top-right");
    activeHandlesMap.top && activeHandlesMap.left && this._renderHandle("corner-top-left");
    this._attachEventHandlers();
  },
  _renderHandle(handleName) {
    const $handle = renderer_default("<div>").addClass("dx-resizable-handle").addClass(`dx-resizable-handle-${handleName}`).appendTo(this.$element());
    this._handles.push($handle);
  },
  _attachEventHandlers() {
    if (this.option("disabled")) {
      return;
    }
    const handlers = {};
    handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);
    handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);
    handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);
    this._handles.forEach((handleElement) => {
      events_engine_default.on(handleElement, handlers, {
        direction: "both",
        immediate: true
      });
    });
  },
  _detachEventHandlers() {
    this._handles.forEach((handleElement) => {
      events_engine_default.off(handleElement);
    });
  },
  _toggleEventHandlers(shouldAttachEvents) {
    shouldAttachEvents ? this._attachEventHandlers() : this._detachEventHandlers();
  },
  _getElementSize() {
    const $element = this.$element();
    return "border-box" === $element.css("boxSizing") ? {
      width: getOuterWidth($element),
      height: getOuterHeight($element)
    } : {
      width: getWidth($element),
      height: getHeight($element)
    };
  },
  _dragStartHandler(e) {
    const $element = this.$element();
    if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = true;
      return;
    }
    this._toggleResizingClass(true);
    this._movingSides = this._getMovingSides(e);
    this._elementLocation = locate($element);
    this._elementSize = this._getElementSize();
    this._renderDragOffsets(e);
    this._resizeStartAction({
      event: e,
      width: this._elementSize.width,
      height: this._elementSize.height,
      handles: this._movingSides
    });
    e.targetElements = null;
  },
  _toggleResizingClass(value2) {
    this.$element().toggleClass("dx-resizable-resizing", value2);
  },
  _renderDragOffsets(e) {
    const area = this._getArea();
    if (!area) {
      return;
    }
    const $handle = renderer_default(e.target).closest(".dx-resizable-handle");
    const handleWidth = getOuterWidth($handle);
    const handleHeight = getOuterHeight($handle);
    const handleOffset = $handle.offset();
    const areaOffset = area.offset;
    const scrollOffset = this._getAreaScrollOffset();
    e.maxLeftOffset = this._leftMaxOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;
    e.maxRightOffset = this._rightMaxOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;
    e.maxTopOffset = this._topMaxOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;
    e.maxBottomOffset = this._bottomMaxOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY;
  },
  _getBorderWidth($element, direction) {
    if (isWindow($element.get(0))) {
      return 0;
    }
    const borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES[direction]);
    return parseInt(borderWidth) || 0;
  },
  _proportionate(direction, value2) {
    const size = this._elementSize;
    const factor = "x" === direction ? size.width / size.height : size.height / size.width;
    return value2 * factor;
  },
  _getProportionalDelta(_ref) {
    let {
      x,
      y
    } = _ref;
    const proportionalY = this._proportionate("y", x);
    if (proportionalY >= y) {
      return {
        x,
        y: proportionalY
      };
    }
    const proportionalX = this._proportionate("x", y);
    if (proportionalX >= x) {
      return {
        x: proportionalX,
        y
      };
    }
    return {
      x: 0,
      y: 0
    };
  },
  _getDirectionName(axis) {
    const sides = this._movingSides;
    if ("x" === axis) {
      return sides.left ? "left" : "right";
    }
    return sides.top ? "top" : "bottom";
  },
  _fitIntoArea(axis, value2) {
    const directionName = this._getDirectionName(axis);
    return Math.min(value2, this[`_${directionName}MaxOffset`] ?? 1 / 0);
  },
  _fitDeltaProportionally(delta) {
    let fittedDelta = _extends({}, delta);
    const size = this._elementSize;
    const {
      minWidth,
      minHeight,
      maxWidth,
      maxHeight
    } = this.option();
    const getWidth2 = () => size.width + fittedDelta.x;
    const getHeight2 = () => size.height + fittedDelta.y;
    const isInArea = (axis) => fittedDelta[axis] === this._fitIntoArea(axis, fittedDelta[axis]);
    const isFittedX = () => inRange(getWidth2(), minWidth, maxWidth) && isInArea("x");
    const isFittedY = () => inRange(getHeight2(), minHeight, maxHeight) && isInArea("y");
    if (!isFittedX()) {
      const x = this._fitIntoArea("x", fitIntoRange(getWidth2(), minWidth, maxWidth) - size.width);
      fittedDelta = {
        x,
        y: this._proportionate("y", x)
      };
    }
    if (!isFittedY()) {
      const y = this._fitIntoArea("y", fitIntoRange(getHeight2(), minHeight, maxHeight) - size.height);
      fittedDelta = {
        x: this._proportionate("x", y),
        y
      };
    }
    return isFittedX() && isFittedY() ? fittedDelta : {
      x: 0,
      y: 0
    };
  },
  _fitDelta(_ref2) {
    let {
      x,
      y
    } = _ref2;
    const size = this._elementSize;
    const {
      minWidth,
      minHeight,
      maxWidth,
      maxHeight
    } = this.option();
    return {
      x: fitIntoRange(size.width + x, minWidth, maxWidth) - size.width,
      y: fitIntoRange(size.height + y, minHeight, maxHeight) - size.height
    };
  },
  _getDeltaByOffset(offset2) {
    const sides = this._movingSides;
    const shouldKeepAspectRatio = this._isCornerHandler(sides) && this.option("keepAspectRatio");
    let delta = {
      x: offset2.x * (sides.left ? -1 : 1),
      y: offset2.y * (sides.top ? -1 : 1)
    };
    if (shouldKeepAspectRatio) {
      const proportionalDelta = this._getProportionalDelta(delta);
      const fittedProportionalDelta = this._fitDeltaProportionally(proportionalDelta);
      delta = fittedProportionalDelta;
    } else {
      const fittedDelta = this._fitDelta(delta);
      const roundedFittedDelta = this._roundByStep(fittedDelta);
      delta = roundedFittedDelta;
    }
    return delta;
  },
  _updatePosition(delta, _ref3) {
    let {
      width,
      height
    } = _ref3;
    const location = this._elementLocation;
    const sides = this._movingSides;
    const $element = this.$element();
    const elementRect = this._getElementSize();
    const offsetTop = delta.y * (sides.top ? -1 : 1) - ((elementRect.height || height) - height);
    const offsetLeft = delta.x * (sides.left ? -1 : 1) - ((elementRect.width || width) - width);
    move($element, {
      top: location.top + (sides.top ? offsetTop : 0),
      left: location.left + (sides.left ? offsetLeft : 0)
    });
  },
  _dragHandler(e) {
    const offset2 = this._getOffset(e);
    const delta = this._getDeltaByOffset(offset2);
    const dimensions = this._updateDimensions(delta);
    this._updatePosition(delta, dimensions);
    this._triggerResizeAction(e, dimensions);
  },
  _updateDimensions(delta) {
    const isAbsoluteSize = (size2) => "px" === size2.substring(size2.length - 2);
    const isStepPrecisionStrict = "strict" === this.option("stepPrecision");
    const size = this._elementSize;
    const width = size.width + delta.x;
    const height = size.height + delta.y;
    const elementStyle = this.$element().get(0).style;
    const shouldRenderWidth = delta.x || isStepPrecisionStrict || isAbsoluteSize(elementStyle.width);
    const shouldRenderHeight = delta.y || isStepPrecisionStrict || isAbsoluteSize(elementStyle.height);
    if (shouldRenderWidth) {
      this.option({
        width
      });
    }
    if (shouldRenderHeight) {
      this.option({
        height
      });
    }
    return {
      width: shouldRenderWidth ? width : size.width,
      height: shouldRenderHeight ? height : size.height
    };
  },
  _triggerResizeAction(e, _ref4) {
    let {
      width,
      height
    } = _ref4;
    this._resizeAction({
      event: e,
      width: this.option("width") || width,
      height: this.option("height") || height,
      handles: this._movingSides
    });
    triggerResizeEvent(this.$element());
  },
  _isCornerHandler: (sides) => 0 === Object.values(sides).reduce((xor2, value2) => xor2 ^ value2, 0),
  _getOffset(e) {
    const {
      offset: offset2
    } = e;
    const sides = this._movingSides;
    if (!sides.left && !sides.right) {
      offset2.x = 0;
    }
    if (!sides.top && !sides.bottom) {
      offset2.y = 0;
    }
    return offset2;
  },
  _roundByStep(delta) {
    return "strict" === this.option("stepPrecision") ? this._roundStrict(delta) : this._roundNotStrict(delta);
  },
  _getSteps() {
    return pairToObject(this.option("step"), !this.option("roundStepValue"));
  },
  _roundNotStrict(delta) {
    const steps = this._getSteps();
    return {
      x: delta.x - delta.x % steps.h,
      y: delta.y - delta.y % steps.v
    };
  },
  _roundStrict(delta) {
    const sides = this._movingSides;
    const offset2 = {
      x: delta.x * (sides.left ? -1 : 1),
      y: delta.y * (sides.top ? -1 : 1)
    };
    const steps = this._getSteps();
    const location = this._elementLocation;
    const size = this._elementSize;
    const xPos = sides.left ? location.left : location.left + size.width;
    const yPos = sides.top ? location.top : location.top + size.height;
    const newXShift = (xPos + offset2.x) % steps.h;
    const newYShift = (yPos + offset2.y) % steps.v;
    const sign2 = Math.sign || ((x) => {
      x = +x;
      if (0 === x || isNaN(x)) {
        return x;
      }
      return x > 0 ? 1 : -1;
    });
    const separatorOffset = (steps2, offset3) => (1 + 0.2 * sign2(offset3)) % 1 * steps2;
    const isSmallOffset = (offset3, steps2) => Math.abs(offset3) < 0.2 * steps2;
    let newOffsetX = offset2.x - newXShift;
    let newOffsetY = offset2.y - newYShift;
    if (newXShift > separatorOffset(steps.h, offset2.x)) {
      newOffsetX += steps.h;
    }
    if (newYShift > separatorOffset(steps.v, offset2.y)) {
      newOffsetY += steps.v;
    }
    const roundedOffset_x = (sides.left || sides.right) && !isSmallOffset(offset2.x, steps.h) ? newOffsetX : 0, roundedOffset_y = (sides.top || sides.bottom) && !isSmallOffset(offset2.y, steps.v) ? newOffsetY : 0;
    return {
      x: roundedOffset_x * (sides.left ? -1 : 1),
      y: roundedOffset_y * (sides.top ? -1 : 1)
    };
  },
  _getMovingSides(e) {
    const $target = renderer_default(e.target);
    const hasCornerTopLeftClass = $target.hasClass("dx-resizable-handle-corner-top-left");
    const hasCornerTopRightClass = $target.hasClass("dx-resizable-handle-corner-top-right");
    const hasCornerBottomLeftClass = $target.hasClass("dx-resizable-handle-corner-bottom-left");
    const hasCornerBottomRightClass = $target.hasClass("dx-resizable-handle-corner-bottom-right");
    return {
      top: $target.hasClass("dx-resizable-handle-top") || hasCornerTopLeftClass || hasCornerTopRightClass,
      left: $target.hasClass("dx-resizable-handle-left") || hasCornerTopLeftClass || hasCornerBottomLeftClass,
      bottom: $target.hasClass("dx-resizable-handle-bottom") || hasCornerBottomLeftClass || hasCornerBottomRightClass,
      right: $target.hasClass("dx-resizable-handle-right") || hasCornerTopRightClass || hasCornerBottomRightClass
    };
  },
  _getArea() {
    let area = this.option("area");
    if (isFunction(area)) {
      area = area.call(this);
    }
    if (isPlainObject(area)) {
      return this._getAreaFromObject(area);
    }
    return this._getAreaFromElement(area);
  },
  _getAreaScrollOffset() {
    const area = this.option("area");
    const isElement = !isFunction(area) && !isPlainObject(area);
    const scrollOffset = {
      scrollY: 0,
      scrollX: 0
    };
    if (isElement) {
      const areaElement = renderer_default(area)[0];
      if (isWindow(areaElement)) {
        scrollOffset.scrollX = areaElement.pageXOffset;
        scrollOffset.scrollY = areaElement.pageYOffset;
      }
    }
    return scrollOffset;
  },
  _getAreaFromObject(area) {
    const result2 = {
      width: area.right - area.left,
      height: area.bottom - area.top,
      offset: {
        left: area.left,
        top: area.top
      }
    };
    this._correctAreaGeometry(result2);
    return result2;
  },
  _getAreaFromElement(area) {
    const $area = renderer_default(area);
    let result2;
    if ($area.length) {
      result2 = {
        width: getInnerWidth($area),
        height: getInnerHeight($area),
        offset: extend({
          top: 0,
          left: 0
        }, isWindow($area[0]) ? {} : $area.offset())
      };
      this._correctAreaGeometry(result2, $area);
    }
    return result2;
  },
  _correctAreaGeometry(result2, $area) {
    const areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0;
    const areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
    result2.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), "left");
    result2.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), "top");
    result2.width -= getOuterWidth(this.$element()) - getInnerWidth(this.$element());
    result2.height -= getOuterHeight(this.$element()) - getInnerHeight(this.$element());
  },
  _dragEndHandler(e) {
    const $element = this.$element();
    this._resizeEndAction({
      event: e,
      width: getOuterWidth($element),
      height: getOuterHeight($element),
      handles: this._movingSides
    });
    this._toggleResizingClass(false);
  },
  _renderWidth(width) {
    this.option("width", fitIntoRange(width, this.option("minWidth"), this.option("maxWidth")));
  },
  _renderHeight(height) {
    this.option("height", fitIntoRange(height, this.option("minHeight"), this.option("maxHeight")));
  },
  _optionChanged(args) {
    switch (args.name) {
      case "disabled":
        this._toggleEventHandlers(!args.value);
        this.callBase(args);
        break;
      case "handles":
        this._invalidate();
        break;
      case "minWidth":
      case "maxWidth":
        hasWindow() && this._renderWidth(getOuterWidth(this.$element()));
        break;
      case "minHeight":
      case "maxHeight":
        hasWindow() && this._renderHeight(getOuterHeight(this.$element()));
        break;
      case "onResize":
      case "onResizeStart":
      case "onResizeEnd":
        this._renderActions();
        break;
      case "area":
      case "stepPrecision":
      case "step":
      case "roundStepValue":
      case "keepAspectRatio":
        break;
      default:
        this.callBase(args);
    }
  },
  _clean() {
    this.$element().find(".dx-resizable-handle").remove();
  },
  _useTemplates: () => false
});
component_registrator_default(RESIZABLE, Resizable);
var m_resizable_default = Resizable;

// ../../../../../../node_modules/devextreme/esm/ui/resizable.js
var resizable_default = m_resizable_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popup/m_popup_drag.js
var PopupDrag = class {
  constructor(config3) {
    this.init(config3);
  }
  init(_ref) {
    let {
      dragEnabled,
      handle,
      draggableElement,
      positionController
    } = _ref;
    this._positionController = positionController;
    this._draggableElement = draggableElement;
    this._handle = handle;
    this._dragEnabled = dragEnabled;
    this.unsubscribe();
    if (!dragEnabled) {
      return;
    }
    this.subscribe();
  }
  moveDown(e) {
    this._moveTo(5, 0, e);
  }
  moveUp(e) {
    this._moveTo(-5, 0, e);
  }
  moveLeft(e) {
    this._moveTo(0, -5, e);
  }
  moveRight(e) {
    this._moveTo(0, 5, e);
  }
  subscribe() {
    const eventNames = this._getEventNames();
    events_engine_default.on(this._handle, eventNames.startEventName, (e) => {
      this._dragStartHandler(e);
    });
    events_engine_default.on(this._handle, eventNames.updateEventName, (e) => {
      this._dragUpdateHandler(e);
    });
    events_engine_default.on(this._handle, eventNames.endEventName, (e) => {
      this._dragEndHandler(e);
    });
  }
  unsubscribe() {
    const eventNames = this._getEventNames();
    events_engine_default.off(this._handle, eventNames.startEventName);
    events_engine_default.off(this._handle, eventNames.updateEventName);
    events_engine_default.off(this._handle, eventNames.endEventName);
  }
  _getEventNames() {
    const startEventName = addNamespace2(DRAG_START_EVENT, "overlayDrag");
    const updateEventName = addNamespace2(DRAG_EVENT, "overlayDrag");
    const endEventName = addNamespace2(DRAG_END_EVENT, "overlayDrag");
    return {
      startEventName,
      updateEventName,
      endEventName
    };
  }
  _dragStartHandler(e) {
    const allowedOffsets = this._getAllowedOffsets();
    this._prevOffset = {
      x: 0,
      y: 0
    };
    e.targetElements = [];
    e.maxTopOffset = allowedOffsets.top;
    e.maxBottomOffset = allowedOffsets.bottom;
    e.maxLeftOffset = allowedOffsets.left;
    e.maxRightOffset = allowedOffsets.right;
  }
  _dragUpdateHandler(e) {
    const targetOffset = {
      top: e.offset.y - this._prevOffset.y,
      left: e.offset.x - this._prevOffset.x
    };
    this._moveByOffset(targetOffset);
    this._prevOffset = e.offset;
  }
  _dragEndHandler(event) {
    this._positionController.dragHandled();
    this._positionController.detectVisualPositionChange(event);
  }
  _moveTo(top, left, e) {
    if (!this._dragEnabled) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    const offset2 = this._fitOffsetIntoAllowedRange(top, left);
    this._moveByOffset(offset2);
    this._dragEndHandler(e);
  }
  _fitOffsetIntoAllowedRange(top, left) {
    const allowedOffsets = this._getAllowedOffsets();
    return {
      top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
      left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
    };
  }
  _getContainerDimensions() {
    const document2 = dom_adapter_default.getDocument();
    const container = this._positionController.$dragResizeContainer.get(0);
    let containerWidth = getOuterWidth(container);
    let containerHeight = getOuterHeight(container);
    if (isWindow(container)) {
      containerHeight = Math.max(document2.body.clientHeight, containerHeight);
      containerWidth = Math.max(document2.body.clientWidth, containerWidth);
    }
    return {
      width: containerWidth,
      height: containerHeight
    };
  }
  _getContainerPosition() {
    const container = this._positionController.$dragResizeContainer.get(0);
    return isWindow(container) ? {
      top: 0,
      left: 0
    } : getOffset(container);
  }
  _getElementPosition() {
    return getOffset(this._draggableElement);
  }
  _getInnerDelta() {
    const containerDimensions = this._getContainerDimensions();
    const elementDimensions = this._getElementDimensions();
    return {
      x: containerDimensions.width - elementDimensions.width,
      y: containerDimensions.height - elementDimensions.height
    };
  }
  _getOuterDelta() {
    const {
      width,
      height
    } = this._getElementDimensions();
    const {
      outsideDragFactor
    } = this._positionController;
    return {
      x: width * outsideDragFactor,
      y: height * outsideDragFactor
    };
  }
  _getFullDelta() {
    const fullDelta = this._getInnerDelta();
    const outerDelta = this._getOuterDelta();
    return {
      x: fullDelta.x + outerDelta.x,
      y: fullDelta.y + outerDelta.y
    };
  }
  _getElementDimensions() {
    return {
      width: this._draggableElement.offsetWidth,
      height: this._draggableElement.offsetHeight
    };
  }
  _getAllowedOffsets() {
    const fullDelta = this._getFullDelta();
    const isDragAllowed = fullDelta.y >= 0 && fullDelta.x >= 0;
    if (!isDragAllowed) {
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }
    const elementPosition = this._getElementPosition();
    const containerPosition = this._getContainerPosition();
    const outerDelta = this._getOuterDelta();
    return {
      top: elementPosition.top - containerPosition.top + outerDelta.y,
      bottom: -elementPosition.top + containerPosition.top + fullDelta.y,
      left: elementPosition.left - containerPosition.left + outerDelta.x,
      right: -elementPosition.left + containerPosition.left + fullDelta.x
    };
  }
  _moveByOffset(offset2) {
    const currentPosition = locate(this._draggableElement);
    const newPosition = {
      left: currentPosition.left + offset2.left,
      top: currentPosition.top + offset2.top
    };
    move(this._draggableElement, newPosition);
  }
};
var m_popup_drag_default = PopupDrag;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popup/m_popup_overflow_manager.js
var overflowManagerMock = {
  setOverflow: noop2,
  restoreOverflow: noop2
};
var createBodyOverflowManager = () => {
  if (!hasWindow()) {
    return overflowManagerMock;
  }
  const window28 = getWindow();
  const {
    documentElement
  } = dom_adapter_default.getDocument();
  const body = dom_adapter_default.getBody();
  const isIosDevice = "ios" === devices_default.real().platform;
  const prevSettings = {
    overflow: null,
    overflowX: null,
    overflowY: null,
    paddingRight: null,
    position: null,
    top: null,
    left: null
  };
  return {
    setOverflow: isIosDevice ? () => {
      if (isDefined(prevSettings.position) || "fixed" === body.style.position) {
        return;
      }
      const {
        scrollY,
        scrollX
      } = window28;
      prevSettings.position = body.style.position;
      prevSettings.top = body.style.top;
      prevSettings.left = body.style.left;
      body.style.setProperty("position", "fixed");
      body.style.setProperty("top", -scrollY + "px");
      body.style.setProperty("left", -scrollX + "px");
    } : () => {
      (() => {
        const scrollBarWidth = window28.innerWidth - documentElement.clientWidth;
        if (prevSettings.paddingRight || scrollBarWidth <= 0) {
          return;
        }
        const paddingRight = window28.getComputedStyle(body).getPropertyValue("padding-right");
        const computedBodyPaddingRight = parseInt(paddingRight, 10);
        prevSettings.paddingRight = computedBodyPaddingRight;
        body.style.setProperty("padding-right", `${computedBodyPaddingRight + scrollBarWidth}px`);
      })();
      if (prevSettings.overflow || "hidden" === body.style.overflow) {
        return;
      }
      prevSettings.overflow = body.style.overflow;
      prevSettings.overflowX = body.style.overflowX;
      prevSettings.overflowY = body.style.overflowY;
      body.style.setProperty("overflow", "hidden");
    },
    restoreOverflow: isIosDevice ? () => {
      if (!isDefined(prevSettings.position)) {
        return;
      }
      const scrollY = -parseInt(body.style.top, 10);
      const scrollX = -parseInt(body.style.left, 10);
      ["position", "top", "left"].forEach((property) => {
        if (prevSettings[property]) {
          body.style.setProperty(property, prevSettings[property]);
        } else {
          body.style.removeProperty(property);
        }
      });
      window28.scrollTo(scrollX, scrollY);
      prevSettings.position = null;
    } : () => {
      (() => {
        if (!isDefined(prevSettings.paddingRight)) {
          return;
        }
        if (prevSettings.paddingRight) {
          body.style.setProperty("padding-right", `${prevSettings.paddingRight}px`);
        } else {
          body.style.removeProperty("padding-right");
        }
        prevSettings.paddingRight = null;
      })();
      ["overflow", "overflowX", "overflowY"].forEach((property) => {
        if (!isDefined(prevSettings[property])) {
          return;
        }
        const propertyInKebabCase = property.replace(/(X)|(Y)/, (symbol) => `-${symbol.toLowerCase()}`);
        if (prevSettings[property]) {
          body.style.setProperty(propertyInKebabCase, prevSettings[property]);
        } else {
          body.style.removeProperty(propertyInKebabCase);
        }
        prevSettings[property] = null;
      });
    }
  };
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popup/m_popup_position_controller.js
var _excluded9 = ["fullScreen", "forceApplyBindings", "dragOutsideBoundary", "dragAndResizeArea", "outsideDragFactor"];
var window18 = getWindow();
var PopupPositionController = class extends OverlayPositionController {
  constructor(_ref) {
    let {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    } = _ref, args = _objectWithoutPropertiesLoose(_ref, _excluded9);
    super(args);
    this._props = _extends({}, this._props, {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    });
    this._$dragResizeContainer = void 0;
    this._updateDragResizeContainer();
  }
  set fullScreen(fullScreen) {
    this._props.fullScreen = fullScreen;
    if (fullScreen) {
      this._fullScreenEnabled();
    } else {
      this._fullScreenDisabled();
    }
  }
  get $dragResizeContainer() {
    return this._$dragResizeContainer;
  }
  get outsideDragFactor() {
    if (this._props.dragOutsideBoundary) {
      return 1;
    }
    return this._props.outsideDragFactor;
  }
  set dragAndResizeArea(dragAndResizeArea) {
    this._props.dragAndResizeArea = dragAndResizeArea;
    this._updateDragResizeContainer();
  }
  set dragOutsideBoundary(dragOutsideBoundary) {
    this._props.dragOutsideBoundary = dragOutsideBoundary;
    this._updateDragResizeContainer();
  }
  set outsideDragFactor(outsideDragFactor) {
    this._props.outsideDragFactor = outsideDragFactor;
  }
  updateContainer(containerProp) {
    super.updateContainer(containerProp);
    this._updateDragResizeContainer();
  }
  dragHandled() {
    this.restorePositionOnNextRender(false);
  }
  resizeHandled() {
    this.restorePositionOnNextRender(false);
  }
  positionContent() {
    if (this._props.fullScreen) {
      move(this._$content, {
        top: 0,
        left: 0
      });
      this.detectVisualPositionChange();
    } else {
      var _this$_props$forceApp, _this$_props;
      null === (_this$_props$forceApp = (_this$_props = this._props).forceApplyBindings) || void 0 === _this$_props$forceApp || _this$_props$forceApp.call(_this$_props);
      super.positionContent();
    }
  }
  _updateDragResizeContainer() {
    this._$dragResizeContainer = this._getDragResizeContainer();
  }
  _getDragResizeContainer() {
    if (this._props.dragOutsideBoundary) {
      return renderer_default(window18);
    }
    if (this._props.dragAndResizeArea) {
      return renderer_default(this._props.dragAndResizeArea);
    }
    const isContainerDefined = originalViewPort().get(0) || this._props.container;
    return isContainerDefined ? this._$markupContainer : renderer_default(window18);
  }
  _getVisualContainer() {
    if (this._props.fullScreen) {
      return renderer_default(window18);
    }
    return super._getVisualContainer();
  }
  _fullScreenEnabled() {
    this.restorePositionOnNextRender(false);
  }
  _fullScreenDisabled() {
    this.restorePositionOnNextRender(true);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popup/m_popup.js
var window19 = getWindow();
var ALLOWED_TOOLBAR_ITEM_ALIASES = ["cancel", "clear", "done"];
var IS_OLD_SAFARI = browser_default.safari && compare(browser_default.version, [11]) < 0;
var HEIGHT_STRATEGIES = {
  static: "",
  inherit: "dx-popup-inherit-height",
  flex: "dx-popup-flex-height"
};
var getButtonPlace = (name2) => {
  const device = devices_default.current();
  const {
    platform
  } = device;
  let toolbar = "bottom";
  let location = "before";
  if ("ios" === platform) {
    switch (name2) {
      case "cancel":
        toolbar = "top";
        break;
      case "clear":
        toolbar = "top";
        location = "after";
        break;
      case "done":
        location = "after";
    }
  } else if ("android" === platform) {
    switch (name2) {
      case "cancel":
      case "done":
        location = "after";
    }
  }
  return {
    toolbar,
    location
  };
};
var Popup = ui_overlay_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), {
      upArrow: (e) => {
        var _this$_drag;
        null === (_this$_drag = this._drag) || void 0 === _this$_drag || _this$_drag.moveUp(e);
      },
      downArrow: (e) => {
        var _this$_drag2;
        null === (_this$_drag2 = this._drag) || void 0 === _this$_drag2 || _this$_drag2.moveDown(e);
      },
      leftArrow: (e) => {
        var _this$_drag3;
        null === (_this$_drag3 = this._drag) || void 0 === _this$_drag3 || _this$_drag3.moveLeft(e);
      },
      rightArrow: (e) => {
        var _this$_drag4;
        null === (_this$_drag4 = this._drag) || void 0 === _this$_drag4 || _this$_drag4.moveRight(e);
      }
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      fullScreen: false,
      title: "",
      showTitle: true,
      titleTemplate: "title",
      onTitleRendered: null,
      dragOutsideBoundary: false,
      dragEnabled: false,
      dragAndResizeArea: void 0,
      enableBodyScroll: true,
      outsideDragFactor: 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      resizeEnabled: false,
      toolbarItems: [],
      showCloseButton: false,
      bottomTemplate: "bottom",
      useDefaultToolbarButtons: false,
      useFlatToolbarButtons: false,
      autoResizeEnabled: true
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: {
        platform: "ios"
      },
      options: {
        animation: this._iosAnimation
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        animation: this._androidAnimation
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        showCloseButton: true
      }
    }, {
      device: (device) => "desktop" === devices_default.real().deviceType && "generic" === device.platform,
      options: {
        dragEnabled: true
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useFlatToolbarButtons: true
      }
    }, {
      device: () => isMaterial(),
      options: {
        useDefaultToolbarButtons: true,
        showCloseButton: false
      }
    }]);
  },
  _iosAnimation: {
    show: {
      type: "slide",
      duration: 400,
      from: {
        position: {
          my: "top",
          at: "bottom"
        }
      },
      to: {
        position: {
          my: "center",
          at: "center"
        }
      }
    },
    hide: {
      type: "slide",
      duration: 400,
      from: {
        opacity: 1,
        position: {
          my: "center",
          at: "center"
        }
      },
      to: {
        opacity: 1,
        position: {
          my: "top",
          at: "bottom"
        }
      }
    }
  },
  _androidAnimation() {
    return this.option("fullScreen") ? {
      show: {
        type: "slide",
        duration: 300,
        from: {
          top: "30%",
          opacity: 0
        },
        to: {
          top: 0,
          opacity: 1
        }
      },
      hide: {
        type: "slide",
        duration: 300,
        from: {
          top: 0,
          opacity: 1
        },
        to: {
          top: "30%",
          opacity: 0
        }
      }
    } : {
      show: {
        type: "fade",
        duration: 400,
        from: 0,
        to: 1
      },
      hide: {
        type: "fade",
        duration: 400,
        from: 1,
        to: 0
      }
    };
  },
  _init() {
    const popupWrapperClassExternal = this.option("_wrapperClassExternal");
    const popupWrapperClasses = popupWrapperClassExternal ? `dx-popup-wrapper ${popupWrapperClassExternal}` : "dx-popup-wrapper";
    this.callBase();
    this._createBodyOverflowManager();
    this._updateResizeCallbackSkipCondition();
    this.$element().addClass("dx-popup");
    this.$wrapper().addClass(popupWrapperClasses);
    this._$popupContent = this._$content.wrapInner(renderer_default("<div>").addClass("dx-popup-content")).children().eq(0);
    this._toggleContentScrollClass();
    this.$overlayContent().attr("role", "dialog");
  },
  _render() {
    const isFullscreen = this.option("fullScreen");
    this._toggleFullScreenClass(isFullscreen);
    this.callBase();
  },
  _createBodyOverflowManager() {
    this._bodyOverflowManager = createBodyOverflowManager();
  },
  _toggleFullScreenClass(value2) {
    this.$overlayContent().toggleClass("dx-popup-fullscreen", value2).toggleClass("dx-popup-normal", !value2);
  },
  _initTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      title: new EmptyTemplate(),
      bottom: new EmptyTemplate()
    });
  },
  _getActionsList() {
    return this.callBase().concat(["onResizeStart", "onResize", "onResizeEnd"]);
  },
  _contentResizeHandler(entry) {
    if (!this._shouldSkipContentResize(entry)) {
      this._renderGeometry({
        shouldOnlyReposition: true
      });
    }
  },
  _doesShowAnimationChangeDimensions() {
    const animation3 = this.option("animation");
    return ["to", "from"].some((prop) => {
      var _animation$show;
      const config3 = null === animation3 || void 0 === animation3 || null === (_animation$show = animation3.show) || void 0 === _animation$show ? void 0 : _animation$show[prop];
      return isObject(config3) && ("width" in config3 || "height" in config3);
    });
  },
  _updateResizeCallbackSkipCondition() {
    const doesShowAnimationChangeDimensions = this._doesShowAnimationChangeDimensions();
    this._shouldSkipContentResize = (entry) => doesShowAnimationChangeDimensions && this._showAnimationProcessing || this._areContentDimensionsRendered(entry);
  },
  _observeContentResize(shouldObserve) {
    if (!this.option("useResizeObserver")) {
      return;
    }
    const contentElement = this._$content.get(0);
    if (shouldObserve) {
      resize_observer_default.observe(contentElement, (entry) => {
        this._contentResizeHandler(entry);
      });
    } else {
      resize_observer_default.unobserve(contentElement);
    }
  },
  _areContentDimensionsRendered(entry) {
    var _entry$contentBoxSize, _this$_renderedDimens3, _this$_renderedDimens4;
    const contentBox = null === (_entry$contentBoxSize = entry.contentBoxSize) || void 0 === _entry$contentBoxSize ? void 0 : _entry$contentBoxSize[0];
    if (contentBox) {
      var _this$_renderedDimens, _this$_renderedDimens2;
      return parseInt(contentBox.inlineSize, 10) === (null === (_this$_renderedDimens = this._renderedDimensions) || void 0 === _this$_renderedDimens ? void 0 : _this$_renderedDimens.width) && parseInt(contentBox.blockSize, 10) === (null === (_this$_renderedDimens2 = this._renderedDimensions) || void 0 === _this$_renderedDimens2 ? void 0 : _this$_renderedDimens2.height);
    }
    const {
      contentRect
    } = entry;
    return parseInt(contentRect.width, 10) === (null === (_this$_renderedDimens3 = this._renderedDimensions) || void 0 === _this$_renderedDimens3 ? void 0 : _this$_renderedDimens3.width) && parseInt(contentRect.height, 10) === (null === (_this$_renderedDimens4 = this._renderedDimensions) || void 0 === _this$_renderedDimens4 ? void 0 : _this$_renderedDimens4.height);
  },
  _renderContent() {
    this.callBase();
    this._observeContentResize(true);
  },
  _renderContentImpl() {
    this._renderTitle();
    this.callBase();
    this._renderResize();
    this._renderBottom();
  },
  _renderTitle() {
    const items = this._getToolbarItems("top");
    const {
      title,
      showTitle
    } = this.option();
    if (showTitle && !!title) {
      items.unshift({
        location: devices_default.current().ios ? "center" : "before",
        text: title
      });
    }
    if (showTitle || items.length > 0) {
      this._$title && this._$title.remove();
      const $title = renderer_default("<div>").addClass("dx-popup-title").insertBefore(this.$content());
      this._$title = this._renderTemplateByType("titleTemplate", items, $title).addClass("dx-popup-title");
      this._renderDrag();
      this._executeTitleRenderAction(this._$title);
      this._$title.toggleClass("dx-has-close-button", this._hasCloseButton());
    } else if (this._$title) {
      this._$title.detach();
    }
    this._toggleAriaLabel();
  },
  _toggleAriaLabel() {
    var _this$_$title;
    const {
      title,
      showTitle
    } = this.option();
    const shouldSetAriaLabel = showTitle && !!title;
    const titleId = shouldSetAriaLabel ? new guid_default() : null;
    null === (_this$_$title = this._$title) || void 0 === _this$_$title || _this$_$title.find(".dx-toolbar-label").eq(0).attr("id", titleId);
    this.$overlayContent().attr("aria-labelledby", titleId);
  },
  _renderTemplateByType(optionName, data2, $container, additionalToolbarOptions) {
    const {
      rtlEnabled,
      useDefaultToolbarButtons,
      useFlatToolbarButtons,
      disabled
    } = this.option();
    const template = this._getTemplateByOption(optionName);
    const toolbarTemplate = template instanceof EmptyTemplate;
    if (toolbarTemplate) {
      const integrationOptions = extend({}, this.option("integrationOptions"), {
        skipTemplates: ["content", "title"]
      });
      const toolbarOptions = extend(additionalToolbarOptions, {
        items: data2,
        rtlEnabled,
        useDefaultButtons: useDefaultToolbarButtons,
        useFlatButtons: useFlatToolbarButtons,
        disabled,
        integrationOptions
      });
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: {
          widget: this._getToolbarName(),
          options: toolbarOptions
        }
      });
      const $toolbar = $container.children("div");
      $container.replaceWith($toolbar);
      return $toolbar;
    }
    const $result = renderer_default(template.render({
      container: getPublicElement($container)
    }));
    if ($result.hasClass("dx-template-wrapper")) {
      $container.replaceWith($result);
      $container = $result;
    }
    return $container;
  },
  _getToolbarName: () => "dxToolbarBase",
  _renderVisibilityAnimate(visible2) {
    return this.callBase(visible2);
  },
  _hide() {
    this._observeContentResize(false);
    return this.callBase();
  },
  _executeTitleRenderAction($titleElement) {
    this._getTitleRenderAction()({
      titleElement: getPublicElement($titleElement)
    });
  },
  _getTitleRenderAction() {
    return this._titleRenderAction || this._createTitleRenderAction();
  },
  _createTitleRenderAction() {
    return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _getCloseButton() {
    return {
      toolbar: "top",
      location: "after",
      template: this._getCloseButtonRenderer()
    };
  },
  _getCloseButtonRenderer() {
    return (_, __, container) => {
      const $button = renderer_default("<div>").addClass("dx-closebutton");
      this._createComponent($button, button_default, {
        icon: "close",
        onClick: this._createToolbarItemAction(void 0),
        stylingMode: "text",
        integrationOptions: {}
      });
      renderer_default(container).append($button);
    };
  },
  _getToolbarItems(toolbar) {
    const toolbarItems = this.option("toolbarItems");
    const toolbarsItems = [];
    this._toolbarItemClasses = [];
    const currentPlatform = devices_default.current().platform;
    let index2 = 0;
    each(toolbarItems, (_, data2) => {
      const isShortcut = isDefined(data2.shortcut);
      const item = isShortcut ? getButtonPlace(data2.shortcut) : data2;
      if (isShortcut && "ios" === currentPlatform && index2 < 2) {
        item.toolbar = "top";
        index2++;
      }
      item.toolbar = data2.toolbar || item.toolbar || "top";
      if (item && item.toolbar === toolbar) {
        if (isShortcut) {
          extend(item, {
            location: data2.location
          }, this._getToolbarItemByAlias(data2));
        }
        const isLTROrder = "generic" === currentPlatform;
        if ("done" === data2.shortcut && isLTROrder || "cancel" === data2.shortcut && !isLTROrder) {
          toolbarsItems.unshift(item);
        } else {
          toolbarsItems.push(item);
        }
      }
    });
    if ("top" === toolbar && this._hasCloseButton()) {
      toolbarsItems.push(this._getCloseButton());
    }
    return toolbarsItems;
  },
  _hasCloseButton() {
    return this.option("showCloseButton") && this.option("showTitle");
  },
  _getLocalizationKey: (itemType) => "done" === itemType.toLowerCase() ? "OK" : camelize(itemType, true),
  _getToolbarButtonStylingMode(shortcut) {
    if (isFluent()) {
      return "done" === shortcut ? "contained" : "outlined";
    }
    return this.option("useFlatToolbarButtons") ? "text" : "contained";
  },
  _getToolbarButtonType(shortcut) {
    if (isFluent() && "done" === shortcut || this.option("useDefaultToolbarButtons")) {
      return "default";
    }
    return "normal";
  },
  _getToolbarItemByAlias(data2) {
    const that = this;
    const itemType = data2.shortcut;
    if (!ALLOWED_TOOLBAR_ITEM_ALIASES.includes(itemType)) {
      return false;
    }
    const itemConfig = extend({
      text: message_default.format(this._getLocalizationKey(itemType)),
      onClick: this._createToolbarItemAction(data2.onClick),
      integrationOptions: {},
      type: this._getToolbarButtonType(itemType),
      stylingMode: this._getToolbarButtonStylingMode(itemType)
    }, data2.options || {});
    const itemClass = `dx-popup-${itemType}`;
    this._toolbarItemClasses.push(itemClass);
    return {
      template(_, __, container) {
        const $toolbarItem = renderer_default("<div>").addClass(itemClass).appendTo(container);
        that._createComponent($toolbarItem, button_default, itemConfig);
      }
    };
  },
  _createToolbarItemAction(clickAction) {
    return this._createAction(clickAction, {
      afterExecute(e) {
        e.component.hide();
      }
    });
  },
  _renderBottom() {
    const items = this._getToolbarItems("bottom");
    if (items.length) {
      this._$bottom && this._$bottom.remove();
      const $bottom = renderer_default("<div>").addClass("dx-popup-bottom").insertAfter(this.$content());
      this._$bottom = this._renderTemplateByType("bottomTemplate", items, $bottom, {
        compactMode: true
      }).addClass("dx-popup-bottom");
      this._toggleClasses();
    } else {
      this._$bottom && this._$bottom.detach();
    }
  },
  _toggleDisabledState(value2) {
    this.callBase(...arguments);
    this.$content().toggleClass("dx-state-disabled", Boolean(value2));
  },
  _toggleClasses() {
    const aliases = ALLOWED_TOOLBAR_ITEM_ALIASES;
    each(aliases, (_, alias) => {
      const className = `dx-popup-${alias}`;
      if (this._toolbarItemClasses.includes(className)) {
        this.$wrapper().addClass(`${className}-visible`);
        this._$bottom.addClass(className);
      } else {
        this.$wrapper().removeClass(`${className}-visible`);
        this._$bottom.removeClass(className);
      }
    });
  },
  _toggleFocusClass(isFocused, $element) {
    this.callBase(isFocused, $element);
    if (isFocused && !isLastZIndexInStack(this._zIndex)) {
      const zIndex = create(this._zIndexInitValue());
      remove4(this._zIndex);
      this._zIndex = zIndex;
      this._$wrapper.css("zIndex", zIndex);
      this._$content.css("zIndex", zIndex);
    }
  },
  _toggleContentScrollClass() {
    const isNativeScrollingEnabled = !this.option("preventScrollEvents");
    this.$content().toggleClass("dx-popup-content-scrollable", isNativeScrollingEnabled);
  },
  _getPositionControllerConfig() {
    const {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    } = this.option();
    return extend({}, this.callBase(), {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    });
  },
  _initPositionController() {
    this._positionController = new PopupPositionController(this._getPositionControllerConfig());
  },
  _getDragTarget() {
    return this.topToolbar();
  },
  _renderGeometry(options2) {
    const {
      visible: visible2,
      useResizeObserver
    } = this.option();
    if (visible2 && hasWindow()) {
      const isAnimated = this._showAnimationProcessing;
      const shouldRepeatAnimation = isAnimated && !(null !== options2 && void 0 !== options2 && options2.forceStopAnimation) && useResizeObserver;
      this._isAnimationPaused = shouldRepeatAnimation || void 0;
      this._stopAnimation();
      if (null !== options2 && void 0 !== options2 && options2.shouldOnlyReposition) {
        this._renderPosition(false);
      } else {
        this._renderGeometryImpl(null === options2 || void 0 === options2 ? void 0 : options2.isDimensionChange);
      }
      if (shouldRepeatAnimation) {
        this._animateShowing();
        this._isAnimationPaused = void 0;
      }
    }
  },
  _cacheDimensions() {
    if (!this.option("useResizeObserver")) {
      return;
    }
    this._renderedDimensions = {
      width: parseInt(getWidth(this._$content), 10),
      height: parseInt(getHeight(this._$content), 10)
    };
  },
  _renderGeometryImpl() {
    let isDimensionChange = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    if (!isDimensionChange) {
      this._resetContentHeight();
    }
    this.callBase();
    this._cacheDimensions();
    this._setContentHeight();
  },
  _resetContentHeight() {
    const height = this._getOptionValue("height");
    if ("auto" === height) {
      this.$content().css({
        height: "auto",
        maxHeight: "none"
      });
    }
  },
  _renderDrag() {
    const $dragTarget = this._getDragTarget();
    const dragEnabled = this.option("dragEnabled");
    if (!$dragTarget) {
      return;
    }
    const config3 = {
      dragEnabled,
      handle: $dragTarget.get(0),
      draggableElement: this._$content.get(0),
      positionController: this._positionController
    };
    if (this._drag) {
      this._drag.init(config3);
    } else {
      this._drag = new m_popup_drag_default(config3);
    }
    this.$overlayContent().toggleClass("dx-popup-draggable", dragEnabled);
  },
  _renderResize() {
    this._resizable = this._createComponent(this._$content, resizable_default, {
      handles: this.option("resizeEnabled") ? "all" : "none",
      onResizeEnd: (e) => {
        this._resizeEndHandler(e);
        this._observeContentResize(true);
      },
      onResize: (e) => {
        this._setContentHeight();
        this._actions.onResize(e);
      },
      onResizeStart: (e) => {
        this._observeContentResize(false);
        this._actions.onResizeStart(e);
      },
      minHeight: 100,
      minWidth: 100,
      area: this._positionController.$dragResizeContainer,
      keepAspectRatio: false
    });
  },
  _resizeEndHandler(e) {
    const width = this._resizable.option("width");
    const height = this._resizable.option("height");
    width && this._setOptionWithoutOptionChange("width", width);
    height && this._setOptionWithoutOptionChange("height", height);
    this._cacheDimensions();
    this._positionController.resizeHandled();
    this._positionController.detectVisualPositionChange(e.event);
    this._actions.onResizeEnd(e);
  },
  _setContentHeight() {
    (this.option("forceApplyBindings") || noop2)();
    const overlayContent = this.$overlayContent().get(0);
    const currentHeightStrategyClass = this._chooseHeightStrategy(overlayContent);
    this.$content().css(this._getHeightCssStyles(currentHeightStrategyClass, overlayContent));
    this._setHeightClasses(this.$overlayContent(), currentHeightStrategyClass);
  },
  _heightStrategyChangeOffset: (currentHeightStrategyClass, popupVerticalPaddings) => currentHeightStrategyClass === HEIGHT_STRATEGIES.flex ? -popupVerticalPaddings : 0,
  _chooseHeightStrategy(overlayContent) {
    const isAutoWidth = "auto" === overlayContent.style.width || "" === overlayContent.style.width;
    let currentHeightStrategyClass = HEIGHT_STRATEGIES.static;
    if (this._isAutoHeight() && this.option("autoResizeEnabled")) {
      if (isAutoWidth || IS_OLD_SAFARI) {
        currentHeightStrategyClass = HEIGHT_STRATEGIES.inherit;
      } else {
        currentHeightStrategyClass = HEIGHT_STRATEGIES.flex;
      }
    }
    return currentHeightStrategyClass;
  },
  _getHeightCssStyles(currentHeightStrategyClass, overlayContent) {
    let cssStyles = {};
    const contentMaxHeight = this._getOptionValue("maxHeight", overlayContent);
    const contentMinHeight = this._getOptionValue("minHeight", overlayContent);
    const popupHeightParts = this._splitPopupHeight();
    const toolbarsAndVerticalOffsetsHeight = popupHeightParts.header + popupHeightParts.footer + popupHeightParts.contentVerticalOffsets + popupHeightParts.popupVerticalOffsets + this._heightStrategyChangeOffset(currentHeightStrategyClass, popupHeightParts.popupVerticalPaddings);
    if (currentHeightStrategyClass === HEIGHT_STRATEGIES.static) {
      if (!this._isAutoHeight() || contentMaxHeight || contentMinHeight) {
        const overlayHeight = this.option("fullScreen") ? Math.min(getBoundingRect(overlayContent).height, getWindow().innerHeight) : getBoundingRect(overlayContent).height;
        const contentHeight = overlayHeight - toolbarsAndVerticalOffsetsHeight;
        cssStyles = {
          height: Math.max(0, contentHeight),
          minHeight: "auto",
          maxHeight: "auto"
        };
      }
    } else {
      const container = renderer_default(this._positionController.$visualContainer).get(0);
      const maxHeightValue = addOffsetToMaxHeight(contentMaxHeight, -toolbarsAndVerticalOffsetsHeight, container);
      const minHeightValue = addOffsetToMinHeight(contentMinHeight, -toolbarsAndVerticalOffsetsHeight, container);
      cssStyles = {
        height: "auto",
        minHeight: minHeightValue,
        maxHeight: maxHeightValue
      };
    }
    return cssStyles;
  },
  _setHeightClasses($container, currentClass) {
    let excessClasses = "";
    for (const name2 in HEIGHT_STRATEGIES) {
      if (HEIGHT_STRATEGIES[name2] !== currentClass) {
        excessClasses += ` ${HEIGHT_STRATEGIES[name2]}`;
      }
    }
    $container.removeClass(excessClasses).addClass(currentClass);
  },
  _isAutoHeight() {
    return "auto" === this.$overlayContent().get(0).style.height;
  },
  _splitPopupHeight() {
    const topToolbar = this.topToolbar();
    const bottomToolbar = this.bottomToolbar();
    return {
      header: getVisibleHeight(topToolbar && topToolbar.get(0)),
      footer: getVisibleHeight(bottomToolbar && bottomToolbar.get(0)),
      contentVerticalOffsets: getVerticalOffsets(this.$overlayContent().get(0), true),
      popupVerticalOffsets: getVerticalOffsets(this.$content().get(0), true),
      popupVerticalPaddings: getVerticalOffsets(this.$content().get(0), false)
    };
  },
  _isAllWindowCovered() {
    return this.callBase() || this.option("fullScreen");
  },
  _renderDimensions() {
    if (this.option("fullScreen")) {
      this.$overlayContent().css({
        width: "100%",
        height: "100%",
        minWidth: "",
        maxWidth: "",
        minHeight: "",
        maxHeight: ""
      });
    } else {
      this.callBase();
    }
    if (hasWindow()) {
      this._renderFullscreenWidthClass();
    }
  },
  _dimensionChanged() {
    this._renderGeometry({
      isDimensionChange: true
    });
  },
  _clean() {
    this.callBase();
    this._observeContentResize(false);
  },
  _dispose() {
    this.callBase();
    this._toggleBodyScroll(true);
  },
  _renderFullscreenWidthClass() {
    this.$overlayContent().toggleClass("dx-popup-fullscreen-width", getOuterWidth(this.$overlayContent()) === getWidth(window19));
  },
  _toggleSafariScrolling() {
    if (!this.option("enableBodyScroll")) {
      return;
    }
    this.callBase();
  },
  _toggleBodyScroll(enabled) {
    if (!this._bodyOverflowManager) {
      return;
    }
    const {
      setOverflow,
      restoreOverflow
    } = this._bodyOverflowManager;
    if (enabled) {
      restoreOverflow();
    } else {
      setOverflow();
    }
  },
  refreshPosition() {
    this._renderPosition();
  },
  _optionChanged(args) {
    var _this$_resizable2;
    const {
      value: value2,
      name: name2
    } = args;
    switch (name2) {
      case "disabled":
        this.callBase(args);
        this._renderTitle();
        this._renderBottom();
        break;
      case "animation":
        this._updateResizeCallbackSkipCondition();
        break;
      case "enableBodyScroll":
        if (this.option("visible")) {
          this._toggleBodyScroll(value2);
        }
        break;
      case "showTitle":
      case "title":
      case "titleTemplate":
        this._renderTitle();
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "bottomTemplate":
        this._renderBottom();
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "container":
        this.callBase(args);
        if (this.option("resizeEnabled")) {
          var _this$_resizable;
          null === (_this$_resizable = this._resizable) || void 0 === _this$_resizable || _this$_resizable.option("area", this._positionController.$dragResizeContainer);
        }
        break;
      case "width":
      case "height":
        this.callBase(args);
        null === (_this$_resizable2 = this._resizable) || void 0 === _this$_resizable2 || _this$_resizable2.option(name2, value2);
        break;
      case "onTitleRendered":
        this._createTitleRenderAction(value2);
        break;
      case "toolbarItems":
      case "useDefaultToolbarButtons":
      case "useFlatToolbarButtons": {
        const shouldRenderGeometry = !args.fullName.match(/^toolbarItems((\[\d+\])(\.(options|visible).*)?)?$/);
        this._renderTitle();
        this._renderBottom();
        if (shouldRenderGeometry) {
          this._renderGeometry();
          triggerResizeEvent(this.$overlayContent());
        }
        break;
      }
      case "dragEnabled":
        this._renderDrag();
        break;
      case "dragAndResizeArea":
        this._positionController.dragAndResizeArea = value2;
        if (this.option("resizeEnabled")) {
          this._resizable.option("area", this._positionController.$dragResizeContainer);
        }
        this._positionController.positionContent();
        break;
      case "dragOutsideBoundary":
        this._positionController.dragOutsideBoundary = value2;
        if (this.option("resizeEnabled")) {
          this._resizable.option("area", this._positionController.$dragResizeContainer);
        }
        break;
      case "outsideDragFactor":
        this._positionController.outsideDragFactor = value2;
        break;
      case "resizeEnabled":
        this._renderResize();
        this._renderGeometry();
        break;
      case "autoResizeEnabled":
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "fullScreen":
        this._positionController.fullScreen = value2;
        this._toggleFullScreenClass(value2);
        this._toggleSafariScrolling();
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "showCloseButton":
        this._renderTitle();
        break;
      case "preventScrollEvents":
        this.callBase(args);
        this._toggleContentScrollClass();
        break;
      default:
        this.callBase(args);
    }
  },
  bottomToolbar() {
    return this._$bottom;
  },
  topToolbar() {
    return this._$title;
  },
  $content() {
    return this._$popupContent;
  },
  content() {
    return getPublicElement(this.$content());
  },
  $overlayContent() {
    return this._$content;
  },
  getFocusableElements() {
    return this.$wrapper().find("[tabindex]").filter((index2, item) => item.getAttribute("tabindex") >= 0);
  }
});
component_registrator_default("dxPopup", Popup);
var m_popup_default = Popup;

// ../../../../../../node_modules/devextreme/esm/ui/popup/ui.popup.js
var ui_popup_default = m_popup_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_dialog.js
var window20 = getWindow();
var DEFAULT_BUTTON = {
  text: "OK",
  onClick: () => true
};
var custom = function(options2) {
  const deferred = Deferred();
  options2 = options2 || {};
  const $element = renderer_default("<div>").addClass("dx-dialog").appendTo(value());
  const isMessageDefined = "message" in options2;
  const isMessageHtmlDefined = "messageHtml" in options2;
  if (isMessageDefined) {
    ui_errors_default.log("W1013");
  }
  const messageHtml = String(isMessageHtmlDefined ? options2.messageHtml : options2.message);
  const messageId = options2.title ? null : new guid_default();
  const $message = renderer_default("<div>").addClass("dx-dialog-message").html(messageHtml).attr("id", messageId);
  const popupToolbarItems = [];
  const popupInstance = new ui_popup_default($element, extend({
    title: options2.title ?? "",
    showTitle: ensureDefined(options2.showTitle, true),
    dragEnabled: ensureDefined(options2.dragEnabled, true),
    height: "auto",
    width: options2.width,
    showCloseButton: options2.showCloseButton || false,
    ignoreChildEvents: false,
    container: $element,
    visualContainer: window20,
    dragAndResizeArea: window20,
    onContentReady(args) {
      args.component.$content().addClass("dx-dialog-content").append($message);
      if (messageId) {
        args.component.$overlayContent().attr("aria-labelledby", messageId);
      }
    },
    onShowing(e) {
      e.component.bottomToolbar().addClass("dx-dialog-buttons").find(".dx-button").addClass("dx-dialog-button");
      resetActiveElement();
    },
    onShown(e) {
      const $firstButton = e.component.bottomToolbar().find(".dx-button").first();
      events_engine_default.trigger($firstButton, "focus");
    },
    onHiding() {
      deferred.reject();
    },
    onHidden(_ref) {
      let {
        element
      } = _ref;
      renderer_default(element).remove();
    },
    animation: {
      show: {
        type: "pop",
        duration: 400
      },
      hide: {
        type: "pop",
        duration: 400,
        to: {
          opacity: 0,
          scale: 0
        },
        from: {
          opacity: 1,
          scale: 1
        }
      }
    },
    rtlEnabled: config_default().rtlEnabled,
    position: {
      boundaryOffset: {
        h: 10,
        v: 0
      }
    }
  }, options2.popupOptions));
  const buttonOptions = options2.buttons || [DEFAULT_BUTTON];
  buttonOptions.forEach((options3) => {
    const action = new Action(options3.onClick, {
      context: popupInstance
    });
    popupToolbarItems.push({
      toolbar: "bottom",
      location: devices_default.current().android ? "after" : "center",
      widget: "dxButton",
      options: _extends({}, options3, {
        onClick() {
          const result2 = action.execute(...arguments);
          hide3(result2);
        }
      })
    });
  });
  popupInstance.option("toolbarItems", popupToolbarItems);
  popupInstance.$wrapper().addClass("dx-dialog-wrapper");
  if (options2.position) {
    popupInstance.option("position", options2.position);
  }
  popupInstance.$wrapper().addClass("dx-dialog-root");
  function hide3(value2) {
    deferred.resolve(value2);
    popupInstance.hide();
  }
  return {
    show: function() {
      if ("phone" === devices_default.real().deviceType) {
        const isPortrait = getHeight(window20) > getWidth(window20);
        const width = isPortrait ? "90%" : "60%";
        popupInstance.option({
          width
        });
      }
      popupInstance.show();
      return deferred.promise();
    },
    hide: hide3
  };
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/utils/date.js
var addOffsets = (date, offsets) => {
  const newDateMs = offsets.reduce((result2, offset2) => result2 + offset2, date.getTime());
  return new Date(newDateMs);
};
var dateUtilsTs = {
  addOffsets
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/timezone_calculator/const.js
var PathTimeZoneConversion;
!function(PathTimeZoneConversion2) {
  PathTimeZoneConversion2.fromSourceToAppointment = "toAppointment";
  PathTimeZoneConversion2.fromAppointmentToSource = "fromAppointment";
  PathTimeZoneConversion2.fromSourceToGrid = "toGrid";
  PathTimeZoneConversion2.fromGridToSource = "fromGrid";
}(PathTimeZoneConversion || (PathTimeZoneConversion = {}));

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/timezone_calculator/calculator.js
var toMs = date_default.dateToMilliseconds;
var TimeZoneCalculator = class {
  constructor(options2) {
    this.options = options2;
  }
  createDate(sourceDate, info) {
    const date = new Date(sourceDate);
    switch (info.path) {
      case PathTimeZoneConversion.fromSourceToAppointment:
        return this.getConvertedDate(date, info.appointmentTimeZone, true, false);
      case PathTimeZoneConversion.fromAppointmentToSource:
        return this.getConvertedDate(date, info.appointmentTimeZone, true, true);
      case PathTimeZoneConversion.fromSourceToGrid:
        return this.getConvertedDate(date, info.appointmentTimeZone, false, false);
      case PathTimeZoneConversion.fromGridToSource:
        return this.getConvertedDate(date, info.appointmentTimeZone, false, true);
      default:
        throw new Error("not specified pathTimeZoneConversion");
    }
  }
  getOffsets(date, appointmentTimezone) {
    const clientOffset = -this.getClientOffset(date) / date_default.dateToMilliseconds("hour");
    const commonOffset = this.getCommonOffset(date);
    const appointmentOffset = this.getAppointmentOffset(date, appointmentTimezone);
    return {
      client: clientOffset,
      common: !isDefined(commonOffset) ? clientOffset : commonOffset,
      appointment: "number" !== typeof appointmentOffset ? clientOffset : appointmentOffset
    };
  }
  getConvertedDateByOffsets(date, clientOffset, targetOffset, isBack) {
    const direction = isBack ? -1 : 1;
    const resultDate = new Date(date);
    return dateUtilsTs.addOffsets(resultDate, [direction * (toMs("hour") * targetOffset), -direction * (toMs("hour") * clientOffset)]);
  }
  getOriginStartDateOffsetInMs(date, timezone, isUTCDate) {
    const offsetInHours = this.getOffsetInHours(date, timezone, isUTCDate);
    return 36e5 * offsetInHours;
  }
  getOffsetInHours(date, timezone, isUTCDate) {
    const {
      client,
      appointment,
      common: common2
    } = this.getOffsets(date, timezone);
    if (!!timezone && isUTCDate) {
      return appointment - client;
    }
    if (!!timezone && !isUTCDate) {
      return appointment - common2;
    }
    if (!timezone && isUTCDate) {
      return common2 - client;
    }
    return 0;
  }
  getClientOffset(date) {
    return this.options.getClientOffset(date);
  }
  getCommonOffset(date) {
    return this.options.tryGetCommonOffset(date);
  }
  getAppointmentOffset(date, appointmentTimezone) {
    return this.options.tryGetAppointmentOffset(date, appointmentTimezone);
  }
  getConvertedDate(date, appointmentTimezone, useAppointmentTimeZone, isBack) {
    const newDate = new Date(date.getTime());
    const offsets = this.getOffsets(newDate, appointmentTimezone);
    if (useAppointmentTimeZone && !!appointmentTimezone) {
      return this.getConvertedDateByOffsets(date, offsets.client, offsets.appointment, isBack);
    }
    return this.getConvertedDateByOffsets(date, offsets.client, offsets.common, isBack);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_date_adapter.js
var toMs2 = date_default.dateToMilliseconds;
var DateAdapterCore = class {
  constructor(source) {
    this._source = new Date(source.getTime ? source.getTime() : source);
  }
  get source() {
    return this._source;
  }
  result() {
    return this._source;
  }
  getTimezoneOffset() {
    let format2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    const value2 = this._source.getTimezoneOffset();
    if ("minute" === format2) {
      return value2 * toMs2("minute");
    }
    return value2;
  }
  getTime() {
    return this._source.getTime();
  }
  setTime(value2) {
    this._source.setTime(value2);
    return this;
  }
  addTime(value2) {
    this._source.setTime(this._source.getTime() + value2);
    return this;
  }
  setMinutes(value2) {
    this._source.setMinutes(value2);
    return this;
  }
  addMinutes(value2) {
    this._source.setMinutes(this._source.getMinutes() + value2);
    return this;
  }
  subtractMinutes(value2) {
    this._source.setMinutes(this._source.getMinutes() - value2);
    return this;
  }
};
var DateAdapter = (date) => new DateAdapterCore(date);
var m_date_adapter_default = DateAdapter;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/timezones/m_utils_timezones_data.js
var getConvertedUntils = (value2) => value2.split("|").map((until) => {
  if ("Infinity" === until) {
    return null;
  }
  return 1e3 * parseInt(until, 36);
});
var parseTimezone = (timeZoneConfig) => {
  const {
    offsets
  } = timeZoneConfig;
  const {
    offsetIndices
  } = timeZoneConfig;
  const {
    untils
  } = timeZoneConfig;
  const offsetList = offsets.split("|").map((value2) => parseInt(value2));
  const offsetIndexList = offsetIndices.split("").map((value2) => parseInt(value2));
  const dateList = getConvertedUntils(untils).map((accumulator = 0, (value2) => accumulator += value2));
  var accumulator;
  return {
    offsetList,
    offsetIndexList,
    dateList
  };
};
var TimeZoneCache = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  tryGet(id) {
    if (!this.map.get(id)) {
      const config3 = timeZoneDataUtils.getTimezoneById(id);
      if (!config3) {
        return false;
      }
      const timeZoneInfo = parseTimezone(config3);
      this.map.set(id, timeZoneInfo);
    }
    return this.map.get(id);
  }
};
var tzCache = new TimeZoneCache();
var timeZoneDataUtils = {
  _tzCache: tzCache,
  getTimeZonesOld: () => config_default().timezones ?? [],
  formatOffset(offset2) {
    const hours = Math.floor(offset2);
    const minutesInDecimal = offset2 - hours;
    const signString = sign(offset2) >= 0 ? "+" : "-";
    const hoursString = `0${Math.abs(hours)}`.slice(-2);
    const minutesString = minutesInDecimal > 0 ? ":" + 60 * minutesInDecimal : ":00";
    return signString + hoursString + minutesString;
  },
  formatId: (id) => id.split("/").join(" - ").split("_").join(" "),
  getTimezoneById(id) {
    if (!id) {
      return;
    }
    const tzList = this.getTimeZonesOld();
    for (let i = 0; i < tzList.length; i++) {
      const currentId = tzList[i].id;
      if (currentId === id) {
        return tzList[i];
      }
    }
    return;
  },
  getTimeZoneOffsetById(id, timestamp) {
    const timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getUtcOffset(timeZoneInfo, timestamp) : void 0;
  },
  getTimeZoneDeclarationTuple(id, year) {
    const timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getTimeZoneDeclarationTupleCore(timeZoneInfo, year) : [];
  },
  getTimeZoneDeclarationTupleCore(timeZoneInfo, year) {
    const {
      offsetList
    } = timeZoneInfo;
    const {
      offsetIndexList
    } = timeZoneInfo;
    const {
      dateList
    } = timeZoneInfo;
    const tupleResult = [];
    for (let i = 0; i < dateList.length; i++) {
      const currentDate = dateList[i];
      const currentYear = new Date(currentDate).getFullYear();
      if (currentYear === year) {
        const offset2 = offsetList[offsetIndexList[i + 1]];
        tupleResult.push({
          date: currentDate,
          offset: -offset2 / 60
        });
      }
      if (currentYear > year) {
        break;
      }
    }
    return tupleResult;
  },
  getUtcOffset(timeZoneInfo, dateTimeStamp) {
    const {
      offsetList
    } = timeZoneInfo;
    const {
      offsetIndexList
    } = timeZoneInfo;
    const {
      dateList
    } = timeZoneInfo;
    const lastIntervalStartIndex = dateList.length - 1 - 1;
    let index2 = lastIntervalStartIndex;
    while (index2 >= 0 && dateTimeStamp < dateList[index2]) {
      index2--;
    }
    const offset2 = offsetList[offsetIndexList[index2 + 1]];
    return -offset2 / 60 || offset2;
  }
};
var m_utils_timezones_data_default = timeZoneDataUtils;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/timezones/timezone_list.js
var timezone_list_default = {
  value: ["Etc/GMT+12", "Etc/GMT+11", "Pacific/Midway", "Pacific/Niue", "Pacific/Pago_Pago", "Pacific/Samoa", "US/Samoa", "Etc/GMT+10", "HST", "Pacific/Honolulu", "Pacific/Johnston", "Pacific/Rarotonga", "Pacific/Tahiti", "US/Hawaii", "Pacific/Marquesas", "America/Adak", "America/Atka", "Etc/GMT+9", "Pacific/Gambier", "US/Aleutian", "America/Anchorage", "America/Juneau", "America/Metlakatla", "America/Nome", "America/Sitka", "America/Yakutat", "Etc/GMT+8", "Pacific/Pitcairn", "US/Alaska", "America/Creston", "America/Dawson_Creek", "America/Dawson", "America/Ensenada", "America/Fort_Nelson", "America/Hermosillo", "America/Los_Angeles", "America/Phoenix", "America/Santa_Isabel", "America/Tijuana", "America/Vancouver", "America/Whitehorse", "Canada/Pacific", "Canada/Yukon", "Etc/GMT+7", "Mexico/BajaNorte", "MST", "PST8PDT", "US/Arizona", "US/Pacific", "America/Belize", "America/Boise", "America/Cambridge_Bay", "America/Chihuahua", "America/Costa_Rica", "America/Denver", "America/Edmonton", "America/El_Salvador", "America/Guatemala", "America/Inuvik", "America/Managua", "America/Mazatlan", "America/Monterrey", "America/Ojinaga", "America/Regina", "America/Shiprock", "America/Swift_Current", "America/Tegucigalpa", "America/Yellowknife", "Canada/Mountain", "Canada/Saskatchewan", "Chile/EasterIsland", "Etc/GMT+6", "Mexico/BajaSur", "MST7MDT", "Navajo", "Pacific/Easter", "Pacific/Galapagos", "US/Mountain", "America/Atikokan", "America/Bahia_Banderas", "America/Bogota", "America/Cancun", "America/Cayman", "America/Chicago", "America/Coral_Harbour", "America/Eirunepe", "America/Guayaquil", "America/Indiana/Knox", "America/Indiana/Tell_City", "America/Jamaica", "America/Knox_IN", "America/Lima", "America/Matamoros", "America/Menominee", "America/Merida", "America/Mexico_City", "America/North_Dakota/Beulah", "America/North_Dakota/Center", "America/North_Dakota/New_Salem", "America/Panama", "America/Porto_Acre", "America/Rainy_River", "America/Rankin_Inlet", "America/Resolute", "America/Rio_Branco", "America/Winnipeg", "Brazil/Acre", "Canada/Central", "CST6CDT", "EST", "Etc/GMT+5", "Jamaica", "Mexico/General", "US/Central", "US/Indiana-Starke", "America/Anguilla", "America/Antigua", "America/Aruba", "America/Asuncion", "America/Barbados", "America/Blanc-Sablon", "America/Boa_Vista", "America/Campo_Grande", "America/Caracas", "America/Cuiaba", "America/Curacao", "America/Detroit", "America/Dominica", "America/Fort_Wayne", "America/Grand_Turk", "America/Grenada", "America/Guadeloupe", "America/Guyana", "America/Havana", "America/Indiana/Indianapolis", "America/Indiana/Marengo", "America/Indiana/Petersburg", "America/Indiana/Vevay", "America/Indiana/Vincennes", "America/Indiana/Winamac", "America/Indianapolis", "America/Iqaluit", "America/Kentucky/Louisville", "America/Kentucky/Monticello", "America/Kralendijk", "America/La_Paz", "America/Louisville", "America/Lower_Princes", "America/Manaus", "America/Marigot", "America/Martinique", "America/Montreal", "America/Montserrat", "America/Nassau", "America/New_York", "America/Nipigon", "America/Pangnirtung", "America/Port_of_Spain", "America/Port-au-Prince", "America/Porto_Velho", "America/Puerto_Rico", "America/Santiago", "America/Santo_Domingo", "America/St_Barthelemy", "America/St_Kitts", "America/St_Lucia", "America/St_Thomas", "America/St_Vincent", "America/Thunder_Bay", "America/Toronto", "America/Tortola", "America/Virgin", "Brazil/West", "Canada/Eastern", "Chile/Continental", "Cuba", "EST5EDT", "Etc/GMT+4", "US/East-Indiana", "US/Eastern", "US/Michigan", "America/Araguaina", "America/Argentina/Buenos_Aires", "America/Argentina/Catamarca", "America/Argentina/ComodRivadavia", "America/Argentina/Cordoba", "America/Argentina/Jujuy", "America/Argentina/La_Rioja", "America/Argentina/Mendoza", "America/Argentina/Rio_Gallegos", "America/Argentina/Salta", "America/Argentina/San_Juan", "America/Argentina/San_Luis", "America/Argentina/Tucuman", "America/Argentina/Ushuaia", "America/Bahia", "America/Belem", "America/Buenos_Aires", "America/Catamarca", "America/Cayenne", "America/Cordoba", "America/Fortaleza", "America/Glace_Bay", "America/Goose_Bay", "America/Halifax", "America/Jujuy", "America/Maceio", "America/Mendoza", "America/Moncton", "America/Montevideo", "America/Paramaribo", "America/Punta_Arenas", "America/Recife", "America/Rosario", "America/Santarem", "America/Sao_Paulo", "America/Thule", "Antarctica/Palmer", "Antarctica/Rothera", "Atlantic/Bermuda", "Atlantic/Stanley", "Brazil/East", "Canada/Atlantic", "Etc/GMT+3", "America/St_Johns", "Canada/Newfoundland", "America/Godthab", "America/Miquelon", "America/Noronha", "America/Nuuk", "Atlantic/South_Georgia", "Brazil/DeNoronha", "Etc/GMT+2", "Atlantic/Cape_Verde", "Etc/GMT+1", "Africa/Abidjan", "Africa/Accra", "Africa/Bamako", "Africa/Banjul", "Africa/Bissau", "Africa/Conakry", "Africa/Dakar", "Africa/Freetown", "Africa/Lome", "Africa/Monrovia", "Africa/Nouakchott", "Africa/Ouagadougou", "Africa/Sao_Tome", "Africa/Timbuktu", "America/Danmarkshavn", "America/Scoresbysund", "Atlantic/Azores", "Atlantic/Reykjavik", "Atlantic/St_Helena", "Etc/GMT-0", "Etc/GMT", "Etc/GMT+0", "Etc/GMT0", "Etc/Greenwich", "Etc/UCT", "Etc/Universal", "Etc/UTC", "Etc/Zulu", "GMT-0", "GMT", "GMT+0", "GMT0", "Greenwich", "Iceland", "UCT", "Universal", "UTC", "Zulu", "Africa/Algiers", "Africa/Bangui", "Africa/Brazzaville", "Africa/Casablanca", "Africa/Douala", "Africa/El_Aaiun", "Africa/Kinshasa", "Africa/Lagos", "Africa/Libreville", "Africa/Luanda", "Africa/Malabo", "Africa/Ndjamena", "Africa/Niamey", "Africa/Porto-Novo", "Africa/Tunis", "Atlantic/Canary", "Atlantic/Faeroe", "Atlantic/Faroe", "Atlantic/Madeira", "Eire", "Etc/GMT-1", "Europe/Belfast", "Europe/Dublin", "Europe/Guernsey", "Europe/Isle_of_Man", "Europe/Jersey", "Europe/Lisbon", "Europe/London", "GB-Eire", "GB", "Portugal", "WET", "Africa/Blantyre", "Africa/Bujumbura", "Africa/Cairo", "Africa/Ceuta", "Africa/Gaborone", "Africa/Harare", "Africa/Johannesburg", "Africa/Khartoum", "Africa/Kigali", "Africa/Lubumbashi", "Africa/Lusaka", "Africa/Maputo", "Africa/Maseru", "Africa/Mbabane", "Africa/Tripoli", "Africa/Windhoek", "Antarctica/Troll", "Arctic/Longyearbyen", "Atlantic/Jan_Mayen", "CET", "Egypt", "Etc/GMT-2", "Europe/Amsterdam", "Europe/Andorra", "Europe/Belgrade", "Europe/Berlin", "Europe/Bratislava", "Europe/Brussels", "Europe/Budapest", "Europe/Busingen", "Europe/Copenhagen", "Europe/Gibraltar", "Europe/Kaliningrad", "Europe/Ljubljana", "Europe/Luxembourg", "Europe/Madrid", "Europe/Malta", "Europe/Monaco", "Europe/Oslo", "Europe/Paris", "Europe/Podgorica", "Europe/Prague", "Europe/Rome", "Europe/San_Marino", "Europe/Sarajevo", "Europe/Skopje", "Europe/Stockholm", "Europe/Tirane", "Europe/Vaduz", "Europe/Vatican", "Europe/Vienna", "Europe/Warsaw", "Europe/Zagreb", "Europe/Zurich", "Libya", "MET", "Poland", "Africa/Addis_Ababa", "Africa/Asmara", "Africa/Asmera", "Africa/Dar_es_Salaam", "Africa/Djibouti", "Africa/Juba", "Africa/Kampala", "Africa/Mogadishu", "Africa/Nairobi", "Antarctica/Syowa", "Asia/Aden", "Asia/Amman", "Asia/Baghdad", "Asia/Bahrain", "Asia/Beirut", "Asia/Damascus", "Asia/Famagusta", "Asia/Gaza", "Asia/Hebron", "Asia/Istanbul", "Asia/Jerusalem", "Asia/Kuwait", "Asia/Nicosia", "Asia/Qatar", "Asia/Riyadh", "Asia/Tel_Aviv", "EET", "Etc/GMT-3", "Europe/Athens", "Europe/Bucharest", "Europe/Chisinau", "Europe/Helsinki", "Europe/Istanbul", "Europe/Kiev", "Europe/Kirov", "Europe/Mariehamn", "Europe/Minsk", "Europe/Moscow", "Europe/Nicosia", "Europe/Riga", "Europe/Simferopol", "Europe/Sofia", "Europe/Tallinn", "Europe/Tiraspol", "Europe/Uzhgorod", "Europe/Vilnius", "Europe/Zaporozhye", "Indian/Antananarivo", "Indian/Comoro", "Indian/Mayotte", "Israel", "Turkey", "W-SU", "Asia/Baku", "Asia/Dubai", "Asia/Muscat", "Asia/Tbilisi", "Asia/Yerevan", "Etc/GMT-4", "Europe/Astrakhan", "Europe/Samara", "Europe/Saratov", "Europe/Ulyanovsk", "Europe/Volgograd", "Indian/Mahe", "Indian/Mauritius", "Indian/Reunion", "Asia/Kabul", "Asia/Tehran", "Iran", "Antarctica/Mawson", "Asia/Aqtau", "Asia/Aqtobe", "Asia/Ashgabat", "Asia/Ashkhabad", "Asia/Atyrau", "Asia/Dushanbe", "Asia/Karachi", "Asia/Oral", "Asia/Qyzylorda", "Asia/Samarkand", "Asia/Tashkent", "Asia/Yekaterinburg", "Etc/GMT-5", "Indian/Kerguelen", "Indian/Maldives", "Asia/Calcutta", "Asia/Colombo", "Asia/Kolkata", "Asia/Kathmandu", "Asia/Katmandu", "Antarctica/Vostok", "Asia/Almaty", "Asia/Bishkek", "Asia/Dacca", "Asia/Dhaka", "Asia/Kashgar", "Asia/Omsk", "Asia/Qostanay", "Asia/Thimbu", "Asia/Thimphu", "Asia/Urumqi", "Etc/GMT-6", "Indian/Chagos", "Asia/Rangoon", "Asia/Yangon", "Indian/Cocos", "Antarctica/Davis", "Asia/Bangkok", "Asia/Barnaul", "Asia/Ho_Chi_Minh", "Asia/Hovd", "Asia/Jakarta", "Asia/Krasnoyarsk", "Asia/Novokuznetsk", "Asia/Novosibirsk", "Asia/Phnom_Penh", "Asia/Pontianak", "Asia/Saigon", "Asia/Tomsk", "Asia/Vientiane", "Etc/GMT-7", "Indian/Christmas", "Antarctica/Casey", "Asia/Brunei", "Asia/Choibalsan", "Asia/Chongqing", "Asia/Chungking", "Asia/Harbin", "Asia/Hong_Kong", "Asia/Irkutsk", "Asia/Kuala_Lumpur", "Asia/Kuching", "Asia/Macao", "Asia/Macau", "Asia/Makassar", "Asia/Manila", "Asia/Shanghai", "Asia/Singapore", "Asia/Taipei", "Asia/Ujung_Pandang", "Asia/Ulaanbaatar", "Asia/Ulan_Bator", "Australia/Perth", "Australia/West", "Etc/GMT-8", "Hongkong", "PRC", "ROC", "Singapore", "Australia/Eucla", "Asia/Chita", "Asia/Dili", "Asia/Jayapura", "Asia/Khandyga", "Asia/Pyongyang", "Asia/Seoul", "Asia/Tokyo", "Asia/Yakutsk", "Etc/GMT-9", "Japan", "Pacific/Palau", "ROK", "Australia/Adelaide", "Australia/Broken_Hill", "Australia/Darwin", "Australia/North", "Australia/South", "Australia/Yancowinna", "Antarctica/DumontDUrville", "Asia/Ust-Nera", "Asia/Vladivostok", "Australia/ACT", "Australia/Brisbane", "Australia/Canberra", "Australia/Currie", "Australia/Hobart", "Australia/Lindeman", "Australia/Melbourne", "Australia/NSW", "Australia/Queensland", "Australia/Sydney", "Australia/Tasmania", "Australia/Victoria", "Etc/GMT-10", "Pacific/Chuuk", "Pacific/Guam", "Pacific/Port_Moresby", "Pacific/Saipan", "Pacific/Truk", "Pacific/Yap", "Australia/LHI", "Australia/Lord_Howe", "Antarctica/Macquarie", "Asia/Magadan", "Asia/Sakhalin", "Asia/Srednekolymsk", "Etc/GMT-11", "Pacific/Bougainville", "Pacific/Efate", "Pacific/Guadalcanal", "Pacific/Kosrae", "Pacific/Norfolk", "Pacific/Noumea", "Pacific/Pohnpei", "Pacific/Ponape", "Antarctica/McMurdo", "Antarctica/South_Pole", "Asia/Anadyr", "Asia/Kamchatka", "Etc/GMT-12", "Kwajalein", "NZ", "Pacific/Auckland", "Pacific/Fiji", "Pacific/Funafuti", "Pacific/Kwajalein", "Pacific/Majuro", "Pacific/Nauru", "Pacific/Tarawa", "Pacific/Wake", "Pacific/Wallis", "NZ-CHAT", "Pacific/Chatham", "Etc/GMT-13", "Pacific/Apia", "Pacific/Enderbury", "Pacific/Fakaofo", "Pacific/Tongatapu", "Etc/GMT-14", "Pacific/Kiritimati"]
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_utils_time_zone.js
var toMs3 = date_default.dateToMilliseconds;
var GMT = "GMT";
var offsetFormatRegexp = /^GMT(?:[+-]\d{2}:\d{2})?$/;
var createUTCDateWithLocalOffset = (date) => {
  if (!date) {
    return null;
  }
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
};
var createDateFromUTCWithLocalOffset = (date) => {
  const result2 = m_date_adapter_default(date);
  const timezoneOffsetBeforeInMin = result2.getTimezoneOffset();
  result2.addTime(result2.getTimezoneOffset("minute"));
  result2.subtractMinutes(timezoneOffsetBeforeInMin - result2.getTimezoneOffset());
  return result2.source;
};
var getTimeZones = function() {
  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  return timezone_list_default.value.map((tz) => ({
    offset: calculateTimezoneByValue(tz, date),
    title: getTimezoneTitle(tz, date),
    id: tz
  }));
};
var createUTCDate = (date) => new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes()));
var getTimezoneOffsetChangeInMinutes = (startDate, endDate, updatedStartDate, updatedEndDate) => getDaylightOffset(updatedStartDate, updatedEndDate) - getDaylightOffset(startDate, endDate);
var getTimezoneOffsetChangeInMs = (startDate, endDate, updatedStartDate, updatedEndDate) => getTimezoneOffsetChangeInMinutes(startDate, endDate, updatedStartDate, updatedEndDate) * toMs3("minute");
var getDaylightOffset = (startDate, endDate) => new Date(startDate).getTimezoneOffset() - new Date(endDate).getTimezoneOffset();
var getDaylightOffsetInMs = (startDate, endDate) => getDaylightOffset(startDate, endDate) * toMs3("minute");
var isValidDate = (date) => date instanceof Date && !isNaN(date.valueOf());
var calculateTimezoneByValueOld = function(timezone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  const customTimezones = m_utils_timezones_data_default.getTimeZonesOld();
  if (0 === customTimezones.length) {
    return;
  }
  const dateUtc = createUTCDate(date);
  return m_utils_timezones_data_default.getTimeZoneOffsetById(timezone, dateUtc.getTime());
};
var calculateTimezoneByValueCore = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  const offset2 = getStringOffset(timeZone, date);
  if (void 0 === offset2) {
    return;
  }
  if (offset2 === GMT) {
    return 0;
  }
  const isMinus = "-" === offset2.substring(3, 4);
  const hours = offset2.substring(4, 6);
  const minutes = offset2.substring(7, 9);
  const result2 = parseInt(hours, 10) + parseInt(minutes, 10) / 60;
  return isMinus ? -result2 : result2;
};
var calculateTimezoneByValue = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (!timeZone) {
    return;
  }
  const isValidTimezone = timezone_list_default.value.includes(timeZone);
  if (!isValidTimezone) {
    errors_default.log("W0009", timeZone);
    return;
  }
  if (!isValidDate(date)) {
    return;
  }
  let result2 = calculateTimezoneByValueOld(timeZone, date);
  if (void 0 === result2) {
    result2 = calculateTimezoneByValueCore(timeZone, date);
  }
  return result2;
};
var getStringOffset = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  let result2 = "";
  try {
    var _dateTimeFormat$forma;
    const dateTimeFormat = new Intl.DateTimeFormat("en-US", {
      timeZone,
      timeZoneName: "longOffset"
    });
    result2 = (null === (_dateTimeFormat$forma = dateTimeFormat.formatToParts(date).find((_ref) => {
      let {
        type: type2
      } = _ref;
      return "timeZoneName" === type2;
    })) || void 0 === _dateTimeFormat$forma ? void 0 : _dateTimeFormat$forma.value) ?? "";
  } catch (e) {
    errors_default.log("W0009", timeZone);
    return;
  }
  const isSupportedFormat = offsetFormatRegexp.test(result2);
  if (!isSupportedFormat) {
    errors_default.log("W0009", timeZone);
    return;
  }
  return result2;
};
var getOffsetNamePart = (offset2) => {
  if (offset2 === GMT) {
    return `${offset2} +00:00`;
  }
  return offset2.replace(GMT, `${GMT} `);
};
var getTimezoneTitle = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (!isValidDate(date)) {
    return "";
  }
  const tzNamePart = timeZone.replace(/\//g, " - ").replace(/_/g, " ");
  const offset2 = getStringOffset(timeZone, date);
  if (void 0 === offset2) {
    return;
  }
  const offsetNamePart = getOffsetNamePart(offset2);
  return `(${offsetNamePart}) ${tzNamePart}`;
};
var _getDaylightOffsetByTimezone = (startDate, endDate, timeZone) => {
  const startDayOffset = calculateTimezoneByValue(timeZone, startDate);
  const endDayOffset = calculateTimezoneByValue(timeZone, endDate);
  if (void 0 === startDayOffset || void 0 === endDayOffset) {
    return 0;
  }
  return startDayOffset - endDayOffset;
};
var getCorrectedDateByDaylightOffsets = (convertedOriginalStartDate, convertedDate, date, timeZone, startDateTimezone) => {
  const daylightOffsetByCommonTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, timeZone);
  const daylightOffsetByAppointmentTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, startDateTimezone);
  const diff = daylightOffsetByCommonTimezone - daylightOffsetByAppointmentTimezone;
  return new Date(date.getTime() - diff * toMs3("hour"));
};
var correctRecurrenceExceptionByTimezone = function(exception, exceptionByStartDate, timeZone, startDateTimeZone) {
  let isBackConversion = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let timezoneOffset = (exception.getTimezoneOffset() - exceptionByStartDate.getTimezoneOffset()) / 60;
  if (startDateTimeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, startDateTimeZone);
  } else if (timeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, timeZone);
  }
  return new Date(exception.getTime() + (isBackConversion ? -1 : 1) * timezoneOffset * toMs3("hour"));
};
var isTimezoneChangeInDate = (date) => {
  const startDayDate = new Date(new Date(date).setHours(0, 0, 0, 0));
  const endDayDate = new Date(new Date(date).setHours(23, 59, 59, 0));
  return startDayDate.getTimezoneOffset() - endDayDate.getTimezoneOffset() !== 0;
};
var getDateWithoutTimezoneChange = (date) => {
  const clonedDate = new Date(date);
  if (isTimezoneChangeInDate(clonedDate)) {
    const result2 = new Date(clonedDate);
    return new Date(result2.setDate(result2.getDate() + 1));
  }
  return clonedDate;
};
var isSameAppointmentDates = (startDate, endDate) => {
  endDate = new Date(endDate.getTime() - 1);
  return date_default.sameDate(startDate, endDate);
};
var getClientTimezoneOffset = function() {
  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  return 6e4 * date.getTimezoneOffset();
};
var getDiffBetweenClientTimezoneOffsets = function() {
  let firstDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  let secondDate = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  return getClientTimezoneOffset(firstDate) - getClientTimezoneOffset(secondDate);
};
var isEqualLocalTimeZone = function(timeZoneName) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (Intl) {
    const localTimeZoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
    if (localTimeZoneName === timeZoneName) {
      return true;
    }
  }
  return isEqualLocalTimeZoneByDeclaration(timeZoneName, date);
};
var hasDSTInLocalTimeZone = () => {
  const [startDate, endDate] = getExtremeDates();
  return startDate.getTimezoneOffset() !== endDate.getTimezoneOffset();
};
var getOffset2 = (date) => -date.getTimezoneOffset() / 60;
var getDateAndMoveHourBack = (dateStamp) => new Date(dateStamp - toMs3("hour"));
var isEqualLocalTimeZoneByDeclarationOld = (timeZoneName, date) => {
  const year = date.getFullYear();
  const configTuple = m_utils_timezones_data_default.getTimeZoneDeclarationTuple(timeZoneName, year);
  const [summerTime, winterTime] = configTuple;
  const noDSTInTargetTimeZone = configTuple.length < 2;
  if (noDSTInTargetTimeZone) {
    const targetTimeZoneOffset = m_utils_timezones_data_default.getTimeZoneOffsetById(timeZoneName, date);
    const localTimeZoneOffset = getOffset2(date);
    if (targetTimeZoneOffset !== localTimeZoneOffset) {
      return false;
    }
    return !hasDSTInLocalTimeZone();
  }
  const localSummerOffset = getOffset2(new Date(summerTime.date));
  const localWinterOffset = getOffset2(new Date(winterTime.date));
  if (localSummerOffset !== summerTime.offset) {
    return false;
  }
  if (localSummerOffset === getOffset2(getDateAndMoveHourBack(summerTime.date))) {
    return false;
  }
  if (localWinterOffset !== winterTime.offset) {
    return false;
  }
  if (localWinterOffset === getOffset2(getDateAndMoveHourBack(winterTime.date))) {
    return false;
  }
  return true;
};
var isEqualLocalTimeZoneByDeclaration = (timeZoneName, date) => {
  const customTimezones = m_utils_timezones_data_default.getTimeZonesOld();
  const targetTimezoneData = customTimezones.filter((tz) => tz.id === timeZoneName);
  if (1 === targetTimezoneData.length) {
    return isEqualLocalTimeZoneByDeclarationOld(timeZoneName, date);
  }
  return false;
};
var getExtremeDates = () => {
  const nowDate = new Date(Date.now());
  const startDate = /* @__PURE__ */ new Date();
  const endDate = /* @__PURE__ */ new Date();
  startDate.setFullYear(nowDate.getFullYear(), 0, 1);
  endDate.setFullYear(nowDate.getFullYear(), 6, 1);
  return [startDate, endDate];
};
var setOffsetsToDate = (targetDate, offsetsArray) => {
  const newDateMs = offsetsArray.reduce((result2, offset2) => result2 + offset2, targetDate.getTime());
  return new Date(newDateMs);
};
var addOffsetsWithoutDST = function(date) {
  for (var _len = arguments.length, offsets = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    offsets[_key - 1] = arguments[_key];
  }
  const newDate = dateUtilsTs.addOffsets(date, offsets);
  const daylightShift = getDaylightOffsetInMs(date, newDate);
  if (!daylightShift) {
    return newDate;
  }
  const correctLocalDate = dateUtilsTs.addOffsets(newDate, [-daylightShift]);
  const daylightSecondShift = getDaylightOffsetInMs(newDate, correctLocalDate);
  return !daylightSecondShift ? correctLocalDate : newDate;
};
var utils = {
  getDaylightOffset,
  getDaylightOffsetInMs,
  getTimezoneOffsetChangeInMinutes,
  getTimezoneOffsetChangeInMs,
  calculateTimezoneByValue,
  getCorrectedDateByDaylightOffsets,
  isSameAppointmentDates,
  correctRecurrenceExceptionByTimezone,
  getClientTimezoneOffset,
  getDiffBetweenClientTimezoneOffsets,
  createUTCDateWithLocalOffset,
  createDateFromUTCWithLocalOffset,
  createUTCDate,
  isTimezoneChangeInDate,
  getDateWithoutTimezoneChange,
  hasDSTInLocalTimeZone,
  isEqualLocalTimeZone,
  isEqualLocalTimeZoneByDeclaration,
  getTimeZones,
  setOffsetsToDate,
  addOffsetsWithoutDST
};
var m_utils_time_zone_default = utils;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/timezone_calculator/utils.js
var createTimeZoneCalculator = (currentTimeZone) => new TimeZoneCalculator({
  getClientOffset: (date) => m_utils_time_zone_default.getClientTimezoneOffset(date),
  tryGetCommonOffset: (date) => m_utils_time_zone_default.calculateTimezoneByValue(currentTimeZone, date),
  tryGetAppointmentOffset: (date, appointmentTimezone) => m_utils_time_zone_default.calculateTimezoneByValue(appointmentTimezone, date)
});

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/themes.js
var getThemeType = () => {
  const theme = current();
  return {
    isCompact: isCompact(theme),
    isMaterial: isMaterial(theme),
    isFluent: isFluent(theme),
    isMaterialBased: isMaterialBased(theme)
  };
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_classes.js
var FIXED_CONTAINER_CLASS = "dx-scheduler-fixed-appointments";
var REDUCED_APPOINTMENT_CLASS = "dx-scheduler-appointment-reduced";
var REDUCED_APPOINTMENT_ICON = "dx-scheduler-appointment-reduced-icon";
var RECURRENCE_APPOINTMENT_CLASS = "dx-scheduler-appointment-recurrence";
var EMPTY_APPOINTMENT_CLASS = "dx-scheduler-appointment-empty";
var ALL_DAY_APPOINTMENT_CLASS = "dx-scheduler-all-day-appointment";
var REDUCED_APPOINTMENT_PARTS_CLASSES = {
  head: "dx-scheduler-appointment-head",
  body: "dx-scheduler-appointment-body",
  tail: "dx-scheduler-appointment-tail"
};
var DIRECTION_APPOINTMENT_CLASSES = {
  horizontal: "dx-scheduler-appointment-horizontal",
  vertical: "dx-scheduler-appointment-vertical"
};
var APPOINTMENT_DRAG_SOURCE_CLASS = "dx-scheduler-appointment-drag-source";
var APPOINTMENT_ITEM_CLASS = "dx-scheduler-appointment";
var APPOINTMENT_CONTENT_CLASSES = {
  APPOINTMENT_CONTENT_DETAILS: "dx-scheduler-appointment-content-details",
  RECURRING_ICON: "dx-scheduler-appointment-recurrence-icon",
  APPOINTMENT_TITLE: "dx-scheduler-appointment-title",
  APPOINTMENT_DATE: "dx-scheduler-appointment-content-date",
  ALL_DAY_CONTENT: "dx-scheduler-appointment-content-allday",
  ITEM: "dx-scheduler-appointment",
  STRIP: "dx-scheduler-appointment-strip",
  AGENDA_MARKER: "dx-scheduler-agenda-appointment-marker",
  AGENDA_RESOURCE_LIST: "dx-scheduler-appointment-resource-list",
  AGENDA_RESOURCE_LIST_ITEM: "dx-scheduler-appointment-resource-item",
  AGENDA_RESOURCE_LIST_ITEM_VALUE: "dx-scheduler-appointment-resource-item-value"
};
var AGENDA_LAST_IN_DATE_APPOINTMENT_CLASS = "dx-scheduler-last-in-date-agenda-appointment";
var APPOINTMENT_HAS_RESOURCE_COLOR_CLASS = "dx-scheduler-appointment-has-resource-color";
var HEADER_CURRENT_TIME_CELL_CLASS = "dx-scheduler-header-panel-current-time-cell";
var VIRTUAL_CELL_CLASS = "dx-scheduler-virtual-cell";
var TIME_PANEL_CLASS = "dx-scheduler-time-panel";
var DATE_TABLE_CLASS = "dx-scheduler-date-table";
var DATE_TABLE_ROW_CLASS = "dx-scheduler-date-table-row";
var GROUP_ROW_CLASS = "dx-scheduler-group-row";
var GROUP_HEADER_CONTENT_CLASS = "dx-scheduler-group-header-content";
var LAST_GROUP_CELL_CLASS = "dx-scheduler-last-group-cell";
var FIRST_GROUP_CELL_CLASS = "dx-scheduler-first-group-cell";
var VERTICAL_GROUP_COUNT_CLASSES = ["dx-scheduler-group-column-count-one", "dx-scheduler-group-column-count-two", "dx-scheduler-group-column-count-three"];

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_constants.js
var LIST_ITEM_DATA_KEY = "dxListItemData";
var LIST_ITEM_CLASS = "dx-list-item";
var APPOINTMENT_SETTINGS_KEY = "dxAppointmentSettings";
var HORIZONTAL_GROUP_ORIENTATION = "horizontal";
var VIEWS = {
  DAY: "day",
  WEEK: "week",
  WORK_WEEK: "workWeek",
  MONTH: "month",
  TIMELINE_DAY: "timelineDay",
  TIMELINE_WEEK: "timelineWeek",
  TIMELINE_WORK_WEEK: "timelineWorkWeek",
  TIMELINE_MONTH: "timelineMonth",
  AGENDA: "agenda"
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/const.js
var VERTICAL_GROUP_ORIENTATION = "vertical";
var HORIZONTAL_GROUP_ORIENTATION2 = "horizontal";
var TIMELINE_VIEWS = {
  timelineDay: true,
  timelineWeek: true,
  timelineWorkWeek: true,
  timelineMonth: true
};
var VIEW_TYPES = ["day", "week", "workWeek", "month", "timelineDay", "timelineWeek", "timelineWorkWeek", "timelineMonth", "agenda"];

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/base.js
var toMs4 = date_default.dateToMilliseconds;
var getDurationInHours = (startDate, endDate) => Math.floor((endDate.getTime() - startDate.getTime()) / toMs4("hour"));
var getDatesWithoutTime = (min, max) => {
  const newMin = date_default.trimTime(min);
  const newMax = date_default.trimTime(max);
  newMax.setDate(newMax.getDate() + 1);
  return [newMin, newMax];
};
var getAppointmentRenderingStrategyName = (viewType) => {
  const {
    renderingStrategy
  } = {
    day: {
      renderingStrategy: "vertical"
    },
    week: {
      renderingStrategy: "week"
    },
    workWeek: {
      renderingStrategy: "week"
    },
    month: {
      renderingStrategy: "horizontalMonth"
    },
    timelineDay: {
      renderingStrategy: "horizontal"
    },
    timelineWeek: {
      renderingStrategy: "horizontal"
    },
    timelineWorkWeek: {
      renderingStrategy: "horizontal"
    },
    timelineMonth: {
      renderingStrategy: "horizontalMonthLine"
    },
    agenda: {
      renderingStrategy: "agenda"
    }
  }[viewType];
  return renderingStrategy;
};
var getAppointmentTakesAllDay = (appointmentAdapter, allDayPanelMode) => {
  const {
    startDate,
    endDate,
    allDay
  } = appointmentAdapter;
  switch (allDayPanelMode) {
    case "hidden":
      return false;
    case "allDay":
      return allDay;
    default:
      if (allDay) {
        return true;
      }
      if (!isDefined(endDate)) {
        return false;
      }
      return getDurationInHours(startDate, endDate) >= 24;
  }
};
var getAppointmentKey = (geometry) => {
  const {
    left,
    top,
    width,
    height
  } = geometry;
  return `${left}-${top}-${width}-${height}`;
};
var hasResourceValue = (resourceValues, itemValue) => isDefined(resourceValues.find((value2) => equalByValue(value2, itemValue)));
var getOverflowIndicatorColor = (color, colors) => !colors.length || 0 === colors.filter((item) => item !== color).length ? color : void 0;
var getVerticalGroupCountClass = (groups) => {
  switch (null === groups || void 0 === groups ? void 0 : groups.length) {
    case 1:
      return VERTICAL_GROUP_COUNT_CLASSES[0];
    case 2:
      return VERTICAL_GROUP_COUNT_CLASSES[1];
    case 3:
      return VERTICAL_GROUP_COUNT_CLASSES[2];
    default:
      return;
  }
};
var setOptionHour = (date, optionHour) => {
  const nextDate = new Date(date);
  if (!isDefined(optionHour)) {
    return nextDate;
  }
  nextDate.setHours(optionHour, optionHour % 1 * 60, 0, 0);
  return nextDate;
};
var calculateDayDuration = (startDayHour, endDayHour) => endDayHour - startDayHour;
var getStartViewDateTimeOffset = (startViewDate, startDayHour) => {
  const validStartDayHour = Math.floor(startDayHour);
  const isDSTChange = m_utils_time_zone_default.isTimezoneChangeInDate(startViewDate);
  if (isDSTChange && validStartDayHour !== startViewDate.getHours()) {
    return date_default.dateToMilliseconds("hour");
  }
  return 0;
};
var getValidCellDateForLocalTimeFormat = (date, _ref) => {
  let {
    startViewDate,
    startDayHour,
    cellIndexShift,
    viewOffset
  } = _ref;
  const originDate = dateUtilsTs.addOffsets(date, [-viewOffset]);
  const localTimeZoneChangedInOriginDate = m_utils_time_zone_default.isTimezoneChangeInDate(originDate);
  if (!localTimeZoneChangedInOriginDate) {
    return date;
  }
  const startViewDateWithoutDST = new Date(new Date(startViewDate).setDate(startViewDate.getDate() + 2));
  const startViewDateOffset = getStartViewDateTimeOffset(startViewDate, startDayHour);
  return dateUtilsTs.addOffsets(startViewDateWithoutDST, [viewOffset, cellIndexShift, -startViewDateOffset]);
};
var getTotalCellCountByCompleteData = (completeData) => completeData[completeData.length - 1].length;
var getDisplayedCellCount = (displayedCellCount, completeData) => displayedCellCount ?? getTotalCellCountByCompleteData(completeData);
var getHeaderCellText = (headerIndex, date, headerCellTextFormat, getDateForHeaderText2, additionalOptions) => {
  const validDate = getDateForHeaderText2(headerIndex, date, additionalOptions);
  return date_default3.format(validDate, headerCellTextFormat);
};
var isVerticalGroupingApplied = (groups, groupOrientation) => groupOrientation === VERTICAL_GROUP_ORIENTATION && !!groups.length;
var getGroupCount = (groups) => {
  let result2 = 0;
  for (let i = 0, len = groups.length; i < len; i += 1) {
    if (!i) {
      result2 = groups[i].items.length;
    } else {
      result2 *= groups[i].items.length;
    }
  }
  return result2;
};
var getHorizontalGroupCount = (groups, groupOrientation) => {
  const groupCount = getGroupCount(groups) || 1;
  const isVerticalGrouping = isVerticalGroupingApplied(groups, groupOrientation);
  return isVerticalGrouping ? 1 : groupCount;
};
var isTimelineView = (viewType) => !!TIMELINE_VIEWS[viewType];
var isDateAndTimeView = (viewType) => viewType !== VIEWS.TIMELINE_MONTH && viewType !== VIEWS.MONTH;
var isHorizontalView = (viewType) => {
  switch (viewType) {
    case VIEWS.TIMELINE_DAY:
    case VIEWS.TIMELINE_WEEK:
    case VIEWS.TIMELINE_WORK_WEEK:
    case VIEWS.TIMELINE_MONTH:
    case VIEWS.MONTH:
      return true;
    default:
      return false;
  }
};
var isDateInRange = (date, startDate, endDate, diff) => diff > 0 ? date_default.dateInRange(date, startDate, new Date(endDate.getTime() - 1)) : date_default.dateInRange(date, endDate, startDate, "date");
var isFirstCellInMonthWithIntervalCount = (cellDate, intervalCount) => 1 === cellDate.getDate() && intervalCount > 1;
var getViewStartByOptions = (startDate, currentDate, intervalDuration, startViewDate) => {
  if (!startDate) {
    return new Date(currentDate);
  }
  let currentStartDate = date_default.trimTime(startViewDate);
  const diff = currentStartDate.getTime() <= currentDate.getTime() ? 1 : -1;
  let endDate = new Date(currentStartDate.getTime() + intervalDuration * diff);
  while (!isDateInRange(currentDate, currentStartDate, endDate, diff)) {
    currentStartDate = endDate;
    endDate = new Date(currentStartDate.getTime() + intervalDuration * diff);
  }
  return diff > 0 ? currentStartDate : endDate;
};
var calculateIsGroupedAllDayPanel = (groups, groupOrientation, isAllDayPanelVisible) => isVerticalGroupingApplied(groups, groupOrientation) && isAllDayPanelVisible;
var calculateViewStartDate = (startDateOption) => startDateOption;
var getCellDuration = (viewType, startDayHour, endDayHour, hoursInterval) => {
  switch (viewType) {
    case "month":
      return 36e5 * calculateDayDuration(startDayHour, endDayHour);
    case "timelineMonth":
      return date_default.dateToMilliseconds("day");
    default:
      return 36e5 * hoursInterval;
  }
};
var calculateCellIndex = (rowIndex, columnIndex, rowCount) => columnIndex * rowCount + rowIndex;
var getTotalRowCountByCompleteData = (completeData) => completeData.length;
var getDisplayedRowCount = (displayedRowCount, completeData) => displayedRowCount ?? getTotalRowCountByCompleteData(completeData);
var getStartViewDateWithoutDST = (startViewDate, startDayHour) => {
  const newStartViewDate = m_utils_time_zone_default.getDateWithoutTimezoneChange(startViewDate);
  newStartViewDate.setHours(startDayHour);
  return newStartViewDate;
};
var getIsGroupedAllDayPanel = (hasAllDayRow, isVerticalGrouping) => hasAllDayRow && isVerticalGrouping;
var getKeyByGroup = (groupIndex, isVerticalGrouping) => {
  if (isVerticalGrouping && !!groupIndex) {
    return groupIndex.toString();
  }
  return "0";
};
var getToday = (indicatorTime, timeZoneCalculator) => {
  const todayDate = indicatorTime ?? /* @__PURE__ */ new Date();
  return (null === timeZoneCalculator || void 0 === timeZoneCalculator ? void 0 : timeZoneCalculator.createDate(todayDate, {
    path: "toGrid"
  })) || todayDate;
};
var getCalculatedFirstDayOfWeek = (firstDayOfWeekOption) => isDefined(firstDayOfWeekOption) ? firstDayOfWeekOption : date_default3.firstDayOfWeekIndex();
var isHorizontalGroupingApplied = (groups, groupOrientation) => groupOrientation === HORIZONTAL_GROUP_ORIENTATION2 && !!groups.length;
var isGroupingByDate = (groups, groupOrientation, groupByDate) => {
  const isHorizontalGrouping = isHorizontalGroupingApplied(groups, groupOrientation);
  return groupByDate && isHorizontalGrouping;
};
var getSkippedHoursInRange = (startDate, endDate, allDay, viewDataProvider) => {
  const isAllDay = allDay && !viewDataProvider.viewType.includes("timeline");
  let result2 = 0;
  const currentDate = new Date(startDate);
  currentDate.setDate(currentDate.getDate() + 1);
  currentDate.setHours(0, 0, 0, 0);
  const endDateWithStartHour = new Date(endDate);
  endDateWithStartHour.setHours(0, 0, 0, 0);
  const {
    startDayHour,
    endDayHour
  } = viewDataProvider.getViewOptions();
  const dayHours = isAllDay ? 24 : endDayHour - startDayHour;
  while (currentDate < endDateWithStartHour) {
    if (viewDataProvider.isSkippedDate(currentDate)) {
      result2 += dayHours;
    }
    currentDate.setDate(currentDate.getDate() + 1);
  }
  const startDateHours = startDate.getHours();
  const endDateHours = endDate.getHours() + endDate.getTime() % 36e5 / 36e5;
  if (viewDataProvider.isSkippedDate(startDate)) {
    if (isAllDay) {
      result2 += 24;
    } else if (startDateHours < startDayHour) {
      result2 += dayHours;
    } else if (startDateHours < endDayHour) {
      result2 += endDayHour - startDateHours;
    }
  }
  if (viewDataProvider.isSkippedDate(endDate)) {
    if (isAllDay) {
      result2 += 24;
    } else if (endDateHours > endDayHour) {
      result2 += dayHours;
    } else if (endDateHours > startDayHour) {
      result2 += endDateHours - startDayHour;
    }
  }
  return result2;
};
var isDataOnWeekend = (date) => {
  const day = date.getDay();
  return 6 === day || 0 === day;
};
var getWeekendsCount = (days3) => 2 * Math.floor(days3 / 7);
var extendGroupItemsForGroupingByDate = (groupRenderItems, columnCountPerGroup) => [...new Array(columnCountPerGroup)].reduce((currentGroupItems, _, index2) => groupRenderItems.map((groupsRow, rowIndex) => {
  const currentRow = currentGroupItems[rowIndex] || [];
  return [...currentRow, ...groupsRow.map((item, columnIndex) => _extends({}, item, {
    key: `${item.key}_group_by_date_${index2}`,
    isFirstGroupCell: 0 === columnIndex,
    isLastGroupCell: columnIndex === groupsRow.length - 1
  }))];
}), []);
var getGroupPanelData = (groups, columnCountPerGroup, groupByDate, baseColSpan) => {
  let repeatCount = 1;
  let groupPanelItems = groups.map((group) => {
    const result2 = [];
    const {
      name: resourceName,
      items,
      data: data2
    } = group;
    for (let iterator = 0; iterator < repeatCount; iterator += 1) {
      result2.push(...items.map((_ref2, index2) => {
        let {
          id,
          text,
          color
        } = _ref2;
        return {
          id,
          text,
          color,
          key: `${iterator}_${resourceName}_${id}`,
          resourceName,
          data: null === data2 || void 0 === data2 ? void 0 : data2[index2]
        };
      }));
    }
    repeatCount *= items.length;
    return result2;
  });
  if (groupByDate) {
    groupPanelItems = extendGroupItemsForGroupingByDate(groupPanelItems, columnCountPerGroup);
  }
  return {
    groupPanelItems,
    baseColSpan
  };
};
var splitNumber = (value2, splitValue) => Array.from({
  length: Math.ceil(value2 / splitValue)
}, (_, index2) => Math.min(value2 - splitValue * index2, splitValue));

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/agenda.js
var calculateStartViewDate = (currentDate, startDayHour) => {
  const validCurrentDate = new Date(currentDate);
  return setOptionHour(validCurrentDate, startDayHour);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/day.js
var calculateStartViewDate2 = (currentDate, startDayHour, startDate, intervalDuration) => {
  const firstViewDate = getViewStartByOptions(startDate, currentDate, intervalDuration, startDate);
  return setOptionHour(firstViewDate, startDayHour);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/month.js
var calculateCellIndex2 = (rowIndex, columnIndex, _, columnCount) => rowIndex * columnCount + columnIndex;
var getViewStartByOptions2 = (startDate, currentDate, intervalCount, startViewDate) => {
  if (!startDate) {
    return new Date(currentDate);
  }
  let currentStartDate = new Date(startViewDate);
  const validStartViewDate = new Date(startViewDate);
  const diff = currentStartDate.getTime() <= currentDate.getTime() ? 1 : -1;
  let endDate = new Date(new Date(validStartViewDate.setMonth(validStartViewDate.getMonth() + diff * intervalCount)));
  while (!isDateInRange(currentDate, currentStartDate, endDate, diff)) {
    currentStartDate = new Date(endDate);
    if (diff > 0) {
      currentStartDate.setDate(1);
    }
    endDate = new Date(new Date(endDate.setMonth(endDate.getMonth() + diff * intervalCount)));
  }
  return diff > 0 ? currentStartDate : endDate;
};
var getCellText = (date, intervalCount) => {
  if (isFirstCellInMonthWithIntervalCount(date, intervalCount)) {
    const monthName = date_default3.getMonthNames("abbreviated")[date.getMonth()];
    return [monthName, date_default3.format(date, "day")].join(" ");
  }
  return date_default3.format(date, "dd");
};
var calculateStartViewDate3 = (currentDate, startDayHour, startDate, intervalCount, firstDayOfWeekOption) => {
  const viewStart = getViewStartByOptions2(startDate, currentDate, intervalCount, date_default.getFirstMonthDate(startDate));
  const firstMonthDate = date_default.getFirstMonthDate(viewStart);
  const firstDayOfWeek = getCalculatedFirstDayOfWeek(firstDayOfWeekOption);
  const firstViewDate = date_default.getFirstWeekDate(firstMonthDate, firstDayOfWeek);
  return setOptionHour(firstViewDate, startDayHour);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/render.js
var addToStyles = (options2, style) => {
  const nextStyle = style ?? {};
  const result2 = _extends({}, nextStyle);
  options2.forEach((_ref) => {
    let {
      attr,
      value: value2
    } = _ref;
    result2[attr] = value2 || nextStyle[attr];
  });
  return result2;
};
var addWidthToStyle = (value2, style) => {
  const width = value2 ? `${value2}px` : "";
  return addToStyles([{
    attr: "width",
    value: width
  }], style);
};
var addHeightToStyle = (value2, style) => {
  const height = value2 ? `${value2}px` : "";
  return addToStyles([{
    attr: "height",
    value: height
  }], style);
};
var combineClasses2 = (classesMap) => Object.keys(classesMap).filter((cssClass) => !!cssClass && classesMap[cssClass]).join(" ");
var getGroupCellClasses = function() {
  let isFirstGroupCell = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
  let isLastGroupCell = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
  let className = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
  return combineClasses2({
    "dx-scheduler-first-group-cell": isFirstGroupCell,
    "dx-scheduler-last-group-cell": isLastGroupCell,
    [className]: true
  });
};
var getCellSizeHorizontalClass = (viewType, crossScrollingEnabled) => {
  switch (viewType) {
    case "day":
    case "week":
    case "workWeek":
    case "month":
      return crossScrollingEnabled ? "dx-scheduler-cell-sizes-horizontal" : "";
    default:
      return "dx-scheduler-cell-sizes-horizontal";
  }
};
var getCellSizeVerticalClass = (isAllDayCell) => !isAllDayCell ? "dx-scheduler-cell-sizes-vertical" : "";

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/timeline_month.js
var calculateStartViewDate4 = (currentDate, startDayHour, startDate, intervalCount) => {
  const firstViewDate = date_default.getFirstMonthDate(getViewStartByOptions2(startDate, currentDate, intervalCount, date_default.getFirstMonthDate(startDate)));
  return setOptionHour(firstViewDate, startDayHour);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/timeline_week.js
var getDateForHeaderText = (index2, date, _ref) => {
  let {
    startDayHour,
    startViewDate,
    cellCountInDay,
    interval,
    viewOffset
  } = _ref;
  return getValidCellDateForLocalTimeFormat(date, {
    startViewDate,
    startDayHour,
    cellIndexShift: index2 % cellCountInDay * interval,
    viewOffset
  });
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/views.js
var getCurrentView = (currentView, views) => {
  let currentViewProps = views.find((view) => {
    const names = isObject(view) ? [view.name, view.type] : [view];
    if (names.includes(currentView)) {
      return true;
    }
    return false;
  });
  if (void 0 === currentViewProps) {
    if (VIEW_TYPES.includes(currentView)) {
      currentViewProps = currentView;
    } else {
      [currentViewProps] = views;
    }
  }
  return currentViewProps;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/week.js
var getTimePanelCellText = (rowIndex, date, startViewDate, cellDuration, startDayHour, viewOffset) => {
  if (rowIndex % 2 !== 0) {
    return "";
  }
  const validTimeDate = getValidCellDateForLocalTimeFormat(date, {
    startViewDate,
    startDayHour,
    cellIndexShift: Math.round(cellDuration) * rowIndex,
    viewOffset
  });
  return date_default3.format(validTimeDate, "shorttime");
};
var getIntervalDuration = (intervalCount) => 7 * date_default.dateToMilliseconds("day") * intervalCount;
var getValidStartDate = (startDate, firstDayOfWeek) => startDate ? date_default.getFirstWeekDate(startDate, firstDayOfWeek) : void 0;
var calculateStartViewDate5 = (currentDate, startDayHour, startDate, intervalDuration, firstDayOfWeekOption) => {
  const firstDayOfWeek = getCalculatedFirstDayOfWeek(firstDayOfWeekOption);
  const viewStart = getViewStartByOptions(startDate, currentDate, intervalDuration, getValidStartDate(startDate, firstDayOfWeek));
  const firstViewDate = date_default.getFirstWeekDate(viewStart, firstDayOfWeek);
  return setOptionHour(firstViewDate, startDayHour);
};
var calculateViewStartDate2 = (startDateOption, firstDayOfWeek) => {
  const validFirstDayOfWeek = firstDayOfWeek ?? date_default3.firstDayOfWeekIndex();
  return date_default.getFirstWeekDate(startDateOption, validFirstDayOfWeek);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/work_week.js
var calculateStartViewDate6 = (currentDate, startDayHour, startDate, intervalDuration, firstDayOfWeek) => {
  const viewStart = getViewStartByOptions(startDate, currentDate, intervalDuration, getValidStartDate(startDate, firstDayOfWeek));
  const firstViewDate = date_default.getFirstWeekDate(viewStart, firstDayOfWeek);
  if (isDataOnWeekend(firstViewDate)) {
    const currentDay = firstViewDate.getDay();
    const distance = (8 - currentDay) % 7;
    firstViewDate.setDate(firstViewDate.getDate() + distance);
  }
  return setOptionHour(firstViewDate, startDayHour);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_expression_utils.js
var ExpressionUtils = {
  getField: (dataAccessors, field, obj) => {
    if (!isDefined(dataAccessors.getter[field])) {
      return;
    }
    return dataAccessors.getter[field](obj);
  },
  setField: (dataAccessors, field, obj, value2) => {
    if (!isDefined(dataAccessors.setter[field])) {
      return;
    }
    dataAccessors.setter[field](obj, value2);
    return obj;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/data_provider/m_utils.js
var toMs5 = date_default.dateToMilliseconds;
var FULL_DATE_FORMAT = "yyyyMMddTHHmmss";
var compareDateWithStartDayHour = (startDate, endDate, startDayHour, allDay, severalDays) => {
  const startTime = date_default.dateTimeFromDecimal(startDayHour);
  const result2 = startDate.getHours() >= startTime.hours && startDate.getMinutes() >= startTime.minutes || endDate.getHours() === startTime.hours && endDate.getMinutes() > startTime.minutes || endDate.getHours() > startTime.hours || severalDays || allDay;
  return result2;
};
var compareDateWithEndDayHour = (options2) => {
  const {
    startDate,
    endDate,
    startDayHour,
    endDayHour,
    viewStartDayHour,
    viewEndDayHour,
    allDay,
    severalDays,
    min,
    max,
    checkIntersectViewport
  } = options2;
  const hiddenInterval = (24 - viewEndDayHour + viewStartDayHour) * toMs5("hour");
  const apptDuration = endDate.getTime() - startDate.getTime();
  const delta = (hiddenInterval - apptDuration) / toMs5("hour");
  const apptStartHour = startDate.getHours();
  const apptStartMinutes = startDate.getMinutes();
  let result2;
  const endTime = date_default.dateTimeFromDecimal(endDayHour);
  const startTime = date_default.dateTimeFromDecimal(startDayHour);
  const apptIntersectViewport = startDate < max && endDate > min;
  result2 = checkIntersectViewport && apptIntersectViewport || apptStartHour < endTime.hours || apptStartHour === endTime.hours && apptStartMinutes < endTime.minutes || allDay && startDate <= max || severalDays && apptIntersectViewport && (apptStartHour < endTime.hours || 60 * endDate.getHours() + endDate.getMinutes() > 60 * startTime.hours);
  if (apptDuration < hiddenInterval) {
    if (apptStartHour > endTime.hours && apptStartMinutes > endTime.minutes && delta <= apptStartHour - endDayHour) {
      result2 = false;
    }
  }
  return result2;
};
var getAppointmentTakesSeveralDays = (adapter) => !date_default.sameDate(adapter.startDate, adapter.endDate);
var _isEndDateWrong = (startDate, endDate) => !endDate || isNaN(endDate.getTime()) || startDate.getTime() > endDate.getTime();
var _appointmentPartInInterval = (startDate, endDate, startDayHour, endDayHour) => {
  const apptStartDayHour = startDate.getHours();
  const apptEndDayHour = endDate.getHours();
  return apptStartDayHour <= startDayHour && apptEndDayHour <= endDayHour && apptEndDayHour >= startDayHour || apptEndDayHour >= endDayHour && apptStartDayHour <= endDayHour && apptStartDayHour >= startDayHour;
};
var getRecurrenceException = (appointmentAdapter, timeZoneCalculator, timeZone) => {
  const {
    recurrenceException
  } = appointmentAdapter;
  if (recurrenceException) {
    const exceptions = recurrenceException.split(",");
    for (let i = 0; i < exceptions.length; i++) {
      exceptions[i] = _convertRecurrenceException(exceptions[i], appointmentAdapter.startDate, timeZoneCalculator, timeZone);
    }
    return exceptions.join();
  }
  return recurrenceException;
};
var _convertRecurrenceException = (exceptionString, startDate, timeZoneCalculator, timeZone) => {
  exceptionString = exceptionString.replace(/\s/g, "");
  const getConvertedToTimeZone = (date) => timeZoneCalculator.createDate(date, {
    path: "toGrid"
  });
  const exceptionDate = date_serialization_default.deserializeDate(exceptionString);
  const convertedStartDate = getConvertedToTimeZone(startDate);
  let convertedExceptionDate = getConvertedToTimeZone(exceptionDate);
  convertedExceptionDate = m_utils_time_zone_default.correctRecurrenceExceptionByTimezone(convertedExceptionDate, convertedStartDate, timeZone);
  exceptionString = date_serialization_default.serializeDate(convertedExceptionDate, FULL_DATE_FORMAT);
  return exceptionString;
};
var replaceWrongEndDate = (rawAppointment, startDate, endDate, appointmentDuration, dataAccessors) => {
  if (_isEndDateWrong(startDate, endDate)) {
    const isAllDay = ExpressionUtils.getField(dataAccessors, "allDay", rawAppointment);
    const calculatedEndDate = ((isAllDay2, startDate2) => {
      if (isAllDay2) {
        return date_default.setToDayEnd(new Date(startDate2));
      }
      return new Date(startDate2.getTime() + appointmentDuration * toMs5("minute"));
    })(isAllDay, startDate);
    dataAccessors.setter.endDate(rawAppointment, calculatedEndDate);
  }
};
var sortAppointmentsByStartDate = (appointments, dataAccessors) => {
  appointments.sort((a, b) => {
    const firstDate = new Date(ExpressionUtils.getField(dataAccessors, "startDate", a.settings || a));
    const secondDate = new Date(ExpressionUtils.getField(dataAccessors, "startDate", b.settings || b));
    return Math.sign(firstDate.getTime() - secondDate.getTime());
  });
};

// ../../../../../../node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = (
  /** @class */
  function() {
    function Weekday2(weekday, n) {
      if (n === 0)
        throw new Error("Can't create weekday with n == 0");
      this.weekday = weekday;
      this.n = n;
    }
    Weekday2.fromStr = function(str) {
      return new Weekday2(ALL_WEEKDAYS.indexOf(str));
    };
    Weekday2.prototype.nth = function(n) {
      return this.n === n ? this : new Weekday2(this.weekday, n);
    };
    Weekday2.prototype.equals = function(other) {
      return this.weekday === other.weekday && this.n === other.n;
    };
    Weekday2.prototype.toString = function() {
      var s = ALL_WEEKDAYS[this.weekday];
      if (this.n)
        s = (this.n > 0 ? "+" : "") + String(this.n) + s;
      return s;
    };
    Weekday2.prototype.getJsWeekday = function() {
      return this.weekday === 6 ? 0 : this.weekday + 1;
    };
    return Weekday2;
  }()
);

// ../../../../../../node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value2) {
  return value2 !== null && value2 !== void 0;
};
var isNumber2 = function(value2) {
  return typeof value2 === "number";
};
var isWeekdayStr = function(value2) {
  return typeof value2 === "string" && ALL_WEEKDAYS.includes(value2);
};
var isArray2 = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i = start; i < end; i++)
    rang.push(i);
  return rang;
};
var repeat = function(value2, times) {
  var i = 0;
  var array = [];
  if (isArray2(value2)) {
    for (; i < times; i++)
      array[i] = [].concat(value2);
  } else {
    for (; i < times; i++)
      array[i] = value2;
  }
  return array;
};
var toArray = function(item) {
  if (isArray2(item)) {
    return item;
  }
  return [item];
};
function padStart(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};
var divmod = function(a, b) {
  return { div: Math.floor(a / b), mod: pymod(a, b) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// ../../../../../../node_modules/rrule/dist/esm/dateutil.js
var datetime = function(y, m, d, h2, i, s) {
  if (h2 === void 0) {
    h2 = 0;
  }
  if (i === void 0) {
    i = 0;
  }
  if (s === void 0) {
    s = 0;
  }
  return new Date(Date.UTC(y, m - 1, d, h2, i, s));
};
var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var ONE_DAY = 1e3 * 60 * 60 * 24;
var MAXYEAR = 9999;
var ORDINAL_BASE = datetime(1970, 1, 1);
var PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
var isLeapYear = function(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var isDate2 = function(value2) {
  return value2 instanceof Date;
};
var isValidDate2 = function(value2) {
  return isDate2(value2) && !isNaN(value2.getTime());
};
var daysBetween = function(date1, date2) {
  var date1ms = date1.getTime();
  var date2ms = date2.getTime();
  var differencems = date1ms - date2ms;
  return Math.round(differencems / ONE_DAY);
};
var toOrdinal = function(date) {
  return daysBetween(date, ORDINAL_BASE);
};
var fromOrdinal = function(ordinal) {
  return new Date(ORDINAL_BASE.getTime() + ordinal * ONE_DAY);
};
var getMonthDays = function(date) {
  var month = date.getUTCMonth();
  return month === 1 && isLeapYear(date.getUTCFullYear()) ? 29 : MONTH_DAYS[month];
};
var getWeekday = function(date) {
  return PY_WEEKDAYS[date.getUTCDay()];
};
var monthRange = function(year, month) {
  var date = datetime(year, month + 1, 1);
  return [getWeekday(date), getMonthDays(date)];
};
var combine = function(date, time) {
  time = time || date;
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
};
var clone2 = function(date) {
  var dolly = new Date(date.getTime());
  return dolly;
};
var cloneDates = function(dates) {
  var clones = [];
  for (var i = 0; i < dates.length; i++) {
    clones.push(clone2(dates[i]));
  }
  return clones;
};
var sort = function(dates) {
  dates.sort(function(a, b) {
    return a.getTime() - b.getTime();
  });
};
var timeToUntilString = function(time, utc) {
  if (utc === void 0) {
    utc = true;
  }
  var date = new Date(time);
  return [
    padStart(date.getUTCFullYear().toString(), 4, "0"),
    padStart(date.getUTCMonth() + 1, 2, "0"),
    padStart(date.getUTCDate(), 2, "0"),
    "T",
    padStart(date.getUTCHours(), 2, "0"),
    padStart(date.getUTCMinutes(), 2, "0"),
    padStart(date.getUTCSeconds(), 2, "0"),
    utc ? "Z" : ""
  ].join("");
};
var untilStringToDate = function(until) {
  var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
  var bits = re.exec(until);
  if (!bits)
    throw new Error("Invalid UNTIL value: ".concat(until));
  return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
};
var dateTZtoISO8601 = function(date, timeZone) {
  var dateStr = date.toLocaleString("sv-SE", { timeZone });
  return dateStr.replace(" ", "T") + "Z";
};
var dateInTimeZone = function(date, timeZone) {
  var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  var dateInLocalTZ = new Date(dateTZtoISO8601(date, localTimeZone));
  var dateInTargetTZ = new Date(dateTZtoISO8601(date, timeZone !== null && timeZone !== void 0 ? timeZone : "UTC"));
  var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
  return new Date(date.getTime() - tzOffset);
};

// ../../../../../../node_modules/rrule/dist/esm/iterresult.js
var IterResult = (
  /** @class */
  function() {
    function IterResult2(method, args) {
      this.minDate = null;
      this.maxDate = null;
      this._result = [];
      this.total = 0;
      this.method = method;
      this.args = args;
      if (method === "between") {
        this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
        this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
      } else if (method === "before") {
        this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
      } else if (method === "after") {
        this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
      }
    }
    IterResult2.prototype.accept = function(date) {
      ++this.total;
      var tooEarly = this.minDate && date < this.minDate;
      var tooLate = this.maxDate && date > this.maxDate;
      if (this.method === "between") {
        if (tooEarly)
          return true;
        if (tooLate)
          return false;
      } else if (this.method === "before") {
        if (tooLate)
          return false;
      } else if (this.method === "after") {
        if (tooEarly)
          return true;
        this.add(date);
        return false;
      }
      return this.add(date);
    };
    IterResult2.prototype.add = function(date) {
      this._result.push(date);
      return true;
    };
    IterResult2.prototype.getValue = function() {
      var res = this._result;
      switch (this.method) {
        case "all":
        case "between":
          return res;
        case "before":
        case "after":
        default:
          return res.length ? res[res.length - 1] : null;
      }
    };
    IterResult2.prototype.clone = function() {
      return new IterResult2(this.method, this.args);
    };
    return IterResult2;
  }()
);
var iterresult_default = IterResult;

// ../../../../../../node_modules/rrule/node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p2))
        d2[p2] = b2[p2];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// ../../../../../../node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = (
  /** @class */
  function(_super) {
    __extends(CallbackIterResult2, _super);
    function CallbackIterResult2(method, args, iterator) {
      var _this = _super.call(this, method, args) || this;
      _this.iterator = iterator;
      return _this;
    }
    CallbackIterResult2.prototype.add = function(date) {
      if (this.iterator(date, this._result.length)) {
        this._result.push(date);
        return true;
      }
      return false;
    };
    return CallbackIterResult2;
  }(iterresult_default)
);
var callbackiterresult_default = CallbackIterResult;

// ../../../../../../node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// ../../../../../../node_modules/rrule/dist/esm/nlp/totext.js
var contains3 = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = (
  /** @class */
  function() {
    function ToText2(rrule, gettext, language, dateFormatter) {
      if (gettext === void 0) {
        gettext = defaultGetText;
      }
      if (language === void 0) {
        language = i18n_default;
      }
      if (dateFormatter === void 0) {
        dateFormatter = defaultDateFormatter;
      }
      this.text = [];
      this.language = language || i18n_default;
      this.gettext = gettext;
      this.dateFormatter = dateFormatter;
      this.rrule = rrule;
      this.options = rrule.options;
      this.origOptions = rrule.origOptions;
      if (this.origOptions.bymonthday) {
        var bymonthday = [].concat(this.options.bymonthday);
        var bynmonthday = [].concat(this.options.bynmonthday);
        bymonthday.sort(function(a, b) {
          return a - b;
        });
        bynmonthday.sort(function(a, b) {
          return b - a;
        });
        this.bymonthday = bymonthday.concat(bynmonthday);
        if (!this.bymonthday.length)
          this.bymonthday = null;
      }
      if (isPresent(this.origOptions.byweekday)) {
        var byweekday = !isArray2(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
        var days3 = String(byweekday);
        this.byweekday = {
          allWeeks: byweekday.filter(function(weekday) {
            return !weekday.n;
          }),
          someWeeks: byweekday.filter(function(weekday) {
            return Boolean(weekday.n);
          }),
          isWeekdays: days3.indexOf("MO") !== -1 && days3.indexOf("TU") !== -1 && days3.indexOf("WE") !== -1 && days3.indexOf("TH") !== -1 && days3.indexOf("FR") !== -1 && days3.indexOf("SA") === -1 && days3.indexOf("SU") === -1,
          isEveryDay: days3.indexOf("MO") !== -1 && days3.indexOf("TU") !== -1 && days3.indexOf("WE") !== -1 && days3.indexOf("TH") !== -1 && days3.indexOf("FR") !== -1 && days3.indexOf("SA") !== -1 && days3.indexOf("SU") !== -1
        };
        var sortWeekDays = function(a, b) {
          return a.weekday - b.weekday;
        };
        this.byweekday.allWeeks.sort(sortWeekDays);
        this.byweekday.someWeeks.sort(sortWeekDays);
        if (!this.byweekday.allWeeks.length)
          this.byweekday.allWeeks = null;
        if (!this.byweekday.someWeeks.length)
          this.byweekday.someWeeks = null;
      } else {
        this.byweekday = null;
      }
    }
    ToText2.isFullyConvertible = function(rrule) {
      var canConvert = true;
      if (!(rrule.options.freq in ToText2.IMPLEMENTED))
        return false;
      if (rrule.origOptions.until && rrule.origOptions.count)
        return false;
      for (var key in rrule.origOptions) {
        if (contains3(["dtstart", "tzid", "wkst", "freq"], key))
          return true;
        if (!contains3(ToText2.IMPLEMENTED[rrule.options.freq], key))
          return false;
      }
      return canConvert;
    };
    ToText2.prototype.isFullyConvertible = function() {
      return ToText2.isFullyConvertible(this.rrule);
    };
    ToText2.prototype.toString = function() {
      var gettext = this.gettext;
      if (!(this.options.freq in ToText2.IMPLEMENTED)) {
        return gettext("RRule error: Unable to fully convert this rrule to text");
      }
      this.text = [gettext("every")];
      this[RRule.FREQUENCIES[this.options.freq]]();
      if (this.options.until) {
        this.add(gettext("until"));
        var until = this.options.until;
        this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
      } else if (this.options.count) {
        this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
      }
      if (!this.isFullyConvertible())
        this.add(gettext("(~ approximate)"));
      return this.text.join("");
    };
    ToText2.prototype.HOURLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
    };
    ToText2.prototype.MINUTELY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
    };
    ToText2.prototype.DAILY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      }
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      } else if (this.origOptions.byhour) {
        this._byhour();
      }
    };
    ToText2.prototype.WEEKLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
      }
      if (this.byweekday && this.byweekday.isWeekdays) {
        if (this.options.interval === 1) {
          this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
        } else {
          this.add(gettext("on")).add(gettext("weekdays"));
        }
      } else if (this.byweekday && this.byweekday.isEveryDay) {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      } else {
        if (this.options.interval === 1)
          this.add(gettext("week"));
        if (this.origOptions.bymonth) {
          this.add(gettext("in"));
          this._bymonth();
        }
        if (this.bymonthday) {
          this._bymonthday();
        } else if (this.byweekday) {
          this._byweekday();
        }
        if (this.origOptions.byhour) {
          this._byhour();
        }
      }
    };
    ToText2.prototype.MONTHLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString()).add(gettext("months"));
          if (this.plural(this.options.interval))
            this.add(gettext("in"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(gettext("weekdays"));
      } else if (this.byweekday) {
        this._byweekday();
      }
    };
    ToText2.prototype.YEARLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
          this.add(gettext("years"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
      if (this.options.byyearday) {
        this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
      }
      if (this.options.byweekno) {
        this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
      }
    };
    ToText2.prototype._bymonthday = function() {
      var gettext = this.gettext;
      if (this.byweekday && this.byweekday.allWeeks) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
      } else {
        this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
      }
    };
    ToText2.prototype._byweekday = function() {
      var gettext = this.gettext;
      if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
      }
      if (this.byweekday.someWeeks) {
        if (this.byweekday.allWeeks)
          this.add(gettext("and"));
        this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
      }
    };
    ToText2.prototype._byhour = function() {
      var gettext = this.gettext;
      this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
    };
    ToText2.prototype._bymonth = function() {
      this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
    };
    ToText2.prototype.nth = function(n) {
      n = parseInt(n.toString(), 10);
      var nth;
      var gettext = this.gettext;
      if (n === -1)
        return gettext("last");
      var npos = Math.abs(n);
      switch (npos) {
        case 1:
        case 21:
        case 31:
          nth = npos + gettext("st");
          break;
        case 2:
        case 22:
          nth = npos + gettext("nd");
          break;
        case 3:
        case 23:
          nth = npos + gettext("rd");
          break;
        default:
          nth = npos + gettext("th");
      }
      return n < 0 ? nth + " " + gettext("last") : nth;
    };
    ToText2.prototype.monthtext = function(m) {
      return this.language.monthNames[m - 1];
    };
    ToText2.prototype.weekdaytext = function(wday) {
      var weekday = isNumber2(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
      return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
    };
    ToText2.prototype.plural = function(n) {
      return n % 100 !== 1;
    };
    ToText2.prototype.add = function(s) {
      this.text.push(" ");
      this.text.push(s);
      return this;
    };
    ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
      var _this = this;
      if (delim === void 0) {
        delim = ",";
      }
      if (!isArray2(arr)) {
        arr = [arr];
      }
      var delimJoin = function(array, delimiter, finalDelimiter) {
        var list = "";
        for (var i = 0; i < array.length; i++) {
          if (i !== 0) {
            if (i === array.length - 1) {
              list += " " + finalDelimiter + " ";
            } else {
              list += delimiter + " ";
            }
          }
          list += array[i];
        }
        return list;
      };
      callback = callback || function(o) {
        return o.toString();
      };
      var realCallback = function(arg) {
        return callback && callback.call(_this, arg);
      };
      if (finalDelim) {
        return delimJoin(arr.map(realCallback), delim, finalDelim);
      } else {
        return arr.map(realCallback).join(delim + " ");
      }
    };
    return ToText2;
  }()
);
var totext_default = ToText;

// ../../../../../../node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = (
  /** @class */
  function() {
    function Parser2(rules) {
      this.done = true;
      this.rules = rules;
    }
    Parser2.prototype.start = function(text) {
      this.text = text;
      this.done = false;
      return this.nextSymbol();
    };
    Parser2.prototype.isDone = function() {
      return this.done && this.symbol === null;
    };
    Parser2.prototype.nextSymbol = function() {
      var best;
      var bestSymbol;
      this.symbol = null;
      this.value = null;
      do {
        if (this.done)
          return false;
        var rule = void 0;
        best = null;
        for (var name_1 in this.rules) {
          rule = this.rules[name_1];
          var match2 = rule.exec(this.text);
          if (match2) {
            if (best === null || match2[0].length > best[0].length) {
              best = match2;
              bestSymbol = name_1;
            }
          }
        }
        if (best != null) {
          this.text = this.text.substr(best[0].length);
          if (this.text === "")
            this.done = true;
        }
        if (best == null) {
          this.done = true;
          this.symbol = null;
          this.value = null;
          return;
        }
      } while (bestSymbol === "SKIP");
      this.symbol = bestSymbol;
      this.value = best;
      return true;
    };
    Parser2.prototype.accept = function(name2) {
      if (this.symbol === name2) {
        if (this.value) {
          var v = this.value;
          this.nextSymbol();
          return v;
        }
        this.nextSymbol();
        return true;
      }
      return false;
    };
    Parser2.prototype.acceptNumber = function() {
      return this.accept("number");
    };
    Parser2.prototype.expect = function(name2) {
      if (this.accept(name2))
        return true;
      throw new Error("expected " + name2 + " but found " + this.symbol);
    };
    return Parser2;
  }()
);
function parseText(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options2 = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text))
    return null;
  S();
  return options2;
  function S() {
    ttr.expect("every");
    var n = ttr.acceptNumber();
    if (n)
      options2.interval = parseInt(n[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options2.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F();
        }
        break;
      case "weekday(s)":
        options2.freq = RRule.WEEKLY;
        options2.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        AT();
        F();
        break;
      case "week(s)":
        options2.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          AT();
          F();
        }
        break;
      case "hour(s)":
        options2.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "minute(s)":
        options2.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "month(s)":
        options2.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "year(s)":
        options2.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options2.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options2.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options2.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        AT();
        MDAYs();
        F();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options2.freq = RRule.YEARLY;
        options2.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m = decodeM();
          if (!m) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options2.bymonth.push(m);
          ttr.nextSymbol();
        }
        ON();
        F();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on2 = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on2 || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options2.byweekday)
            options2.byweekday = [];
          options2.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options2.bymonthday)
            options2.bymonthday = [];
          options2.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options2.byweekday)
          options2.byweekday = [];
        options2.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options2.byweekday) {
          options2.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options2.byweekno = [parseInt(n[0], 10)];
        while (ttr.accept("comma")) {
          n = ttr.acceptNumber();
          if (!n) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options2.byweekno.push(parseInt(n[0], 10));
        }
      } else if (m) {
        ttr.nextSymbol();
        if (!options2.bymonth)
          options2.bymonth = [];
        options2.bymonth.push(m);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n = ttr.acceptNumber();
      if (!n) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options2.byhour = [parseInt(n[0], 10)];
      while (ttr.accept("comma")) {
        n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options2.byhour.push(parseInt(n[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v = parseInt(ttr.value[1], 10);
        if (v < -366 || v > 366)
          throw new Error("Nth out of range: " + v);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v : v;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options2.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options2.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options2.until = new Date(date);
    } else if (ttr.accept("for")) {
      options2.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// ../../../../../../node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// ../../../../../../node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// ../../../../../../node_modules/rrule/dist/esm/datetime.js
var Time = (
  /** @class */
  function() {
    function Time2(hour, minute, second, millisecond) {
      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.millisecond = millisecond || 0;
    }
    Time2.prototype.getHours = function() {
      return this.hour;
    };
    Time2.prototype.getMinutes = function() {
      return this.minute;
    };
    Time2.prototype.getSeconds = function() {
      return this.second;
    };
    Time2.prototype.getMilliseconds = function() {
      return this.millisecond;
    };
    Time2.prototype.getTime = function() {
      return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
    };
    return Time2;
  }()
);
var DateTime = (
  /** @class */
  function(_super) {
    __extends(DateTime2, _super);
    function DateTime2(year, month, day, hour, minute, second, millisecond) {
      var _this = _super.call(this, hour, minute, second, millisecond) || this;
      _this.year = year;
      _this.month = month;
      _this.day = day;
      return _this;
    }
    DateTime2.fromDate = function(date) {
      return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
    };
    DateTime2.prototype.getWeekday = function() {
      return getWeekday(new Date(this.getTime()));
    };
    DateTime2.prototype.getTime = function() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
    };
    DateTime2.prototype.getDay = function() {
      return this.day;
    };
    DateTime2.prototype.getMonth = function() {
      return this.month;
    };
    DateTime2.prototype.getYear = function() {
      return this.year;
    };
    DateTime2.prototype.addYears = function(years) {
      this.year += years;
    };
    DateTime2.prototype.addMonths = function(months) {
      this.month += months;
      if (this.month > 12) {
        var yearDiv = Math.floor(this.month / 12);
        var monthMod = pymod(this.month, 12);
        this.month = monthMod;
        this.year += yearDiv;
        if (this.month === 0) {
          this.month = 12;
          --this.year;
        }
      }
    };
    DateTime2.prototype.addWeekly = function(days3, wkst) {
      if (wkst > this.getWeekday()) {
        this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days3 * 7;
      } else {
        this.day += -(this.getWeekday() - wkst) + days3 * 7;
      }
      this.fixDay();
    };
    DateTime2.prototype.addDaily = function(days3) {
      this.day += days3;
      this.fixDay();
    };
    DateTime2.prototype.addHours = function(hours, filtered, byhour) {
      if (filtered) {
        this.hour += Math.floor((23 - this.hour) / hours) * hours;
      }
      for (; ; ) {
        this.hour += hours;
        var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
        if (dayDiv) {
          this.hour = hourMod;
          this.addDaily(dayDiv);
        }
        if (empty(byhour) || includes(byhour, this.hour))
          break;
      }
    };
    DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
      if (filtered) {
        this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
      }
      for (; ; ) {
        this.minute += minutes;
        var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
        if (hourDiv) {
          this.minute = minuteMod;
          this.addHours(hourDiv, false, byhour);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
          break;
        }
      }
    };
    DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
      if (filtered) {
        this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
      }
      for (; ; ) {
        this.second += seconds;
        var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
        if (minuteDiv) {
          this.second = secondMod;
          this.addMinutes(minuteDiv, false, byhour, byminute);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
          break;
        }
      }
    };
    DateTime2.prototype.fixDay = function() {
      if (this.day <= 28) {
        return;
      }
      var daysinmonth = monthRange(this.year, this.month - 1)[1];
      if (this.day <= daysinmonth) {
        return;
      }
      while (this.day > daysinmonth) {
        this.day -= daysinmonth;
        ++this.month;
        if (this.month === 13) {
          this.month = 1;
          ++this.year;
          if (this.year > MAXYEAR) {
            return;
          }
        }
        daysinmonth = monthRange(this.year, this.month - 1)[1];
      }
    };
    DateTime2.prototype.add = function(options2, filtered) {
      var freq = options2.freq, interval = options2.interval, wkst = options2.wkst, byhour = options2.byhour, byminute = options2.byminute, bysecond = options2.bysecond;
      switch (freq) {
        case Frequency.YEARLY:
          return this.addYears(interval);
        case Frequency.MONTHLY:
          return this.addMonths(interval);
        case Frequency.WEEKLY:
          return this.addWeekly(interval, wkst);
        case Frequency.DAILY:
          return this.addDaily(interval);
        case Frequency.HOURLY:
          return this.addHours(interval, filtered, byhour);
        case Frequency.MINUTELY:
          return this.addMinutes(interval, filtered, byhour, byminute);
        case Frequency.SECONDLY:
          return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
      }
    };
    return DateTime2;
  }(Time)
);

// ../../../../../../node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options2) {
  var invalid = [];
  var keys = Object.keys(options2);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (isDate2(options2[key]) && !isValidDate2(options2[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options2);
}
function parseOptions(options2) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options2));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options2.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date((/* @__PURE__ */ new Date()).setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber2(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber2(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i = 0; i < opts.bysetpos.length; i++) {
      var v = opts.bysetpos[i];
      if (v === 0 || !(v >= -366 && v <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray2(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray2(opts.byyearday) && isNumber2(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray2(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i = 0; i < opts.bymonthday.length; i++) {
      var v = opts.bymonthday[i];
      if (v > 0) {
        bymonthday.push(v);
      } else if (v < 0) {
        bynmonthday.push(v);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray2(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber2(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i = 0; i < opts.byweekday.length; i++) {
      var wday = opts.byweekday[i];
      if (isNumber2(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber2(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber2(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber2(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// ../../../../../../node_modules/rrule/dist/esm/parsestring.js
function parseString(rfcString) {
  var options2 = rfcString.split("\n").map(parseLine).filter(function(x) {
    return x !== null;
  });
  return __assign(__assign({}, options2[0]), options2[1]);
}
function parseDtstart(line) {
  var options2 = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options2;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options2.tzid = tzid;
  }
  options2.dtstart = untilStringToDate(dtstart);
  return options2;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options2 = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr) {
    var _a = attr.split("="), key = _a[0], value2 = _a[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options2.freq = Frequency[value2.toUpperCase()];
        break;
      case "WKST":
        options2.wkst = Days[value2.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber2(value2);
        var optionKey = key.toLowerCase();
        options2[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options2.byweekday = parseWeekday(value2);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options2.tzid = dtstart.tzid;
        options2.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options2.until = untilStringToDate(value2);
        break;
      case "BYEASTER":
        options2.byeaster = Number(value2);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options2;
}
function parseNumber2(value2) {
  if (value2.indexOf(",") !== -1) {
    var values = value2.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value2);
}
function parseIndividualNumber(value2) {
  if (/^[+-]?\d+$/.test(value2)) {
    return Number(value2);
  }
  return value2;
}
function parseWeekday(value2) {
  var days3 = value2.split(",");
  return days3.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n);
  });
}

// ../../../../../../node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = (
  /** @class */
  function() {
    function DateWithZone2(date, tzid) {
      if (isNaN(date.getTime())) {
        throw new RangeError("Invalid date passed to DateWithZone");
      }
      this.date = date;
      this.tzid = tzid;
    }
    Object.defineProperty(DateWithZone2.prototype, "isUTC", {
      get: function() {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: false,
      configurable: true
    });
    DateWithZone2.prototype.toString = function() {
      var datestr = timeToUntilString(this.date.getTime(), this.isUTC);
      if (!this.isUTC) {
        return ";TZID=".concat(this.tzid, ":").concat(datestr);
      }
      return ":".concat(datestr);
    };
    DateWithZone2.prototype.getTime = function() {
      return this.date.getTime();
    };
    DateWithZone2.prototype.rezonedDate = function() {
      if (this.isUTC) {
        return this.date;
      }
      return dateInTimeZone(this.date, this.tzid);
    };
    return DateWithZone2;
  }()
);

// ../../../../../../node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options2) {
  var rrule = [];
  var dtstart = "";
  var keys = Object.keys(options2);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i = 0; i < keys.length; i++) {
    if (keys[i] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys[i]))
      continue;
    var key = keys[i].toUpperCase();
    var value2 = options2[keys[i]];
    var outValue = "";
    if (!isPresent(value2) || isArray2(value2) && !value2.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options2.freq];
        break;
      case "WKST":
        if (isNumber2(value2)) {
          outValue = new Weekday(value2).toString();
        } else {
          outValue = value2.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value2).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray2(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value2, options2.tzid);
        break;
      case "UNTIL":
        outValue = timeToUntilString(value2, !options2.tzid);
        break;
      default:
        if (isArray2(value2)) {
          var strValues = [];
          for (var j = 0; j < value2.length; j++) {
            strValues[j] = String(value2[j]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value2);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a) {
    var key2 = _a[0], value3 = _a[1];
    return "".concat(key2, "=").concat(value3.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x) {
    return !!x;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// ../../../../../../node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i) {
      return date.getTime() === right[i].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = (
  /** @class */
  function() {
    function Cache3() {
      this.all = false;
      this.before = [];
      this.after = [];
      this.between = [];
    }
    Cache3.prototype._cacheAdd = function(what, value2, args) {
      if (value2) {
        value2 = value2 instanceof Date ? clone2(value2) : cloneDates(value2);
      }
      if (what === "all") {
        this.all = value2;
      } else {
        args._value = value2;
        this[what].push(args);
      }
    };
    Cache3.prototype._cacheGet = function(what, args) {
      var cached = false;
      var argsKeys = args ? Object.keys(args) : [];
      var findCacheDiff = function(item2) {
        for (var i2 = 0; i2 < argsKeys.length; i2++) {
          var key = argsKeys[i2];
          if (!argsMatch(args[key], item2[key])) {
            return true;
          }
        }
        return false;
      };
      var cachedObject = this[what];
      if (what === "all") {
        cached = this.all;
      } else if (isArray2(cachedObject)) {
        for (var i = 0; i < cachedObject.length; i++) {
          var item = cachedObject[i];
          if (argsKeys.length && findCacheDiff(item))
            continue;
          cached = item._value;
          break;
        }
      }
      if (!cached && this.all) {
        var iterResult = new iterresult_default(what, args);
        for (var i = 0; i < this.all.length; i++) {
          if (!iterResult.accept(this.all[i]))
            break;
        }
        cached = iterResult.getValue();
        this._cacheAdd(what, cached, args);
      }
      return isArray2(cached) ? cloneDates(cached) : cached instanceof Date ? clone2(cached) : cached;
    };
    return Cache3;
  }()
);

// ../../../../../../node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i = 0; i < 55; i++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// ../../../../../../node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options2) {
  var firstyday = datetime(year, 1, 1);
  var yearlen = isLeapYear(year) ? 366 : 365;
  var nextyearlen = isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = toOrdinal(firstyday);
  var yearweekday = getWeekday(firstyday);
  var result2 = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options2.byweekno)) {
    return result2;
  }
  result2.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options2.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result2.yearlen + pymod(yearweekday - options2.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j = 0; j < options2.byweekno.length; j++) {
    var n = options2.byweekno[j];
    if (n < 0) {
      n += numweeks + 1;
    }
    if (!(n > 0 && n <= numweeks)) {
      continue;
    }
    var i = void 0;
    if (n > 1) {
      i = no1wkst + (n - 1) * 7;
      if (no1wkst !== firstwkst) {
        i -= 7 - firstwkst;
      }
    } else {
      i = no1wkst;
    }
    for (var k = 0; k < 7; k++) {
      result2.wnomask[i] = 1;
      i++;
      if (result2.wdaymask[i] === options2.wkst)
        break;
    }
  }
  if (includes(options2.byweekno, 1)) {
    var i = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i -= 7 - firstwkst;
    if (i < yearlen) {
      for (var j = 0; j < 7; j++) {
        result2.wnomask[i] = 1;
        i += 1;
        if (result2.wdaymask[i] === options2.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options2.byweekno, -1)) {
      var lyearweekday = getWeekday(datetime(year - 1, 1, 1));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options2.wkst, 7);
      var lyearlen = isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options2.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options2.byweekno, lnumweeks)) {
      for (var i = 0; i < no1wkst; i++)
        result2.wnomask[i] = 1;
    }
  }
  return result2;
}
function baseYearMasks(year) {
  var yearlen = isLeapYear(year) ? 366 : 365;
  var firstyday = datetime(year, 1, 1);
  var wday = getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// ../../../../../../node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options2) {
  var result2 = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options2.freq === RRule.YEARLY) {
    if (empty(options2.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j = 0; j < options2.bymonth.length; j++) {
        month = options2.bymonth[j];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options2.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result2;
  }
  result2.nwdaymask = repeat(0, yearlen);
  for (var j = 0; j < ranges.length; j++) {
    var rang = ranges[j];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k = 0; k < options2.bynweekday.length; k++) {
      var i = void 0;
      var _a = options2.bynweekday[k], wday = _a[0], n = _a[1];
      if (n < 0) {
        i = last + (n + 1) * 7;
        i -= pymod(wdaymask[i] - wday, 7);
      } else {
        i = first + (n - 1) * 7;
        i += pymod(7 - wdaymask[i] + wday, 7);
      }
      if (first <= i && i <= last)
        result2.nwdaymask[i] = 1;
    }
  }
  return result2;
}

// ../../../../../../node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y, offset2) {
  if (offset2 === void 0) {
    offset2 = 0;
  }
  var a = y % 19;
  var b = Math.floor(y / 100);
  var c = y % 100;
  var d = Math.floor(b / 4);
  var e = b % 4;
  var f = Math.floor((b + 8) / 25);
  var g = Math.floor((b - f + 1) / 3);
  var h2 = Math.floor(19 * a + b - d - g + 15) % 30;
  var i = Math.floor(c / 4);
  var k = c % 4;
  var l = Math.floor(32 + 2 * e + 2 * i - h2 - k) % 7;
  var m = Math.floor((a + 11 * h2 + 22 * l) / 451);
  var month = Math.floor((h2 + l - 7 * m + 114) / 31);
  var day = (h2 + l - 7 * m + 114) % 31 + 1;
  var date = Date.UTC(y, month - 1, day + offset2);
  var yearStart = Date.UTC(y, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// ../../../../../../node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = (
  /** @class */
  function() {
    function Iterinfo2(options2) {
      this.options = options2;
    }
    Iterinfo2.prototype.rebuild = function(year, month) {
      var options2 = this.options;
      if (year !== this.lastyear) {
        this.yearinfo = rebuildYear(year, options2);
      }
      if (notEmpty(options2.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
        var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
        this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options2);
      }
      if (isPresent(options2.byeaster)) {
        this.eastermask = easter(year, options2.byeaster);
      }
    };
    Object.defineProperty(Iterinfo2.prototype, "lastyear", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearlen", {
      get: function() {
        return this.yearinfo.yearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
      get: function() {
        return this.yearinfo.yearordinal;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mrange", {
      get: function() {
        return this.yearinfo.mrange;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
      get: function() {
        return this.yearinfo.wdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mmask", {
      get: function() {
        return this.yearinfo.mmask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wnomask", {
      get: function() {
        return this.yearinfo.wnomask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
      get: function() {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
      get: function() {
        return this.yearinfo.nextyearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
      get: function() {
        return this.yearinfo.mdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
      get: function() {
        return this.yearinfo.nmdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Iterinfo2.prototype.ydayset = function() {
      return [range(this.yearlen), 0, this.yearlen];
    };
    Iterinfo2.prototype.mdayset = function(_, month) {
      var start = this.mrange[month - 1];
      var end = this.mrange[month];
      var set = repeat(null, this.yearlen);
      for (var i = start; i < end; i++)
        set[i] = i;
      return [set, start, end];
    };
    Iterinfo2.prototype.wdayset = function(year, month, day) {
      var set = repeat(null, this.yearlen + 7);
      var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      var start = i;
      for (var j = 0; j < 7; j++) {
        set[i] = i;
        ++i;
        if (this.wdaymask[i] === this.options.wkst)
          break;
      }
      return [set, start, i];
    };
    Iterinfo2.prototype.ddayset = function(year, month, day) {
      var set = repeat(null, this.yearlen);
      var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      set[i] = i;
      return [set, i, i + 1];
    };
    Iterinfo2.prototype.htimeset = function(hour, _, second, millisecond) {
      var _this = this;
      var set = [];
      this.options.byminute.forEach(function(minute) {
        set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.mtimeset = function(hour, minute, _, millisecond) {
      var set = this.options.bysecond.map(function(second) {
        return new Time(hour, minute, second, millisecond);
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
      return [new Time(hour, minute, second, millisecond)];
    };
    Iterinfo2.prototype.getdayset = function(freq) {
      switch (freq) {
        case Frequency.YEARLY:
          return this.ydayset.bind(this);
        case Frequency.MONTHLY:
          return this.mdayset.bind(this);
        case Frequency.WEEKLY:
          return this.wdayset.bind(this);
        case Frequency.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    };
    Iterinfo2.prototype.gettimeset = function(freq) {
      switch (freq) {
        case Frequency.HOURLY:
          return this.htimeset.bind(this);
        case Frequency.MINUTELY:
          return this.mtimeset.bind(this);
        case Frequency.SECONDLY:
          return this.stimeset.bind(this);
      }
    };
    return Iterinfo2;
  }()
);
var iterinfo_default = Iterinfo;

// ../../../../../../node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j = 0; j < bysetpos.length; j++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k = start; k < end; k++) {
      var val = dayset[k];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i = void 0;
    if (daypos < 0) {
      i = tmp.slice(daypos)[0];
    } else {
      i = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = fromOrdinal(ii.yearordinal + i);
    var res = combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  sort(poslist);
  return poslist;
}

// ../../../../../../node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options2) {
  var dtstart = options2.dtstart, freq = options2.freq, interval = options2.interval, until = options2.until, bysetpos = options2.bysetpos;
  var count = options2.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options2);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options2);
  for (; ; ) {
    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options2);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j = 0; j < poslist.length; j++) {
        var res = poslist[j];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options2);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j = start; j < end; j++) {
        var currentDay = dayset[j];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = fromOrdinal(ii.yearordinal + currentDay);
        for (var k = 0; k < timeset.length; k++) {
          var time = timeset[k];
          var res = combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options2);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options2.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options2, filtered);
    if (counterDate.year > MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options2) {
  var bymonth = options2.bymonth, byweekno = options2.byweekno, byweekday = options2.byweekday, byeaster = options2.byeaster, bymonthday = options2.bymonthday, bynmonthday = options2.bynmonthday, byyearday = options2.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options2) {
  return new DateWithZone(date, options2.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options2) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options2);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options2) {
  var freq = options2.freq, byhour = options2.byhour, byminute = options2.byminute, bysecond = options2.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options2);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// ../../../../../../node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = (
  /** @class */
  function() {
    function RRule2(options2, noCache) {
      if (options2 === void 0) {
        options2 = {};
      }
      if (noCache === void 0) {
        noCache = false;
      }
      this._cache = noCache ? null : new Cache();
      this.origOptions = initializeOptions(options2);
      var parsedOptions = parseOptions(options2).parsedOptions;
      this.options = parsedOptions;
    }
    RRule2.parseText = function(text, language) {
      return parseText(text, language);
    };
    RRule2.fromText = function(text, language) {
      return fromText(text, language);
    };
    RRule2.fromString = function(str) {
      return new RRule2(RRule2.parseString(str) || void 0);
    };
    RRule2.prototype._iter = function(iterResult) {
      return iter(iterResult, this.options);
    };
    RRule2.prototype._cacheGet = function(what, args) {
      if (!this._cache)
        return false;
      return this._cache._cacheGet(what, args);
    };
    RRule2.prototype._cacheAdd = function(what, value2, args) {
      if (!this._cache)
        return;
      return this._cache._cacheAdd(what, value2, args);
    };
    RRule2.prototype.all = function(iterator) {
      if (iterator) {
        return this._iter(new callbackiterresult_default("all", {}, iterator));
      }
      var result2 = this._cacheGet("all");
      if (result2 === false) {
        result2 = this._iter(new iterresult_default("all", {}));
        this._cacheAdd("all", result2);
      }
      return result2;
    };
    RRule2.prototype.between = function(after, before, inc, iterator) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(after) || !isValidDate2(before)) {
        throw new Error("Invalid date passed in to RRule.between");
      }
      var args = {
        before,
        after,
        inc
      };
      if (iterator) {
        return this._iter(new callbackiterresult_default("between", args, iterator));
      }
      var result2 = this._cacheGet("between", args);
      if (result2 === false) {
        result2 = this._iter(new iterresult_default("between", args));
        this._cacheAdd("between", result2, args);
      }
      return result2;
    };
    RRule2.prototype.before = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.before");
      }
      var args = { dt, inc };
      var result2 = this._cacheGet("before", args);
      if (result2 === false) {
        result2 = this._iter(new iterresult_default("before", args));
        this._cacheAdd("before", result2, args);
      }
      return result2;
    };
    RRule2.prototype.after = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.after");
      }
      var args = { dt, inc };
      var result2 = this._cacheGet("after", args);
      if (result2 === false) {
        result2 = this._iter(new iterresult_default("after", args));
        this._cacheAdd("after", result2, args);
      }
      return result2;
    };
    RRule2.prototype.count = function() {
      return this.all().length;
    };
    RRule2.prototype.toString = function() {
      return optionsToString(this.origOptions);
    };
    RRule2.prototype.toText = function(gettext, language, dateFormatter) {
      return toText(this, gettext, language, dateFormatter);
    };
    RRule2.prototype.isFullyConvertibleToText = function() {
      return isFullyConvertible(this);
    };
    RRule2.prototype.clone = function() {
      return new RRule2(this.origOptions);
    };
    RRule2.FREQUENCIES = [
      "YEARLY",
      "MONTHLY",
      "WEEKLY",
      "DAILY",
      "HOURLY",
      "MINUTELY",
      "SECONDLY"
    ];
    RRule2.YEARLY = Frequency.YEARLY;
    RRule2.MONTHLY = Frequency.MONTHLY;
    RRule2.WEEKLY = Frequency.WEEKLY;
    RRule2.DAILY = Frequency.DAILY;
    RRule2.HOURLY = Frequency.HOURLY;
    RRule2.MINUTELY = Frequency.MINUTELY;
    RRule2.SECONDLY = Frequency.SECONDLY;
    RRule2.MO = Days.MO;
    RRule2.TU = Days.TU;
    RRule2.WE = Days.WE;
    RRule2.TH = Days.TH;
    RRule2.FR = Days.FR;
    RRule2.SA = Days.SA;
    RRule2.SU = Days.SU;
    RRule2.parseString = parseString;
    RRule2.optionsToString = optionsToString;
    return RRule2;
  }()
);

// ../../../../../../node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i = 0; i < _rdate.length; i++) {
    var zonedDate = new DateWithZone(_rdate[i], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// ../../../../../../node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s, options2) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s, options2.unfold);
  lines.forEach(function(line) {
    var _a;
    if (!line)
      return;
    var _b = breakDownLine(line), name2 = _b.name, parms = _b.parms, value2 = _b.value;
    switch (name2.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString(line));
        break;
      case "RDATE":
        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value2, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString(value2));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value2, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name2);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s, options2) {
  var _a = parseInput(s, options2), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
  var noCache = options2.cache === false;
  if (options2.compatible) {
    options2.forceset = true;
    options2.unfold = true;
  }
  if (options2.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options2.compatible && options2.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options2.dtstart || dtstart, val.tzid || options2.tzid || tzid), noCache);
}
function rrulestr(s, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return buildRule(s, initializeOptions2(options2));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options2) {
  var invalid = [];
  var keys = Object.keys(options2);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS2), options2);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a = split(line, ":", 1), name2 = _a[0], value2 = _a[1];
  return {
    name: name2,
    value: value2
  };
}
function breakDownLine(line) {
  var _a = extractName(line), name2 = _a.name, value2 = _a.value;
  var parms = name2.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value: value2
  };
}
function splitIntoLines(s, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s = s && s.trim();
  if (!s)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s.split(/\s/);
  }
  var lines = s.split("\n");
  var i = 0;
  while (i < lines.length) {
    var line = lines[i] = lines[i].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i, 1);
    } else if (i > 0 && line[0] === " ") {
      lines[i - 1] += line.slice(1);
      lines.splice(i, 1);
    } else {
      i += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return untilStringToDate(datestr);
  });
}

// ../../../../../../node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i = 0; i < _this._rrule.length; i++) {
      var field_1 = _this._rrule[i].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = (
  /** @class */
  function(_super) {
    __extends(RRuleSet2, _super);
    function RRuleSet2(noCache) {
      if (noCache === void 0) {
        noCache = false;
      }
      var _this = _super.call(this, {}, noCache) || this;
      _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
      _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
      _this._rrule = [];
      _this._rdate = [];
      _this._exrule = [];
      _this._exdate = [];
      return _this;
    }
    RRuleSet2.prototype._iter = function(iterResult) {
      return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
    };
    RRuleSet2.prototype.rrule = function(rrule) {
      _addRule(rrule, this._rrule);
    };
    RRuleSet2.prototype.exrule = function(rrule) {
      _addRule(rrule, this._exrule);
    };
    RRuleSet2.prototype.rdate = function(date) {
      _addDate(date, this._rdate);
    };
    RRuleSet2.prototype.exdate = function(date) {
      _addDate(date, this._exdate);
    };
    RRuleSet2.prototype.rrules = function() {
      return this._rrule.map(function(e) {
        return rrulestr(e.toString());
      });
    };
    RRuleSet2.prototype.exrules = function() {
      return this._exrule.map(function(e) {
        return rrulestr(e.toString());
      });
    };
    RRuleSet2.prototype.rdates = function() {
      return this._rdate.map(function(e) {
        return new Date(e.getTime());
      });
    };
    RRuleSet2.prototype.exdates = function() {
      return this._exdate.map(function(e) {
        return new Date(e.getTime());
      });
    };
    RRuleSet2.prototype.valueOf = function() {
      var result2 = [];
      if (!this._rrule.length && this._dtstart) {
        result2 = result2.concat(optionsToString({ dtstart: this._dtstart }));
      }
      this._rrule.forEach(function(rrule) {
        result2 = result2.concat(rrule.toString().split("\n"));
      });
      this._exrule.forEach(function(exrule) {
        result2 = result2.concat(exrule.toString().split("\n").map(function(line) {
          return line.replace(/^RRULE:/, "EXRULE:");
        }).filter(function(line) {
          return !/^DTSTART/.test(line);
        }));
      });
      if (this._rdate.length) {
        result2.push(rdatesToString("RDATE", this._rdate, this.tzid()));
      }
      if (this._exdate.length) {
        result2.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
      }
      return result2;
    };
    RRuleSet2.prototype.toString = function() {
      return this.valueOf().join("\n");
    };
    RRuleSet2.prototype.clone = function() {
      var rrs = new RRuleSet2(!!this._cache);
      this._rrule.forEach(function(rule) {
        return rrs.rrule(rule.clone());
      });
      this._exrule.forEach(function(rule) {
        return rrs.exrule(rule.clone());
      });
      this._rdate.forEach(function(date) {
        return rrs.rdate(new Date(date.getTime()));
      });
      this._exdate.forEach(function(date) {
        return rrs.exdate(new Date(date.getTime()));
      });
      return rrs;
    };
    return RRuleSet2;
  }(RRule)
);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_recurrence.js
var toMs6 = date_default.dateToMilliseconds;
var ruleNames = ["freq", "interval", "byday", "byweekno", "byyearday", "bymonth", "bymonthday", "count", "until", "byhour", "byminute", "bysecond", "bysetpos", "wkst"];
var freqNames = ["DAILY", "WEEKLY", "MONTHLY", "YEARLY", "SECONDLY", "MINUTELY", "HOURLY"];
var days = {
  SU: 0,
  MO: 1,
  TU: 2,
  WE: 3,
  TH: 4,
  FR: 5,
  SA: 6
};
var loggedWarnings = [];
var RRULE_BROKEN_TIMEZONES = ["Etc/GMT-13", "MIT", "Pacific/Apia", "Pacific/Enderbury", "Pacific/Tongatapu", "Etc/GMT-14", "Pacific/Kiritimati"];
var recurrence = null;
function getRecurrenceProcessor() {
  if (!recurrence) {
    recurrence = new RecurrenceProcessor();
  }
  return recurrence;
}
var RecurrenceProcessor = class {
  constructor() {
    this.rRule = null;
    this.rRuleSet = null;
    this.validator = new RecurrenceValidator();
  }
  generateDates(options2) {
    const recurrenceRule = this.evalRecurrenceRule(options2.rule);
    const {
      rule
    } = recurrenceRule;
    if (!recurrenceRule.isValid || !rule.freq) {
      return [];
    }
    const rruleIntervalParams = this._createRruleIntervalParams(options2);
    this._initializeRRule(options2, rruleIntervalParams.startIntervalDate, rule.until);
    return this.rRuleSet.between(rruleIntervalParams.minViewDate, rruleIntervalParams.maxViewDate, true).filter((date) => date.getTime() + rruleIntervalParams.appointmentDuration >= rruleIntervalParams.minViewTime).map((date) => this._convertRruleResult(rruleIntervalParams, options2, date));
  }
  _createRruleIntervalParams(options2) {
    const {
      start,
      min,
      max,
      appointmentTimezoneOffset
    } = options2;
    const clientOffsets_startDate = m_utils_time_zone_default.getClientTimezoneOffset(start), clientOffsets_minViewDate = m_utils_time_zone_default.getClientTimezoneOffset(min), clientOffsets_maxViewDate = m_utils_time_zone_default.getClientTimezoneOffset(max);
    const duration = options2.end ? options2.end.getTime() - options2.start.getTime() : 0;
    const startIntervalDate = m_utils_time_zone_default.setOffsetsToDate(options2.start, [-clientOffsets_startDate, appointmentTimezoneOffset]);
    const minViewTime = options2.min.getTime() - clientOffsets_minViewDate + appointmentTimezoneOffset;
    const minViewDate = new Date(minViewTime - duration);
    const maxViewDate = m_utils_time_zone_default.setOffsetsToDate(options2.max, [-clientOffsets_maxViewDate, appointmentTimezoneOffset]);
    const startDateDSTDifferenceMs = m_utils_time_zone_default.getDiffBetweenClientTimezoneOffsets(options2.start, startIntervalDate);
    const switchToSummerTime = startDateDSTDifferenceMs < 0;
    return {
      startIntervalDate,
      minViewTime,
      minViewDate,
      maxViewDate,
      startIntervalDateDSTShift: switchToSummerTime ? 0 : startDateDSTDifferenceMs,
      appointmentDuration: duration
    };
  }
  _convertRruleResult(rruleIntervalParams, options2, rruleDate) {
    const convertedBackDate = m_utils_time_zone_default.setOffsetsToDate(rruleDate, [...this._getLocalMachineOffset(rruleDate), -options2.appointmentTimezoneOffset, rruleIntervalParams.startIntervalDateDSTShift]);
    const convertedDateDSTShift = m_utils_time_zone_default.getDiffBetweenClientTimezoneOffsets(convertedBackDate, rruleDate);
    const switchToSummerTime = convertedDateDSTShift < 0;
    const resultDate = m_utils_time_zone_default.setOffsetsToDate(convertedBackDate, [convertedDateDSTShift]);
    const resultDateDSTShift = m_utils_time_zone_default.getDiffBetweenClientTimezoneOffsets(resultDate, convertedBackDate);
    if (resultDateDSTShift && switchToSummerTime) {
      return new Date(resultDate.getTime() + resultDateDSTShift);
    }
    return resultDate;
  }
  _getLocalMachineOffset(rruleDate) {
    const machineTimezoneOffset = m_utils_time_zone_default.getClientTimezoneOffset(rruleDate);
    const machineTimezoneName = date_default.getMachineTimezoneName();
    const result2 = [machineTimezoneOffset];
    const isTimezoneOffsetInBrokenRange = machineTimezoneOffset / 36e5 <= -13;
    const isTimezoneNameInBrokenNames = !machineTimezoneName || RRULE_BROKEN_TIMEZONES.some((timezone) => machineTimezoneName.includes(timezone));
    if (isTimezoneOffsetInBrokenRange && isTimezoneNameInBrokenNames) {
      result2.push(-864e5);
    }
    return result2;
  }
  hasRecurrence(options2) {
    return !!this.generateDates(options2).length;
  }
  evalRecurrenceRule(rule) {
    const result2 = {
      rule: {},
      isValid: false
    };
    if (rule) {
      result2.rule = this._parseRecurrenceRule(rule);
      result2.isValid = this.validator.validateRRule(result2.rule, rule);
    }
    return result2;
  }
  isValidRecurrenceRule(rule) {
    return this.evalRecurrenceRule(rule).isValid;
  }
  daysFromByDayRule(rule) {
    let result2 = [];
    if (rule.byday) {
      if (Array.isArray(rule.byday)) {
        result2 = rule.byday;
      } else {
        result2 = rule.byday.split(",");
      }
    }
    return result2.map((item) => {
      const match2 = item.match(/[A-Za-z]+/);
      return !!match2 && match2[0];
    }).filter((item) => !!item);
  }
  getAsciiStringByDate(date) {
    const currentOffset = date.getTimezoneOffset() * toMs6("minute");
    const offsetDate = new Date(date.getTime() + currentOffset);
    return `${offsetDate.getFullYear() + `0${offsetDate.getMonth() + 1}`.slice(-2) + `0${offsetDate.getDate()}`.slice(-2)}T${`0${offsetDate.getHours()}`.slice(-2)}${`0${offsetDate.getMinutes()}`.slice(-2)}${`0${offsetDate.getSeconds()}`.slice(-2)}Z`;
  }
  getRecurrenceString(object) {
    if (!object || !object.freq) {
      return;
    }
    let result2 = "";
    for (const field in object) {
      let value2 = object[field];
      if ("interval" === field && value2 < 2) {
        continue;
      }
      if ("until" === field) {
        value2 = this.getAsciiStringByDate(value2);
      }
      result2 += `${field}=${value2};`;
    }
    result2 = result2.substring(0, result2.length - 1);
    return result2.toUpperCase();
  }
  _parseExceptionToRawArray(value2) {
    return value2.match(/(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2}))?(Z)?/);
  }
  getDateByAsciiString(exceptionText) {
    if ("string" !== typeof exceptionText) {
      return exceptionText;
    }
    const result2 = this._parseExceptionToRawArray(exceptionText);
    if (!result2) {
      return null;
    }
    const [year, month, date, hours, minutes, seconds, isUtc] = this._createDateTuple(result2);
    if (isUtc) {
      return new Date(Date.UTC(year, month, date, hours, minutes, seconds));
    }
    return new Date(year, month, date, hours, minutes, seconds);
  }
  _dispose() {
    if (this.rRuleSet) {
      delete this.rRuleSet;
      this.rRuleSet = null;
    }
    if (this.rRule) {
      delete this.rRule;
      this.rRule = null;
    }
  }
  _getTimeZoneOffset() {
    return (/* @__PURE__ */ new Date()).getTimezoneOffset();
  }
  _initializeRRule(options2, startDateUtc, until) {
    const ruleOptions = RRule.parseString(options2.rule);
    const {
      firstDayOfWeek
    } = options2;
    ruleOptions.dtstart = startDateUtc;
    if (!ruleOptions.wkst && firstDayOfWeek) {
      const weekDayNumbers = [6, 0, 1, 2, 3, 4, 5];
      ruleOptions.wkst = weekDayNumbers[firstDayOfWeek];
    }
    if (until) {
      ruleOptions.until = m_utils_time_zone_default.setOffsetsToDate(until, [-m_utils_time_zone_default.getClientTimezoneOffset(until), options2.appointmentTimezoneOffset]);
    }
    this._createRRule(ruleOptions);
    if (options2.exception) {
      const exceptionStrings = options2.exception;
      const exceptionDates = exceptionStrings.split(",").map((rule) => this.getDateByAsciiString(rule));
      exceptionDates.forEach((date) => {
        if (options2.getPostProcessedException) {
          date = options2.getPostProcessedException(date);
        }
        const utcDate = m_utils_time_zone_default.setOffsetsToDate(date, [-m_utils_time_zone_default.getClientTimezoneOffset(date), options2.appointmentTimezoneOffset]);
        this.rRuleSet.exdate(utcDate);
      });
    }
  }
  _createRRule(ruleOptions) {
    this._dispose();
    this.rRuleSet = new RRuleSet();
    this.rRule = new RRule(ruleOptions);
    this.rRuleSet.rrule(this.rRule);
  }
  _parseRecurrenceRule(recurrence2) {
    const ruleObject = {};
    const ruleParts = recurrence2.split(";");
    for (let i = 0, len = ruleParts.length; i < len; i++) {
      const rule = ruleParts[i].split("=");
      const ruleName = rule[0].toLowerCase();
      const ruleValue = rule[1];
      ruleObject[ruleName] = ruleValue;
    }
    const count = parseInt(ruleObject.count);
    if (!isNaN(count)) {
      ruleObject.count = count;
    }
    if (ruleObject.interval) {
      const interval = parseInt(ruleObject.interval);
      if (!isNaN(interval)) {
        ruleObject.interval = interval;
      }
    } else {
      ruleObject.interval = 1;
    }
    if (ruleObject.freq && ruleObject.until) {
      ruleObject.until = this.getDateByAsciiString(ruleObject.until);
    }
    return ruleObject;
  }
  _createDateTuple(parseResult) {
    const isUtc = void 0 !== parseResult[8];
    parseResult.shift();
    if (void 0 === parseResult[3]) {
      parseResult.splice(3);
    } else {
      parseResult.splice(3, 1);
      parseResult.splice(6);
    }
    parseResult[1]--;
    parseResult.unshift(null);
    return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc];
  }
};
var RecurrenceValidator = class {
  validateRRule(rule, recurrence2) {
    if (this._brokenRuleNameExists(rule) || !freqNames.includes(rule.freq) || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {
      this._logBrokenRule(recurrence2);
      return false;
    }
    return true;
  }
  _wrongUntilRule(rule) {
    let wrongUntil = false;
    const {
      until
    } = rule;
    if (void 0 !== until && !(until instanceof Date)) {
      wrongUntil = true;
    }
    return wrongUntil;
  }
  _wrongCountRule(rule) {
    let wrongCount = false;
    const {
      count
    } = rule;
    if (count && "string" === typeof count) {
      wrongCount = true;
    }
    return wrongCount;
  }
  _wrongByMonthDayRule(rule) {
    let wrongByMonthDay = false;
    const byMonthDay = rule.bymonthday;
    if (byMonthDay && isNaN(parseInt(byMonthDay))) {
      wrongByMonthDay = true;
    }
    return wrongByMonthDay;
  }
  _wrongByMonth(rule) {
    let wrongByMonth = false;
    const byMonth = rule.bymonth;
    if (byMonth && isNaN(parseInt(byMonth))) {
      wrongByMonth = true;
    }
    return wrongByMonth;
  }
  _wrongIntervalRule(rule) {
    let wrongInterval = false;
    const {
      interval
    } = rule;
    if (interval && "string" === typeof interval) {
      wrongInterval = true;
    }
    return wrongInterval;
  }
  _wrongDayOfWeek(rule) {
    const byDay = rule.byday;
    const daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);
    let brokenDaysExist = false;
    if ("" === byDay) {
      brokenDaysExist = true;
    }
    each(daysByRule, (_, day) => {
      if (!Object.prototype.hasOwnProperty.call(days, day)) {
        brokenDaysExist = true;
        return false;
      }
      return;
    });
    return brokenDaysExist;
  }
  _brokenRuleNameExists(rule) {
    let brokenRuleExists = false;
    each(rule, (ruleName) => {
      if (!ruleNames.includes(ruleName)) {
        brokenRuleExists = true;
        return false;
      }
      return;
    });
    return brokenRuleExists;
  }
  _logBrokenRule(recurrence2) {
    if (!loggedWarnings.includes(recurrence2)) {
      errors_default.log("W0006", recurrence2);
      loggedWarnings.push(recurrence2);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_appointment_adapter.js
var PROPERTY_NAMES = {
  startDate: "startDate",
  endDate: "endDate",
  allDay: "allDay",
  text: "text",
  description: "description",
  startDateTimeZone: "startDateTimeZone",
  endDateTimeZone: "endDateTimeZone",
  recurrenceRule: "recurrenceRule",
  recurrenceException: "recurrenceException",
  disabled: "disabled"
};
var AppointmentAdapter = class _AppointmentAdapter {
  constructor(rawAppointment, dataAccessors, timeZoneCalculator, options2) {
    this.rawAppointment = rawAppointment;
    this.dataAccessors = dataAccessors;
    this.timeZoneCalculator = timeZoneCalculator;
    this.options = options2;
  }
  get duration() {
    return this.endDate ? this.endDate - this.startDate : 0;
  }
  get startDate() {
    const result2 = this.getField(PROPERTY_NAMES.startDate);
    return void 0 === result2 ? result2 : new Date(result2);
  }
  set startDate(value2) {
    this.setField(PROPERTY_NAMES.startDate, value2);
  }
  get endDate() {
    const result2 = this.getField(PROPERTY_NAMES.endDate);
    return void 0 === result2 ? result2 : new Date(result2);
  }
  set endDate(value2) {
    this.setField(PROPERTY_NAMES.endDate, value2);
  }
  get allDay() {
    return this.getField(PROPERTY_NAMES.allDay);
  }
  set allDay(value2) {
    this.setField(PROPERTY_NAMES.allDay, value2);
  }
  get text() {
    return this.getField(PROPERTY_NAMES.text);
  }
  set text(value2) {
    this.setField(PROPERTY_NAMES.text, value2);
  }
  get description() {
    return this.getField(PROPERTY_NAMES.description);
  }
  set description(value2) {
    this.setField(PROPERTY_NAMES.description, value2);
  }
  get startDateTimeZone() {
    return this.getField(PROPERTY_NAMES.startDateTimeZone);
  }
  get endDateTimeZone() {
    return this.getField(PROPERTY_NAMES.endDateTimeZone);
  }
  get recurrenceRule() {
    return this.getField(PROPERTY_NAMES.recurrenceRule);
  }
  set recurrenceRule(value2) {
    this.setField(PROPERTY_NAMES.recurrenceRule, value2);
  }
  get recurrenceException() {
    return this.getField(PROPERTY_NAMES.recurrenceException);
  }
  set recurrenceException(value2) {
    this.setField(PROPERTY_NAMES.recurrenceException, value2);
  }
  get disabled() {
    return !!this.getField(PROPERTY_NAMES.disabled);
  }
  get isRecurrent() {
    return getRecurrenceProcessor().isValidRecurrenceRule(this.recurrenceRule);
  }
  getField(property) {
    return ExpressionUtils.getField(this.dataAccessors, property, this.rawAppointment);
  }
  setField(property, value2) {
    return ExpressionUtils.setField(this.dataAccessors, property, this.rawAppointment, value2);
  }
  calculateStartDate(pathTimeZoneConversion) {
    if (!this.startDate || isNaN(this.startDate.getTime())) {
      throw ui_errors_default.Error("E1032", this.text);
    }
    return this.calculateDate(this.startDate, this.startDateTimeZone, pathTimeZoneConversion);
  }
  calculateEndDate(pathTimeZoneConversion) {
    return this.calculateDate(this.endDate, this.endDateTimeZone, pathTimeZoneConversion);
  }
  calculateDate(date, appointmentTimeZone, pathTimeZoneConversion) {
    if (!date) {
      return;
    }
    return this.timeZoneCalculator.createDate(date, {
      appointmentTimeZone,
      path: pathTimeZoneConversion
    });
  }
  clone() {
    let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    const result2 = new _AppointmentAdapter(deepExtendArraySafe({}, this.rawAppointment), this.dataAccessors, this.timeZoneCalculator, options2);
    if (null !== options2 && void 0 !== options2 && options2.pathTimeZone) {
      result2.startDate = result2.calculateStartDate(options2.pathTimeZone);
      result2.endDate = result2.calculateEndDate(options2.pathTimeZone);
    }
    return result2;
  }
  source() {
    let serializeDate2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    if (serializeDate2) {
      const clonedAdapter = this.clone();
      clonedAdapter.startDate = this.startDate;
      clonedAdapter.endDate = this.endDate;
      return clonedAdapter.source();
    }
    return extend({}, this.rawAppointment);
  }
};
var createAppointmentAdapter = (rawAppointment, dataAccessors, timeZoneCalculator, options2) => new AppointmentAdapter(rawAppointment, dataAccessors, timeZoneCalculator, options2);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/data.js
var getPreparedDataItems = (dataItems, dataAccessors, cellDurationInMinutes, timeZoneCalculator) => {
  const result2 = [];
  null === dataItems || void 0 === dataItems || dataItems.forEach((rawAppointment) => {
    var _recurrenceRule$match;
    const startDate = new Date(dataAccessors.getter.startDate(rawAppointment));
    const endDate = new Date(dataAccessors.getter.endDate(rawAppointment));
    replaceWrongEndDate(rawAppointment, startDate, endDate, cellDurationInMinutes, dataAccessors);
    const adapter = createAppointmentAdapter(rawAppointment, dataAccessors, timeZoneCalculator);
    const comparableStartDate = adapter.startDate && adapter.calculateStartDate("toGrid");
    const comparableEndDate = adapter.endDate && adapter.calculateEndDate("toGrid");
    const regex = new RegExp("freq", "gi");
    const recurrenceRule = adapter.recurrenceRule;
    const hasRecurrenceRule = !!(null !== recurrenceRule && void 0 !== recurrenceRule && null !== (_recurrenceRule$match = recurrenceRule.match(regex)) && void 0 !== _recurrenceRule$match && _recurrenceRule$match.length);
    const visible2 = isDefined(rawAppointment.visible) ? !!rawAppointment.visible : true;
    if (comparableStartDate && comparableEndDate) {
      result2.push({
        allDay: !!adapter.allDay,
        startDate: comparableStartDate,
        startDateTimeZone: rawAppointment.startDateTimeZone,
        endDate: comparableEndDate,
        endDateTimeZone: rawAppointment.endDateTimeZone,
        recurrenceRule: adapter.recurrenceRule,
        recurrenceException: adapter.recurrenceException,
        hasRecurrenceRule,
        visible: visible2,
        rawAppointment
      });
    }
  });
  return result2;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/exclude_from_recurrence.js
var FULL_DATE_FORMAT2 = "yyyyMMddTHHmmss";
var UTC_FULL_DATE_FORMAT = `${FULL_DATE_FORMAT2}Z`;
var getSerializedDate = (date, startDate, isAllDay) => {
  if (isAllDay) {
    date.setHours(startDate.getHours(), startDate.getMinutes(), startDate.getSeconds(), startDate.getMilliseconds());
  }
  return date_serialization_default.serializeDate(date, UTC_FULL_DATE_FORMAT);
};
var createRecurrenceException = (appointmentAdapter, exceptionDate) => {
  const result2 = [];
  if (appointmentAdapter.recurrenceException) {
    result2.push(appointmentAdapter.recurrenceException);
  }
  result2.push(getSerializedDate(exceptionDate, appointmentAdapter.startDate, appointmentAdapter.allDay));
  return result2.join();
};
var excludeFromRecurrence = (appointment, exceptionDate, dataAccessors, timeZoneCalculator) => {
  const appointmentAdapter = createAppointmentAdapter(_extends({}, appointment), dataAccessors, timeZoneCalculator);
  appointmentAdapter.recurrenceException = createRecurrenceException(appointmentAdapter, exceptionDate);
  return appointmentAdapter;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/format_weekday.js
var formatWeekday = (date) => date_default3.getDayNames("abbreviated")[date.getDay()];
var formatWeekdayAndDay = (date) => `${formatWeekday(date)} ${date_default3.format(date, "day")}`;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/utils/index.js
var agendaUtils = {
  calculateStartViewDate
};
var dayUtils = {
  calculateStartViewDate: calculateStartViewDate2
};
var weekUtils = {
  getIntervalDuration,
  getTimePanelCellText,
  calculateStartViewDate: calculateStartViewDate5,
  calculateViewStartDate: calculateViewStartDate2
};
var workWeekUtils = {
  calculateStartViewDate: calculateStartViewDate6
};
var monthUtils = {
  getViewStartByOptions: getViewStartByOptions2,
  getCellText,
  calculateCellIndex: calculateCellIndex2,
  calculateStartViewDate: calculateStartViewDate3
};
var timelineWeekUtils = {
  getDateForHeaderText
};
var timelineMonthUtils = {
  calculateStartViewDate: calculateStartViewDate4
};
var viewsUtils = {
  getCurrentView
};
var renderUtils = {
  addToStyles,
  addWidthToStyle,
  addHeightToStyle,
  getGroupCellClasses,
  combineClasses: combineClasses2,
  getCellSizeHorizontalClass,
  getCellSizeVerticalClass
};
var themeUtils = {
  getThemeType
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/editor/m_data_expression.js
var DataExpressionMixin = extend({}, data_helper_default, {
  _dataExpressionDefaultOptions: () => ({
    items: [],
    dataSource: null,
    itemTemplate: "item",
    value: null,
    valueExpr: "this",
    displayExpr: void 0
  }),
  _initDataExpressions() {
    this._compileValueGetter();
    this._compileDisplayGetter();
    this._initDynamicTemplates();
    this._initDataSource();
    this._itemsToDataSource();
  },
  _itemsToDataSource() {
    if (!this.option("dataSource")) {
      this._dataSource = new DataSource({
        store: new array_store_default(this.option("items")),
        pageSize: 0
      });
      this._initDataController();
    }
  },
  _compileDisplayGetter() {
    this._displayGetter = compileGetter(this._displayGetterExpr());
  },
  _displayGetterExpr() {
    return this.option("displayExpr");
  },
  _compileValueGetter() {
    this._valueGetter = compileGetter(this._valueGetterExpr());
  },
  _valueGetterExpr() {
    return this.option("valueExpr") || "this";
  },
  _loadValue(value2) {
    const deferred = Deferred();
    value2 = this._unwrappedValue(value2);
    if (!isDefined(value2)) {
      return deferred.reject().promise();
    }
    this._loadSingle(this._valueGetterExpr(), value2).done((item) => {
      this._isValueEquals(this._valueGetter(item), value2) ? deferred.resolve(item) : deferred.reject();
    }).fail(() => {
      deferred.reject();
    });
    this._loadValueDeferred = deferred;
    return deferred.promise();
  },
  _rejectValueLoading() {
    var _this$_loadValueDefer;
    null === (_this$_loadValueDefer = this._loadValueDeferred) || void 0 === _this$_loadValueDefer || _this$_loadValueDefer.reject({
      shouldSkipCallback: true
    });
  },
  _getCurrentValue() {
    return this.option("value");
  },
  _unwrappedValue(value2) {
    value2 = value2 ?? this._getCurrentValue();
    if (value2 && this._dataSource && "this" === this._valueGetterExpr()) {
      value2 = this._getItemKey(value2);
    }
    return variable_wrapper_default.unwrap(value2);
  },
  _getItemKey(value2) {
    const key = this._dataSource.key();
    if (Array.isArray(key)) {
      const result2 = {};
      for (let i = 0, n = key.length; i < n; i++) {
        result2[key[i]] = value2[key[i]];
      }
      return result2;
    }
    if (key && "object" === typeof value2) {
      value2 = value2[key];
    }
    return value2;
  },
  _isValueEquals(value1, value2) {
    const dataSourceKey = this._dataSource && this._dataSource.key();
    let result2 = this._compareValues(value1, value2);
    if (!result2 && dataSourceKey && isDefined(value1) && isDefined(value2)) {
      if (Array.isArray(dataSourceKey)) {
        result2 = this._compareByCompositeKey(value1, value2, dataSourceKey);
      } else {
        result2 = this._compareByKey(value1, value2, dataSourceKey);
      }
    }
    return result2;
  },
  _compareByCompositeKey(value1, value2, key) {
    const isObject2 = isObject;
    if (!isObject2(value1) || !isObject2(value2)) {
      return false;
    }
    for (let i = 0, n = key.length; i < n; i++) {
      if (value1[key[i]] !== value2[key[i]]) {
        return false;
      }
    }
    return true;
  },
  _compareByKey(value1, value2, key) {
    const unwrapObservable = variable_wrapper_default.unwrap;
    const valueKey1 = ensureDefined(unwrapObservable(value1[key]), value1);
    const valueKey2 = ensureDefined(unwrapObservable(value2[key]), value2);
    return this._compareValues(valueKey1, valueKey2);
  },
  _compareValues: (value1, value2) => toComparable(value1, true) === toComparable(value2, true),
  _initDynamicTemplates: noop2,
  _setCollectionWidgetItemTemplate() {
    this._initDynamicTemplates();
    this._setCollectionWidgetOption("itemTemplate", this.option("itemTemplate"));
  },
  _getCollectionKeyExpr() {
    const valueExpr = this.option("valueExpr");
    const isValueExprField = isString(valueExpr) && "this" !== valueExpr || isFunction(valueExpr);
    return isValueExprField ? valueExpr : null;
  },
  _dataExpressionOptionChanged(args) {
    switch (args.name) {
      case "items":
        this._itemsToDataSource();
        this._setCollectionWidgetOption("items");
        break;
      case "dataSource":
        this._initDataSource();
        break;
      case "itemTemplate":
        this._setCollectionWidgetItemTemplate();
        break;
      case "valueExpr":
        this._compileValueGetter();
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._initDynamicTemplates();
        this._setCollectionWidgetOption("displayExpr");
    }
  }
});
var m_data_expression_default = DataExpressionMixin;

// ../../../../../../node_modules/devextreme/esm/ui/editor/ui.data_expression.js
var ui_data_expression_default = m_data_expression_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_validation_message.js
var INVALID_MESSAGE = "dx-invalid-message";
var INVALID_MESSAGE_AUTO = "dx-invalid-message-auto";
var INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always";
var INVALID_MESSAGE_CONTENT = "dx-invalid-message-content";
var ValidationMessage = ui_overlay_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      integrationOptions: {},
      templatesRenderAsynchronously: false,
      shading: false,
      width: "auto",
      height: "auto",
      hideOnOutsideClick: false,
      animation: null,
      visible: true,
      propagateOutsideClick: true,
      _checkParentVisibility: false,
      rtlEnabled: false,
      contentTemplate: this._renderInnerHtml,
      maxWidth: "100%",
      container: this.$element(),
      target: void 0,
      mode: "auto",
      validationErrors: void 0,
      preventScrollEvents: false,
      positionSide: "top",
      boundary: void 0,
      offset: {
        h: 0,
        v: 0
      },
      contentId: void 0
    });
  },
  _init() {
    this.callBase();
    this.updateMaxWidth();
    this._updatePosition();
  },
  _initMarkup() {
    this.callBase();
    this._ensureMessageNotEmpty();
    this._updatePositionByTarget();
    this._toggleModeClass();
    this._updateContentId();
  },
  _updatePositionByTarget() {
    const {
      target
    } = this.option();
    this.option("position.of", target);
  },
  _ensureMessageNotEmpty() {
    this._textMarkup = this._getTextMarkup();
    const shouldShowMessage = this.option("visible") && this._textMarkup;
    this._toggleVisibilityClasses(shouldShowMessage);
  },
  _toggleVisibilityClasses(visible2) {
    if (visible2) {
      this.$element().addClass(INVALID_MESSAGE);
      this.$wrapper().addClass(INVALID_MESSAGE);
    } else {
      this.$element().removeClass(INVALID_MESSAGE);
      this.$wrapper().removeClass(INVALID_MESSAGE);
    }
  },
  _updateContentId() {
    const {
      container,
      contentId
    } = this.option();
    const id = contentId ?? renderer_default(container).attr("aria-describedby");
    this.$content().addClass(INVALID_MESSAGE_CONTENT).attr("id", id);
  },
  _renderInnerHtml(element) {
    const $element = element && renderer_default(element);
    null === $element || void 0 === $element || $element.html(this._textMarkup);
  },
  _getTextMarkup() {
    const validationErrors = this.option("validationErrors") ?? [];
    let validationErrorMessage = "";
    validationErrors.forEach((err) => {
      const separator = validationErrorMessage ? "<br />" : "";
      validationErrorMessage += separator + encodeHtml((null === err || void 0 === err ? void 0 : err.message) ?? "");
    });
    return validationErrorMessage;
  },
  _toggleModeClass() {
    const mode = this.option("mode");
    this.$wrapper().toggleClass(INVALID_MESSAGE_AUTO, "auto" === mode).toggleClass(INVALID_MESSAGE_ALWAYS, "always" === mode);
  },
  updateMaxWidth() {
    const target = this.option("target");
    const targetWidth = getOuterWidth(target);
    let maxWidth = "100%";
    if (targetWidth) {
      maxWidth = Math.max(targetWidth, 100);
    }
    this.option({
      maxWidth
    });
  },
  _getPositionsArray(positionSide, rtlSide) {
    switch (positionSide) {
      case "top":
        return [`${rtlSide} bottom`, `${rtlSide} top`];
      case "left":
        return ["right", "left"];
      case "right":
        return ["left", "right"];
      default:
        return [`${rtlSide} top`, `${rtlSide} bottom`];
    }
  },
  _updatePosition() {
    const {
      positionSide,
      rtlEnabled,
      offset: componentOffset,
      boundary
    } = this.option();
    const rtlSide = getDefaultAlignment(rtlEnabled);
    const positions = this._getPositionsArray(positionSide, rtlSide);
    const offset2 = _extends({}, componentOffset);
    this.$element().addClass(`dx-invalid-message-${positionSide}`);
    if (rtlEnabled && "left" !== positionSide && "right" !== positionSide) {
      offset2.h = -offset2.h;
    }
    if ("top" === positionSide) {
      offset2.v = -offset2.v;
    }
    if ("left" === positionSide) {
      offset2.h = -offset2.h;
    }
    this.option("position", {
      offset: offset2,
      boundary,
      my: positions[0],
      at: positions[1],
      collision: "none flip"
    });
  },
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "target":
        this._updatePositionByTarget();
        this.updateMaxWidth();
        this.callBase(args);
        break;
      case "boundary":
        this.option("position.boundary", value2);
        break;
      case "mode":
        this._toggleModeClass(value2);
        break;
      case "rtlEnabled":
      case "offset":
      case "positionSide":
        this.$element().removeClass(`dx-invalid-message-${previousValue}`);
        this._updatePosition();
        break;
      case "container":
        this._updateContentId();
        this.callBase(args);
        break;
      case "contentId":
        this._updateContentId();
        break;
      case "validationErrors":
        this._ensureMessageNotEmpty();
        this._renderInnerHtml(this.$content());
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxValidationMessage", ValidationMessage);
var m_validation_message_default = ValidationMessage;

// ../../../../../../node_modules/devextreme/esm/ui/validation_message.js
var validation_message_default = m_validation_message_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/editor/m_editor.js
var INVALID_MESSAGE_AUTO2 = "dx-invalid-message-auto";
var DX_INVALID_BADGE_CLASS = "dx-show-invalid-badge";
var VALIDATION_TARGET = "dx-validation-target";
var ALLOWED_STYLING_MODES = ["outlined", "filled", "underlined"];
var VALIDATION_MESSAGE_KEYS_MAP = {
  validationMessageMode: "mode",
  validationMessagePosition: "positionSide",
  validationMessageOffset: "offset",
  validationBoundary: "boundary"
};
var Editor = ui_widget_default.inherit({
  ctor() {
    this.showValidationMessageTimeout = null;
    this.validationRequest = callbacks_default();
    this.callBase.apply(this, arguments);
  },
  _createElement(element) {
    this.callBase(element);
    const $element = this.$element();
    if ($element) {
      data($element[0], VALIDATION_TARGET, this);
    }
  },
  _initOptions(options2) {
    this.callBase.apply(this, arguments);
    this.option(validation_engine_default.initValidationOptions(options2));
  },
  _init() {
    this._initialValue = this.option("value");
    this.callBase();
    this._options.cache("validationTooltipOptions", this.option("validationTooltipOptions"));
    const $element = this.$element();
    $element.addClass(DX_INVALID_BADGE_CLASS);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: null,
      name: "",
      onValueChanged: null,
      readOnly: false,
      isValid: true,
      validationError: null,
      validationErrors: null,
      validationStatus: "valid",
      validationMessageMode: "auto",
      validationMessagePosition: "bottom",
      validationBoundary: void 0,
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {},
      _showValidationMessage: true,
      isDirty: false
    });
  },
  _attachKeyboardEvents() {
    if (!this.option("readOnly")) {
      this.callBase();
    }
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      validationError: true
    });
  },
  _createValueChangeAction() {
    this._valueChangeAction = this._createActionByOption("onValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _suppressValueChangeAction() {
    this._valueChangeActionSuppressed = true;
  },
  _resumeValueChangeAction() {
    this._valueChangeActionSuppressed = false;
  },
  _initMarkup() {
    var _this$option;
    this._toggleReadOnlyState();
    this._setSubmitElementName(this.option("name"));
    this.callBase();
    this._renderValidationState();
    null === (_this$option = this.option("_onMarkupRendered")) || void 0 === _this$option || _this$option();
  },
  _raiseValueChangeAction(value2, previousValue) {
    if (!this._valueChangeAction) {
      this._createValueChangeAction();
    }
    this._valueChangeAction(this._valueChangeArgs(value2, previousValue));
  },
  _valueChangeArgs(value2, previousValue) {
    return {
      value: value2,
      previousValue,
      event: this._valueChangeEventInstance
    };
  },
  _saveValueChangeEvent(e) {
    this._valueChangeEventInstance = e;
  },
  _focusInHandler(e) {
    const isValidationMessageShownOnFocus = "auto" === this.option("validationMessageMode");
    if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
      var _this$_validationMess;
      const $validationMessageWrapper = null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess ? void 0 : _this$_validationMess.$wrapper();
      null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO2);
      clearTimeout(this.showValidationMessageTimeout);
      this.showValidationMessageTimeout = setTimeout(() => null === $validationMessageWrapper || void 0 === $validationMessageWrapper ? void 0 : $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO2), 150);
    }
    return this.callBase(e);
  },
  _canValueBeChangedByClick: () => false,
  _getStylingModePrefix: () => "dx-editor-",
  _renderStylingMode() {
    const optionValue = this.option("stylingMode");
    const prefix = this._getStylingModePrefix();
    const allowedStylingClasses = ALLOWED_STYLING_MODES.map((mode) => prefix + mode);
    allowedStylingClasses.forEach((className) => this.$element().removeClass(className));
    let stylingModeClass = prefix + optionValue;
    if (!allowedStylingClasses.includes(stylingModeClass)) {
      const defaultOptionValue = this._getDefaultOptions().stylingMode;
      const platformOptionValue = this._convertRulesToOptions(this._defaultOptionsRules()).stylingMode;
      stylingModeClass = prefix + (platformOptionValue || defaultOptionValue);
    }
    this.$element().addClass(stylingModeClass);
  },
  _getValidationErrors() {
    let validationErrors = this.option("validationErrors");
    if (!validationErrors && this.option("validationError")) {
      validationErrors = [this.option("validationError")];
    }
    return validationErrors;
  },
  _disposeValidationMessage() {
    if (this._$validationMessage) {
      this._$validationMessage.remove();
      this.setAria("describedby", null);
      this._$validationMessage = void 0;
      this._validationMessage = void 0;
    }
  },
  _toggleValidationClasses(isInvalid3) {
    this.$element().toggleClass("dx-invalid", isInvalid3);
    this.setAria("invalid", isInvalid3 || void 0);
  },
  _renderValidationState() {
    const isValid = this.option("isValid") && "invalid" !== this.option("validationStatus");
    const validationErrors = this._getValidationErrors();
    const $element = this.$element();
    this._toggleValidationClasses(!isValid);
    if (!hasWindow() || false === this.option("_showValidationMessage")) {
      return;
    }
    this._disposeValidationMessage();
    if (!isValid && validationErrors) {
      const {
        validationMessageMode,
        validationMessageOffset,
        validationBoundary,
        rtlEnabled
      } = this.option();
      this._$validationMessage = renderer_default("<div>").appendTo($element);
      const validationMessageContentId = `dx-${new guid_default()}`;
      this.setAria("describedby", validationMessageContentId);
      this._validationMessage = new validation_message_default(this._$validationMessage, extend({
        validationErrors,
        rtlEnabled,
        target: this._getValidationMessageTarget(),
        visualContainer: $element,
        mode: validationMessageMode,
        positionSide: this._getValidationMessagePosition(),
        offset: validationMessageOffset,
        boundary: validationBoundary,
        contentId: validationMessageContentId
      }, this._options.cache("validationTooltipOptions")));
      this._bindInnerWidgetOptions(this._validationMessage, "validationTooltipOptions");
    }
  },
  _getValidationMessagePosition() {
    return this.option("validationMessagePosition");
  },
  _getValidationMessageTarget() {
    return this.$element();
  },
  _toggleReadOnlyState() {
    const readOnly = this.option("readOnly");
    this._toggleBackspaceHandler(readOnly);
    this.$element().toggleClass("dx-state-readonly", !!readOnly);
    this._setAriaReadonly(readOnly);
  },
  _setAriaReadonly(readOnly) {
    this.setAria("readonly", readOnly || void 0);
  },
  _toggleBackspaceHandler(isReadOnly) {
    const $eventTarget = this._keyboardEventBindingTarget();
    const eventName = addNamespace2("keydown", "editorReadOnly");
    events_engine_default.off($eventTarget, eventName);
    if (isReadOnly) {
      events_engine_default.on($eventTarget, eventName, (e) => {
        if ("backspace" === normalizeKeyName(e)) {
          e.preventDefault();
        }
      });
    }
  },
  _dispose() {
    const element = this.$element()[0];
    data(element, VALIDATION_TARGET, null);
    clearTimeout(this.showValidationMessageTimeout);
    this._disposeValidationMessage();
    this.callBase();
  },
  _setSubmitElementName(name2) {
    const $submitElement = this._getSubmitElement();
    if (!$submitElement) {
      return;
    }
    if (name2.length > 0) {
      $submitElement.attr("name", name2);
    } else {
      $submitElement.removeAttr("name");
    }
  },
  _getSubmitElement: () => null,
  _setValidationMessageOption(_ref) {
    var _this$_validationMess2;
    let {
      name: name2,
      value: value2
    } = _ref;
    const optionKey = VALIDATION_MESSAGE_KEYS_MAP[name2] ? VALIDATION_MESSAGE_KEYS_MAP[name2] : name2;
    null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 || _this$_validationMess2.option(optionKey, value2);
  },
  _hasActiveElement: noop2,
  _optionChanged(args) {
    var _this$_validationMess3;
    switch (args.name) {
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "readOnly":
        this._toggleReadOnlyState();
        this._refreshFocusState();
        break;
      case "value":
        if (args.value != args.previousValue) {
          this.option("isDirty", this._initialValue !== args.value);
          this.validationRequest.fire({
            value: args.value,
            editor: this
          });
        }
        if (!this._valueChangeActionSuppressed) {
          this._raiseValueChangeAction(args.value, args.previousValue);
          this._saveValueChangeEvent(void 0);
        }
        break;
      case "width":
        this.callBase(args);
        null === (_this$_validationMess3 = this._validationMessage) || void 0 === _this$_validationMess3 || _this$_validationMess3.updateMaxWidth();
        break;
      case "name":
        this._setSubmitElementName(args.value);
        break;
      case "isValid":
      case "validationError":
      case "validationErrors":
      case "validationStatus":
        this.option(validation_engine_default.synchronizeValidationOptions(args, this.option()));
        this._renderValidationState();
        break;
      case "validationBoundary":
      case "validationMessageMode":
      case "validationMessagePosition":
      case "validationMessageOffset":
        this._setValidationMessageOption(args);
        break;
      case "rtlEnabled":
        this._setValidationMessageOption(args);
        this.callBase(args);
        break;
      case "validationTooltipOptions":
        this._innerWidgetOptionChanged(this._validationMessage, args);
        break;
      case "_showValidationMessage":
      case "isDirty":
        break;
      default:
        this.callBase(args);
    }
  },
  _resetToInitialValue() {
    this.option("value", this._initialValue);
  },
  blur() {
    if (this._hasActiveElement()) {
      resetActiveElement();
    }
  },
  clear() {
    const defaultOptions3 = this._getDefaultOptions();
    this.option("value", defaultOptions3.value);
  },
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      this._initialValue = value2;
    }
    this._resetToInitialValue();
    this.option("isDirty", false);
    this.option("isValid", true);
  }
});
Editor.isEditor = (instance) => instance instanceof Editor;
var m_editor_default = Editor;

// ../../../../../../node_modules/devextreme/esm/ui/editor/editor.js
var editor_default = m_editor_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/editor.js
var TypedEditor = editor_default;
var editor_default2 = TypedEditor;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/radio_group/m_radio_collection.js
var RadioCollection = class extends edit_default {
  _focusTarget() {
    return renderer_default(this.element()).parent();
  }
  _nullValueSelectionSupported() {
    return true;
  }
  _getDefaultOptions() {
    const defaultOptions3 = super._getDefaultOptions();
    return extend(defaultOptions3, ui_data_expression_default._dataExpressionDefaultOptions(), {
      _itemAttributes: {
        role: "radio"
      }
    });
  }
  _initMarkup() {
    super._initMarkup();
    deferRender(() => {
      this._itemElements().addClass("dx-radiobutton");
    });
  }
  _keyboardEventBindingTarget() {
    return this._focusTarget();
  }
  _postprocessRenderItem(args) {
    const {
      itemData: {
        html
      },
      itemElement
    } = args;
    if (!html) {
      const $radio = renderer_default("<div>").addClass("dx-radiobutton-icon");
      renderer_default("<div>").addClass("dx-radiobutton-icon-dot").appendTo($radio);
      const $radioContainer = renderer_default("<div>").append($radio).addClass("dx-radio-value-container");
      renderer_default(itemElement).prepend($radioContainer);
    }
    super._postprocessRenderItem(args);
  }
  _processSelectableItem($itemElement, isSelected) {
    super._processSelectableItem($itemElement, isSelected);
    $itemElement.toggleClass("dx-radiobutton-checked", isSelected).find(".dx-radiobutton-icon").first().toggleClass("dx-radiobutton-icon-checked", isSelected);
    this.setAria("checked", isSelected, $itemElement);
  }
  _refreshContent() {
    this._prepareContent();
    this._renderContent();
  }
  _supportedKeys() {
    const parent = super._supportedKeys();
    return extend({}, parent, {
      enter(e) {
        e.preventDefault();
        return parent.enter.apply(this, arguments);
      },
      space(e) {
        e.preventDefault();
        return parent.space.apply(this, arguments);
      }
    });
  }
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  }
  _setAriaSelectionAttribute() {
  }
};
var m_radio_collection_default = RadioCollection;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/radio_group/m_radio_group.js
var RadioGroup = class extends editor_default2 {
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _defaultOptionsRules() {
    const defaultOptionsRules = super._defaultOptionsRules();
    return defaultOptionsRules.concat([{
      device: {
        tablet: true
      },
      options: {
        layout: "horizontal"
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  }
  _fireContentReadyAction(force) {
    force && super._fireContentReadyAction();
  }
  _focusTarget() {
    return this.$element();
  }
  _getAriaTarget() {
    return this.$element();
  }
  _getDefaultOptions() {
    const defaultOptions3 = super._getDefaultOptions();
    return extend(defaultOptions3, extend(ui_data_expression_default._dataExpressionDefaultOptions(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      layout: "vertical"
    }));
  }
  _getItemValue(item) {
    return this._valueGetter ? this._valueGetter(item) : item.text;
  }
  _getSubmitElement() {
    return this._$submitElement;
  }
  _init() {
    super._init();
    this._activeStateUnit = ".dx-radiobutton";
    this._feedbackHideTimeout = 100;
    this._initDataExpressions();
  }
  _initMarkup() {
    renderer_default(this.element()).addClass("dx-radiogroup");
    this._renderSubmitElement();
    this.setAria("role", "radiogroup");
    this._renderRadios();
    this._renderLayout();
    super._initMarkup();
  }
  _itemClickHandler(_ref) {
    let {
      itemElement,
      event,
      itemData
    } = _ref;
    if (this.itemElements().is(itemElement)) {
      const newValue = this._getItemValue(itemData);
      if (newValue !== this.option("value")) {
        this._saveValueChangeEvent(event);
        this.option("value", newValue);
      }
    }
  }
  _getSelectedItemKeys() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.option("value");
    const isNullSelectable = "this" !== this.option("valueExpr");
    const shouldSelectValue = isNullSelectable && null === value2 || isDefined(value2);
    return shouldSelectValue ? [value2] : [];
  }
  _setSelection(currentValue) {
    const value2 = this._unwrappedValue(currentValue);
    this._setCollectionWidgetOption("selectedItemKeys", this._getSelectedItemKeys(value2));
  }
  _renderValidationState() {
    var _this$_validationMess;
    super._renderValidationState();
    null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess || _this$_validationMess.$content().attr("role", "alert");
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    this._dataExpressionOptionChanged(args);
    switch (name2) {
      case "dataSource":
        this._invalidate();
        break;
      case "focusStateEnabled":
      case "accessKey":
      case "tabIndex":
        this._setCollectionWidgetOption(name2, value2);
        break;
      case "disabled":
        super._optionChanged(args);
        this._setCollectionWidgetOption(name2, value2);
        break;
      case "valueExpr":
        this._setCollectionWidgetOption("keyExpr", this._getCollectionKeyExpr());
        break;
      case "value":
        this._setSelection(value2);
        this._setSubmitValue(value2);
        super._optionChanged(args);
        break;
      case "items":
        this._setSelection(this.option("value"));
        break;
      case "itemTemplate":
      case "displayExpr":
        break;
      case "layout":
        this._renderLayout();
        this._updateItemsSize();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _render() {
    super._render();
    this._updateItemsSize();
  }
  _renderLayout() {
    const layout = this.option("layout");
    const $element = renderer_default(this.element());
    $element.toggleClass("dx-radiogroup-vertical", "vertical" === layout);
    $element.toggleClass("dx-radiogroup-horizontal", "horizontal" === layout);
  }
  _renderRadios() {
    this._areRadiosCreated = Deferred();
    const $radios = renderer_default("<div>").appendTo(this.$element());
    const {
      displayExpr,
      accessKey,
      focusStateEnabled,
      itemTemplate,
      tabIndex
    } = this.option();
    this._createComponent($radios, m_radio_collection_default, {
      onInitialized: (_ref2) => {
        let {
          component
        } = _ref2;
        this._radios = component;
      },
      onContentReady: (e) => {
        this._fireContentReadyAction(true);
      },
      onItemClick: this._itemClickHandler.bind(this),
      displayExpr,
      accessKey,
      dataSource: this._dataSource,
      focusStateEnabled,
      itemTemplate,
      keyExpr: this._getCollectionKeyExpr(),
      noDataText: "",
      scrollingEnabled: false,
      selectByClick: false,
      selectionMode: "single",
      selectedItemKeys: this._getSelectedItemKeys(),
      tabIndex
    });
    this._areRadiosCreated.resolve();
  }
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    this._setSubmitValue();
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      value: true
    });
  }
  _setSubmitValue(value2) {
    value2 = value2 ?? this.option("value");
    const submitValue = "this" === this.option("valueExpr") ? this._displayGetter(value2) : value2;
    this._$submitElement.val(submitValue);
  }
  _setCollectionWidgetOption(name2, value2) {
    this._areRadiosCreated.done(this._setWidgetOption.bind(this, "_radios", arguments));
  }
  _updateItemsSize() {
    if ("horizontal" === this.option("layout")) {
      var _this$itemElements;
      null === (_this$itemElements = this.itemElements()) || void 0 === _this$itemElements || _this$itemElements.css("height", "auto");
    } else {
      var _this$itemElements2;
      const itemsCount = this.option("items").length;
      null === (_this$itemElements2 = this.itemElements()) || void 0 === _this$itemElements2 || _this$itemElements2.css("height", 100 / itemsCount + "%");
    }
  }
  focus() {
    var _this$_radios;
    null === (_this$_radios = this._radios) || void 0 === _this$_radios || _this$_radios.focus();
  }
  itemElements() {
    var _this$_radios2;
    return null === (_this$_radios2 = this._radios) || void 0 === _this$_radios2 ? void 0 : _this$_radios2._itemElements();
  }
};
RadioGroup.include(ui_data_expression_default);
component_registrator_default("dxRadioGroup", RadioGroup);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_button_group.js
var BUTTON_GROUP_ITEM_HAS_WIDTH = "dx-buttongroup-item-has-width";
var BUTTON_GROUP_STYLING_MODE_CLASS = {
  contained: "dx-buttongroup-mode-contained",
  outlined: "dx-buttongroup-mode-outlined",
  text: "dx-buttongroup-mode-text"
};
var ButtonCollection = ui_collection_widget_edit_default.inherit({
  _initTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data2, model) => {
        this._prepareItemStyles($container);
        const template = this.option("buttonTemplate");
        this._createComponent($container, button_default, extend({}, model, data2, this._getBasicButtonOptions(), {
          _templateData: this._hasCustomTemplate(template) ? model : {},
          template: model.template || template
        }));
      }, ["text", "type", "icon", "disabled", "visible", "hint"], this.option("integrationOptions.watchMethod"))
    });
  },
  _getBasicButtonOptions() {
    return {
      focusStateEnabled: false,
      onClick: null,
      hoverStateEnabled: this.option("hoverStateEnabled"),
      activeStateEnabled: this.option("activeStateEnabled"),
      stylingMode: this.option("stylingMode")
    };
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      itemTemplateProperty: null
    });
  },
  _hasCustomTemplate(template) {
    return isFunction(template) || this.option("integrationOptions.templates")[template];
  },
  _selectedItemClass: () => "dx-item-selected dx-state-selected",
  _prepareItemStyles($item) {
    const itemIndex = $item.data("dxItemIndex");
    0 === itemIndex && $item.addClass("dx-buttongroup-first-item");
    const items = this.option("items");
    items && itemIndex === items.length - 1 && $item.addClass("dx-buttongroup-last-item");
    $item.addClass("dx-shape-standard");
  },
  _renderItemContent(args) {
    args.container = renderer_default(args.container).parent();
    return this.callBase(args);
  },
  _setAriaSelectionAttribute($target, value2) {
    this.setAria("pressed", value2, $target);
  },
  _renderItemContentByNode(args, $node) {
    args.container = renderer_default(args.container.children().first());
    return this.callBase(args, $node);
  },
  _focusTarget() {
    return this.$element().parent();
  },
  _keyboardEventBindingTarget() {
    return this._focusTarget();
  },
  _refreshContent() {
    this._prepareContent();
    this._renderContent();
  },
  _itemClass: () => "dx-buttongroup-item",
  _itemSelectHandler(e) {
    if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
      return;
    }
    this.callBase(e);
  }
});
var ButtonGroup = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      focusStateEnabled: true,
      selectionMode: "single",
      selectedItems: [],
      selectedItemKeys: [],
      stylingMode: "contained",
      keyExpr: "text",
      items: [],
      buttonTemplate: "content",
      onSelectionChanged: null,
      onItemClick: null
    });
  },
  _init() {
    this.callBase();
    this._createItemClickAction();
  },
  _createItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  },
  _initMarkup() {
    this.setAria("role", "group");
    this.$element().addClass("dx-buttongroup");
    this._renderStylingMode();
    this._renderButtons();
    this._syncSelectionOptions();
    this.callBase();
  },
  _renderStylingMode() {
    const {
      stylingMode
    } = this.option();
    for (const key in BUTTON_GROUP_STYLING_MODE_CLASS) {
      this.$element().removeClass(BUTTON_GROUP_STYLING_MODE_CLASS[key]);
    }
    this.$element().addClass(BUTTON_GROUP_STYLING_MODE_CLASS[stylingMode] ?? BUTTON_GROUP_STYLING_MODE_CLASS.contained);
  },
  _fireSelectionChangeEvent(addedItems, removedItems) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems,
      removedItems
    });
  },
  _renderButtons() {
    const $buttons = renderer_default("<div>").addClass("dx-buttongroup-wrapper").appendTo(this.$element());
    const selectedItems = this.option("selectedItems");
    const options2 = {
      selectionMode: this.option("selectionMode"),
      items: this.option("items"),
      keyExpr: this.option("keyExpr"),
      buttonTemplate: this.option("buttonTemplate"),
      scrollingEnabled: false,
      selectedItemKeys: this.option("selectedItemKeys"),
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      activeStateEnabled: this.option("activeStateEnabled"),
      stylingMode: this.option("stylingMode"),
      accessKey: this.option("accessKey"),
      tabIndex: this.option("tabIndex"),
      noDataText: "",
      selectionRequired: false,
      onItemRendered: (e) => {
        const width = this.option("width");
        isDefined(width) && renderer_default(e.itemElement).addClass(BUTTON_GROUP_ITEM_HAS_WIDTH);
      },
      onSelectionChanged: (e) => {
        this._syncSelectionOptions();
        this._fireSelectionChangeEvent(e.addedItems, e.removedItems);
      },
      onItemClick: (e) => {
        this._itemClickAction(e);
      }
    };
    if (isDefined(selectedItems) && selectedItems.length) {
      options2.selectedItems = selectedItems;
    }
    this._buttonsCollection = this._createComponent($buttons, ButtonCollection, options2);
  },
  _syncSelectionOptions() {
    this._setOptionWithoutOptionChange("selectedItems", this._buttonsCollection.option("selectedItems"));
    this._setOptionWithoutOptionChange("selectedItemKeys", this._buttonsCollection.option("selectedItemKeys"));
  },
  _optionChanged(args) {
    switch (args.name) {
      case "stylingMode":
      case "selectionMode":
      case "keyExpr":
      case "buttonTemplate":
      case "items":
      case "activeStateEnabled":
      case "focusStateEnabled":
      case "hoverStateEnabled":
      case "tabIndex":
        this._invalidate();
        break;
      case "selectedItemKeys":
      case "selectedItems":
        this._buttonsCollection.option(args.name, args.value);
        break;
      case "onItemClick":
        this._createItemClickAction();
        break;
      case "onSelectionChanged":
        break;
      case "width":
        this.callBase(args);
        this._buttonsCollection.itemElements().toggleClass(BUTTON_GROUP_ITEM_HAS_WIDTH, !!args.value);
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxButtonGroup", ButtonGroup);
var m_button_group_default = ButtonGroup;

// ../../../../../../node_modules/devextreme/esm/ui/button_group.js
var button_group_default = m_button_group_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_load_indicator.js
var navigator2 = getNavigator();
var LoadIndicator = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      indicatorSrc: "",
      activeStateEnabled: false,
      hoverStateEnabled: false,
      _animatingSegmentCount: 1,
      _animatingSegmentInner: false
    });
  },
  _defaultOptionsRules() {
    const themeName = current();
    return this.callBase().concat([{
      device() {
        const realDevice2 = devices_default.real();
        const obsoleteAndroid = "android" === realDevice2.platform && !/chrome/i.test(navigator2.userAgent);
        return obsoleteAndroid;
      },
      options: {
        viaImage: true
      }
    }, {
      device: () => isMaterialBased(themeName),
      options: {
        _animatingSegmentCount: 2,
        _animatingSegmentInner: true
      }
    }, {
      device: () => isGeneric(themeName),
      options: {
        _animatingSegmentCount: 7
      }
    }]);
  },
  _useTemplates: () => false,
  _init() {
    this.callBase();
    this.$element().addClass("dx-loadindicator");
    const label = message_default.format("Loading");
    const aria = {
      role: "alert",
      label
    };
    this.setAria(aria);
  },
  _initMarkup() {
    this.callBase();
    this._renderWrapper();
    this._renderIndicatorContent();
    this._renderMarkup();
  },
  _renderWrapper() {
    this._$wrapper = renderer_default("<div>").addClass("dx-loadindicator-wrapper");
    this.$element().append(this._$wrapper);
  },
  _renderIndicatorContent() {
    this._$content = renderer_default("<div>").addClass("dx-loadindicator-content");
    this._$wrapper.append(this._$content);
  },
  _renderMarkup() {
    const {
      viaImage,
      indicatorSrc
    } = this.option();
    if (animation() && !viaImage && !indicatorSrc) {
      this._renderMarkupForAnimation();
    } else {
      this._renderMarkupForImage();
    }
  },
  _renderMarkupForAnimation() {
    const animatingSegmentInner = this.option("_animatingSegmentInner");
    this._$indicator = renderer_default("<div>").addClass("dx-loadindicator-icon");
    this._$content.append(this._$indicator);
    for (let i = this.option("_animatingSegmentCount"); i >= 0; --i) {
      const $segment = renderer_default("<div>").addClass("dx-loadindicator-segment").addClass("dx-loadindicator-segment" + i);
      if (animatingSegmentInner) {
        $segment.append(renderer_default("<div>").addClass("dx-loadindicator-segment-inner"));
      }
      this._$indicator.append($segment);
    }
  },
  _renderMarkupForImage() {
    const {
      indicatorSrc
    } = this.option();
    if (indicatorSrc) {
      this._$wrapper.addClass("dx-loadindicator-image");
      this._$wrapper.css("backgroundImage", `url(${indicatorSrc})`);
    } else if (animation()) {
      this._renderMarkupForAnimation();
    }
  },
  _renderDimensions() {
    this.callBase();
    this._updateContentSizeForAnimation();
  },
  _updateContentSizeForAnimation() {
    if (!this._$indicator) {
      return;
    }
    let width = this.option("width");
    let height = this.option("height");
    if (width || height) {
      width = getWidth(this.$element());
      height = getHeight(this.$element());
      const minDimension = Math.min(height, width);
      this._$wrapper.css({
        height: minDimension,
        width: minDimension,
        fontSize: minDimension
      });
    }
  },
  _clean() {
    this.callBase();
    this._removeMarkupForAnimation();
    this._removeMarkupForImage();
  },
  _removeMarkupForAnimation() {
    if (!this._$indicator) {
      return;
    }
    this._$indicator.remove();
    delete this._$indicator;
  },
  _removeMarkupForImage() {
    this._$wrapper.css("backgroundImage", "none");
  },
  _optionChanged(args) {
    switch (args.name) {
      case "_animatingSegmentCount":
      case "_animatingSegmentInner":
      case "indicatorSrc":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxLoadIndicator", LoadIndicator);
var m_load_indicator_default = LoadIndicator;

// ../../../../../../node_modules/devextreme/esm/ui/load_indicator.js
var load_indicator_default = m_load_indicator_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_button.js
var TextEditorButton = class {
  constructor(name2, editor, options2) {
    this.instance = null;
    this.$container = null;
    this.$placeMarker = null;
    this.editor = editor;
    this.name = name2;
    this.options = options2 || {};
  }
  _addPlaceMarker($container) {
    this.$placeMarker = renderer_default("<div>").appendTo($container);
  }
  _addToContainer($element) {
    const {
      $placeMarker,
      $container
    } = this;
    $placeMarker ? $placeMarker.replaceWith($element) : $element.appendTo($container);
  }
  _attachEvents(instance, $element) {
    throw "Not implemented";
  }
  _create() {
    throw "Not implemented";
  }
  _isRendered() {
    return !!this.instance;
  }
  _isVisible() {
    const {
      editor,
      options: options2
    } = this;
    return options2.visible || !editor.option("readOnly");
  }
  _isDisabled() {
    throw "Not implemented";
  }
  _shouldRender() {
    return this._isVisible() && !this._isRendered();
  }
  dispose() {
    const {
      instance,
      $placeMarker
    } = this;
    if (instance) {
      instance.dispose ? instance.dispose() : instance.remove();
      this.instance = null;
    }
    $placeMarker && $placeMarker.remove();
  }
  render() {
    let $container = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.$container;
    this.$container = $container;
    if (this._isVisible()) {
      const {
        instance,
        $element
      } = this._create();
      this.instance = instance;
      this._attachEvents(instance, $element);
    } else {
      this._addPlaceMarker($container);
    }
  }
  update() {
    if (this._shouldRender()) {
      this.render();
    }
    return !!this.instance;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.clear.js
var pointerDown = pointer_default.down;
var ClearButton = class extends TextEditorButton {
  _create() {
    const $element = renderer_default("<span>").addClass("dx-clear-button-area").append(renderer_default("<span>").addClass("dx-icon").addClass("dx-icon-clear"));
    this._addToContainer($element);
    this.update(true);
    return {
      instance: $element,
      $element
    };
  }
  _isVisible() {
    const {
      editor
    } = this;
    return editor._isClearButtonVisible();
  }
  _attachEvents(instance, $button) {
    const {
      editor
    } = this;
    const editorName = editor.NAME;
    events_engine_default.on($button, addNamespace2(pointerDown, editorName), (e) => {
      e.preventDefault();
      if ("mouse" !== e.pointerType) {
        editor._clearValueHandler(e);
      }
    });
    events_engine_default.on($button, addNamespace2(CLICK_EVENT_NAME, editorName), (e) => editor._clearValueHandler(e));
  }
  _legacyRender($editor, isVisible2) {
    $editor.toggleClass("dx-show-clear-button", isVisible2);
  }
  update() {
    let rendered = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    !rendered && super.update();
    const {
      editor,
      instance
    } = this;
    const $editor = editor.$element();
    const isVisible2 = this._isVisible();
    instance && instance.toggleClass("dx-state-invisible", !isVisible2);
    this._legacyRender($editor, isVisible2);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.label.js
var TextEditorLabel = class {
  constructor(props) {
    this.NAME = "dxLabel";
    this._props = props;
    this._id = `dx-texteditor-label-${new guid_default()}`;
    this._render();
    this._toggleMarkupVisibility();
  }
  _isVisible() {
    return !!this._props.text && "hidden" !== this._props.mode;
  }
  _render() {
    this._$before = renderer_default("<div>").addClass("dx-label-before");
    this._$labelSpan = renderer_default("<span>");
    this._$label = renderer_default("<div>").addClass("dx-label").append(this._$labelSpan);
    this._$after = renderer_default("<div>").addClass("dx-label-after");
    this._$root = renderer_default("<div>").addClass("dx-texteditor-label").attr("id", this._id).append(this._$before).append(this._$label).append(this._$after);
    this._updateMark();
    this._updateText();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  _toggleMarkupVisibility() {
    const visible2 = this._isVisible();
    this._updateEditorBeforeButtonsClass(visible2);
    this._updateEditorLabelClass(visible2);
    visible2 ? this._$root.appendTo(this._props.$editor) : this._$root.detach();
    this._attachEvents();
  }
  _attachEvents() {
    const clickEventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const hoverStartEventName = addNamespace2(HOVERSTART, this.NAME);
    const activeEventName = addNamespace2(ACTIVE_EVENT_NAME, this.NAME);
    events_engine_default.off(this._$labelSpan, clickEventName);
    events_engine_default.off(this._$labelSpan, hoverStartEventName);
    events_engine_default.off(this._$labelSpan, activeEventName);
    if (this._isVisible() && this._isOutsideMode()) {
      events_engine_default.on(this._$labelSpan, clickEventName, (e) => {
        const selectedText = getWindow().getSelection().toString();
        if ("" === selectedText) {
          this._props.onClickHandler();
          e.preventDefault();
        }
      });
      events_engine_default.on(this._$labelSpan, hoverStartEventName, (e) => {
        this._props.onHoverHandler(e);
      });
      events_engine_default.on(this._$labelSpan, activeEventName, (e) => {
        this._props.onActiveHandler(e);
      });
    }
  }
  _updateEditorLabelClass(visible2) {
    this._props.$editor.removeClass("dx-texteditor-with-floating-label").removeClass("dx-texteditor-label-outside").removeClass("dx-texteditor-with-label");
    if (visible2) {
      const labelClass = "floating" === this._props.mode ? "dx-texteditor-with-floating-label" : "dx-texteditor-with-label";
      this._props.$editor.addClass(labelClass);
      if (this._isOutsideMode()) {
        this._props.$editor.addClass("dx-texteditor-label-outside");
      }
    }
  }
  _isOutsideMode() {
    return "outside" === this._props.mode;
  }
  _updateEditorBeforeButtonsClass() {
    let visible2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._isVisible();
    this._props.$editor.removeClass("dx-texteditor-with-before-buttons");
    if (visible2) {
      const beforeButtonsClass = this._props.containsButtonsBefore ? "dx-texteditor-with-before-buttons" : "";
      this._props.$editor.addClass(beforeButtonsClass);
    }
  }
  _updateMark() {
    this._$labelSpan.attr("data-mark", this._props.mark);
  }
  _updateText() {
    this._$labelSpan.text(this._props.text);
  }
  _updateBeforeWidth() {
    if (this._isVisible()) {
      const width = this._props.beforeWidth ?? this._props.getBeforeWidth();
      this._$before.css({
        width
      });
      this._updateLabelTransform();
    }
  }
  _updateLabelTransform() {
    let offset2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    this._$labelSpan.css("transform", "");
    if (this._isVisible() && this._isOutsideMode()) {
      const sign2 = this._props.rtlEnabled ? 1 : -1;
      const labelTranslateX = sign2 * (getWidth(this._$before) + offset2);
      this._$labelSpan.css("transform", `translateX(${labelTranslateX}px)`);
    }
  }
  _updateMaxWidth() {
    if (this._isVisible() && !this._isOutsideMode()) {
      const maxWidth = this._props.containerWidth ?? this._props.getContainerWidth();
      this._$label.css({
        maxWidth
      });
    }
  }
  $element() {
    return this._$root;
  }
  isVisible() {
    return this._isVisible();
  }
  getId() {
    if (this._isVisible()) {
      return this._id;
    }
  }
  updateMode(mode) {
    this._props.mode = mode;
    this._toggleMarkupVisibility();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  updateText(text) {
    this._props.text = text;
    this._updateText();
    this._toggleMarkupVisibility();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  updateMark(mark) {
    this._props.mark = mark;
    this._updateMark();
  }
  updateContainsButtonsBefore(containsButtonsBefore) {
    this._props.containsButtonsBefore = containsButtonsBefore;
    this._updateEditorBeforeButtonsClass();
  }
  updateBeforeWidth(beforeWidth) {
    this._props.beforeWidth = beforeWidth;
    this._updateBeforeWidth();
  }
  updateMaxWidth(containerWidth) {
    this._props.containerWidth = containerWidth;
    this._updateMaxWidth();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_custom.js
var CustomButton = class extends TextEditorButton {
  _attachEvents(instance, $element) {
    const {
      editor
    } = this;
    events_engine_default.on($element, HOVERSTART, () => {
      editor.$element().addClass("dx-custom-button-hovered");
    });
    events_engine_default.on($element, HOVEREND, () => {
      editor.$element().removeClass("dx-custom-button-hovered");
    });
    events_engine_default.on($element, CLICK_EVENT_NAME, (e) => {
      e.stopPropagation();
    });
  }
  _create() {
    const {
      editor
    } = this;
    const $element = renderer_default("<div>");
    this._addToContainer($element);
    const instance = editor._createComponent($element, button_default, extend({}, this.options, {
      ignoreParentReadOnly: true,
      disabled: this._isDisabled(),
      integrationOptions: this._prepareIntegrationOptions(editor)
    }));
    return {
      $element,
      instance
    };
  }
  _prepareIntegrationOptions(editor) {
    return extend({}, editor.option("integrationOptions"), {
      skipTemplates: ["content"]
    });
  }
  update() {
    const isUpdated = super.update();
    if (this.instance) {
      this.instance.option("disabled", this._isDisabled());
    }
    return isUpdated;
  }
  _isVisible() {
    const {
      editor
    } = this;
    return editor.option("visible");
  }
  _isDisabled() {
    const isDefinedByUser = void 0 !== this.options.disabled;
    if (isDefinedByUser) {
      return this.instance ? this.instance.option("disabled") : this.options.disabled;
    }
    return this.editor.option("readOnly");
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_index.js
function checkButtonInfo(buttonInfo) {
  (() => {
    if (!buttonInfo || "object" !== typeof buttonInfo || Array.isArray(buttonInfo)) {
      throw ui_errors_default.Error("E1053");
    }
  })();
  (() => {
    if (!("name" in buttonInfo)) {
      throw ui_errors_default.Error("E1054");
    }
  })();
  (() => {
    const {
      name: name2
    } = buttonInfo;
    if ("string" !== typeof name2) {
      throw ui_errors_default.Error("E1055");
    }
  })();
  (() => {
    const {
      location
    } = buttonInfo;
    if ("location" in buttonInfo && "after" !== location && "before" !== location) {
      buttonInfo.location = "after";
    }
  })();
}
function checkNamesUniqueness(existingNames, newName) {
  if (-1 !== existingNames.indexOf(newName)) {
    throw ui_errors_default.Error("E1055", newName);
  }
  existingNames.push(newName);
}
function isPredefinedButtonName(name2, predefinedButtonsInfo) {
  return !!predefinedButtonsInfo.find((info) => info.name === name2);
}
var TextEditorButtonCollection = class {
  constructor(editor, defaultButtonsInfo) {
    this.buttons = [];
    this.defaultButtonsInfo = defaultButtonsInfo;
    this.editor = editor;
  }
  _compileButtonInfo(buttons) {
    const names = [];
    return buttons.map((button) => {
      const isStringButton = "string" === typeof button;
      if (!isStringButton) {
        checkButtonInfo(button);
      }
      const isDefaultButton = isStringButton || isPredefinedButtonName(button.name, this.defaultButtonsInfo);
      if (isDefaultButton) {
        const defaultButtonInfo = this.defaultButtonsInfo.find((_ref) => {
          let {
            name: name3
          } = _ref;
          return name3 === button || name3 === button.name;
        });
        if (!defaultButtonInfo) {
          throw ui_errors_default.Error("E1056", this.editor.NAME, button);
        }
        checkNamesUniqueness(names, button);
        return defaultButtonInfo;
      }
      const {
        name: name2
      } = button;
      checkNamesUniqueness(names, name2);
      return extend(button, {
        Ctor: CustomButton
      });
    });
  }
  _createButton(buttonsInfo) {
    const {
      Ctor,
      options: options2,
      name: name2
    } = buttonsInfo;
    const button = new Ctor(name2, this.editor, options2);
    this.buttons.push(button);
    return button;
  }
  _renderButtons(buttons, $container, targetLocation) {
    let $buttonsContainer = null;
    const buttonsInfo = buttons ? this._compileButtonInfo(buttons) : this.defaultButtonsInfo;
    buttonsInfo.forEach((buttonsInfo2) => {
      const {
        location = "after"
      } = buttonsInfo2;
      if (location === targetLocation) {
        this._createButton(buttonsInfo2).render((() => {
          $buttonsContainer = $buttonsContainer ?? renderer_default("<div>").addClass("dx-texteditor-buttons-container");
          "before" === targetLocation ? $container.prepend($buttonsContainer) : $container.append($buttonsContainer);
          return $buttonsContainer;
        })());
      }
    });
    return $buttonsContainer;
  }
  clean() {
    this.buttons.forEach((button) => button.dispose());
    this.buttons = [];
  }
  getButton(buttonName) {
    const button = this.buttons.find((_ref2) => {
      let {
        name: name2
      } = _ref2;
      return name2 === buttonName;
    });
    return button && button.instance;
  }
  renderAfterButtons(buttons, $container) {
    return this._renderButtons(buttons, $container, "after");
  }
  renderBeforeButtons(buttons, $container) {
    return this._renderButtons(buttons, $container, "before");
  }
  updateButtons(names) {
    this.buttons.forEach((button) => {
      if (!names || -1 !== names.indexOf(button.name)) {
        button.update();
      }
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.base.js
var EVENTS_LIST = ["KeyDown", "KeyPress", "KeyUp", "Change", "Cut", "Copy", "Paste", "Input"];
var CONTROL_KEYS = ["tab", "enter", "shift", "control", "alt", "escape", "pageUp", "pageDown", "end", "home", "leftArrow", "upArrow", "rightArrow", "downArrow"];
var TextEditorLabelCreator = TextEditorLabel;
function checkButtonsOptionType(buttons) {
  if (isDefined(buttons) && !Array.isArray(buttons)) {
    throw ui_errors_default.Error("E1053");
  }
}
var TextEditorBase = editor_default.inherit({
  ctor(_, options2) {
    if (options2) {
      checkButtonsOptionType(options2.buttons);
    }
    this._buttonCollection = new TextEditorButtonCollection(this, this._getDefaultButtons());
    this._$beforeButtonsContainer = null;
    this._$afterButtonsContainer = null;
    this._labelContainerElement = null;
    this.callBase.apply(this, arguments);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      buttons: void 0,
      value: "",
      spellcheck: false,
      showClearButton: false,
      valueChangeEvent: "change",
      placeholder: "",
      inputAttr: {},
      onFocusIn: null,
      onFocusOut: null,
      onKeyDown: null,
      onKeyUp: null,
      onChange: null,
      onInput: null,
      onCut: null,
      onCopy: null,
      onPaste: null,
      onEnterKey: null,
      mode: "text",
      hoverStateEnabled: true,
      focusStateEnabled: true,
      text: void 0,
      displayValueFormatter: (value2) => isDefined(value2) && false !== value2 ? value2 : "",
      stylingMode: config_default().editorStylingMode || "outlined",
      showValidationMark: true,
      label: "",
      labelMode: "static",
      labelMark: ""
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device() {
        const themeName = current();
        return isMaterial(themeName);
      },
      options: {
        labelMode: "floating",
        stylingMode: config_default().editorStylingMode || "filled"
      }
    }, {
      device() {
        const themeName = current();
        return isFluent(themeName);
      },
      options: {
        labelMode: "outside"
      }
    }]);
  },
  _getDefaultButtons: () => [{
    name: "clear",
    Ctor: ClearButton
  }],
  _isClearButtonVisible() {
    return this.option("showClearButton") && !this.option("readOnly");
  },
  _input() {
    return this.$element().find(".dx-texteditor-input").first();
  },
  _isFocused() {
    return focused(this._input()) || this.callBase();
  },
  _inputWrapper() {
    return this.$element();
  },
  _buttonsContainer() {
    return this._inputWrapper().find(".dx-texteditor-buttons-container").eq(0);
  },
  _isControlKey: (key) => CONTROL_KEYS.includes(key),
  _renderStylingMode() {
    this.callBase();
    this._updateButtonsStyling(this.option("stylingMode"));
  },
  _initMarkup() {
    this.$element().addClass("dx-texteditor");
    this._renderInput();
    this._renderButtonContainers();
    this._renderStylingMode();
    this._renderInputType();
    this._renderPlaceholder();
    this._renderProps();
    this.callBase();
    this._renderValue();
    this._renderLabel();
  },
  _render() {
    this.callBase();
    this._refreshValueChangeEvent();
    this._refreshEvents();
    this._renderEnterKeyAction();
    this._renderEmptinessEvent();
  },
  _renderInput() {
    this._$textEditorContainer = renderer_default("<div>").addClass("dx-texteditor-container").appendTo(this.$element());
    this._$textEditorInputContainer = renderer_default("<div>").addClass("dx-texteditor-input-container").appendTo(this._$textEditorContainer);
    this._$textEditorInputContainer.append(this._createInput());
  },
  _getInputContainer() {
    return this._$textEditorInputContainer;
  },
  _renderPendingIndicator() {
    this.$element().addClass("dx-validation-pending");
    const $inputContainer = this._getInputContainer();
    const $indicatorElement = renderer_default("<div>").addClass("dx-pending-indicator").appendTo($inputContainer);
    this._pendingIndicator = this._createComponent($indicatorElement, load_indicator_default);
  },
  _disposePendingIndicator() {
    if (!this._pendingIndicator) {
      return;
    }
    this._pendingIndicator.dispose();
    this._pendingIndicator.$element().remove();
    this._pendingIndicator = null;
    this.$element().removeClass("dx-validation-pending");
  },
  _renderValidationState() {
    this.callBase();
    const isPending2 = "pending" === this.option("validationStatus");
    if (isPending2) {
      !this._pendingIndicator && this._renderPendingIndicator();
      this._showValidMark = false;
    } else {
      if ("invalid" === this.option("validationStatus")) {
        this._showValidMark = false;
      }
      if (!this._showValidMark && true === this.option("showValidationMark")) {
        this._showValidMark = "valid" === this.option("validationStatus") && !!this._pendingIndicator;
      }
      this._disposePendingIndicator();
    }
    this._toggleValidMark();
  },
  _getButtonsContainer() {
    return this._$textEditorContainer;
  },
  _renderButtonContainers() {
    const buttons = this.option("buttons");
    const $buttonsContainer = this._getButtonsContainer();
    this._$beforeButtonsContainer = this._buttonCollection.renderBeforeButtons(buttons, $buttonsContainer);
    this._$afterButtonsContainer = this._buttonCollection.renderAfterButtons(buttons, $buttonsContainer);
  },
  _cleanButtonContainers() {
    var _this$_$beforeButtons, _this$_$afterButtonsC;
    null === (_this$_$beforeButtons = this._$beforeButtonsContainer) || void 0 === _this$_$beforeButtons || _this$_$beforeButtons.remove();
    null === (_this$_$afterButtonsC = this._$afterButtonsContainer) || void 0 === _this$_$afterButtonsC || _this$_$afterButtonsC.remove();
    this._buttonCollection.clean();
  },
  _clean() {
    this._buttonCollection.clean();
    this._disposePendingIndicator();
    this._unobserveLabelContainerResize();
    this._$beforeButtonsContainer = null;
    this._$afterButtonsContainer = null;
    this._$textEditorContainer = null;
    this.callBase();
  },
  _createInput() {
    const $input = renderer_default("<input>");
    this._applyInputAttributes($input, this.option("inputAttr"));
    return $input;
  },
  _setSubmitElementName(name2) {
    const inputAttrName = this.option("inputAttr.name");
    return this.callBase(name2 || inputAttrName || "");
  },
  _applyInputAttributes($input, customAttributes) {
    const inputAttributes = extend(this._getDefaultAttributes(), customAttributes);
    $input.attr(inputAttributes).addClass("dx-texteditor-input");
    this._setInputMinHeight($input);
  },
  _setInputMinHeight($input) {
    $input.css("minHeight", this.option("height") ? "0" : "");
  },
  _getPlaceholderAttr() {
    const {
      ios: ios2,
      mac: mac2
    } = devices_default.real();
    const {
      placeholder
    } = this.option();
    const value2 = placeholder || (ios2 || mac2 ? " " : null);
    return value2;
  },
  _getDefaultAttributes() {
    const defaultAttributes = {
      autocomplete: "off",
      placeholder: this._getPlaceholderAttr()
    };
    return defaultAttributes;
  },
  _updateButtons(names) {
    this._buttonCollection.updateButtons(names);
  },
  _updateButtonsStyling(editorStylingMode) {
    each(this.option("buttons"), (_, _ref) => {
      let {
        options: options2,
        name: buttonName
      } = _ref;
      if (options2 && !options2.stylingMode && this.option("visible")) {
        const buttonInstance = this.getButton(buttonName);
        buttonInstance.option && buttonInstance.option("stylingMode", "underlined" === editorStylingMode ? "text" : "contained");
      }
    });
  },
  _renderValue() {
    const renderInputPromise = this._renderInputValue();
    return renderInputPromise.promise();
  },
  _renderInputValue(value2) {
    value2 = value2 ?? this.option("value");
    let text = this.option("text");
    const displayValue = this.option("displayValue");
    const displayValueFormatter = this.option("displayValueFormatter");
    if (void 0 !== displayValue && null !== value2) {
      text = displayValueFormatter(displayValue);
    } else if (!isDefined(text)) {
      text = displayValueFormatter(value2);
    }
    this.option("text", text);
    if (this._input().val() !== (isDefined(text) ? text : "")) {
      this._renderDisplayText(text);
    } else {
      this._toggleEmptinessEventHandler();
    }
    return Deferred().resolve();
  },
  _renderDisplayText(text) {
    this._input().val(text);
    this._toggleEmptinessEventHandler();
  },
  _isValueValid() {
    if (this._input().length) {
      const {
        validity
      } = this._input().get(0);
      if (validity) {
        return validity.valid;
      }
    }
    return true;
  },
  _toggleEmptiness(isEmpty2) {
    this.$element().toggleClass("dx-texteditor-empty", isEmpty2);
    this._togglePlaceholder(isEmpty2);
  },
  _togglePlaceholder(isEmpty2) {
    this.$element().find(".dx-placeholder").eq(0).toggleClass("dx-state-invisible", !isEmpty2);
  },
  _renderProps() {
    this._toggleReadOnlyState();
    this._toggleSpellcheckState();
    this._toggleTabIndex();
  },
  _toggleDisabledState(value2) {
    this.callBase.apply(this, arguments);
    const $input = this._input();
    $input.prop("disabled", value2);
  },
  _toggleTabIndex() {
    const $input = this._input();
    const disabled = this.option("disabled");
    const focusStateEnabled = this.option("focusStateEnabled");
    if (disabled || !focusStateEnabled) {
      $input.attr("tabIndex", -1);
    } else {
      $input.removeAttr("tabIndex");
    }
  },
  _toggleReadOnlyState() {
    this._input().prop("readOnly", this._readOnlyPropValue());
    this.callBase();
  },
  _readOnlyPropValue() {
    return this.option("readOnly");
  },
  _toggleSpellcheckState() {
    this._input().prop("spellcheck", this.option("spellcheck"));
  },
  _unobserveLabelContainerResize() {
    if (this._labelContainerElement) {
      resize_observer_default.unobserve(this._labelContainerElement);
      this._labelContainerElement = null;
    }
  },
  _getLabelContainer() {
    return this._input();
  },
  _getLabelContainerWidth() {
    return getWidth(this._getLabelContainer());
  },
  _getLabelBeforeWidth() {
    const buttonsBeforeWidth = this._$beforeButtonsContainer && getWidth(this._$beforeButtonsContainer);
    return buttonsBeforeWidth ?? 0;
  },
  _updateLabelWidth() {
    this._label.updateBeforeWidth(this._getLabelBeforeWidth());
    this._label.updateMaxWidth(this._getLabelContainerWidth());
  },
  _getFieldElement() {
    return this._getLabelContainer();
  },
  _setFieldAria(force) {
    var _this$_label;
    const inputAttr = this.option("inputAttr");
    const ariaLabel = null === inputAttr || void 0 === inputAttr ? void 0 : inputAttr["aria-label"];
    const labelId = null === (_this$_label = this._label) || void 0 === _this$_label ? void 0 : _this$_label.getId();
    const value2 = ariaLabel ? void 0 : labelId;
    if (value2 || force) {
      const aria = {
        labelledby: value2,
        label: ariaLabel
      };
      this.setAria(aria, this._getFieldElement());
    }
  },
  _renderLabel() {
    this._unobserveLabelContainerResize();
    this._labelContainerElement = renderer_default(this._getLabelContainer()).get(0);
    const {
      label,
      labelMode,
      labelMark,
      rtlEnabled
    } = this.option();
    const labelConfig = {
      onClickHandler: () => {
        this.focus();
      },
      onHoverHandler: (e) => {
        e.stopPropagation();
      },
      onActiveHandler: (e) => {
        e.stopPropagation();
      },
      $editor: this.$element(),
      text: label,
      mark: labelMark,
      mode: labelMode,
      rtlEnabled,
      containsButtonsBefore: !!this._$beforeButtonsContainer,
      getContainerWidth: () => this._getLabelContainerWidth(),
      getBeforeWidth: () => this._getLabelBeforeWidth()
    };
    this._label = new TextEditorLabelCreator(labelConfig);
    this._setFieldAria();
    if (this._labelContainerElement) {
      resize_observer_default.observe(this._labelContainerElement, this._updateLabelWidth.bind(this));
    }
  },
  _renderPlaceholder() {
    this._renderPlaceholderMarkup();
    this._attachPlaceholderEvents();
  },
  _renderPlaceholderMarkup() {
    if (this._$placeholder) {
      this._$placeholder.remove();
      this._$placeholder = null;
    }
    const $input = this._input();
    const placeholder = this.option("placeholder");
    const placeholderAttributes = {
      id: placeholder ? `dx-${new guid_default()}` : void 0,
      "data-dx_placeholder": placeholder
    };
    const $placeholder = this._$placeholder = renderer_default("<div>").attr(placeholderAttributes);
    $placeholder.insertAfter($input);
    $placeholder.addClass("dx-placeholder");
  },
  _attachPlaceholderEvents() {
    const startEvent = addNamespace2(pointer_default.up, this.NAME);
    events_engine_default.on(this._$placeholder, startEvent, () => {
      events_engine_default.trigger(this._input(), "focus");
    });
    this._toggleEmptinessEventHandler();
  },
  _placeholder() {
    return this._$placeholder || renderer_default();
  },
  _clearValueHandler(e) {
    const $input = this._input();
    e.stopPropagation();
    this._saveValueChangeEvent(e);
    this._clearValue();
    !this._isFocused() && events_engine_default.trigger($input, "focus");
    events_engine_default.trigger($input, "input");
  },
  _clearValue() {
    this.clear();
  },
  _renderEvents() {
    const $input = this._input();
    each(EVENTS_LIST, (_, event) => {
      if (this.hasActionSubscription(`on${event}`)) {
        const action = this._createActionByOption(`on${event}`, {
          excludeValidators: ["readOnly"]
        });
        events_engine_default.on($input, addNamespace2(event.toLowerCase(), this.NAME), (e) => {
          if (this._disposed) {
            return;
          }
          action({
            event: e
          });
        });
      }
    });
  },
  _refreshEvents() {
    const $input = this._input();
    each(EVENTS_LIST, (_, event) => {
      events_engine_default.off($input, addNamespace2(event.toLowerCase(), this.NAME));
    });
    this._renderEvents();
  },
  _keyPressHandler() {
    this.option("text", this._input().val());
  },
  _keyDownHandler(e) {
    const $input = this._input();
    const isCtrlEnter = e.ctrlKey && "enter" === normalizeKeyName(e);
    const isNewValue = $input.val() !== this.option("value");
    if (isCtrlEnter && isNewValue) {
      events_engine_default.trigger($input, "change");
    }
  },
  _getValueChangeEventOptionName: () => "valueChangeEvent",
  _renderValueChangeEvent() {
    const keyPressEvent = addNamespace2(this._renderValueEventName(), `${this.NAME}TextChange`);
    const valueChangeEvent = addNamespace2(this.option(this._getValueChangeEventOptionName()), `${this.NAME}ValueChange`);
    const keyDownEvent = addNamespace2("keydown", `${this.NAME}TextChange`);
    const $input = this._input();
    events_engine_default.on($input, keyPressEvent, this._keyPressHandler.bind(this));
    events_engine_default.on($input, valueChangeEvent, this._valueChangeEventHandler.bind(this));
    events_engine_default.on($input, keyDownEvent, this._keyDownHandler.bind(this));
  },
  _cleanValueChangeEvent() {
    const valueChangeNamespace = `.${this.NAME}ValueChange`;
    const textChangeNamespace = `.${this.NAME}TextChange`;
    events_engine_default.off(this._input(), valueChangeNamespace);
    events_engine_default.off(this._input(), textChangeNamespace);
  },
  _refreshValueChangeEvent() {
    this._cleanValueChangeEvent();
    this._renderValueChangeEvent();
  },
  _renderValueEventName: () => "input change keypress",
  _focusTarget() {
    return this._input();
  },
  _focusEventTarget() {
    return this.element();
  },
  _isInput(element) {
    return element === this._input().get(0);
  },
  _preventNestedFocusEvent(event) {
    if (event.isDefaultPrevented()) {
      return true;
    }
    let shouldPrevent = this._isNestedTarget(event.relatedTarget);
    if ("focusin" === event.type) {
      shouldPrevent = shouldPrevent && this._isNestedTarget(event.target) && !this._isInput(event.target);
    } else if (!shouldPrevent) {
      this._toggleFocusClass(false, this.$element());
    }
    shouldPrevent && event.preventDefault();
    return shouldPrevent;
  },
  _isNestedTarget(target) {
    return !!this.$element().find(target).length;
  },
  _focusClassTarget() {
    return this.$element();
  },
  _focusInHandler(event) {
    this._preventNestedFocusEvent(event);
    this.callBase.apply(this, arguments);
  },
  _focusOutHandler(event) {
    this._preventNestedFocusEvent(event);
    this.callBase.apply(this, arguments);
  },
  _toggleFocusClass(isFocused, $element) {
    this.callBase(isFocused, this._focusClassTarget($element));
  },
  _hasFocusClass(element) {
    return this.callBase(renderer_default(element || this.$element()));
  },
  _renderEmptinessEvent() {
    const $input = this._input();
    events_engine_default.on($input, "input blur", this._toggleEmptinessEventHandler.bind(this));
  },
  _toggleEmptinessEventHandler() {
    const text = this._input().val();
    const isEmpty2 = ("" === text || null === text) && this._isValueValid();
    this._toggleEmptiness(isEmpty2);
  },
  _valueChangeEventHandler(e, formattedValue) {
    if (this.option("readOnly")) {
      return;
    }
    this._saveValueChangeEvent(e);
    this.option("value", arguments.length > 1 ? formattedValue : this._input().val());
    this._saveValueChangeEvent(void 0);
  },
  _renderEnterKeyAction() {
    this._enterKeyAction = this._createActionByOption("onEnterKey", {
      excludeValidators: ["readOnly"]
    });
    events_engine_default.off(this._input(), "keyup.onEnterKey.dxTextEditor");
    events_engine_default.on(this._input(), "keyup.onEnterKey.dxTextEditor", this._enterKeyHandlerUp.bind(this));
  },
  _enterKeyHandlerUp(e) {
    if (this._disposed) {
      return;
    }
    if ("enter" === normalizeKeyName(e)) {
      this._enterKeyAction({
        event: e
      });
    }
  },
  _updateValue() {
    this._options.silent("text", null);
    this._renderValue();
  },
  _dispose() {
    this._enterKeyAction = void 0;
    this.callBase();
  },
  _getSubmitElement() {
    return this._input();
  },
  _hasActiveElement() {
    return this._input().is(dom_adapter_default.getActiveElement(this._input()[0]));
  },
  _optionChanged(args) {
    const {
      name: name2,
      fullName,
      value: value2
    } = args;
    const eventName = name2.replace("on", "");
    if (EVENTS_LIST.includes(eventName)) {
      this._refreshEvents();
      return;
    }
    switch (name2) {
      case "valueChangeEvent":
        this._refreshValueChangeEvent();
        this._refreshFocusEvent();
        this._refreshEvents();
        break;
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "focusStateEnabled":
        this.callBase(args);
        this._toggleTabIndex();
        break;
      case "spellcheck":
        this._toggleSpellcheckState();
        break;
      case "mode":
        this._renderInputType();
        break;
      case "onEnterKey":
        this._renderEnterKeyAction();
        break;
      case "placeholder":
        this._renderPlaceholder();
        this._setFieldAria(true);
        this._input().attr({
          placeholder: this._getPlaceholderAttr()
        });
        break;
      case "label":
        this._label.updateText(value2);
        this._setFieldAria(true);
        break;
      case "labelMark":
        this._label.updateMark(value2);
        break;
      case "labelMode":
        this._label.updateMode(value2);
        this._setFieldAria();
        break;
      case "width":
        this.callBase(args);
        this._label.updateMaxWidth(this._getLabelContainerWidth());
        break;
      case "readOnly":
      case "disabled":
        this._updateButtons();
        this.callBase(args);
        break;
      case "showClearButton":
        this._updateButtons(["clear"]);
        break;
      case "text":
      case "showValidationMark":
        break;
      case "value":
        this._updateValue();
        this.callBase(args);
        break;
      case "inputAttr":
        this._applyInputAttributes(this._input(), this.option(name2));
        break;
      case "stylingMode":
        this._renderStylingMode();
        this._updateLabelWidth();
        break;
      case "buttons":
        if (fullName === name2) {
          checkButtonsOptionType(value2);
        }
        this._cleanButtonContainers();
        this._renderButtonContainers();
        this._updateButtonsStyling(this.option("stylingMode"));
        this._updateLabelWidth();
        this._label.updateContainsButtonsBefore(!!this._$beforeButtonsContainer);
        break;
      case "visible":
        this.callBase(args);
        if (value2 && this.option("buttons")) {
          this._cleanButtonContainers();
          this._renderButtonContainers();
          this._updateButtonsStyling(this.option("stylingMode"));
        }
        break;
      case "displayValueFormatter":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  },
  _renderInputType() {
    this._setInputType(this.option("mode"));
  },
  _setInputType(type2) {
    const input = this._input();
    if ("search" === type2) {
      type2 = "text";
    }
    try {
      input.prop("type", type2);
    } catch (e) {
      input.prop("type", "text");
    }
  },
  getButton(name2) {
    return this._buttonCollection.getButton(name2);
  },
  focus() {
    events_engine_default.trigger(this._input(), "focus");
  },
  clear() {
    if (this._showValidMark) {
      this._showValidMark = false;
      this._renderValidationState();
    }
    const defaultOptions3 = this._getDefaultOptions();
    if (this.option("value") === defaultOptions3.value) {
      this._options.silent("text", "");
      this._renderValue();
    } else {
      this.option("value", defaultOptions3.value);
    }
  },
  _resetToInitialValue() {
    if (this.option("value") === this._initialValue) {
      this._options.silent("text", this._initialValue);
      this._renderValue();
    } else {
      this.callBase();
    }
    this._disposePendingIndicator();
    this._showValidMark = false;
    this._toggleValidMark();
  },
  _toggleValidMark() {
    this.$element().toggleClass("dx-valid", !!this._showValidMark);
  },
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      this.callBase(value2);
    } else {
      this.callBase();
    }
  },
  on(eventName, eventHandler) {
    const result2 = this.callBase(eventName, eventHandler);
    const event = eventName.charAt(0).toUpperCase() + eventName.substr(1);
    if (EVENTS_LIST.includes(event)) {
      this._refreshEvents();
    }
    return result2;
  }
});
var m_text_editor_base_default = TextEditorBase;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.rule.js
var BaseMaskRule = class {
  constructor(config3) {
    this._value = " ";
    extend(this, config3);
  }
  next(rule) {
    if (!arguments.length) {
      return this._next;
    }
    this._next = rule;
  }
  _prepareHandlingArgs(args, config3) {
    config3 = config3 || {};
    const handlingProperty = Object.prototype.hasOwnProperty.call(args, "value") ? "value" : "text";
    args[handlingProperty] = config3.str ?? args[handlingProperty];
    args.start = config3.start ?? args.start;
    args.length = config3.length ?? args.length;
    args.index += 1;
    return args;
  }
  first(index2) {
    index2 = index2 || 0;
    return this.next().first(index2 + 1);
  }
  isAccepted(caret3) {
    return false;
  }
  adjustedCaret(caret3, isForwardDirection, char) {
    return isForwardDirection ? this._adjustedForward(caret3, 0, char) : this._adjustedBackward(caret3, 0, char);
  }
  _adjustedForward(caret3, index2, char) {
  }
  _adjustedBackward(caret3, index2, char) {
  }
  isValid(args) {
  }
  reset() {
  }
  clear(args) {
  }
  text() {
  }
  value() {
  }
  rawValue() {
  }
  handle(args) {
  }
};
var EmptyMaskRule = class extends BaseMaskRule {
  next() {
  }
  handle() {
    return 0;
  }
  text() {
    return "";
  }
  value() {
    return "";
  }
  first() {
    return 0;
  }
  rawValue() {
    return "";
  }
  adjustedCaret() {
    return 0;
  }
  isValid() {
    return true;
  }
};
var MaskRule = class extends BaseMaskRule {
  text() {
    return (" " !== this._value ? this._value : this.maskChar) + this.next().text();
  }
  value() {
    return this._value + this.next().value();
  }
  rawValue() {
    return this._value + this.next().rawValue();
  }
  handle(args) {
    const str = Object.prototype.hasOwnProperty.call(args, "value") ? args.value : args.text;
    if (!str || !str.length || !args.length) {
      return 0;
    }
    if (args.start) {
      return this.next().handle(this._prepareHandlingArgs(args, {
        start: args.start - 1
      }));
    }
    const char = str[0];
    const rest = str.substring(1);
    this._tryAcceptChar(char, args);
    return this._accepted() ? this.next().handle(this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    })) + 1 : this.handle(this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    }));
  }
  clear(args) {
    this._tryAcceptChar(" ", args);
    this.next().clear(this._prepareHandlingArgs(args));
  }
  reset() {
    this._accepted(false);
    this.next().reset();
  }
  _tryAcceptChar(char, args) {
    this._accepted(false);
    if (!this._isAllowed(char, args)) {
      return;
    }
    const acceptedChar = " " === char ? this.maskChar : char;
    args.fullText = args.fullText.substring(0, args.index) + acceptedChar + args.fullText.substring(args.index + 1);
    this._accepted(true);
    this._value = char;
  }
  _accepted(value2) {
    if (!arguments.length) {
      return !!this._isAccepted;
    }
    this._isAccepted = !!value2;
  }
  first(index2) {
    return " " === this._value ? index2 || 0 : super.first(index2);
  }
  _isAllowed(char, args) {
    if (" " === char) {
      return true;
    }
    return this._isValid(char, args);
  }
  _isValid(char, args) {
    const {
      allowedChars
    } = this;
    if (allowedChars instanceof RegExp) {
      return allowedChars.test(char);
    }
    if (isFunction(allowedChars)) {
      return allowedChars(char, args.index, args.fullText);
    }
    if (Array.isArray(allowedChars)) {
      return allowedChars.includes(char);
    }
    return allowedChars === char;
  }
  isAccepted(caret3) {
    return 0 === caret3 ? this._accepted() : this.next().isAccepted(caret3 - 1);
  }
  _adjustedForward(caret3, index2, char) {
    if (index2 >= caret3) {
      return index2;
    }
    return this.next()._adjustedForward(caret3, index2 + 1, char) || index2 + 1;
  }
  _adjustedBackward(caret3, index2) {
    if (index2 >= caret3 - 1) {
      return caret3;
    }
    return this.next()._adjustedBackward(caret3, index2 + 1) || index2 + 1;
  }
  isValid(args) {
    return this._isValid(this._value, args) && this.next().isValid(this._prepareHandlingArgs(args));
  }
};
var StubMaskRule = class extends MaskRule {
  value() {
    return this.next().value();
  }
  handle(args) {
    const hasValueProperty = Object.prototype.hasOwnProperty.call(args, "value");
    const str = hasValueProperty ? args.value : args.text;
    if (!str.length || !args.length) {
      return 0;
    }
    if (args.start || hasValueProperty) {
      return this.next().handle(this._prepareHandlingArgs(args, {
        start: args.start && args.start - 1
      }));
    }
    const char = str[0];
    const rest = str.substring(1);
    this._tryAcceptChar(char);
    const nextArgs = this._isAllowed(char) ? this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    }) : args;
    return this.next().handle(nextArgs) + 1;
  }
  clear(args) {
    this._accepted(false);
    this.next().clear(this._prepareHandlingArgs(args));
  }
  _tryAcceptChar(char) {
    this._accepted(this._isValid(char));
  }
  _isValid(char) {
    return char === this.maskChar;
  }
  first(index2) {
    index2 = index2 || 0;
    return this.next().first(index2 + 1);
  }
  _adjustedForward(caret3, index2, char) {
    if (index2 >= caret3 && char === this.maskChar) {
      return index2;
    }
    if (caret3 === index2 + 1 && this._accepted()) {
      return caret3;
    }
    return this.next()._adjustedForward(caret3, index2 + 1, char);
  }
  _adjustedBackward(caret3, index2) {
    if (index2 >= caret3 - 1) {
      return 0;
    }
    return this.next()._adjustedBackward(caret3, index2 + 1);
  }
  isValid(args) {
    return this.next().isValid(this._prepareHandlingArgs(args));
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.strategy.js
var BLUR_EVENT = "blur beforedeactivate";
var DELETE_INPUT_TYPES = ["deleteContentBackward", "deleteSoftLineBackward", "deleteContent", "deleteHardLineBackward"];
var HISTORY_INPUT_TYPES = ["historyUndo", "historyRedo"];
var EVENT_NAMES = ["focusIn", "focusOut", "input", "paste", "cut", "drop", "beforeInput"];
function getEmptyString(length) {
  return " ".repeat(length);
}
var MaskStrategy = class {
  constructor(editor) {
    this.editor = editor;
  }
  _editorOption() {
    return this.editor.option(...arguments);
  }
  _editorInput() {
    return this.editor._input();
  }
  _editorCaret(newCaret) {
    if (!newCaret) {
      return this.editor._caret();
    }
    this.editor._caret(newCaret);
  }
  _attachChangeEventHandler() {
    if (!this._editorOption("valueChangeEvent").split(" ").includes("change")) {
      return;
    }
    const $input = this._editorInput();
    const namespace = addNamespace2(BLUR_EVENT, "dxMask");
    events_engine_default.on($input, namespace, (e) => {
      this.editor._changeHandler(e);
    });
  }
  _beforeInputHandler() {
    this._previousText = this._editorOption("text");
    this._prevCaret = this._editorCaret();
  }
  _inputHandler(event) {
    const {
      originalEvent
    } = event;
    if (!originalEvent) {
      return;
    }
    const {
      inputType: inputType2
    } = originalEvent;
    if (HISTORY_INPUT_TYPES.includes(inputType2)) {
      this._handleHistoryInputEvent();
    } else if (DELETE_INPUT_TYPES.includes(inputType2)) {
      this._handleBackwardDeleteInputEvent();
    } else {
      const currentCaret = this._editorCaret();
      if (!currentCaret.end) {
        return;
      }
      this._clearSelectedText();
      this._autoFillHandler(originalEvent);
      this._editorCaret(currentCaret);
      this._handleInsertTextInputEvent(originalEvent.data);
    }
    if (this._editorOption("text") === this._previousText) {
      event.stopImmediatePropagation();
    }
  }
  _handleHistoryInputEvent() {
    const caret3 = this._editorCaret();
    this._updateEditorMask({
      start: caret3.start,
      length: caret3.end - caret3.start,
      text: ""
    });
    this._editorCaret(this._prevCaret);
  }
  _handleBackwardDeleteInputEvent() {
    this._clearSelectedText();
    const caret3 = this._editorCaret();
    this.editor.setForwardDirection();
    this.editor._adjustCaret();
    const adjustedForwardCaret = this._editorCaret();
    if (adjustedForwardCaret.start !== caret3.start) {
      this.editor.setBackwardDirection();
      this.editor._adjustCaret();
    }
  }
  _clearSelectedText() {
    var _this$_prevCaret, _this$_prevCaret2;
    const length = (null === (_this$_prevCaret = this._prevCaret) || void 0 === _this$_prevCaret ? void 0 : _this$_prevCaret.end) - (null === (_this$_prevCaret2 = this._prevCaret) || void 0 === _this$_prevCaret2 ? void 0 : _this$_prevCaret2.start) || 1;
    const caret3 = this._editorCaret();
    if (!this._isAutoFill()) {
      this.editor.setBackwardDirection();
      this._updateEditorMask({
        start: caret3.start,
        length,
        text: getEmptyString(length)
      });
    }
  }
  _handleInsertTextInputEvent(data2) {
    var _this$_prevCaret3;
    const text = data2 ?? "";
    this.editor.setForwardDirection();
    const hasValidChars = this._updateEditorMask({
      start: (null === (_this$_prevCaret3 = this._prevCaret) || void 0 === _this$_prevCaret3 ? void 0 : _this$_prevCaret3.start) ?? 0,
      length: text.length || 1,
      text
    });
    if (!hasValidChars) {
      this._editorCaret(this._prevCaret);
    }
  }
  _updateEditorMask(args) {
    const textLength = args.text.length;
    const processedCharsCount = this.editor._handleChain(args);
    this.editor._displayMask();
    if (this.editor.isForwardDirection()) {
      const {
        start,
        end
      } = this._editorCaret();
      const correction = processedCharsCount - textLength;
      const hasSkippedStub = processedCharsCount > 1;
      if (hasSkippedStub && 1 === textLength) {
        this._editorCaret({
          start: start + correction,
          end: end + correction
        });
      }
      this.editor._adjustCaret();
    }
    return !!processedCharsCount;
  }
  _focusInHandler() {
    this.editor._showMaskPlaceholder();
    this.editor.setForwardDirection();
    if (!this.editor._isValueEmpty() && this._editorOption("isValid")) {
      this.editor._adjustCaret();
    } else {
      const caret3 = this.editor._maskRulesChain.first();
      this._caretTimeout = setTimeout(() => {
        this._editorCaret({
          start: caret3,
          end: caret3
        });
      }, 0);
    }
  }
  _focusOutHandler(event) {
    this.editor._changeHandler(event);
    if ("onFocus" === this._editorOption("showMaskMode") && this.editor._isValueEmpty()) {
      this._editorOption("text", "");
      this.editor._renderDisplayText("");
    }
  }
  _delHandler(event) {
    const {
      editor
    } = this;
    editor._maskKeyHandler(event, () => {
      if (!editor._hasSelection()) {
        editor._handleKey(" ");
      }
    });
  }
  _cutHandler(event) {
    const caret3 = this._editorCaret();
    const selectedText = this._editorInput().val().substring(caret3.start, caret3.end);
    this.editor._maskKeyHandler(event, () => clipboardText(event, selectedText));
  }
  _dropHandler() {
    this._clearDragTimer();
    this._dragTimer = setTimeout(() => {
      const value2 = this.editor._convertToValue(this._editorInput().val());
      this._editorOption("value", value2);
    });
  }
  _pasteHandler(event) {
    const {
      editor
    } = this;
    if (this._editorOption("disabled")) {
      return;
    }
    const caret3 = this._editorCaret();
    editor._maskKeyHandler(event, () => {
      const pastedText = clipboardText(event);
      const restText = editor._maskRulesChain.text().substring(caret3.end);
      const accepted = editor._handleChain({
        text: pastedText,
        start: caret3.start,
        length: pastedText.length
      });
      const newCaret = caret3.start + accepted;
      editor._handleChain({
        text: restText,
        start: newCaret,
        length: restText.length
      });
      editor._caret({
        start: newCaret,
        end: newCaret
      });
    });
  }
  _autoFillHandler(event) {
    const {
      editor
    } = this;
    const inputVal = this._editorInput().val();
    this._inputHandlerTimer = setTimeout(() => {
      if (this._isAutoFill()) {
        editor._maskKeyHandler(event, () => {
          editor._handleChain({
            text: inputVal,
            start: 0,
            length: inputVal.length
          });
        });
        editor._validateMask();
      }
    });
  }
  _isAutoFill() {
    const $input = this._editorInput();
    if (browser_default.webkit) {
      const input = $input.get(0);
      return (null === input || void 0 === input ? void 0 : input.matches(":-webkit-autofill")) ?? false;
    }
    return false;
  }
  _clearDragTimer() {
    clearTimeout(this._dragTimer);
  }
  _clearTimers() {
    this._clearDragTimer();
    clearTimeout(this._caretTimeout);
    clearTimeout(this._inputHandlerTimer);
  }
  getHandler(handlerName) {
    return (args) => {
      var _this;
      null === (_this = this[`_${handlerName}Handler`]) || void 0 === _this || _this.call(this, args);
    };
  }
  attachEvents() {
    const $input = this._editorInput();
    EVENT_NAMES.forEach((eventName) => {
      const namespace = addNamespace2(eventName.toLowerCase(), "dxMask");
      events_engine_default.on($input, namespace, this.getHandler(eventName));
    });
    this._attachChangeEventHandler();
  }
  detachEvents() {
    this._clearTimers();
    events_engine_default.off(this._editorInput(), ".dxMask");
  }
  clean() {
    this._clearTimers();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_utils.caret.js
var {
  ios,
  mac
} = devices_default.real();
var isFocusingOnCaretChange = ios || mac;
var getCaret = function(input) {
  let range2;
  try {
    range2 = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } catch (e) {
    range2 = {
      start: 0,
      end: 0
    };
  }
  return range2;
};
var setCaret = function(input, position3) {
  const body = dom_adapter_default.getBody();
  if (!body.contains(input) && !body.contains(input.getRootNode().host)) {
    return;
  }
  try {
    input.selectionStart = position3.start;
    input.selectionEnd = position3.end;
  } catch (e) {
  }
};
var caret = function(input, position3) {
  let force = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
  input = renderer_default(input).get(0);
  if (!isDefined(position3)) {
    return getCaret(input);
  }
  if (!force && isFocusingOnCaretChange && dom_adapter_default.getActiveElement(input) !== input) {
    return;
  }
  setCaret(input, position3);
};
var m_utils_caret_default = caret;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.js
var caret2 = m_utils_caret_default;
var buildInMaskRules = {
  0: /[0-9]/,
  9: /[0-9\s]/,
  "#": /[-+0-9\s]/,
  L: (char) => isLiteralChar(char),
  l: (char) => isLiteralChar(char) || isSpaceChar(char),
  C: /\S/,
  c: /./,
  A: (char) => isLiteralChar(char) || isNumericChar(char),
  a: (char) => isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char)
};
function isNumericChar(char) {
  return /[0-9]/.test(char);
}
function isLiteralChar(char) {
  const code = char.charCodeAt();
  return code > 64 && code < 91 || code > 96 && code < 123 || code > 127;
}
function isSpaceChar(char) {
  return " " === char;
}
var TextEditorMask = m_text_editor_base_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      mask: "",
      maskChar: "_",
      maskRules: {},
      maskInvalidMessage: message_default.format("validation-mask"),
      useMaskedValue: false,
      showMaskMode: "always"
    });
  },
  _supportedKeys() {
    const that = this;
    const keyHandlerMap = {
      del: that._maskStrategy.getHandler("del"),
      enter: that._changeHandler
    };
    const result2 = that.callBase();
    each(keyHandlerMap, (key, callback) => {
      const parentHandler = result2[key];
      result2[key] = function(e) {
        that.option("mask") && callback.call(that, e);
        parentHandler && parentHandler(e);
      };
    });
    return result2;
  },
  _getSubmitElement() {
    return !this.option("mask") ? this.callBase() : this._$hiddenElement;
  },
  _init() {
    this.callBase();
    this._initMaskStrategy();
  },
  _initMaskStrategy() {
    this._maskStrategy = new MaskStrategy(this);
  },
  _initMarkup() {
    this._renderHiddenElement();
    this.callBase();
  },
  _attachMouseWheelEventHandlers() {
    const hasMouseWheelHandler = this._onMouseWheel !== noop2;
    if (!hasMouseWheelHandler) {
      return;
    }
    const input = this._input();
    const eventName = addNamespace2(EVENT_NAME, this.NAME);
    const mouseWheelAction = this._createAction((e) => {
      const {
        event
      } = e;
      if (focused(input) && !isCommandKeyPressed(event)) {
        this._onMouseWheel(event);
        event.preventDefault();
        event.stopPropagation();
      }
    });
    events_engine_default.off(input, eventName);
    events_engine_default.on(input, eventName, (e) => {
      mouseWheelAction({
        event: e
      });
    });
  },
  _onMouseWheel: noop2,
  _useMaskBehavior() {
    return Boolean(this.option("mask"));
  },
  _attachDropEventHandler() {
    const useMaskBehavior = this._useMaskBehavior();
    if (!useMaskBehavior) {
      return;
    }
    const eventName = addNamespace2("drop", this.NAME);
    const input = this._input();
    events_engine_default.off(input, eventName);
    events_engine_default.on(input, eventName, (e) => e.preventDefault());
  },
  _render() {
    this._attachMouseWheelEventHandlers();
    this._renderMask();
    this.callBase();
    this._attachDropEventHandler();
  },
  _renderHiddenElement() {
    if (this.option("mask")) {
      this._$hiddenElement = renderer_default("<input>").attr("type", "hidden").appendTo(this._inputWrapper());
    }
  },
  _removeHiddenElement() {
    this._$hiddenElement && this._$hiddenElement.remove();
  },
  _renderMask() {
    this.$element().removeClass("dx-texteditor-masked");
    this._maskRulesChain = null;
    this._maskStrategy.detachEvents();
    if (!this.option("mask")) {
      return;
    }
    this.$element().addClass("dx-texteditor-masked");
    this._maskStrategy.attachEvents();
    this._parseMask();
    this._renderMaskedValue();
  },
  _changeHandler(e) {
    const $input = this._input();
    const inputValue = $input.val();
    if (inputValue === this._changedValue) {
      return;
    }
    this._changedValue = inputValue;
    const changeEvent = createEvent(e, {
      type: "change"
    });
    events_engine_default.trigger($input, changeEvent);
  },
  _parseMask() {
    this._maskRules = extend({}, buildInMaskRules, this.option("maskRules"));
    this._maskRulesChain = this._parseMaskRule(0);
  },
  _parseMaskRule(index2) {
    const mask = this.option("mask");
    if (index2 >= mask.length) {
      return new EmptyMaskRule();
    }
    const currentMaskChar = mask[index2];
    const isEscapedChar = "\\" === currentMaskChar;
    const result2 = isEscapedChar ? new StubMaskRule({
      maskChar: mask[index2 + 1]
    }) : this._getMaskRule(currentMaskChar);
    result2.next(this._parseMaskRule(index2 + 1 + isEscapedChar));
    return result2;
  },
  _getMaskRule(pattern) {
    let ruleConfig;
    each(this._maskRules, (rulePattern, allowedChars) => {
      if (rulePattern === pattern) {
        ruleConfig = {
          pattern: rulePattern,
          allowedChars
        };
        return false;
      }
    });
    return isDefined(ruleConfig) ? new MaskRule(extend({
      maskChar: this.option("maskChar") || " "
    }, ruleConfig)) : new StubMaskRule({
      maskChar: pattern
    });
  },
  _renderMaskedValue() {
    if (!this._maskRulesChain) {
      return;
    }
    const value2 = this.option("value") || "";
    this._maskRulesChain.clear(this._normalizeChainArguments());
    const chainArgs = {
      length: value2.length
    };
    chainArgs[this._isMaskedValueMode() ? "text" : "value"] = value2;
    this._handleChain(chainArgs);
    this._displayMask();
  },
  _replaceSelectedText(text, selection, char) {
    if (void 0 === char) {
      return text;
    }
    const textBefore = text.slice(0, selection.start);
    const textAfter = text.slice(selection.end);
    const edited = textBefore + char + textAfter;
    return edited;
  },
  _isMaskedValueMode() {
    return this.option("useMaskedValue");
  },
  _displayMask(caret3) {
    caret3 = caret3 || this._caret();
    this._renderValue();
    this._caret(caret3);
  },
  _isValueEmpty() {
    return isEmpty(this._value);
  },
  _shouldShowMask() {
    const showMaskMode = this.option("showMaskMode");
    if ("onFocus" === showMaskMode) {
      return focused(this._input()) || !this._isValueEmpty();
    }
    return true;
  },
  _showMaskPlaceholder() {
    if (this._shouldShowMask()) {
      const text = this._maskRulesChain.text();
      this.option("text", text);
      if ("onFocus" === this.option("showMaskMode")) {
        this._renderDisplayText(text);
      }
    }
  },
  _renderValue() {
    if (this._maskRulesChain) {
      this._showMaskPlaceholder();
      if (this._$hiddenElement) {
        const value2 = this._maskRulesChain.value();
        const submitElementValue = !isEmpty(value2) ? this._getPreparedValue() : "";
        this._$hiddenElement.val(submitElementValue);
      }
    }
    return this.callBase();
  },
  _getPreparedValue() {
    return this._convertToValue().replace(/\s+$/, "");
  },
  _valueChangeEventHandler(e) {
    if (!this._maskRulesChain) {
      this.callBase.apply(this, arguments);
      return;
    }
    this._saveValueChangeEvent(e);
    this.option("value", this._getPreparedValue());
  },
  _isControlKeyFired(e) {
    return this._isControlKey(normalizeKeyName(e)) || isCommandKeyPressed(e);
  },
  _handleChain(args) {
    const handledCount = this._maskRulesChain.handle(this._normalizeChainArguments(args));
    this._updateMaskInfo();
    return handledCount;
  },
  _normalizeChainArguments(args) {
    args = args || {};
    args.index = 0;
    args.fullText = this._maskRulesChain.text();
    return args;
  },
  _convertToValue(text) {
    if (this._isMaskedValueMode()) {
      text = this._replaceMaskCharWithEmpty(text || this._textValue || "");
    } else {
      text = text || this._value || "";
    }
    return text;
  },
  _replaceMaskCharWithEmpty(text) {
    return text.replace(new RegExp(this.option("maskChar"), "g"), " ");
  },
  _maskKeyHandler(e, keyHandler) {
    if (this.option("readOnly")) {
      return;
    }
    this.setForwardDirection();
    e.preventDefault();
    this._handleSelection();
    const previousText = this._input().val();
    const raiseInputEvent = () => {
      if (previousText !== this._input().val()) {
        events_engine_default.trigger(this._input(), "input");
      }
    };
    const handled = keyHandler();
    if (handled) {
      handled.then(raiseInputEvent);
    } else {
      this.setForwardDirection();
      this._adjustCaret();
      this._displayMask();
      this._maskRulesChain.reset();
      raiseInputEvent();
    }
  },
  _handleKey(key, direction) {
    this._direction(direction || "forward");
    this._adjustCaret(key);
    this._handleKeyChain(key);
    this._moveCaret();
  },
  _handleSelection() {
    if (!this._hasSelection()) {
      return;
    }
    const caret3 = this._caret();
    const emptyChars = new Array(caret3.end - caret3.start + 1).join(" ");
    this._handleKeyChain(emptyChars);
  },
  _handleKeyChain(chars) {
    const caret3 = this._caret();
    const start = this.isForwardDirection() ? caret3.start : caret3.start - 1;
    const end = this.isForwardDirection() ? caret3.end : caret3.end - 1;
    const length = start === end ? 1 : end - start;
    this._handleChain({
      text: chars,
      start,
      length
    });
  },
  _tryMoveCaretBackward() {
    this.setBackwardDirection();
    const currentCaret = this._caret().start;
    this._adjustCaret();
    return !currentCaret || currentCaret !== this._caret().start;
  },
  _adjustCaret(char) {
    const caretStart = this._caret().start;
    const isForwardDirection = this.isForwardDirection();
    const caret3 = this._maskRulesChain.adjustedCaret(caretStart, isForwardDirection, char);
    this._caret({
      start: caret3,
      end: caret3
    });
  },
  _moveCaret() {
    const currentCaret = this._caret().start;
    const maskRuleIndex = currentCaret + (this.isForwardDirection() ? 0 : -1);
    const caret3 = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this.isForwardDirection() ? 1 : -1) : currentCaret;
    this._caret({
      start: caret3,
      end: caret3
    });
  },
  _caret(position3, force) {
    const $input = this._input();
    if (!$input.length) {
      return;
    }
    if (!arguments.length) {
      return caret2($input);
    }
    caret2($input, position3, force);
  },
  _hasSelection() {
    const caret3 = this._caret();
    return caret3.start !== caret3.end;
  },
  _direction(direction) {
    if (!arguments.length) {
      return this._typingDirection;
    }
    this._typingDirection = direction;
  },
  setForwardDirection() {
    this._direction("forward");
  },
  setBackwardDirection() {
    this._direction("backward");
  },
  isForwardDirection() {
    return "forward" === this._direction();
  },
  _updateMaskInfo() {
    this._textValue = this._maskRulesChain.text();
    this._value = this._maskRulesChain.value();
  },
  _clean() {
    this._maskStrategy && this._maskStrategy.clean();
    this.callBase();
  },
  _validateMask() {
    if (!this._maskRulesChain) {
      return;
    }
    const isValid = isEmpty(this.option("value")) || this._maskRulesChain.isValid(this._normalizeChainArguments());
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: this.option("maskInvalidMessage")
      }
    });
  },
  _updateHiddenElement() {
    this._removeHiddenElement();
    if (this.option("mask")) {
      this._input().removeAttr("name");
      this._renderHiddenElement();
    }
    this._setSubmitElementName(this.option("name"));
  },
  _updateMaskOption() {
    this._updateHiddenElement();
    this._renderMask();
    this._validateMask();
    this._refreshValueChangeEvent();
  },
  _processEmptyMask(mask) {
    if (mask) {
      return;
    }
    const value2 = this.option("value");
    this.option({
      text: value2,
      isValid: true,
      validationError: null
    });
    this.validationRequest.fire({
      value: value2,
      editor: this
    });
    this._renderValue();
  },
  _optionChanged(args) {
    switch (args.name) {
      case "mask":
        this._updateMaskOption();
        this._processEmptyMask(args.value);
        break;
      case "maskChar":
      case "maskRules":
      case "useMaskedValue":
        this._updateMaskOption();
        break;
      case "value":
        this._renderMaskedValue();
        this._validateMask();
        this.callBase(args);
        this._changedValue = this._input().val();
        break;
      case "maskInvalidMessage":
        break;
      case "showMaskMode":
        this.option("text", "");
        this._renderValue();
        break;
      default:
        this.callBase(args);
    }
  },
  clear() {
    const {
      value: defaultValue
    } = this._getDefaultOptions();
    if (this.option("value") === defaultValue) {
      this._renderMaskedValue();
    }
    this.callBase();
  }
});
var m_text_editor_mask_default = TextEditorMask;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.js
component_registrator_default("dxTextEditor", m_text_editor_mask_default);
var m_text_editor_default = m_text_editor_mask_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_text_box.js
var window21 = getWindow();
var ignoreKeys = ["backspace", "tab", "enter", "pageUp", "pageDown", "end", "home", "leftArrow", "rightArrow", "downArrow", "upArrow", "del"];
var TextBox = m_text_editor_default.inherit({
  ctor(element, options2) {
    if (options2) {
      this._showClearButton = options2.showClearButton;
    }
    this.callBase.apply(this, arguments);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: "",
      mode: "text",
      maxLength: null
    });
  },
  _initMarkup() {
    this.$element().addClass("dx-textbox");
    this.callBase();
    this.setAria("role", "textbox");
  },
  _renderInputType() {
    this.callBase();
    this._renderSearchMode();
  },
  _useTemplates: () => false,
  _renderProps() {
    this.callBase();
    this._toggleMaxLengthProp();
  },
  _toggleMaxLengthProp() {
    const maxLength = this._getMaxLength();
    if (maxLength && maxLength > 0) {
      this._input().attr("maxLength", maxLength);
    } else {
      this._input().removeAttr("maxLength");
    }
  },
  _renderSearchMode() {
    const $element = this._$element;
    if ("search" === this.option("mode")) {
      $element.addClass("dx-searchbox");
      this._renderSearchIcon();
      if (void 0 === this._showClearButton) {
        this._showClearButton = this.option("showClearButton");
        this.option("showClearButton", true);
      }
    } else {
      $element.removeClass("dx-searchbox");
      this._$searchIcon && this._$searchIcon.remove();
      this.option("showClearButton", void 0 === this._showClearButton ? this.option("showClearButton") : this._showClearButton);
      delete this._showClearButton;
    }
  },
  _renderSearchIcon() {
    const $searchIcon = renderer_default("<div>").addClass("dx-icon").addClass("dx-icon-search");
    $searchIcon.prependTo(this._input().parent());
    this._$searchIcon = $searchIcon;
  },
  _getLabelContainerWidth() {
    if (this._$searchIcon) {
      const $inputContainer = this._input().parent();
      return getWidth($inputContainer) - this._getLabelBeforeWidth();
    }
    return this.callBase();
  },
  _getLabelBeforeWidth() {
    let labelBeforeWidth = this.callBase();
    if (this._$searchIcon) {
      labelBeforeWidth += getOuterWidth(this._$searchIcon);
    }
    return labelBeforeWidth;
  },
  _optionChanged(args) {
    switch (args.name) {
      case "maxLength":
        this._toggleMaxLengthProp();
        break;
      case "mode":
        this.callBase(args);
        this._updateLabelWidth();
        break;
      case "mask":
        this.callBase(args);
        this._toggleMaxLengthProp();
        break;
      default:
        this.callBase(args);
    }
  },
  _onKeyDownCutOffHandler(e) {
    const actualMaxLength = this._getMaxLength();
    if (actualMaxLength && !e.ctrlKey && !this._hasSelection()) {
      const $input = renderer_default(e.target);
      const key = normalizeKeyName(e);
      this._cutOffExtraChar($input);
      return $input.val().length < actualMaxLength || ignoreKeys.includes(key) || "" !== window21.getSelection().toString();
    }
    return true;
  },
  _onChangeCutOffHandler(e) {
    const $input = renderer_default(e.target);
    if (this.option("maxLength")) {
      this._cutOffExtraChar($input);
    }
  },
  _cutOffExtraChar($input) {
    const actualMaxLength = this._getMaxLength();
    const textInput = $input.val();
    if (actualMaxLength && textInput.length > actualMaxLength) {
      $input.val(textInput.substr(0, actualMaxLength));
    }
  },
  _getMaxLength() {
    const isMaskSpecified = !!this.option("mask");
    return isMaskSpecified ? null : this.option("maxLength");
  }
});
component_registrator_default("dxTextBox", TextBox);
var m_text_box_default = TextBox;

// ../../../../../../node_modules/devextreme/esm/ui/text_box/text_box.js
var text_box_default = m_text_box_default;

// ../../../../../../node_modules/devextreme/esm/ui/text_box.js
var text_box_default2 = text_box_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_button.js
var DROP_DOWN_EDITOR_BUTTON_VISIBLE = "dx-dropdowneditor-button-visible";
var BUTTON_MESSAGE = "dxDropDownEditor-selectLabel";
var DropDownButton = class extends TextEditorButton {
  constructor(name2, editor, options2) {
    super(name2, editor, options2);
    this.currentTemplate = null;
  }
  _attachEvents(instance) {
    const {
      editor
    } = this;
    instance.option("onClick", (e) => {
      var _editor$_shouldCallOp;
      if (null !== (_editor$_shouldCallOp = editor._shouldCallOpenHandler) && void 0 !== _editor$_shouldCallOp && _editor$_shouldCallOp.call(editor)) {
        editor._openHandler(e);
        return;
      }
      !editor.option("openOnFieldClick") && editor._openHandler(e);
    });
    events_engine_default.on(instance.$element(), "mousedown", (e) => {
      if (editor.$element().is(".dx-state-focused")) {
        e.preventDefault();
      }
    });
  }
  _create() {
    const {
      editor
    } = this;
    const $element = renderer_default("<div>");
    const options2 = this._getOptions();
    this._addToContainer($element);
    const instance = editor._createComponent($element, button_default, extend({}, options2, {
      elementAttr: {
        "aria-label": message_default.format(BUTTON_MESSAGE)
      }
    }));
    this._legacyRender(editor.$element(), $element, options2.visible);
    return {
      $element,
      instance
    };
  }
  _getOptions() {
    const {
      editor
    } = this;
    const visible2 = this._isVisible();
    const isReadOnly = editor.option("readOnly");
    const options2 = {
      focusStateEnabled: false,
      hoverStateEnabled: false,
      activeStateEnabled: false,
      useInkRipple: false,
      disabled: isReadOnly,
      visible: visible2
    };
    this._addTemplate(options2);
    return options2;
  }
  _isVisible() {
    const {
      editor
    } = this;
    return super._isVisible() && editor.option("showDropDownButton");
  }
  _legacyRender($editor, $element, isVisible2) {
    $editor.toggleClass(DROP_DOWN_EDITOR_BUTTON_VISIBLE, isVisible2);
    if ($element) {
      $element.removeClass("dx-button").removeClass("dx-button-mode-contained").addClass("dx-dropdowneditor-button");
    }
  }
  _isSameTemplate() {
    return this.editor.option("dropDownButtonTemplate") === this.currentTemplate;
  }
  _addTemplate(options2) {
    if (!this._isSameTemplate()) {
      options2.template = this.editor._getTemplateByOption("dropDownButtonTemplate");
      this.currentTemplate = this.editor.option("dropDownButtonTemplate");
    }
  }
  update() {
    const shouldUpdate = super.update();
    if (shouldUpdate) {
      const {
        editor,
        instance
      } = this;
      const $editor = editor.$element();
      const options2 = this._getOptions();
      null === instance || void 0 === instance || instance.option(options2);
      this._legacyRender($editor, null === instance || void 0 === instance ? void 0 : instance.$element(), options2.visible);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_utils.js
var getElementWidth = function($element) {
  if (hasWindow()) {
    return getOuterWidth($element);
  }
};
var getSizeValue = function(size) {
  if (null === size) {
    size = void 0;
  }
  if ("function" === typeof size) {
    size = size();
  }
  return size;
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_editor.js
var DROP_DOWN_EDITOR_INPUT_WRAPPER = "dx-dropdowneditor-input-wrapper";
var DROP_DOWN_EDITOR_OVERLAY = "dx-dropdowneditor-overlay";
var DROP_DOWN_EDITOR_OVERLAY_FLIPPED = "dx-dropdowneditor-overlay-flipped";
var DROP_DOWN_EDITOR_ACTIVE = "dx-dropdowneditor-active";
var DROP_DOWN_EDITOR_FIELD_CLICKABLE = "dx-dropdowneditor-field-clickable";
var DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER = "dx-dropdowneditor-field-template-wrapper";
var isIOs = "ios" === devices_default.current().platform;
var DropDownEditor = text_box_default2.inherit({
  _supportedKeys() {
    return extend({}, this.callBase(), {
      tab(e) {
        if (!this.option("opened")) {
          return;
        }
        if (!this._popup.getFocusableElements().length) {
          this.close();
          return;
        }
        const $focusableElement = e.shiftKey ? this._getLastPopupElement() : this._getFirstPopupElement();
        if ($focusableElement) {
          events_engine_default.trigger($focusableElement, "focus");
          $focusableElement.select();
        }
        e.preventDefault();
      },
      escape(e) {
        if (this.option("opened")) {
          e.preventDefault();
        }
        this.close();
        return true;
      },
      upArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          if (e.altKey) {
            this.close();
            return false;
          }
        }
        return true;
      },
      downArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          if (e.altKey) {
            this._validatedOpening();
            return false;
          }
        }
        return true;
      },
      enter(e) {
        if (this.option("opened")) {
          e.preventDefault();
          this._valueChangeEventHandler(e);
        }
        return true;
      }
    });
  },
  _getDefaultButtons() {
    return this.callBase().concat([{
      name: "dropDown",
      Ctor: DropDownButton
    }]);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: null,
      onOpened: null,
      onClosed: null,
      opened: false,
      acceptCustomValue: true,
      applyValueMode: "instantly",
      deferRendering: true,
      activeStateEnabled: true,
      dropDownButtonTemplate: "dropDownButton",
      fieldTemplate: null,
      openOnFieldClick: false,
      showDropDownButton: true,
      buttons: void 0,
      dropDownOptions: {
        showTitle: false
      },
      popupPosition: this._getDefaultPopupPosition(),
      onPopupInitialized: null,
      applyButtonText: message_default.format("OK"),
      cancelButtonText: message_default.format("Cancel"),
      buttonsLocation: "default",
      useHiddenSubmitElement: false,
      validationMessagePosition: "auto"
    });
  },
  _useTemplates: () => true,
  _getDefaultPopupPosition(isRtlEnabled) {
    const position3 = getDefaultAlignment(isRtlEnabled);
    return {
      offset: {
        h: 0,
        v: -1
      },
      my: `${position3} top`,
      at: `${position3} bottom`,
      collision: "flip flip"
    };
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device(device) {
        const isGeneric2 = "generic" === device.platform;
        return isGeneric2;
      },
      options: {
        popupPosition: {
          offset: {
            v: 0
          }
        }
      }
    }]);
  },
  _inputWrapper() {
    return this.$element().find(`.${DROP_DOWN_EDITOR_INPUT_WRAPPER}`).first();
  },
  _init() {
    this.callBase();
    this._initVisibilityActions();
    this._initPopupInitializedAction();
    this._updatePopupPosition(this.option("rtlEnabled"));
    this._options.cache("dropDownOptions", this.option("dropDownOptions"));
  },
  _updatePopupPosition(isRtlEnabled) {
    const {
      my,
      at
    } = this._getDefaultPopupPosition(isRtlEnabled);
    const currentPosition = this.option("popupPosition");
    this.option("popupPosition", extend({}, currentPosition, {
      my,
      at
    }));
  },
  _initVisibilityActions() {
    this._openAction = this._createActionByOption("onOpened", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this._closeAction = this._createActionByOption("onClosed", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _initPopupInitializedAction() {
    this._popupInitializedAction = this._createActionByOption("onPopupInitialized", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _initMarkup() {
    this._renderSubmitElement();
    this.callBase();
    this.$element().addClass("dx-dropdowneditor");
    this.setAria("role", this._getAriaRole());
  },
  _render() {
    this.callBase();
    this._renderOpenHandler();
    this._attachFocusOutHandler();
    this._renderOpenedState();
  },
  _renderContentImpl() {
    if (!this.option("deferRendering")) {
      this._createPopup();
    }
  },
  _renderInput() {
    this.callBase();
    this._renderTemplateWrapper();
    this._wrapInput();
    this._setDefaultAria();
  },
  _wrapInput() {
    this._$container = this.$element().wrapInner(renderer_default("<div>").addClass(DROP_DOWN_EDITOR_INPUT_WRAPPER)).children().eq(0);
  },
  _getAriaHasPopup: () => "true",
  _getAriaAutocomplete: () => "none",
  _getAriaRole: () => "combobox",
  _setDefaultAria() {
    this.setAria({
      haspopup: this._getAriaHasPopup(),
      autocomplete: this._getAriaAutocomplete(),
      role: this._getAriaRole()
    });
  },
  _readOnlyPropValue() {
    return !this._isEditable() || this.callBase();
  },
  _cleanFocusState() {
    this.callBase();
    if (this.option("fieldTemplate")) {
      this._detachFocusEvents();
    }
  },
  _getFieldTemplate() {
    return this.option("fieldTemplate") && this._getTemplateByOption("fieldTemplate");
  },
  _renderMask() {
    if (this.option("fieldTemplate")) {
      return;
    }
    this.callBase();
  },
  _renderField() {
    const fieldTemplate = this._getFieldTemplate();
    fieldTemplate && this._renderTemplatedField(fieldTemplate, this._fieldRenderData());
  },
  _renderPlaceholder() {
    const hasFieldTemplate = !!this._getFieldTemplate();
    if (!hasFieldTemplate) {
      this.callBase();
    }
  },
  _renderValue() {
    if (this.option("useHiddenSubmitElement")) {
      this._setSubmitValue();
    }
    const promise = this.callBase();
    promise.always(this._renderField.bind(this));
  },
  _getButtonsContainer() {
    const fieldTemplate = this._getFieldTemplate();
    return fieldTemplate ? this._$container : this._$textEditorContainer;
  },
  _renderTemplateWrapper() {
    const fieldTemplate = this._getFieldTemplate();
    if (!fieldTemplate) {
      return;
    }
    if (!this._$templateWrapper) {
      this._$templateWrapper = renderer_default("<div>").addClass(DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER).prependTo(this.$element());
    }
  },
  _renderTemplatedField(fieldTemplate, data2) {
    const isFocused = focused(this._input());
    this._detachKeyboardEvents();
    this._detachFocusEvents();
    this._$textEditorContainer.remove();
    this._$templateWrapper.empty();
    const $templateWrapper = this._$templateWrapper;
    const currentRenderContext = Symbol("renderContext");
    this._activeRenderContext = currentRenderContext;
    fieldTemplate.render({
      model: data2,
      container: getPublicElement($templateWrapper),
      onRendered: () => {
        if (this._activeRenderContext !== currentRenderContext) {
          return;
        }
        const isRenderedInRoot = !!this.$element().find($templateWrapper).length;
        if (!isRenderedInRoot) {
          return;
        }
        const $input = this._input();
        if (!$input.length) {
          throw ui_errors_default.Error("E1010");
        }
        this._integrateInput();
        isFocused && events_engine_default.trigger($input, "focus");
      }
    });
  },
  _integrateInput() {
    var _this$option;
    const {
      isValid
    } = this.option();
    this._renderFocusState();
    this._refreshValueChangeEvent();
    this._refreshEvents();
    this._refreshEmptinessEvent();
    this._setDefaultAria();
    this._setFieldAria();
    this._toggleValidationClasses(!isValid);
    null === (_this$option = this.option("_onMarkupRendered")) || void 0 === _this$option || _this$option();
  },
  _refreshEmptinessEvent() {
    events_engine_default.off(this._input(), "input blur", this._toggleEmptinessEventHandler);
    this._renderEmptinessEvent();
  },
  _fieldRenderData() {
    return this.option("value");
  },
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      dropDownButton: new FunctionTemplate((options2) => {
        const $icon = renderer_default("<div>").addClass("dx-dropdowneditor-icon");
        renderer_default(options2.container).append($icon);
      })
    });
    this.callBase();
  },
  _renderOpenHandler() {
    const $inputWrapper = this._inputWrapper();
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const openOnFieldClick = this.option("openOnFieldClick");
    events_engine_default.off($inputWrapper, eventName);
    events_engine_default.on($inputWrapper, eventName, this._getInputClickHandler(openOnFieldClick));
    this.$element().toggleClass(DROP_DOWN_EDITOR_FIELD_CLICKABLE, openOnFieldClick);
    if (openOnFieldClick) {
      this._openOnFieldClickAction = this._createAction(this._openHandler.bind(this));
    }
  },
  _attachFocusOutHandler() {
    if (isIOs) {
      this._detachFocusOutEvents();
      events_engine_default.on(this._inputWrapper(), addNamespace2("focusout", this.NAME), (event) => {
        const newTarget = event.relatedTarget;
        if (newTarget && this.option("opened")) {
          const isNewTargetOutside = this._isTargetOutOfComponent(newTarget);
          if (isNewTargetOutside) {
            this.close();
          }
        }
      });
    }
  },
  _isTargetOutOfComponent(newTarget) {
    const popupWrapper = this.content ? renderer_default(this.content()).closest(`.${DROP_DOWN_EDITOR_OVERLAY}`) : this._$popup;
    const isTargetOutsidePopup = 0 === renderer_default(newTarget).closest(`.${DROP_DOWN_EDITOR_OVERLAY}`, popupWrapper).length;
    return isTargetOutsidePopup;
  },
  _detachFocusOutEvents() {
    isIOs && events_engine_default.off(this._inputWrapper(), addNamespace2("focusout", this.NAME));
  },
  _getInputClickHandler(openOnFieldClick) {
    return openOnFieldClick ? (e) => {
      this._executeOpenAction(e);
    } : () => {
      this._focusInput();
    };
  },
  _openHandler() {
    this._toggleOpenState();
  },
  _executeOpenAction(e) {
    this._openOnFieldClickAction({
      event: e
    });
  },
  _keyboardEventBindingTarget() {
    return this._input();
  },
  _focusInput() {
    if (this.option("disabled")) {
      return false;
    }
    if (this.option("focusStateEnabled") && !focused(this._input())) {
      this._resetCaretPosition();
      events_engine_default.trigger(this._input(), "focus");
    }
    return true;
  },
  _resetCaretPosition() {
    let ignoreEditable = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const inputElement = this._input().get(0);
    if (inputElement) {
      const {
        value: value2
      } = inputElement;
      const caretPosition = isDefined(value2) && (ignoreEditable || this._isEditable()) ? value2.length : 0;
      this._caret({
        start: caretPosition,
        end: caretPosition
      }, true);
    }
  },
  _isEditable() {
    return this.option("acceptCustomValue");
  },
  _toggleOpenState(isVisible2) {
    if (!this._focusInput()) {
      return;
    }
    if (!this.option("readOnly")) {
      isVisible2 = arguments.length ? isVisible2 : !this.option("opened");
      this.option("opened", isVisible2);
    }
  },
  _getControlsAria() {
    return this._popup && this._popupContentId;
  },
  _renderOpenedState() {
    const opened = this.option("opened");
    if (opened) {
      this._createPopup();
    }
    this.$element().toggleClass(DROP_DOWN_EDITOR_ACTIVE, opened);
    this._setPopupOption("visible", opened);
    const arias = {
      expanded: opened,
      controls: this._getControlsAria()
    };
    this.setAria(arias);
    this.setAria("owns", opened ? this._popupContentId : void 0, this.$element());
  },
  _createPopup() {
    if (this._$popup) {
      return;
    }
    this._$popup = renderer_default("<div>").addClass(DROP_DOWN_EDITOR_OVERLAY).appendTo(this.$element());
    this._renderPopup();
    this._renderPopupContent();
    this._setPopupAriaLabel();
  },
  _setPopupAriaLabel() {
    const $overlayContent = this._popup.$overlayContent();
    this.setAria("label", "Dropdown", $overlayContent);
  },
  _renderPopupContent: noop2,
  _renderPopup() {
    const popupConfig = extend(this._popupConfig(), this._options.cache("dropDownOptions"));
    delete popupConfig.closeOnOutsideClick;
    this._popup = this._createComponent(this._$popup, ui_popup_default, popupConfig);
    this._popup.on({
      showing: this._popupShowingHandler.bind(this),
      shown: this._popupShownHandler.bind(this),
      hiding: this._popupHidingHandler.bind(this),
      hidden: this._popupHiddenHandler.bind(this),
      contentReady: this._contentReadyHandler.bind(this)
    });
    this._attachPopupKeyHandler();
    this._contentReadyHandler();
    this._setPopupContentId(this._popup.$content());
    this._bindInnerWidgetOptions(this._popup, "dropDownOptions");
  },
  _attachPopupKeyHandler() {
    events_engine_default.on(this._popup.$overlayContent(), addNamespace2("keydown", this.NAME), (e) => this._popupKeyHandler(e));
  },
  _popupKeyHandler(e) {
    switch (normalizeKeyName(e)) {
      case "tab":
        this._popupTabHandler(e);
        break;
      case "escape":
        this._popupEscHandler(e);
    }
  },
  _popupTabHandler(e) {
    const $target = renderer_default(e.target);
    const moveBackward = e.shiftKey && $target.is(this._getFirstPopupElement());
    const moveForward = !e.shiftKey && $target.is(this._getLastPopupElement());
    if (moveForward || moveBackward) {
      events_engine_default.trigger(this.field(), "focus");
      e.preventDefault();
    }
  },
  _popupEscHandler() {
    events_engine_default.trigger(this._input(), "focus");
    this.close();
  },
  _setPopupContentId($popupContent) {
    this._popupContentId = `dx-${new guid_default()}`;
    this.setAria("id", this._popupContentId, $popupContent);
  },
  _contentReadyHandler: noop2,
  _popupConfig() {
    return {
      onInitialized: this._getPopupInitializedHandler(),
      position: extend(this.option("popupPosition"), {
        of: this.$element()
      }),
      showTitle: this.option("dropDownOptions.showTitle"),
      _ignoreFunctionValueDeprecation: true,
      width: () => getElementWidth(this.$element()),
      height: "auto",
      shading: false,
      hideOnParentScroll: true,
      hideOnOutsideClick: (e) => this._closeOutsideDropDownHandler(e),
      animation: {
        show: {
          type: "fade",
          duration: 0,
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          duration: 400,
          from: 1,
          to: 0
        }
      },
      deferRendering: false,
      focusStateEnabled: false,
      showCloseButton: false,
      dragEnabled: false,
      toolbarItems: this._getPopupToolbarItems(),
      onPositioned: this._popupPositionedHandler.bind(this),
      fullScreen: false,
      contentTemplate: null,
      _hideOnParentScrollTarget: this.$element(),
      _wrapperClassExternal: DROP_DOWN_EDITOR_OVERLAY,
      _ignorePreventScrollEventsDeprecation: true
    };
  },
  _popupInitializedHandler: noop2,
  _getPopupInitializedHandler() {
    const onPopupInitialized = this.option("onPopupInitialized");
    return (e) => {
      this._popupInitializedHandler(e);
      if (onPopupInitialized) {
        this._popupInitializedAction({
          popup: e.component
        });
      }
    };
  },
  _dimensionChanged() {
    if (hasWindow() && !this.$element().is(":visible")) {
      this.close();
      return;
    }
    this._updatePopupWidth();
  },
  _updatePopupWidth() {
    const popupWidth = getSizeValue(this.option("dropDownOptions.width"));
    if (void 0 === popupWidth) {
      this._setPopupOption("width", () => getElementWidth(this.$element()));
    }
  },
  _popupPositionedHandler(e) {
    var _e$position;
    const {
      labelMode,
      stylingMode
    } = this.option();
    if (!this._popup) {
      return;
    }
    const $popupOverlayContent = this._popup.$overlayContent();
    const isOverlayFlipped = null === (_e$position = e.position) || void 0 === _e$position || null === (_e$position = _e$position.v) || void 0 === _e$position ? void 0 : _e$position.flip;
    const shouldIndentForLabel = "hidden" !== labelMode && "outside" !== labelMode && "outlined" === stylingMode;
    if (e.position) {
      $popupOverlayContent.toggleClass(DROP_DOWN_EDITOR_OVERLAY_FLIPPED, isOverlayFlipped);
    }
    if (isOverlayFlipped && shouldIndentForLabel && this._label.isVisible()) {
      const $label = this._label.$element();
      move($popupOverlayContent, {
        top: locate($popupOverlayContent).top - parseInt($label.css("fontSize"))
      });
    }
  },
  _popupShowingHandler: noop2,
  _popupHidingHandler() {
    this.option("opened", false);
  },
  _popupShownHandler() {
    var _this$_validationMess;
    this._openAction();
    null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess || _this$_validationMess.option("positionSide", this._getValidationMessagePositionSide());
  },
  _popupHiddenHandler() {
    var _this$_validationMess2;
    this._closeAction();
    null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 || _this$_validationMess2.option("positionSide", this._getValidationMessagePositionSide());
  },
  _getValidationMessagePositionSide() {
    const validationMessagePosition = this.option("validationMessagePosition");
    if ("auto" !== validationMessagePosition) {
      return validationMessagePosition;
    }
    let positionSide = "bottom";
    if (this._popup && this._popup.option("visible")) {
      const {
        top: myTop
      } = position_default.setup(this.$element());
      const {
        top: popupTop
      } = position_default.setup(this._popup.$content());
      positionSide = myTop + this.option("popupPosition").offset.v > popupTop ? "bottom" : "top";
    }
    return positionSide;
  },
  _closeOutsideDropDownHandler(_ref) {
    let {
      target
    } = _ref;
    const $target = renderer_default(target);
    const dropDownButton = this.getButton("dropDown");
    const $dropDownButton = dropDownButton && dropDownButton.$element();
    const isInputClicked = !!$target.closest(this.$element()).length;
    const isDropDownButtonClicked = !!$target.closest($dropDownButton).length;
    const isOutsideClick = !isInputClicked && !isDropDownButtonClicked;
    return isOutsideClick;
  },
  _clean() {
    delete this._openOnFieldClickAction;
    delete this._$templateWrapper;
    if (this._$popup) {
      this._$popup.remove();
      delete this._$popup;
      delete this._popup;
    }
    this.callBase();
  },
  _setPopupOption(optionName, value2) {
    this._setWidgetOption("_popup", arguments);
  },
  _validatedOpening() {
    if (!this.option("readOnly")) {
      this._toggleOpenState(true);
    }
  },
  _getPopupToolbarItems() {
    return "useButtons" === this.option("applyValueMode") ? this._popupToolbarItemsConfig() : [];
  },
  _getFirstPopupElement() {
    return renderer_default(this._popup.getFocusableElements()).first();
  },
  _getLastPopupElement() {
    return renderer_default(this._popup.getFocusableElements()).last();
  },
  _popupToolbarItemsConfig() {
    const buttonsConfig = [{
      shortcut: "done",
      options: {
        onClick: this._applyButtonHandler.bind(this),
        text: this.option("applyButtonText")
      }
    }, {
      shortcut: "cancel",
      options: {
        onClick: this._cancelButtonHandler.bind(this),
        text: this.option("cancelButtonText")
      }
    }];
    return this._applyButtonsLocation(buttonsConfig);
  },
  _applyButtonsLocation(buttonsConfig) {
    const buttonsLocation = this.option("buttonsLocation");
    const resultConfig = buttonsConfig;
    if ("default" !== buttonsLocation) {
      const position3 = splitPair(buttonsLocation);
      each(resultConfig, (_, element) => {
        extend(element, {
          toolbar: position3[0],
          location: position3[1]
        });
      });
    }
    return resultConfig;
  },
  _applyButtonHandler() {
    this.close();
    this.option("focusStateEnabled") && this.focus();
  },
  _cancelButtonHandler() {
    this.close();
    this.option("focusStateEnabled") && this.focus();
  },
  _popupOptionChanged(args) {
    const options2 = ui_widget_default.getOptionsFromContainer(args);
    this._setPopupOption(options2);
    const optionsKeys = Object.keys(options2);
    if (optionsKeys.includes("width") || optionsKeys.includes("height")) {
      this._dimensionChanged();
    }
  },
  _renderSubmitElement() {
    if (this.option("useHiddenSubmitElement")) {
      this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    }
  },
  _setSubmitValue() {
    this._getSubmitElement().val(this.option("value"));
  },
  _getSubmitElement() {
    if (this.option("useHiddenSubmitElement")) {
      return this._$submitElement;
    }
    return this.callBase();
  },
  _dispose() {
    this._detachFocusOutEvents();
    this.callBase();
  },
  _optionChanged(args) {
    var _this$_popup;
    switch (args.name) {
      case "width":
      case "height":
        this.callBase(args);
        null === (_this$_popup = this._popup) || void 0 === _this$_popup || _this$_popup.repaint();
        break;
      case "opened":
        this._renderOpenedState();
        break;
      case "onOpened":
      case "onClosed":
        this._initVisibilityActions();
        break;
      case "onPopupInitialized":
        this._initPopupInitializedAction();
        break;
      case "fieldTemplate":
      case "acceptCustomValue":
      case "openOnFieldClick":
        this._invalidate();
        break;
      case "dropDownButtonTemplate":
      case "showDropDownButton":
        this._updateButtons(["dropDown"]);
        break;
      case "dropDownOptions":
        this._popupOptionChanged(args);
        this._options.cache("dropDownOptions", this.option("dropDownOptions"));
        break;
      case "popupPosition":
        break;
      case "deferRendering":
        if (hasWindow()) {
          this._createPopup();
        }
        break;
      case "applyValueMode":
      case "applyButtonText":
      case "cancelButtonText":
      case "buttonsLocation":
        this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
        break;
      case "useHiddenSubmitElement":
        if (this._$submitElement) {
          this._$submitElement.remove();
          this._$submitElement = void 0;
        }
        this._renderSubmitElement();
        break;
      case "rtlEnabled":
        this._updatePopupPosition(args.value);
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  },
  open() {
    this.option("opened", true);
  },
  close() {
    this.option("opened", false);
  },
  field() {
    return getPublicElement(this._input());
  },
  content() {
    return this._popup ? this._popup.content() : null;
  }
});
component_registrator_default("dxDropDownEditor", DropDownEditor);
var m_drop_down_editor_default = DropDownEditor;

// ../../../../../../node_modules/devextreme/esm/events/swipe.js
var SWIPE_START_EVENT = "dxswipestart";
var SWIPE_EVENT = "dxswipe";
var SWIPE_END_EVENT = "dxswipeend";
var HorizontalStrategy = {
  defaultItemSizeFunc: function() {
    return getWidth(this.getElement());
  },
  getBounds: function() {
    return [this._maxLeftOffset, this._maxRightOffset];
  },
  calcOffsetRatio: function(e) {
    const endEventData = eventData(e);
    return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe: function(e) {
    const endEventData = eventData(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time;
  }
};
var VerticalStrategy = {
  defaultItemSizeFunc: function() {
    return getHeight(this.getElement());
  },
  getBounds: function() {
    return [this._maxTopOffset, this._maxBottomOffset];
  },
  calcOffsetRatio: function(e) {
    const endEventData = eventData(e);
    return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe: function(e) {
    const endEventData = eventData(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time;
  }
};
var STRATEGIES = {
  horizontal: HorizontalStrategy,
  vertical: VerticalStrategy
};
var SwipeEmitter = emitter_gesture_default.inherit({
  TICK_INTERVAL: 300,
  FAST_SWIPE_SPEED_LIMIT: 10,
  ctor: function(element) {
    this.callBase(element);
    this.direction = "horizontal";
    this.elastic = true;
  },
  _getStrategy: function() {
    return STRATEGIES[this.direction];
  },
  _defaultItemSizeFunc: function() {
    return this._getStrategy().defaultItemSizeFunc.call(this);
  },
  _itemSizeFunc: function() {
    return this.itemSizeFunc || this._defaultItemSizeFunc;
  },
  _init: function(e) {
    this._tickData = eventData(e);
  },
  _start: function(e) {
    this._savedEventData = eventData(e);
    e = this._fireEvent("dxswipestart", e);
    if (!e.cancel) {
      this._maxLeftOffset = e.maxLeftOffset;
      this._maxRightOffset = e.maxRightOffset;
      this._maxTopOffset = e.maxTopOffset;
      this._maxBottomOffset = e.maxBottomOffset;
    }
  },
  _move: function(e) {
    const strategy4 = this._getStrategy();
    const moveEventData = eventData(e);
    let offset2 = strategy4.calcOffsetRatio.call(this, e);
    offset2 = this._fitOffset(offset2, this.elastic);
    if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
      this._tickData = moveEventData;
    }
    this._fireEvent("dxswipe", e, {
      offset: offset2
    });
    if (false !== e.cancelable) {
      e.preventDefault();
    }
  },
  _end: function(e) {
    const strategy4 = this._getStrategy();
    const offsetRatio = strategy4.calcOffsetRatio.call(this, e);
    const isFast = strategy4.isFastSwipe.call(this, e);
    let startOffset = offsetRatio;
    let targetOffset = this._calcTargetOffset(offsetRatio, isFast);
    startOffset = this._fitOffset(startOffset, this.elastic);
    targetOffset = this._fitOffset(targetOffset, false);
    this._fireEvent("dxswipeend", e, {
      offset: startOffset,
      targetOffset
    });
  },
  _fitOffset: function(offset2, elastic) {
    const strategy4 = this._getStrategy();
    const bounds = strategy4.getBounds.call(this);
    if (offset2 < -bounds[0]) {
      return elastic ? (-2 * bounds[0] + offset2) / 3 : -bounds[0];
    }
    if (offset2 > bounds[1]) {
      return elastic ? (2 * bounds[1] + offset2) / 3 : bounds[1];
    }
    return offset2;
  },
  _calcTargetOffset: function(offsetRatio, isFast) {
    let result2;
    if (isFast) {
      result2 = Math.ceil(Math.abs(offsetRatio));
      if (offsetRatio < 0) {
        result2 = -result2;
      }
    } else {
      result2 = Math.round(offsetRatio);
    }
    return result2;
  }
});
emitter_registrator_default({
  emitter: SwipeEmitter,
  events: ["dxswipestart", "dxswipe", "dxswipeend"]
});

// ../../../../../../node_modules/devextreme/esm/events/gesture/swipeable.js
var DX_SWIPEABLE = "dxSwipeable";
var ACTION_TO_EVENT_MAP = {
  onStart: SWIPE_START_EVENT,
  onUpdated: SWIPE_EVENT,
  onEnd: SWIPE_END_EVENT,
  onCancel: "dxswipecancel"
};
var Swipeable = dom_component_default.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      elastic: true,
      immediate: false,
      immediateTimeout: 180,
      direction: "horizontal",
      itemSizeFunc: null,
      onStart: null,
      onUpdated: null,
      onEnd: null,
      onCancel: null
    });
  },
  _render: function() {
    this.callBase();
    this.$element().addClass("dx-swipeable");
    this._attachEventHandlers();
  },
  _attachEventHandlers: function() {
    this._detachEventHandlers();
    if (this.option("disabled")) {
      return;
    }
    const NAME = this.NAME;
    this._createEventData();
    each(ACTION_TO_EVENT_MAP, (function(actionName, eventName) {
      const action = this._createActionByOption(actionName, {
        context: this
      });
      eventName = addNamespace2(eventName, NAME);
      events_engine_default.on(this.$element(), eventName, this._eventData, function(e) {
        return action({
          event: e
        });
      });
    }).bind(this));
  },
  _createEventData: function() {
    this._eventData = {
      elastic: this.option("elastic"),
      itemSizeFunc: this.option("itemSizeFunc"),
      direction: this.option("direction"),
      immediate: this.option("immediate"),
      immediateTimeout: this.option("immediateTimeout")
    };
  },
  _detachEventHandlers: function() {
    events_engine_default.off(this.$element(), ".dxSwipeable");
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "disabled":
      case "onStart":
      case "onUpdated":
      case "onEnd":
      case "onCancel":
      case "elastic":
      case "immediate":
      case "itemSizeFunc":
      case "direction":
        this._detachEventHandlers();
        this._attachEventHandlers();
        break;
      case "rtlEnabled":
        break;
      default:
        this.callBase(args);
    }
  },
  _useTemplates: function() {
    return false;
  }
});
getName(Swipeable, DX_SWIPEABLE);
var swipeable_default = Swipeable;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.selection.strategy.js
var CalendarSelectionStrategy = class {
  constructor(component) {
    this.calendar = component;
  }
  dateOption(optionName) {
    return this.calendar._dateOption(optionName);
  }
  dateValue(value2, e) {
    this.calendar._dateValue(value2, e);
  }
  skipNavigate() {
    this.calendar._skipNavigate = true;
  }
  updateAriaSelected(value2, previousValue) {
    this.calendar._updateAriaSelected(value2, previousValue);
    if (value2[0] && this.calendar.option("currentDate").getTime() === value2[0].getTime()) {
      this.calendar._updateAriaId(value2[0]);
    }
  }
  processValueChanged(value2, previousValue) {
    var _value, _previousValue;
    if (isDefined(value2) && !Array.isArray(value2)) {
      value2 = [value2];
    }
    if (isDefined(previousValue) && !Array.isArray(previousValue)) {
      previousValue = [previousValue];
    }
    value2 = (null === (_value = value2) || void 0 === _value ? void 0 : _value.map((item) => this._convertToDate(item))) || [];
    previousValue = (null === (_previousValue = previousValue) || void 0 === _previousValue ? void 0 : _previousValue.map((item) => this._convertToDate(item))) || [];
    this._updateViewsValue(value2);
    this.updateAriaSelected(value2, previousValue);
    if (!this._currentDateChanged) {
      this.calendar._initCurrentDate();
    }
    this._currentDateChanged = false;
  }
  _isDateDisabled(date) {
    const min = this.calendar._dateOption("min");
    const max = this.calendar._dateOption("max");
    const isLessThanMin = isDefined(min) && date < min && !date_default.sameDate(min, date);
    const isBiggerThanMax = isDefined(max) && date > max && !date_default.sameDate(max, date);
    return this.calendar._view.isDateDisabled(date) || isLessThanMin || isBiggerThanMax;
  }
  _getLowestDateInArray(dates) {
    if (dates.length) {
      return new Date(Math.min(...dates));
    }
  }
  _convertToDate(value2) {
    return this.calendar._convertToDate(value2);
  }
  _isMaxZoomLevel() {
    return this.calendar._isMaxZoomLevel();
  }
  _updateViewsOption(optionName, optionValue) {
    this.calendar._updateViewsOption(optionName, optionValue);
  }
  _updateViewsValue(value2) {
    this._updateViewsOption("value", value2);
  }
  _updateCurrentDate(value2) {
    this.calendar.option("currentDate", value2 ?? /* @__PURE__ */ new Date());
  }
  _shouldHandleWeekNumberClick() {
    const {
      selectionMode,
      selectWeekOnClick
    } = this.calendar.option();
    return selectWeekOnClick && "single" !== selectionMode;
  }
};
var m_calendar_selection_strategy_default = CalendarSelectionStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.multiple.selection.strategy.js
var CalendarMultiSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "MultiSelection";
  }
  getViewOptions() {
    return {
      value: this.dateOption("value"),
      range: [],
      selectionMode: "multiple",
      onWeekNumberClick: this._shouldHandleWeekNumberClick() ? this._weekNumberClickHandler.bind(this) : null
    };
  }
  selectValue(selectedValue, e) {
    const value2 = [...this.dateOption("value")];
    const alreadySelectedIndex = value2.findIndex((date) => (null === date || void 0 === date ? void 0 : date.toDateString()) === selectedValue.toDateString());
    if (alreadySelectedIndex > -1) {
      value2.splice(alreadySelectedIndex, 1);
    } else {
      value2.push(selectedValue);
    }
    this.skipNavigate();
    this._updateCurrentDate(selectedValue);
    this._currentDateChanged = true;
    this.dateValue(value2, e);
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = this.dateOption("value"));
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  getDefaultCurrentDate() {
    const dates = this.dateOption("value").filter((value2) => value2);
    return this._getLowestDateInArray(dates);
  }
  restoreValue() {
    this.calendar.option("value", []);
  }
  _weekNumberClickHandler(_ref) {
    let {
      rowDates,
      event
    } = _ref;
    const selectedDates = rowDates.filter((date) => !this._isDateDisabled(date));
    this.dateValue(selectedDates, event);
  }
};
var m_calendar_multiple_selection_strategy_default = CalendarMultiSelectionStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.navigator.js
var Navigator = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      onClick: void 0,
      onCaptionClick: void 0,
      type: "normal",
      stylingMode: "outlined",
      text: ""
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => isMaterial(),
      options: {
        type: "default",
        stylingMode: "text"
      }
    }, {
      device: () => isFluent(),
      options: {
        type: "normal",
        stylingMode: "text"
      }
    }]);
  }
  _init() {
    super._init();
    this._initActions();
  }
  _initActions() {
    this._clickAction = this._createActionByOption("onClick");
    this._captionClickAction = this._createActionByOption("onCaptionClick");
  }
  _initMarkup() {
    super._initMarkup();
    renderer_default(this.element()).addClass("dx-calendar-navigator");
    this._renderButtons();
    this._renderCaption();
  }
  _renderButtons() {
    const {
      rtlEnabled,
      type: type2,
      stylingMode,
      focusStateEnabled
    } = this.option();
    this._prevButton = this._createComponent(renderer_default("<div>"), button_default, {
      focusStateEnabled,
      icon: rtlEnabled ? "chevronright" : "chevronleft",
      onClick: (e) => {
        this._clickAction({
          direction: -1,
          event: e
        });
      },
      type: type2,
      stylingMode,
      integrationOptions: {}
    });
    const $prevButton = renderer_default(this._prevButton.element()).addClass("dx-calendar-navigator-previous-view").addClass("dx-calendar-navigator-previous-month");
    this._nextButton = this._createComponent(renderer_default("<div>"), button_default, {
      focusStateEnabled,
      icon: rtlEnabled ? "chevronleft" : "chevronright",
      onClick: (e) => {
        this._clickAction({
          direction: 1,
          event: e
        });
      },
      type: type2,
      stylingMode,
      integrationOptions: {}
    });
    const $nextButton = renderer_default(this._nextButton.element()).addClass("dx-calendar-navigator-next-view").addClass("dx-calendar-navigator-next-month");
    this._caption = this._createComponent(renderer_default("<div>").addClass("dx-calendar-caption-button"), button_default, {
      focusStateEnabled,
      onClick: (e) => {
        this._captionClickAction({
          event: e
        });
      },
      type: type2,
      stylingMode,
      template: (_, content) => {
        const {
          text
        } = this.option();
        const viewCaptionTexts = text.split(" - ");
        viewCaptionTexts.forEach((captionText) => {
          renderer_default(content).append(renderer_default("<span>").addClass("dx-button-text").text(captionText));
        });
      },
      integrationOptions: {}
    });
    const $caption = this._caption.$element();
    this.$element().append($prevButton, $caption, $nextButton);
  }
  _renderCaption() {
    var _this$_caption;
    null === (_this$_caption = this._caption) || void 0 === _this$_caption || _this$_caption.option("text", this.option("text"));
  }
  toggleButton(buttonPrefix, value2) {
    const buttonName = `_${buttonPrefix}Button`;
    const button = this[buttonName];
    if (button) {
      button.option("disabled", value2);
      button.$element().toggleClass("dx-calendar-disabled-navigator-link", value2);
    }
  }
  _optionChanged(args) {
    if ("text" === args.name) {
      this._renderCaption();
    } else {
      super._optionChanged(args);
    }
  }
};
var m_calendar_navigator_default = Navigator;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.range.selection.strategy.js
var CalendarRangeSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "RangeSelection";
  }
  getViewOptions() {
    const value2 = this._getValue();
    const range2 = this._getDaysInRange(value2[0], value2[1]);
    return {
      value: value2,
      range: range2,
      selectionMode: "range",
      onCellHover: this._cellHoverHandler.bind(this),
      onWeekNumberClick: this._shouldHandleWeekNumberClick() ? this._weekNumberClickHandler.bind(this) : null
    };
  }
  selectValue(selectedValue, e) {
    const [startDate, endDate] = this._getValue();
    this.skipNavigate();
    this._updateCurrentDate(selectedValue);
    this._currentDateChanged = true;
    if (true === this.calendar.option("_allowChangeSelectionOrder")) {
      this.calendar._valueSelected = true;
      if ("startDate" === this.calendar.option("_currentSelection")) {
        if (this.calendar._convertToDate(selectedValue) > this.calendar._convertToDate(endDate)) {
          this.dateValue([selectedValue, null], e);
        } else {
          this.dateValue([selectedValue, endDate], e);
        }
      } else if (this.calendar._convertToDate(selectedValue) >= this.calendar._convertToDate(startDate)) {
        this.dateValue([startDate, selectedValue], e);
      } else {
        this.dateValue([selectedValue, null], e);
      }
    } else if (!startDate || endDate) {
      this.dateValue([selectedValue, null], e);
    } else {
      this.dateValue(startDate < selectedValue ? [startDate, selectedValue] : [selectedValue, startDate], e);
    }
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = this._getValue());
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  processValueChanged(value2, previousValue) {
    super.processValueChanged(value2, previousValue);
    const range2 = this._getRange();
    this._updateViewsOption("range", range2);
  }
  getDefaultCurrentDate() {
    const {
      _allowChangeSelectionOrder,
      _currentSelection
    } = this.calendar.option();
    const value2 = this.dateOption("value");
    if (_allowChangeSelectionOrder) {
      if ("startDate" === _currentSelection && value2[0]) {
        return value2[0];
      }
      if ("endDate" === _currentSelection && value2[1]) {
        return value2[1];
      }
    }
    const dates = value2.filter((value3) => value3);
    return this._getLowestDateInArray(dates);
  }
  restoreValue() {
    this.calendar.option("value", [null, null]);
  }
  _getValue() {
    const value2 = this.dateOption("value");
    if (!value2.length) {
      return value2;
    }
    let [startDate, endDate] = value2;
    if (startDate && endDate && startDate > endDate) {
      [startDate, endDate] = [endDate, startDate];
    }
    return [startDate, endDate];
  }
  _getRange() {
    const [startDate, endDate] = this._getValue();
    return this._getDaysInRange(startDate, endDate);
  }
  _getDaysInRange(startDate, endDate) {
    if (!startDate || !endDate) {
      return [];
    }
    const {
      currentDate,
      viewsCount
    } = this.calendar.option();
    const isAdditionalViewDate = this.calendar._isAdditionalViewDate(currentDate);
    const firstDateInViews = date_default.getFirstMonthDate(date_default.addDateInterval(currentDate, "month", isAdditionalViewDate ? -2 : -1));
    const lastDateInViews = date_default.getLastMonthDate(date_default.addDateInterval(currentDate, "month", isAdditionalViewDate ? 1 : viewsCount));
    const rangeStartDate = new Date(Math.max(firstDateInViews, startDate));
    const rangeEndDate = new Date(Math.min(lastDateInViews, endDate));
    return [...date_default.getDatesOfInterval(rangeStartDate, rangeEndDate, 864e5), rangeEndDate];
  }
  _cellHoverHandler(e) {
    const isMaxZoomLevel = this._isMaxZoomLevel();
    const [startDate, endDate] = this._getValue();
    const {
      _allowChangeSelectionOrder,
      _currentSelection
    } = this.calendar.option();
    if (isMaxZoomLevel) {
      const skipHoveredRange = _allowChangeSelectionOrder && "startDate" === _currentSelection;
      if (startDate && !endDate && !skipHoveredRange) {
        if (e.value > startDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(startDate, e.value));
          return;
        }
      } else if (!startDate && endDate && !(_allowChangeSelectionOrder && "endDate" === _currentSelection)) {
        if (e.value < endDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(e.value, endDate));
          return;
        }
      } else if (startDate && endDate) {
        if ("startDate" === _currentSelection && e.value < startDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(e.value, startDate));
          return;
        }
        if ("endDate" === _currentSelection && e.value > endDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(endDate, e.value));
          return;
        }
      }
      this._updateViewsOption("hoveredRange", []);
    }
  }
  _weekNumberClickHandler(_ref) {
    let {
      rowDates,
      event
    } = _ref;
    const selectedDates = rowDates.filter((date) => !this._isDateDisabled(date));
    const value2 = selectedDates.length ? [selectedDates[0], selectedDates[selectedDates.length - 1]] : [null, null];
    this.dateValue(value2, event);
  }
};
var m_calendar_range_selection_strategy_default = CalendarRangeSelectionStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.single.selection.strategy.js
var CalendarSingleSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "SingleSelection";
  }
  getViewOptions() {
    return {
      value: this.dateOption("value"),
      range: [],
      selectionMode: "single"
    };
  }
  selectValue(selectedValue, e) {
    this.skipNavigate();
    this.dateValue(selectedValue, e);
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = [this.dateOption("value")]);
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  getDefaultCurrentDate() {
    return this.dateOption("value");
  }
  restoreValue() {
    this.calendar.option("value", null);
  }
  _updateViewsValue(value2) {
    this._updateViewsOption("value", value2[0]);
  }
};
var m_calendar_single_selection_strategy_default = CalendarSingleSelectionStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.base_view.js
var {
  abstract: abstract6
} = ui_widget_default;
var NOT_WEEK_CELL_SELECTOR = "td:not(.dx-calendar-week-number-cell)";
var CALENDAR_DXCLICK_EVENT_NAME = addNamespace2(CLICK_EVENT_NAME, "dxCalendar");
var CALENDAR_DXHOVERSTART_EVENT_NAME = addNamespace2(HOVERSTART, "dxCalendar");
var CURRENT_DATE_TEXT = {
  month: message_default.format("dxCalendar-currentDay"),
  year: message_default.format("dxCalendar-currentMonth"),
  decade: message_default.format("dxCalendar-currentYear"),
  century: message_default.format("dxCalendar-currentYearRange")
};
var SELECTION_MODE = {
  single: "single",
  multiple: "multiple",
  range: "range"
};
var BaseView = ui_widget_default.inherit({
  _getViewName: () => "base",
  _getDefaultOptions() {
    return extend(this.callBase(), {
      date: /* @__PURE__ */ new Date(),
      focusStateEnabled: false,
      cellTemplate: null,
      disabledDates: null,
      onCellClick: null,
      onCellHover: null,
      onWeekNumberClick: null,
      rowCount: 3,
      colCount: 4,
      allowValueSelection: true,
      _todayDate: () => /* @__PURE__ */ new Date()
    });
  },
  _initMarkup() {
    this.callBase();
    this._renderImpl();
  },
  _renderImpl() {
    this.$element().append(this._createTable());
    this._createDisabledDatesHandler();
    this._renderBody();
    this._renderContouredDate();
    this._renderValue();
    this._renderRange();
    this._renderEvents();
    this._updateTableAriaLabel();
  },
  _getLocalizedWidgetName() {
    const localizedWidgetName = message_default.format("dxCalendar-ariaWidgetName");
    return localizedWidgetName;
  },
  _getSingleModeAriaLabel() {
    const {
      value: value2
    } = this.option();
    const localizedWidgetName = this._getLocalizedWidgetName();
    const formattedDate = date_default3.format(value2, "date");
    const selectedDatesText = message_default.format("dxCalendar-selectedDate", formattedDate);
    const ariaLabel = `${localizedWidgetName}. ${selectedDatesText}`;
    return ariaLabel;
  },
  _getRangeModeAriaLabel() {
    const {
      value: value2
    } = this.option();
    const localizedWidgetName = this._getLocalizedWidgetName();
    const [startDate, endDate] = value2;
    const formattedStartDate = date_default3.format(startDate, "date");
    const formattedEndDate = date_default3.format(endDate, "date");
    const selectedDatesText = startDate && endDate ? message_default.format("dxCalendar-selectedDateRange", formattedStartDate, formattedEndDate) : message_default.format("dxCalendar-selectedDate", formattedStartDate ?? formattedEndDate);
    const ariaLabel = `${localizedWidgetName}. ${selectedDatesText}`;
    return ariaLabel;
  },
  _getMultipleModeAriaLabel() {
    const ariaLabel = this._getLocalizedWidgetName();
    return ariaLabel;
  },
  _getTableAriaLabel() {
    const {
      value: value2,
      selectionMode
    } = this.option();
    const isValueEmpty = !value2 || Array.isArray(value2) && !value2.filter(Boolean).length;
    if (isValueEmpty) {
      return this._getLocalizedWidgetName();
    }
    switch (selectionMode) {
      case SELECTION_MODE.single:
        return this._getSingleModeAriaLabel();
      case SELECTION_MODE.range:
        return this._getRangeModeAriaLabel();
      case SELECTION_MODE.multiple:
        return this._getMultipleModeAriaLabel();
    }
  },
  _updateTableAriaLabel() {
    const label = this._getTableAriaLabel();
    this.setAria({
      label
    }, this._$table);
  },
  _createTable() {
    this._$table = renderer_default("<table>");
    this.setAria({
      role: "grid"
    }, this._$table);
    return this._$table;
  },
  _renderBody() {
    this.$body = renderer_default("<tbody>").appendTo(this._$table);
    const rowData = {
      cellDate: this._getFirstCellData(),
      prevCellDate: null
    };
    for (let rowIndex = 0, rowCount = this.option("rowCount"); rowIndex < rowCount; rowIndex++) {
      rowData.row = this._createRow();
      for (let colIndex = 0, colCount = this.option("colCount"); colIndex < colCount; colIndex++) {
        this._renderCell(rowData, colIndex);
      }
      this._renderWeekNumberCell(rowData);
    }
  },
  _createRow() {
    const row = dom_adapter_default.createElement("tr");
    this.setAria("role", "row", renderer_default(row));
    this.$body.get(0).appendChild(row);
    return row;
  },
  _createCell(cellDate, cellIndex) {
    const cell = dom_adapter_default.createElement("td");
    const $cell = renderer_default(cell);
    cell.className = this._getClassNameByDate(cellDate, cellIndex);
    cell.setAttribute("data-value", date_serialization_default.serializeDate(cellDate, date_default.getShortDateFormat()));
    data(cell, "dxDateValueKey", cellDate);
    this.setAria({
      role: "gridcell",
      selected: false,
      label: this.getCellAriaLabel(cellDate)
    }, $cell);
    return {
      cell,
      $cell
    };
  },
  _renderCell(params, cellIndex) {
    const {
      cellDate,
      prevCellDate,
      row
    } = params;
    if (prevCellDate) {
      date_default.fixTimezoneGap(prevCellDate, cellDate);
    }
    params.prevCellDate = cellDate;
    const {
      cell,
      $cell
    } = this._createCell(cellDate, cellIndex);
    const cellTemplate = this.option("cellTemplate");
    renderer_default(row).append(cell);
    if (cellTemplate) {
      cellTemplate.render(this._prepareCellTemplateData(cellDate, cellIndex, $cell));
    } else {
      cell.innerHTML = this._getCellText(cellDate);
    }
    params.cellDate = this._getNextCellData(cellDate);
  },
  _getClassNameByDate(cellDate, cellIndex) {
    let className = "dx-calendar-cell";
    if (this._isTodayCell(cellDate)) {
      className += " dx-calendar-today";
    }
    if (this._isDateOutOfRange(cellDate) || this.isDateDisabled(cellDate)) {
      className += " dx-calendar-empty-cell";
    }
    if (this._isOtherView(cellDate)) {
      className += " dx-calendar-other-view";
    }
    if (this.option("selectionMode") === SELECTION_MODE.range) {
      if (0 === cellIndex) {
        className += " dx-calendar-cell-start-in-row";
      }
      if (cellIndex === this.option("colCount") - 1) {
        className += " dx-calendar-cell-end-in-row";
      }
      if (this._isStartDayOfMonth(cellDate)) {
        className += " dx-calendar-cell-start";
      }
      if (this._isEndDayOfMonth(cellDate)) {
        className += " dx-calendar-cell-end";
      }
    }
    return className;
  },
  _prepareCellTemplateData(cellDate, cellIndex, $cell) {
    const isDateCell = cellDate instanceof Date;
    const text = isDateCell ? this._getCellText(cellDate) : cellDate;
    const date = isDateCell ? cellDate : void 0;
    const view = this._getViewName();
    return {
      model: {
        text,
        date,
        view
      },
      container: getPublicElement($cell),
      index: cellIndex
    };
  },
  _renderEvents() {
    this._createCellClickAction();
    events_engine_default.off(this._$table, CALENDAR_DXCLICK_EVENT_NAME);
    events_engine_default.on(this._$table, CALENDAR_DXCLICK_EVENT_NAME, NOT_WEEK_CELL_SELECTOR, (e) => {
      if (!renderer_default(e.currentTarget).hasClass("dx-calendar-empty-cell")) {
        this._cellClickAction({
          event: e,
          value: renderer_default(e.currentTarget).data("dxDateValueKey")
        });
      }
    });
    const {
      selectionMode
    } = this.option();
    events_engine_default.off(this._$table, CALENDAR_DXHOVERSTART_EVENT_NAME);
    if (selectionMode === SELECTION_MODE.range) {
      this._createCellHoverAction();
      events_engine_default.on(this._$table, CALENDAR_DXHOVERSTART_EVENT_NAME, NOT_WEEK_CELL_SELECTOR, (e) => {
        if (!renderer_default(e.currentTarget).hasClass("dx-calendar-empty-cell")) {
          this._cellHoverAction({
            event: e,
            value: renderer_default(e.currentTarget).data("dxDateValueKey")
          });
        }
      });
    }
    if (selectionMode !== SELECTION_MODE.single) {
      this._createWeekNumberCellClickAction();
      events_engine_default.on(this._$table, CALENDAR_DXCLICK_EVENT_NAME, ".dx-calendar-week-number-cell", (e) => {
        const $row = renderer_default(e.currentTarget).closest("tr");
        const firstDateInRow = $row.find(".dx-calendar-cell").first().data("dxDateValueKey");
        const lastDateInRow = $row.find(".dx-calendar-cell").last().data("dxDateValueKey");
        const rowDates = [...date_default.getDatesOfInterval(firstDateInRow, lastDateInRow, 864e5), lastDateInRow];
        this._weekNumberCellClickAction({
          event: e,
          rowDates
        });
      });
    }
  },
  _createCellClickAction() {
    this._cellClickAction = this._createActionByOption("onCellClick");
  },
  _createCellHoverAction() {
    this._cellHoverAction = this._createActionByOption("onCellHover");
  },
  _createWeekNumberCellClickAction() {
    this._weekNumberCellClickAction = this._createActionByOption("onWeekNumberClick");
  },
  _createDisabledDatesHandler() {
    const disabledDates = this.option("disabledDates");
    this._disabledDatesHandler = Array.isArray(disabledDates) ? this._getDefaultDisabledDatesHandler(disabledDates) : disabledDates || noop2;
  },
  _getDefaultDisabledDatesHandler: () => noop2,
  _isTodayCell: abstract6,
  _isDateOutOfRange: abstract6,
  isDateDisabled(cellDate) {
    const dateParts = {
      date: cellDate,
      view: this._getViewName()
    };
    return this._disabledDatesHandler(dateParts);
  },
  _isOtherView: abstract6,
  _isStartDayOfMonth: abstract6,
  _isEndDayOfMonth: abstract6,
  _getCellText: abstract6,
  _getFirstCellData: abstract6,
  _getNextCellData: abstract6,
  _renderContouredDate(contouredDate) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    contouredDate = contouredDate || this.option("contouredDate");
    const $oldContouredCell = this._getContouredCell();
    const $newContouredCell = this._getCellByDate(contouredDate);
    $oldContouredCell.removeClass("dx-calendar-contoured-date");
    if (contouredDate) {
      $newContouredCell.addClass("dx-calendar-contoured-date");
    }
  },
  _getContouredCell() {
    return this._$table.find(".dx-calendar-contoured-date");
  },
  _renderValue() {
    if (!this.option("allowValueSelection")) {
      return;
    }
    let value2 = this.option("value");
    if (!Array.isArray(value2)) {
      value2 = [value2];
    }
    this._updateSelectedClass(value2);
  },
  _updateSelectedClass(value2) {
    var _this$_$selectedCells;
    if (this._isRangeMode() && !this._isMonthView()) {
      return;
    }
    null === (_this$_$selectedCells = this._$selectedCells) || void 0 === _this$_$selectedCells || _this$_$selectedCells.forEach(($cell) => {
      $cell.removeClass("dx-calendar-selected-date");
    });
    this._$selectedCells = value2.map((value3) => this._getCellByDate(value3));
    this._$selectedCells.forEach(($cell) => {
      $cell.addClass("dx-calendar-selected-date");
    });
  },
  _renderRange() {
    var _this$_$rangeCells, _this$_$hoveredRangeC, _this$_$rangeStartHov, _this$_$rangeEndHover, _this$_$rangeStartDat, _this$_$rangeEndDateC, _this$_$rangeStartDat2, _this$_$rangeEndDateC2;
    const {
      allowValueSelection,
      value: value2,
      range: range2
    } = this.option();
    if (!allowValueSelection || !this._isRangeMode() || !this._isMonthView()) {
      return;
    }
    null === (_this$_$rangeCells = this._$rangeCells) || void 0 === _this$_$rangeCells || _this$_$rangeCells.forEach(($cell) => {
      $cell.removeClass("dx-calendar-cell-in-range");
    });
    null === (_this$_$hoveredRangeC = this._$hoveredRangeCells) || void 0 === _this$_$hoveredRangeC || _this$_$hoveredRangeC.forEach(($cell) => {
      $cell.removeClass("dx-calendar-cell-range-hover");
    });
    null === (_this$_$rangeStartHov = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov || _this$_$rangeStartHov.removeClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover || _this$_$rangeEndHover.removeClass("dx-calendar-cell-range-hover-end");
    null === (_this$_$rangeStartDat = this._$rangeStartDateCell) || void 0 === _this$_$rangeStartDat || _this$_$rangeStartDat.removeClass("dx-calendar-range-start-date");
    null === (_this$_$rangeEndDateC = this._$rangeEndDateCell) || void 0 === _this$_$rangeEndDateC || _this$_$rangeEndDateC.removeClass("dx-calendar-range-end-date");
    this._$rangeCells = range2.map((value3) => this._getCellByDate(value3));
    this._$rangeStartDateCell = this._getCellByDate(value2[0]);
    this._$rangeEndDateCell = this._getCellByDate(value2[1]);
    this._$rangeCells.forEach(($cell) => {
      $cell.addClass("dx-calendar-cell-in-range");
    });
    null === (_this$_$rangeStartDat2 = this._$rangeStartDateCell) || void 0 === _this$_$rangeStartDat2 || _this$_$rangeStartDat2.addClass("dx-calendar-range-start-date");
    null === (_this$_$rangeEndDateC2 = this._$rangeEndDateCell) || void 0 === _this$_$rangeEndDateC2 || _this$_$rangeEndDateC2.addClass("dx-calendar-range-end-date");
  },
  _renderHoveredRange() {
    var _this$_$hoveredRangeC2, _this$_$rangeStartHov2, _this$_$rangeEndHover2, _this$_$rangeStartHov3, _this$_$rangeEndHover3;
    const {
      allowValueSelection,
      hoveredRange
    } = this.option();
    if (!allowValueSelection || !this._isRangeMode() || !this._isMonthView()) {
      return;
    }
    null === (_this$_$hoveredRangeC2 = this._$hoveredRangeCells) || void 0 === _this$_$hoveredRangeC2 || _this$_$hoveredRangeC2.forEach(($cell) => {
      $cell.removeClass("dx-calendar-cell-range-hover");
    });
    null === (_this$_$rangeStartHov2 = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov2 || _this$_$rangeStartHov2.removeClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover2 = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover2 || _this$_$rangeEndHover2.removeClass("dx-calendar-cell-range-hover-end");
    this._$hoveredRangeCells = hoveredRange.map((value2) => this._getCellByDate(value2));
    this._$rangeStartHoverCell = this._getCellByDate(hoveredRange[0]);
    this._$rangeEndHoverCell = this._getCellByDate(hoveredRange[hoveredRange.length - 1]);
    this._$hoveredRangeCells.forEach(($cell) => {
      $cell.addClass("dx-calendar-cell-range-hover");
    });
    null === (_this$_$rangeStartHov3 = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov3 || _this$_$rangeStartHov3.addClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover3 = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover3 || _this$_$rangeEndHover3.addClass("dx-calendar-cell-range-hover-end");
  },
  _isMonthView() {
    return "month" === this.option("zoomLevel");
  },
  _isRangeMode() {
    return this.option("selectionMode") === SELECTION_MODE.range;
  },
  _getCurrentDateFormat: () => null,
  getCellAriaLabel(date) {
    const viewName = this._getViewName();
    const isToday = this._isTodayCell(date);
    const format2 = this._getCurrentDateFormat();
    const dateRangeText = format2 ? date_default3.format(date, format2) : this._getCellText(date);
    const ariaLabel = isToday ? `${dateRangeText}. ${CURRENT_DATE_TEXT[viewName]}` : dateRangeText;
    return ariaLabel;
  },
  _getFirstAvailableDate() {
    let date = this.option("date");
    const min = this.option("min");
    date = date_default.getViewFirstCellDate(this._getViewName(), date);
    return new Date(min && date < min ? min : date);
  },
  _getCellByDate: abstract6,
  isBoundary: abstract6,
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "value":
        this._renderValue();
        this._updateTableAriaLabel();
        break;
      case "range":
        this._renderRange();
        break;
      case "hoveredRange":
        this._renderHoveredRange();
        break;
      case "contouredDate":
        this._renderContouredDate(value2);
        break;
      case "onCellClick":
        this._createCellClickAction();
        break;
      case "onCellHover":
        this._createCellHoverAction();
        break;
      case "min":
      case "max":
      case "disabledDates":
      case "cellTemplate":
      case "selectionMode":
        this._invalidate();
        break;
      case "_todayDate":
        this._renderBody();
        break;
      default:
        this.callBase(args);
    }
  }
});
var m_calendar_base_view_default = BaseView;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.views.js
var Views = {
  month: m_calendar_base_view_default.inherit({
    _getViewName: () => "month",
    _getCurrentDateFormat: () => "longdate",
    _getDefaultOptions() {
      return extend(this.callBase(), {
        firstDayOfWeek: 0,
        rowCount: 6,
        colCount: 7
      });
    },
    _renderImpl() {
      this.callBase();
      this._renderHeader();
    },
    _renderBody() {
      this.callBase();
      this._$table.find(".dx-calendar-other-view").addClass("dx-calendar-other-month");
    },
    _renderFocusTarget: noop2,
    _renderHeader() {
      const $headerRow = renderer_default("<tr>");
      const $header = renderer_default("<thead>").append($headerRow);
      this._$table.prepend($header);
      for (let colIndex = 0, colCount = this.option("colCount"); colIndex < colCount; colIndex++) {
        this._renderHeaderCell(colIndex, $headerRow);
      }
      if (this.option("showWeekNumbers")) {
        this._renderWeekHeaderCell($headerRow);
      }
    },
    _renderHeaderCell(cellIndex, $headerRow) {
      const {
        firstDayOfWeek
      } = this.option();
      const {
        full: fullCaption,
        abbreviated: abbrCaption
      } = this._getDayCaption(firstDayOfWeek + cellIndex);
      const $cell = renderer_default("<th>").attr({
        scope: "col",
        abbr: fullCaption
      }).text(abbrCaption);
      $headerRow.append($cell);
    },
    _renderWeekHeaderCell($headerRow) {
      const $weekNumberHeaderCell = renderer_default("<th>").attr({
        scope: "col",
        abbr: "WeekNumber",
        class: "dx-week-number-header"
      });
      $headerRow.prepend($weekNumberHeaderCell);
    },
    _renderWeekNumberCell(rowData) {
      const {
        showWeekNumbers,
        cellTemplate,
        selectionMode,
        selectWeekOnClick
      } = this.option();
      if (!showWeekNumbers) {
        return;
      }
      const weekNumber = this._getWeekNumber(rowData.prevCellDate);
      const cell = dom_adapter_default.createElement("td");
      const $cell = renderer_default(cell);
      cell.className = "dx-calendar-week-number-cell";
      if ("single" !== selectionMode && selectWeekOnClick) {
        $cell.addClass("dx-calendar-week-selection");
      }
      if (cellTemplate) {
        cellTemplate.render(this._prepareCellTemplateData(weekNumber, -1, $cell));
      } else {
        cell.innerHTML = weekNumber;
      }
      rowData.row.prepend(cell);
      this.setAria({
        role: "gridcell",
        label: `Week ${weekNumber}`
      }, $cell);
    },
    _getWeekNumber(date) {
      const {
        weekNumberRule,
        firstDayOfWeek
      } = this.option();
      if ("auto" === weekNumberRule) {
        return date_default.getWeekNumber(date, firstDayOfWeek, 1 === firstDayOfWeek ? "firstFourDays" : "firstDay");
      }
      return date_default.getWeekNumber(date, firstDayOfWeek, weekNumberRule);
    },
    getNavigatorCaption() {
      return date_default3.format(this.option("date"), "monthandyear");
    },
    _isTodayCell(cellDate) {
      const today = this.option("_todayDate")();
      return date_default.sameDate(cellDate, today);
    },
    _isDateOutOfRange(cellDate) {
      const minDate = this.option("min");
      const maxDate = this.option("max");
      return !date_default.dateInRange(cellDate, minDate, maxDate, "date");
    },
    _isOtherView(cellDate) {
      return cellDate.getMonth() !== this.option("date").getMonth();
    },
    _isStartDayOfMonth(cellDate) {
      return date_default.sameDate(cellDate, date_default.getFirstMonthDate(this.option("date")));
    },
    _isEndDayOfMonth(cellDate) {
      return date_default.sameDate(cellDate, date_default.getLastMonthDate(this.option("date")));
    },
    _getCellText: (cellDate) => date_default3.format(cellDate, "d"),
    _getDayCaption(day) {
      const daysInWeek = this.option("colCount");
      const dayIndex = day % daysInWeek;
      return {
        full: date_default3.getDayNames()[dayIndex],
        abbreviated: date_default3.getDayNames("abbreviated")[dayIndex]
      };
    },
    _getFirstCellData() {
      const {
        firstDayOfWeek
      } = this.option();
      const firstDay = date_default.getFirstMonthDate(this.option("date"));
      let firstMonthDayOffset = firstDayOfWeek - firstDay.getDay();
      const daysInWeek = this.option("colCount");
      if (firstMonthDayOffset >= 0) {
        firstMonthDayOffset -= daysInWeek;
      }
      firstDay.setDate(firstDay.getDate() + firstMonthDayOffset);
      return firstDay;
    },
    _getNextCellData(date) {
      date = new Date(date);
      date.setDate(date.getDate() + 1);
      return date;
    },
    _getCellByDate(date) {
      return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(date, date_default.getShortDateFormat())}']`);
    },
    isBoundary(date) {
      return date_default.sameMonthAndYear(date, this.option("min")) || date_default.sameMonthAndYear(date, this.option("max"));
    },
    _getDefaultDisabledDatesHandler: (disabledDates) => function(args) {
      const isDisabledDate = disabledDates.some((item) => date_default.sameDate(item, args.date));
      if (isDisabledDate) {
        return true;
      }
    }
  }),
  year: m_calendar_base_view_default.inherit({
    _getViewName: () => "year",
    _getCurrentDateFormat: () => "monthandyear",
    _isTodayCell(cellDate) {
      const today = this.option("_todayDate")();
      return date_default.sameMonthAndYear(cellDate, today);
    },
    _isDateOutOfRange(cellDate) {
      return !date_default.dateInRange(cellDate, date_default.getFirstMonthDate(this.option("min")), date_default.getLastMonthDate(this.option("max")));
    },
    _isOtherView: () => false,
    _isStartDayOfMonth: () => false,
    _isEndDayOfMonth: () => false,
    _getCellText: (cellDate) => date_default3.getMonthNames("abbreviated")[cellDate.getMonth()],
    _getFirstCellData() {
      const currentDate = this.option("date");
      const data2 = new Date(currentDate);
      data2.setDate(1);
      data2.setMonth(0);
      return data2;
    },
    _getNextCellData(date) {
      date = new Date(date);
      date.setMonth(date.getMonth() + 1);
      return date;
    },
    _getCellByDate(date) {
      const foundDate = new Date(date);
      foundDate.setDate(1);
      return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default.getShortDateFormat())}']`);
    },
    getNavigatorCaption() {
      return date_default3.format(this.option("date"), "yyyy");
    },
    isBoundary(date) {
      return date_default.sameYear(date, this.option("min")) || date_default.sameYear(date, this.option("max"));
    },
    _renderWeekNumberCell: noop2
  }),
  decade: m_calendar_base_view_default.inherit({
    _getViewName: () => "decade",
    _isTodayCell(cellDate) {
      const today = this.option("_todayDate")();
      return date_default.sameYear(cellDate, today);
    },
    _isDateOutOfRange(cellDate) {
      const min = this.option("min");
      const max = this.option("max");
      return !date_default.dateInRange(cellDate.getFullYear(), min && min.getFullYear(), max && max.getFullYear());
    },
    _isOtherView(cellDate) {
      const date = new Date(cellDate);
      date.setMonth(1);
      return !date_default.sameDecade(date, this.option("date"));
    },
    _isStartDayOfMonth: () => false,
    _isEndDayOfMonth: () => false,
    _getCellText: (cellDate) => date_default3.format(cellDate, "yyyy"),
    _getFirstCellData() {
      const year = date_default.getFirstYearInDecade(this.option("date")) - 1;
      return date_default.createDateWithFullYear(year, 0, 1);
    },
    _getNextCellData(date) {
      date = new Date(date);
      date.setFullYear(date.getFullYear() + 1);
      return date;
    },
    getNavigatorCaption() {
      const currentDate = this.option("date");
      const firstYearInDecade = date_default.getFirstYearInDecade(currentDate);
      const startDate = new Date(currentDate);
      const endDate = new Date(currentDate);
      startDate.setFullYear(firstYearInDecade);
      endDate.setFullYear(firstYearInDecade + 9);
      return `${date_default3.format(startDate, "yyyy")}-${date_default3.format(endDate, "yyyy")}`;
    },
    _isValueOnCurrentView: (currentDate, value2) => date_default.sameDecade(currentDate, value2),
    _getCellByDate(date) {
      const foundDate = new Date(date);
      foundDate.setDate(1);
      foundDate.setMonth(0);
      return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default.getShortDateFormat())}']`);
    },
    isBoundary(date) {
      return date_default.sameDecade(date, this.option("min")) || date_default.sameDecade(date, this.option("max"));
    },
    _renderWeekNumberCell: noop2
  }),
  century: m_calendar_base_view_default.inherit({
    _getViewName: () => "century",
    _isTodayCell(cellDate) {
      const today = this.option("_todayDate")();
      return date_default.sameDecade(cellDate, today);
    },
    _isDateOutOfRange(cellDate) {
      const decade = date_default.getFirstYearInDecade(cellDate);
      const minDecade = date_default.getFirstYearInDecade(this.option("min"));
      const maxDecade = date_default.getFirstYearInDecade(this.option("max"));
      return !date_default.dateInRange(decade, minDecade, maxDecade);
    },
    _isOtherView(cellDate) {
      const date = new Date(cellDate);
      date.setMonth(1);
      return !date_default.sameCentury(date, this.option("date"));
    },
    _isStartDayOfMonth: () => false,
    _isEndDayOfMonth: () => false,
    _getCellText(cellDate) {
      const startDate = date_default3.format(cellDate, "yyyy");
      const endDate = new Date(cellDate);
      endDate.setFullYear(endDate.getFullYear() + 9);
      return `${startDate} - ${date_default3.format(endDate, "yyyy")}`;
    },
    _getFirstCellData() {
      const decade = date_default.getFirstDecadeInCentury(this.option("date")) - 10;
      return date_default.createDateWithFullYear(decade, 0, 1);
    },
    _getNextCellData(date) {
      date = new Date(date);
      date.setFullYear(date.getFullYear() + 10);
      return date;
    },
    _getCellByDate(date) {
      const foundDate = new Date(date);
      foundDate.setDate(1);
      foundDate.setMonth(0);
      foundDate.setFullYear(date_default.getFirstYearInDecade(foundDate));
      return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default.getShortDateFormat())}']`);
    },
    getNavigatorCaption() {
      const currentDate = this.option("date");
      const firstDecadeInCentury = date_default.getFirstDecadeInCentury(currentDate);
      const startDate = new Date(currentDate);
      const endDate = new Date(currentDate);
      startDate.setFullYear(firstDecadeInCentury);
      endDate.setFullYear(firstDecadeInCentury + 99);
      return `${date_default3.format(startDate, "yyyy")}-${date_default3.format(endDate, "yyyy")}`;
    },
    isBoundary(date) {
      return date_default.sameCentury(date, this.option("min")) || date_default.sameCentury(date, this.option("max"));
    },
    _renderWeekNumberCell: noop2
  })
};
var m_calendar_views_default = Views;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.js
var CALENDAR_DXHOVEREND_EVENT_NAME = addNamespace2(HOVEREND, "dxCalendar");
var LEVEL_COMPARE_MAP = {
  month: 3,
  year: 2,
  decade: 1,
  century: 0
};
var ZOOM_LEVEL = {
  MONTH: "month",
  YEAR: "year",
  DECADE: "decade",
  CENTURY: "century"
};
var SELECTION_STRATEGIES = {
  SingleSelection: m_calendar_single_selection_strategy_default,
  MultipleSelection: m_calendar_multiple_selection_strategy_default,
  RangeSelection: m_calendar_range_selection_strategy_default
};
var Calendar = editor_default.inherit({
  _activeStateUnit: ".dx-calendar-cell",
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      currentDate: /* @__PURE__ */ new Date(),
      value: null,
      dateSerializationFormat: void 0,
      min: new Date(1e3, 0),
      max: new Date(3e3, 0),
      firstDayOfWeek: void 0,
      viewsCount: 1,
      zoomLevel: ZOOM_LEVEL.MONTH,
      maxZoomLevel: ZOOM_LEVEL.MONTH,
      minZoomLevel: ZOOM_LEVEL.CENTURY,
      selectionMode: "single",
      selectWeekOnClick: true,
      showTodayButton: false,
      showWeekNumbers: false,
      weekNumberRule: "auto",
      cellTemplate: "cell",
      disabledDates: null,
      onCellClick: null,
      onContouredChanged: null,
      skipFocusCheck: false,
      _todayDate: () => /* @__PURE__ */ new Date()
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  },
  _supportedKeys() {
    return extend(this.callBase(), {
      rightArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._waitRenderView(1);
        } else {
          this._moveCurrentDateByOffset(1 * this._getRtlCorrection());
        }
      },
      leftArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._waitRenderView(-1);
        } else {
          this._moveCurrentDateByOffset(-1 * this._getRtlCorrection());
        }
      },
      upArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._navigateUp();
        } else {
          if (fx_default.isAnimating(this._view.$element())) {
            return;
          }
          this._moveCurrentDateByOffset(-1 * this._view.option("colCount"));
        }
      },
      downArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._navigateDown();
        } else {
          if (fx_default.isAnimating(this._view.$element())) {
            return;
          }
          this._moveCurrentDateByOffset(1 * this._view.option("colCount"));
        }
      },
      home(e) {
        e.preventDefault();
        const zoomLevel = this.option("zoomLevel");
        const currentDate = this.option("currentDate");
        const min = this._dateOption("min");
        if (this._view.isDateDisabled(currentDate)) {
          return;
        }
        const date = date_default.sameView(zoomLevel, currentDate, min) ? min : date_default.getViewFirstCellDate(zoomLevel, currentDate);
        this._moveToClosestAvailableDate(date);
      },
      end(e) {
        e.preventDefault();
        const zoomLevel = this.option("zoomLevel");
        const currentDate = this.option("currentDate");
        const max = this._dateOption("max");
        if (this._view.isDateDisabled(currentDate)) {
          return;
        }
        const date = date_default.sameView(zoomLevel, currentDate, max) ? max : date_default.getViewLastCellDate(zoomLevel, currentDate);
        this._moveToClosestAvailableDate(date);
      },
      pageUp(e) {
        e.preventDefault();
        this._waitRenderView(-1 * this._getRtlCorrection());
      },
      pageDown(e) {
        e.preventDefault();
        this._waitRenderView(1 * this._getRtlCorrection());
      },
      tab: noop2,
      enter: this._enterKeyHandler
    });
  },
  _enterKeyHandler(e) {
    if (!this._isMaxZoomLevel()) {
      this._navigateDown();
    } else if (!this._view.isDateDisabled(this.option("currentDate"))) {
      const value2 = this._updateTimeComponent(this.option("currentDate"));
      this._selectionStrategy.selectValue(value2, e);
    }
  },
  _getSerializationFormat(optionName) {
    const value2 = this.option(optionName || "value");
    if (this.option("dateSerializationFormat")) {
      return this.option("dateSerializationFormat");
    }
    if (isNumeric(value2)) {
      return "number";
    }
    if (!isString(value2)) {
      return;
    }
    return date_serialization_default.getDateSerializationFormat(value2);
  },
  _convertToDate: (value2) => date_serialization_default.deserializeDate(value2),
  _dateValue(value2, event) {
    if (event) {
      if ("keydown" === event.type) {
        const cellElement = this._view._getContouredCell().get(0);
        event.target = cellElement;
      }
      this._saveValueChangeEvent(event);
    }
    this._dateOption("value", value2);
  },
  _dateOption(optionName, optionValue) {
    const isArray3 = "value" === optionName && !this._isSingleMode();
    const value2 = this.option("value");
    if (1 === arguments.length) {
      return isArray3 ? (value2 ?? []).map((value3) => this._convertToDate(value3)) : this._convertToDate(this.option(optionName));
    }
    const serializationFormat = this._getSerializationFormat(optionName);
    const serializedValue = isArray3 ? (null === optionValue || void 0 === optionValue ? void 0 : optionValue.map((value3) => date_serialization_default.serializeDate(value3, serializationFormat))) || [] : date_serialization_default.serializeDate(optionValue, serializationFormat);
    this.option(optionName, serializedValue);
  },
  _isSingleMode() {
    return "single" === this.option("selectionMode");
  },
  _shiftDate(zoomLevel, date, offset2, reverse) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        date.setDate(date.getDate() + offset2 * reverse);
        break;
      case ZOOM_LEVEL.YEAR:
        date.setMonth(date.getMonth() + offset2 * reverse);
        break;
      case ZOOM_LEVEL.DECADE:
        date.setFullYear(date.getFullYear() + offset2 * reverse);
        break;
      case ZOOM_LEVEL.CENTURY:
        date.setFullYear(date.getFullYear() + 10 * offset2 * reverse);
    }
  },
  _moveCurrentDateByOffset(offset2) {
    const baseDate = this.option("currentDate");
    let currentDate = new Date(baseDate);
    const zoomLevel = this.option("zoomLevel");
    this._shiftDate(zoomLevel, currentDate, offset2, 1);
    const maxDate = this._getMaxDate();
    const minDate = this._getMinDate();
    let isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, currentDate, baseDate);
    let isDateForwardInRange = inRange(currentDate, minDate, maxDate) && isDateForwardInNeighborView;
    const dateForward = new Date(currentDate);
    while (isDateForwardInRange) {
      if (!this._view.isDateDisabled(dateForward)) {
        currentDate = dateForward;
        break;
      }
      this._shiftDate(zoomLevel, dateForward, offset2, 1);
      isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, dateForward, baseDate);
      isDateForwardInRange = inRange(dateForward, minDate, maxDate) && isDateForwardInNeighborView;
    }
    if (this._view.isDateDisabled(baseDate) || this._view.isDateDisabled(currentDate)) {
      const direction = offset2 > 0 ? 1 : -1;
      const isViewDisabled = 1 === direction ? this._isNextViewDisabled() : this._isPrevViewDisabled();
      if (!isViewDisabled) {
        this._waitRenderView(direction);
      } else {
        this._moveToClosestAvailableDate(currentDate);
      }
    } else {
      this._skipNavigate = true;
      this.option("currentDate", currentDate);
    }
  },
  _isNextViewDisabled() {
    return this._navigator._nextButton.option("disabled");
  },
  _isPrevViewDisabled() {
    return this._navigator._prevButton.option("disabled");
  },
  _areDatesInSameView(zoomLevel, date1, date2) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        return date1.getMonth() === date2.getMonth();
      case ZOOM_LEVEL.YEAR:
        return date1.getYear() === date2.getYear();
      case ZOOM_LEVEL.DECADE:
        return parseInt(date1.getYear() / 10) === parseInt(date2.getYear() / 10);
      case ZOOM_LEVEL.CENTURY:
        return parseInt(date1.getYear() / 100) === parseInt(date2.getYear() / 100);
    }
  },
  _areDatesInNeighborView(zoomLevel, date1, date2) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        return ((a, b) => {
          const abs3 = Math.abs(a - b);
          return Math.min(abs3, 12 - abs3);
        })(date1.getMonth(), date2.getMonth()) <= 1;
      case ZOOM_LEVEL.YEAR:
        return Math.abs(date1.getYear() - date2.getYear()) <= 1;
      case ZOOM_LEVEL.DECADE:
        return Math.abs(date1.getYear() - date2.getYear()) <= 10;
      case ZOOM_LEVEL.CENTURY:
        return Math.abs(date1.getYear() - date2.getYear()) <= 100;
    }
  },
  _moveToClosestAvailableDate() {
    let baseDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.option("currentDate");
    let currentDate = new Date(baseDate);
    const zoomLevel = this.option("zoomLevel");
    const isCurrentDateAvailable = !this._isDateNotAvailable(currentDate);
    let isDateForwardAvailable = isCurrentDateAvailable;
    let isDateBackwardAvailable = isCurrentDateAvailable;
    let isDateForwardInStartView;
    let isDateBackwardInStartView;
    const dateForward = new Date(currentDate);
    const dateBackward = new Date(currentDate);
    do {
      if (isDateForwardAvailable) {
        currentDate = dateForward;
        break;
      }
      if (isDateBackwardAvailable) {
        currentDate = dateBackward;
        break;
      }
      this._shiftDate(zoomLevel, dateForward, 1, 1);
      this._shiftDate(zoomLevel, dateBackward, 1, -1);
      isDateForwardInStartView = this._areDatesInSameView(zoomLevel, dateForward, baseDate);
      isDateBackwardInStartView = this._areDatesInSameView(zoomLevel, dateBackward, baseDate);
      isDateForwardAvailable = isDateForwardInStartView && !this._isDateNotAvailable(dateForward);
      isDateBackwardAvailable = isDateBackwardInStartView && !this._isDateNotAvailable(dateBackward);
    } while (isDateForwardInStartView || isDateBackwardInStartView);
    this.option("currentDate", currentDate);
  },
  _isDateNotAvailable(date) {
    const maxDate = this._getMaxDate();
    const minDate = this._getMinDate();
    return !inRange(date, minDate, maxDate) || this._view.isDateDisabled(date);
  },
  _init() {
    this.callBase();
    this._initSelectionStrategy();
    this._correctZoomLevel();
    this._initCurrentDate();
    this._initActions();
  },
  _initSelectionStrategy() {
    const strategyName = this._getSelectionStrategyName();
    const strategy4 = SELECTION_STRATEGIES[strategyName];
    if (!this._selectionStrategy || this._selectionStrategy.NAME !== strategyName) {
      this._selectionStrategy = new strategy4(this);
    }
  },
  _refreshSelectionStrategy() {
    this._initSelectionStrategy();
    this._selectionStrategy.restoreValue();
    this._refresh();
  },
  _getSelectionStrategyName() {
    const selectionMode = this.option("selectionMode");
    switch (selectionMode) {
      case "multiple":
        return "MultipleSelection";
      case "range":
        return "RangeSelection";
      default:
        return "SingleSelection";
    }
  },
  _correctZoomLevel() {
    const minZoomLevel = this.option("minZoomLevel");
    const maxZoomLevel = this.option("maxZoomLevel");
    const zoomLevel = this.option("zoomLevel");
    if (LEVEL_COMPARE_MAP[maxZoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
      return;
    }
    if (LEVEL_COMPARE_MAP[zoomLevel] > LEVEL_COMPARE_MAP[maxZoomLevel]) {
      this.option("zoomLevel", maxZoomLevel);
    } else if (LEVEL_COMPARE_MAP[zoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
      this.option("zoomLevel", minZoomLevel);
    }
  },
  _initCurrentDate() {
    const currentDate = this._getNormalizedDate(this._selectionStrategy.getDefaultCurrentDate()) ?? this._getNormalizedDate(this.option("currentDate"));
    this.option("currentDate", currentDate);
  },
  _getNormalizedDate(date) {
    date = date_default.normalizeDate(date, this._getMinDate(), this._getMaxDate());
    return isDefined(date) ? this._getDate(date) : date;
  },
  _initActions() {
    this._cellClickAction = this._createActionByOption("onCellClick");
    this._onContouredChanged = this._createActionByOption("onContouredChanged");
  },
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      cell: new FunctionTemplate((options2) => {
        const data2 = options2.model;
        renderer_default(options2.container).append(renderer_default("<span>").text(data2 && data2.text || String(data2)));
      })
    });
    this.callBase();
  },
  _updateCurrentDate(date) {
    if (fx_default.isAnimating(this._$viewsWrapper)) {
      fx_default.stop(this._$viewsWrapper, true);
    }
    const min = this._getMinDate();
    const max = this._getMaxDate();
    if (min > max) {
      this.option("currentDate", /* @__PURE__ */ new Date());
      return;
    }
    const normalizedDate = this._getNormalizedDate(date);
    if (date.getTime() !== normalizedDate.getTime()) {
      this.option("currentDate", new Date(normalizedDate));
      return;
    }
    let offset2 = this._getViewsOffset(this._view.option("date"), normalizedDate);
    if (0 !== offset2 && !this._isMaxZoomLevel() && this._isOtherViewCellClicked) {
      offset2 = 0;
    }
    if (this._view && 0 !== offset2 && !this._suppressNavigation) {
      if (this._additionalView) {
        if (offset2 > 2 || offset2 < -1) {
          this._refreshViews();
          this._setViewContoured(normalizedDate);
          this._updateAriaId(normalizedDate);
          this._renderNavigator();
        } else if (1 === offset2 && this._skipNavigate) {
          this._setViewContoured(normalizedDate);
          this._updateAriaId(normalizedDate);
        } else {
          this._navigate(offset2, normalizedDate);
        }
      } else {
        this._navigate(offset2, normalizedDate);
      }
    } else {
      this._renderNavigator();
      this._setViewContoured(normalizedDate);
      this._updateAriaId(normalizedDate);
    }
    this._skipNavigate = false;
  },
  _isAdditionalViewDate(date) {
    if (!this._additionalView) {
      return false;
    }
    return date >= this._additionalView._getFirstAvailableDate();
  },
  _getActiveView(date) {
    return this._isAdditionalViewDate(date) ? this._additionalView : this._view;
  },
  _setViewContoured(date) {
    if (this.option("skipFocusCheck") || renderer_default(this._$viewsWrapper).is(":focus")) {
      var _this$_additionalView;
      this._view.option("contouredDate", null);
      null === (_this$_additionalView = this._additionalView) || void 0 === _this$_additionalView || _this$_additionalView.option("contouredDate", null);
      const view = this._isAdditionalViewDate(date) ? this._additionalView : this._view;
      view.option("contouredDate", date);
    }
  },
  _getMinDate() {
    const _rangeMin = this.option("_rangeMin");
    if (_rangeMin) {
      return _rangeMin;
    }
    if (this.min) {
      return this.min;
    }
    this.min = this._dateOption("min") || new Date(1e3, 0);
    return this.min;
  },
  _getMaxDate() {
    const _rangeMax = this.option("_rangeMax");
    if (_rangeMax) {
      return _rangeMax;
    }
    if (this.max) {
      return this.max;
    }
    this.max = this._dateOption("max") || new Date(3e3, 0);
    return this.max;
  },
  _getViewsOffset(startDate, endDate) {
    const zoomLevel = this.option("zoomLevel");
    if (zoomLevel === ZOOM_LEVEL.MONTH) {
      return this._getMonthsOffset(startDate, endDate);
    }
    let zoomCorrection;
    switch (zoomLevel) {
      case ZOOM_LEVEL.CENTURY:
        zoomCorrection = 100;
        break;
      case ZOOM_LEVEL.DECADE:
        zoomCorrection = 10;
        break;
      default:
        zoomCorrection = 1;
    }
    return parseInt(endDate.getFullYear() / zoomCorrection) - parseInt(startDate.getFullYear() / zoomCorrection);
  },
  _getMonthsOffset(startDate, endDate) {
    const yearOffset = endDate.getFullYear() - startDate.getFullYear();
    const monthOffset = endDate.getMonth() - startDate.getMonth();
    return 12 * yearOffset + monthOffset;
  },
  _waitRenderView(offset2) {
    if (this._alreadyViewRender) {
      return;
    }
    this._alreadyViewRender = true;
    const date = this._getDateByOffset(offset2 * this._getRtlCorrection());
    this._moveToClosestAvailableDate(date);
    this._waitRenderViewTimeout = setTimeout(() => {
      this._alreadyViewRender = false;
    });
  },
  _getRtlCorrection() {
    return this.option("rtlEnabled") ? -1 : 1;
  },
  _getDateByOffset(offset2, date) {
    date = this._getDate(date ?? this.option("currentDate"));
    const currentDay = date.getDate();
    const difference = date_default.getDifferenceInMonth(this.option("zoomLevel")) * offset2;
    date.setDate(1);
    date.setMonth(date.getMonth() + difference);
    const lastDay = date_default.getLastMonthDate(date).getDate();
    date.setDate(currentDay > lastDay ? lastDay : currentDay);
    return date;
  },
  _focusTarget() {
    return this._$viewsWrapper;
  },
  _focusEventTarget() {
    return this.$element();
  },
  _initMarkup() {
    this._renderSubmitElement();
    const $element = this.$element();
    $element.addClass("dx-calendar");
    $element.toggleClass("dx-calendar-range", "range" === this.option("selectionMode"));
    this._renderBody();
    $element.append(this.$body);
    this._renderViews();
    this._renderNavigator();
    this.callBase();
    this._renderEvents();
    $element.prepend(this._navigator.$element());
    this._renderSwipeable();
    this._renderFooter();
    this._selectionStrategy.updateAriaSelected();
    this._updateAriaId();
    this._updateNavigatorLabels();
    this.setAria("role", "application");
    this._moveToClosestAvailableDate();
  },
  _render() {
    this.callBase();
    this._setViewContoured(this.option("currentDate"));
  },
  _renderBody() {
    if (!this._$viewsWrapper) {
      this.$body = renderer_default("<div>").addClass("dx-calendar-body");
      this._$viewsWrapper = renderer_default("<div>").addClass("dx-calendar-views-wrapper");
      this.$body.append(this._$viewsWrapper);
    }
  },
  _setAriaReadonly: noop2,
  _getKeyboardListeners() {
    return this.callBase().concat([this._view]);
  },
  _renderViews() {
    this.$element().addClass(`dx-calendar-view-${this.option("zoomLevel")}`);
    const {
      currentDate,
      viewsCount
    } = this.option();
    this.$element().toggleClass("dx-calendar-multiview", viewsCount > 1);
    this._view = this._renderSpecificView(currentDate);
    if (hasWindow()) {
      const beforeDate = this._getDateByOffset(-1, currentDate);
      this._beforeView = this._isViewAvailable(beforeDate) ? this._renderSpecificView(beforeDate) : null;
      const afterDate = this._getDateByOffset(viewsCount, currentDate);
      afterDate.setDate(1);
      this._afterView = this._isViewAvailable(afterDate) ? this._renderSpecificView(afterDate) : null;
    }
    if (viewsCount > 1) {
      this._additionalView = this._renderSpecificView(this._getDateByOffset(1, currentDate));
    }
    this._translateViews();
  },
  _renderSpecificView(date) {
    const {
      zoomLevel
    } = this.option();
    const specificView = m_calendar_views_default[zoomLevel];
    const $view = renderer_default("<div>").appendTo(this._$viewsWrapper);
    const config3 = this._viewConfig(date);
    const view = this._createComponent($view, specificView, config3);
    return view;
  },
  _viewConfig(date) {
    let disabledDates = this.option("disabledDates");
    disabledDates = isFunction(disabledDates) ? this._injectComponent(disabledDates.bind(this)) : disabledDates;
    return _extends({}, this._selectionStrategy.getViewOptions(), {
      date,
      min: this._getMinDate(),
      max: this._getMaxDate(),
      firstDayOfWeek: this.option("firstDayOfWeek") ?? date_default3.firstDayOfWeekIndex(),
      showWeekNumbers: this.option("showWeekNumbers"),
      selectWeekOnClick: this.option("selectWeekOnClick"),
      weekNumberRule: this.option("weekNumberRule"),
      zoomLevel: this.option("zoomLevel"),
      tabIndex: void 0,
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      disabledDates,
      onCellClick: this._cellClickHandler.bind(this),
      cellTemplate: this._getTemplateByOption("cellTemplate"),
      allowValueSelection: this._isMaxZoomLevel(),
      _todayDate: this.option("_todayDate")
    });
  },
  _renderEvents() {
    events_engine_default.off(this._$viewsWrapper, CALENDAR_DXHOVEREND_EVENT_NAME);
    if ("range" === this.option("selectionMode")) {
      events_engine_default.on(this._$viewsWrapper, CALENDAR_DXHOVEREND_EVENT_NAME, null, () => {
        this._updateViewsOption("hoveredRange", []);
      });
    }
  },
  _injectComponent(func) {
    const that = this;
    return function(params) {
      extend(params, {
        component: that
      });
      return func(params);
    };
  },
  _isViewAvailable(date) {
    const zoomLevel = this.option("zoomLevel");
    const min = date_default.getViewMinBoundaryDate(zoomLevel, this._getMinDate());
    const max = date_default.getViewMaxBoundaryDate(zoomLevel, this._getMaxDate());
    return date_default.dateInRange(date, min, max);
  },
  _translateViews() {
    const {
      viewsCount
    } = this.option();
    move(this._view.$element(), {
      left: 0,
      top: 0
    });
    this._moveViewElement(this._beforeView, -1);
    this._moveViewElement(this._afterView, viewsCount);
    this._moveViewElement(this._additionalView, 1);
  },
  _moveViewElement(view, coefficient) {
    view && move(view.$element(), {
      left: this._getViewPosition(coefficient),
      top: 0
    });
  },
  _getViewPosition(coefficient) {
    const rtlCorrection = this.option("rtlEnabled") ? -1 : 1;
    return 100 * coefficient * rtlCorrection + "%";
  },
  _cellClickHandler(e) {
    const zoomLevel = this.option("zoomLevel");
    const nextView = date_default.getViewDown(zoomLevel);
    const isMaxZoomLevel = this._isMaxZoomLevel();
    if (nextView && !isMaxZoomLevel) {
      this._navigateDown(e.event.currentTarget);
    } else {
      const newValue = this._updateTimeComponent(e.value);
      this._selectionStrategy.selectValue(newValue, e.event);
      this._cellClickAction(e);
    }
  },
  _updateTimeComponent(date) {
    const result2 = new Date(date);
    const currentValue = this._dateOption("value");
    if (currentValue && this._isSingleMode()) {
      result2.setHours(currentValue.getHours());
      result2.setMinutes(currentValue.getMinutes());
      result2.setSeconds(currentValue.getSeconds());
      result2.setMilliseconds(currentValue.getMilliseconds());
    }
    return result2;
  },
  _isMaxZoomLevel() {
    return this.option("zoomLevel") === this.option("maxZoomLevel");
  },
  _navigateDown(cell) {
    const zoomLevel = this.option("zoomLevel");
    if (this._isMaxZoomLevel()) {
      return;
    }
    const nextView = date_default.getViewDown(zoomLevel);
    if (!nextView) {
      return;
    }
    let newCurrentDate = this._view.option("contouredDate") || this._view.option("date");
    if (cell) {
      newCurrentDate = renderer_default(cell).data("dxDateValueKey");
    }
    this._isOtherViewCellClicked = true;
    this.option("currentDate", newCurrentDate);
    this.option("zoomLevel", nextView);
    this._isOtherViewCellClicked = false;
    this._renderNavigator();
    this._animateShowView();
    this._moveToClosestAvailableDate();
    this._setViewContoured(this._getNormalizedDate(this.option("currentDate")));
  },
  _renderNavigator() {
    if (!this._navigator) {
      this._navigator = new m_calendar_navigator_default(renderer_default("<div>"), this._navigatorConfig());
    }
    this._navigator.option("text", this._getViewsCaption(this._view, this._additionalView));
    this._updateButtonsVisibility();
  },
  _navigatorConfig() {
    const {
      focusStateEnabled,
      rtlEnabled
    } = this.option();
    return {
      text: this._getViewsCaption(this._view, this._additionalView),
      onClick: this._navigatorClickHandler.bind(this),
      onCaptionClick: this._navigateUp.bind(this),
      focusStateEnabled,
      rtlEnabled,
      tabIndex: void 0
    };
  },
  _navigatorClickHandler(e) {
    const {
      currentDate,
      viewsCount
    } = this.option();
    let offset2 = e.direction;
    if (viewsCount > 1) {
      const additionalViewActive = this._isAdditionalViewDate(currentDate);
      const shouldDoubleOffset = additionalViewActive && offset2 < 0 || !additionalViewActive && offset2 > 0;
      if (shouldDoubleOffset) {
        offset2 *= 2;
      }
    }
    const newCurrentDate = this._getDateByOffset(offset2, currentDate);
    this._moveToClosestAvailableDate(newCurrentDate);
  },
  _navigateUp() {
    const zoomLevel = this.option("zoomLevel");
    const nextView = date_default.getViewUp(zoomLevel);
    if (!nextView || this._isMinZoomLevel(zoomLevel)) {
      return;
    }
    this.option("zoomLevel", nextView);
    this._renderNavigator();
    this._animateShowView();
    this._moveToClosestAvailableDate();
    this._setViewContoured(this._getNormalizedDate(this.option("currentDate")));
  },
  _isMinZoomLevel(zoomLevel) {
    const min = this._getMinDate();
    const max = this._getMaxDate();
    return date_default.sameView(zoomLevel, min, max) || this.option("minZoomLevel") === zoomLevel;
  },
  _updateButtonsVisibility() {
    this._navigator.toggleButton("next", !isDefined(this._afterView));
    this._navigator.toggleButton("prev", !isDefined(this._beforeView));
  },
  _renderSwipeable() {
    if (!this._swipeable) {
      this._swipeable = this._createComponent(this.$element(), swipeable_default, {
        onStart: this._swipeStartHandler.bind(this),
        onUpdated: this._swipeUpdateHandler.bind(this),
        onEnd: this._swipeEndHandler.bind(this),
        itemSizeFunc: this._viewWidth.bind(this)
      });
    }
  },
  _swipeStartHandler(e) {
    fx_default.stop(this._$viewsWrapper, true);
    const {
      viewsCount
    } = this.option();
    this._toggleGestureCoverCursor("grabbing");
    e.event.maxLeftOffset = this._getRequiredView("next") ? 1 / viewsCount : 0;
    e.event.maxRightOffset = this._getRequiredView("prev") ? 1 / viewsCount : 0;
  },
  _toggleGestureCoverCursor(cursor) {
    renderer_default(".dx-gesture-cover").css("cursor", cursor);
  },
  _getRequiredView(name2) {
    let view;
    const isRtl = this.option("rtlEnabled");
    if ("next" === name2) {
      view = isRtl ? this._beforeView : this._afterView;
    } else if ("prev" === name2) {
      view = isRtl ? this._afterView : this._beforeView;
    }
    return view;
  },
  _swipeUpdateHandler(e) {
    const {
      offset: offset2
    } = e.event;
    move(this._$viewsWrapper, {
      left: offset2 * this._viewWidth(),
      top: 0
    });
    this._updateNavigatorCaption(offset2);
  },
  _swipeEndHandler(e) {
    this._toggleGestureCoverCursor("auto");
    const {
      currentDate,
      rtlEnabled
    } = this.option();
    const {
      targetOffset
    } = e.event;
    const moveOffset = !targetOffset ? 0 : targetOffset / Math.abs(targetOffset);
    const isAdditionalViewActive = this._isAdditionalViewDate(currentDate);
    const shouldDoubleOffset = isAdditionalViewActive && (rtlEnabled ? -1 === moveOffset : 1 === moveOffset);
    if (0 === moveOffset) {
      this._animateWrapper(0, 250);
      return;
    }
    const offset2 = -moveOffset * this._getRtlCorrection() * (shouldDoubleOffset ? 2 : 1);
    let date = this._getDateByOffset(offset2);
    if (this._isDateInInvalidRange(date)) {
      if (moveOffset >= 0) {
        date = new Date(this._getMinDate());
      } else {
        date = new Date(this._getMaxDate());
      }
    }
    this.option("currentDate", date);
  },
  _viewWidth() {
    if (!this._viewWidthValue) {
      this._viewWidthValue = getWidth(this.$element()) / this.option("viewsCount");
    }
    return this._viewWidthValue;
  },
  _updateNavigatorCaption(offset2) {
    offset2 *= this._getRtlCorrection();
    const isMultiView = this.option("viewsCount") > 1;
    let view;
    let additionalView;
    if (offset2 > 0.5 && this._beforeView) {
      view = this._beforeView;
      additionalView = isMultiView && this._view;
    } else if (offset2 < -0.5 && this._afterView) {
      view = isMultiView ? this._additionalView : this._afterView;
      additionalView = isMultiView ? this._afterView : null;
    } else {
      view = this._view;
      additionalView = isMultiView ? this._additionalView : null;
    }
    this._navigator.option("text", this._getViewsCaption(view, additionalView));
  },
  _getViewsCaption(view, additionalView) {
    let caption = view.getNavigatorCaption();
    const {
      viewsCount
    } = this.option();
    if (viewsCount > 1 && additionalView) {
      const additionalViewCaption = additionalView.getNavigatorCaption();
      caption = `${caption} - ${additionalViewCaption}`;
    }
    return caption;
  },
  _isDateInInvalidRange(date) {
    if (this._view.isBoundary(date)) {
      return;
    }
    const min = this._getMinDate();
    const max = this._getMaxDate();
    const normalizedDate = date_default.normalizeDate(date, min, max);
    return normalizedDate === min || normalizedDate === max;
  },
  _renderFooter() {
    const showTodayButton = this.option("showTodayButton");
    if (showTodayButton) {
      const $todayButton = this._createComponent(renderer_default("<div>"), button_default, {
        focusStateEnabled: this.option("focusStateEnabled"),
        text: message_default.format("dxCalendar-todayButtonText"),
        onClick: (args) => {
          this._toTodayView(args);
        },
        type: isFluent() ? "normal" : "default",
        stylingMode: isFluent() ? "outlined" : "text",
        integrationOptions: {}
      }).$element().addClass("dx-calendar-today-button");
      this._$footer = renderer_default("<div>").addClass("dx-calendar-footer").append($todayButton);
      this.$element().append(this._$footer);
    }
    this.$element().toggleClass("dx-calendar-with-footer", showTodayButton);
  },
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    this._setSubmitValue(this.option("value"));
  },
  _setSubmitValue(value2) {
    const dateValue = this._convertToDate(value2);
    this._getSubmitElement().val(date_serialization_default.serializeDate(dateValue, "yyyy-MM-dd"));
  },
  _getSubmitElement() {
    return this._$submitElement;
  },
  _animateShowView() {
    fx_default.stop(this._view.$element(), true);
    this._popAnimationView(this._view, 0.6, 1, 250);
    if (this.option("viewsCount") > 1) {
      fx_default.stop(this._additionalView.$element(), true);
      this._popAnimationView(this._additionalView, 0.6, 1, 250);
    }
  },
  _popAnimationView: (view, from, to, duration) => fx_default.animate(view.$element(), {
    type: "pop",
    from: {
      scale: from,
      opacity: from
    },
    to: {
      scale: to,
      opacity: to
    },
    duration
  }),
  _navigate(offset2, value2) {
    if (0 !== offset2 && 1 !== Math.abs(offset2) && this._isViewAvailable(value2)) {
      const newView = this._renderSpecificView(value2);
      if (offset2 > 0) {
        this._afterView && this._afterView.$element().remove();
        this._afterView = newView;
      } else {
        this._beforeView && this._beforeView.$element().remove();
        this._beforeView = newView;
      }
      this._translateViews();
    }
    const rtlCorrection = this._getRtlCorrection();
    const offsetSign = offset2 > 0 ? 1 : offset2 < 0 ? -1 : 0;
    const endPosition = -rtlCorrection * offsetSign * this._viewWidth();
    const viewsWrapperPosition = this._$viewsWrapper.position().left;
    if (viewsWrapperPosition !== endPosition) {
      if (this._preventViewChangeAnimation) {
        this._wrapperAnimationEndHandler(offset2, value2);
      } else {
        this._animateWrapper(endPosition, 250).done(this._wrapperAnimationEndHandler.bind(this, offset2, value2));
      }
    }
  },
  _animateWrapper(to, duration) {
    return fx_default.animate(this._$viewsWrapper, {
      type: "slide",
      from: {
        left: this._$viewsWrapper.position().left
      },
      to: {
        left: to
      },
      duration
    });
  },
  _getDate: (value2) => new Date(value2),
  _toTodayView(args) {
    const today = /* @__PURE__ */ new Date();
    if (this._isMaxZoomLevel()) {
      this._selectionStrategy.selectValue(today, args.event);
      return;
    }
    this._preventViewChangeAnimation = true;
    this.option("zoomLevel", this.option("maxZoomLevel"));
    this._selectionStrategy.selectValue(today, args.event);
    this._animateShowView();
    this._preventViewChangeAnimation = false;
  },
  _wrapperAnimationEndHandler(offset2, newDate) {
    this._rearrangeViews(offset2);
    this._translateViews();
    this._resetLocation();
    this._renderNavigator();
    this._setViewContoured(newDate);
    this._updateAriaId(newDate);
    this._selectionStrategy.updateAriaSelected();
  },
  _rearrangeViews(offset2) {
    var _this$viewToRemoveKey;
    if (0 === offset2) {
      return;
    }
    const {
      viewsCount
    } = this.option();
    let viewOffset;
    let viewToCreateKey;
    let viewToRemoveKey;
    let viewBeforeCreateKey;
    let viewAfterRemoveKey;
    if (offset2 < 0) {
      viewOffset = 1;
      viewToCreateKey = "_beforeView";
      viewToRemoveKey = "_afterView";
      viewBeforeCreateKey = "_view";
      viewAfterRemoveKey = 1 === viewsCount ? "_view" : "_additionalView";
    } else {
      viewOffset = -1;
      viewToCreateKey = "_afterView";
      viewToRemoveKey = "_beforeView";
      viewBeforeCreateKey = 1 === viewsCount ? "_view" : "_additionalView";
      viewAfterRemoveKey = "_view";
    }
    if (!this[viewToCreateKey]) {
      return;
    }
    const destinationDate = this[viewToCreateKey].option("date");
    null === (_this$viewToRemoveKey = this[viewToRemoveKey]) || void 0 === _this$viewToRemoveKey || _this$viewToRemoveKey.$element().remove();
    this[viewToRemoveKey] = this._renderSpecificView(this._getDateByOffset(viewOffset * viewsCount, destinationDate));
    this[viewAfterRemoveKey].$element().remove();
    if (1 === viewsCount) {
      this[viewAfterRemoveKey] = this[viewToCreateKey];
    } else {
      this[viewAfterRemoveKey] = this[viewBeforeCreateKey];
      this[viewBeforeCreateKey] = this[viewToCreateKey];
    }
    const dateByOffset = this._getDateByOffset(-viewOffset, destinationDate);
    this[viewToCreateKey] = this._isViewAvailable(dateByOffset) ? this._renderSpecificView(dateByOffset) : null;
  },
  _resetLocation() {
    move(this._$viewsWrapper, {
      left: 0,
      top: 0
    });
  },
  _clean() {
    this.callBase();
    this._clearViewWidthCache();
    delete this._$viewsWrapper;
    delete this._navigator;
    delete this._$footer;
  },
  _clearViewWidthCache() {
    delete this._viewWidthValue;
  },
  _disposeViews() {
    this._view.$element().remove();
    this._beforeView && this._beforeView.$element().remove();
    this._additionalView && this._additionalView.$element().remove();
    this._afterView && this._afterView.$element().remove();
    delete this._view;
    delete this._additionalView;
    delete this._beforeView;
    delete this._afterView;
    delete this._skipNavigate;
  },
  _dispose() {
    clearTimeout(this._waitRenderViewTimeout);
    this.callBase();
  },
  _refreshViews() {
    this._resetActiveState();
    this._disposeViews();
    this._renderViews();
  },
  _visibilityChanged() {
    this._translateViews();
  },
  _shouldSkipFocusEvent(event) {
    const {
      target,
      relatedTarget
    } = event;
    return renderer_default(target).parents(".dx-calendar").length && renderer_default(relatedTarget).parents(".dx-calendar").length;
  },
  _focusInHandler(event) {
    if (renderer_default(event.target).is(this._$viewsWrapper)) {
      this._setViewContoured(this.option("currentDate"));
    }
    if (this._shouldSkipFocusEvent(event)) {
      return;
    }
    this.callBase.apply(this, arguments);
    this._toggleFocusClass(true, this.$element());
  },
  _focusOutHandler(event) {
    if (renderer_default(event.target).is(this._$viewsWrapper)) {
      var _this$_additionalView2;
      this._view.option("contouredDate", null);
      null === (_this$_additionalView2 = this._additionalView) || void 0 === _this$_additionalView2 || _this$_additionalView2.option("contouredDate", null);
    }
    if (this._shouldSkipFocusEvent(event)) {
      return;
    }
    this.callBase.apply(this, arguments);
    this._toggleFocusClass(false, this.$element());
  },
  _updateViewsOption(optionName, newValue) {
    var _this$_additionalView3, _this$_beforeView, _this$_afterView;
    this._view.option(optionName, newValue);
    null === (_this$_additionalView3 = this._additionalView) || void 0 === _this$_additionalView3 || _this$_additionalView3.option(optionName, newValue);
    null === (_this$_beforeView = this._beforeView) || void 0 === _this$_beforeView || _this$_beforeView.option(optionName, newValue);
    null === (_this$_afterView = this._afterView) || void 0 === _this$_afterView || _this$_afterView.option(optionName, newValue);
  },
  _setViewsMinOption(min) {
    this._restoreViewsMinMaxOptions();
    this.option("_rangeMin", this._convertToDate(min));
    this._updateViewsOption("min", this._getMinDate());
  },
  _setViewsMaxOption(max) {
    this._restoreViewsMinMaxOptions();
    this.option("_rangeMax", this._convertToDate(max));
    this._updateViewsOption("max", this._getMaxDate());
  },
  _restoreViewsMinMaxOptions() {
    this._resetActiveState();
    this.option({
      _rangeMin: null,
      _rangeMax: null
    });
    this._updateViewsOption("min", this._getMinDate());
    this._updateViewsOption("max", this._getMaxDate());
  },
  _updateNavigatorLabels() {
    let zoomLevel = this.option("zoomLevel");
    zoomLevel = zoomLevel.charAt(0).toUpperCase() + zoomLevel.slice(1);
    const captionButtonText = this._navigator._caption.option("text");
    const localizedPrevButtonLabel = message_default.format(`dxCalendar-previous${zoomLevel}ButtonLabel`);
    const localizedCaptionLabel = message_default.format(`dxCalendar-caption${zoomLevel}Label`);
    const localizedNextButtonLabel = message_default.format(`dxCalendar-next${zoomLevel}ButtonLabel`);
    this.setAria("label", localizedPrevButtonLabel, this._navigator._prevButton.$element());
    this.setAria("label", `${captionButtonText}. ${localizedCaptionLabel}`, this._navigator._caption.$element());
    this.setAria("label", localizedNextButtonLabel, this._navigator._nextButton.$element());
  },
  _updateAriaSelected(value2, previousValue) {
    previousValue.forEach((item) => {
      this.setAria("selected", false, this._view._getCellByDate(item));
    });
    value2.forEach((item) => {
      this.setAria("selected", true, this._view._getCellByDate(item));
    });
    if (this.option("viewsCount") > 1) {
      previousValue.forEach((item) => {
        this.setAria("selected", false, this._additionalView._getCellByDate(item));
      });
      value2.forEach((item) => {
        this.setAria("selected", true, this._additionalView._getCellByDate(item));
      });
    }
  },
  _updateAriaId(value2) {
    value2 = value2 ?? this.option("currentDate");
    const ariaId = `dx-${new guid_default()}`;
    const view = this._getActiveView(value2);
    const $newCell = view._getCellByDate(value2);
    this.setAria("id", ariaId, $newCell);
    this.setAria("activedescendant", ariaId);
    this._onContouredChanged(ariaId);
  },
  _suppressingNavigation(callback, args) {
    this._suppressNavigation = true;
    callback.apply(this, args);
    delete this._suppressNavigation;
  },
  _optionChanged(args) {
    const {
      value: value2,
      previousValue
    } = args;
    switch (args.name) {
      case "width":
        this.callBase(args);
        this._clearViewWidthCache();
        break;
      case "min":
      case "max":
        this.min = void 0;
        this.max = void 0;
        this._suppressingNavigation(this._updateCurrentDate, [this.option("currentDate")]);
        this._refreshViews();
        this._renderNavigator();
        break;
      case "selectionMode":
        this._refreshSelectionStrategy();
        this._initCurrentDate();
        break;
      case "selectWeekOnClick":
      case "_todayDate":
      case "showWeekNumbers":
      case "weekNumberRule":
        this._refreshViews();
        break;
      case "firstDayOfWeek":
        this._refreshViews();
        this._updateButtonsVisibility();
        break;
      case "focusStateEnabled":
      case "disabledDates":
      case "dateSerializationFormat":
      case "cellTemplate":
      case "showTodayButton":
        this._invalidate();
        break;
      case "currentDate":
        this.setAria("id", void 0, this._view._getCellByDate(previousValue));
        this._updateCurrentDate(value2);
        break;
      case "zoomLevel":
        this.$element().removeClass(`dx-calendar-view-${previousValue}`);
        this._correctZoomLevel();
        this._refreshViews();
        this._renderNavigator();
        this._updateAriaId();
        this._updateNavigatorLabels();
        break;
      case "minZoomLevel":
      case "maxZoomLevel":
        this._correctZoomLevel();
        this._updateButtonsVisibility();
        break;
      case "value":
        this._selectionStrategy.processValueChanged(value2, previousValue);
        this._setSubmitValue(value2);
        this.callBase(args);
        break;
      case "viewsCount":
        this._refreshViews();
        this._renderNavigator();
        break;
      case "onCellClick":
        this._view.option("onCellClick", value2);
        break;
      case "onContouredChanged":
        this._onContouredChanged = this._createActionByOption("onContouredChanged");
        break;
      case "skipFocusCheck":
        break;
      default:
        this.callBase(args);
    }
  },
  getContouredDate() {
    return this._view.option("contouredDate");
  }
});
component_registrator_default("dxCalendar", Calendar);
var m_calendar_default = Calendar;

// ../../../../../../node_modules/devextreme/esm/ui/calendar.js
var calendar_default = m_calendar_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.js
var {
  abstract: abstract7
} = class_default;
var DateBoxStrategy = class_default.inherit({
  ctor(dateBox) {
    this.dateBox = dateBox;
  },
  widgetOption() {
    return this._widget && this._widget.option.apply(this._widget, arguments);
  },
  _renderWidget(element) {
    element = element || renderer_default("<div>");
    this._widget = this._createWidget(element);
    this._widget.$element().appendTo(this._getWidgetContainer());
  },
  _createWidget(element) {
    const widgetName = this._getWidgetName();
    const widgetOptions = this._getWidgetOptions();
    return this.dateBox._createComponent(element, widgetName, widgetOptions);
  },
  _getWidgetOptions: abstract7,
  _getWidgetName: abstract7,
  getDefaultOptions: () => ({
    mode: "text"
  }),
  getDisplayFormat: abstract7,
  supportedKeys: noop2,
  getKeyboardListener: noop2,
  customizeButtons: noop2,
  getParsedText(text, format2) {
    const value2 = date_default3.parse(text, format2);
    return value2 || date_default3.parse(text);
  },
  renderInputMinMax: noop2,
  renderOpenedState() {
    this._updateValue();
  },
  popupConfig: abstract7,
  _dimensionChanged() {
    var _this$_getPopup;
    null === (_this$_getPopup = this._getPopup()) || void 0 === _this$_getPopup || _this$_getPopup.repaint();
  },
  renderPopupContent() {
    const popup = this._getPopup();
    this._renderWidget();
    const $popupContent = popup.$content().parent();
    events_engine_default.off($popupContent, "mousedown");
    events_engine_default.on($popupContent, "mousedown", this._preventFocusOnPopup.bind(this));
  },
  _preventFocusOnPopup(e) {
    e.preventDefault();
  },
  _getWidgetContainer() {
    return this._getPopup().$content();
  },
  _getPopup() {
    return this.dateBox._popup;
  },
  popupShowingHandler: noop2,
  popupHiddenHandler: noop2,
  _updateValue() {
    this._widget && this._widget.option("value", this.dateBoxValue());
  },
  useCurrentDateByDefault: noop2,
  getDefaultDate: () => /* @__PURE__ */ new Date(),
  textChangedHandler: noop2,
  renderValue() {
    if (this.dateBox.option("opened")) {
      this._updateValue();
    }
  },
  getValue() {
    return this._widget.option("value");
  },
  isAdaptivityChanged: () => false,
  dispose() {
    const popup = this._getPopup();
    if (popup) {
      popup.$content().empty();
    }
  },
  dateBoxValue() {
    if (arguments.length) {
      return this.dateBox.dateValue.apply(this.dateBox, arguments);
    }
    return this.dateBox.dateOption.apply(this.dateBox, ["value"]);
  }
});
var m_date_box_strategy_default = DateBoxStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.calendar.js
var CalendarStrategy = m_date_box_strategy_default.inherit({
  NAME: "Calendar",
  getDefaultOptions() {
    return extend(this.callBase(), {
      todayButtonText: message_default.format("dxCalendar-todayButtonText")
    });
  },
  supportedKeys() {
    const homeEndHandler = function(e) {
      if (this.option("opened")) {
        e.preventDefault();
        return true;
      }
      return false;
    };
    return {
      rightArrow() {
        if (this.option("opened")) {
          return true;
        }
      },
      leftArrow() {
        if (this.option("opened")) {
          return true;
        }
      },
      enter: (function(e) {
        if (this.dateBox.option("opened")) {
          e.preventDefault();
          if (this._widget.option("zoomLevel") === this._widget.option("maxZoomLevel")) {
            const viewValue = this._getContouredValue();
            const lastActionElement = this._lastActionElement;
            const shouldCloseDropDown = this._closeDropDownByEnter();
            if (shouldCloseDropDown && viewValue && "calendar" === lastActionElement) {
              this.dateBoxValue(viewValue, e);
            }
            shouldCloseDropDown && this.dateBox.close();
            this.dateBox._valueChangeEventHandler(e);
            return !shouldCloseDropDown;
          }
          return true;
        }
        this.dateBox._valueChangeEventHandler(e);
      }).bind(this),
      home: homeEndHandler,
      end: homeEndHandler
    };
  },
  getDisplayFormat: (displayFormat) => displayFormat || "shortdate",
  _closeDropDownByEnter: () => true,
  _getWidgetName: () => calendar_default,
  _getContouredValue() {
    return this._widget._view.option("contouredDate");
  },
  getKeyboardListener() {
    return this._widget;
  },
  _getWidgetOptions() {
    const disabledDates = this.dateBox.option("disabledDates");
    return extend(this.dateBox.option("calendarOptions"), {
      value: this.dateBoxValue() || null,
      selectionMode: "single",
      dateSerializationFormat: null,
      min: this.dateBox.dateOption("min"),
      max: this.dateBox.dateOption("max"),
      onValueChanged: this._valueChangedHandler.bind(this),
      onCellClick: this._cellClickHandler.bind(this),
      disabledDates: isFunction(disabledDates) ? this._injectComponent(disabledDates.bind(this.dateBox)) : disabledDates,
      onContouredChanged: this._refreshActiveDescendant.bind(this),
      skipFocusCheck: true
    });
  },
  _injectComponent(func) {
    const that = this;
    return function(params) {
      extend(params, {
        component: that.dateBox
      });
      return func(params);
    };
  },
  _refreshActiveDescendant(e) {
    this._lastActionElement = "calendar";
    this.dateBox.setAria("activedescendant", e.actionValue);
  },
  _getTodayButtonConfig() {
    const buttonsLocation = this.dateBox.option("buttonsLocation");
    const isButtonsLocationDefault = "default" === buttonsLocation;
    const position3 = isButtonsLocationDefault ? ["bottom", "center"] : splitPair(buttonsLocation);
    const stylingMode = isMaterial() ? "text" : "outlined";
    return {
      widget: "dxButton",
      toolbar: position3[0],
      location: "after" === position3[1] ? "before" : position3[1],
      options: {
        onClick: (args) => {
          this._widget._toTodayView(args);
        },
        text: this.dateBox.option("todayButtonText"),
        elementAttr: {
          class: "dx-button-today"
        },
        stylingMode
      }
    };
  },
  _isCalendarVisible() {
    const {
      calendarOptions
    } = this.dateBox.option();
    return isEmptyObject(calendarOptions) || false !== calendarOptions.visible;
  },
  _getPopupToolbarItems(toolbarItems) {
    const useButtons = "useButtons" === this.dateBox.option("applyValueMode");
    const shouldRenderTodayButton = useButtons && this._isCalendarVisible();
    if (shouldRenderTodayButton) {
      const todayButton = this._getTodayButtonConfig();
      return [todayButton, ...toolbarItems];
    }
    return toolbarItems;
  },
  popupConfig: (popupConfig) => extend(true, popupConfig, {
    position: {
      collision: "flipfit flip"
    },
    width: "auto"
  }),
  _valueChangedHandler(e) {
    const {
      value: value2
    } = e;
    const prevValue = e.previousValue;
    if (date_default.sameDate(value2, prevValue) && date_default.sameHoursAndMinutes(value2, prevValue)) {
      return;
    }
    if ("instantly" === this.dateBox.option("applyValueMode")) {
      this.dateBoxValue(this.getValue(), e.event);
    }
  },
  _updateValue() {
    if (!this._widget) {
      return;
    }
    this._widget.option("value", this.dateBoxValue());
  },
  textChangedHandler() {
    this._lastActionElement = "input";
    if (this.dateBox.option("opened") && this._widget) {
      this._updateValue(true);
    }
  },
  _cellClickHandler(e) {
    const {
      dateBox
    } = this;
    if ("instantly" === dateBox.option("applyValueMode")) {
      dateBox.option("opened", false);
      this.dateBoxValue(this.getValue(), e.event);
    }
  }
});
var m_date_box_strategy_calendar_default = CalendarStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_box.js
var MINSIZE_MAP = {
  row: "minWidth",
  col: "minHeight"
};
var MAXSIZE_MAP = {
  row: "maxWidth",
  col: "maxHeight"
};
var FLEX_JUSTIFY_CONTENT_MAP = {
  start: "flex-start",
  end: "flex-end",
  center: "center",
  "space-between": "space-between",
  "space-around": "space-around"
};
var FLEX_ALIGN_ITEMS_MAP = {
  start: "flex-start",
  end: "flex-end",
  center: "center",
  stretch: "stretch"
};
var FLEX_DIRECTION_MAP = {
  row: "row",
  col: "column"
};
var setFlexProp = (element, prop, value2) => {
  value2 = normalizeStyleProp(prop, value2);
  element.style[styleProp(prop)] = value2;
  if (!hasWindow()) {
    if ("" === value2 || !isDefined(value2)) {
      return;
    }
    const cssName = dasherize(prop);
    const styleExpr = `${cssName}: ${value2};`;
    setStyle(element, styleExpr, false);
  }
};
var BoxItem = class extends m_item_default {
  _renderVisible(value2, oldValue) {
    super._renderVisible(value2);
    if (isDefined(oldValue)) {
      this._options.fireItemStateChangedAction({
        name: "visible",
        state: value2,
        oldState: oldValue
      });
    }
  }
};
var LayoutStrategy = class {
  constructor($element, option) {
    this._$element = $element;
    this._option = option;
  }
  renderBox() {
    this._$element.css({
      display: `${stylePropPrefix("flexDirection")}flex`
    });
    setFlexProp(this._$element.get(0), "flexDirection", FLEX_DIRECTION_MAP[this._option("direction")]);
  }
  renderAlign() {
    this._$element.css({
      justifyContent: this._normalizedAlign()
    });
  }
  _normalizedAlign() {
    const align = this._option("align");
    return align in FLEX_JUSTIFY_CONTENT_MAP ? FLEX_JUSTIFY_CONTENT_MAP[align] : align;
  }
  renderCrossAlign() {
    this._$element.css({
      alignItems: this._normalizedCrossAlign()
    });
  }
  _normalizedCrossAlign() {
    const crossAlign = this._option("crossAlign");
    return crossAlign in FLEX_ALIGN_ITEMS_MAP ? FLEX_ALIGN_ITEMS_MAP[crossAlign] : crossAlign;
  }
  renderItems($items) {
    const flexPropPrefix = stylePropPrefix("flexDirection");
    const direction = this._option("direction");
    each($items, function() {
      const $item = renderer_default(this);
      const item = $item.data("dxBoxItemData");
      $item.css({
        display: `${flexPropPrefix}flex`
      }).css(MAXSIZE_MAP[direction], item.maxSize || "none").css(MINSIZE_MAP[direction], item.minSize || "0");
      setFlexProp($item.get(0), "flexBasis", item.baseSize || 0);
      setFlexProp($item.get(0), "flexGrow", item.ratio);
      setFlexProp($item.get(0), "flexShrink", isDefined(item.shrink) ? item.shrink : 1);
      $item.children().each((_, itemContent) => {
        renderer_default(itemContent).css({
          width: "auto",
          height: "auto",
          display: `${stylePropPrefix("flexDirection")}flex`,
          flexBasis: 0
        });
        setFlexProp(itemContent, "flexGrow", 1);
        setFlexProp(itemContent, "flexDirection", renderer_default(itemContent)[0].style.flexDirection || "column");
      });
    });
  }
};
var Box = class _Box extends ui_collection_widget_edit_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      direction: "row",
      align: "start",
      crossAlign: "stretch",
      activeStateEnabled: false,
      focusStateEnabled: false,
      onItemStateChanged: void 0,
      _queue: void 0
    });
  }
  _itemClass() {
    return "dx-box-item";
  }
  _itemDataKey() {
    return "dxBoxItemData";
  }
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  }
  _init() {
    super._init();
    this.$element().addClass("dx-box-flex");
    this._initLayout();
    this._initBoxQueue();
  }
  _initLayout() {
    this._layout = new LayoutStrategy(this.$element(), this.option.bind(this));
  }
  _initBoxQueue() {
    this._queue = this.option("_queue") || [];
  }
  _queueIsNotEmpty() {
    return this.option("_queue") ? false : !!this._queue.length;
  }
  _pushItemToQueue($item, config3) {
    this._queue.push({
      $item,
      config: config3
    });
  }
  _shiftItemFromQueue() {
    return this._queue.shift();
  }
  _initMarkup() {
    this.$element().addClass("dx-box");
    this._layout.renderBox();
    super._initMarkup();
    this._renderAlign();
    this._renderActions();
  }
  _renderActions() {
    this._onItemStateChanged = this._createActionByOption("onItemStateChanged");
  }
  _renderAlign() {
    this._layout.renderAlign();
    this._layout.renderCrossAlign();
  }
  _renderItems(items) {
    super._renderItems(items);
    while (this._queueIsNotEmpty()) {
      const item = this._shiftItemFromQueue();
      this._createComponent(item.$item, _Box, extend({
        itemTemplate: this.option("itemTemplate"),
        itemHoldTimeout: this.option("itemHoldTimeout"),
        onItemHold: this.option("onItemHold"),
        onItemClick: this.option("onItemClick"),
        onItemContextMenu: this.option("onItemContextMenu"),
        onItemRendered: this.option("onItemRendered"),
        _queue: this._queue
      }, item.config));
    }
    this._layout.renderItems(this._itemElements());
  }
  _renderItemContent(args) {
    const $itemNode = args.itemData && args.itemData.node;
    if ($itemNode) {
      return this._renderItemContentByNode(args, $itemNode);
    }
    return super._renderItemContent(args);
  }
  _postprocessRenderItem(args) {
    const boxConfig = args.itemData.box;
    if (!boxConfig) {
      return;
    }
    this._pushItemToQueue(args.itemContent, boxConfig);
  }
  _createItemByTemplate(itemTemplate, args) {
    if (args.itemData.box) {
      return itemTemplate.source ? itemTemplate.source() : renderer_default();
    }
    return super._createItemByTemplate(itemTemplate, args);
  }
  _itemOptionChanged(item, property, value2, oldValue) {
    if ("visible" === property) {
      this._onItemStateChanged({
        name: property,
        state: value2,
        oldState: false !== oldValue
      });
    }
    super._itemOptionChanged(item, property, value2);
  }
  _optionChanged(args) {
    switch (args.name) {
      case "_queue":
      case "direction":
        this._invalidate();
        break;
      case "align":
        this._layout.renderAlign();
        break;
      case "crossAlign":
        this._layout.renderCrossAlign();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _itemOptions() {
    const options2 = super._itemOptions();
    options2.fireItemStateChangedAction = (e) => {
      this._onItemStateChanged(e);
    };
    return options2;
  }
};
Box.ItemClass = BoxItem;
component_registrator_default("dxBox", Box);
var m_box_default = Box;

// ../../../../../../node_modules/devextreme/esm/ui/box.js
var box_default = m_box_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_utils.js
var DATE_COMPONENTS = ["year", "day", "month", "day"];
var TIME_COMPONENTS = ["hours", "minutes", "seconds", "milliseconds"];
var ONE_DAY2 = 864e5;
var ONE_YEAR = 31536e6;
var getStringFormat = function(format2) {
  const formatType = typeof format2;
  if ("string" === formatType) {
    return "format";
  }
  if ("object" === formatType && void 0 !== format2.type) {
    return format2.type;
  }
  return null;
};
var dateUtils2 = {
  SUPPORTED_FORMATS: ["date", "time", "datetime"],
  ONE_MINUTE: 6e4,
  ONE_DAY: ONE_DAY2,
  ONE_YEAR,
  MIN_DATEVIEW_DEFAULT_DATE: new Date(1900, 0, 1),
  MAX_DATEVIEW_DEFAULT_DATE: function() {
    const newDate = /* @__PURE__ */ new Date();
    return new Date(newDate.getFullYear() + 50, newDate.getMonth(), newDate.getDate(), 23, 59, 59);
  }(),
  FORMATS_INFO: {
    date: {
      getStandardPattern: () => "yyyy-MM-dd",
      components: DATE_COMPONENTS
    },
    time: {
      getStandardPattern: () => "HH:mm",
      components: TIME_COMPONENTS
    },
    datetime: {
      getStandardPattern() {
        let standardPattern;
        !function() {
          const $input = renderer_default("<input>").attr("type", "datetime");
          $input.val("2000-01-01T01:01Z");
          if ($input.val()) {
            standardPattern = "yyyy-MM-ddTHH:mmZ";
          }
        }();
        if (!standardPattern) {
          standardPattern = "yyyy-MM-ddTHH:mm:ssZ";
        }
        dateUtils2.FORMATS_INFO.datetime.getStandardPattern = function() {
          return standardPattern;
        };
        return standardPattern;
      },
      components: [...DATE_COMPONENTS, ...TIME_COMPONENTS]
    },
    "datetime-local": {
      getStandardPattern: () => "yyyy-MM-ddTHH:mm:ss",
      components: [...DATE_COMPONENTS, "hours", "minutes", "seconds"]
    }
  },
  FORMATS_MAP: {
    date: "shortdate",
    time: "shorttime",
    datetime: "shortdateshorttime"
  },
  SUBMIT_FORMATS_MAP: {
    date: "date",
    time: "time",
    datetime: "datetime-local"
  },
  toStandardDateFormat(date, type2) {
    const pattern = dateUtils2.FORMATS_INFO[type2].getStandardPattern();
    return date_serialization_default.serializeDate(date, pattern);
  },
  fromStandardDateFormat(text) {
    const date = date_serialization_default.dateParser(text);
    return isDate(date) ? date : void 0;
  },
  getMaxMonthDay: (year, month) => new Date(year, month + 1, 0).getDate(),
  mergeDates(oldValue, newValue, format2) {
    if (!newValue) {
      return newValue || null;
    }
    if (!oldValue || isNaN(oldValue.getTime())) {
      const now = /* @__PURE__ */ new Date(null);
      oldValue = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    }
    const result2 = new Date(oldValue.valueOf());
    const formatInfo = dateUtils2.FORMATS_INFO[format2];
    each(formatInfo.components, function() {
      const componentInfo = dateUtils2.DATE_COMPONENTS_INFO[this];
      result2[componentInfo.setter](newValue[componentInfo.getter]());
    });
    return result2;
  },
  getLongestCaptionIndex(captionArray) {
    let longestIndex = 0;
    let longestCaptionLength = 0;
    let i;
    for (i = 0; i < captionArray.length; ++i) {
      if (captionArray[i].length > longestCaptionLength) {
        longestIndex = i;
        longestCaptionLength = captionArray[i].length;
      }
    }
    return longestIndex;
  },
  formatUsesMonthName: (format2) => date_default3.formatUsesMonthName(format2),
  formatUsesDayName: (format2) => date_default3.formatUsesDayName(format2),
  getLongestDate(format2, monthNames, dayNames) {
    const stringFormat = getStringFormat(format2);
    let month = 9;
    if (!stringFormat || dateUtils2.formatUsesMonthName(stringFormat)) {
      month = dateUtils2.getLongestCaptionIndex(monthNames);
    }
    const longestDate = new Date(1888, month, 21, 23, 59, 59, 999);
    if (!stringFormat || dateUtils2.formatUsesDayName(stringFormat)) {
      const date = longestDate.getDate() - longestDate.getDay() + dateUtils2.getLongestCaptionIndex(dayNames);
      longestDate.setDate(date);
    }
    return longestDate;
  },
  normalizeTime(date) {
    date.setSeconds(0);
    date.setMilliseconds(0);
  }
};
dateUtils2.DATE_COMPONENTS_INFO = {
  year: {
    getter: "getFullYear",
    setter: "setFullYear",
    formatter(value2, date) {
      const formatDate2 = new Date(date.getTime());
      formatDate2.setFullYear(value2);
      return date_default3.format(formatDate2, "yyyy");
    },
    startValue: void 0,
    endValue: void 0
  },
  day: {
    getter: "getDate",
    setter: "setDate",
    formatter(value2, date) {
      const formatDate2 = new Date(date.getTime());
      formatDate2.setDate(value2);
      return date_default3.format(formatDate2, "d");
    },
    startValue: 1,
    endValue: void 0
  },
  month: {
    getter: "getMonth",
    setter: "setMonth",
    formatter: (value2) => date_default3.getMonthNames()[value2],
    startValue: 0,
    endValue: 11
  },
  hours: {
    getter: "getHours",
    setter: "setHours",
    formatter: (value2) => date_default3.format(new Date(0, 0, 0, value2), "hour"),
    startValue: 0,
    endValue: 23
  },
  minutes: {
    getter: "getMinutes",
    setter: "setMinutes",
    formatter: (value2) => date_default3.format(new Date(0, 0, 0, 0, value2), "minute"),
    startValue: 0,
    endValue: 59
  },
  seconds: {
    getter: "getSeconds",
    setter: "setSeconds",
    formatter: (value2) => date_default3.format(new Date(0, 0, 0, 0, 0, value2), "second"),
    startValue: 0,
    endValue: 59
  },
  milliseconds: {
    getter: "getMilliseconds",
    setter: "setMilliseconds",
    formatter: (value2) => date_default3.format(new Date(0, 0, 0, 0, 0, 0, value2), "millisecond"),
    startValue: 0,
    endValue: 999
  }
};
var m_date_utils_default = dateUtils2;

// ../../../../../../node_modules/devextreme/esm/__internal/events/dblclick.js
var DBLCLICK_EVENT_NAME = "dxdblclick";
var NAMESPACED_CLICK_EVENT = addNamespace2(CLICK_EVENT_NAME, "dxDblClick");
var DblClick = class_default.inherit({
  ctor() {
    this._handlerCount = 0;
    this._forgetLastClick();
  },
  _forgetLastClick() {
    this._firstClickTarget = null;
    this._lastClickTimeStamp = -300;
  },
  add() {
    if (this._handlerCount <= 0) {
      events_engine_default.on(dom_adapter_default.getDocument(), NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this));
    }
    this._handlerCount += 1;
  },
  _clickHandler(e) {
    const timeStamp = e.timeStamp || Date.now();
    const timeBetweenClicks = timeStamp - this._lastClickTimeStamp;
    const isSimulated = timeBetweenClicks < 0;
    const isDouble = !isSimulated && timeBetweenClicks < 300;
    if (isDouble) {
      fireEvent({
        type: "dxdblclick",
        target: closestCommonParent(this._firstClickTarget, e.target),
        originalEvent: e
      });
      this._forgetLastClick();
    } else {
      this._firstClickTarget = e.target;
      this._lastClickTimeStamp = timeStamp;
      clearTimeout(this._lastClickClearTimeout);
      this._lastClickClearTimeout = setTimeout(() => {
        this._forgetLastClick();
      }, 600);
    }
  },
  remove() {
    this._handlerCount -= 1;
    if (this._handlerCount <= 0) {
      this._forgetLastClick();
      events_engine_default.off(dom_adapter_default.getDocument(), NAMESPACED_CLICK_EVENT, void 0);
      clearTimeout(this._lastClickClearTimeout);
      this._handlerCount = 0;
    }
  }
});
var dblClick = new DblClick();

// ../../../../../../node_modules/devextreme/esm/events/double_click.js
event_registrator_default(DBLCLICK_EVENT_NAME, dblClick);

// ../../../../../../node_modules/devextreme/esm/ui/text_box/ui.text_editor.js
var ui_text_editor_default = m_text_editor_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.spin.js
var SPIN_CLASS = "dx-numberbox-spin";
var SPIN_BUTTON_CLASS = "dx-numberbox-spin-button";
var NUMBER_BOX = "dxNumberBox";
var POINTERUP_EVENT_NAME = addNamespace2(pointer_default.up, NUMBER_BOX);
var POINTERCANCEL_EVENT_NAME = addNamespace2(pointer_default.cancel, NUMBER_BOX);
var SpinButton = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      direction: "up",
      onChange: null,
      activeStateEnabled: true,
      hoverStateEnabled: true
    });
  },
  _initMarkup() {
    this.callBase();
    const direction = `${SPIN_CLASS}-${this.option("direction")}`;
    this.$element().addClass(SPIN_BUTTON_CLASS).addClass(direction);
    this._spinIcon = renderer_default("<div>").addClass(`${direction}-icon`).appendTo(this.$element());
  },
  _render() {
    this.callBase();
    const eventName = addNamespace2(pointer_default.down, this.NAME);
    const $element = this.$element();
    events_engine_default.off($element, eventName);
    events_engine_default.on($element, eventName, this._spinDownHandler.bind(this));
    this._spinChangeHandler = this._createActionByOption("onChange");
  },
  _spinDownHandler(e) {
    e.preventDefault();
    this._clearTimer();
    events_engine_default.on(this.$element(), hold_default.name, () => {
      this._feedBackDeferred = Deferred();
      lock(this._feedBackDeferred);
      this._spinChangeHandler({
        event: e
      });
      this._holdTimer = setInterval(this._spinChangeHandler, 100, {
        event: e
      });
    });
    const document2 = dom_adapter_default.getDocument();
    events_engine_default.on(document2, POINTERUP_EVENT_NAME, this._clearTimer.bind(this));
    events_engine_default.on(document2, POINTERCANCEL_EVENT_NAME, this._clearTimer.bind(this));
    this._spinChangeHandler({
      event: e
    });
  },
  _dispose() {
    this._clearTimer();
    this.callBase();
  },
  _clearTimer() {
    events_engine_default.off(this.$element(), hold_default.name);
    const document2 = dom_adapter_default.getDocument();
    events_engine_default.off(document2, POINTERUP_EVENT_NAME);
    events_engine_default.off(document2, POINTERCANCEL_EVENT_NAME);
    if (this._feedBackDeferred) {
      this._feedBackDeferred.resolve();
    }
    if (this._holdTimer) {
      clearInterval(this._holdTimer);
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "onChange":
      case "direction":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  }
});
var m_number_box_spin_default = SpinButton;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.spins.js
var SPIN_CLASS2 = "dx-numberbox-spin";
var SPIN_CONTAINER_CLASS = "dx-numberbox-spin-container";
var SPIN_TOUCH_FRIENDLY_CLASS = "dx-numberbox-spin-touch-friendly";
var SpinButtons = class extends TextEditorButton {
  _attachEvents(instance, $spinContainer) {
    const {
      editor
    } = this;
    const eventName = addNamespace2(pointer_default.down, editor.NAME);
    const $spinContainerChildren = $spinContainer.children();
    const pointerDownAction = editor._createAction((e) => editor._spinButtonsPointerDownHandler(e));
    events_engine_default.off($spinContainer, eventName);
    events_engine_default.on($spinContainer, eventName, (e) => pointerDownAction({
      event: e
    }));
    m_number_box_spin_default.getInstance($spinContainerChildren.eq(0)).option("onChange", (e) => editor._spinUpChangeHandler(e));
    m_number_box_spin_default.getInstance($spinContainerChildren.eq(1)).option("onChange", (e) => editor._spinDownChangeHandler(e));
  }
  _create() {
    const {
      editor
    } = this;
    const $spinContainer = renderer_default("<div>").addClass(SPIN_CONTAINER_CLASS);
    const $spinUp = renderer_default("<div>").appendTo($spinContainer);
    const $spinDown = renderer_default("<div>").appendTo($spinContainer);
    const options2 = this._getOptions();
    this._addToContainer($spinContainer);
    editor._createComponent($spinUp, m_number_box_spin_default, extend({
      direction: "up"
    }, options2));
    editor._createComponent($spinDown, m_number_box_spin_default, extend({
      direction: "down"
    }, options2));
    this._legacyRender(editor.$element(), this._isTouchFriendly(), options2.visible);
    return {
      instance: $spinContainer,
      $element: $spinContainer
    };
  }
  _getOptions() {
    const {
      editor
    } = this;
    const visible2 = this._isVisible();
    const disabled = editor.option("disabled");
    return {
      visible: visible2,
      disabled
    };
  }
  _isVisible() {
    const {
      editor
    } = this;
    return super._isVisible() && editor.option("showSpinButtons");
  }
  _isTouchFriendly() {
    const {
      editor
    } = this;
    return editor.option("showSpinButtons") && editor.option("useLargeSpinButtons");
  }
  _legacyRender($editor, isTouchFriendly, isVisible2) {
    $editor.toggleClass(SPIN_TOUCH_FRIENDLY_CLASS, isTouchFriendly);
    $editor.toggleClass(SPIN_CLASS2, isVisible2);
  }
  update() {
    const shouldUpdate = super.update();
    if (shouldUpdate) {
      const {
        editor,
        instance
      } = this;
      const $editor = editor.$element();
      const isVisible2 = this._isVisible();
      const isTouchFriendly = this._isTouchFriendly();
      const $spinButtons = instance.children();
      const spinUp = m_number_box_spin_default.getInstance($spinButtons.eq(0));
      const spinDown = m_number_box_spin_default.getInstance($spinButtons.eq(1));
      const options2 = this._getOptions();
      spinUp.option(options2);
      spinDown.option(options2);
      this._legacyRender($editor, isTouchFriendly, isVisible2);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.base.js
var math = Math;
var WIDGET_CLASS = "dx-numberbox";
var FIREFOX_CONTROL_KEYS = ["tab", "del", "backspace", "leftArrow", "rightArrow", "home", "end", "enter"];
var NumberBoxBase = ui_text_editor_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), {
      upArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          this._spinUpChangeHandler(e);
        }
      },
      downArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          this._spinDownChangeHandler(e);
        }
      },
      enter() {
      }
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: 0,
      min: void 0,
      max: void 0,
      step: 1,
      showSpinButtons: false,
      useLargeSpinButtons: true,
      mode: "text",
      invalidValueMessage: message_default.format("dxNumberBox-invalidValueMessage"),
      buttons: void 0
    });
  },
  _useTemplates: () => false,
  _getDefaultButtons() {
    return this.callBase().concat([{
      name: "spins",
      Ctor: SpinButtons
    }]);
  },
  _isSupportInputMode() {
    const version3 = parseFloat(browser_default.version);
    return browser_default.chrome && version3 >= 66 || browser_default.safari && version3 >= 12;
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => devices_default.real().generic && !devices_default.isSimulator(),
      options: {
        useLargeSpinButtons: false
      }
    }, {
      device: (function() {
        return "desktop" !== devices_default.real().deviceType && !this._isSupportInputMode();
      }).bind(this),
      options: {
        mode: "number"
      }
    }]);
  },
  _initMarkup() {
    this._renderSubmitElement();
    this.$element().addClass(WIDGET_CLASS);
    this.callBase();
  },
  _getDefaultAttributes() {
    const attributes = this.callBase();
    attributes.inputmode = "decimal";
    return attributes;
  },
  _renderContentImpl() {
    this.option("isValid") && this._validateValue(this.option("value"));
    this.setAria("role", "spinbutton");
  },
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    this._setSubmitValue(this.option("value"));
  },
  _setSubmitValue(value2) {
    this._getSubmitElement().val(applyServerDecimalSeparator(value2));
  },
  _getSubmitElement() {
    return this._$submitElement;
  },
  _keyPressHandler(e) {
    this.callBase(e);
    const char = getChar(e);
    const isInputCharValid = /[\d.,eE\-+]/.test(char);
    if (!isInputCharValid) {
      const keyName = normalizeKeyName(e);
      if (isCommandKeyPressed(e) || keyName && FIREFOX_CONTROL_KEYS.includes(keyName)) {
        return;
      }
      e.preventDefault();
      return false;
    }
    this._keyPressed = true;
  },
  _onMouseWheel(dxEvent) {
    dxEvent.delta > 0 ? this._spinValueChange(1, dxEvent) : this._spinValueChange(-1, dxEvent);
  },
  _renderValue() {
    const inputValue = this._input().val();
    const value2 = this.option("value");
    if (!inputValue.length || Number(inputValue) !== value2) {
      this._forceValueRender();
      this._toggleEmptinessEventHandler();
    }
    const valueText = isDefined(value2) ? null : message_default.format("dxNumberBox-noDataText");
    this.setAria({
      valuenow: ensureDefined(value2, ""),
      valuetext: valueText
    });
    this.option("text", this._input().val());
    this._updateButtons();
    return Deferred().resolve();
  },
  _forceValueRender() {
    const value2 = this.option("value");
    const number = Number(value2);
    const formattedValue = isNaN(number) ? "" : this._applyDisplayValueFormatter(value2);
    this._renderDisplayText(formattedValue);
  },
  _applyDisplayValueFormatter(value2) {
    return this.option("displayValueFormatter")(value2);
  },
  _renderProps() {
    this._input().prop({
      min: this.option("min"),
      max: this.option("max"),
      step: this.option("step")
    });
    this.setAria({
      valuemin: ensureDefined(this.option("min"), ""),
      valuemax: ensureDefined(this.option("max"), "")
    });
  },
  _spinButtonsPointerDownHandler() {
    const $input = this._input();
    if (!this.option("useLargeSpinButtons") && dom_adapter_default.getActiveElement() !== $input[0]) {
      events_engine_default.trigger($input, "focus");
    }
  },
  _spinUpChangeHandler(e) {
    if (!this.option("readOnly")) {
      this._spinValueChange(1, e.event || e);
    }
  },
  _spinDownChangeHandler(e) {
    if (!this.option("readOnly")) {
      this._spinValueChange(-1, e.event || e);
    }
  },
  _spinValueChange(sign2, dxEvent) {
    const step = parseFloat(this.option("step"));
    if (0 === step) {
      return;
    }
    let value2 = parseFloat(this._normalizeInputValue()) || 0;
    value2 = this._correctRounding(value2, step * sign2);
    const min = this.option("min");
    const max = this.option("max");
    if (isDefined(min)) {
      value2 = Math.max(min, value2);
    }
    if (isDefined(max)) {
      value2 = Math.min(max, value2);
    }
    this._saveValueChangeEvent(dxEvent);
    this.option("value", value2);
  },
  _correctRounding(value2, step) {
    const regex = /[,.](.*)/;
    const isFloatValue = regex.test(value2);
    const isFloatStep = regex.test(step);
    if (isFloatValue || isFloatStep) {
      const valueAccuracy = isFloatValue ? regex.exec(value2)[0].length : 0;
      const stepAccuracy = isFloatStep ? regex.exec(step)[0].length : 0;
      const accuracy = math.max(valueAccuracy, stepAccuracy);
      value2 = this._round(value2 + step, accuracy);
      return value2;
    }
    return value2 + step;
  },
  _round(value2, precision) {
    precision = precision || 0;
    const multiplier = 10 ** precision;
    value2 *= multiplier;
    value2 = Math.round(value2) / multiplier;
    return value2;
  },
  _renderValueChangeEvent() {
    this.callBase();
    const forceValueChangeEvent = addNamespace2("focusout", "NumberBoxForceValueChange");
    events_engine_default.off(this.element(), forceValueChangeEvent);
    events_engine_default.on(this.element(), forceValueChangeEvent, this._forceRefreshInputValue.bind(this));
  },
  _forceRefreshInputValue() {
    if ("number" === this.option("mode")) {
      return;
    }
    const $input = this._input();
    const formattedValue = this._applyDisplayValueFormatter(this.option("value"));
    $input.val(null);
    $input.val(formattedValue);
  },
  _valueChangeEventHandler(e) {
    const $input = this._input();
    const inputValue = this._normalizeText();
    const value2 = this._parseValue(inputValue);
    const valueHasDigits = "." !== inputValue && "-" !== inputValue;
    if (this._isValueValid() && !this._validateValue(value2)) {
      $input.val(this._applyDisplayValueFormatter(value2));
      return;
    }
    if (valueHasDigits) {
      this.callBase(e, isNaN(value2) ? null : value2);
    }
    this._applyValueBoundaries(inputValue, value2);
    this.validationRequest.fire({
      value: value2,
      editor: this
    });
  },
  _applyValueBoundaries(inputValue, parsedValue) {
    const isValueIncomplete = this._isValueIncomplete(inputValue);
    const isValueCorrect = this._isValueInRange(inputValue);
    if (!isValueIncomplete && !isValueCorrect && null !== parsedValue) {
      if (Number(inputValue) !== parsedValue) {
        this._input().val(this._applyDisplayValueFormatter(parsedValue));
      }
    }
  },
  _replaceCommaWithPoint: (value2) => value2.replace(",", "."),
  _inputIsInvalid() {
    const isNumberMode = "number" === this.option("mode");
    const validityState = this._input().get(0).validity;
    return isNumberMode && validityState && validityState.badInput;
  },
  _renderDisplayText(text) {
    if (this._inputIsInvalid()) {
      return;
    }
    this.callBase(text);
  },
  _isValueIncomplete: (value2) => /(^-$)|(^-?\d*\.$)|(\d+e-?$)/i.test(value2),
  _isValueInRange(value2) {
    return inRange(value2, this.option("min"), this.option("max"));
  },
  _isNumber(value2) {
    return null !== this._parseValue(value2);
  },
  _validateValue(value2) {
    const inputValue = this._normalizeText();
    const isValueValid = this._isValueValid();
    let isValid = true;
    const isNumber3 = this._isNumber(inputValue);
    if (isNaN(Number(value2))) {
      isValid = false;
    }
    if (!value2 && isValueValid) {
      isValid = true;
    } else if (!isNumber3 && !isValueValid) {
      isValid = false;
    }
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: this.option("invalidValueMessage")
      }
    });
    return isValid;
  },
  _normalizeInputValue() {
    return this._parseValue(this._normalizeText());
  },
  _normalizeText() {
    const value2 = this._input().val().trim();
    return this._replaceCommaWithPoint(value2);
  },
  _parseValue(value2) {
    const number = parseFloat(value2);
    if (isNaN(number)) {
      return null;
    }
    return fitIntoRange(number, this.option("min"), this.option("max"));
  },
  _clearValue() {
    if (this._inputIsInvalid()) {
      this._input().val("");
      this._validateValue();
    }
    this.callBase();
  },
  clear() {
    if (null === this.option("value")) {
      this.option("text", "");
      if (this._input().length) {
        this._renderValue();
      }
    } else {
      this.option("value", null);
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "value":
        this._validateValue(args.value);
        this._setSubmitValue(args.value);
        this.callBase(args);
        this._resumeValueChangeAction();
        break;
      case "step":
        this._renderProps();
        break;
      case "min":
      case "max":
        this._renderProps();
        this.option("value", this._parseValue(this.option("value")));
        break;
      case "showSpinButtons":
      case "useLargeSpinButtons":
        this._updateButtons(["spins"]);
        break;
      case "invalidValueMessage":
        break;
      default:
        this.callBase(args);
    }
  }
});
var m_number_box_base_default = NumberBoxBase;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_utils.js
var getRealSeparatorIndex = function(str) {
  let quoteBalance = 0;
  let separatorCount = 0;
  for (let i = 0; i < str.length; ++i) {
    if ("'" === str[i]) {
      quoteBalance++;
    }
    if ("." === str[i]) {
      ++separatorCount;
      if (quoteBalance % 2 === 0) {
        return {
          occurrence: separatorCount,
          index: i
        };
      }
    }
  }
  return {
    occurrence: 1,
    index: -1
  };
};
var getNthOccurrence = function(str, c, n) {
  let i = -1;
  while (n-- && i++ < str.length) {
    i = str.indexOf(c, i);
  }
  return i;
};
var splitByIndex = function(str, index2) {
  if (-1 === index2) {
    return [str];
  }
  return [str.slice(0, index2), str.slice(index2 + 1)];
};
var adjustPercentValue = function(rawValue, precision) {
  return rawValue && adjust(rawValue / 100, precision);
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.caret.js
var getCaretBoundaries = function(text, format2) {
  if ("string" === typeof format2) {
    const signParts = format2.split(";");
    const sign2 = number_default2.getSign(text, format2);
    signParts[1] = signParts[1] || `-${signParts[0]}`;
    format2 = signParts[sign2 < 0 ? 1 : 0];
    const mockEscapedStubs = (str) => str.replace(/'([^']*)'/g, (str2) => str2.split("").map(() => " ").join("").substr(2));
    format2 = mockEscapedStubs(format2);
    const prefixStubLength = /^[^#0.,]*/.exec(format2)[0].length;
    const postfixStubLength = /[^#0.,]*$/.exec(format2)[0].length;
    return {
      start: prefixStubLength,
      end: text.length - postfixStubLength
    };
  }
  return {
    start: 0,
    end: text.length
  };
};
var _getDigitCountBeforeIndex = function(index2, text) {
  const decimalSeparator = number_default2.getDecimalSeparator();
  const regExp = new RegExp(`[^0-9${escapeRegExp(decimalSeparator)}]`, "g");
  const textBeforePosition = text.slice(0, index2);
  return textBeforePosition.replace(regExp, "").length;
};
var _reverseText = function(text) {
  return text.split("").reverse().join("");
};
var _getDigitPositionByIndex = function(digitIndex, text) {
  if (!digitIndex) {
    return -1;
  }
  const regExp = /[0-9]/g;
  let counter = 1;
  let index2 = null;
  let result2 = regExp.exec(text);
  while (result2) {
    index2 = result2.index;
    if (counter >= digitIndex) {
      return index2;
    }
    counter++;
    result2 = regExp.exec(text);
  }
  return null === index2 ? text.length : index2;
};
var _trimNonNumericCharsFromEnd = function(text) {
  return text.replace(/[^0-9e]+$/, "");
};
var getCaretWithOffset = function(caret3, offset2) {
  if (void 0 === caret3.start) {
    caret3 = {
      start: caret3,
      end: caret3
    };
  }
  return {
    start: caret3.start + offset2,
    end: caret3.end + offset2
  };
};
var getCaretAfterFormat = function(text, formatted, caret3, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const point = number_default2.getDecimalSeparator();
  const isSeparatorBasedText = isSeparatorBasedString(text);
  const realSeparatorOccurrenceIndex = getRealSeparatorIndex(format2).occurrence;
  const pointPosition = isSeparatorBasedText ? 0 : getNthOccurrence(text, point, realSeparatorOccurrenceIndex);
  const newPointPosition = getNthOccurrence(formatted, point, realSeparatorOccurrenceIndex);
  const textParts = splitByIndex(text, pointPosition);
  const formattedParts = splitByIndex(formatted, newPointPosition);
  const isCaretOnFloat = -1 !== pointPosition && caret3.start > pointPosition;
  if (isCaretOnFloat) {
    const relativeIndex = caret3.start - pointPosition - 1;
    const digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);
    const newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;
    return getCaretInBoundaries(newPosition, formatted, format2);
  }
  const formattedIntPart = _trimNonNumericCharsFromEnd(formattedParts[0]);
  const positionFromEnd = textParts[0].length - caret3.start;
  const digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));
  const newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedIntPart));
  const newPositionFromBegin = formattedIntPart.length - (newPositionFromEnd + 1);
  return getCaretInBoundaries(newPositionFromBegin, formatted, format2);
};
function isSeparatorBasedString(text) {
  return 1 === text.length && !!text.match(/^[,.][0-9]*$/g);
}
var isCaretInBoundaries = function(caret3, text, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const boundaries = getCaretInBoundaries(caret3, text, format2);
  return caret3.start >= boundaries.start && caret3.end <= boundaries.end;
};
function getCaretInBoundaries(caret3, text, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const boundaries = getCaretBoundaries(text, format2);
  const adjustedCaret = {
    start: fitIntoRange(caret3.start, boundaries.start, boundaries.end),
    end: fitIntoRange(caret3.end, boundaries.start, boundaries.end)
  };
  return adjustedCaret;
}
var getCaretOffset = function(previousText, newText, format2) {
  const previousBoundaries = getCaretBoundaries(previousText, format2);
  const newBoundaries = getCaretBoundaries(newText, format2);
  return newBoundaries.start - previousBoundaries.start;
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.mask.js
var NumberBoxMask = m_number_box_base_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      useMaskBehavior: true,
      format: null
    });
  },
  _isDeleteKey: (key) => "del" === key,
  _supportedKeys() {
    if (!this._useMaskBehavior()) {
      return this.callBase();
    }
    return extend(this.callBase(), {
      minus: this._revertSign.bind(this),
      del: this._removeHandler.bind(this),
      backspace: this._removeHandler.bind(this),
      leftArrow: this._arrowHandler.bind(this, -1),
      rightArrow: this._arrowHandler.bind(this, 1),
      home: this._moveCaretToBoundaryEventHandler.bind(this, 1),
      enter: this._updateFormattedValue.bind(this),
      end: this._moveCaretToBoundaryEventHandler.bind(this, -1)
    });
  },
  _getTextSeparatorIndex(text) {
    const decimalSeparator = number_default2.getDecimalSeparator();
    const realSeparatorOccurrenceIndex = getRealSeparatorIndex(this.option("format")).occurrence;
    return getNthOccurrence(text, decimalSeparator, realSeparatorOccurrenceIndex);
  },
  _focusInHandler(e) {
    if (!this._preventNestedFocusEvent(e)) {
      this.clearCaretTimeout();
      this._caretTimeout = setTimeout(() => {
        this._caretTimeout = void 0;
        const caret3 = this._caret();
        if (caret3.start === caret3.end && this._useMaskBehavior()) {
          const text = this._getInputVal();
          const decimalSeparatorIndex = this._getTextSeparatorIndex(text);
          if (decimalSeparatorIndex >= 0) {
            this._caret({
              start: decimalSeparatorIndex,
              end: decimalSeparatorIndex
            });
          } else {
            this._moveCaretToBoundaryEventHandler(-1, e);
          }
        }
      }, 0);
    }
    this.callBase(e);
  },
  _focusOutHandler(e) {
    const shouldHandleEvent = !this._preventNestedFocusEvent(e);
    if (shouldHandleEvent) {
      this._focusOutOccurs = true;
      if (this._useMaskBehavior()) {
        this._updateFormattedValue();
      }
    }
    this.callBase(e);
    if (shouldHandleEvent) {
      this._focusOutOccurs = false;
    }
  },
  _hasValueBeenChanged(inputValue) {
    const format2 = this._getFormatPattern();
    const value2 = this.option("value");
    const formatted = this._format(value2, format2) || "";
    return formatted !== inputValue;
  },
  _updateFormattedValue() {
    const inputValue = this._getInputVal();
    if (this._hasValueBeenChanged(inputValue)) {
      this._updateParsedValue();
      this._adjustParsedValue();
      this._setTextByParsedValue();
      if (this._parsedValue !== this.option("value")) {
        events_engine_default.trigger(this._input(), "change");
      }
    }
  },
  _arrowHandler(step, e) {
    if (!this._useMaskBehavior()) {
      return;
    }
    const text = this._getInputVal();
    const format2 = this._getFormatPattern();
    let nextCaret = getCaretWithOffset(this._caret(), step);
    if (!isCaretInBoundaries(nextCaret, text, format2)) {
      nextCaret = 1 === step ? nextCaret.end : nextCaret.start;
      e.preventDefault();
      this._caret(getCaretInBoundaries(nextCaret, text, format2));
    }
  },
  _moveCaretToBoundary(direction) {
    const boundaries = getCaretBoundaries(this._getInputVal(), this._getFormatPattern());
    const newCaret = getCaretWithOffset(1 === direction ? boundaries.start : boundaries.end, 0);
    this._caret(newCaret);
  },
  _moveCaretToBoundaryEventHandler(direction, e) {
    if (!this._useMaskBehavior() || e && e.shiftKey) {
      return;
    }
    this._moveCaretToBoundary(direction);
    e && e.preventDefault();
  },
  _shouldMoveCaret(text, caret3) {
    const decimalSeparator = number_default2.getDecimalSeparator();
    const isDecimalSeparatorNext = text.charAt(caret3.end) === decimalSeparator;
    const moveToFloat = (this._lastKey === decimalSeparator || "." === this._lastKey || "," === this._lastKey) && isDecimalSeparatorNext;
    return moveToFloat;
  },
  _getInputVal() {
    return number_default2.convertDigits(this._input().val(), true);
  },
  _keyboardHandler(e) {
    this.clearCaretTimeout();
    this._lastKey = number_default2.convertDigits(getChar(e), true);
    this._lastKeyName = normalizeKeyName(e);
    if (!this._shouldHandleKey(e.originalEvent)) {
      return this.callBase(e);
    }
    const normalizedText = this._getInputVal();
    const caret3 = this._caret();
    let enteredChar;
    if ("minus" === this._lastKeyName) {
      enteredChar = "";
    } else {
      enteredChar = 110 === e.which ? number_default2.getDecimalSeparator() : this._lastKey;
    }
    const newValue = this._tryParse(normalizedText, caret3, enteredChar);
    if (this._shouldMoveCaret(normalizedText, caret3)) {
      this._moveCaret(1);
      e.originalEvent.preventDefault();
    }
    if (void 0 === newValue) {
      if ("minus" !== this._lastKeyName) {
        e.originalEvent.preventDefault();
      }
    } else {
      this._parsedValue = newValue;
    }
    return this.callBase(e);
  },
  _keyPressHandler(e) {
    if (!this._useMaskBehavior()) {
      this.callBase(e);
    }
  },
  _removeHandler(e) {
    const caret3 = this._caret();
    const text = this._getInputVal();
    let {
      start
    } = caret3;
    let {
      end
    } = caret3;
    this._lastKey = getChar(e);
    this._lastKeyName = normalizeKeyName(e);
    const isDeleteKey = this._isDeleteKey(this._lastKeyName);
    const isBackspaceKey = !isDeleteKey;
    if (start === end) {
      const caretPosition = start;
      const canDelete = isBackspaceKey && caretPosition > 0 || isDeleteKey && caretPosition < text.length;
      if (canDelete) {
        isDeleteKey && end++;
        isBackspaceKey && start--;
      } else {
        e.preventDefault();
        return;
      }
    }
    const char = text.slice(start, end);
    if (this._isStub(char)) {
      this._moveCaret(isDeleteKey ? 1 : -1);
      if (this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0) {
        this._revertSign(e);
        this._setTextByParsedValue();
        const shouldTriggerInputEvent = this.option("valueChangeEvent").split(" ").includes("input");
        if (shouldTriggerInputEvent) {
          events_engine_default.trigger(this._input(), "input");
        }
      }
      e.preventDefault();
      return;
    }
    const decimalSeparator = number_default2.getDecimalSeparator();
    if (char === decimalSeparator) {
      const decimalSeparatorIndex = text.indexOf(decimalSeparator);
      if (this._isNonStubAfter(decimalSeparatorIndex + 1)) {
        this._moveCaret(isDeleteKey ? 1 : -1);
        e.preventDefault();
      }
      return;
    }
    if (end - start < text.length) {
      const editedText = this._replaceSelectedText(text, {
        start,
        end
      }, "");
      const noDigits = editedText.search(/[0-9]/) < 0;
      if (noDigits && this._isValueInRange(0)) {
        this._parsedValue = this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0 ? -0 : 0;
        return;
      }
    }
    const valueAfterRemoving = this._tryParse(text, {
      start,
      end
    }, "");
    if (void 0 === valueAfterRemoving) {
      e.preventDefault();
    } else {
      this._parsedValue = valueAfterRemoving;
    }
  },
  _isPercentFormat() {
    const format2 = this._getFormatPattern();
    const noEscapedFormat = format2.replace(/'[^']+'/g, "");
    return -1 !== noEscapedFormat.indexOf("%");
  },
  _parse(text, format2) {
    const formatOption = this.option("format");
    const isCustomParser = isFunction(formatOption.parser);
    const parser = isCustomParser ? formatOption.parser : number_default2.parse;
    let integerPartStartIndex = 0;
    if (!isCustomParser) {
      const formatPointIndex = getRealSeparatorIndex(format2).index;
      const textPointIndex = this._getTextSeparatorIndex(text);
      const formatIntegerPartLength = -1 !== formatPointIndex ? formatPointIndex : format2.length;
      const textIntegerPartLength = -1 !== textPointIndex ? textPointIndex : text.length;
      if (textIntegerPartLength > formatIntegerPartLength && -1 === format2.indexOf("#")) {
        integerPartStartIndex = textIntegerPartLength - formatIntegerPartLength;
      }
    }
    text = text.substr(integerPartStartIndex);
    return parser(text, format2);
  },
  _format(value2, format2) {
    const formatOption = this.option("format");
    const customFormatter = (null === formatOption || void 0 === formatOption ? void 0 : formatOption.formatter) || formatOption;
    const formatter = isFunction(customFormatter) ? customFormatter : number_default2.format;
    const formattedValue = null === value2 ? "" : formatter(value2, format2);
    return formattedValue;
  },
  _getFormatPattern() {
    if (!this._currentFormat) {
      this._updateFormat();
    }
    return this._currentFormat;
  },
  _updateFormat() {
    const format2 = this.option("format");
    const isCustomParser = isFunction(null === format2 || void 0 === format2 ? void 0 : format2.parser);
    const isLDMLPattern = isString(format2) && (format2.includes("0") || format2.includes("#"));
    const isExponentialFormat = "exponential" === format2 || "exponential" === (null === format2 || void 0 === format2 ? void 0 : format2.type);
    const shouldUseFormatAsIs = isCustomParser || isLDMLPattern || isExponentialFormat;
    this._currentFormat = shouldUseFormatAsIs ? format2 : getFormat((value2) => {
      const text = this._format(value2, format2);
      return number_default2.convertDigits(text, true);
    });
  },
  _getFormatForSign(text) {
    const format2 = this._getFormatPattern();
    if (isString(format2)) {
      const signParts = format2.split(";");
      const sign3 = number_default2.getSign(text, format2);
      signParts[1] = signParts[1] || `-${signParts[0]}`;
      return sign3 < 0 ? signParts[1] : signParts[0];
    }
    const sign2 = number_default2.getSign(text);
    return sign2 < 0 ? "-" : "";
  },
  _removeStubs(text, excludeComma) {
    const format2 = this._getFormatForSign(text);
    const thousandsSeparator = number_default2.getThousandsSeparator();
    const stubs = this._getStubs(format2);
    let result2 = text;
    if (stubs.length) {
      const prefixStubs = stubs[0];
      const postfixRegex = new RegExp(`(${escapeRegExp(stubs[1] || "")})$`, "g");
      const decoratorsRegex = new RegExp(`[-${escapeRegExp(excludeComma ? "" : thousandsSeparator)}]`, "g");
      result2 = result2.replace(prefixStubs, "").replace(postfixRegex, "").replace(decoratorsRegex, "");
    }
    return result2;
  },
  _getStubs(format2) {
    const regExpResult = /[^']([#0.,]+)/g.exec(format2);
    const pattern = regExpResult && regExpResult[0].trim();
    return format2.split(pattern).map((stub) => stub.replace(/'/g, ""));
  },
  _truncateToPrecision(value2, maxPrecision) {
    if (isDefined(value2)) {
      const strValue = value2.toString();
      const decimalSeparatorIndex = strValue.indexOf(".");
      if (strValue && decimalSeparatorIndex > -1) {
        const parsedValue = parseFloat(strValue.substr(0, decimalSeparatorIndex + maxPrecision + 1));
        return isNaN(parsedValue) ? value2 : parsedValue;
      }
    }
    return value2;
  },
  _tryParse(text, selection, char) {
    const isTextSelected = selection.start !== selection.end;
    const isWholeTextSelected = isTextSelected && 0 === selection.start && selection.end === text.length;
    const decimalSeparator = number_default2.getDecimalSeparator();
    if (isWholeTextSelected && char === decimalSeparator) {
      return 0;
    }
    const editedText = this._replaceSelectedText(text, selection, char);
    const format2 = this._getFormatPattern();
    let parsedValue = this._getParsedValue(editedText, format2);
    const maxPrecision = !format2.parser && this._getPrecisionLimits(editedText).max;
    const isValueChanged = parsedValue !== this._parsedValue;
    const isDecimalPointRestricted = char === decimalSeparator && 0 === maxPrecision;
    const isUselessCharRestricted = !isTextSelected && !isValueChanged && "-" !== char && this._isStub(char);
    if (isDecimalPointRestricted || isUselessCharRestricted) {
      return;
    }
    if ("" === this._removeStubs(editedText)) {
      parsedValue = Math.abs(0 * this._parsedValue);
    }
    if (isNaN(parsedValue)) {
      return;
    }
    const value2 = null === parsedValue ? this._parsedValue : parsedValue;
    parsedValue = maxPrecision ? this._truncateToPrecision(value2, maxPrecision) : parsedValue;
    return !format2.parser && this._isPercentFormat() ? adjustPercentValue(parsedValue, maxPrecision) : parsedValue;
  },
  _getParsedValue(text, format2) {
    const sign2 = number_default2.getSign(text, (null === format2 || void 0 === format2 ? void 0 : format2.formatter) || format2);
    const textWithoutStubs = this._removeStubs(text, true);
    const parsedValue = this._parse(textWithoutStubs, format2);
    const parsedValueSign = parsedValue < 0 ? -1 : 1;
    const parsedValueWithSign = isNumeric(parsedValue) && sign2 !== parsedValueSign ? sign2 * parsedValue : parsedValue;
    return parsedValueWithSign;
  },
  _isValueIncomplete(text) {
    if (!this._useMaskBehavior()) {
      return this.callBase(text);
    }
    const caret3 = this._caret();
    const point = number_default2.getDecimalSeparator();
    const pointIndex = this._getTextSeparatorIndex(text);
    const isCaretOnFloat = pointIndex >= 0 && pointIndex < caret3.start;
    const textParts = this._removeStubs(text, true).split(point);
    if (!isCaretOnFloat || 2 !== textParts.length) {
      return false;
    }
    const floatLength = textParts[1].length;
    const format2 = this._getFormatPattern();
    const isCustomParser = !!format2.parser;
    const precision = !isCustomParser && this._getPrecisionLimits(this._getFormatPattern(), text);
    const isPrecisionInRange = isCustomParser ? true : inRange(floatLength, precision.min, precision.max);
    const endsWithZero = "0" === textParts[1].charAt(floatLength - 1);
    return isPrecisionInRange && (endsWithZero || !floatLength);
  },
  _isValueInRange(value2) {
    const min = ensureDefined(this.option("min"), -1 / 0);
    const max = ensureDefined(this.option("max"), 1 / 0);
    return inRange(value2, min, max);
  },
  _setInputText(text) {
    const normalizedText = number_default2.convertDigits(text, true);
    const newCaret = getCaretAfterFormat(this._getInputVal(), normalizedText, this._caret(), this._getFormatPattern());
    this._input().val(text);
    this._toggleEmptinessEventHandler();
    this._formattedValue = text;
    if (!this._focusOutOccurs) {
      this._caret(newCaret);
    }
  },
  _useMaskBehavior() {
    return !!this.option("format") && this.option("useMaskBehavior");
  },
  _renderInputType() {
    const isNumberType = "number" === this.option("mode");
    const isDesktop = "desktop" === devices_default.real().deviceType;
    if (this._useMaskBehavior() && isNumberType) {
      this._setInputType(isDesktop || this._isSupportInputMode() ? "text" : "tel");
    } else {
      this.callBase();
    }
  },
  _isChar: (str) => isString(str) && 1 === str.length,
  _moveCaret(offset2) {
    if (!offset2) {
      return;
    }
    const newCaret = getCaretWithOffset(this._caret(), offset2);
    const adjustedCaret = getCaretInBoundaries(newCaret, this._getInputVal(), this._getFormatPattern());
    this._caret(adjustedCaret);
  },
  _shouldHandleKey(e) {
    const keyName = normalizeKeyName(e);
    const isSpecialChar = isCommandKeyPressed(e) || e.altKey || e.shiftKey || !this._isChar(keyName);
    const isMinusKey = "minus" === keyName;
    const useMaskBehavior = this._useMaskBehavior();
    return useMaskBehavior && !isSpecialChar && !isMinusKey;
  },
  _renderInput() {
    this.callBase();
    this._renderFormatter();
  },
  _renderFormatter() {
    this._clearCache();
    this._detachFormatterEvents();
    if (this._useMaskBehavior()) {
      this._attachFormatterEvents();
    }
  },
  _detachFormatterEvents() {
    events_engine_default.off(this._input(), ".dxNumberFormatter");
  },
  _isInputFromPaste(e) {
    const inputType2 = e.originalEvent && e.originalEvent.inputType;
    if (isDefined(inputType2)) {
      return "insertFromPaste" === inputType2;
    }
    return this._isValuePasted;
  },
  _attachFormatterEvents() {
    const $input = this._input();
    events_engine_default.on($input, addNamespace2("input", "dxNumberFormatter"), (e) => {
      this._formatValue(e);
      this._isValuePasted = false;
    });
    events_engine_default.on($input, addNamespace2("dxclick", "dxNumberFormatter"), () => {
      if (!this._caretTimeout) {
        this._caretTimeout = setTimeout(() => {
          this._caretTimeout = void 0;
          this._caret(getCaretInBoundaries(this._caret(), this._getInputVal(), this._getFormatPattern()));
        }, 0);
      }
    });
    events_engine_default.on($input, DBLCLICK_EVENT_NAME, () => {
      this.clearCaretTimeout();
    });
  },
  clearCaretTimeout() {
    clearTimeout(this._caretTimeout);
    this._caretTimeout = void 0;
  },
  _forceRefreshInputValue() {
    if (!this._useMaskBehavior()) {
      return this.callBase();
    }
  },
  _isNonStubAfter(index2) {
    const text = this._getInputVal().slice(index2);
    return text && !this._isStub(text, true);
  },
  _isStub(str, isString4) {
    const escapedDecimalSeparator = escapeRegExp(number_default2.getDecimalSeparator());
    const regExpString = `^[^0-9${escapedDecimalSeparator}]+$`;
    const stubRegExp = new RegExp(regExpString, "g");
    return stubRegExp.test(str) && (isString4 || this._isChar(str));
  },
  _parseValue(text) {
    if (!this._useMaskBehavior()) {
      return this.callBase(text);
    }
    return this._parsedValue;
  },
  _getPrecisionLimits(text) {
    const currentFormat = this._getFormatForSign(text);
    const realSeparatorIndex = getRealSeparatorIndex(currentFormat).index;
    const floatPart = (splitByIndex(currentFormat, realSeparatorIndex)[1] || "").replace(/[^#0]/g, "");
    const minPrecision = floatPart.replace(/^(0*)#*/, "$1").length;
    const maxPrecision = floatPart.length;
    return {
      min: minPrecision,
      max: maxPrecision
    };
  },
  _revertSign(e) {
    if (!this._useMaskBehavior()) {
      return;
    }
    const caret3 = this._caret();
    if (caret3.start !== caret3.end) {
      if ("minus" === normalizeKeyName(e)) {
        this._applyRevertedSign(e, caret3, true);
        return;
      }
      this._caret(getCaretInBoundaries(0, this._getInputVal(), this._getFormatPattern()));
    }
    this._applyRevertedSign(e, caret3);
  },
  _applyRevertedSign(e, caret3, preserveSelectedText) {
    const newValue = -1 * ensureDefined(this._parsedValue, null);
    if (this._isValueInRange(newValue) || 0 === newValue) {
      this._parsedValue = newValue;
      if (preserveSelectedText) {
        const format2 = this._getFormatPattern();
        const previousText = this._getInputVal();
        this._setTextByParsedValue();
        e.preventDefault();
        const currentText = this._getInputVal();
        const offset2 = getCaretOffset(previousText, currentText, format2);
        caret3 = getCaretWithOffset(caret3, offset2);
        const caretInBoundaries = getCaretInBoundaries(caret3, currentText, format2);
        this._caret(caretInBoundaries);
      }
    }
  },
  _removeMinusFromText(text, caret3) {
    const isMinusPressed = "minus" === this._lastKeyName && "-" === text.charAt(caret3.start - 1);
    return isMinusPressed ? this._replaceSelectedText(text, {
      start: caret3.start - 1,
      end: caret3.start
    }, "") : text;
  },
  _setTextByParsedValue() {
    const format2 = this._getFormatPattern();
    const parsed = this._parseValue();
    const formatted = this._format(parsed, format2) || "";
    this._setInputText(formatted);
  },
  _formatValue(e) {
    let normalizedText = this._getInputVal();
    const caret3 = this._caret();
    const textWithoutMinus = this._removeMinusFromText(normalizedText, caret3);
    const wasMinusRemoved = textWithoutMinus !== normalizedText;
    normalizedText = textWithoutMinus;
    if (!this._isInputFromPaste(e) && this._isValueIncomplete(textWithoutMinus)) {
      this._formattedValue = normalizedText;
      if (wasMinusRemoved) {
        this._setTextByParsedValue();
      }
      return;
    }
    const textWasChanged = number_default2.convertDigits(this._formattedValue, true) !== normalizedText;
    if (textWasChanged) {
      const value2 = this._tryParse(normalizedText, caret3, "");
      if (isDefined(value2)) {
        this._parsedValue = value2;
      }
    }
    this._setTextByParsedValue();
  },
  _renderDisplayText() {
    if (this._useMaskBehavior()) {
      this._toggleEmptinessEventHandler();
    } else {
      this.callBase.apply(this, arguments);
    }
  },
  _renderValue() {
    if (this._useMaskBehavior()) {
      this._parsedValue = this.option("value");
      this._setTextByParsedValue();
    }
    return this.callBase();
  },
  _updateParsedValue() {
    const inputValue = this._getInputVal();
    this._parsedValue = this._tryParse(inputValue, this._caret());
  },
  _adjustParsedValue() {
    if (!this._useMaskBehavior()) {
      return;
    }
    const clearedText = this._removeStubs(this._getInputVal());
    const parsedValue = clearedText ? this._parseValue() : null;
    if (!isNumeric(parsedValue)) {
      this._parsedValue = parsedValue;
      return;
    }
    this._parsedValue = fitIntoRange(parsedValue, this.option("min"), this.option("max"));
  },
  _valueChangeEventHandler(e) {
    if (!this._useMaskBehavior()) {
      return this.callBase(e);
    }
    const caret3 = this._caret();
    this._saveValueChangeEvent(e);
    this._lastKey = null;
    this._lastKeyName = null;
    this._updateParsedValue();
    this._adjustParsedValue();
    this.option("value", this._parsedValue);
    if (caret3) {
      this._caret(caret3);
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "format":
      case "useMaskBehavior":
        this._renderInputType();
        this._updateFormat();
        this._renderFormatter();
        this._renderValue();
        this._refreshValueChangeEvent();
        this._refreshEvents();
        break;
      case "min":
      case "max":
        this._adjustParsedValue();
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  },
  _clearCache() {
    delete this._formattedValue;
    delete this._lastKey;
    delete this._lastKeyName;
    delete this._parsedValue;
    delete this._focusOutOccurs;
    clearTimeout(this._caretTimeout);
    delete this._caretTimeout;
  },
  _clean() {
    this._clearCache();
    this.callBase();
  }
});
var m_number_box_mask_default = NumberBoxMask;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.js
component_registrator_default("dxNumberBox", m_number_box_mask_default);
var m_number_box_default = m_number_box_mask_default;

// ../../../../../../node_modules/devextreme/esm/ui/number_box.js
var number_box_default = m_number_box_default;

// ../../../../../../node_modules/devextreme/esm/renovation/utils/dom.js
function querySelectorInSameDocument(el, selector) {
  var _el$getRootNode;
  const root = (null === (_el$getRootNode = el.getRootNode) || void 0 === _el$getRootNode ? void 0 : _el$getRootNode.call(el)) ?? document;
  return root.querySelector(selector);
}

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/editors/editor.js
var INVALID_MESSAGE_AUTO3 = "dx-invalid-message-auto";
var VALIDATION_TARGET2 = "dx-validation-target";
var Editor2 = class extends component_default {
  getProps() {
    const props = super.getProps();
    props.onFocusIn = () => {
      const isValidationMessageShownOnFocus = "auto" === this.option("validationMessageMode");
      if (isValidationMessageShownOnFocus) {
        const $validationMessageWrapper = renderer_default(querySelectorInSameDocument(this.element(), ".dx-invalid-message.dx-overlay-wrapper"));
        null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO3);
        const timeToWaitBeforeShow = 150;
        if (this.showValidationMessageTimeout) {
          clearTimeout(this.showValidationMessageTimeout);
        }
        this.showValidationMessageTimeout = setTimeout(() => {
          null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO3);
        }, timeToWaitBeforeShow);
      }
    };
    props.saveValueChangeEvent = (e) => {
      this._valueChangeEventInstance = e;
    };
    return props;
  }
  _createElement(element) {
    super._createElement(element);
    this.showValidationMessageTimeout = void 0;
    this.validationRequest = callbacks_default();
    data(this.$element()[0], VALIDATION_TARGET2, this);
  }
  _render() {
    var _this$option;
    null === (_this$option = this.option("_onMarkupRendered")) || void 0 === _this$option || _this$option();
  }
  _init() {
    super._init();
    this._initialValue = this.option("value");
  }
  _initializeComponent() {
    super._initializeComponent();
    this._valueChangeAction = this._createActionByOption("onValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initOptions(options2) {
    super._initOptions(options2);
    this.option(validation_engine_default.initValidationOptions(options2));
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {}
    });
  }
  _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    const innerWidgetOptions = extend({}, innerWidget.option());
    const syncOptions = () => this._silent(optionsContainer, innerWidgetOptions);
    syncOptions();
    innerWidget.on("optionChanged", syncOptions);
  }
  _raiseValidation(value2, previousValue) {
    const areValuesEmpty = !isDefined(value2) && !isDefined(previousValue);
    if (value2 !== previousValue && !areValuesEmpty) {
      this.validationRequest.fire({
        value: value2,
        editor: this
      });
    }
  }
  _raiseValueChangeAction(value2, previousValue) {
    var _this$_valueChangeAct;
    null === (_this$_valueChangeAct = this._valueChangeAction) || void 0 === _this$_valueChangeAct || _this$_valueChangeAct.call(this, {
      element: this.$element(),
      previousValue,
      value: value2,
      event: this._valueChangeEventInstance
    });
    this._valueChangeEventInstance = void 0;
  }
  _optionChanged(option) {
    const {
      name: name2,
      previousValue,
      value: value2
    } = option;
    if (name2 && void 0 !== this._getActionConfigs()[name2]) {
      this._addAction(name2);
    }
    switch (name2) {
      case "value":
        this._raiseValidation(value2, previousValue);
        this.option("isDirty", this._initialValue !== value2);
        this._raiseValueChangeAction(value2, previousValue);
        break;
      case "onValueChanged":
        this._valueChangeAction = this._createActionByOption("onValueChanged", {
          excludeValidators: ["disabled", "readOnly"]
        });
        break;
      case "isValid":
      case "validationError":
      case "validationErrors":
      case "validationStatus":
        this.option(validation_engine_default.synchronizeValidationOptions(option, this.option()));
    }
    super._optionChanged(option);
  }
  clear() {
    const {
      value: value2
    } = this._getDefaultOptions();
    this.option({
      value: value2
    });
  }
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      this._initialValue = value2;
    }
    this.option("value", this._initialValue);
    this.option("isDirty", false);
    this.option("isValid", true);
  }
  _dispose() {
    super._dispose();
    data(this.element(), VALIDATION_TARGET2, null);
    if (this.showValidationMessageTimeout) {
      clearTimeout(this.showValidationMessageTimeout);
    }
  }
};
var prevIsEditor = editor_default.isEditor;
var newIsEditor = (instance) => prevIsEditor(instance) || instance instanceof Editor2;
Editor2.isEditor = newIsEditor;
editor_default.isEditor = newIsEditor;

// ../../../../../../node_modules/devextreme/esm/renovation/component_wrapper/editors/check_box.js
var CheckBox = class extends Editor2 {
  _useTemplates() {
    return false;
  }
  _isFocused() {
    const focusTarget = this.$element()[0];
    return focusTarget.classList.contains("dx-state-focused");
  }
  getSupportedKeyNames() {
    return ["space"];
  }
  getProps() {
    const props = super.getProps();
    if (null !== props.value) {
      props.value = Boolean(props.value);
    }
    return props;
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/utils/get_updated_options.js
var defaultNotDeepCopyArrays = ["dataSource", "selectedRowKeys"];
var propsToIgnore = {
  integrationOptions: true
};
function getDiffItem(key, value2, previousValue) {
  return {
    path: key,
    value: value2,
    previousValue
  };
}
function compare2(resultPaths, item1, item2, key, fullPropName, notDeepCopyArrays) {
  if (propsToIgnore[key]) {
    return;
  }
  const type1 = type(item1);
  const type2 = type(item2);
  if (item1 === item2) {
    return;
  }
  if (type1 !== type2) {
    resultPaths.push(getDiffItem(key, item2, item1));
  } else if ("object" === type1) {
    if (!isPlainObject(item2)) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else {
      const diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);
      resultPaths.push(...diffPaths.map((item) => _extends({}, item, {
        path: `${key}.${item.path}`
      })));
    }
  } else if ("array" === type1) {
    const notDeepCopy = notDeepCopyArrays.some((prop) => fullPropName.includes(prop));
    if (notDeepCopy && item1 !== item2) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else if (item1.length !== item2.length) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else {
      const diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);
      [].push.apply(resultPaths, diffPaths.map((item) => _extends({}, item, {
        path: `${key}${item.path}`
      })));
    }
  } else {
    resultPaths.push(getDiffItem(key, item2, item1));
  }
}
var objectDiffsFiltered = (propsEnumerator) => (oldProps, props, fullPropName, notDeepCopyArrays) => {
  const resultPaths = [];
  const processItem = !Array.isArray(oldProps) ? (propName) => {
    compare2(resultPaths, oldProps[propName], props[propName], propName, `${fullPropName}.${propName}`, notDeepCopyArrays);
  } : (propName) => {
    compare2(resultPaths, oldProps[propName], props[propName], `[${propName}]`, `${fullPropName}.${propName}`, notDeepCopyArrays);
  };
  propsEnumerator(oldProps).forEach(processItem);
  Object.keys(props).filter((propName) => !Object.prototype.hasOwnProperty.call(oldProps, propName) && oldProps[propName] !== props[propName]).forEach((propName) => {
    resultPaths.push({
      path: propName,
      value: props[propName],
      previousValue: oldProps[propName]
    });
  });
  return resultPaths;
};
var objectDiffs = objectDiffsFiltered((oldProps) => Object.keys(oldProps));
var reactProps = {
  key: true,
  ref: true,
  children: true,
  style: true
};
var objectDiffsWithoutReactProps = objectDiffsFiltered((prop) => Object.keys(prop).filter((p2) => !reactProps[p2]));
function getUpdatedOptions(oldProps, props) {
  let notDeepCopyArrays = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : defaultNotDeepCopyArrays;
  return objectDiffsWithoutReactProps(oldProps, props, "", notDeepCopyArrays);
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/common/dom_component_wrapper.js
var _excluded10 = ["valueChange"];
var _excluded22 = ["componentProps", "componentType", "templateNames"];
var normalizeProps2 = (props) => Object.keys(props).reduce((accumulator, key) => {
  if (void 0 !== props[key]) {
    accumulator[key] = props[key];
  }
  return accumulator;
}, {});
var viewFunction6 = (_ref) => {
  let {
    props: {
      componentProps: {
        className
      }
    },
    restAttributes,
    widgetRef
  } = _ref;
  return normalizeProps2(createVNode(1, "div", className, null, 1, _extends({}, restAttributes), null, widgetRef));
};
var DomComponentWrapperProps = {};
var DomComponentWrapper = class extends InfernoComponent {
  get config() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  constructor(props) {
    super(props);
    this.state = {};
    this.widgetRef = createRef();
    this.getInstance = this.getInstance.bind(this);
    this.setupWidget = this.setupWidget.bind(this);
    this.updateWidget = this.updateWidget.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.setupWidget, []), new InfernoEffect(this.updateWidget, [this.props.componentProps, this.config, this.props.templateNames])];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[1]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props.componentProps, this.config, this.props.templateNames]);
  }
  setupWidget() {
    const componentInstance = new this.props.componentType(this.widgetRef.current, this.properties);
    this.instance = componentInstance;
    return () => {
      componentInstance.dispose();
      this.instance = null;
    };
  }
  updateWidget() {
    const instance = this.getInstance();
    if (!instance) {
      return;
    }
    const updatedOptions = getUpdatedOptions(this.prevProps || {}, this.properties);
    if (updatedOptions.length) {
      instance.beginUpdate();
      updatedOptions.forEach((_ref2) => {
        let {
          path,
          value: value2
        } = _ref2;
        instance.option(path, value2);
      });
      instance.endUpdate();
    }
    this.prevProps = this.properties;
  }
  get properties() {
    var _this$config;
    const normalizedProps = normalizeProps2(this.props.componentProps);
    const {
      valueChange
    } = normalizedProps, restProps = _objectWithoutPropertiesLoose(normalizedProps, _excluded10);
    const properties = _extends({
      rtlEnabled: !!(null !== (_this$config = this.config) && void 0 !== _this$config && _this$config.rtlEnabled),
      isRenovated: true
    }, restProps);
    if (valueChange) {
      properties.onValueChanged = (_ref3) => {
        let {
          value: value2
        } = _ref3;
        return valueChange(value2);
      };
    }
    const templates = this.props.templateNames;
    templates.forEach((name2) => {
      if (hasTemplate(name2, properties, this)) {
        properties[name2] = (item, index2, container) => {
          renderTemplate(this.props.componentProps[name2], {
            item,
            index: index2,
            container
          }, this);
        };
      }
    });
    return properties;
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded22);
    return restProps;
  }
  getInstance() {
    return this.instance;
  }
  render() {
    const props = this.props;
    return viewFunction6({
      props: _extends({}, props),
      widgetRef: this.widgetRef,
      config: this.config,
      properties: this.properties,
      restAttributes: this.restAttributes
    });
  }
};
DomComponentWrapper.defaultProps = DomComponentWrapperProps;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/overlays/validation_message.js
var _excluded11 = ["accessKey", "activeStateEnabled", "boundary", "className", "contentId", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "mode", "offset", "onClick", "onKeyDown", "positionSide", "rtlEnabled", "tabIndex", "target", "validationErrors", "visible", "visualContainer", "width"];
var viewFunction7 = (_ref) => {
  let {
    componentProps,
    restAttributes
  } = _ref;
  return normalizeProps(createComponentVNode(2, DomComponentWrapper, _extends({
    componentType: validation_message_default,
    componentProps,
    templateNames: []
  }, restAttributes)));
};
var ValidationMessageProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(BaseWidgetProps), Object.getOwnPropertyDescriptors({
  mode: "auto",
  positionSide: "top",
  offset: Object.freeze({
    h: 0,
    v: 0
  }),
  isReactComponentWrapper: true
})));
var ValidationMessage2 = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }
  get componentProps() {
    return this.props;
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded11);
    return restProps;
  }
  render() {
    const props = this.props;
    return viewFunction7({
      props: _extends({}, props),
      componentProps: this.componentProps,
      restAttributes: this.restAttributes
    });
  }
};
ValidationMessage2.defaultProps = ValidationMessageProps;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/editors/common/editor.js
var _excluded12 = ["accessKey", "activeStateEnabled", "aria", "children", "className", "classes", "defaultValue", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "inputAttr", "isDirty", "isValid", "name", "onClick", "onFocusIn", "onKeyDown", "readOnly", "rtlEnabled", "tabIndex", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "value", "valueChange", "visible", "width"];
var getCssClasses3 = (model) => {
  const {
    classes,
    isValid,
    readOnly
  } = model;
  const classesMap = {
    "dx-state-readonly": !!readOnly,
    "dx-invalid": !isValid,
    [String(classes)]: !!classes
  };
  return combineClasses(classesMap);
};
var viewFunction8 = (viewModel) => {
  const {
    aria,
    cssClasses: classes,
    isValidationMessageVisible,
    onFocusIn,
    props: {
      accessKey,
      activeStateEnabled,
      children,
      className,
      disabled,
      focusStateEnabled,
      height,
      hint,
      hoverStateEnabled,
      onClick,
      onKeyDown,
      rtlEnabled,
      tabIndex,
      validationMessageMode,
      validationMessagePosition,
      visible: visible2,
      width
    },
    restAttributes,
    rootElementRef,
    validationErrors,
    validationMessageGuid,
    validationMessageTarget,
    widgetRef
  } = viewModel;
  return normalizeProps(createComponentVNode(2, Widget2, _extends({
    rootElementRef,
    aria,
    classes,
    activeStateEnabled,
    focusStateEnabled,
    hoverStateEnabled,
    accessKey,
    className,
    rtlEnabled,
    hint,
    disabled,
    height,
    width,
    onFocusIn,
    onClick,
    onKeyDown,
    tabIndex,
    visible: visible2
  }, restAttributes, {
    children: createFragment([children, isValidationMessageVisible && createComponentVNode(2, ValidationMessage2, {
      validationErrors,
      mode: validationMessageMode,
      positionSide: validationMessagePosition,
      rtlEnabled,
      target: validationMessageTarget,
      boundary: validationMessageTarget,
      visualContainer: validationMessageTarget,
      contentId: validationMessageGuid
    })], 0)
  }), null, widgetRef));
};
var EditorProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(BaseWidgetProps), Object.getOwnPropertyDescriptors({
  readOnly: false,
  name: "",
  validationError: null,
  validationErrors: null,
  validationMessageMode: "auto",
  validationMessagePosition: "bottom",
  validationStatus: "valid",
  isValid: true,
  isDirty: false,
  inputAttr: Object.freeze({}),
  defaultValue: null,
  valueChange: () => {
  }
})));
var EditorPropsType = {
  get readOnly() {
    return EditorProps.readOnly;
  },
  get name() {
    return EditorProps.name;
  },
  get validationError() {
    return EditorProps.validationError;
  },
  get validationErrors() {
    return EditorProps.validationErrors;
  },
  get validationMessageMode() {
    return EditorProps.validationMessageMode;
  },
  get validationMessagePosition() {
    return EditorProps.validationMessagePosition;
  },
  get validationStatus() {
    return EditorProps.validationStatus;
  },
  get isValid() {
    return EditorProps.isValid;
  },
  get isDirty() {
    return EditorProps.isDirty;
  },
  get inputAttr() {
    return EditorProps.inputAttr;
  },
  get defaultValue() {
    return EditorProps.defaultValue;
  },
  get valueChange() {
    return EditorProps.valueChange;
  },
  get className() {
    return EditorProps.className;
  },
  get activeStateEnabled() {
    return EditorProps.activeStateEnabled;
  },
  get disabled() {
    return EditorProps.disabled;
  },
  get focusStateEnabled() {
    return EditorProps.focusStateEnabled;
  },
  get hoverStateEnabled() {
    return EditorProps.hoverStateEnabled;
  },
  get tabIndex() {
    return EditorProps.tabIndex;
  },
  get visible() {
    return EditorProps.visible;
  },
  get aria() {
    return WidgetProps.aria;
  },
  get classes() {
    return WidgetProps.classes;
  }
};
var Editor3 = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.widgetRef = createRef();
    this.rootElementRef = createRef();
    this.__getterCache = {};
    this.state = {
      validationMessageGuid: `dx-${new guid_default()}`,
      isValidationMessageVisible: false,
      value: void 0 !== this.props.value ? this.props.value : this.props.defaultValue
    };
    this.updateValidationMessageVisibility = this.updateValidationMessageVisibility.bind(this);
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.onFocusIn = this.onFocusIn.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.updateValidationMessageVisibility, [this.props.isValid, this.props.validationStatus, this.props.validationError, this.props.validationErrors]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props.isValid, this.props.validationStatus, this.props.validationError, this.props.validationErrors]);
  }
  updateValidationMessageVisibility() {
    this.setState((__state_argument) => ({
      isValidationMessageVisible: this.shouldShowValidationMessage
    }));
  }
  onFocusIn(event) {
    const {
      onFocusIn
    } = this.props;
    null === onFocusIn || void 0 === onFocusIn || onFocusIn(event);
  }
  get cssClasses() {
    return `${getCssClasses3(_extends({}, this.props, { value: void 0 !== this.props.value ? this.props.value : this.state.value }))}`;
  }
  get shouldShowValidationMessage() {
    const {
      isValid,
      validationStatus
    } = this.props;
    const validationErrors = this.validationErrors ?? [];
    const isEditorValid = isValid && "invalid" !== validationStatus;
    return !isEditorValid && validationErrors.length > 0;
  }
  get aria() {
    const {
      isValid,
      readOnly
    } = this.props;
    const result2 = {
      readonly: readOnly ? "true" : "false",
      invalid: !isValid ? "true" : "false"
    };
    if (this.shouldShowValidationMessage) {
      result2.describedBy = this.state.validationMessageGuid;
    }
    return _extends({}, result2, this.props.aria);
  }
  get validationErrors() {
    if (void 0 !== this.__getterCache.validationErrors) {
      return this.__getterCache.validationErrors;
    }
    return this.__getterCache.validationErrors = (() => {
      const {
        validationError,
        validationErrors
      } = this.props;
      let allValidationErrors = validationErrors && [...validationErrors];
      if (!allValidationErrors && validationError) {
        allValidationErrors = [_extends({}, validationError)];
      }
      return allValidationErrors;
    })();
  }
  get validationMessageTarget() {
    var _this$rootElementRef;
    return null === (_this$rootElementRef = this.rootElementRef) || void 0 === _this$rootElementRef ? void 0 : _this$rootElementRef.current;
  }
  get restAttributes() {
    const _this$props$value = _extends({}, this.props, {
      value: void 0 !== this.props.value ? this.props.value : this.state.value
    }), restProps = _objectWithoutPropertiesLoose(_this$props$value, _excluded12);
    return restProps;
  }
  focus() {
    this.widgetRef.current.focus();
  }
  blur() {
    this.widgetRef.current.blur();
  }
  componentWillUpdate(nextProps, nextState, context2) {
    super.componentWillUpdate();
    if (this.props.validationError !== nextProps.validationError || this.props.validationErrors !== nextProps.validationErrors) {
      this.__getterCache.validationErrors = void 0;
    }
  }
  render() {
    const props = this.props;
    return viewFunction8({
      props: _extends({}, props, {
        value: void 0 !== this.props.value ? this.props.value : this.state.value
      }),
      validationMessageGuid: this.state.validationMessageGuid,
      isValidationMessageVisible: this.state.isValidationMessageVisible,
      rootElementRef: this.rootElementRef,
      widgetRef: this.widgetRef,
      onFocusIn: this.onFocusIn,
      cssClasses: this.cssClasses,
      shouldShowValidationMessage: this.shouldShowValidationMessage,
      aria: this.aria,
      validationErrors: this.validationErrors,
      validationMessageTarget: this.validationMessageTarget,
      restAttributes: this.restAttributes
    });
  }
};
Editor3.defaultProps = EditorPropsType;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/editors/check_box/check_box_icon.js
var _excluded13 = ["size"];
var viewFunction9 = (viewModel) => {
  const {
    cssStyles,
    elementRef
  } = viewModel;
  return createVNode(1, "span", "dx-checkbox-icon", null, 1, {
    style: normalizeStyles(cssStyles)
  }, null, elementRef);
};
var CheckBoxIconProps = {};
var CheckBoxIcon = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.elementRef = createRef();
    this.__getterCache = {};
  }
  get cssStyles() {
    if (void 0 !== this.__getterCache.cssStyles) {
      return this.__getterCache.cssStyles;
    }
    return this.__getterCache.cssStyles = (() => {
      const {
        size
      } = this.props;
      const fontSize = normalizeStyleProp("fontSize", size);
      return {
        fontSize
      };
    })();
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded13);
    return restProps;
  }
  componentWillUpdate(nextProps, nextState, context2) {
    if (this.props.size !== nextProps.size) {
      this.__getterCache.cssStyles = void 0;
    }
  }
  render() {
    const props = this.props;
    return viewFunction9({
      props: _extends({}, props),
      elementRef: this.elementRef,
      cssStyles: this.cssStyles,
      restAttributes: this.restAttributes
    });
  }
};
CheckBoxIcon.defaultProps = CheckBoxIconProps;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/editors/check_box/check_box.js
var _excluded14 = ["accessKey", "activeStateEnabled", "aria", "className", "defaultValue", "disabled", "enableThreeStateBehavior", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "iconSize", "inputAttr", "isDirty", "isValid", "name", "onClick", "onFocusIn", "onKeyDown", "readOnly", "rtlEnabled", "saveValueChangeEvent", "tabIndex", "text", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "value", "valueChange", "visible", "width"];
var getCssClasses4 = (model) => {
  const {
    text,
    value: value2
  } = model;
  const checked = value2;
  const indeterminate = null === checked;
  const classesMap = {
    "dx-checkbox": true,
    "dx-checkbox-checked": true === checked,
    "dx-checkbox-has-text": !!text,
    "dx-checkbox-indeterminate": indeterminate
  };
  return combineClasses(classesMap);
};
var viewFunction10 = (viewModel) => {
  const {
    aria,
    cssClasses: classes,
    editorRef,
    keyDown: onKeyDown,
    onWidgetClick: onClick,
    props: {
      accessKey,
      activeStateEnabled,
      className,
      disabled,
      focusStateEnabled,
      height,
      hint,
      hoverStateEnabled,
      iconSize,
      isValid,
      name: name2,
      onFocusIn,
      readOnly,
      rtlEnabled,
      tabIndex,
      text,
      validationError,
      validationErrors,
      validationMessageMode,
      validationMessagePosition,
      validationStatus,
      value: value2,
      visible: visible2,
      width
    },
    restAttributes
  } = viewModel;
  return normalizeProps(createComponentVNode(2, Editor3, _extends({
    aria,
    classes,
    onClick,
    onKeyDown,
    accessKey,
    activeStateEnabled,
    focusStateEnabled,
    hoverStateEnabled,
    className,
    disabled,
    readOnly,
    hint,
    height,
    width,
    rtlEnabled,
    tabIndex,
    visible: visible2,
    validationError,
    validationErrors,
    validationMessageMode,
    validationMessagePosition,
    validationStatus,
    isValid,
    onFocusIn
  }, restAttributes, {
    children: createFragment([normalizeProps(createVNode(64, "input", null, null, 1, _extends({
      type: "hidden",
      value: `${value2}`
    }, name2 && {
      name: name2
    }))), createVNode(1, "div", "dx-checkbox-container", [createComponentVNode(2, CheckBoxIcon, {
      size: iconSize,
      isChecked: true === value2
    }), text && createVNode(1, "span", "dx-checkbox-text", text, 0)], 0)], 4)
  }), null, editorRef));
};
var CheckBoxProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(EditorProps), Object.getOwnPropertyDescriptors({
  text: "",
  enableThreeStateBehavior: false,
  activeStateEnabled: true,
  hoverStateEnabled: true,
  get focusStateEnabled() {
    return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
  },
  defaultValue: false,
  valueChange: () => {
  }
})));
var CheckBoxPropsType = {
  get text() {
    return CheckBoxProps.text;
  },
  get enableThreeStateBehavior() {
    return CheckBoxProps.enableThreeStateBehavior;
  },
  get activeStateEnabled() {
    return CheckBoxProps.activeStateEnabled;
  },
  get hoverStateEnabled() {
    return CheckBoxProps.hoverStateEnabled;
  },
  get focusStateEnabled() {
    return CheckBoxProps.focusStateEnabled;
  },
  get defaultValue() {
    return CheckBoxProps.defaultValue;
  },
  get valueChange() {
    return CheckBoxProps.valueChange;
  },
  get readOnly() {
    return CheckBoxProps.readOnly;
  },
  get name() {
    return CheckBoxProps.name;
  },
  get validationError() {
    return CheckBoxProps.validationError;
  },
  get validationErrors() {
    return CheckBoxProps.validationErrors;
  },
  get validationMessageMode() {
    return CheckBoxProps.validationMessageMode;
  },
  get validationMessagePosition() {
    return CheckBoxProps.validationMessagePosition;
  },
  get validationStatus() {
    return CheckBoxProps.validationStatus;
  },
  get isValid() {
    return CheckBoxProps.isValid;
  },
  get isDirty() {
    return CheckBoxProps.isDirty;
  },
  get inputAttr() {
    return CheckBoxProps.inputAttr;
  },
  get className() {
    return CheckBoxProps.className;
  },
  get disabled() {
    return CheckBoxProps.disabled;
  },
  get tabIndex() {
    return CheckBoxProps.tabIndex;
  },
  get visible() {
    return CheckBoxProps.visible;
  },
  get aria() {
    return WidgetProps.aria;
  }
};
var CheckBox2 = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.editorRef = createRef();
    this.state = {
      value: void 0 !== this.props.value ? this.props.value : this.props.defaultValue
    };
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.onWidgetClick = this.onWidgetClick.bind(this);
    this.keyDown = this.keyDown.bind(this);
  }
  createEffects() {
    return [createReRenderEffect()];
  }
  onWidgetClick(event) {
    const {
      enableThreeStateBehavior,
      readOnly,
      saveValueChangeEvent
    } = this.props;
    if (!readOnly) {
      null === saveValueChangeEvent || void 0 === saveValueChangeEvent || saveValueChangeEvent(event);
      if (enableThreeStateBehavior) {
        let __newValue;
        this.setState((__state_argument) => {
          __newValue = null === (void 0 !== this.props.value ? this.props.value : __state_argument.value) || (!(void 0 !== this.props.value ? this.props.value : __state_argument.value) ? null : false);
          return {
            value: __newValue
          };
        });
        this.props.valueChange(__newValue);
      } else {
        let __newValue;
        this.setState((__state_argument) => {
          __newValue = !((void 0 !== this.props.value ? this.props.value : __state_argument.value) ?? false);
          return {
            value: __newValue
          };
        });
        this.props.valueChange(__newValue);
      }
    }
  }
  keyDown(e) {
    const {
      onKeyDown
    } = this.props;
    const {
      keyName,
      originalEvent,
      which
    } = e;
    const result2 = null === onKeyDown || void 0 === onKeyDown ? void 0 : onKeyDown(e);
    if (null !== result2 && void 0 !== result2 && result2.cancel) {
      return result2;
    }
    if ("space" === keyName || "space" === which) {
      originalEvent.preventDefault();
      this.onWidgetClick(originalEvent);
    }
    return;
  }
  get cssClasses() {
    return getCssClasses4(_extends({}, this.props, {
      value: void 0 !== this.props.value ? this.props.value : this.state.value
    }));
  }
  get aria() {
    const checked = true === (void 0 !== this.props.value ? this.props.value : this.state.value);
    const indeterminate = null === (void 0 !== this.props.value ? this.props.value : this.state.value);
    const result2 = {
      role: "checkbox",
      checked: indeterminate ? "mixed" : `${checked}`
    };
    return _extends({}, result2, this.props.aria);
  }
  get restAttributes() {
    const _this$props$value = _extends({}, this.props, {
      value: void 0 !== this.props.value ? this.props.value : this.state.value
    }), restProps = _objectWithoutPropertiesLoose(_this$props$value, _excluded14);
    return restProps;
  }
  focus() {
    this.editorRef.current.focus();
  }
  blur() {
    this.editorRef.current.blur();
  }
  render() {
    const props = this.props;
    return viewFunction10({
      props: _extends({}, props, {
        value: void 0 !== this.props.value ? this.props.value : this.state.value
      }),
      editorRef: this.editorRef,
      onWidgetClick: this.onWidgetClick,
      keyDown: this.keyDown,
      cssClasses: this.cssClasses,
      aria: this.aria,
      restAttributes: this.restAttributes
    });
  }
};
function __processTwoWayProps(defaultProps) {
  const twoWayProps = ["value"];
  return Object.keys(defaultProps).reduce((props, propName) => {
    const propValue = defaultProps[propName];
    const defaultPropName = twoWayProps.some((p2) => p2 === propName) ? "default" + propName.charAt(0).toUpperCase() + propName.slice(1) : propName;
    props[defaultPropName] = propValue;
    return props;
  }, {});
}
CheckBox2.defaultProps = CheckBoxPropsType;
var __defaultOptionRules2 = [];
function defaultOptions2(rule) {
  __defaultOptionRules2.push(rule);
  CheckBox2.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(CheckBox2.defaultProps), Object.getOwnPropertyDescriptors(__processTwoWayProps(convertRulesToOptions(__defaultOptionRules2)))));
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/editors/check_box/check_box.j.js
var CheckBox3 = class extends CheckBox {
  getProps() {
    const props = super.getProps();
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    return props;
  }
  focus() {
    var _this$viewRef;
    return null === (_this$viewRef = this.viewRef) || void 0 === _this$viewRef ? void 0 : _this$viewRef.focus(...arguments);
  }
  blur() {
    var _this$viewRef2;
    return null === (_this$viewRef2 = this.viewRef) || void 0 === _this$viewRef2 ? void 0 : _this$viewRef2.blur(...arguments);
  }
  _getActionConfigs() {
    return {
      onFocusIn: {},
      onClick: {}
    };
  }
  get _propsInfo() {
    return {
      twoWay: [
        ["value", "defaultValue", "valueChange"]
      ],
      allowNull: ["defaultValue", "validationError", "validationErrors", "value"],
      elements: [],
      templates: [],
      props: ["text", "iconSize", "enableThreeStateBehavior", "activeStateEnabled", "hoverStateEnabled", "focusStateEnabled", "saveValueChangeEvent", "defaultValue", "valueChange", "readOnly", "name", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "isValid", "isDirty", "inputAttr", "onFocusIn", "className", "accessKey", "disabled", "height", "hint", "onClick", "onKeyDown", "rtlEnabled", "tabIndex", "visible", "width", "aria", "value"]
    };
  }
  get _viewComponent() {
    return CheckBox2;
  }
};
component_registrator_default("dxCheckBox", CheckBox3);
CheckBox3.defaultOptions = defaultOptions2;

// ../../../../../../node_modules/devextreme/esm/ui/check_box.js
var check_box_default = CheckBox3;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/radio_group/m_radio_button.js
var RadioButton = editor_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), {
      space: function(e) {
        e.preventDefault();
        this._clickAction({
          event: e
        });
      }
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      value: false
    });
  },
  _canValueBeChangedByClick: () => true,
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  },
  _init() {
    this.callBase();
    this.$element().addClass("dx-radiobutton");
  },
  _initMarkup() {
    this.callBase();
    this._renderIcon();
    this._renderCheckedState(this.option("value"));
    this._renderClick();
    this.setAria("role", "radio");
  },
  _renderIcon() {
    this._$icon = renderer_default("<div>").addClass("dx-radiobutton-icon");
    renderer_default("<div>").addClass("dx-radiobutton-icon-dot").appendTo(this._$icon);
    this.$element().append(this._$icon);
  },
  _renderCheckedState(checked) {
    this.$element().toggleClass("dx-radiobutton-checked", checked).find(".dx-radiobutton-icon").toggleClass("dx-radiobutton-icon-checked", checked);
    this.setAria("checked", checked);
  },
  _renderClick() {
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    this._clickAction = this._createAction((args) => {
      this._clickHandler(args.event);
    });
    events_engine_default.off(this.$element(), eventName);
    events_engine_default.on(this.$element(), eventName, (e) => {
      this._clickAction({
        event: e
      });
    });
  },
  _clickHandler(e) {
    this._saveValueChangeEvent(e);
    this.option("value", true);
  },
  _optionChanged(args) {
    if ("value" === args.name) {
      this._renderCheckedState(args.value);
      this.callBase(args);
    } else {
      this.callBase(args);
    }
  }
});
component_registrator_default("dxRadioButton", RadioButton);
var m_radio_button_default = RadioButton;

// ../../../../../../node_modules/devextreme/esm/ui/radio_group/radio_button.js
var radio_button_default = m_radio_button_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator.js
var LIST_EDIT_DECORATOR = "dxListEditDecorator";
var SWIPE_START_EVENT_NAME = addNamespace2(SWIPE_START_EVENT, LIST_EDIT_DECORATOR);
var SWIPE_UPDATE_EVENT_NAME = addNamespace2(SWIPE_EVENT, LIST_EDIT_DECORATOR);
var SWIPE_END_EVENT_NAME = addNamespace2(SWIPE_END_EVENT, LIST_EDIT_DECORATOR);
var EditDecorator = class_default.inherit({
  ctor(list) {
    this._list = list;
    this._init();
  },
  _init: noop2,
  _shouldHandleSwipe: false,
  _attachSwipeEvent(config3) {
    const swipeConfig = {
      itemSizeFunc: (function() {
        if (this._clearSwipeCache) {
          this._itemWidthCache = getWidth(this._list.$element());
          this._clearSwipeCache = false;
        }
        return this._itemWidthCache;
      }).bind(this)
    };
    events_engine_default.on(config3.$itemElement, SWIPE_START_EVENT_NAME, swipeConfig, this._itemSwipeStartHandler.bind(this));
    events_engine_default.on(config3.$itemElement, SWIPE_UPDATE_EVENT_NAME, this._itemSwipeUpdateHandler.bind(this));
    events_engine_default.on(config3.$itemElement, SWIPE_END_EVENT_NAME, this._itemSwipeEndHandler.bind(this));
  },
  _itemSwipeStartHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = true;
      return;
    }
    clearTimeout(this._list._inkRippleTimer);
    this._swipeStartHandler($itemElement, e);
  },
  _itemSwipeUpdateHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    this._swipeUpdateHandler($itemElement, e);
  },
  _itemSwipeEndHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    this._swipeEndHandler($itemElement, e);
    this._clearSwipeCache = true;
  },
  beforeBag: noop2,
  afterBag: noop2,
  _commonOptions() {
    return {
      activeStateEnabled: this._list.option("activeStateEnabled"),
      hoverStateEnabled: this._list.option("hoverStateEnabled"),
      focusStateEnabled: this._list.option("focusStateEnabled")
    };
  },
  modifyElement(config3) {
    if (this._shouldHandleSwipe) {
      this._attachSwipeEvent(config3);
      this._clearSwipeCache = true;
    }
  },
  afterRender: noop2,
  handleClick: noop2,
  handleKeyboardEvents: noop2,
  handleEnterPressing: noop2,
  handleContextMenu: noop2,
  _swipeStartHandler: noop2,
  _swipeUpdateHandler: noop2,
  _swipeEndHandler: noop2,
  visibilityChange: noop2,
  getExcludedSelectors: noop2,
  dispose: noop2
});
var m_list_edit_decorator_default = EditDecorator;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator_registry.js
var registry = {};
function register(option, type2, decoratorClass) {
  const decoratorsRegistry = registry;
  const decoratorConfig = {};
  decoratorConfig[option] = decoratorsRegistry[option] ? decoratorsRegistry[option] : {};
  decoratorConfig[option][type2] = decoratorClass;
  extend(decoratorsRegistry, decoratorConfig);
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator.selection.js
var SELECT_DECORATOR_ENABLED_CLASS = "dx-list-select-decorator-enabled";
var SELECT_CHECKBOX_CONTAINER_CLASS = "dx-list-select-checkbox-container";
var SELECT_CHECKBOX_CLASS = "dx-list-select-checkbox";
var SELECT_RADIO_BUTTON_CONTAINER_CLASS = "dx-list-select-radiobutton-container";
var SELECT_RADIO_BUTTON_CLASS = "dx-list-select-radiobutton";
var CLICK_EVENT_NAME2 = addNamespace2(CLICK_EVENT_NAME, "dxListEditDecorator");
register("selection", "default", m_list_edit_decorator_default.inherit({
  _init() {
    this.callBase.apply(this, arguments);
    const selectionMode = this._list.option("selectionMode");
    this._singleStrategy = "single" === selectionMode;
    this._containerClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CONTAINER_CLASS : SELECT_CHECKBOX_CONTAINER_CLASS;
    this._controlClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CLASS : SELECT_CHECKBOX_CLASS;
    this._controlWidget = this._singleStrategy ? radio_button_default : check_box_default;
    this._list.$element().addClass(SELECT_DECORATOR_ENABLED_CLASS);
  },
  beforeBag(config3) {
    const {
      $itemElement
    } = config3;
    const $container = config3.$container.addClass(this._containerClass);
    const $control = renderer_default("<div>").addClass(this._controlClass).appendTo($container);
    new this._controlWidget($control, extend(this._commonOptions(), {
      value: this._isSelected($itemElement),
      elementAttr: {
        "aria-label": "Check State"
      },
      focusStateEnabled: false,
      hoverStateEnabled: false,
      onValueChanged: (function(e) {
        e.event && this._list._saveSelectionChangeEvent(e.event);
        this._processCheckedState($itemElement, e.value);
        e.event && e.event.stopPropagation();
      }).bind(this)
    }));
  },
  modifyElement(config3) {
    this.callBase.apply(this, arguments);
    const {
      $itemElement
    } = config3;
    const control = this._controlWidget.getInstance($itemElement.find(`.${this._controlClass}`));
    events_engine_default.on($itemElement, "stateChanged", (e, state) => {
      control.option("value", state);
    });
  },
  _updateSelectAllState() {
    if (!this._$selectAll) {
      return;
    }
    this._selectAllCheckBox.option("value", this._list.isSelectAll());
  },
  afterRender() {
    if ("all" !== this._list.option("selectionMode")) {
      return;
    }
    if (!this._$selectAll) {
      this._renderSelectAll();
    } else {
      this._updateSelectAllState();
    }
  },
  handleKeyboardEvents(currentFocusedIndex, moveFocusUp) {
    const moveFocusDown = !moveFocusUp;
    const list = this._list;
    const $selectAll = this._$selectAll;
    const lastItemIndex = list._getLastItemIndex();
    const isFocusOutOfList = moveFocusUp && 0 === currentFocusedIndex || moveFocusDown && currentFocusedIndex === lastItemIndex;
    const hasSelectAllItem = !!$selectAll;
    if (hasSelectAllItem && isFocusOutOfList) {
      list.option("focusedElement", $selectAll);
      list.scrollToItem(list.option("focusedElement"));
      return true;
    }
    return false;
  },
  handleEnterPressing(e) {
    if (this._$selectAll && this._$selectAll.hasClass("dx-state-focused")) {
      e.target = this._$selectAll.get(0);
      this._list._saveSelectionChangeEvent(e);
      this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"));
      return true;
    }
  },
  _renderSelectAll() {
    this._$selectAll = renderer_default("<div>").addClass("dx-list-select-all");
    const downArrowHandler = this._list._supportedKeys().downArrow.bind(this._list);
    const selectAllCheckBoxElement = renderer_default("<div>").addClass("dx-list-select-all-checkbox").appendTo(this._$selectAll);
    this._selectAllCheckBox = this._list._createComponent(selectAllCheckBoxElement, check_box_default, {
      elementAttr: {
        "aria-label": message_default.format("dxList-selectAll")
      },
      focusStateEnabled: false,
      hoverStateEnabled: false
    });
    this._selectAllCheckBox.registerKeyHandler("downArrow", downArrowHandler);
    renderer_default("<div>").addClass("dx-list-select-all-label").text(this._list.option("selectAllText")).appendTo(this._$selectAll);
    this._list.itemsContainer().prepend(this._$selectAll);
    this._updateSelectAllState();
    this._updateSelectAllAriaLabel();
    this._attachSelectAllHandler();
  },
  _attachSelectAllHandler() {
    this._selectAllCheckBox.option("onValueChanged", this._selectAllHandler.bind(this));
    events_engine_default.off(this._$selectAll, CLICK_EVENT_NAME2);
    events_engine_default.on(this._$selectAll, CLICK_EVENT_NAME2, this._selectAllClickHandler.bind(this));
  },
  _updateSelectAllAriaLabel() {
    if (!this._$selectAll) {
      return;
    }
    const {
      value: value2
    } = this._selectAllCheckBox.option();
    const indeterminate = void 0 === value2;
    const checkedText = indeterminate ? "half checked" : value2 ? "checked" : "not checked";
    const label = `${message_default.format("dxList-selectAll")}, ${checkedText}`;
    this._$selectAll.attr({
      "aria-label": label
    });
  },
  _selectAllHandler(e) {
    e.event && e.event.stopPropagation();
    e.event && this._list._saveSelectionChangeEvent(e.event);
    const {
      value: value2
    } = this._selectAllCheckBox.option();
    if (value2) {
      this._selectAllItems();
    } else if (false === value2) {
      this._unselectAllItems();
    }
    this._updateSelectAllAriaLabel();
    this._list._createActionByOption("onSelectAllValueChanged")({
      value: value2
    });
  },
  _checkSelectAllCapability() {
    const list = this._list;
    const dataController = list._dataController;
    if ("allPages" === list.option("selectAllMode") && list.option("grouped") && !dataController.group()) {
      ui_errors_default.log("W1010");
      return false;
    }
    return true;
  },
  _selectAllItems() {
    if (!this._checkSelectAllCapability()) {
      return;
    }
    this._list._selection.selectAll("page" === this._list.option("selectAllMode"));
  },
  _unselectAllItems() {
    if (!this._checkSelectAllCapability()) {
      return;
    }
    this._list._selection.deselectAll("page" === this._list.option("selectAllMode"));
  },
  _selectAllClickHandler(e) {
    this._list._saveSelectionChangeEvent(e);
    this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"));
  },
  _isSelected($itemElement) {
    return this._list.isItemSelected($itemElement);
  },
  _processCheckedState($itemElement, checked) {
    if (checked) {
      this._list.selectItem($itemElement);
    } else {
      this._list.unselectItem($itemElement);
    }
  },
  dispose() {
    this._disposeSelectAll();
    this._list.$element().removeClass(SELECT_DECORATOR_ENABLED_CLASS);
    this.callBase.apply(this, arguments);
  },
  _disposeSelectAll() {
    if (this._$selectAll) {
      this._$selectAll.remove();
      this._$selectAll = null;
    }
  }
}));

// ../../../../../../node_modules/devextreme/esm/core/utils/stubs.js
function stubComponent(componentName) {
  return class {
    constructor() {
      throw new Error(`Module '${componentName}' not found`);
    }
    static getInstance() {
    }
  };
}

// ../../../../../../node_modules/devextreme/esm/ui/widget/ui.search_box_mixin.js
var EditorClass = stubComponent("TextBox");
var ui_search_box_mixin_default = {
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      searchMode: "",
      searchExpr: null,
      searchValue: "",
      searchEnabled: false,
      searchEditorOptions: {}
    });
  },
  _initMarkup: function() {
    this._renderSearch();
    this.callBase();
  },
  _renderSearch: function() {
    const $element = this.$element();
    const searchEnabled = this.option("searchEnabled");
    const searchBoxClassName = this._addWidgetPrefix("search");
    const rootElementClassName = this._addWidgetPrefix("with-search");
    if (!searchEnabled) {
      $element.removeClass(rootElementClassName);
      this._removeSearchBox();
      return;
    }
    const editorOptions = this._getSearchEditorOptions();
    if (this._searchEditor) {
      this._searchEditor.option(editorOptions);
    } else {
      $element.addClass(rootElementClassName);
      this._$searchEditorElement = renderer_default("<div>").addClass(searchBoxClassName).prependTo($element);
      this._searchEditor = this._createComponent(this._$searchEditorElement, EditorClass, editorOptions);
    }
  },
  _removeSearchBox: function() {
    this._$searchEditorElement && this._$searchEditorElement.remove();
    delete this._$searchEditorElement;
    delete this._searchEditor;
  },
  _getSearchEditorOptions: function() {
    const that = this;
    const userEditorOptions = that.option("searchEditorOptions");
    const searchText = message_default.format("Search");
    return extend({
      mode: "search",
      placeholder: searchText,
      tabIndex: that.option("tabIndex"),
      value: that.option("searchValue"),
      valueChangeEvent: "input",
      inputAttr: {
        "aria-label": searchText
      },
      onValueChanged: function(e) {
        const searchTimeout = that.option("searchTimeout");
        that._valueChangeDeferred = new Deferred();
        clearTimeout(that._valueChangeTimeout);
        that._valueChangeDeferred.done((function() {
          this.option("searchValue", e.value);
        }).bind(that));
        if (e.event && "input" === e.event.type && searchTimeout) {
          that._valueChangeTimeout = setTimeout(function() {
            that._valueChangeDeferred.resolve();
          }, searchTimeout);
        } else {
          that._valueChangeDeferred.resolve();
        }
      }
    }, userEditorOptions);
  },
  _getAriaTarget: function() {
    if (this.option("searchEnabled")) {
      return this._itemContainer(true);
    }
    return this.callBase();
  },
  _focusTarget: function() {
    if (this.option("searchEnabled")) {
      return this._itemContainer(true);
    }
    return this.callBase();
  },
  _updateFocusState: function(e, isFocused) {
    if (this.option("searchEnabled")) {
      this._toggleFocusClass(isFocused, this.$element());
    }
    this.callBase(e, isFocused);
  },
  getOperationBySearchMode: function(searchMode) {
    return "equals" === searchMode ? "=" : searchMode;
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "searchEnabled":
      case "searchEditorOptions":
        this._invalidate();
        break;
      case "searchExpr":
      case "searchMode":
      case "searchValue":
        if (!this._dataSource) {
          ui_errors_default.log("W1009");
          return;
        }
        if ("searchMode" === args.name) {
          this._dataSource.searchOperation(this.getOperationBySearchMode(args.value));
        } else {
          this._dataSource[args.name](args.value);
        }
        this._dataSource.load();
        break;
      case "searchTimeout":
        break;
      default:
        this.callBase(args);
    }
  },
  focus: function() {
    if (!this.option("focusedElement") && this.option("searchEnabled")) {
      this._searchEditor && this._searchEditor.focus();
      return;
    }
    this.callBase();
  },
  _cleanAria: function() {
    const $element = this.$element();
    this.setAria({
      role: null,
      activedescendant: null
    }, $element);
    $element.attr("tabIndex", null);
  },
  _clean() {
    this.callBase();
    this._cleanAria();
  },
  _refresh: function() {
    if (this._valueChangeDeferred) {
      this._valueChangeDeferred.resolve();
    }
    this.callBase();
  },
  setEditorClass: function(value2) {
    EditorClass = value2;
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/utils/type_conversion.js
function toNumber(attribute) {
  return attribute ? Number(attribute.replace("px", "")) : 0;
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_element_style.js
function getElementStyle(el) {
  var _getWindow$getCompute, _getWindow;
  return el && hasWindow() ? null === (_getWindow$getCompute = (_getWindow = getWindow()).getComputedStyle) || void 0 === _getWindow$getCompute ? void 0 : _getWindow$getCompute.call(_getWindow, el) : null;
}
function getElementMargin(element, side) {
  const style = getElementStyle(element);
  return style ? toNumber(style[`margin${titleize(side)}`]) : 0;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.live_update.js
var PRIVATE_KEY_FIELD = "__dx_key__";
var m_collection_widget_live_update_default = m_collection_widget_edit_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      repaintChangesOnly: false
    });
  },
  ctor() {
    var _this$_dataController;
    this.callBase.apply(this, arguments);
    this._customizeStoreLoadOptions = (e) => {
      const dataController = this._dataController;
      if (dataController.getDataSource() && !this._dataController.isLoaded()) {
        this._correctionIndex = 0;
      }
      if (this._correctionIndex && e.storeLoadOptions) {
        e.storeLoadOptions.skip += this._correctionIndex;
      }
    };
    null === (_this$_dataController = this._dataController) || void 0 === _this$_dataController || _this$_dataController.on("customizeStoreLoadOptions", this._customizeStoreLoadOptions);
  },
  reload() {
    this._correctionIndex = 0;
  },
  _init() {
    this.callBase();
    this._refreshItemsCache();
    this._correctionIndex = 0;
  },
  _findItemElementByKey(key) {
    let result2 = renderer_default();
    const keyExpr = this.key();
    this.itemElements().each((_, item) => {
      const $item = renderer_default(item);
      const itemData = this._getItemData($item);
      if (keyExpr ? keysEqual(keyExpr, this.keyOf(itemData), key) : this._isItemEquals(itemData, key)) {
        result2 = $item;
        return false;
      }
    });
    return result2;
  },
  _dataSourceChangedHandler(newItems, e) {
    if (null !== e && void 0 !== e && e.changes) {
      this._modifyByChanges(e.changes);
    } else {
      this.callBase(newItems, e);
      this._refreshItemsCache();
    }
  },
  _isItemEquals(item1, item2) {
    if (item1 && item1.__dx_key__) {
      item1 = item1.data;
    }
    try {
      return JSON.stringify(item1) === JSON.stringify(item2);
    } catch (e) {
      return item1 === item2;
    }
  },
  _isItemStrictEquals(item1, item2) {
    return this._isItemEquals(item1, item2);
  },
  _shouldAddNewGroup(changes, items) {
    let result2 = false;
    if (this.option("grouped")) {
      if (!changes.length) {
        result2 = true;
      }
      each(changes, (i, change) => {
        if ("insert" === change.type) {
          result2 = true;
          each(items, (_, item) => {
            if (void 0 !== change.data.key && change.data.key === item.key) {
              result2 = false;
              return false;
            }
          });
        }
      });
    }
    return result2;
  },
  _partialRefresh() {
    if (this.option("repaintChangesOnly")) {
      const keyOf = (data2) => {
        if (data2 && void 0 !== data2.__dx_key__) {
          return data2.__dx_key__;
        }
        return this.keyOf(data2);
      };
      const result2 = findChanges(this._itemsCache, this._editStrategy.itemsGetter(), keyOf, this._isItemStrictEquals.bind(this));
      if (result2 && this._itemsCache.length && !this._shouldAddNewGroup(result2, this._itemsCache)) {
        this._modifyByChanges(result2, true);
        this._renderEmptyMessage();
        return true;
      }
      this._refreshItemsCache();
    }
    return false;
  },
  _refreshItemsCache() {
    if (this.option("repaintChangesOnly")) {
      const items = this._editStrategy.itemsGetter();
      try {
        this._itemsCache = extend(true, [], items);
        if (!this.key()) {
          this._itemsCache = this._itemsCache.map((itemCache, index2) => ({
            [PRIVATE_KEY_FIELD]: items[index2],
            data: itemCache
          }));
        }
      } catch (e) {
        this._itemsCache = extend([], items);
      }
    }
  },
  _dispose() {
    this._dataController.off("customizeStoreLoadOptions", this._customizeStoreLoadOptions);
    this.callBase();
  },
  _updateByChange(keyInfo, items, change, isPartialRefresh) {
    if (isPartialRefresh) {
      this._renderItem(change.index, change.data, null, this._findItemElementByKey(change.key));
    } else {
      const changedItem = items[indexByKey(keyInfo, items, change.key)];
      if (changedItem) {
        update(keyInfo, items, change.key, change.data).done(() => {
          this._renderItem(items.indexOf(changedItem), changedItem, null, this._findItemElementByKey(change.key));
        });
      }
    }
  },
  _insertByChange(keyInfo, items, change, isPartialRefresh) {
    when(isPartialRefresh || insert(keyInfo, items, change.data, change.index)).done(() => {
      this._beforeItemElementInserted(change);
      this._renderItem(change.index ?? items.length, change.data);
      this._afterItemElementInserted();
      this._correctionIndex++;
    });
  },
  _updateSelectionAfterRemoveByChange(removeIndex) {
    const selectedIndex = this.option("selectedIndex");
    if (selectedIndex > removeIndex) {
      this.option("selectedIndex", selectedIndex - 1);
    } else if (selectedIndex === removeIndex && 1 === this.option("selectedItems").length) {
      this.option("selectedItems", []);
    } else {
      this._normalizeSelectedItems();
    }
  },
  _beforeItemElementInserted(change) {
    const selectedIndex = this.option("selectedIndex");
    if (change.index <= selectedIndex) {
      this.option("selectedIndex", selectedIndex + 1);
    }
  },
  _afterItemElementInserted: noop2,
  _removeByChange(keyInfo, items, change, isPartialRefresh) {
    const index2 = isPartialRefresh ? change.index : indexByKey(keyInfo, items, change.key);
    const removedItem = isPartialRefresh ? change.oldItem : items[index2];
    if (removedItem) {
      const $removedItemElement = this._findItemElementByKey(change.key);
      const deletedActionArgs = this._extendActionArgs($removedItemElement);
      this._waitDeletingPrepare($removedItemElement).done(() => {
        if (isPartialRefresh) {
          this._updateIndicesAfterIndex(index2 - 1);
          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
          this._updateSelectionAfterRemoveByChange(index2);
        } else {
          this._deleteItemElementByIndex(index2);
          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
        }
      });
      this._correctionIndex--;
    }
  },
  _modifyByChanges(changes, isPartialRefresh) {
    const items = this._editStrategy.itemsGetter();
    const keyInfo = {
      key: this.key.bind(this),
      keyOf: this.keyOf.bind(this)
    };
    const dataController = this._dataController;
    const paginate = dataController.paginate();
    const group = dataController.group();
    if (paginate || group) {
      changes = changes.filter((item) => "insert" !== item.type || void 0 !== item.index);
    }
    changes.forEach((change) => this[`_${change.type}ByChange`](keyInfo, items, change, isPartialRefresh));
    this._renderedItemsCount = items.length;
    this._refreshItemsCache();
    this._fireContentReadyAction();
  },
  _appendItemToContainer($container, $itemFrame, index2) {
    const nextSiblingElement = $container.children(this._itemSelector()).get(index2);
    dom_adapter_default.insertElement($container.get(0), $itemFrame.get(0), nextSiblingElement);
  },
  _optionChanged(args) {
    switch (args.name) {
      case "items": {
        const isItemsUpdated = this._partialRefresh(args.value);
        if (!isItemsUpdated) {
          this.callBase(args);
        }
        break;
      }
      case "dataSource":
        if (!this.option("repaintChangesOnly") || !args.value) {
          this.option("items", []);
        }
        this.callBase(args);
        break;
      case "repaintChangesOnly":
        break;
      default:
        this.callBase(args);
    }
  }
});

// ../../../../../../node_modules/devextreme/esm/ui/collection/ui.collection_widget.live_update.js
var ui_collection_widget_live_update_default = m_collection_widget_live_update_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_load_panel.js
var LoadPanel = ui_overlay_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), {
      escape: noop2
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      message: message_default.format("Loading"),
      width: 222,
      height: 90,
      animation: null,
      showIndicator: true,
      indicatorSrc: "",
      showPane: true,
      delay: 0,
      templatesRenderAsynchronously: false,
      hideTopOverlayHandler: null,
      focusStateEnabled: false,
      propagateOutsideClick: true,
      preventScrollEvents: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: {
        platform: "generic"
      },
      options: {
        shadingColor: "transparent"
      }
    }, {
      device: () => isMaterial(),
      options: {
        message: "",
        width: 60,
        height: 60,
        maxHeight: 60,
        maxWidth: 60
      }
    }, {
      device: () => isFluent(),
      options: {
        width: "auto",
        height: "auto"
      }
    }]);
  },
  _init() {
    this.callBase.apply(this, arguments);
  },
  _render() {
    this.callBase();
    this.$element().addClass("dx-loadpanel");
    this.$wrapper().addClass("dx-loadpanel-wrapper");
    this._updateWrapperAria();
  },
  _updateWrapperAria() {
    this.$wrapper().removeAttr("aria-label").removeAttr("role");
    const showIndicator = this.option("showIndicator");
    if (!showIndicator) {
      const aria = this._getAriaAttributes();
      this.$wrapper().attr(aria);
    }
  },
  _getAriaAttributes() {
    const {
      message
    } = this.option();
    const label = message || message_default.format("Loading");
    const aria = {
      role: "alert",
      "aria-label": label
    };
    return aria;
  },
  _renderContentImpl() {
    this.callBase();
    this.$content().addClass("dx-loadpanel-content");
    this._$loadPanelContentWrapper = renderer_default("<div>").addClass("dx-loadpanel-content-wrapper");
    this._$loadPanelContentWrapper.appendTo(this.$content());
    this._togglePaneVisible();
    this._cleanPreviousContent();
    this._renderLoadIndicator();
    this._renderMessage();
  },
  _show() {
    const delay = this.option("delay");
    if (!delay) {
      return this.callBase();
    }
    const deferred = Deferred();
    const callBase = this.callBase.bind(this);
    this._clearShowTimeout();
    this._showTimeout = setTimeout(() => {
      callBase().done(() => {
        deferred.resolve();
      });
    }, delay);
    return deferred.promise();
  },
  _hide() {
    this._clearShowTimeout();
    return this.callBase();
  },
  _clearShowTimeout() {
    clearTimeout(this._showTimeout);
  },
  _renderMessage() {
    if (!this._$loadPanelContentWrapper) {
      return;
    }
    const message = this.option("message");
    if (!message) {
      return;
    }
    const $message = renderer_default("<div>").addClass("dx-loadpanel-message").text(message);
    this._$loadPanelContentWrapper.append($message);
  },
  _renderLoadIndicator() {
    if (!this._$loadPanelContentWrapper || !this.option("showIndicator")) {
      return;
    }
    if (!this._$indicator) {
      this._$indicator = renderer_default("<div>").addClass("dx-loadpanel-indicator").appendTo(this._$loadPanelContentWrapper);
    }
    this._createComponent(this._$indicator, load_indicator_default, {
      elementAttr: this._getAriaAttributes(),
      indicatorSrc: this.option("indicatorSrc")
    });
  },
  _cleanPreviousContent() {
    this.$content().find(".dx-loadpanel-message").remove();
    this.$content().find(".dx-loadpanel-indicator").remove();
    delete this._$indicator;
  },
  _togglePaneVisible() {
    this.$content().toggleClass("dx-loadpanel-pane-hidden", !this.option("showPane"));
  },
  _optionChanged(args) {
    switch (args.name) {
      case "delay":
        break;
      case "message":
      case "showIndicator":
        this._cleanPreviousContent();
        this._renderLoadIndicator();
        this._renderMessage();
        this._updateWrapperAria();
        break;
      case "showPane":
        this._togglePaneVisible();
        break;
      case "indicatorSrc":
        this._renderLoadIndicator();
        break;
      default:
        this.callBase(args);
    }
  },
  _dispose() {
    this._clearShowTimeout();
    this.callBase();
  }
});
component_registrator_default("dxLoadPanel", LoadPanel);
var m_load_panel_default = LoadPanel;

// ../../../../../../node_modules/devextreme/esm/ui/load_panel.js
var load_panel_default = m_load_panel_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollbar.js
var SCROLLBAR = "dxScrollbar";
var HOVER_ENABLED_STATE = "dx-scrollbar-hoverable";
var HORIZONTAL = "horizontal";
var SCROLLBAR_VISIBLE = {
  onScroll: "onScroll",
  onHover: "onHover",
  always: "always",
  never: "never"
};
var activeScrollbar = null;
var Scrollbar = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      direction: null,
      visible: false,
      activeStateEnabled: false,
      visibilityMode: SCROLLBAR_VISIBLE.onScroll,
      containerSize: 0,
      contentSize: 0,
      expandable: true,
      scaleRatio: 1
    });
  },
  _init() {
    this.callBase();
    this._isHovered = false;
  },
  _initMarkup() {
    this._renderThumb();
    this.callBase();
  },
  _render() {
    this.callBase();
    this._renderDirection();
    this._update();
    this._attachPointerDownHandler();
    this.option("hoverStateEnabled", this._isHoverMode());
    this.$element().toggleClass(HOVER_ENABLED_STATE, this.option("hoverStateEnabled"));
  },
  _renderThumb() {
    this._$thumb = renderer_default("<div>").addClass("dx-scrollable-scroll");
    renderer_default("<div>").addClass("dx-scrollable-scroll-content").appendTo(this._$thumb);
    this.$element().addClass("dx-scrollable-scrollbar").append(this._$thumb);
  },
  isThumb($element) {
    return !!this.$element().find($element).length;
  },
  _isHoverMode() {
    const visibilityMode = this.option("visibilityMode");
    return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && this.option("expandable");
  },
  _renderDirection() {
    const direction = this.option("direction");
    this.$element().addClass(`dx-scrollbar-${direction}`);
    this._dimension = direction === HORIZONTAL ? "width" : "height";
    this._prop = direction === HORIZONTAL ? "left" : "top";
  },
  _attachPointerDownHandler() {
    events_engine_default.on(this._$thumb, addNamespace2(pointer_default.down, SCROLLBAR), this.feedbackOn.bind(this));
  },
  feedbackOn(e) {
    null === e || void 0 === e || e.preventDefault();
    this.$element().addClass("dx-scrollable-scrollbar-active");
    activeScrollbar = this;
  },
  feedbackOff() {
    this.$element().removeClass("dx-scrollable-scrollbar-active");
    activeScrollbar = null;
  },
  cursorEnter() {
    this._isHovered = true;
    if (this._needScrollbar()) {
      this.option("visible", true);
    }
  },
  cursorLeave() {
    this._isHovered = false;
    this.option("visible", false);
  },
  _renderDimensions() {
    this._$thumb.css({
      width: this.option("width"),
      height: this.option("height")
    });
  },
  _toggleVisibility(visible2) {
    if (this.option("visibilityMode") === SCROLLBAR_VISIBLE.onScroll) {
      this._$thumb.css("opacity");
    }
    visible2 = this._adjustVisibility(visible2);
    this.option().visible = visible2;
    this._$thumb.toggleClass("dx-state-invisible", !visible2);
  },
  _adjustVisibility(visible2) {
    if (this._baseContainerToContentRatio && !this._needScrollbar()) {
      return false;
    }
    switch (this.option("visibilityMode")) {
      case SCROLLBAR_VISIBLE.onScroll:
        break;
      case SCROLLBAR_VISIBLE.onHover:
        visible2 = visible2 || !!this._isHovered;
        break;
      case SCROLLBAR_VISIBLE.never:
        visible2 = false;
        break;
      case SCROLLBAR_VISIBLE.always:
        visible2 = true;
    }
    return visible2;
  },
  moveTo(location) {
    if (this._isHidden()) {
      return;
    }
    if (isPlainObject(location)) {
      location = location[this._prop] || 0;
    }
    const scrollBarLocation = {};
    scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
    move(this._$thumb, scrollBarLocation);
  },
  _calculateScrollBarPosition(location) {
    return -location * this._thumbRatio;
  },
  _update() {
    const containerSize = Math.round(this.option("containerSize"));
    const contentSize = Math.round(this.option("contentSize"));
    let baseContainerSize = Math.round(this.option("baseContainerSize"));
    let baseContentSize = Math.round(this.option("baseContentSize"));
    if (isNaN(baseContainerSize)) {
      baseContainerSize = containerSize;
      baseContentSize = contentSize;
    }
    this._baseContainerToContentRatio = baseContentSize ? baseContainerSize / baseContentSize : baseContainerSize;
    this._realContainerToContentRatio = contentSize ? containerSize / contentSize : containerSize;
    const thumbSize = Math.round(Math.max(Math.round(containerSize * this._realContainerToContentRatio), 15));
    this._thumbRatio = (containerSize - thumbSize) / (this.option("scaleRatio") * (contentSize - containerSize));
    this.option(this._dimension, thumbSize / this.option("scaleRatio"));
    this.$element().css("display", this._needScrollbar() ? "" : "none");
  },
  _isHidden() {
    return this.option("visibilityMode") === SCROLLBAR_VISIBLE.never;
  },
  _needScrollbar() {
    return !this._isHidden() && this._baseContainerToContentRatio < 1;
  },
  containerToContentRatio() {
    return this._realContainerToContentRatio;
  },
  _normalizeSize(size) {
    return isPlainObject(size) ? size[this._dimension] || 0 : size;
  },
  _clean() {
    this.callBase();
    if (this === activeScrollbar) {
      activeScrollbar = null;
    }
    events_engine_default.off(this._$thumb, `.${SCROLLBAR}`);
  },
  _optionChanged(args) {
    if (this._isHidden()) {
      return;
    }
    switch (args.name) {
      case "containerSize":
      case "contentSize":
        this.option()[args.name] = this._normalizeSize(args.value);
        this._update();
        break;
      case "baseContentSize":
      case "baseContainerSize":
      case "scaleRatio":
        this._update();
        break;
      case "visibilityMode":
      case "direction":
        this._invalidate();
        break;
      default:
        this.callBase.apply(this, arguments);
    }
  },
  update: deferRenderer(function() {
    this._adjustVisibility() && this.option("visible", true);
  })
});
ready_callbacks_default.add(() => {
  events_engine_default.subscribeGlobal(dom_adapter_default.getDocument(), addNamespace2(pointer_default.up, SCROLLBAR), () => {
    if (activeScrollbar) {
      activeScrollbar.feedbackOff();
    }
  });
});
var m_scrollbar_default = Scrollbar;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.native.js
var SCROLLABLE_NATIVE = "dxNativeScrollable";
var SCROLLABLE_SCROLLBAR_SIMULATED = "dx-scrollable-scrollbar-simulated";
var SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden";
var VERTICAL = "vertical";
var HORIZONTAL2 = "horizontal";
var NativeStrategy = class_default.inherit({
  ctor(scrollable) {
    this._init(scrollable);
  },
  _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = renderer_default(scrollable.container());
    this._$content = scrollable.$content();
    this._direction = scrollable.option("direction");
    this._useSimulatedScrollbar = scrollable.option("useSimulatedScrollbar");
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
    this._isRtlNativeStrategy = scrollable._isRtlNativeStrategy.bind(scrollable);
  },
  render() {
    const device = devices_default.real();
    const deviceType = device.platform;
    this._$element.addClass("dx-scrollable-native").addClass(`dx-scrollable-native-${deviceType}`).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._isScrollbarVisible());
    if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
      this._renderScrollbars();
    }
  },
  updateRtlPosition(isFirstRender) {
    if (isFirstRender && this.option("rtlEnabled")) {
      if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
        this._moveScrollbars();
      }
    }
  },
  _renderScrollbars() {
    this._scrollbars = {};
    this._hideScrollbarTimeout = 0;
    this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
    this._renderScrollbar(VERTICAL);
    this._renderScrollbar(HORIZONTAL2);
  },
  _renderScrollbar(direction) {
    if (!this._isDirection(direction)) {
      return;
    }
    this._scrollbars[direction] = new m_scrollbar_default(renderer_default("<div>").appendTo(this._$element), {
      direction,
      expandable: this._component.option("scrollByThumb")
    });
  },
  handleInit: noop2,
  handleStart: noop2,
  handleMove(e) {
    if (this._isLocked()) {
      e.cancel = true;
      return;
    }
    if (this._allowedDirection()) {
      e.originalEvent.isScrollingEvent = true;
    }
  },
  handleEnd: noop2,
  handleCancel: noop2,
  handleStop: noop2,
  _eachScrollbar(callback) {
    callback = callback.bind(this);
    each(this._scrollbars || {}, (direction, scrollbar) => {
      callback(scrollbar, direction);
    });
  },
  createActions() {
    this._scrollAction = this._createActionByOption("onScroll");
    this._updateAction = this._createActionByOption("onUpdated");
  },
  _createActionArgs() {
    const {
      left,
      top
    } = this.location();
    return {
      event: this._eventForUserAction,
      scrollOffset: this._getScrollOffset(),
      reachedLeft: this._isRtlNativeStrategy() ? this._isReachedRight(-left) : this._isReachedLeft(left),
      reachedRight: this._isRtlNativeStrategy() ? this._isReachedLeft(-Math.abs(left)) : this._isReachedRight(left),
      reachedTop: this._isDirection(VERTICAL) ? Math.round(top) >= 0 : void 0,
      reachedBottom: this._isDirection(VERTICAL) ? Math.round(Math.abs(top) - this._getMaxOffset().top) >= 0 : void 0
    };
  },
  _getScrollOffset() {
    const {
      top,
      left
    } = this.location();
    return {
      top: -top,
      left: this._normalizeOffsetLeft(-left)
    };
  },
  _normalizeOffsetLeft(scrollLeft) {
    if (this._isRtlNativeStrategy()) {
      return this._getMaxOffset().left + scrollLeft;
    }
    return scrollLeft;
  },
  _isReachedLeft(left) {
    return this._isDirection(HORIZONTAL2) ? Math.round(left) >= 0 : void 0;
  },
  _isReachedRight(left) {
    return this._isDirection(HORIZONTAL2) ? Math.round(Math.abs(left) - this._getMaxOffset().left) >= 0 : void 0;
  },
  _isScrollbarVisible() {
    const {
      showScrollbar
    } = this.option();
    return "never" !== showScrollbar && false !== showScrollbar;
  },
  handleScroll(e) {
    this._eventForUserAction = e;
    this._moveScrollbars();
    this._scrollAction(this._createActionArgs());
  },
  _moveScrollbars() {
    const {
      top,
      left
    } = this._getScrollOffset();
    this._eachScrollbar((scrollbar) => {
      scrollbar.moveTo({
        top: -top,
        left: -left
      });
      scrollbar.option("visible", true);
    });
    this._hideScrollbars();
  },
  _hideScrollbars() {
    clearTimeout(this._hideScrollbarTimeout);
    this._hideScrollbarTimeout = setTimeout(() => {
      this._eachScrollbar((scrollbar) => {
        scrollbar.option("visible", false);
      });
    }, 500);
  },
  location() {
    return {
      left: -this._$container.scrollLeft(),
      top: -this._$container.scrollTop()
    };
  },
  disabledChanged: noop2,
  update() {
    this._update();
    this._updateAction(this._createActionArgs());
  },
  _update() {
    this._updateDimensions();
    this._updateScrollbars();
  },
  _updateDimensions() {
    this._containerSize = {
      height: getHeight(this._$container),
      width: getWidth(this._$container)
    };
    this._componentContentSize = {
      height: getHeight(this._component.$content()),
      width: getWidth(this._component.$content())
    };
    this._contentSize = {
      height: getHeight(this._$content),
      width: getWidth(this._$content)
    };
  },
  _updateScrollbars() {
    this._eachScrollbar(function(scrollbar, direction) {
      const dimension = direction === VERTICAL ? "height" : "width";
      scrollbar.option({
        containerSize: this._containerSize[dimension],
        contentSize: this._componentContentSize[dimension]
      });
      scrollbar.update();
    });
  },
  _allowedDirections() {
    return {
      vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
      horizontal: this._isDirection(HORIZONTAL2) && this._contentSize.width > this._containerSize.width
    };
  },
  dispose() {
    const {
      className
    } = this._$element.get(0);
    const scrollableNativeRegexp = new RegExp("dx-scrollable-native\\S*", "g");
    if (scrollableNativeRegexp.test(className)) {
      this._$element.removeClass(className.match(scrollableNativeRegexp).join(" "));
    }
    events_engine_default.off(this._$element, `.${SCROLLABLE_NATIVE}`);
    events_engine_default.off(this._$container, `.${SCROLLABLE_NATIVE}`);
    this._removeScrollbars();
    clearTimeout(this._hideScrollbarTimeout);
  },
  _removeScrollbars() {
    this._eachScrollbar((scrollbar) => {
      scrollbar.$element().remove();
    });
  },
  scrollBy(distance) {
    const location = this.location();
    this._$container.scrollTop(Math.round(-location.top - distance.top));
    this._$container.scrollLeft(Math.round(-location.left - distance.left));
  },
  validate(e) {
    if (this.option("disabled")) {
      return false;
    }
    if (isDxMouseWheelEvent(e) && this._isScrolledInMaxDirection(e)) {
      return false;
    }
    return !!this._allowedDirection();
  },
  _isScrolledInMaxDirection(e) {
    const container = this._$container.get(0);
    let result2;
    if (e.delta > 0) {
      result2 = e.shiftKey ? !container.scrollLeft : !container.scrollTop;
    } else if (e.shiftKey) {
      result2 = container.scrollLeft >= this._getMaxOffset().left;
    } else {
      result2 = container.scrollTop >= this._getMaxOffset().top;
    }
    return result2;
  },
  getDirection() {
    return this._allowedDirection();
  }
});
var m_scrollable_native_default = NativeStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.native.pull_down.js
var PullDownNativeScrollViewStrategy = m_scrollable_native_default.inherit({
  _init(scrollView) {
    this.callBase(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$refreshingText = scrollView._$refreshingText;
    this._$scrollViewContent = renderer_default(scrollView.content());
    this._$container = renderer_default(scrollView.container());
    this._initCallbacks();
  },
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  },
  render() {
    this.callBase();
    this._renderPullDown();
    this._releaseState();
  },
  _renderPullDown() {
    const $image = renderer_default("<div>").addClass("dx-scrollview-pull-down-image");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    const $text = this._$pullDownText = renderer_default("<div>").addClass("dx-scrollview-pull-down-text");
    this._$pullingDownText = renderer_default("<div>").text(this.option("pullingDownText")).appendTo($text);
    this._$pulledDownText = renderer_default("<div>").text(this.option("pulledDownText")).appendTo($text);
    this._$refreshingText = renderer_default("<div>").text(this.option("refreshingText")).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  },
  _releaseState() {
    this._state = 0;
    this._refreshPullDownText();
  },
  _refreshPullDownText() {
    const that = this;
    const pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: 0
    }, {
      element: this._$pulledDownText,
      visibleState: 1
    }, {
      element: this._$refreshingText,
      visibleState: 2
    }];
    each(pullDownTextItems, (_, item) => {
      const action = that._state === item.visibleState ? "addClass" : "removeClass";
      item.element[action]("dx-scrollview-pull-down-text-visible");
    });
  },
  update() {
    this.callBase();
    this._setTopPocketOffset();
  },
  _updateDimensions() {
    this.callBase();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const contentEl = this._$scrollViewContent.get(0);
    const containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  },
  _allowedDirections() {
    const allowedDirections = this.callBase();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  },
  _setTopPocketOffset() {
    this._$topPocket.css({
      top: -this._topPocketSize
    });
  },
  handleEnd() {
    this.callBase();
    this._complete();
  },
  handleStop() {
    this.callBase();
    this._complete();
  },
  _complete() {
    if (1 === this._state) {
      this._setPullDownOffset(this._topPocketSize);
      clearTimeout(this._pullDownRefreshTimeout);
      this._pullDownRefreshTimeout = setTimeout(() => {
        this._pullDownRefreshing();
      }, 400);
    }
  },
  _setPullDownOffset(offset2) {
    move(this._$topPocket, {
      top: offset2
    });
    move(this._$scrollViewContent, {
      top: offset2
    });
  },
  handleScroll(e) {
    this.callBase(e);
    if (2 === this._state) {
      return;
    }
    const currentLocation = this.location().top;
    const scrollDelta = (this._location || 0) - currentLocation;
    this._location = currentLocation;
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  },
  _isPullDown() {
    return this._pullDownEnabled && this._location >= this._topPocketSize;
  },
  _isReachBottom() {
    return this._reachBottomEnabled && Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  },
  _reachBottom() {
    if (3 === this._state) {
      return;
    }
    this._state = 3;
    this.reachBottomCallbacks.fire();
  },
  _pullDownReady() {
    if (1 === this._state) {
      return;
    }
    this._state = 1;
    this._$pullDown.addClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
  },
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._releaseState();
  },
  _pullDownRefreshing() {
    if (2 === this._state) {
      return;
    }
    this._state = 2;
    this._$pullDown.addClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  },
  pullDownEnable(enabled) {
    if (enabled) {
      this._updateDimensions();
      this._setTopPocketOffset();
    }
    this._pullDownEnabled = enabled;
  },
  reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  },
  pendingRelease() {
    this._state = 1;
  },
  release() {
    const deferred = Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    if (3 === this._state) {
      this._state = 0;
    }
    this._releaseTimeout = setTimeout(() => {
      this._setPullDownOffset(0);
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }, 400);
    return deferred.promise();
  },
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    this.callBase();
  }
});
var m_scroll_view_native_pull_down_default = PullDownNativeScrollViewStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.native.swipe_down.js
var SwipeDownNativeScrollViewStrategy = m_scrollable_native_default.inherit({
  _init(scrollView) {
    this.callBase(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$scrollViewContent = renderer_default(scrollView.content());
    this._$container = renderer_default(scrollView.container());
    this._initCallbacks();
    this._location = 0;
  },
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  },
  render() {
    this.callBase();
    this._renderPullDown();
    this._releaseState();
  },
  _renderPullDown() {
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    this._$icon = renderer_default("<div>").addClass("dx-icon-pulldown");
    this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator));
  },
  _releaseState() {
    this._state = 0;
    this._releasePullDown();
    this._updateDimensions();
  },
  _releasePullDown() {
    this._$pullDown.css({
      opacity: 0
    });
  },
  _updateDimensions() {
    this.callBase();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const contentEl = this._$scrollViewContent.get(0);
    const containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  },
  _allowedDirections() {
    const allowedDirections = this.callBase();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  },
  handleInit(e) {
    this.callBase(e);
    if (0 === this._state && 0 === this._location) {
      this._startClientY = eventData(e.originalEvent).y;
      this._state = 4;
    }
  },
  handleMove(e) {
    this.callBase(e);
    this._deltaY = eventData(e.originalEvent).y - this._startClientY;
    if (4 === this._state) {
      if (this._pullDownEnabled && this._deltaY > 0) {
        this._state = 5;
      } else {
        this._complete();
      }
    }
    if (5 === this._state) {
      e.preventDefault();
      this._movePullDown();
    }
  },
  _movePullDown() {
    const pullDownHeight = this._getPullDownHeight();
    const top = Math.min(3 * pullDownHeight, this._deltaY + this._getPullDownStartPosition());
    const angle = 180 * top / pullDownHeight / 3;
    this._$pullDown.css({
      opacity: 1
    }).toggleClass("dx-scrollview-pull-down-refreshing", top < pullDownHeight);
    move(this._$pullDown, {
      top
    });
    this._$icon.css({
      transform: `rotate(${angle}deg)`
    });
  },
  _isPullDown() {
    return this._pullDownEnabled && 5 === this._state && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition();
  },
  _getPullDownHeight() {
    return Math.round(0.05 * getOuterHeight(this._$element));
  },
  _getPullDownStartPosition() {
    return -Math.round(1.5 * getOuterHeight(this._$pullDown));
  },
  handleEnd() {
    if (this._isPullDown()) {
      this._pullDownRefreshing();
    }
    this._complete();
  },
  handleStop() {
    this._complete();
  },
  _complete() {
    if (4 === this._state || 5 === this._state) {
      this._releaseState();
    }
  },
  handleScroll(e) {
    this.callBase(e);
    if (2 === this._state) {
      return;
    }
    const currentLocation = this.location().top;
    const scrollDelta = this._location - currentLocation;
    this._location = currentLocation;
    if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  },
  _isReachBottom() {
    return this._reachBottomEnabled && Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  },
  _reachBottom() {
    this.reachBottomCallbacks.fire();
  },
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading");
    this._releaseState();
  },
  _pullDownRefreshing() {
    this._state = 2;
    this._pullDownRefreshHandler();
  },
  _pullDownRefreshHandler() {
    this._refreshPullDown();
    this.pullDownCallbacks.fire();
  },
  _refreshPullDown() {
    this._$pullDown.addClass("dx-scrollview-pull-down-loading");
    move(this._$pullDown, {
      top: this._getPullDownHeight()
    });
  },
  pullDownEnable(enabled) {
    this._$topPocket.toggle(enabled);
    this._pullDownEnabled = enabled;
  },
  reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  },
  pendingRelease() {
    this._state = 1;
  },
  release() {
    const deferred = Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    this._releaseTimeout = setTimeout(() => {
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }, 800);
    return deferred.promise();
  },
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    this.callBase();
  }
});
var m_scroll_view_native_swipe_down_default = SwipeDownNativeScrollViewStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_animator.js
var {
  abstract: abstract8
} = class_default;
var Animator = class_default.inherit({
  ctor() {
    this._finished = true;
    this._stopped = false;
    this._proxiedStepCore = this._stepCore.bind(this);
  },
  start() {
    this._stopped = false;
    this._finished = false;
    this._stepCore();
  },
  stop() {
    this._stopped = true;
    cancelAnimationFrame(this._stepAnimationFrame);
  },
  _stepCore() {
    if (this._isStopped()) {
      this._stop();
      return;
    }
    if (this._isFinished()) {
      this._finished = true;
      this._complete();
      return;
    }
    this._step();
    this._stepAnimationFrame = requestAnimationFrame(this._proxiedStepCore);
  },
  _step: abstract8,
  _isFinished: noop2,
  _stop: noop2,
  _complete: noop2,
  _isStopped() {
    return this._stopped;
  },
  inProgress() {
    return !(this._stopped || this._finished);
  }
});
var m_animator_default = Animator;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.simulated.js
var SCROLLABLE_SIMULATED = "dxSimulatedScrollable";
var SCROLLABLE_STRATEGY = "dxScrollableStrategy";
var SCROLLABLE_SIMULATED_CURSOR = `${SCROLLABLE_SIMULATED}Cursor`;
var SCROLLABLE_SIMULATED_KEYBOARD = `${SCROLLABLE_SIMULATED}Keyboard`;
var SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = "dx-scrollable-scrollbars-alwaysvisible";
var VERTICAL2 = "vertical";
var HORIZONTAL3 = "horizontal";
var FRAME_DURATION = Math.round(1e3 / 60);
var BOUNCE_FRAMES = 400 / FRAME_DURATION;
var BOUNCE_ACCELERATION_SUM = (1 - 0.92 ** BOUNCE_FRAMES) / (1 - 0.92);
var KEY_CODES = {
  PAGE_UP: "pageUp",
  PAGE_DOWN: "pageDown",
  END: "end",
  HOME: "home",
  LEFT: "leftArrow",
  UP: "upArrow",
  RIGHT: "rightArrow",
  DOWN: "downArrow",
  TAB: "tab"
};
var InertiaAnimator = m_animator_default.inherit({
  ctor(scroller) {
    this.callBase();
    this.scroller = scroller;
  },
  VELOCITY_LIMIT: 1,
  _isFinished() {
    return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;
  },
  _step() {
    this.scroller._scrollStep(this.scroller._velocity);
    this.scroller._velocity *= this._acceleration();
  },
  _acceleration() {
    return this.scroller._inBounds() ? 0.92 : 0.5;
  },
  _complete() {
    this.scroller._scrollComplete();
  }
});
var BounceAnimator = InertiaAnimator.inherit({
  VELOCITY_LIMIT: 0.2,
  _isFinished() {
    return this.scroller._crossBoundOnNextStep() || this.callBase();
  },
  _acceleration: () => 0.92,
  _complete() {
    this.scroller._move(this.scroller._bounceLocation);
    this.callBase();
  }
});
var Scroller = class_default.inherit({
  ctor(options2) {
    this._initOptions(options2);
    this._initAnimators();
    this._initScrollbar();
  },
  _initOptions(options2) {
    this._location = 0;
    this._topReached = false;
    this._bottomReached = false;
    this._axis = options2.direction === HORIZONTAL3 ? "x" : "y";
    this._prop = options2.direction === HORIZONTAL3 ? "left" : "top";
    this._dimension = options2.direction === HORIZONTAL3 ? "width" : "height";
    this._scrollProp = options2.direction === HORIZONTAL3 ? "scrollLeft" : "scrollTop";
    each(options2, (optionName, optionValue) => {
      this[`_${optionName}`] = optionValue;
    });
  },
  _initAnimators() {
    this._inertiaAnimator = new InertiaAnimator(this);
    this._bounceAnimator = new BounceAnimator(this);
  },
  _initScrollbar() {
    this._scrollbar = new m_scrollbar_default(renderer_default("<div>").appendTo(this._$container), {
      direction: this._direction,
      visible: this._scrollByThumb,
      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
      expandable: this._scrollByThumb
    });
    this._$scrollbar = this._scrollbar.$element();
  },
  _visibilityModeNormalize: (mode) => true === mode ? "onScroll" : false === mode ? "never" : mode,
  _scrollStep(delta) {
    const prevLocation = this._location;
    this._location += delta;
    this._suppressBounce();
    this._move();
    if (Math.abs(prevLocation - this._location) < 1) {
      return;
    }
    events_engine_default.triggerHandler(this._$container, {
      type: "scroll"
    });
  },
  _suppressBounce() {
    if (this._bounceEnabled || this._inBounds(this._location)) {
      return;
    }
    this._velocity = 0;
    this._location = this._boundLocation();
  },
  _boundLocation(location) {
    location = void 0 !== location ? location : this._location;
    return Math.max(Math.min(location, this._maxOffset), this._minOffset);
  },
  _move(location) {
    this._location = void 0 !== location ? location * this._getScaleRatio() : this._location;
    this._moveContent();
    this._moveScrollbar();
  },
  _moveContent() {
    const location = this._location;
    this._$container[this._scrollProp](-location / this._getScaleRatio());
    this._moveContentByTranslator(location);
  },
  _getScaleRatio() {
    if (hasWindow() && !this._scaleRatio) {
      const element = this._$element.get(0);
      const realDimension = this._getRealDimension(element, this._dimension);
      const baseDimension = this._getBaseDimension(element, this._dimension);
      this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100;
    }
    return this._scaleRatio || 1;
  },
  _getRealDimension: (element, dimension) => Math.round(getBoundingRect(element)[dimension]),
  _getBaseDimension(element, dimension) {
    const dimensionName = `offset${titleize(dimension)}`;
    return element[dimensionName];
  },
  _moveContentByTranslator(location) {
    let translateOffset;
    const minOffset = -this._maxScrollPropValue;
    if (location > 0) {
      translateOffset = location;
    } else if (location <= minOffset) {
      translateOffset = location - minOffset;
    } else {
      translateOffset = location % 1;
    }
    if (this._translateOffset === translateOffset) {
      return;
    }
    const targetLocation = {};
    targetLocation[this._prop] = translateOffset;
    this._translateOffset = translateOffset;
    if (0 === translateOffset) {
      resetPosition(this._$content);
      return;
    }
    move(this._$content, targetLocation);
  },
  _moveScrollbar() {
    this._scrollbar.moveTo(this._location);
  },
  _scrollComplete() {
    if (this._inBounds()) {
      this._hideScrollbar();
      if (this._completeDeferred) {
        this._completeDeferred.resolve();
      }
    }
    this._scrollToBounds();
  },
  _scrollToBounds() {
    if (this._inBounds()) {
      return;
    }
    this._bounceAction();
    this._setupBounce();
    this._bounceAnimator.start();
  },
  _setupBounce() {
    const boundLocation = this._bounceLocation = this._boundLocation();
    const bounceDistance = boundLocation - this._location;
    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;
  },
  _inBounds(location) {
    location = void 0 !== location ? location : this._location;
    return this._boundLocation(location) === location;
  },
  _crossBoundOnNextStep() {
    const location = this._location;
    const nextLocation = location + this._velocity;
    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;
  },
  _initHandler(e) {
    this._stopScrolling();
    this._prepareThumbScrolling(e);
  },
  _stopScrolling: deferRenderer(function() {
    this._hideScrollbar();
    this._inertiaAnimator.stop();
    this._bounceAnimator.stop();
  }),
  _prepareThumbScrolling(e) {
    if (isDxMouseWheelEvent(e.originalEvent)) {
      return;
    }
    const $target = renderer_default(e.originalEvent.target);
    const scrollbarClicked = this._isScrollbar($target);
    if (scrollbarClicked) {
      this._moveToMouseLocation(e);
    }
    this._thumbScrolling = scrollbarClicked || this._isThumb($target);
    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
    if (this._thumbScrolling) {
      this._scrollbar.feedbackOn();
    }
  },
  _isThumbScrollingHandler($target) {
    return this._isThumb($target);
  },
  _moveToMouseLocation(e) {
    const mouseLocation = e[`page${this._axis.toUpperCase()}`] - this._$element.offset()[this._prop];
    const location = this._location + mouseLocation / this._containerToContentRatio() - getHeight(this._$container) / 2;
    this._scrollStep(-Math.round(location));
  },
  _startHandler() {
    this._showScrollbar();
  },
  _moveHandler(delta) {
    if (this._crossThumbScrolling) {
      return;
    }
    if (this._thumbScrolling) {
      delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());
    }
    this._scrollBy(delta);
  },
  _scrollBy(delta) {
    delta = delta[this._axis];
    if (!this._inBounds()) {
      delta *= 0.5;
    }
    this._scrollStep(delta);
  },
  _scrollByHandler(delta) {
    this._scrollBy(delta);
    this._scrollComplete();
  },
  _containerToContentRatio() {
    return this._scrollbar.containerToContentRatio();
  },
  _endHandler(velocity) {
    this._completeDeferred = Deferred();
    this._velocity = velocity[this._axis];
    this._inertiaHandler();
    this._resetThumbScrolling();
    return this._completeDeferred.promise();
  },
  _inertiaHandler() {
    this._suppressInertia();
    this._inertiaAnimator.start();
  },
  _suppressInertia() {
    if (!this._inertiaEnabled || this._thumbScrolling) {
      this._velocity = 0;
    }
  },
  _resetThumbScrolling() {
    this._thumbScrolling = false;
    this._crossThumbScrolling = false;
  },
  _stopHandler() {
    if (this._thumbScrolling) {
      this._scrollComplete();
    }
    this._resetThumbScrolling();
    this._scrollToBounds();
  },
  _disposeHandler() {
    this._stopScrolling();
    this._$scrollbar.remove();
  },
  _updateHandler() {
    this._update();
    this._moveToBounds();
  },
  _update() {
    this._stopScrolling();
    return deferUpdate(() => {
      this._resetScaleRatio();
      this._updateLocation();
      this._updateBounds();
      this._updateScrollbar();
      deferRender(() => {
        this._moveScrollbar();
        this._scrollbar.update();
      });
    });
  },
  _resetScaleRatio() {
    this._scaleRatio = null;
  },
  _updateLocation() {
    this._location = (locate(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();
  },
  _updateBounds() {
    this._maxOffset = this._getMaxOffset();
    this._minOffset = this._getMinOffset();
  },
  _getMaxOffset: () => 0,
  _getMinOffset() {
    this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);
    return -this._maxScrollPropValue;
  },
  _updateScrollbar: deferUpdater(function() {
    const containerSize = this._containerSize();
    const contentSize = this._contentSize();
    const baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);
    const baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);
    deferRender(() => {
      this._scrollbar.option({
        containerSize,
        contentSize,
        baseContainerSize,
        baseContentSize,
        scaleRatio: this._getScaleRatio()
      });
    });
  }),
  _moveToBounds: deferRenderer(deferUpdater(deferRenderer(function() {
    const location = this._boundLocation();
    const locationChanged = location !== this._location;
    this._location = location;
    this._move();
    if (locationChanged) {
      this._scrollAction();
    }
  }))),
  _createActionsHandler(actions) {
    this._scrollAction = actions.scroll;
    this._bounceAction = actions.bounce;
  },
  _showScrollbar() {
    this._scrollbar.option("visible", true);
  },
  _hideScrollbar() {
    this._scrollbar.option("visible", false);
  },
  _containerSize() {
    return this._getRealDimension(this._$container.get(0), this._dimension);
  },
  _contentSize() {
    const isOverflowHidden = "hidden" === this._$content.css(`overflow${this._axis.toUpperCase()}`);
    let contentSize = this._getRealDimension(this._$content.get(0), this._dimension);
    if (!isOverflowHidden) {
      const containerScrollSize = this._$content[0][`scroll${titleize(this._dimension)}`] * this._getScaleRatio();
      contentSize = Math.max(containerScrollSize, contentSize);
    }
    return contentSize;
  },
  _validateEvent(e) {
    const $target = renderer_default(e.originalEvent.target);
    return this._isThumb($target) || this._isScrollbar($target);
  },
  _isThumb($element) {
    return this._scrollByThumb && this._scrollbar.isThumb($element);
  },
  _isScrollbar($element) {
    return this._scrollByThumb && $element && $element.is(this._$scrollbar);
  },
  _reachedMin() {
    return Math.round(this._location - this._minOffset) <= 0;
  },
  _reachedMax() {
    return Math.round(this._location - this._maxOffset) >= 0;
  },
  _cursorEnterHandler() {
    this._resetScaleRatio();
    this._updateScrollbar();
    this._scrollbar.cursorEnter();
  },
  _cursorLeaveHandler() {
    this._scrollbar.cursorLeave();
  },
  dispose: noop2
});
var hoveredScrollable;
var activeScrollable;
var SimulatedStrategy = class_default.inherit({
  ctor(scrollable) {
    this._init(scrollable);
  },
  _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = renderer_default(scrollable.container());
    this._$wrapper = scrollable._$wrapper;
    this._$content = scrollable.$content();
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
  },
  render() {
    this._$element.addClass("dx-scrollable-simulated");
    this._createScrollers();
    if (this.option("useKeyboard")) {
      this._$container.prop("tabIndex", 0);
    }
    this._attachKeyboardHandler();
    this._attachCursorHandlers();
  },
  _createScrollers() {
    this._scrollers = {};
    if (this._isDirection(HORIZONTAL3)) {
      this._createScroller(HORIZONTAL3);
    }
    if (this._isDirection(VERTICAL2)) {
      this._createScroller(VERTICAL2);
    }
    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, "always" === this.option("showScrollbar"));
  },
  _createScroller(direction) {
    this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));
  },
  _scrollerOptions(direction) {
    return {
      direction,
      $content: this._$content,
      $container: this._$container,
      $wrapper: this._$wrapper,
      $element: this._$element,
      scrollByThumb: this.option("scrollByThumb"),
      scrollbarVisible: this.option("showScrollbar"),
      bounceEnabled: this.option("bounceEnabled"),
      inertiaEnabled: this.option("inertiaEnabled"),
      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)
    };
  },
  _applyScaleRatio(targetLocation) {
    for (const direction in this._scrollers) {
      const prop = this._getPropByDirection(direction);
      if (isDefined(targetLocation[prop])) {
        const scroller = this._scrollers[direction];
        targetLocation[prop] *= scroller._getScaleRatio();
      }
    }
    return targetLocation;
  },
  _isAnyThumbScrolling($target) {
    let result2 = false;
    this._eventHandler("isThumbScrolling", $target).done((isThumbScrollingVertical, isThumbScrollingHorizontal) => {
      result2 = isThumbScrollingVertical || isThumbScrollingHorizontal;
    });
    return result2;
  },
  handleInit(e) {
    this._suppressDirections(e);
    this._eventForUserAction = e;
    this._eventHandler("init", e);
  },
  _suppressDirections(e) {
    if (isDxMouseWheelEvent(e.originalEvent)) {
      this._prepareDirections(true);
      return;
    }
    this._prepareDirections();
    this._eachScroller(function(scroller, direction) {
      const $target = renderer_default(e.originalEvent.target);
      const isValid = scroller._validateEvent(e) || this.option("scrollByContent") && this._isContent($target);
      this._validDirections[direction] = isValid;
    });
  },
  _isContent($element) {
    return !!$element.closest(this._$element).length;
  },
  _prepareDirections(value2) {
    value2 = value2 || false;
    this._validDirections = {};
    this._validDirections[HORIZONTAL3] = value2;
    this._validDirections[VERTICAL2] = value2;
  },
  _eachScroller(callback) {
    callback = callback.bind(this);
    each(this._scrollers, (direction, scroller) => {
      callback(scroller, direction);
    });
  },
  handleStart(e) {
    this._eventForUserAction = e;
    this._eventHandler("start").done(this._startAction);
  },
  _saveActive() {
    activeScrollable = this;
  },
  _resetActive() {
    if (activeScrollable === this) {
      activeScrollable = null;
    }
  },
  handleMove(e) {
    if (this._isLocked()) {
      e.cancel = true;
      this._resetActive();
      return;
    }
    this._saveActive();
    e.preventDefault && e.preventDefault();
    this._adjustDistance(e, e.delta);
    this._eventForUserAction = e;
    this._eventHandler("move", e.delta);
  },
  _adjustDistance(e, distance) {
    distance.x *= this._validDirections[HORIZONTAL3];
    distance.y *= this._validDirections[VERTICAL2];
    const devicePixelRatio = this._tryGetDevicePixelRatio();
    if (devicePixelRatio && isDxMouseWheelEvent(e.originalEvent)) {
      distance.x = Math.round(distance.x / devicePixelRatio * 100) / 100;
      distance.y = Math.round(distance.y / devicePixelRatio * 100) / 100;
    }
  },
  _tryGetDevicePixelRatio() {
    if (hasWindow()) {
      return getWindow().devicePixelRatio;
    }
  },
  handleEnd(e) {
    this._resetActive();
    this._refreshCursorState(e.originalEvent && e.originalEvent.target);
    this._adjustDistance(e, e.velocity);
    this._eventForUserAction = e;
    return this._eventHandler("end", e.velocity).done(this._endAction);
  },
  handleCancel(e) {
    this._resetActive();
    this._eventForUserAction = e;
    return this._eventHandler("end", {
      x: 0,
      y: 0
    });
  },
  handleStop() {
    this._resetActive();
    this._eventHandler("stop");
  },
  handleScroll() {
    this._updateRtlConfig();
    this._scrollAction();
  },
  _attachKeyboardHandler() {
    events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_KEYBOARD}`);
    if (!this.option("disabled") && this.option("useKeyboard")) {
      events_engine_default.on(this._$element, addNamespace2("keydown", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));
    }
  },
  _keyDownHandler(e) {
    clearTimeout(this._updateHandlerTimeout);
    this._updateHandlerTimeout = setTimeout(() => {
      if (normalizeKeyName(e) === KEY_CODES.TAB) {
        this._eachScroller((scroller) => {
          scroller._updateHandler();
        });
      }
    });
    if (!this._$container.is(dom_adapter_default.getActiveElement(this._$container.get(0)))) {
      return;
    }
    let handled = true;
    switch (normalizeKeyName(e)) {
      case KEY_CODES.DOWN:
        this._scrollByLine({
          y: 1
        });
        break;
      case KEY_CODES.UP:
        this._scrollByLine({
          y: -1
        });
        break;
      case KEY_CODES.RIGHT:
        this._scrollByLine({
          x: 1
        });
        break;
      case KEY_CODES.LEFT:
        this._scrollByLine({
          x: -1
        });
        break;
      case KEY_CODES.PAGE_DOWN:
        this._scrollByPage(1);
        break;
      case KEY_CODES.PAGE_UP:
        this._scrollByPage(-1);
        break;
      case KEY_CODES.HOME:
        this._scrollToHome();
        break;
      case KEY_CODES.END:
        this._scrollToEnd();
        break;
      default:
        handled = false;
    }
    if (handled) {
      e.stopPropagation();
      e.preventDefault();
    }
  },
  _scrollByLine(lines) {
    const devicePixelRatio = this._tryGetDevicePixelRatio();
    let scrollOffset = 40;
    if (devicePixelRatio) {
      scrollOffset = Math.abs(scrollOffset / devicePixelRatio * 100) / 100;
    }
    this.scrollBy({
      top: (lines.y || 0) * -scrollOffset,
      left: (lines.x || 0) * -scrollOffset
    });
  },
  _scrollByPage(page) {
    const prop = this._wheelProp();
    const dimension = this._dimensionByProp(prop);
    const distance = {};
    const getter = "width" === dimension ? getWidth : getHeight;
    distance[prop] = page * -getter(this._$container);
    this.scrollBy(distance);
  },
  _dimensionByProp: (prop) => "left" === prop ? "width" : "height",
  _getPropByDirection: (direction) => direction === HORIZONTAL3 ? "left" : "top",
  _scrollToHome() {
    const prop = this._wheelProp();
    const distance = {};
    distance[prop] = 0;
    this._component.scrollTo(distance);
  },
  _scrollToEnd() {
    const prop = this._wheelProp();
    const dimension = this._dimensionByProp(prop);
    const distance = {};
    const getter = "width" === dimension ? getWidth : getHeight;
    distance[prop] = getter(this._$content) - getter(this._$container);
    this._component.scrollTo(distance);
  },
  createActions() {
    this._startAction = this._createActionHandler("onStart");
    this._endAction = this._createActionHandler("onEnd");
    this._updateAction = this._createActionHandler("onUpdated");
    this._createScrollerActions();
  },
  _createScrollerActions() {
    this._scrollAction = this._createActionHandler("onScroll");
    this._bounceAction = this._createActionHandler("onBounce");
    this._eventHandler("createActions", {
      scroll: this._scrollAction,
      bounce: this._bounceAction
    });
  },
  _createActionHandler(optionName) {
    const actionHandler = this._createActionByOption(optionName);
    return () => {
      actionHandler(extend(this._createActionArgs(), arguments));
    };
  },
  _createActionArgs() {
    const {
      horizontal: scrollerX,
      vertical: scrollerY
    } = this._scrollers;
    const offset2 = this._getScrollOffset();
    this._scrollOffset = {
      top: scrollerY && offset2.top,
      left: scrollerX && offset2.left
    };
    return {
      event: this._eventForUserAction,
      scrollOffset: this._scrollOffset,
      reachedLeft: scrollerX && scrollerX._reachedMax(),
      reachedRight: scrollerX && scrollerX._reachedMin(),
      reachedTop: scrollerY && scrollerY._reachedMax(),
      reachedBottom: scrollerY && scrollerY._reachedMin()
    };
  },
  _getScrollOffset() {
    return {
      top: -this.location().top,
      left: -this.location().left
    };
  },
  _eventHandler(eventName) {
    const args = [].slice.call(arguments).slice(1);
    const deferreds = map(this._scrollers, (scroller) => scroller[`_${eventName}Handler`].apply(scroller, args));
    return when.apply(renderer_default, deferreds).promise();
  },
  location() {
    const location = locate(this._$content);
    location.top -= this._$container.scrollTop();
    location.left -= this._$container.scrollLeft();
    return location;
  },
  disabledChanged() {
    this._attachCursorHandlers();
  },
  _attachCursorHandlers() {
    events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_CURSOR}`);
    if (!this.option("disabled") && this._isHoverMode()) {
      events_engine_default.on(this._$element, addNamespace2("mouseenter", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));
      events_engine_default.on(this._$element, addNamespace2("mouseleave", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));
    }
  },
  _isHoverMode() {
    return "onHover" === this.option("showScrollbar");
  },
  _cursorEnterHandler(e) {
    e = e || {};
    e.originalEvent = e.originalEvent || {};
    if (activeScrollable || e.originalEvent._hoverHandled) {
      return;
    }
    if (hoveredScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    hoveredScrollable = this;
    this._eventHandler("cursorEnter");
    e.originalEvent._hoverHandled = true;
  },
  _cursorLeaveHandler(e) {
    if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {
      return;
    }
    this._eventHandler("cursorLeave");
    hoveredScrollable = null;
    this._refreshCursorState(e && e.relatedTarget);
  },
  _refreshCursorState(target) {
    if (!this._isHoverMode() && (!target || activeScrollable)) {
      return;
    }
    const $target = renderer_default(target);
    const $scrollable = $target.closest(".dx-scrollable-simulated:not(.dx-state-disabled)");
    const targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
    if (hoveredScrollable && hoveredScrollable !== targetScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    if (targetScrollable) {
      targetScrollable._cursorEnterHandler();
    }
  },
  update() {
    const result2 = this._eventHandler("update").done(this._updateAction);
    return when(result2, deferUpdate(() => {
      const allowedDirections = this._allowedDirections();
      deferRender(() => {
        let touchDirection = allowedDirections.vertical ? "pan-x" : "";
        touchDirection = allowedDirections.horizontal ? "pan-y" : touchDirection;
        touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? "none" : touchDirection;
        this._$container.css("touchAction", touchDirection);
      });
      return when().promise();
    }));
  },
  _allowedDirections() {
    const bounceEnabled = this.option("bounceEnabled");
    const verticalScroller = this._scrollers[VERTICAL2];
    const horizontalScroller = this._scrollers[HORIZONTAL3];
    return {
      vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
      horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
    };
  },
  _updateBounds() {
    this._scrollers[HORIZONTAL3] && this._scrollers[HORIZONTAL3]._updateBounds();
  },
  _isHorizontalAndRtlEnabled() {
    return this.option("rtlEnabled") && this.option("direction") !== VERTICAL2;
  },
  updateRtlPosition(needInitializeRtlConfig) {
    if (needInitializeRtlConfig) {
      this._rtlConfig = {
        scrollRight: 0,
        clientWidth: this._$container.get(0).clientWidth,
        windowPixelRatio: this._getWindowDevicePixelRatio()
      };
    }
    this._updateBounds();
    if (this._isHorizontalAndRtlEnabled()) {
      let scrollLeft = this._getMaxOffset().left - this._rtlConfig.scrollRight;
      if (scrollLeft <= 0) {
        scrollLeft = 0;
        this._rtlConfig.scrollRight = this._getMaxOffset().left;
      }
      if (this._getScrollOffset().left !== scrollLeft) {
        this._rtlConfig.skipUpdating = true;
        this._component.scrollTo({
          left: scrollLeft
        });
        this._rtlConfig.skipUpdating = false;
      }
    }
  },
  _updateRtlConfig() {
    if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {
      const {
        clientWidth,
        scrollLeft
      } = this._$container.get(0);
      const windowPixelRatio = this._getWindowDevicePixelRatio();
      if (this._rtlConfig.windowPixelRatio === windowPixelRatio && this._rtlConfig.clientWidth === clientWidth) {
        this._rtlConfig.scrollRight = this._getMaxOffset().left - scrollLeft;
      }
      this._rtlConfig.clientWidth = clientWidth;
      this._rtlConfig.windowPixelRatio = windowPixelRatio;
    }
  },
  _getWindowDevicePixelRatio: () => hasWindow() ? getWindow().devicePixelRatio : 1,
  scrollBy(distance) {
    const verticalScroller = this._scrollers[VERTICAL2];
    const horizontalScroller = this._scrollers[HORIZONTAL3];
    if (verticalScroller) {
      distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;
    }
    if (horizontalScroller) {
      distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;
    }
    this._prepareDirections(true);
    this._startAction();
    this._eventHandler("scrollBy", {
      x: distance.left,
      y: distance.top
    });
    this._endAction();
    this._updateRtlConfig();
  },
  validate(e) {
    if (isDxMouseWheelEvent(e) && isCommandKeyPressed(e)) {
      return false;
    }
    if (this.option("disabled")) {
      return false;
    }
    if (this.option("bounceEnabled")) {
      return true;
    }
    return isDxMouseWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e);
  },
  _validateWheel(e) {
    const scroller = this._scrollers[this._wheelDirection(e)];
    const reachedMin = scroller._reachedMin();
    const reachedMax = scroller._reachedMax();
    const contentGreaterThanContainer = !reachedMin || !reachedMax;
    const locatedNotAtBound = !reachedMin && !reachedMax;
    const scrollFromMin = reachedMin && e.delta > 0;
    const scrollFromMax = reachedMax && e.delta < 0;
    let validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);
    validated = validated || void 0 !== this._validateWheelTimer;
    if (validated) {
      clearTimeout(this._validateWheelTimer);
      this._validateWheelTimer = setTimeout(() => {
        this._validateWheelTimer = void 0;
      }, 500);
    }
    return validated;
  },
  _validateMove(e) {
    if (!this.option("scrollByContent") && !renderer_default(e.target).closest(".dx-scrollable-scrollbar").length) {
      return false;
    }
    return this._allowedDirection();
  },
  getDirection(e) {
    return isDxMouseWheelEvent(e) ? this._wheelDirection(e) : this._allowedDirection();
  },
  _wheelProp() {
    return this._wheelDirection() === HORIZONTAL3 ? "left" : "top";
  },
  _wheelDirection(e) {
    switch (this.option("direction")) {
      case HORIZONTAL3:
        return HORIZONTAL3;
      case VERTICAL2:
        return VERTICAL2;
      default:
        return e && e.shiftKey ? HORIZONTAL3 : VERTICAL2;
    }
  },
  dispose() {
    this._resetActive();
    if (hoveredScrollable === this) {
      hoveredScrollable = null;
    }
    this._eventHandler("dispose");
    this._detachEventHandlers();
    this._$element.removeClass("dx-scrollable-simulated");
    this._eventForUserAction = null;
    clearTimeout(this._validateWheelTimer);
    clearTimeout(this._updateHandlerTimeout);
  },
  _detachEventHandlers() {
    events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_CURSOR}`);
    events_engine_default.off(this._$container, `.${SCROLLABLE_SIMULATED_KEYBOARD}`);
  }
});

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.simulated.js
var math2 = Math;
var ScrollViewScroller = Scroller.inherit({
  ctor() {
    this._topPocketSize = 0;
    this._bottomPocketSize = 0;
    this.callBase.apply(this, arguments);
    this._initCallbacks();
    this._releaseState();
  },
  _releaseState() {
    this._state = 0;
    this._refreshPullDownText();
  },
  _refreshPullDownText() {
    const that = this;
    const pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: 0
    }, {
      element: this._$pulledDownText,
      visibleState: 1
    }, {
      element: this._$refreshingText,
      visibleState: 2
    }];
    each(pullDownTextItems, (_, item) => {
      const action = that._state === item.visibleState ? "addClass" : "removeClass";
      item.element[action]("dx-scrollview-pull-down-text-visible");
    });
  },
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  },
  _updateBounds() {
    const considerPockets = "horizontal" !== this._direction;
    if (considerPockets) {
      this._topPocketSize = this._$topPocket.get(0).clientHeight;
      this._bottomPocketSize = this._$bottomPocket.get(0).clientHeight;
      const containerEl = this._$container.get(0);
      const contentEl = this._$content.get(0);
      this._bottomBoundary = Math.max(contentEl.clientHeight - this._bottomPocketSize - containerEl.clientHeight, 0);
    }
    this.callBase();
  },
  _updateScrollbar() {
    this._scrollbar.option({
      containerSize: this._containerSize(),
      contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize,
      scaleRatio: this._getScaleRatio()
    });
  },
  _moveContent() {
    this.callBase();
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (this._isReachBottom()) {
      this._reachBottomReady();
    } else if (0 !== this._state) {
      this._stateReleased();
    }
  },
  _moveScrollbar() {
    this._scrollbar.moveTo(this._topPocketSize + this._location);
  },
  _isPullDown() {
    return this._pullDownEnabled && this._location >= 0;
  },
  _isReachBottom() {
    const containerEl = this._$container.get(0);
    return this._reachBottomEnabled && Math.round(this._bottomBoundary - Math.ceil(containerEl.scrollTop)) <= 1;
  },
  _scrollComplete() {
    if (this._inBounds() && 1 === this._state) {
      this._pullDownRefreshing();
    } else if (this._inBounds() && 3 === this._state) {
      this._reachBottomLoading();
    } else {
      this.callBase();
    }
  },
  _reachBottomReady() {
    if (3 === this._state) {
      return;
    }
    this._state = 3;
    this._minOffset = this._getMinOffset();
  },
  _getMaxOffset() {
    return -this._topPocketSize;
  },
  _getMinOffset() {
    return math2.min(this.callBase(), -this._topPocketSize);
  },
  _reachBottomLoading() {
    this.reachBottomCallbacks.fire();
  },
  _pullDownReady() {
    if (1 === this._state) {
      return;
    }
    this._state = 1;
    this._maxOffset = 0;
    this._$pullDown.addClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
  },
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._releaseState();
    this._updateBounds();
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this.releaseCallbacks.fire();
  },
  _pullDownRefreshing() {
    if (2 === this._state) {
      return;
    }
    this._state = 2;
    this._$pullDown.addClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  },
  _releaseHandler() {
    if (0 === this._state) {
      this._moveToBounds();
    }
    this._update();
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this._releaseTask = executeAsync(this._release.bind(this));
    return this._releaseTask.promise;
  },
  _release() {
    this._stateReleased();
    this._scrollComplete();
  },
  _reachBottomEnablingHandler(enabled) {
    if (this._reachBottomEnabled === enabled) {
      return;
    }
    this._reachBottomEnabled = enabled;
    this._updateBounds();
  },
  _pullDownEnablingHandler(enabled) {
    if (this._pullDownEnabled === enabled) {
      return;
    }
    this._pullDownEnabled = enabled;
    this._considerTopPocketChange();
    this._updateHandler();
  },
  _considerTopPocketChange() {
    this._location -= getHeight(this._$topPocket) || -this._topPocketSize;
    this._maxOffset = 0;
    this._move();
  },
  _pendingReleaseHandler() {
    this._state = 1;
  },
  dispose() {
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this.callBase();
  }
});
var SimulatedScrollViewStrategy = SimulatedStrategy.inherit({
  _init(scrollView) {
    this.callBase(scrollView);
    this._$pullDown = scrollView._$pullDown;
    this._$topPocket = scrollView._$topPocket;
    this._$bottomPocket = scrollView._$bottomPocket;
    this._initCallbacks();
  },
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  },
  render() {
    this._renderPullDown();
    this.callBase();
  },
  _renderPullDown() {
    const $image = renderer_default("<div>").addClass("dx-scrollview-pull-down-image");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    const $text = this._$pullDownText = renderer_default("<div>").addClass("dx-scrollview-pull-down-text");
    this._$pullingDownText = renderer_default("<div>").text(this.option("pullingDownText")).appendTo($text);
    this._$pulledDownText = renderer_default("<div>").text(this.option("pulledDownText")).appendTo($text);
    this._$refreshingText = renderer_default("<div>").text(this.option("refreshingText")).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  },
  pullDownEnable(enabled) {
    this._eventHandler("pullDownEnabling", enabled);
  },
  reachBottomEnable(enabled) {
    this._eventHandler("reachBottomEnabling", enabled);
  },
  _createScroller(direction) {
    const that = this;
    const scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
    scroller.pullDownCallbacks.add(() => {
      that.pullDownCallbacks.fire();
    });
    scroller.releaseCallbacks.add(() => {
      that.releaseCallbacks.fire();
    });
    scroller.reachBottomCallbacks.add(() => {
      that.reachBottomCallbacks.fire();
    });
  },
  _scrollerOptions(direction) {
    return extend(this.callBase(direction), {
      $topPocket: this._$topPocket,
      $bottomPocket: this._$bottomPocket,
      $pullDown: this._$pullDown,
      $pullDownText: this._$pullDownText,
      $pullingDownText: this._$pullingDownText,
      $pulledDownText: this._$pulledDownText,
      $refreshingText: this._$refreshingText
    });
  },
  pendingRelease() {
    this._eventHandler("pendingRelease");
  },
  release() {
    return this._eventHandler("release").done(this._updateAction);
  },
  location() {
    const location = this.callBase();
    location.top += getHeight(this._$topPocket);
    return location;
  },
  dispose() {
    each(this._scrollers, function() {
      this.dispose();
    });
    this.callBase();
  }
});
var m_scroll_view_simulated_default = SimulatedScrollViewStrategy;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_relative_offset.js
function getRelativeOffset(targetElementClass, sourceElement) {
  const offset2 = {
    left: 0,
    top: 0
  };
  let element = sourceElement;
  while (null !== (_element = element) && void 0 !== _element && _element.offsetParent && !element.classList.contains(targetElementClass)) {
    var _element;
    const parentElement = element.offsetParent;
    const elementRect = element.getBoundingClientRect();
    const parentElementRect = parentElement.getBoundingClientRect();
    offset2.left += elementRect.left - parentElementRect.left;
    offset2.top += elementRect.top - parentElementRect.top;
    element = element.offsetParent;
  }
  return offset2;
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/common/consts.js
var DIRECTION_VERTICAL = "vertical";
var DIRECTION_HORIZONTAL = "horizontal";
var DIRECTION_BOTH = "both";
var SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content";

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_element_location_internal.js
function getElementLocationInternal(targetElement, direction, containerElement, scrollOffset, offset2) {
  const additionalOffset = _extends({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }, offset2);
  const isVertical = direction === DIRECTION_VERTICAL;
  const prop = isVertical ? "top" : "left";
  const inverseProp = isVertical ? "bottom" : "right";
  const dimension = isVertical ? "height" : "width";
  const containerOffsetSize = containerElement[`offset${titleize(dimension)}`];
  const containerClientSize = containerElement[`client${titleize(dimension)}`];
  const containerSize = containerElement.getBoundingClientRect()[dimension];
  const elementSize2 = targetElement.getBoundingClientRect()[dimension];
  let scale = 1;
  if (Math.abs(containerSize - containerOffsetSize) > 1) {
    scale = containerSize / containerOffsetSize;
  }
  const relativeElementOffset = getRelativeOffset(SCROLLABLE_CONTENT_CLASS, targetElement)[prop] / scale;
  const containerScrollOffset = scrollOffset[prop];
  const relativeStartOffset = containerScrollOffset - relativeElementOffset + additionalOffset[prop];
  const relativeEndOffset = containerScrollOffset - relativeElementOffset - elementSize2 / scale + containerClientSize - additionalOffset[inverseProp];
  if (relativeStartOffset <= 0 && relativeEndOffset >= 0) {
    return containerScrollOffset;
  }
  return containerScrollOffset - (Math.abs(relativeStartOffset) > Math.abs(relativeEndOffset) ? relativeEndOffset : relativeStartOffset);
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.device.js
var deviceDependentOptions = function() {
  return [{
    device: () => !nativeScrolling,
    options: {
      useNative: false
    }
  }, {
    device: (device) => !devices_default.isSimulator() && "desktop" === devices_default.real().deviceType && "generic" === device.platform,
    options: {
      bounceEnabled: false,
      scrollByThumb: true,
      scrollByContent: touch,
      showScrollbar: "onHover"
    }
  }];
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.js
var SCROLLABLE = "dxScrollable";
var SCROLLABLE_STRATEGY2 = "dxScrollableStrategy";
var VERTICAL3 = "vertical";
var HORIZONTAL4 = "horizontal";
var BOTH = "both";
var Scrollable = dom_component_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      disabled: false,
      onScroll: null,
      direction: VERTICAL3,
      showScrollbar: "onScroll",
      useNative: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      onUpdated: null,
      onStart: null,
      onEnd: null,
      onBounce: null,
      useSimulatedScrollbar: false,
      useKeyboard: true,
      inertiaEnabled: true,
      updateManually: false,
      _onVisibilityChanged: noop2
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat(deviceDependentOptions(), [{
      device: () => nativeScrolling && "android" === devices_default.real().platform && !browser_default.mozilla,
      options: {
        useSimulatedScrollbar: true
      }
    }]);
  },
  _initOptions(options2) {
    this.callBase(options2);
    if (!("useSimulatedScrollbar" in options2)) {
      this._setUseSimulatedScrollbar();
    }
  },
  _setUseSimulatedScrollbar() {
    if (!this.initialOption("useSimulatedScrollbar")) {
      this.option("useSimulatedScrollbar", !this.option("useNative"));
    }
  },
  _init() {
    this.callBase();
    this._initScrollableMarkup();
    this._locked = false;
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this.update();
      this._updateRtlPosition();
      this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
      delete this._savedScrollOffset;
      this.option("_onVisibilityChanged")(this);
    } else {
      this._savedScrollOffset = this.scrollOffset();
    }
  },
  _initScrollableMarkup() {
    const $element = this.$element().addClass("dx-scrollable");
    const $container = this._$container = renderer_default("<div>").addClass("dx-scrollable-container");
    const $wrapper = this._$wrapper = renderer_default("<div>").addClass("dx-scrollable-wrapper");
    const $content = this._$content = renderer_default("<div>").addClass("dx-scrollable-content");
    $content.append($element.contents()).appendTo($container);
    $container.appendTo($wrapper);
    $wrapper.appendTo($element);
  },
  _dimensionChanged() {
    this.update();
    this._updateRtlPosition();
  },
  _initMarkup() {
    this.callBase();
    this._renderDirection();
  },
  _render() {
    this._renderStrategy();
    this._attachEventHandlers();
    this._renderDisabledState();
    this._createActions();
    this.update();
    this.callBase();
    this._updateRtlPosition(true);
  },
  _updateRtlPosition(needInitializeRtlConfig) {
    this._strategy.updateRtlPosition(needInitializeRtlConfig);
  },
  _getMaxOffset() {
    const {
      scrollWidth,
      clientWidth,
      scrollHeight,
      clientHeight
    } = renderer_default(this.container()).get(0);
    return {
      left: scrollWidth - clientWidth,
      top: scrollHeight - clientHeight
    };
  },
  _attachEventHandlers() {
    const strategy4 = this._strategy;
    const initEventData = {
      getDirection: strategy4.getDirection.bind(strategy4),
      validate: this._validate.bind(this),
      isNative: this.option("useNative"),
      scrollTarget: this._$container
    };
    events_engine_default.off(this._$wrapper, `.${SCROLLABLE}`);
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.init, SCROLLABLE), initEventData, this._initHandler.bind(this));
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.start, SCROLLABLE), strategy4.handleStart.bind(strategy4));
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.move, SCROLLABLE), strategy4.handleMove.bind(strategy4));
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.end, SCROLLABLE), strategy4.handleEnd.bind(strategy4));
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.cancel, SCROLLABLE), strategy4.handleCancel.bind(strategy4));
    events_engine_default.on(this._$wrapper, addNamespace2(emitter_gesture_scroll_default.stop, SCROLLABLE), strategy4.handleStop.bind(strategy4));
    events_engine_default.off(this._$container, `.${SCROLLABLE}`);
    events_engine_default.on(this._$container, addNamespace2("scroll", SCROLLABLE), strategy4.handleScroll.bind(strategy4));
  },
  _validate(e) {
    if (this._isLocked()) {
      return false;
    }
    this._updateIfNeed();
    return this._moveIsAllowed(e);
  },
  _moveIsAllowed(e) {
    return this._strategy.validate(e);
  },
  handleMove(e) {
    this._strategy.handleMove(e);
  },
  _prepareDirections(value2) {
    this._strategy._prepareDirections(value2);
  },
  _initHandler() {
    const strategy4 = this._strategy;
    strategy4.handleInit.apply(strategy4, arguments);
  },
  _renderDisabledState() {
    this.$element().toggleClass("dx-scrollable-disabled", this.option("disabled"));
    if (this.option("disabled")) {
      this._lock();
    } else {
      this._unlock();
    }
  },
  _renderDirection() {
    this.$element().removeClass(`dx-scrollable-${HORIZONTAL4}`).removeClass(`dx-scrollable-${VERTICAL3}`).removeClass(`dx-scrollable-${BOTH}`).addClass(`dx-scrollable-${this.option("direction")}`);
  },
  _renderStrategy() {
    this._createStrategy();
    this._strategy.render();
    this.$element().data(SCROLLABLE_STRATEGY2, this._strategy);
  },
  _createStrategy() {
    this._strategy = this.option("useNative") ? new m_scrollable_native_default(this) : new SimulatedStrategy(this);
  },
  _createActions() {
    this._strategy && this._strategy.createActions();
  },
  _clean() {
    this._strategy && this._strategy.dispose();
  },
  _optionChanged(args) {
    switch (args.name) {
      case "onStart":
      case "onEnd":
      case "onUpdated":
      case "onScroll":
      case "onBounce":
        this._createActions();
        break;
      case "direction":
        this._resetInactiveDirection();
        this._invalidate();
        break;
      case "useNative":
        this._setUseSimulatedScrollbar();
        this._invalidate();
        break;
      case "inertiaEnabled":
      case "scrollByThumb":
      case "bounceEnabled":
      case "useKeyboard":
      case "showScrollbar":
      case "useSimulatedScrollbar":
        this._invalidate();
        break;
      case "disabled":
        this._renderDisabledState();
        this._strategy && this._strategy.disabledChanged();
        break;
      case "updateManually":
      case "scrollByContent":
      case "_onVisibilityChanged":
        break;
      case "width":
        this.callBase(args);
        this._updateRtlPosition();
        break;
      default:
        this.callBase(args);
    }
  },
  _resetInactiveDirection() {
    const inactiveProp = this._getInactiveProp();
    if (!inactiveProp || !hasWindow()) {
      return;
    }
    const scrollOffset = this.scrollOffset();
    scrollOffset[inactiveProp] = 0;
    this.scrollTo(scrollOffset);
  },
  _getInactiveProp() {
    const direction = this.option("direction");
    if (direction === VERTICAL3) {
      return "left";
    }
    if (direction === HORIZONTAL4) {
      return "top";
    }
  },
  _location() {
    return this._strategy.location();
  },
  _normalizeLocation(location) {
    if (isPlainObject(location)) {
      const left = ensureDefined(location.left, location.x);
      const top = ensureDefined(location.top, location.y);
      return {
        left: isDefined(left) ? -left : void 0,
        top: isDefined(top) ? -top : void 0
      };
    }
    const direction = this.option("direction");
    return {
      left: direction !== VERTICAL3 ? -location : void 0,
      top: direction !== HORIZONTAL4 ? -location : void 0
    };
  },
  _isLocked() {
    return this._locked;
  },
  _lock() {
    this._locked = true;
  },
  _unlock() {
    if (!this.option("disabled")) {
      this._locked = false;
    }
  },
  _isDirection(direction) {
    const current2 = this.option("direction");
    if (direction === VERTICAL3) {
      return current2 !== HORIZONTAL4;
    }
    if (direction === HORIZONTAL4) {
      return current2 !== VERTICAL3;
    }
    return current2 === direction;
  },
  _updateAllowedDirection() {
    const allowedDirections = this._strategy._allowedDirections();
    if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {
      this._allowedDirectionValue = BOTH;
    } else if (this._isDirection(HORIZONTAL4) && allowedDirections.horizontal) {
      this._allowedDirectionValue = HORIZONTAL4;
    } else if (this._isDirection(VERTICAL3) && allowedDirections.vertical) {
      this._allowedDirectionValue = VERTICAL3;
    } else {
      this._allowedDirectionValue = null;
    }
  },
  _allowedDirection() {
    return this._allowedDirectionValue;
  },
  $content() {
    return this._$content;
  },
  content() {
    return getPublicElement(this._$content);
  },
  container() {
    return getPublicElement(this._$container);
  },
  scrollOffset() {
    return this._strategy._getScrollOffset();
  },
  _isRtlNativeStrategy() {
    const {
      useNative,
      rtlEnabled
    } = this.option();
    return useNative && rtlEnabled;
  },
  scrollTop() {
    return this.scrollOffset().top;
  },
  scrollLeft() {
    return this.scrollOffset().left;
  },
  clientHeight() {
    return getHeight(this._$container);
  },
  scrollHeight() {
    return getOuterHeight(this.$content());
  },
  clientWidth() {
    return getWidth(this._$container);
  },
  scrollWidth() {
    return getOuterWidth(this.$content());
  },
  update() {
    if (!this._strategy) {
      return;
    }
    return when(this._strategy.update()).done(() => {
      this._updateAllowedDirection();
    });
  },
  scrollBy(distance) {
    distance = this._normalizeLocation(distance);
    if (!distance.top && !distance.left) {
      return;
    }
    this._updateIfNeed();
    this._strategy.scrollBy(distance);
  },
  scrollTo(targetLocation) {
    targetLocation = this._normalizeLocation(targetLocation);
    this._updateIfNeed();
    let location = this._location();
    if (!this.option("useNative")) {
      targetLocation = this._strategy._applyScaleRatio(targetLocation);
      location = this._strategy._applyScaleRatio(location);
    }
    if (this._isRtlNativeStrategy()) {
      location.left -= this._getMaxOffset().left;
    }
    const distance = this._normalizeLocation({
      left: location.left - ensureDefined(targetLocation.left, location.left),
      top: location.top - ensureDefined(targetLocation.top, location.top)
    });
    if (!distance.top && !distance.left) {
      return;
    }
    this._strategy.scrollBy(distance);
  },
  scrollToElement(element, offset2) {
    const $element = renderer_default(element);
    const elementInsideContent = this.$content().find(element).length;
    const elementIsInsideContent = $element.parents(".dx-scrollable").length - $element.parents(".dx-scrollable-content").length === 0;
    if (!elementInsideContent || !elementIsInsideContent) {
      return;
    }
    const scrollPosition = {
      top: 0,
      left: 0
    };
    const direction = this.option("direction");
    if (direction !== VERTICAL3) {
      scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL4, offset2);
    }
    if (direction !== HORIZONTAL4) {
      scrollPosition.top = this.getScrollElementPosition($element, VERTICAL3, offset2);
    }
    this.scrollTo(scrollPosition);
  },
  getScrollElementPosition($element, direction, offset2) {
    const scrollOffset = this.scrollOffset();
    return getElementLocationInternal($element.get(0), direction, renderer_default(this.container()).get(0), scrollOffset, offset2);
  },
  _updateIfNeed() {
    if (!this.option("updateManually")) {
      this.update();
    }
  },
  _useTemplates: () => false,
  isRenovated: () => !!Scrollable.IS_RENOVATED_WIDGET
});
component_registrator_default(SCROLLABLE, Scrollable);
var m_scrollable_default = Scrollable;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.js
var SCROLLVIEW_LOADPANEL = "dx-scrollview-loadpanel";
var refreshStrategies = {
  pullDown: m_scroll_view_native_pull_down_default,
  swipeDown: m_scroll_view_native_swipe_down_default,
  simulated: m_scroll_view_simulated_default
};
var isServerSide = !hasWindow();
var scrollViewServerConfig = {
  finishLoading: noop2,
  release: noop2,
  refresh: noop2,
  scrollOffset: () => ({
    top: 0,
    left: 0
  }),
  _optionChanged(args) {
    if ("onUpdated" !== args.name) {
      return this.callBase.apply(this, arguments);
    }
  }
};
var ScrollView = m_scrollable_default.inherit(isServerSide ? scrollViewServerConfig : {
  _getDefaultOptions() {
    return extend(this.callBase(), {
      pullingDownText: message_default.format("dxScrollView-pullingDownText"),
      pulledDownText: message_default.format("dxScrollView-pulledDownText"),
      refreshingText: message_default.format("dxScrollView-refreshingText"),
      reachBottomText: message_default.format("dxScrollView-reachBottomText"),
      onPullDown: null,
      onReachBottom: null,
      refreshStrategy: "pullDown"
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device() {
        const realDevice2 = devices_default.real();
        return "android" === realDevice2.platform;
      },
      options: {
        refreshStrategy: "swipeDown"
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        reachBottomText: ""
      }
    }]);
  },
  _init() {
    this.callBase();
    this._loadingIndicatorEnabled = true;
  },
  _initScrollableMarkup() {
    this.callBase();
    this.$element().addClass("dx-scrollview");
    this._initContent();
    this._initTopPocket();
    this._initBottomPocket();
    this._initLoadPanel();
  },
  _initContent() {
    const $content = renderer_default("<div>").addClass("dx-scrollview-content");
    this._$content.wrapInner($content);
  },
  _initTopPocket() {
    const $topPocket = this._$topPocket = renderer_default("<div>").addClass("dx-scrollview-top-pocket");
    const $pullDown = this._$pullDown = renderer_default("<div>").addClass("dx-scrollview-pull-down");
    $topPocket.append($pullDown);
    this._$content.prepend($topPocket);
  },
  _initBottomPocket() {
    const $bottomPocket = this._$bottomPocket = renderer_default("<div>").addClass("dx-scrollview-bottom-pocket");
    const $reachBottom = this._$reachBottom = renderer_default("<div>").addClass("dx-scrollview-scrollbottom");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-scrollbottom-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    const $text = this._$reachBottomText = renderer_default("<div>").addClass("dx-scrollview-scrollbottom-text");
    this._updateReachBottomText();
    $reachBottom.append($loadContainer.append($loadIndicator)).append($text);
    $bottomPocket.append($reachBottom);
    this._$content.append($bottomPocket);
  },
  _initLoadPanel() {
    const $loadPanelElement = renderer_default("<div>").addClass(SCROLLVIEW_LOADPANEL).appendTo(this.$element());
    const loadPanelOptions = {
      shading: false,
      delay: 400,
      message: this.option("refreshingText"),
      position: {
        of: this.$element()
      }
    };
    this._loadPanel = this._createComponent($loadPanelElement, load_panel_default, loadPanelOptions);
  },
  _updateReachBottomText() {
    this._$reachBottomText.text(this.option("reachBottomText"));
  },
  _createStrategy() {
    const strategyName = this.option("useNative") ? this.option("refreshStrategy") : "simulated";
    const strategyClass = refreshStrategies[strategyName];
    this._strategy = new strategyClass(this);
    this._strategy.pullDownCallbacks.add(this._pullDownHandler.bind(this));
    this._strategy.releaseCallbacks.add(this._releaseHandler.bind(this));
    this._strategy.reachBottomCallbacks.add(this._reachBottomHandler.bind(this));
  },
  _createActions() {
    this.callBase();
    this._pullDownAction = this._createActionByOption("onPullDown");
    this._reachBottomAction = this._createActionByOption("onReachBottom");
    this._tryRefreshPocketState();
  },
  _tryRefreshPocketState() {
    this._pullDownEnable(this.hasActionSubscription("onPullDown"));
    this._reachBottomEnable(this.hasActionSubscription("onReachBottom"));
  },
  on(eventName) {
    const result2 = this.callBase.apply(this, arguments);
    if ("pullDown" === eventName || "reachBottom" === eventName) {
      this._tryRefreshPocketState();
    }
    return result2;
  },
  _pullDownEnable(enabled) {
    if (0 === arguments.length) {
      return this._pullDownEnabled;
    }
    if (this._$pullDown && this._strategy) {
      this._$pullDown.toggle(enabled);
      this._strategy.pullDownEnable(enabled);
      this._pullDownEnabled = enabled;
    }
  },
  _reachBottomEnable(enabled) {
    if (0 === arguments.length) {
      return this._reachBottomEnabled;
    }
    if (this._$reachBottom && this._strategy) {
      this._$reachBottom.toggle(enabled);
      this._strategy.reachBottomEnable(enabled);
      this._reachBottomEnabled = enabled;
    }
  },
  _pullDownHandler() {
    this._loadingIndicator(false);
    this._pullDownLoading();
  },
  _loadingIndicator(value2) {
    if (arguments.length < 1) {
      return this._loadingIndicatorEnabled;
    }
    this._loadingIndicatorEnabled = value2;
  },
  _pullDownLoading() {
    this.startLoading();
    this._pullDownAction();
  },
  _reachBottomHandler() {
    this._loadingIndicator(false);
    this._reachBottomLoading();
  },
  _reachBottomLoading() {
    this.startLoading();
    this._reachBottomAction();
  },
  _releaseHandler() {
    this.finishLoading();
    this._loadingIndicator(true);
  },
  _optionChanged(args) {
    switch (args.name) {
      case "onPullDown":
      case "onReachBottom":
        this._createActions();
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "refreshStrategy":
        this._invalidate();
        break;
      case "reachBottomText":
        this._updateReachBottomText();
        break;
      default:
        this.callBase(args);
    }
  },
  content() {
    return getPublicElement(this._$content.children().eq(1));
  },
  release(preventReachBottom) {
    if (void 0 !== preventReachBottom) {
      this.toggleLoading(!preventReachBottom);
    }
    return this._strategy.release();
  },
  toggleLoading(showOrHide) {
    this._reachBottomEnable(showOrHide);
  },
  refresh() {
    if (!this.hasActionSubscription("onPullDown")) {
      return;
    }
    this._strategy.pendingRelease();
    this._pullDownLoading();
  },
  startLoading() {
    if (this._loadingIndicator() && this.$element().is(":visible")) {
      this._loadPanel.show();
    }
    this._lock();
  },
  finishLoading() {
    this._loadPanel.hide();
    this._unlock();
  },
  _dispose() {
    this._strategy.dispose();
    this.callBase();
    if (this._loadPanel) {
      this._loadPanel.$element().remove();
    }
  }
});
component_registrator_default("dxScrollView", ScrollView);
var m_scroll_view_default = ScrollView;

// ../../../../../../node_modules/devextreme/esm/ui/scroll_view.js
var scroll_view_default = m_scroll_view_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/shared/m_grouped_data_converter_mixin.js
var isCorrectStructure = (data2) => Array.isArray(data2) && data2.every((item) => {
  const hasTwoFields = 2 === Object.keys(item).length;
  const hasCorrectFields = "key" in item && "items" in item;
  return hasTwoFields && hasCorrectFields && Array.isArray(item.items);
});
var m_grouped_data_converter_mixin_default = {
  _getSpecificDataSourceOption() {
    let dataSource = this.option("dataSource");
    let hasSimpleItems = false;
    let data2 = {};
    if (this._getGroupedOption() && isCorrectStructure(dataSource)) {
      data2 = dataSource.reduce((accumulator, item) => {
        const items = item.items.map((innerItem) => {
          if (!isObject(innerItem)) {
            innerItem = {
              text: innerItem
            };
            hasSimpleItems = true;
          }
          if (!("key" in innerItem)) {
            innerItem.key = item.key;
          }
          return innerItem;
        });
        return accumulator.concat(items);
      }, []);
      dataSource = {
        store: {
          type: "array",
          data: data2
        },
        group: {
          selector: "key",
          keepInitialKeyOrder: true
        }
      };
      if (hasSimpleItems) {
        dataSource.searchExpr = "text";
      }
    }
    return dataSource;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_item.js
var ListItem = m_item_default.inherit({
  _renderWatchers() {
    this.callBase();
    this._startWatcher("badge", this._renderBadge.bind(this));
    this._startWatcher("showChevron", this._renderShowChevron.bind(this));
  },
  _renderBadge(badge) {
    this._$element.children(".dx-list-item-badge-container").remove();
    if (!badge) {
      return;
    }
    const $badge = renderer_default("<div>").addClass("dx-list-item-badge-container").append(renderer_default("<div>").addClass("dx-list-item-badge").addClass("dx-badge").text(badge));
    const $chevron = this._$element.children(".dx-list-item-chevron-container").first();
    $chevron.length > 0 ? $badge.insertBefore($chevron) : $badge.appendTo(this._$element);
  },
  _renderShowChevron(showChevron) {
    this._$element.children(".dx-list-item-chevron-container").remove();
    if (!showChevron) {
      return;
    }
    const $chevronContainer = renderer_default("<div>").addClass("dx-list-item-chevron-container");
    const $chevron = renderer_default("<div>").addClass("dx-list-item-chevron");
    $chevronContainer.append($chevron).appendTo(this._$element);
  }
});
var m_item_default2 = ListItem;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.base.js
var LIST_ITEM_SELECTOR = ".dx-list-item";
var SELECT_ALL_ITEM_SELECTOR = ".dx-list-select-all";
var groupItemsGetter = compileGetter("items");
var _scrollView;
var ListBase = ui_collection_widget_live_update_default.inherit({
  _activeStateUnit: [LIST_ITEM_SELECTOR, SELECT_ALL_ITEM_SELECTOR].join(","),
  _supportedKeys() {
    const that = this;
    const moveFocusPerPage = function(direction) {
      let $item = getEdgeVisibleItem(direction);
      const isFocusedItem = $item.is(that.option("focusedElement"));
      if (isFocusedItem) {
        !function($item2, direction2) {
          let resultPosition = $item2.position().top;
          if ("prev" === direction2) {
            resultPosition = $item2.position().top - getHeight(that.$element()) + getOuterHeight($item2);
          }
          that.scrollTo(resultPosition);
        }($item, direction);
        $item = getEdgeVisibleItem(direction);
      }
      that.option("focusedElement", getPublicElement($item));
      that.scrollToItem($item);
    };
    function getEdgeVisibleItem(direction) {
      const scrollTop = that.scrollTop();
      const containerHeight = getHeight(that.$element());
      let $item = renderer_default(that.option("focusedElement"));
      let isItemVisible = true;
      if (!$item.length) {
        return renderer_default();
      }
      while (isItemVisible) {
        const $nextItem = $item[direction]();
        if (!$nextItem.length) {
          break;
        }
        const nextItemLocation = $nextItem.position().top + getOuterHeight($nextItem) / 2;
        isItemVisible = nextItemLocation < containerHeight + scrollTop && nextItemLocation > scrollTop;
        if (isItemVisible) {
          $item = $nextItem;
        }
      }
      return $item;
    }
    return extend(this.callBase(), {
      leftArrow: noop2,
      rightArrow: noop2,
      pageUp() {
        moveFocusPerPage("prev");
        return false;
      },
      pageDown() {
        moveFocusPerPage("next");
        return false;
      }
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      pullRefreshEnabled: false,
      scrollingEnabled: true,
      selectByClick: true,
      showScrollbar: "onScroll",
      useNativeScrolling: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      pullingDownText: message_default.format("dxList-pullingDownText"),
      pulledDownText: message_default.format("dxList-pulledDownText"),
      refreshingText: message_default.format("dxList-refreshingText"),
      pageLoadingText: message_default.format("dxList-pageLoadingText"),
      onScroll: null,
      onPullRefresh: null,
      onPageLoading: null,
      pageLoadMode: "scrollBottom",
      nextButtonText: message_default.format("dxList-nextButtonText"),
      onItemSwipe: null,
      grouped: false,
      onGroupRendered: null,
      collapsibleGroups: false,
      groupTemplate: "group",
      indicateLoading: true,
      activeStateEnabled: true,
      _itemAttributes: {
        role: "option"
      },
      useInkRipple: false,
      wrapItemText: false,
      _swipeEnabled: true,
      showChevronExpr: (data2) => data2 ? data2.showChevron : void 0,
      badgeExpr: (data2) => data2 ? data2.badge : void 0
    });
  },
  _defaultOptionsRules() {
    const themeName = current();
    return this.callBase().concat(deviceDependentOptions(), [{
      device: () => !nativeScrolling,
      options: {
        useNativeScrolling: false
      }
    }, {
      device: (device) => !nativeScrolling && !devices_default.isSimulator() && "desktop" === devices_default.real().deviceType && "generic" === device.platform,
      options: {
        showScrollbar: "onHover",
        pageLoadMode: "nextButton"
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterial(themeName),
      options: {
        useInkRipple: true
      }
    }, {
      device: () => isMaterialBased(themeName),
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        pageLoadingText: ""
      }
    }]);
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._updateLoadingState(true);
    }
  },
  _itemClass: () => "dx-list-item",
  _itemDataKey: () => "dxListItemData",
  _itemContainer() {
    return this._$container;
  },
  _getItemsContainer() {
    return this._$listContainer;
  },
  _cleanItemContainer() {
    this.callBase();
    const listContainer = this._getItemsContainer();
    renderer_default(listContainer).empty();
    listContainer.appendTo(this._$container);
  },
  _saveSelectionChangeEvent(e) {
    this._selectionChangeEventInstance = e;
  },
  _getSelectionChangeEvent() {
    return this._selectionChangeEventInstance;
  },
  _refreshItemElements() {
    if (!this.option("grouped")) {
      this._itemElementsCache = this._getItemsContainer().children(this._itemSelector());
    } else {
      this._itemElementsCache = this._getItemsContainer().children(".dx-list-group").children(".dx-list-group-body").children(this._itemSelector());
    }
  },
  _modifyByChanges() {
    this.callBase.apply(this, arguments);
    this._refreshItemElements();
    this._updateLoadingState(true);
  },
  reorderItem(itemElement, toItemElement) {
    const promise = this.callBase(itemElement, toItemElement);
    return promise.done(function() {
      this._refreshItemElements();
    });
  },
  deleteItem(itemElement) {
    const promise = this.callBase(itemElement);
    return promise.done(function() {
      this._refreshItemElements();
    });
  },
  _itemElements() {
    return this._itemElementsCache;
  },
  _itemSelectHandler(e) {
    if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
      return;
    }
    return this.callBase(e);
  },
  _allowDynamicItemsAppend: () => true,
  _init() {
    this.callBase();
    this._dataController.resetDataSourcePageIndex();
    this._$container = this.$element();
    this._$listContainer = renderer_default("<div>").addClass("dx-list-items");
    this._initScrollView();
    this._feedbackShowTimeout = 70;
    this._createGroupRenderAction();
  },
  _scrollBottomMode() {
    return "scrollBottom" === this.option("pageLoadMode");
  },
  _nextButtonMode() {
    return "nextButton" === this.option("pageLoadMode");
  },
  _dataSourceOptions() {
    const scrollBottom = this._scrollBottomMode();
    const nextButton = this._nextButtonMode();
    return extend(this.callBase(), {
      paginate: ensureDefined(scrollBottom || nextButton, true)
    });
  },
  _getGroupedOption() {
    return this.option("grouped");
  },
  _getGroupContainerByIndex(groupIndex) {
    return this._getItemsContainer().find(".dx-list-group").eq(groupIndex).find(".dx-list-group-body");
  },
  _dataSourceFromUrlLoadMode: () => "raw",
  _initScrollView() {
    const scrollingEnabled = this.option("scrollingEnabled");
    const pullRefreshEnabled = scrollingEnabled && this.option("pullRefreshEnabled");
    const autoPagingEnabled = scrollingEnabled && this._scrollBottomMode() && !!this._dataController.getDataSource();
    this._scrollView = this._createComponent(this.$element(), getScrollView(), {
      height: this.option("height"),
      width: this.option("width"),
      disabled: this.option("disabled") || !scrollingEnabled,
      onScroll: this._scrollHandler.bind(this),
      onPullDown: pullRefreshEnabled ? this._pullDownHandler.bind(this) : null,
      onReachBottom: autoPagingEnabled ? this._scrollBottomHandler.bind(this) : null,
      showScrollbar: this.option("showScrollbar"),
      useNative: this.option("useNativeScrolling"),
      bounceEnabled: this.option("bounceEnabled"),
      scrollByContent: this.option("scrollByContent"),
      scrollByThumb: this.option("scrollByThumb"),
      pullingDownText: this.option("pullingDownText"),
      pulledDownText: this.option("pulledDownText"),
      refreshingText: this.option("refreshingText"),
      reachBottomText: this.option("pageLoadingText"),
      useKeyboard: false
    });
    this._$container = renderer_default(this._scrollView.content());
    this._$listContainer.appendTo(this._$container);
    this._toggleWrapItemText(this.option("wrapItemText"));
    this._createScrollViewActions();
  },
  _toggleWrapItemText(value2) {
    this._$listContainer.toggleClass("dx-wrap-item-text", value2);
  },
  _createScrollViewActions() {
    this._scrollAction = this._createActionByOption("onScroll");
    this._pullRefreshAction = this._createActionByOption("onPullRefresh");
    this._pageLoadingAction = this._createActionByOption("onPageLoading");
  },
  _scrollHandler(e) {
    this._scrollAction && this._scrollAction(e);
  },
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      group: new BindableTemplate(($container, data2) => {
        if (isPlainObject(data2)) {
          if (data2.key) {
            $container.text(data2.key);
          }
        } else {
          $container.text(String(data2));
        }
      }, ["key"], this.option("integrationOptions.watchMethod"))
    });
    this.callBase();
  },
  _prepareDefaultItemTemplate(data2, $container) {
    this.callBase(data2, $container);
    if (data2.icon) {
      const $icon = getImageContainer(data2.icon).addClass("dx-list-item-icon");
      const $iconContainer = renderer_default("<div>").addClass("dx-list-item-icon-container");
      $iconContainer.append($icon);
      $container.prepend($iconContainer);
    }
  },
  _getBindableFields: () => ["text", "html", "icon"],
  _updateLoadingState(tryLoadMore) {
    const dataController = this._dataController;
    const shouldLoadNextPage = this._scrollBottomMode() && tryLoadMore && !dataController.isLoading() && !this._isLastPage();
    if (this._shouldContinueLoading(shouldLoadNextPage)) {
      this._infiniteDataLoading();
    } else {
      this._scrollView.release(!shouldLoadNextPage && !dataController.isLoading());
      this._toggleNextButton(this._shouldRenderNextButton() && !this._isLastPage());
      this._loadIndicationSuppressed(false);
    }
  },
  _shouldRenderNextButton() {
    return this._nextButtonMode() && this._dataController.isLoaded();
  },
  _isDataSourceFirstLoadCompleted(newValue) {
    if (isDefined(newValue)) {
      this._isFirstLoadCompleted = newValue;
    }
    return this._isFirstLoadCompleted;
  },
  _dataSourceLoadingChangedHandler(isLoading) {
    if (this._loadIndicationSuppressed()) {
      return;
    }
    if (isLoading && this.option("indicateLoading")) {
      this._showLoadingIndicatorTimer = setTimeout(() => {
        const isEmpty2 = !this._itemElements().length;
        const shouldIndicateLoading = !isEmpty2 || this._isDataSourceFirstLoadCompleted();
        if (shouldIndicateLoading) {
          var _this$_scrollView;
          null === (_this$_scrollView = this._scrollView) || void 0 === _this$_scrollView || _this$_scrollView.startLoading();
        }
      });
    } else {
      clearTimeout(this._showLoadingIndicatorTimer);
      this._scrollView && this._scrollView.finishLoading();
    }
    if (!isLoading) {
      this._isDataSourceFirstLoadCompleted(false);
    }
  },
  _dataSourceChangedHandler() {
    if (!this._shouldAppendItems() && hasWindow()) {
      this._scrollView && this._scrollView.scrollTo(0);
    }
    this.callBase.apply(this, arguments);
    this._isDataSourceFirstLoadCompleted(true);
  },
  _refreshContent() {
    this._prepareContent();
    this._fireContentReadyAction();
  },
  _hideLoadingIfLoadIndicationOff() {
    if (!this.option("indicateLoading")) {
      this._dataSourceLoadingChangedHandler(false);
    }
  },
  _loadIndicationSuppressed(value2) {
    if (!arguments.length) {
      return this._isLoadIndicationSuppressed;
    }
    this._isLoadIndicationSuppressed = value2;
  },
  _scrollViewIsFull() {
    const scrollView = this._scrollView;
    return !scrollView || getHeight(scrollView.content()) > getHeight(scrollView.container());
  },
  _pullDownHandler(e) {
    this._pullRefreshAction(e);
    const dataController = this._dataController;
    if (dataController.getDataSource() && !dataController.isLoading()) {
      this._clearSelectedItems();
      dataController.pageIndex(0);
      dataController.reload();
    } else {
      this._updateLoadingState();
    }
  },
  _shouldContinueLoading(shouldLoadNextPage) {
    var _this$_scrollView$scr;
    const isBottomReached = getHeight(this._scrollView.content()) - getHeight(this._scrollView.container()) < ((null === (_this$_scrollView$scr = this._scrollView.scrollOffset()) || void 0 === _this$_scrollView$scr ? void 0 : _this$_scrollView$scr.top) ?? 0);
    return shouldLoadNextPage && (!this._scrollViewIsFull() || isBottomReached);
  },
  _infiniteDataLoading() {
    const isElementVisible = this.$element().is(":visible");
    if (isElementVisible) {
      clearTimeout(this._loadNextPageTimer);
      this._loadNextPageTimer = setTimeout(() => {
        this._loadNextPage();
      });
    }
  },
  _scrollBottomHandler(e) {
    this._pageLoadingAction(e);
    const dataController = this._dataController;
    if (!dataController.isLoading() && !this._isLastPage()) {
      this._loadNextPage();
    } else {
      this._updateLoadingState();
    }
  },
  _renderItems(items) {
    if (this.option("grouped")) {
      each(items, this._renderGroup.bind(this));
      this._attachGroupCollapseEvent();
      this._renderEmptyMessage();
      if (isMaterial()) {
        this.attachGroupHeaderInkRippleEvents();
      }
    } else {
      this.callBase.apply(this, arguments);
    }
    this._refreshItemElements();
    this._updateLoadingState(true);
  },
  _attachGroupCollapseEvent() {
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const $element = this.$element();
    const collapsibleGroups = this.option("collapsibleGroups");
    $element.toggleClass("dx-list-collapsible-groups", collapsibleGroups);
    events_engine_default.off($element, eventName, ".dx-list-group-header");
    if (collapsibleGroups) {
      events_engine_default.on($element, eventName, ".dx-list-group-header", (e) => {
        this._createAction((e2) => {
          const $group = renderer_default(e2.event.currentTarget).parent();
          this._collapseGroupHandler($group);
          if (this.option("focusStateEnabled")) {
            this.option("focusedElement", getPublicElement($group.find(".dx-list-item").eq(0)));
          }
        }, {
          validatingTargetName: "element"
        })({
          event: e
        });
      });
    }
  },
  _collapseGroupHandler($group, toggle) {
    const deferred = Deferred();
    if ($group.hasClass("dx-list-group-collapsed") === toggle) {
      return deferred.resolve();
    }
    const $groupBody = $group.children(".dx-list-group-body");
    const startHeight = getOuterHeight($groupBody);
    let endHeight = 0;
    if (0 === startHeight) {
      setHeight($groupBody, "auto");
      endHeight = getOuterHeight($groupBody);
    }
    $group.toggleClass("dx-list-group-collapsed", toggle);
    fx_default.animate($groupBody, {
      type: "custom",
      from: {
        height: startHeight
      },
      to: {
        height: endHeight
      },
      duration: 200,
      complete: (function() {
        this.updateDimensions();
        this._updateLoadingState(true);
        deferred.resolve();
      }).bind(this)
    });
    return deferred.promise();
  },
  _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading();
    if (this._initialized) {
      this._renderEmptyMessage();
      this._updateLoadingState();
    }
  },
  _initMarkup() {
    this._itemElementsCache = renderer_default();
    this.$element().addClass("dx-list");
    this.callBase();
    this.option("useInkRipple") && this._renderInkRipple();
    this.setAria({
      role: "group",
      roledescription: "list"
    }, this.$element());
    this.setAria({
      role: "application"
    }, this._focusTarget());
    this._setListAria();
  },
  _setListAria() {
    const {
      items,
      allowItemDeleting
    } = this.option();
    const label = allowItemDeleting ? message_default.format("dxList-listAriaLabel-deletable") : message_default.format("dxList-listAriaLabel");
    const listArea = null !== items && void 0 !== items && items.length ? {
      role: "listbox",
      label
    } : {
      role: void 0,
      label: void 0
    };
    this.setAria(listArea, this._$listContainer);
  },
  _focusTarget() {
    return this._itemContainer();
  },
  _renderInkRipple() {
    this._inkRipple = render3();
  },
  _toggleActiveState($element, value2, e) {
    this.callBase.apply(this, arguments);
    const that = this;
    if (!this._inkRipple) {
      return;
    }
    const config3 = {
      element: $element,
      event: e
    };
    if (value2) {
      if (isMaterial()) {
        this._inkRippleTimer = setTimeout(() => {
          that._inkRipple.showWave(config3);
        }, 35);
      } else {
        that._inkRipple.showWave(config3);
      }
    } else {
      clearTimeout(this._inkRippleTimer);
      this._inkRipple.hideWave(config3);
    }
  },
  _postprocessRenderItem(args) {
    this._refreshItemElements();
    this.callBase.apply(this, arguments);
    if (this.option("_swipeEnabled")) {
      this._attachSwipeEvent(renderer_default(args.itemElement));
    }
  },
  _attachSwipeEvent($itemElement) {
    const endEventName = addNamespace2(SWIPE_END_EVENT, this.NAME);
    events_engine_default.on($itemElement, endEventName, this._itemSwipeEndHandler.bind(this));
  },
  _itemSwipeEndHandler(e) {
    this._itemDXEventHandler(e, "onItemSwipe", {
      direction: e.offset < 0 ? "left" : "right"
    });
  },
  _nextButtonHandler(e) {
    this._pageLoadingAction(e);
    const dataController = this._dataController;
    if (dataController.getDataSource() && !dataController.isLoading()) {
      this._scrollView.toggleLoading(true);
      this._$nextButton.detach();
      this._loadIndicationSuppressed(true);
      this._loadNextPage();
    }
  },
  _renderGroup(index2, group) {
    const $groupElement = renderer_default("<div>").addClass("dx-list-group").appendTo(this._getItemsContainer());
    const id = `dx-${new guid_default().toString()}`;
    const groupAria = {
      role: "group",
      labelledby: id
    };
    this.setAria(groupAria, $groupElement);
    const $groupHeaderElement = renderer_default("<div>").addClass("dx-list-group-header").attr("id", id).appendTo($groupElement);
    const groupTemplateName = this.option("groupTemplate");
    const groupTemplate = this._getTemplate(group.template || groupTemplateName, group, index2, $groupHeaderElement);
    const renderArgs = {
      index: index2,
      itemData: group,
      container: getPublicElement($groupHeaderElement)
    };
    this._createItemByTemplate(groupTemplate, renderArgs);
    renderer_default("<div>").addClass("dx-list-group-header-indicator").prependTo($groupHeaderElement);
    this._renderingGroupIndex = index2;
    const $groupBody = renderer_default("<div>").addClass("dx-list-group-body").appendTo($groupElement);
    each(groupItemsGetter(group) || [], (itemIndex, item) => {
      this._renderItem({
        group: index2,
        item: itemIndex
      }, item, $groupBody);
    });
    this._groupRenderAction({
      groupElement: getPublicElement($groupElement),
      groupIndex: index2,
      groupData: group
    });
  },
  downInkRippleHandler(e) {
    this._toggleActiveState(renderer_default(e.currentTarget), true, e);
  },
  upInkRippleHandler(e) {
    this._toggleActiveState(renderer_default(e.currentTarget), false);
  },
  attachGroupHeaderInkRippleEvents() {
    const $element = this.$element();
    this._downInkRippleHandler = this._downInkRippleHandler || this.downInkRippleHandler.bind(this);
    this._upInkRippleHandler = this._upInkRippleHandler || this.upInkRippleHandler.bind(this);
    const downArguments = [$element, "dxpointerdown", ".dx-list-group-header", this._downInkRippleHandler];
    const upArguments = [$element, "dxpointerup dxpointerout", ".dx-list-group-header", this._upInkRippleHandler];
    events_engine_default.off(...downArguments);
    events_engine_default.on(...downArguments);
    events_engine_default.off(...upArguments);
    events_engine_default.on(...upArguments);
  },
  _createGroupRenderAction() {
    this._groupRenderAction = this._createActionByOption("onGroupRendered");
  },
  _clean() {
    clearTimeout(this._inkRippleTimer);
    if (this._$nextButton) {
      this._$nextButton.remove();
      this._$nextButton = null;
    }
    this.callBase.apply(this, arguments);
  },
  _dispose() {
    this._isDataSourceFirstLoadCompleted(false);
    clearTimeout(this._holdTimer);
    clearTimeout(this._loadNextPageTimer);
    clearTimeout(this._showLoadingIndicatorTimer);
    this.callBase();
  },
  _toggleDisabledState(value2) {
    this.callBase(value2);
    this._scrollView.option("disabled", value2 || !this.option("scrollingEnabled"));
  },
  _toggleNextButton(value2) {
    const dataController = this._dataController;
    const $nextButton = this._getNextButton();
    this.$element().toggleClass("dx-has-next", value2);
    if (value2 && dataController.isLoaded()) {
      $nextButton.appendTo(this._itemContainer());
    }
    if (!value2) {
      $nextButton.detach();
    }
  },
  _getNextButton() {
    if (!this._$nextButton) {
      this._$nextButton = this._createNextButton();
    }
    return this._$nextButton;
  },
  _createNextButton() {
    const $result = renderer_default("<div>").addClass("dx-list-next-button");
    const $button = renderer_default("<div>").appendTo($result);
    this._createComponent($button, button_default, {
      text: this.option("nextButtonText"),
      onClick: this._nextButtonHandler.bind(this),
      type: isMaterialBased() ? "default" : void 0,
      integrationOptions: {}
    });
    return $result;
  },
  _moveFocus() {
    this.callBase.apply(this, arguments);
    this.scrollToItem(this.option("focusedElement"));
  },
  _refresh() {
    if (!hasWindow()) {
      this.callBase();
    } else {
      const scrollTop = this._scrollView.scrollTop();
      this.callBase();
      scrollTop && this._scrollView.scrollTo(scrollTop);
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "pageLoadMode":
        this._toggleNextButton(args.value);
        this._initScrollView();
        break;
      case "dataSource":
        this.callBase(args);
        this._initScrollView();
        this._isDataSourceFirstLoadCompleted(false);
        break;
      case "items":
        this.callBase(args);
        this._isDataSourceFirstLoadCompleted(false);
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "pageLoadingText":
      case "showScrollbar":
      case "bounceEnabled":
      case "scrollByContent":
      case "scrollByThumb":
      case "useNativeScrolling":
      case "scrollingEnabled":
      case "pullRefreshEnabled":
        this._initScrollView();
        this._updateLoadingState(true);
        break;
      case "nextButtonText":
      case "onItemSwipe":
      case "useInkRipple":
      case "grouped":
      case "collapsibleGroups":
      case "groupTemplate":
      case "showChevronExpr":
      case "badgeExpr":
        this._invalidate();
        break;
      case "onScroll":
      case "onPullRefresh":
      case "onPageLoading":
        this._createScrollViewActions();
        break;
      case "wrapItemText":
        this._toggleWrapItemText(args.value);
        break;
      case "onGroupRendered":
        this._createGroupRenderAction();
        break;
      case "width":
      case "height":
        this.callBase(args);
        this._scrollView.option(args.name, args.value);
        this._scrollView.update();
        break;
      case "indicateLoading":
        this._hideLoadingIfLoadIndicationOff();
        break;
      case "visible":
        this.callBase(args);
        this._scrollView.update();
        break;
      case "rtlEnabled":
        this._initScrollView();
        this.callBase(args);
        break;
      case "_swipeEnabled":
      case "selectByClick":
        break;
      default:
        this.callBase(args);
    }
  },
  _extendActionArgs($itemElement) {
    if (!this.option("grouped")) {
      return this.callBase($itemElement);
    }
    const $group = $itemElement.closest(".dx-list-group");
    const $item = $group.find(".dx-list-item");
    return extend(this.callBase($itemElement), {
      itemIndex: {
        group: $group.index(),
        item: $item.index($itemElement)
      }
    });
  },
  expandGroup(groupIndex) {
    const deferred = Deferred();
    const $group = this._getItemsContainer().find(".dx-list-group").eq(groupIndex);
    this._collapseGroupHandler($group, false).done(() => {
      deferred.resolveWith(this);
    });
    return deferred.promise();
  },
  collapseGroup(groupIndex) {
    const deferred = Deferred();
    const $group = this._getItemsContainer().find(".dx-list-group").eq(groupIndex);
    this._collapseGroupHandler($group, true).done(() => {
      deferred.resolveWith(this);
    });
    return deferred;
  },
  updateDimensions() {
    const that = this;
    const deferred = Deferred();
    if (that._scrollView) {
      that._scrollView.update().done(() => {
        !that._scrollViewIsFull() && that._updateLoadingState(true);
        deferred.resolveWith(that);
      });
    } else {
      deferred.resolveWith(that);
    }
    return deferred.promise();
  },
  reload() {
    this.callBase();
    this.scrollTo(0);
    this._pullDownHandler();
  },
  repaint() {
    this.scrollTo(0);
    this.callBase();
  },
  scrollTop() {
    return this._scrollView.scrollOffset().top;
  },
  clientHeight() {
    return this._scrollView.clientHeight();
  },
  scrollHeight() {
    return this._scrollView.scrollHeight();
  },
  scrollBy(distance) {
    this._scrollView.scrollBy(distance);
  },
  scrollTo(location) {
    this._scrollView.scrollTo(location);
  },
  scrollToItem(itemElement) {
    const $item = this._editStrategy.getItemElement(itemElement);
    const item = null === $item || void 0 === $item ? void 0 : $item.get(0);
    this._scrollView.scrollToElement(item, {
      bottom: getElementMargin(item, "bottom")
    });
  },
  _dimensionChanged() {
    this.updateDimensions();
  }
}).include(m_grouped_data_converter_mixin_default);
ListBase.ItemClass = m_item_default2;
function getScrollView() {
  return _scrollView || scroll_view_default;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.provider.js
var editOptionsRegistry = [];
var registerOption = function(enabledFunc, decoratorTypeFunc, decoratorSubTypeFunc) {
  editOptionsRegistry.push({
    enabled: enabledFunc,
    decoratorType: decoratorTypeFunc,
    decoratorSubType: decoratorSubTypeFunc
  });
};
registerOption(function() {
  return this.option("menuItems").length;
}, () => "menu", function() {
  return this.option("menuMode");
});
registerOption(function() {
  return !this.option("menuItems").length && this.option("allowItemDeleting");
}, function() {
  const mode = this.option("itemDeleteMode");
  return "toggle" === mode || "slideButton" === mode || "swipe" === mode || "static" === mode ? "delete" : "menu";
}, function() {
  let mode = this.option("itemDeleteMode");
  if ("slideItem" === mode) {
    mode = "slide";
  }
  return mode;
});
registerOption(function() {
  return "none" !== this.option("selectionMode") && this.option("showSelectionControls");
}, () => "selection", () => "default");
registerOption(function() {
  return this.option("itemDragging.allowReordering") || this.option("itemDragging.allowDropInsideItem") || this.option("itemDragging.group");
}, () => "reorder", () => "default");
var EditProvider = class_default.inherit({
  ctor(list) {
    this._list = list;
    this._fetchRequiredDecorators();
  },
  dispose() {
    if (this._decorators && this._decorators.length) {
      each(this._decorators, (_, decorator) => {
        decorator.dispose();
      });
    }
  },
  _fetchRequiredDecorators() {
    this._decorators = [];
    each(editOptionsRegistry, (_, option) => {
      const optionEnabled = option.enabled.call(this._list);
      if (optionEnabled) {
        const decoratorType = option.decoratorType.call(this._list);
        const decoratorSubType = option.decoratorSubType.call(this._list);
        const decorator = this._createDecorator(decoratorType, decoratorSubType);
        this._decorators.push(decorator);
      }
    });
  },
  _createDecorator(type2, subType) {
    const decoratorClass = this._findDecorator(type2, subType);
    return new decoratorClass(this._list);
  },
  _findDecorator(type2, subType) {
    var _registry$type;
    const foundDecorator = null === (_registry$type = registry[type2]) || void 0 === _registry$type ? void 0 : _registry$type[subType];
    if (!foundDecorator) {
      throw ui_errors_default.Error("E1012", type2, subType);
    }
    return foundDecorator;
  },
  modifyItemElement(args) {
    const $itemElement = renderer_default(args.itemElement);
    const config3 = {
      $itemElement
    };
    this._prependBeforeBags($itemElement, config3);
    this._appendAfterBags($itemElement, config3);
    this._applyDecorators("modifyElement", config3);
  },
  afterItemsRendered() {
    this._applyDecorators("afterRender");
  },
  _prependBeforeBags($itemElement, config3) {
    const $beforeBags = this._collectDecoratorsMarkup("beforeBag", config3, "dx-list-item-before-bag");
    $itemElement.prepend($beforeBags);
  },
  _appendAfterBags($itemElement, config3) {
    const $afterBags = this._collectDecoratorsMarkup("afterBag", config3, "dx-list-item-after-bag");
    $itemElement.append($afterBags);
  },
  _collectDecoratorsMarkup(method, config3, containerClass) {
    const $collector = renderer_default("<div>");
    each(this._decorators, function() {
      const $container = renderer_default("<div>").addClass(containerClass);
      this[method](extend({
        $container
      }, config3));
      if ($container.children().length) {
        $collector.append($container);
      }
    });
    return $collector.children();
  },
  _applyDecorators(method, config3) {
    each(this._decorators, function() {
      this[method](config3);
    });
  },
  _handlerExists(name2) {
    if (!this._decorators) {
      return false;
    }
    const decorators = this._decorators;
    const {
      length
    } = decorators;
    for (let i = 0; i < length; i++) {
      if (decorators[i][name2] !== noop2) {
        return true;
      }
    }
    return false;
  },
  _eventHandler(name2, $itemElement, e) {
    if (!this._decorators) {
      return false;
    }
    let response = false;
    const decorators = this._decorators;
    const {
      length
    } = decorators;
    for (let i = 0; i < length; i++) {
      response = decorators[i][name2]($itemElement, e);
      if (response) {
        break;
      }
    }
    return response;
  },
  handleClick($itemElement, e) {
    return this._eventHandler("handleClick", $itemElement, e);
  },
  handleKeyboardEvents(currentFocusedIndex, moveFocusUp) {
    return this._eventHandler("handleKeyboardEvents", currentFocusedIndex, moveFocusUp);
  },
  handleEnterPressing(e) {
    return this._eventHandler("handleEnterPressing", e);
  },
  contextMenuHandlerExists() {
    return this._handlerExists("handleContextMenu");
  },
  handleContextMenu($itemElement, e) {
    return this._eventHandler("handleContextMenu", $itemElement, e);
  },
  getExcludedItemSelectors() {
    const excludedSelectors = [];
    this._applyDecorators("getExcludedSelectors", excludedSelectors);
    return excludedSelectors.join(",");
  }
});
var m_list_edit_provider_default = EditProvider;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.strategy.grouped.js
var combineIndex = function(indices) {
  return (indices.group << 20) + indices.item;
};
var splitIndex = function(combinedIndex) {
  return {
    group: combinedIndex >> 20,
    item: 1048575 & combinedIndex
  };
};
var GroupedEditStrategy = m_collection_widget_edit_strategy_plain_default.inherit({
  _groupElements() {
    return this._collectionWidget._itemContainer().find(".dx-list-group");
  },
  _groupItemElements: ($group) => $group.find(".dx-list-item"),
  getIndexByItemData(itemData) {
    const groups = this._collectionWidget.option("items");
    let index2 = false;
    if (!itemData) {
      return false;
    }
    if (itemData.items && itemData.items.length) {
      itemData = itemData.items[0];
    }
    each(groups, (groupIndex, group) => {
      if (!group.items) {
        return false;
      }
      each(group.items, (itemIndex, item) => {
        if (item !== itemData) {
          return true;
        }
        index2 = {
          group: groupIndex,
          item: itemIndex
        };
        return false;
      });
      if (index2) {
        return false;
      }
    });
    return index2;
  },
  getItemDataByIndex(index2) {
    const items = this._collectionWidget.option("items");
    if (isNumeric(index2)) {
      return this.itemsGetter()[index2];
    }
    return index2 && items[index2.group] && items[index2.group].items[index2.item] || null;
  },
  itemsGetter() {
    let resultItems = [];
    const items = this._collectionWidget.option("items");
    for (let i = 0; i < items.length; i++) {
      if (items[i] && items[i].items) {
        resultItems = resultItems.concat(items[i].items);
      } else {
        resultItems.push(items[i]);
      }
    }
    return resultItems;
  },
  deleteItemAtIndex(index2) {
    const indices = splitIndex(index2);
    const itemGroup = this._collectionWidget.option("items")[indices.group].items;
    itemGroup.splice(indices.item, 1);
  },
  getKeysByItems(items) {
    let plainItems = [];
    let i;
    for (i = 0; i < items.length; i++) {
      if (items[i] && items[i].items) {
        plainItems = plainItems.concat(items[i].items);
      } else {
        plainItems.push(items[i]);
      }
    }
    const result2 = [];
    for (i = 0; i < plainItems.length; i++) {
      result2.push(this._collectionWidget.keyOf(plainItems[i]));
    }
    return result2;
  },
  getIndexByKey(key, items) {
    const groups = items || this._collectionWidget.option("items");
    let index2 = -1;
    const that = this;
    each(groups, (groupIndex, group) => {
      if (!group.items) {
        return;
      }
      each(group.items, (itemIndex, item) => {
        const itemKey = that._collectionWidget.keyOf(item);
        if (that._equalKeys(itemKey, key)) {
          index2 = {
            group: groupIndex,
            item: itemIndex
          };
          return false;
        }
      });
      if (-1 !== index2) {
        return false;
      }
    });
    return index2;
  },
  _getGroups(items) {
    const dataController = this._collectionWidget._dataController;
    const group = dataController.group();
    if (group) {
      return store_helper_default.queryByOptions(query_default(items), {
        group
      }).toArray();
    }
    return this._collectionWidget.option("items");
  },
  getItemsByKeys(keys, items) {
    const result2 = [];
    const groups = this._getGroups(items);
    const groupItemByKeyMap = {};
    const getItemMeta = (key) => {
      const index2 = this.getIndexByKey(key, groups);
      const group = index2 && groups[index2.group];
      if (!group) {
        return;
      }
      return {
        groupKey: group.key,
        item: group.items[index2.item]
      };
    };
    each(keys, (_, key) => {
      const itemMeta = getItemMeta(key);
      if (!itemMeta) {
        return;
      }
      const {
        groupKey
      } = itemMeta;
      const {
        item
      } = itemMeta;
      let selectedGroup = groupItemByKeyMap[groupKey];
      if (!selectedGroup) {
        selectedGroup = {
          key: groupKey,
          items: []
        };
        groupItemByKeyMap[groupKey] = selectedGroup;
        result2.push(selectedGroup);
      }
      selectedGroup.items.push(item);
    });
    return result2;
  },
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    const items = this._collectionWidget.option("items");
    const movingIndices = splitIndex(movingIndex);
    const destinationIndices = splitIndex(destinationIndex);
    const movingItemGroup = items[movingIndices.group].items;
    const destinationItemGroup = items[destinationIndices.group].items;
    const movedItemData = movingItemGroup[movingIndices.item];
    movingItemGroup.splice(movingIndices.item, 1);
    destinationItemGroup.splice(destinationIndices.item, 0, movedItemData);
  },
  _isItemIndex: (index2) => index2 && isNumeric(index2.group) && isNumeric(index2.item),
  _getNormalizedItemIndex(itemElement) {
    const $item = renderer_default(itemElement);
    const $group = $item.closest(".dx-list-group");
    if (!$group.length) {
      return -1;
    }
    return combineIndex({
      group: this._groupElements().index($group),
      item: this._groupItemElements($group).index($item)
    });
  },
  _normalizeItemIndex: (index2) => combineIndex(index2),
  _denormalizeItemIndex: (index2) => splitIndex(index2),
  _getItemByNormalizedIndex(index2) {
    const indices = splitIndex(index2);
    const $group = this._groupElements().eq(indices.group);
    return this._groupItemElements($group).eq(indices.item);
  },
  _itemsFromSameParent: (firstIndex, secondIndex) => splitIndex(firstIndex).group === splitIndex(secondIndex).group
});
var m_list_edit_strategy_grouped_default = GroupedEditStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.js
var ListEdit = ListBase.inherit({
  _supportedKeys() {
    const that = this;
    const parent = this.callBase();
    const moveFocusedItem = (e, moveUp) => {
      const editStrategy = this._editStrategy;
      const focusedElement = this.option("focusedElement");
      const focusedItemIndex = editStrategy.getNormalizedIndex(focusedElement);
      const isLastIndexFocused = focusedItemIndex === this._getLastItemIndex();
      if (isLastIndexFocused && this._dataController.isLoading()) {
        return;
      }
      if (e.shiftKey && that.option("itemDragging.allowReordering")) {
        const nextItemIndex = focusedItemIndex + (moveUp ? -1 : 1);
        const $nextItem = editStrategy.getItemElement(nextItemIndex);
        this.reorderItem(focusedElement, $nextItem);
        this.scrollToItem(focusedElement);
        e.preventDefault();
      } else {
        const editProvider = this._editProvider;
        const isInternalMoving = editProvider.handleKeyboardEvents(focusedItemIndex, moveUp);
        if (!isInternalMoving) {
          moveUp ? parent.upArrow(e) : parent.downArrow(e);
        }
      }
    };
    return extend({}, parent, {
      del: (e) => {
        if (that.option("allowItemDeleting")) {
          e.preventDefault();
          that.deleteItem(that.option("focusedElement"));
        }
      },
      upArrow: (e) => moveFocusedItem(e, true),
      downArrow: (e) => moveFocusedItem(e),
      enter: function(e) {
        if (!this._editProvider.handleEnterPressing(e)) {
          parent.enter.apply(this, arguments);
        }
      },
      space: function(e) {
        if (!this._editProvider.handleEnterPressing(e)) {
          parent.space.apply(this, arguments);
        }
      }
    });
  },
  _updateSelection() {
    this._editProvider.afterItemsRendered();
    this.callBase();
  },
  _getLastItemIndex() {
    return this._itemElements().length - 1;
  },
  _refreshItemElements() {
    this.callBase();
    const excludedSelectors = this._editProvider.getExcludedItemSelectors();
    if (excludedSelectors.length) {
      this._itemElementsCache = this._itemElementsCache.not(excludedSelectors);
    }
  },
  _isItemStrictEquals(item1, item2) {
    const privateKey = item1 && item1.__dx_key__;
    if (privateKey && !this.key() && this._selection.isItemSelected(privateKey)) {
      return false;
    }
    return this.callBase(item1, item2);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      showSelectionControls: false,
      selectionMode: "none",
      selectAllMode: "page",
      onSelectAllValueChanged: null,
      selectAllText: message_default.format("dxList-selectAll"),
      menuItems: [],
      menuMode: "context",
      allowItemDeleting: false,
      itemDeleteMode: "static",
      itemDragging: {}
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: (device) => "ios" === device.platform,
      options: {
        menuMode: "slide",
        itemDeleteMode: "slideItem"
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        itemDeleteMode: "swipe"
      }
    }]);
  },
  _init() {
    this.callBase();
    this._initEditProvider();
  },
  _initDataSource() {
    this.callBase();
    if (!this._isPageSelectAll()) {
      this._dataSource && this._dataSource.requireTotalCount(true);
    }
  },
  _isPageSelectAll() {
    return "page" === this.option("selectAllMode");
  },
  _initEditProvider() {
    this._editProvider = new m_list_edit_provider_default(this);
  },
  _disposeEditProvider() {
    if (this._editProvider) {
      this._editProvider.dispose();
    }
  },
  _refreshEditProvider() {
    this._disposeEditProvider();
    this._initEditProvider();
  },
  _initEditStrategy() {
    if (this.option("grouped")) {
      this._editStrategy = new m_list_edit_strategy_grouped_default(this);
    } else {
      this.callBase();
    }
  },
  _initMarkup() {
    this._refreshEditProvider();
    this.callBase();
  },
  _renderItems() {
    this.callBase(...arguments);
    this._editProvider.afterItemsRendered();
  },
  _selectedItemClass: () => "dx-list-item-selected",
  _itemResponseWaitClass: () => "dx-list-item-response-wait",
  _itemClickHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = this._editProvider.handleClick($itemElement, e);
    if (handledByEditProvider) {
      return;
    }
    this._saveSelectionChangeEvent(e);
    this.callBase(...arguments);
  },
  _shouldFireContextMenuEvent() {
    return this.callBase(...arguments) || this._editProvider.contextMenuHandlerExists();
  },
  _itemHoldHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = isTouchEvent(e) && this._editProvider.handleContextMenu($itemElement, e);
    if (handledByEditProvider) {
      e.handledByEditProvider = true;
      return;
    }
    this.callBase(...arguments);
  },
  _getItemContainer(changeData) {
    if (this.option("grouped")) {
      var _this$_editStrategy$g;
      const groupIndex = null === (_this$_editStrategy$g = this._editStrategy.getIndexByItemData(changeData)) || void 0 === _this$_editStrategy$g ? void 0 : _this$_editStrategy$g.group;
      return this._getGroupContainerByIndex(groupIndex);
    }
    return this.callBase(changeData);
  },
  _itemContextMenuHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = !e.handledByEditProvider && this._editProvider.handleContextMenu($itemElement, e);
    if (handledByEditProvider) {
      e.preventDefault();
      return;
    }
    this.callBase(...arguments);
  },
  _postprocessRenderItem(args) {
    this.callBase(...arguments);
    this._editProvider.modifyItemElement(args);
  },
  _clean() {
    this._disposeEditProvider();
    this.callBase();
  },
  focusListItem(index2) {
    const $item = this._editStrategy.getItemElement(index2);
    this.option("focusedElement", $item);
    this.focus();
    this.scrollToItem(this.option("focusedElement"));
  },
  _optionChanged(args) {
    switch (args.name) {
      case "selectAllMode":
        this._initDataSource();
        this._dataController.pageIndex(0);
        this._dataController.load();
        break;
      case "grouped":
        this._clearSelectedItems();
        delete this._renderingGroupIndex;
        this._initEditStrategy();
        this.callBase(args);
        break;
      case "showSelectionControls":
      case "menuItems":
      case "menuMode":
      case "allowItemDeleting":
      case "itemDeleteMode":
      case "itemDragging":
      case "selectAllText":
        this._invalidate();
        break;
      case "onSelectAllValueChanged":
        break;
      default:
        this.callBase(args);
    }
  },
  selectAll() {
    return this._selection.selectAll(this._isPageSelectAll());
  },
  unselectAll() {
    return this._selection.deselectAll(this._isPageSelectAll());
  },
  isSelectAll() {
    return this._selection.getSelectAllState(this._isPageSelectAll());
  },
  getFlatIndexByItemElement(itemElement) {
    return this._itemElements().index(itemElement);
  },
  getItemElementByFlatIndex(flatIndex) {
    const $itemElements = this._itemElements();
    if (flatIndex < 0 || flatIndex >= $itemElements.length) {
      return renderer_default();
    }
    return $itemElements.eq(flatIndex);
  },
  getItemByIndex(index2) {
    return this._editStrategy.getItemDataByIndex(index2);
  },
  deleteItem(itemElement) {
    const editStrategy = this._editStrategy;
    const deletingElementIndex = editStrategy.getNormalizedIndex(itemElement);
    const focusedElement = this.option("focusedElement");
    const focusStateEnabled = this.option("focusStateEnabled");
    const focusedItemIndex = focusedElement ? editStrategy.getNormalizedIndex(focusedElement) : deletingElementIndex;
    const isLastIndexFocused = focusedItemIndex === this._getLastItemIndex();
    const nextFocusedItem = isLastIndexFocused || deletingElementIndex < focusedItemIndex ? focusedItemIndex - 1 : focusedItemIndex;
    const promise = this.callBase(itemElement);
    return promise.done(function() {
      if (focusStateEnabled) {
        this.focusListItem(nextFocusedItem);
      }
    });
  }
});
var m_list_edit_default = ListEdit;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/list/m_list.edit.search.js
var ListSearch = m_list_edit_default.inherit(ui_search_box_mixin_default).inherit({
  _addWidgetPrefix: (className) => `dx-list-${className}`,
  _getCombinedFilter() {
    const dataController = this._dataController;
    const storeLoadOptions = {
      filter: dataController.filter()
    };
    dataController.addSearchFilter(storeLoadOptions);
    const {
      filter
    } = storeLoadOptions;
    return filter;
  },
  _initDataSource() {
    const value2 = this.option("searchValue");
    const expr = this.option("searchExpr");
    const mode = this.option("searchMode");
    this.callBase();
    const dataController = this._dataController;
    value2 && value2.length && dataController.searchValue(value2);
    mode.length && dataController.searchOperation(ui_search_box_mixin_default.getOperationBySearchMode(mode));
    expr && dataController.searchExpr(expr);
  }
});
var m_list_edit_search_default = ListSearch;

// ../../../../../../node_modules/devextreme/esm/ui/list_light.js
component_registrator_default("dxList", m_list_edit_search_default);
var list_light_default = m_list_edit_search_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_list.js
var window22 = getWindow();
var SEARCH_MODES = ["startswith", "contains", "endwith", "notcontains"];
var useCompositionEvents = "android" !== devices_default.real().platform;
var DropDownList = m_drop_down_editor_default.inherit({
  _supportedKeys() {
    const parent = this.callBase();
    return extend({}, parent, {
      tab(e) {
        if (this._allowSelectItemByTab()) {
          this._saveValueChangeEvent(e);
          const $focusedItem = renderer_default(this._list.option("focusedElement"));
          $focusedItem.length && this._setSelectedElement($focusedItem);
        }
        parent.tab.apply(this, arguments);
      },
      space: noop2,
      home: noop2,
      end: noop2
    });
  },
  _allowSelectItemByTab() {
    return this.option("opened") && "instantly" === this.option("applyValueMode");
  },
  _setSelectedElement($element) {
    const value2 = this._valueGetter(this._list._getItemData($element));
    this._setValue(value2);
  },
  _setValue(value2) {
    this.option("value", value2);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), extend(ui_data_expression_default._dataExpressionDefaultOptions(), {
      displayValue: void 0,
      searchEnabled: false,
      searchMode: "contains",
      searchTimeout: 500,
      minSearchLength: 0,
      searchExpr: null,
      valueChangeEvent: "input change keyup",
      selectedItem: null,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      encodeNoDataText: false,
      onSelectionChanged: null,
      onItemClick: noop2,
      showDataBeforeSearch: false,
      grouped: false,
      groupTemplate: "group",
      popupPosition: {
        my: "left top",
        at: "left bottom",
        offset: {
          h: 0,
          v: 0
        },
        collision: "flip"
      },
      wrapItemText: false,
      useItemTextAsTitle: false
    }));
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: {
        platform: "ios"
      },
      options: {
        popupPosition: {
          offset: {
            v: -1
          }
        }
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        buttonsLocation: "bottom center"
      }
    }]);
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      value: true,
      selectedItem: true,
      displayValue: true
    });
  },
  _init() {
    this.callBase();
    this._initDataExpressions();
    this._initActions();
    this._setListDataSource();
    this._validateSearchMode();
    this._clearSelectedItem();
    this._initItems();
  },
  _setListFocusedElementOptionChange() {
    this._list._updateParentActiveDescendant = this._updateActiveDescendant.bind(this);
  },
  _initItems() {
    const {
      items
    } = this.option();
    if (items && !items.length && this._dataSource) {
      this.option().items = this._dataSource.items();
    }
  },
  _initActions() {
    this._initContentReadyAction();
    this._initSelectionChangedAction();
    this._initItemClickAction();
  },
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption("onContentReady", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _initSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _initItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  },
  _initTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      item: new ChildDefaultTemplate("item")
    });
  },
  _isEditable() {
    return this.callBase() || this.option("searchEnabled");
  },
  _saveFocusOnWidget() {
    if (this._list && this._list.initialOption("focusStateEnabled")) {
      this._focusInput();
    }
  },
  _fitIntoRange(value2, start, end) {
    if (value2 > end) {
      return start;
    }
    if (value2 < start) {
      return end;
    }
    return value2;
  },
  _items() {
    const items = this._getPlainItems(!this._list && this._dataSource.items());
    const availableItems = new query_default(items).filter("disabled", "<>", true).toArray();
    return availableItems;
  },
  _calcNextItem(step) {
    const items = this._items();
    const nextIndex = this._fitIntoRange(this._getSelectedIndex() + step, 0, items.length - 1);
    return items[nextIndex];
  },
  _getSelectedIndex() {
    const items = this._items();
    const selectedItem = this.option("selectedItem");
    let result2 = -1;
    each(items, (index2, item) => {
      if (this._isValueEquals(item, selectedItem)) {
        result2 = index2;
        return false;
      }
    });
    return result2;
  },
  _createPopup() {
    this.callBase();
    this._updateCustomBoundaryContainer();
    this._popup.$wrapper().addClass(this._popupWrapperClass());
    const $popupContent = this._popup.$content();
    events_engine_default.off($popupContent, "mouseup");
    events_engine_default.on($popupContent, "mouseup", this._saveFocusOnWidget.bind(this));
  },
  _updateCustomBoundaryContainer() {
    const customContainer = this.option("dropDownOptions.container");
    const $container = customContainer && renderer_default(customContainer);
    if ($container && $container.length && !isWindow($container.get(0))) {
      const $containerWithParents = [].slice.call($container.parents());
      $containerWithParents.unshift($container.get(0));
      each($containerWithParents, (i, parent) => {
        if (parent === renderer_default("body").get(0)) {
          return false;
        }
        if ("hidden" === window22.getComputedStyle(parent).overflowY) {
          this._$customBoundaryContainer = renderer_default(parent);
          return false;
        }
      });
    }
  },
  _popupWrapperClass: () => "dx-dropdownlist-popup-wrapper",
  _renderInputValue() {
    const value2 = this._getCurrentValue();
    this._rejectValueLoading();
    return this._loadInputValue(value2, this._setSelectedItem.bind(this)).always(this.callBase.bind(this, value2));
  },
  _loadInputValue(value2, callback) {
    return this._loadItem(value2).always(callback);
  },
  _getItemFromPlain(value2, cache) {
    let plainItems;
    let selectedItem;
    if (cache && "object" !== typeof value2) {
      if (!cache.itemByValue) {
        cache.itemByValue = {};
        plainItems = this._getPlainItems();
        plainItems.forEach(function(item) {
          cache.itemByValue[this._valueGetter(item)] = item;
        }, this);
      }
      selectedItem = cache.itemByValue[value2];
    }
    if (!selectedItem) {
      plainItems = this._getPlainItems();
      selectedItem = grep(plainItems, (item) => this._isValueEquals(this._valueGetter(item), value2))[0];
    }
    return selectedItem;
  },
  _loadItem(value2, cache) {
    const selectedItem = this._getItemFromPlain(value2, cache);
    return void 0 !== selectedItem ? Deferred().resolve(selectedItem).promise() : this._loadValue(value2);
  },
  _getPlainItems(items) {
    let plainItems = [];
    items = items || this.option("items") || this._dataSource.items() || [];
    for (let i = 0; i < items.length; i++) {
      if (items[i] && items[i].items) {
        plainItems = plainItems.concat(items[i].items);
      } else {
        plainItems.push(items[i]);
      }
    }
    return plainItems;
  },
  _updateActiveDescendant($target) {
    var _this$_list;
    const opened = this.option("opened");
    const listFocusedItemId = null === (_this$_list = this._list) || void 0 === _this$_list ? void 0 : _this$_list.getFocusedItemId();
    const isElementOnDom = renderer_default(`#${listFocusedItemId}`).length > 0;
    const activedescendant = opened && isElementOnDom && listFocusedItemId;
    this.setAria({
      activedescendant: activedescendant || null
    }, $target);
  },
  _setSelectedItem(item) {
    const displayValue = this._displayValue(item);
    this.option("selectedItem", ensureDefined(item, null));
    this.option("displayValue", displayValue);
  },
  _displayValue(item) {
    return this._displayGetter(item);
  },
  _refreshSelected() {
    const cache = {};
    this._listItemElements().each((_, itemElement) => {
      const $itemElement = renderer_default(itemElement);
      const itemValue = this._valueGetter($itemElement.data("dxListItemData"));
      const isItemSelected = this._isSelectedValue(itemValue, cache);
      if (isItemSelected) {
        this._list.selectItem($itemElement);
      } else {
        this._list.unselectItem($itemElement);
      }
    });
  },
  _popupShownHandler() {
    this.callBase();
    this._setFocusPolicy();
  },
  _setFocusPolicy() {
    if (!this.option("focusStateEnabled") || !this._list) {
      return;
    }
    this._list.option("focusedElement", null);
  },
  _isSelectedValue(value2) {
    return this._isValueEquals(value2, this.option("value"));
  },
  _validateSearchMode() {
    const searchMode = this.option("searchMode");
    const normalizedSearchMode = searchMode.toLowerCase();
    if (!SEARCH_MODES.includes(normalizedSearchMode)) {
      throw ui_errors_default.Error("E1019", searchMode);
    }
  },
  _clearSelectedItem() {
    this.option("selectedItem", null);
  },
  _processDataSourceChanging() {
    this._initDataController();
    this._setListOption("_dataController", this._dataController);
    this._setListDataSource();
    this._renderInputValue().fail(() => {
      if (this._isCustomValueAllowed()) {
        return;
      }
      this._clearSelectedItem();
    });
  },
  _isCustomValueAllowed() {
    return this.option("displayCustomValue");
  },
  clear() {
    this.callBase();
    this._clearFilter();
    this._clearSelectedItem();
  },
  _listItemElements() {
    return this._$list ? this._$list.find(".dx-list-item") : renderer_default();
  },
  _popupConfig() {
    return extend(this.callBase(), {
      templatesRenderAsynchronously: false,
      autoResizeEnabled: false,
      maxHeight: this._getMaxHeight.bind(this)
    });
  },
  _renderPopupContent() {
    this.callBase();
    this._renderList();
  },
  _getKeyboardListeners() {
    const canListHaveFocus = this._canListHaveFocus();
    return this.callBase().concat([!canListHaveFocus && this._list]);
  },
  _renderList() {
    this._listId = `dx-${new guid_default()._value}`;
    const $list = renderer_default("<div>").attr("id", this._listId).appendTo(this._popup.$content());
    this._$list = $list;
    this._list = this._createComponent($list, list_light_default, this._listConfig());
    this._refreshList();
    this._renderPreventBlurOnListClick();
    this._setListFocusedElementOptionChange();
  },
  _renderPreventBlurOnListClick() {
    const eventName = addNamespace2("mousedown", "dxDropDownList");
    events_engine_default.off(this._$list, eventName);
    events_engine_default.on(this._$list, eventName, (e) => e.preventDefault());
  },
  _getControlsAria() {
    return this._list && this._listId;
  },
  _renderOpenedState() {
    this.callBase();
    this._list && this._updateActiveDescendant();
    this.setAria("owns", this._popup && this._popupContentId);
  },
  _getAriaHasPopup: () => "listbox",
  _refreshList() {
    if (this._list && this._shouldRefreshDataSource()) {
      this._setListDataSource();
    }
  },
  _shouldRefreshDataSource() {
    const dataSourceProvided = !!this._list.option("dataSource");
    return dataSourceProvided !== this._needPassDataSourceToList();
  },
  _isDesktopDevice: () => "desktop" === devices_default.real().deviceType,
  _listConfig() {
    const options2 = {
      selectionMode: "single",
      _templates: this.option("_templates"),
      templateProvider: this.option("templateProvider"),
      noDataText: this.option("noDataText"),
      encodeNoDataText: this.option("encodeNoDataText"),
      grouped: this.option("grouped"),
      wrapItemText: this.option("wrapItemText"),
      useItemTextAsTitle: this.option("useItemTextAsTitle"),
      onContentReady: this._listContentReadyHandler.bind(this),
      itemTemplate: this.option("itemTemplate"),
      indicateLoading: false,
      keyExpr: this._getCollectionKeyExpr(),
      displayExpr: this._displayGetterExpr(),
      groupTemplate: this.option("groupTemplate"),
      onItemClick: this._listItemClickAction.bind(this),
      dataSource: this._getDataSource(),
      _dataController: this._dataController,
      hoverStateEnabled: this._isDesktopDevice() ? this.option("hoverStateEnabled") : false,
      focusStateEnabled: this._isDesktopDevice() ? this.option("focusStateEnabled") : false
    };
    if (!this._canListHaveFocus()) {
      options2.tabIndex = null;
    }
    return options2;
  },
  _canListHaveFocus: () => false,
  _getDataSource() {
    return this._needPassDataSourceToList() ? this._dataSource : null;
  },
  _dataSourceOptions: () => ({
    paginate: false
  }),
  _getGroupedOption() {
    return this.option("grouped");
  },
  _dataSourceFromUrlLoadMode: () => "raw",
  _listContentReadyHandler() {
    this._list = this._list || this._$list.dxList("instance");
    if (!this.option("deferRendering")) {
      this._refreshSelected();
    }
    this._updatePopupWidth();
    this._updateListDimensions();
    this._contentReadyAction();
  },
  _setListOption(optionName, value2) {
    this._setWidgetOption("_list", arguments);
  },
  _listItemClickAction(e) {
    this._listItemClickHandler(e);
    this._itemClickAction(e);
  },
  _listItemClickHandler: noop2,
  _setListDataSource() {
    if (!this._list) {
      return;
    }
    this._setListOption("dataSource", this._getDataSource());
    if (!this._needPassDataSourceToList()) {
      this._setListOption("items", []);
    }
  },
  _needPassDataSourceToList() {
    return this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded();
  },
  _isMinSearchLengthExceeded() {
    return this._searchValue().toString().length >= this.option("minSearchLength");
  },
  _needClearFilter() {
    return this._canKeepDataSource() ? false : this._needPassDataSourceToList();
  },
  _canKeepDataSource() {
    const isMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
    return this._dataController.isLoaded() && this.option("showDataBeforeSearch") && this.option("minSearchLength") && !isMinSearchLengthExceeded && !this._isLastMinSearchLengthExceeded;
  },
  _searchValue() {
    return this._input().val() || "";
  },
  _getSearchEvent() {
    return addNamespace2("input", `${this.NAME}Search`);
  },
  _getCompositionStartEvent() {
    return addNamespace2("compositionstart", `${this.NAME}CompositionStart`);
  },
  _getCompositionEndEvent() {
    return addNamespace2("compositionend", `${this.NAME}CompositionEnd`);
  },
  _getSetFocusPolicyEvent() {
    return addNamespace2("input", `${this.NAME}FocusPolicy`);
  },
  _renderEvents() {
    this.callBase();
    events_engine_default.on(this._input(), this._getSetFocusPolicyEvent(), () => {
      this._setFocusPolicy();
    });
    if (this._shouldRenderSearchEvent()) {
      events_engine_default.on(this._input(), this._getSearchEvent(), (e) => {
        this._searchHandler(e);
      });
      if (useCompositionEvents) {
        events_engine_default.on(this._input(), this._getCompositionStartEvent(), () => {
          this._isTextCompositionInProgress(true);
        });
        events_engine_default.on(this._input(), this._getCompositionEndEvent(), (e) => {
          this._isTextCompositionInProgress(void 0);
          this._searchHandler(e, this._searchValue());
        });
      }
    }
  },
  _shouldRenderSearchEvent() {
    return this.option("searchEnabled");
  },
  _refreshEvents() {
    events_engine_default.off(this._input(), this._getSearchEvent());
    events_engine_default.off(this._input(), this._getSetFocusPolicyEvent());
    if (useCompositionEvents) {
      events_engine_default.off(this._input(), this._getCompositionStartEvent());
      events_engine_default.off(this._input(), this._getCompositionEndEvent());
    }
    this.callBase();
  },
  _isTextCompositionInProgress(value2) {
    if (arguments.length) {
      this._isTextComposition = value2;
    } else {
      return this._isTextComposition;
    }
  },
  _searchHandler(e, searchValue) {
    if (this._isTextCompositionInProgress()) {
      return;
    }
    if (!this._isMinSearchLengthExceeded()) {
      this._searchCanceled();
      return;
    }
    const searchTimeout = this.option("searchTimeout");
    if (searchTimeout) {
      this._clearSearchTimer();
      this._searchTimer = setTimeout(() => {
        this._searchDataSource(searchValue);
      }, searchTimeout);
    } else {
      this._searchDataSource(searchValue);
    }
  },
  _searchCanceled() {
    this._clearSearchTimer();
    if (this._needClearFilter()) {
      this._filterDataSource(null);
    }
    this._refreshList();
  },
  _searchDataSource() {
    let searchValue = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._searchValue();
    this._filterDataSource(searchValue);
  },
  _filterDataSource(searchValue) {
    this._clearSearchTimer();
    const dataController = this._dataController;
    dataController.searchExpr(this.option("searchExpr") || this._displayGetterExpr());
    dataController.searchOperation(this.option("searchMode"));
    dataController.searchValue(searchValue);
    dataController.load().done(this._dataSourceFiltered.bind(this, searchValue));
  },
  _clearFilter() {
    const dataController = this._dataController;
    dataController.searchValue() && dataController.searchValue(null);
  },
  _dataSourceFiltered() {
    this._isLastMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
    this._refreshList();
    this._refreshPopupVisibility();
  },
  _shouldOpenPopup() {
    return this._hasItemsToShow();
  },
  _refreshPopupVisibility() {
    if (this.option("readOnly") || !this._searchValue()) {
      return;
    }
    const shouldOpenPopup = this._shouldOpenPopup();
    if (shouldOpenPopup && !this._isFocused()) {
      return;
    }
    this.option("opened", shouldOpenPopup);
    if (shouldOpenPopup) {
      this._updatePopupWidth();
      this._updateListDimensions();
    }
  },
  _dataSourceChangedHandler(newItems) {
    if (0 === this._dataController.pageIndex()) {
      this.option().items = newItems;
    } else {
      this.option().items = this.option().items.concat(newItems);
    }
  },
  _hasItemsToShow() {
    const dataController = this._dataController;
    const resultItems = dataController.items() || [];
    const resultAmount = resultItems.length;
    const isMinSearchLengthExceeded = this._needPassDataSourceToList();
    return !!(isMinSearchLengthExceeded && resultAmount);
  },
  _clearSearchTimer() {
    clearTimeout(this._searchTimer);
    delete this._searchTimer;
  },
  _popupShowingHandler() {
    this._updatePopupWidth();
    this._updateListDimensions();
  },
  _dimensionChanged() {
    this.callBase();
    this._updateListDimensions();
  },
  _needPopupRepaint() {
    const dataController = this._dataController;
    const currentPageIndex = dataController.pageIndex();
    const needRepaint = isDefined(this._pageIndex) && currentPageIndex <= this._pageIndex || dataController.isLastPage() && !this._list._scrollViewIsFull();
    this._pageIndex = currentPageIndex;
    return needRepaint;
  },
  _updateListDimensions() {
    if (!this._popup) {
      return;
    }
    if (this._needPopupRepaint()) {
      this._popup.repaint();
    }
    this._list && this._list.updateDimensions();
  },
  _getMaxHeight() {
    const $element = this.$element();
    const $customBoundaryContainer = this._$customBoundaryContainer;
    const offsetTop = $element.offset().top - ($customBoundaryContainer ? $customBoundaryContainer.offset().top : 0);
    const windowHeight = getOuterHeight(window22);
    const containerHeight = $customBoundaryContainer ? Math.min(getOuterHeight($customBoundaryContainer), windowHeight) : windowHeight;
    const maxHeight = Math.max(offsetTop, containerHeight - offsetTop - getOuterHeight($element));
    return Math.min(0.5 * containerHeight, maxHeight);
  },
  _clean() {
    if (this._list) {
      delete this._list;
    }
    delete this._isLastMinSearchLengthExceeded;
    this.callBase();
  },
  _dispose() {
    this._clearSearchTimer();
    this.callBase();
  },
  _setCollectionWidgetOption() {
    this._setListOption.apply(this, arguments);
  },
  _setSubmitValue() {
    const value2 = this.option("value");
    const submitValue = this._shouldUseDisplayValue(value2) ? this._displayGetter(value2) : value2;
    this._getSubmitElement().val(submitValue);
  },
  _shouldUseDisplayValue(value2) {
    return "this" === this.option("valueExpr") && isObject(value2);
  },
  _optionChanged(args) {
    this._dataExpressionOptionChanged(args);
    switch (args.name) {
      case "hoverStateEnabled":
      case "focusStateEnabled":
        this._isDesktopDevice() && this._setListOption(args.name, args.value);
        this.callBase(args);
        break;
      case "items":
        if (!this.option("dataSource")) {
          this._processDataSourceChanging();
        }
        break;
      case "dataSource":
        this._processDataSourceChanging();
        break;
      case "valueExpr":
        this._renderValue();
        this._setListOption("keyExpr", this._getCollectionKeyExpr());
        break;
      case "displayExpr":
        this._renderValue();
        this._setListOption("displayExpr", this._displayGetterExpr());
        break;
      case "searchMode":
        this._validateSearchMode();
        break;
      case "minSearchLength":
        this._refreshList();
        break;
      case "searchEnabled":
      case "showDataBeforeSearch":
      case "searchExpr":
        this._invalidate();
        break;
      case "onContentReady":
        this._initContentReadyAction();
        break;
      case "onSelectionChanged":
        this._initSelectionChangedAction();
        break;
      case "onItemClick":
        this._initItemClickAction();
        break;
      case "grouped":
      case "groupTemplate":
      case "wrapItemText":
      case "noDataText":
      case "encodeNoDataText":
      case "useItemTextAsTitle":
        this._setListOption(args.name);
        break;
      case "displayValue":
        this.option("text", args.value);
        break;
      case "itemTemplate":
      case "searchTimeout":
        break;
      case "selectedItem":
        if (args.previousValue !== args.value) {
          this._selectionChangedAction({
            selectedItem: args.value
          });
        }
        break;
      default:
        this.callBase(args);
    }
  }
}).include(ui_data_expression_default, m_grouped_data_converter_mixin_default);
component_registrator_default("dxDropDownList", DropDownList);
var m_drop_down_list_default = DropDownList;

// ../../../../../../node_modules/devextreme/esm/ui/drop_down_editor/ui.drop_down_list.js
var ui_drop_down_list_default = m_drop_down_list_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_select_box.js
var SelectBox = ui_drop_down_list_default.inherit({
  _supportedKeys() {
    const that = this;
    const parent = this.callBase();
    const clearSelectBox = function(e) {
      const isEditable = this._isEditable();
      if (!isEditable) {
        if (this.option("showClearButton")) {
          e.preventDefault();
          this.clear();
        }
      } else if (this._valueSubstituted()) {
        this._preventFiltering = true;
      }
      this._savedTextRemoveEvent = e;
      this._preventSubstitution = true;
    };
    const searchIfNeeded = function() {
      if (that.option("searchEnabled") && that._valueSubstituted()) {
        that._searchHandler();
      }
    };
    return extend({}, parent, {
      tab() {
        if (this.option("opened") && !this._popup.getFocusableElements().length) {
          this._resetCaretPosition(true);
        }
        parent.tab && parent.tab.apply(this, arguments);
        this._cancelSearchIfNeed();
      },
      upArrow(e) {
        if (parent.upArrow.apply(this, arguments)) {
          if (!this.option("opened")) {
            this._setNextValue(e);
          }
          return true;
        }
        return;
      },
      downArrow(e) {
        if (parent.downArrow.apply(this, arguments)) {
          if (!this.option("opened")) {
            this._setNextValue(e);
          }
          return true;
        }
        return;
      },
      leftArrow() {
        var _parent$leftArrow;
        searchIfNeeded();
        null === (_parent$leftArrow = parent.leftArrow) || void 0 === _parent$leftArrow || _parent$leftArrow.apply(this, arguments);
      },
      rightArrow() {
        searchIfNeeded();
        parent.rightArrow && parent.rightArrow.apply(this, arguments);
      },
      home() {
        searchIfNeeded();
        parent.home && parent.home.apply(this, arguments);
      },
      end() {
        searchIfNeeded();
        parent.end && parent.end.apply(this, arguments);
      },
      escape() {
        const result2 = parent.escape && parent.escape.apply(this, arguments);
        this._cancelEditing();
        return result2 ?? true;
      },
      enter(e) {
        const isOpened = this.option("opened");
        const inputText = this._input().val().trim();
        const isCustomText = inputText && this._list && !this._list.option("focusedElement");
        if (!inputText && isDefined(this.option("value")) && this.option("allowClearing")) {
          this._saveValueChangeEvent(e);
          this.option({
            selectedItem: null,
            value: null
          });
          this.close();
        } else {
          if (this.option("acceptCustomValue")) {
            e.preventDefault();
            if (isCustomText) {
              if (isOpened) {
                this._toggleOpenState();
              }
              this._valueChangeEventHandler(e);
            }
            return isOpened;
          }
          if (parent.enter && parent.enter.apply(this, arguments)) {
            return isOpened;
          }
        }
      },
      space(e) {
        const isOpened = this.option("opened");
        const isSearchEnabled = this.option("searchEnabled");
        const acceptCustomValue = this.option("acceptCustomValue");
        if (!isOpened || isSearchEnabled || acceptCustomValue) {
          return;
        }
        e.preventDefault();
        this._valueChangeEventHandler(e);
        return true;
      },
      backspace: clearSelectBox,
      del: clearSelectBox
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      placeholder: message_default.format("Select"),
      fieldTemplate: null,
      customItemCreateEvent: "change",
      valueChangeEvent: "change",
      acceptCustomValue: false,
      onCustomItemCreating(e) {
        if (!isDefined(e.customItem)) {
          e.customItem = e.text;
        }
      },
      showSelectionControls: false,
      allowClearing: true,
      tooltipEnabled: false,
      openOnFieldClick: true,
      showDropDownButton: true,
      displayCustomValue: false,
      useHiddenSubmitElement: true
    });
  },
  _init() {
    this.callBase();
    this._initCustomItemCreatingAction();
  },
  _initMarkup() {
    this.$element().addClass("dx-selectbox");
    this._renderTooltip();
    this.callBase();
    this._$container.addClass("dx-selectbox-container");
  },
  _createPopup() {
    this.callBase();
    this._popup.$element().addClass("dx-selectbox-popup");
    this._popup.$overlayContent().attr("tabindex", -1);
  },
  _popupWrapperClass() {
    return `${this.callBase()} dx-selectbox-popup-wrapper`;
  },
  _setDeprecatedOptions() {
    this.callBase();
    extend(this._deprecatedOptions, {
      valueChangeEvent: {
        since: "22.2",
        alias: "customItemCreateEvent"
      }
    });
  },
  _cancelEditing() {
    if (!this.option("searchEnabled") && this._list) {
      this._focusListElement(null);
      this._updateField(this.option("selectedItem"));
    }
  },
  _renderOpenedState() {
    this.callBase();
    if (this.option("opened")) {
      this._scrollToSelectedItem();
      this._focusSelectedElement();
    }
  },
  _focusSelectedElement() {
    const searchValue = this._searchValue();
    if (!searchValue) {
      this._focusListElement(null);
      return;
    }
    const {
      items,
      selectedItem
    } = this.option();
    const $listItems = this._list._itemElements();
    const index2 = (null === items || void 0 === items ? void 0 : items.indexOf(selectedItem)) ?? -1;
    const focusedElement = -1 !== index2 && !this._isCustomItemSelected() ? $listItems.eq(index2) : null;
    this._focusListElement(focusedElement);
  },
  _renderFocusedElement() {
    if (!this._list) {
      return;
    }
    const searchValue = this._searchValue();
    if (!searchValue || this.option("acceptCustomValue")) {
      this._focusListElement(null);
      return;
    }
    const $listItems = this._list._itemElements();
    const focusedElement = $listItems.not(".dx-state-disabled").eq(0);
    this._focusListElement(focusedElement);
  },
  _focusListElement(element) {
    this._preventInputValueRender = true;
    this._list.option("focusedElement", getPublicElement(element));
    delete this._preventInputValueRender;
  },
  _scrollToSelectedItem() {
    this._list && this._list.scrollToItem(this._list.option("selectedItem"));
  },
  _listContentReadyHandler() {
    this.callBase();
    const isPaginate = this._dataController.paginate();
    if (isPaginate && this._needPopupRepaint()) {
      return;
    }
    this._scrollToSelectedItem();
  },
  _renderValue() {
    this._renderInputValue();
    this._setSubmitValue();
    return Deferred().resolve();
  },
  _renderInputValue() {
    return this.callBase().always(() => {
      this._renderInputValueAsync();
    });
  },
  _renderInputValueAsync() {
    this._renderTooltip();
    this._renderInputValueImpl().always(() => {
      this._refreshSelected();
    });
  },
  _renderInputValueImpl() {
    this._renderField();
    return Deferred().resolve();
  },
  _setNextItem(step) {
    const item = this._calcNextItem(step);
    const value2 = this._valueGetter(item);
    this._setValue(value2);
  },
  _setNextValue(e) {
    const dataSourceIsLoaded = this._dataController.isLoaded() ? Deferred().resolve() : this._dataController.load();
    dataSourceIsLoaded.done(() => {
      const selectedIndex = this._getSelectedIndex();
      const hasPages = this._dataController.pageSize();
      const isLastPage = this._dataController.isLastPage();
      const isLastItem = selectedIndex === this._items().length - 1;
      this._saveValueChangeEvent(e);
      const step = "downArrow" === normalizeKeyName(e) ? 1 : -1;
      if (hasPages && !isLastPage && isLastItem && step > 0) {
        if (!this._popup) {
          this._createPopup();
        }
        if (!this._dataController.isLoading()) {
          this._list._loadNextPage().done(this._setNextItem.bind(this, step));
        }
      } else {
        this._setNextItem(step);
      }
    });
  },
  _setSelectedItem(item) {
    const isUnknownItem = !this._isCustomValueAllowed() && void 0 === item;
    this.callBase(isUnknownItem ? null : item);
    if (!isUnknownItem && (!this._isEditable() || this._isCustomItemSelected())) {
      this._setListOption("selectedItem", this.option("selectedItem"));
    }
  },
  _isCustomValueAllowed() {
    return this.option("acceptCustomValue") || this.callBase();
  },
  _displayValue(item) {
    item = !isDefined(item) && this._isCustomValueAllowed() ? this.option("value") : item;
    return this.callBase(item);
  },
  _listConfig() {
    const result2 = extend(this.callBase(), {
      pageLoadMode: "scrollBottom",
      onSelectionChanged: this._getSelectionChangeHandler(),
      selectedItem: this.option("selectedItem"),
      onFocusedItemChanged: this._listFocusedItemChangeHandler.bind(this)
    });
    if (this.option("showSelectionControls")) {
      extend(result2, {
        showSelectionControls: true,
        selectByClick: true
      });
    }
    return result2;
  },
  _listFocusedItemChangeHandler(e) {
    if (this._preventInputValueRender) {
      return;
    }
    const list = e.component;
    const focusedElement = renderer_default(list.option("focusedElement"));
    const focusedItem = list._getItemData(focusedElement);
    this._updateField(focusedItem);
  },
  _updateField(item) {
    const fieldTemplate = this._getTemplateByOption("fieldTemplate");
    if (!(fieldTemplate && this.option("fieldTemplate"))) {
      const text = this._displayGetter(item);
      this.option("text", text);
      this._renderDisplayText(text);
      return;
    }
    this._renderField();
  },
  _getSelectionChangeHandler() {
    return this.option("showSelectionControls") ? this._selectionChangeHandler.bind(this) : noop2;
  },
  _selectionChangeHandler(e) {
    each(e.addedItems || [], (_, addedItem) => {
      this._setValue(this._valueGetter(addedItem));
    });
  },
  _getActualSearchValue() {
    return this._dataController.searchValue();
  },
  _isInlineAutocompleteEnabled() {
    return this.option("searchEnabled") && !this.option("acceptCustomValue") && "startswith" === this.option("searchMode");
  },
  _getAriaAutocomplete() {
    const {
      disabled,
      readOnly,
      searchEnabled
    } = this.option();
    const isInputEditable = !(readOnly || disabled);
    const hasAutocomplete = searchEnabled && isInputEditable;
    if (!hasAutocomplete) {
      return "none";
    }
    const isInlineAutocompleteEnabled = this._isInlineAutocompleteEnabled();
    const autocompleteAria = isInlineAutocompleteEnabled ? "both" : "list";
    return autocompleteAria;
  },
  _toggleOpenState(isVisible2) {
    if (this.option("disabled")) {
      return;
    }
    isVisible2 = arguments.length ? isVisible2 : !this.option("opened");
    if (!isVisible2 && !this._shouldClearFilter()) {
      this._restoreInputText(true);
    }
    if (this._wasSearch() && isVisible2) {
      this._wasSearch(false);
      const showDataImmediately = this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded();
      if (showDataImmediately && this._dataController.getDataSource()) {
        if (this._searchTimer) {
          return;
        }
        const searchValue = this._getActualSearchValue();
        searchValue && this._wasSearch(true);
        this._filterDataSource(searchValue || null);
      } else {
        this._setListOption("items", []);
      }
    }
    if (isVisible2) {
      this._scrollToSelectedItem();
    }
    this.callBase(isVisible2);
  },
  _renderTooltip() {
    if (this.option("tooltipEnabled")) {
      this.$element().attr("title", this.option("displayValue"));
    }
  },
  _renderDimensions() {
    this.callBase();
    this._updatePopupWidth();
    this._updateListDimensions();
  },
  _isValueEqualInputText() {
    const initialSelectedItem = this.option("selectedItem");
    if (null === initialSelectedItem) {
      return false;
    }
    const value2 = this._displayGetter(initialSelectedItem);
    const displayValue = value2 ? String(value2) : "";
    const inputText = this._searchValue();
    return displayValue === inputText;
  },
  _popupHidingHandler() {
    if (this._isValueEqualInputText()) {
      this._cancelEditing();
    }
    this.callBase();
  },
  _popupHiddenHandler() {
    this.callBase();
    if (this._shouldCancelSearch()) {
      this._wasSearch(false);
      this._searchCanceled();
      this._shouldCancelSearch(false);
    }
  },
  _restoreInputText(saveEditingValue) {
    if (this.option("readOnly")) {
      return;
    }
    this._loadItemDeferred && this._loadItemDeferred.always(() => {
      const {
        acceptCustomValue,
        text,
        selectedItem: initialSelectedItem
      } = this.option();
      if (acceptCustomValue) {
        if (!saveEditingValue && !this._isValueChanging) {
          this._updateField(initialSelectedItem ?? this._createCustomItem(text));
          this._clearFilter();
        }
        return;
      }
      if (this.option("searchEnabled")) {
        if (!this._searchValue() && this.option("allowClearing")) {
          this._clearTextValue();
          return;
        }
      }
      if (this._isValueEqualInputText()) {
        return;
      }
      this._renderInputValue().always((selectedItem) => {
        const newSelectedItem = ensureDefined(selectedItem, initialSelectedItem);
        this._setSelectedItem(newSelectedItem);
        this._updateField(newSelectedItem);
        this._clearFilter();
      });
    });
  },
  _valueChangeEventIncludesBlur() {
    const valueChangeEvent = this.option(this._getValueChangeEventOptionName());
    return valueChangeEvent.includes("blur");
  },
  _isPreventedFocusOutEvent(e) {
    return this._preventNestedFocusEvent(e) || this._valueChangeEventIncludesBlur();
  },
  _focusOutHandler(e) {
    if (!this._isPreventedFocusOutEvent(e)) {
      const isOverlayTarget = this._isOverlayNestedTarget(e.relatedTarget);
      if (!isOverlayTarget) {
        this._restoreInputText();
        this._clearSearchTimer();
      }
      this._cancelSearchIfNeed(e);
    }
    e.target = this._input().get(0);
    this.callBase(e);
  },
  _cancelSearchIfNeed(e) {
    const {
      searchEnabled
    } = this.option();
    const isOverlayTarget = this._isOverlayNestedTarget(null === e || void 0 === e ? void 0 : e.relatedTarget);
    const shouldCancelSearch = this._wasSearch() && searchEnabled && !isOverlayTarget;
    if (shouldCancelSearch) {
      var _this$_popup;
      const isPopupVisible = null === (_this$_popup = this._popup) || void 0 === _this$_popup ? void 0 : _this$_popup._hideAnimationProcessing;
      this._clearSearchTimer();
      if (isPopupVisible) {
        this._shouldCancelSearch(true);
      } else {
        this._wasSearch(false);
        this._searchCanceled();
      }
    }
  },
  _shouldCancelSearch(value2) {
    if (!arguments.length) {
      return this._shouldCancelSearchValue;
    }
    this._shouldCancelSearchValue = value2;
  },
  _isOverlayNestedTarget: (target) => !!renderer_default(target).closest(".dx-selectbox-popup-wrapper").length,
  _clearTextValue() {
    const selectedItem = this.option("selectedItem");
    const selectedItemText = this._displayGetter(selectedItem);
    const shouldRestoreValue = selectedItem && "" !== selectedItemText;
    if (shouldRestoreValue) {
      if (this._savedTextRemoveEvent) {
        this._saveValueChangeEvent(this._savedTextRemoveEvent);
      }
      this.option("value", null);
    }
    delete this._savedTextRemoveEvent;
  },
  _shouldOpenPopup() {
    return this._needPassDataSourceToList() && this._wasSearch();
  },
  _isFocused() {
    const activeElement = dom_adapter_default.getActiveElement(this.element());
    return this.callBase() && renderer_default(activeElement).closest(this._input()).length > 0;
  },
  _getValueChangeEventOptionName: () => "customItemCreateEvent",
  _renderValueChangeEvent() {
    if (this._isEditable()) {
      this.callBase();
    }
  },
  _fieldRenderData() {
    const $listFocused = this._list && this.option("opened") && renderer_default(this._list.option("focusedElement"));
    if ($listFocused && $listFocused.length) {
      return this._list._getItemData($listFocused);
    }
    return this.option("selectedItem");
  },
  _isSelectedValue(value2) {
    return this._isValueEquals(value2, this.option("value"));
  },
  _shouldCloseOnItemClick() {
    return !(this.option("showSelectionControls") && "single" !== this.option("selectionMode"));
  },
  _listItemClickHandler(e) {
    const previousValue = this._getCurrentValue();
    this._focusListElement(renderer_default(e.itemElement));
    this._saveValueChangeEvent(e.event);
    this._completeSelection(this._valueGetter(e.itemData));
    if (this._shouldCloseOnItemClick()) {
      this.option("opened", false);
    }
    if (this.option("searchEnabled") && previousValue === this._valueGetter(e.itemData)) {
      this._updateField(e.itemData);
    }
    if (this._shouldClearFilter()) {
      this._cancelSearchIfNeed();
    }
  },
  _shouldClearFilter() {
    return this._wasSearch();
  },
  _completeSelection(value2) {
    this._setValue(value2);
  },
  _loadItem(value2, cache) {
    const that = this;
    const deferred = Deferred();
    this.callBase(value2, cache).done((item) => {
      deferred.resolve(item);
    }).fail((args) => {
      if (null !== args && void 0 !== args && args.shouldSkipCallback) {
        return;
      }
      const selectedItem = that.option("selectedItem");
      if (that.option("acceptCustomValue") && value2 === that._valueGetter(selectedItem)) {
        deferred.resolve(selectedItem);
      } else {
        deferred.reject();
      }
    });
    return deferred.promise();
  },
  _loadInputValue(value2, callback) {
    this._loadItemDeferred = this._loadItem(value2).always(callback);
    return this._loadItemDeferred;
  },
  _isCustomItemSelected() {
    const selectedItem = this.option("selectedItem");
    const searchValue = this._searchValue();
    const selectedItemText = this._displayGetter(selectedItem);
    return !selectedItemText || searchValue !== selectedItemText.toString();
  },
  _valueChangeEventHandler(e) {
    if (this.option("acceptCustomValue") && this._isCustomItemSelected() && !this._isValueChanging) {
      this._isValueChanging = true;
      this._customItemAddedHandler(e);
    }
  },
  _initCustomItemCreatingAction() {
    this._customItemCreatingAction = this._createActionByOption("onCustomItemCreating");
  },
  _createCustomItem(text) {
    const params = {
      text
    };
    const actionResult = this._customItemCreatingAction(params);
    const item = ensureDefined(actionResult, params.customItem);
    if (isDefined(actionResult)) {
      errors_default.log("W0015", "onCustomItemCreating", "customItem");
    }
    return item;
  },
  _customItemAddedHandler(e) {
    const searchValue = this._searchValue();
    const item = this._createCustomItem(searchValue);
    this._saveValueChangeEvent(e);
    if (void 0 === item) {
      this._renderValue();
      throw errors_default.Error("E0121");
    }
    if (isPromise(item)) {
      fromPromise(item).done(this._setCustomItem.bind(this)).fail(this._setCustomItem.bind(this, null));
    } else {
      this._setCustomItem(item);
    }
  },
  _setCustomItem(item) {
    if (this._disposed) {
      return;
    }
    item = item || null;
    this.option("selectedItem", item);
    this._cancelSearchIfNeed();
    this._setValue(this._valueGetter(item));
    this._renderDisplayText(this._displayGetter(item));
    this._isValueChanging = false;
  },
  _clearValueHandler(e) {
    this._preventFiltering = true;
    this.callBase(e);
    this._searchCanceled();
    return false;
  },
  _wasSearch(value2) {
    if (!arguments.length) {
      return !!this._wasSearchValue;
    }
    this._wasSearchValue = value2;
    return;
  },
  _searchHandler() {
    if (this._preventFiltering) {
      delete this._preventFiltering;
      return;
    }
    if (this._needPassDataSourceToList()) {
      this._wasSearch(true);
    }
    this.callBase(arguments);
  },
  _dataSourceFiltered(searchValue) {
    this.callBase();
    if (null !== searchValue) {
      this._renderInputSubstitution();
      this._renderFocusedElement();
    }
  },
  _valueSubstituted() {
    const input = this._input().get(0);
    const currentSearchLength = this._searchValue().length;
    const isAllSelected = 0 === input.selectionStart && input.selectionEnd === currentSearchLength;
    const inputHasSelection = input.selectionStart !== input.selectionEnd;
    const isLastSymbolSelected = currentSearchLength === input.selectionEnd;
    return this._wasSearch() && inputHasSelection && !isAllSelected && isLastSymbolSelected && this._shouldSubstitutionBeRendered();
  },
  _shouldSubstitutionBeRendered() {
    return !this._preventSubstitution && this._isInlineAutocompleteEnabled();
  },
  _renderInputSubstitution() {
    if (!this._shouldSubstitutionBeRendered()) {
      delete this._preventSubstitution;
      return;
    }
    const item = this._list && this._getPlainItems(this._list.option("items"))[0];
    if (!item) {
      return;
    }
    const $input = this._input();
    const valueLength = $input.val().length;
    if (0 === valueLength) {
      return;
    }
    const inputElement = $input.get(0);
    const displayValue = this._displayGetter(item).toString();
    inputElement.value = displayValue;
    this._caret({
      start: valueLength,
      end: displayValue.length
    });
  },
  _dispose() {
    this._renderInputValueAsync = noop2;
    delete this._loadItemDeferred;
    this.callBase();
  },
  _optionChanged(args) {
    switch (args.name) {
      case "customItemCreateEvent":
        this._refreshValueChangeEvent();
        this._refreshFocusEvent();
        this._refreshEvents();
        break;
      case "onCustomItemCreating":
        this._initCustomItemCreatingAction();
        break;
      case "tooltipEnabled":
        this._renderTooltip();
        break;
      case "readOnly":
      case "disabled":
      case "searchMode":
        this.callBase(args);
        this._setDefaultAria();
        break;
      case "displayCustomValue":
      case "acceptCustomValue":
      case "showSelectionControls":
        this._invalidate();
        break;
      case "allowClearing":
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxSelectBox", SelectBox);
var m_select_box_default = SelectBox;

// ../../../../../../node_modules/devextreme/esm/ui/select_box.js
var select_box_default = m_select_box_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_time_view.js
var rotateArrow = function($arrow, angle, offset2) {
  cssRotate($arrow, angle, offset2);
};
var cssRotate = function($arrow, angle, offset2) {
  $arrow.css("transform", `rotate(${angle}deg) translate(0,${offset2}px)`);
};
var TimeView = editor_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: new Date(Date.now()),
      use24HourFormat: true,
      _showClock: true,
      _arrowOffset: 5,
      stylingMode: void 0
    });
  },
  _getValue() {
    return this.option("value") || /* @__PURE__ */ new Date();
  },
  _init() {
    this.callBase();
    this.$element().addClass("dx-timeview");
  },
  _render() {
    this.callBase();
    this._renderBox();
    this._updateTime();
  },
  _renderBox() {
    const $box = renderer_default("<div>").appendTo(this.$element());
    const items = [];
    if (this.option("_showClock")) {
      items.push({
        ratio: 1,
        shrink: 0,
        baseSize: "auto",
        template: this._renderClock.bind(this)
      });
    }
    items.push({
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: this._renderField.bind(this)
    });
    this._createComponent($box, box_default, {
      height: "100%",
      width: "100%",
      direction: "col",
      items
    });
  },
  _renderClock(_, __, container) {
    this._$hourArrow = renderer_default("<div>").addClass("dx-timeview-hourarrow");
    this._$minuteArrow = renderer_default("<div>").addClass("dx-timeview-minutearrow");
    const $container = renderer_default(container);
    $container.addClass("dx-timeview-clock").append(this._$hourArrow).append(this._$minuteArrow);
    this.setAria("role", "presentation", $container);
  },
  _updateClock() {
    const time = this._getValue();
    const hourArrowAngle = time.getHours() / 12 * 360 + time.getMinutes() / 60 * 30;
    const minuteArrowAngle = time.getMinutes() / 60 * 360;
    rotateArrow(this._$hourArrow, hourArrowAngle, this.option("_arrowOffset"));
    rotateArrow(this._$minuteArrow, minuteArrowAngle, this.option("_arrowOffset"));
  },
  _getBoxItems(is12HourFormat) {
    const items = [{
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: () => this._hourBox.$element()
    }, {
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: renderer_default("<div>").addClass("dx-timeview-time-separator").text(date_default3.getTimeSeparator())
    }, {
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: () => this._minuteBox.$element()
    }];
    if (is12HourFormat) {
      items.push({
        ratio: 0,
        shrink: 0,
        baseSize: "auto",
        template: () => this._format12.$element()
      });
    }
    return items;
  },
  _renderField() {
    const is12HourFormat = !this.option("use24HourFormat");
    this._createHourBox(is12HourFormat);
    this._createMinuteBox();
    if (is12HourFormat) {
      this._createFormat12Box();
    }
    return this._createComponent(renderer_default("<div>").addClass("dx-timeview-field"), box_default, {
      direction: "row",
      align: "center",
      crossAlign: "center",
      items: this._getBoxItems(is12HourFormat)
    }).$element();
  },
  _createHourBox(is12HourFormat) {
    const editor = this._hourBox = this._createComponent(renderer_default("<div>"), number_box_default, extend({
      min: -1,
      max: is12HourFormat ? 13 : 24,
      value: this._getValue().getHours(),
      onValueChanged: this._onHourBoxValueChanged.bind(this),
      onKeyboardHandled: (opts) => this._keyboardHandler(opts)
    }, this._getNumberBoxConfig()));
    editor.setAria("label", "hours");
  },
  _isPM() {
    return !this.option("use24HourFormat") && 1 === this._format12.option("value");
  },
  _onHourBoxValueChanged(_ref) {
    let {
      value: value2,
      component
    } = _ref;
    const currentValue = this._getValue();
    const newValue = new Date(currentValue);
    let newHours = this._convertMaxHourToMin(value2);
    component.option("value", newHours);
    if (this._isPM()) {
      newHours += 12;
    }
    newValue.setHours(newHours);
    m_date_utils_default.normalizeTime(newValue);
    this.option("value", newValue);
  },
  _convertMaxHourToMin(hours) {
    const maxHoursValue = this.option("use24HourFormat") ? 24 : 12;
    return (maxHoursValue + hours) % maxHoursValue;
  },
  _createMinuteBox() {
    const editor = this._minuteBox = this._createComponent(renderer_default("<div>"), number_box_default, extend({
      min: -1,
      max: 60,
      value: this._getValue().getMinutes(),
      onKeyboardHandled: (opts) => this._keyboardHandler(opts),
      onValueChanged: (_ref2) => {
        let {
          value: value2,
          component
        } = _ref2;
        const newMinutes = (60 + value2) % 60;
        component.option("value", newMinutes);
        const time = new Date(this._getValue());
        time.setMinutes(newMinutes);
        m_date_utils_default.normalizeTime(time);
        this.option("value", time);
      }
    }, this._getNumberBoxConfig()));
    editor.setAria("label", "minutes");
  },
  _createFormat12Box() {
    const periodNames = date_default3.getPeriodNames();
    const editor = this._format12 = this._createComponent(renderer_default("<div>").addClass("dx-timeview-format12"), select_box_default, {
      items: [{
        value: -1,
        text: periodNames[0]
      }, {
        value: 1,
        text: periodNames[1]
      }],
      valueExpr: "value",
      displayExpr: "text",
      onKeyboardHandled: (opts) => this._keyboardHandler(opts),
      onValueChanged: (_ref3) => {
        let {
          value: value2
        } = _ref3;
        const hours = this._getValue().getHours();
        const time = new Date(this._getValue());
        const newHours = (hours + 12 * value2) % 24;
        time.setHours(newHours);
        this.option("value", time);
      },
      value: this._getValue().getHours() >= 12 ? 1 : -1,
      stylingMode: this.option("stylingMode")
    });
    editor.setAria("label", "type");
  },
  _refreshFormat12() {
    if (this.option("use24HourFormat")) {
      return;
    }
    const value2 = this._getValue();
    const hours = value2.getHours();
    const isPM = hours >= 12;
    const newValue = isPM ? 1 : -1;
    this._silentEditorValueUpdate(this._format12, newValue);
  },
  _silentEditorValueUpdate(editor, value2) {
    if (editor) {
      editor._suppressValueChangeAction();
      editor.option("value", value2);
      editor._resumeValueChangeAction();
    }
  },
  _getNumberBoxConfig() {
    return {
      showSpinButtons: true,
      displayValueFormatter: (value2) => (value2 < 10 ? "0" : "") + value2,
      stylingMode: this.option("stylingMode")
    };
  },
  _normalizeHours(hours) {
    return this.option("use24HourFormat") ? hours : hours % 12 || 12;
  },
  _updateField() {
    const hours = this._normalizeHours(this._getValue().getHours());
    this._silentEditorValueUpdate(this._hourBox, hours);
    this._silentEditorValueUpdate(this._minuteBox, this._getValue().getMinutes());
    this._refreshFormat12();
  },
  _updateTime() {
    if (this.option("_showClock")) {
      this._updateClock();
    }
    this._updateField();
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._updateTime();
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "value":
        this._updateTime();
        this.callBase(args);
        break;
      case "_arrowOffset":
        break;
      case "use24HourFormat":
      case "_showClock":
      case "stylingMode":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxTimeView", TimeView);
var m_time_view_default = TimeView;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.calendar_with_time.js
var window23 = getWindow();
var DATEBOX_TIMEVIEW_SIDE_CLASS = "dx-datebox-datetime-time-side";
var CalendarWithTimeStrategy = m_date_box_strategy_calendar_default.inherit({
  NAME: "CalendarWithTime",
  getDefaultOptions() {
    return extend(this.callBase(), {
      applyValueMode: "useButtons",
      buttonsLocation: "bottom after",
      "dropDownOptions.showTitle": false
    });
  },
  _closeDropDownByEnter() {
    return date_default.sameDate(this._getContouredValue(), this.widgetOption("value"));
  },
  getDisplayFormat: (displayFormat) => displayFormat || "shortdateshorttime",
  _is24HourFormat() {
    return date_default3.is24HourFormat(this.getDisplayFormat(this.dateBox.option("displayFormat")));
  },
  _getContouredValue() {
    const viewDate = this.callBase();
    return this._updateDateTime(viewDate);
  },
  _renderWidget() {
    this.callBase();
    this._timeView = this.dateBox._createComponent(renderer_default("<div>"), m_time_view_default, {
      value: this.dateBoxValue(),
      _showClock: !this._isShrinkView(),
      use24HourFormat: this._is24HourFormat(),
      onValueChanged: this._valueChangedHandler.bind(this),
      stylingMode: this.dateBox.option("stylingMode")
    });
  },
  renderOpenedState() {
    this.callBase();
    const popup = this._getPopup();
    if (popup) {
      popup.$wrapper().toggleClass("dx-datebox-adaptivity-mode", this._isSmallScreen());
    }
    clearTimeout(this._repaintTimer);
    this._repaintTimer = setTimeout(() => {
      this._getPopup() && this._getPopup().repaint();
    }, 0);
  },
  isAdaptivityChanged() {
    const isAdaptiveMode = this._isShrinkView();
    const currentAdaptiveMode = this._currentAdaptiveMode;
    if (isAdaptiveMode !== currentAdaptiveMode) {
      this._currentAdaptiveMode = isAdaptiveMode;
      return void 0 !== currentAdaptiveMode;
    }
    return this.callBase();
  },
  _updateValue(preventDefaultValue) {
    let date = this.dateBoxValue();
    if (!date && !preventDefaultValue) {
      date = /* @__PURE__ */ new Date();
      m_date_utils_default.normalizeTime(date);
    }
    this.callBase();
    if (this._timeView) {
      date && this._timeView.option("value", date);
      this._timeView.option("use24HourFormat", this._is24HourFormat());
    }
  },
  _isSmallScreen: () => getWidth(window23) <= 573,
  _isShrinkView() {
    return !this.dateBox.option("showAnalogClock") || this.dateBox.option("adaptivityEnabled") && this._isSmallScreen();
  },
  _getBoxItems() {
    const items = [{
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      name: "calendar"
    }];
    if (!this._isShrinkView()) {
      items.push({
        ratio: 0,
        shrink: 0,
        baseSize: "auto",
        name: "time"
      });
    }
    return items;
  },
  renderPopupContent() {
    this.callBase();
    this._currentAdaptiveMode = this._isShrinkView();
    const $popupContent = this._getPopup().$content();
    this._box = this.dateBox._createComponent(renderer_default("<div>").appendTo($popupContent), box_default, {
      direction: "row",
      crossAlign: "stretch",
      items: this._getBoxItems(),
      itemTemplate: (function(data2, i, element) {
        const $container = renderer_default("<div>");
        switch (data2.name) {
          case "calendar":
            $container.append(this._widget.$element());
            if (this._isShrinkView()) {
              this._timeView.$element().addClass(DATEBOX_TIMEVIEW_SIDE_CLASS);
              $container.append(this._timeView.$element());
            }
            break;
          case "time":
            $container.append(this._timeView.$element());
            renderer_default(element).addClass(DATEBOX_TIMEVIEW_SIDE_CLASS);
        }
        return $container;
      }).bind(this)
    });
  },
  popupConfig(popupConfig) {
    const calendarPopupConfig = this.callBase(popupConfig);
    return extend(calendarPopupConfig, {
      width: "auto"
    });
  },
  _preventFocusOnPopup(e) {
    if (!renderer_default(e.target).hasClass("dx-texteditor-input")) {
      this.callBase.apply(this, arguments);
      if (!this.dateBox._hasFocusClass()) {
        this.dateBox.focus();
      }
    }
  },
  _updateDateTime(date) {
    const time = this._timeView.option("value");
    date.setHours(time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    return date;
  },
  getValue() {
    let date = this._widget.option("value") ?? this._widget.getContouredDate();
    date = date ? new Date(date) : /* @__PURE__ */ new Date();
    return this._updateDateTime(date);
  },
  dispose() {
    clearTimeout(this._removeMinWidthTimer);
    clearTimeout(this._repaintTimer);
    this.callBase();
  }
});
var m_date_box_strategy_calendar_with_time_default = CalendarWithTimeStrategy;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/scroll_direction.js
var ScrollDirection = class {
  constructor(direction) {
    this.DIRECTION_HORIZONTAL = "horizontal";
    this.DIRECTION_VERTICAL = "vertical";
    this.DIRECTION_BOTH = "both";
    this.direction = direction ?? DIRECTION_VERTICAL;
  }
  get isHorizontal() {
    return this.direction === DIRECTION_HORIZONTAL || this.direction === DIRECTION_BOTH;
  }
  get isVertical() {
    return this.direction === DIRECTION_VERTICAL || this.direction === DIRECTION_BOTH;
  }
  get isBoth() {
    return this.direction === DIRECTION_BOTH;
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/convert_location.js
function convertToLocation(location, direction) {
  if (isPlainObject(location)) {
    const left = ensureDefined(location.left, location.x);
    const top = ensureDefined(location.top, location.y);
    return {
      left: isDefined(left) ? left : void 0,
      top: isDefined(top) ? top : void 0
    };
  }
  const {
    isHorizontal,
    isVertical
  } = new ScrollDirection(direction);
  return {
    left: isHorizontal && isDefined(location) ? location : void 0,
    top: isVertical && isDefined(location) ? location : void 0
  };
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_view_roller.js
var DateViewRoller = class extends m_scrollable_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      showScrollbar: "never",
      useNative: false,
      selectedIndex: 0,
      bounceEnabled: false,
      items: [],
      showOnClick: false,
      onClick: null,
      onSelectedIndexChanged: null,
      scrollByContent: true
    });
  }
  _init() {
    super._init();
    this.option("onVisibilityChange", this._visibilityChangedHandler.bind(this));
    this.option("onEnd", this._endActionHandler.bind(this));
  }
  _render() {
    super._render();
    this._renderSelectedItemFrame();
    this.$element().addClass("dx-dateviewroller");
    this._renderContainerClick();
    this._renderItems();
    this._renderSelectedValue();
    this._renderItemsClick();
    this._renderWheelEvent();
    this._renderSelectedIndexChanged();
  }
  _renderSelectedIndexChanged() {
    this._selectedIndexChanged = this._createActionByOption("onSelectedIndexChanged");
  }
  _renderWheelEvent() {
    events_engine_default.on(renderer_default(this.container()), "dxmousewheel", (e) => {
      this._isWheelScrolled = true;
    });
  }
  _renderContainerClick() {
    if (!this.option("showOnClick")) {
      return;
    }
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const clickAction = this._createActionByOption("onClick");
    events_engine_default.off(renderer_default(this.container()), eventName);
    events_engine_default.on(renderer_default(this.container()), eventName, (e) => {
      clickAction({
        event: e
      });
    });
  }
  _renderItems() {
    const items = this.option("items") || [];
    let $items = renderer_default();
    renderer_default(this.content()).empty();
    items.forEach((item) => {
      $items = $items.add(renderer_default("<div>").addClass("dx-dateview-item").append(item));
    });
    renderer_default(this.content()).append($items);
    this._$items = $items;
    this.update();
  }
  _renderSelectedItemFrame() {
    renderer_default("<div>").addClass("dx-dateview-item-selected-frame").append(renderer_default("<div>").addClass("dx-dateview-item-selected-border")).appendTo(renderer_default(this.container()));
  }
  _renderSelectedValue(selectedIndex) {
    const index2 = this._fitIndex(selectedIndex ?? this.option("selectedIndex"));
    this._moveTo({
      top: this._getItemPosition(index2)
    });
    this._renderActiveStateItem();
  }
  _fitIndex(index2) {
    const items = this.option("items") || [];
    const itemCount = items.length;
    if (index2 >= itemCount) {
      return itemCount - 1;
    }
    if (index2 < 0) {
      return 0;
    }
    return index2;
  }
  _getItemPosition(index2) {
    return Math.round(this._itemHeight() * index2);
  }
  _renderItemsClick() {
    const itemSelector = this._getItemSelector();
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    events_engine_default.off(this.$element(), eventName, itemSelector);
    events_engine_default.on(this.$element(), eventName, itemSelector, this._itemClickHandler.bind(this));
  }
  _getItemSelector() {
    return ".dx-dateview-item";
  }
  _itemClickHandler(e) {
    this.option("selectedIndex", this._itemElementIndex(e.currentTarget));
  }
  _itemElementIndex(itemElement) {
    return this._itemElements().index(itemElement);
  }
  _itemElements() {
    return this.$element().find(this._getItemSelector());
  }
  _renderActiveStateItem() {
    const selectedIndex = this.option("selectedIndex");
    each(this._$items, function(index2) {
      renderer_default(this).toggleClass("dx-dateview-item-selected", selectedIndex === index2);
    });
  }
  _shouldScrollToNeighborItem() {
    return "desktop" === devices_default.real().deviceType && this._isWheelScrolled;
  }
  _moveTo(targetLocation) {
    const {
      top,
      left
    } = convertToLocation(targetLocation);
    const location = this.scrollOffset();
    const delta = {
      x: location.left - left,
      y: location.top - top
    };
    if (this._isVisible() && (delta.x || delta.y)) {
      this._prepareDirections(true);
      if (this._animation && !this._shouldScrollToNeighborItem()) {
        const that = this;
        fx_default.stop(renderer_default(this.content()));
        fx_default.animate(renderer_default(this.content()), {
          duration: 200,
          type: "slide",
          to: {
            top: Math.floor(delta.y)
          },
          complete() {
            resetPosition(renderer_default(that.content()));
            that.handleMove({
              delta
            });
          }
        });
        delete this._animation;
      } else {
        this.handleMove({
          delta
        });
      }
    }
  }
  _validate(e) {
    return this._moveIsAllowed(e);
  }
  _fitSelectedIndexInRange(index2) {
    const itemsCount = this.option("items").length;
    return Math.max(Math.min(index2, itemsCount - 1), 0);
  }
  _isInNullNeighborhood(x) {
    return -0.1 <= x && x <= 0.1;
  }
  _getSelectedIndexAfterScroll(currentSelectedIndex) {
    const locationTop = this.scrollOffset().top;
    const currentSelectedIndexPosition = currentSelectedIndex * this._itemHeight();
    const dy = locationTop - currentSelectedIndexPosition;
    if (this._isInNullNeighborhood(dy)) {
      return currentSelectedIndex;
    }
    const direction = dy > 0 ? 1 : -1;
    const newSelectedIndex = this._fitSelectedIndexInRange(currentSelectedIndex + direction);
    return newSelectedIndex;
  }
  _getNewSelectedIndex(currentSelectedIndex) {
    if (this._shouldScrollToNeighborItem()) {
      return this._getSelectedIndexAfterScroll(currentSelectedIndex);
    }
    this._animation = true;
    const ratio = this.scrollOffset().top / this._itemHeight();
    return Math.round(ratio);
  }
  _endActionHandler() {
    const currentSelectedIndex = this.option("selectedIndex");
    const newSelectedIndex = this._getNewSelectedIndex(currentSelectedIndex);
    if (newSelectedIndex === currentSelectedIndex) {
      this._renderSelectedValue(newSelectedIndex);
    } else {
      this.option("selectedIndex", newSelectedIndex);
    }
    this._isWheelScrolled = false;
  }
  _itemHeight() {
    const $item = this._$items.first();
    return getHeight($item);
  }
  _toggleActive(state) {
    this.$element().toggleClass("dx-state-active", state);
  }
  _isVisible() {
    return renderer_default(this.container()).is(":visible");
  }
  _fireSelectedIndexChanged(value2, previousValue) {
    this._selectedIndexChanged({
      value: value2,
      previousValue,
      event: void 0
    });
  }
  _visibilityChanged(visible2) {
    super._visibilityChanged(visible2);
    this._visibilityChangedHandler(visible2);
  }
  _visibilityChangedHandler(visible2) {
    if (visible2) {
      this._visibilityTimer = setTimeout(() => {
        this._renderSelectedValue(this.option("selectedIndex"));
      });
    }
    this.toggleActiveState(false);
  }
  toggleActiveState(state) {
    this.$element().toggleClass("dx-dateviewroller-current", state);
  }
  _refreshSelectedIndex() {
    const selectedIndex = this.option("selectedIndex");
    const fitIndex = this._fitIndex(selectedIndex);
    if (fitIndex === selectedIndex) {
      this._renderActiveStateItem();
    } else {
      this.option("selectedIndex", fitIndex);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "selectedIndex":
        this._fireSelectedIndexChanged(args.value, args.previousValue);
        this._renderSelectedValue(args.value);
        break;
      case "items":
        this._renderItems();
        this._refreshSelectedIndex();
        break;
      case "onClick":
      case "showOnClick":
        this._renderContainerClick();
        break;
      case "onSelectedIndexChanged":
        this._renderSelectedIndexChanged();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dispose() {
    clearTimeout(this._visibilityTimer);
    super._dispose();
  }
};
component_registrator_default("dxDateViewRoller", DateViewRoller);
var m_date_view_roller_default = DateViewRoller;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_view.js
var TYPE = {
  date: "date",
  datetime: "datetime",
  time: "time"
};
var ROLLER_TYPE = {
  year: "year",
  month: "month",
  day: "day",
  hours: "hours"
};
var DateView = editor_default.inherit({
  _valueOption() {
    const value2 = this.option("value");
    const date = new Date(value2);
    return !value2 || isNaN(date) ? this._getDefaultDate() : date;
  },
  _getDefaultDate() {
    const date = /* @__PURE__ */ new Date();
    if (this.option("type") === TYPE.date) {
      return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }
    return date;
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      minDate: m_date_utils_default.MIN_DATEVIEW_DEFAULT_DATE,
      maxDate: m_date_utils_default.MAX_DATEVIEW_DEFAULT_DATE,
      type: TYPE.date,
      value: /* @__PURE__ */ new Date(),
      applyCompactClass: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: (device) => "desktop" !== device.deviceType,
      options: {
        applyCompactClass: true
      }
    }]);
  },
  _render() {
    this.callBase();
    this.$element().addClass("dx-dateview");
    this._toggleFormatClasses(this.option("type"));
    this._toggleCompactClass();
  },
  _toggleFormatClasses(currentFormat, previousFormat) {
    this.$element().addClass(`dx-dateview-${currentFormat}`);
    previousFormat && this.$element().removeClass(`dx-dateview-${previousFormat}`);
  },
  _toggleCompactClass() {
    this.$element().toggleClass("dx-dateview-compact", this.option("applyCompactClass"));
  },
  _wrapper() {
    return this._$wrapper;
  },
  _renderContentImpl() {
    this._$wrapper = renderer_default("<div>").addClass("dx-dateview-wrapper");
    this._renderRollers();
    this._$wrapper.appendTo(this.$element());
  },
  _renderRollers() {
    if (!this._$rollersContainer) {
      this._$rollersContainer = renderer_default("<div>").addClass("dx-dateview-rollers");
    }
    this._$rollersContainer.empty();
    this._createRollerConfigs();
    this._rollers = {};
    const that = this;
    each(that._rollerConfigs, (name2) => {
      const $roller = renderer_default("<div>").appendTo(that._$rollersContainer).addClass(`dx-dateviewroller-${that._rollerConfigs[name2].type}`);
      that._rollers[that._rollerConfigs[name2].type] = that._createComponent($roller, m_date_view_roller_default, {
        items: that._rollerConfigs[name2].displayItems,
        selectedIndex: that._rollerConfigs[name2].selectedIndex,
        showScrollbar: "never",
        scrollByContent: true,
        onStart(e) {
          const roller = e.component;
          roller._toggleActive(true);
          that._setActiveRoller(that._rollerConfigs[name2], roller.option("selectedIndex"));
        },
        onEnd(e) {
          const roller = e.component;
          roller._toggleActive(false);
        },
        onClick(e) {
          const roller = e.component;
          roller._toggleActive(true);
          that._setActiveRoller(that._rollerConfigs[name2], roller.option("selectedIndex"));
          that._setRollerState(that._rollerConfigs[name2], roller.option("selectedIndex"));
          roller._toggleActive(false);
        },
        onSelectedIndexChanged(e) {
          const roller = e.component;
          that._setRollerState(that._rollerConfigs[name2], roller.option("selectedIndex"));
        }
      });
    });
    that._$rollersContainer.appendTo(that._wrapper());
  },
  _createRollerConfigs(type2) {
    const that = this;
    type2 = type2 || that.option("type");
    that._rollerConfigs = {};
    date_default3.getFormatParts(m_date_utils_default.FORMATS_MAP[type2]).forEach((partName) => {
      that._createRollerConfig(partName);
    });
  },
  _createRollerConfig(componentName) {
    const componentInfo = m_date_utils_default.DATE_COMPONENTS_INFO[componentName];
    const valueRange = this._calculateRollerConfigValueRange(componentName);
    const {
      startValue
    } = valueRange;
    const {
      endValue
    } = valueRange;
    const {
      formatter
    } = componentInfo;
    const curDate = this._getCurrentDate();
    const config3 = {
      type: componentName,
      setValue: componentInfo.setter,
      valueItems: [],
      displayItems: [],
      getIndex: (value2) => value2[componentInfo.getter]() - startValue
    };
    for (let i = startValue; i <= endValue; i++) {
      config3.valueItems.push(i);
      config3.displayItems.push(formatter(i, curDate));
    }
    config3.selectedIndex = config3.getIndex(curDate);
    this._rollerConfigs[componentName] = config3;
  },
  _setActiveRoller(currentRoller) {
    const activeRoller = currentRoller && this._rollers[currentRoller.type];
    each(this._rollers, function() {
      this.toggleActiveState(this === activeRoller);
    });
  },
  _updateRollersPosition() {
    const that = this;
    each(this._rollers, function(type2) {
      const correctIndex = that._rollerConfigs[type2].getIndex(that._getCurrentDate());
      this.option("selectedIndex", correctIndex);
    });
  },
  _setRollerState(roller, selectedIndex) {
    if (selectedIndex !== roller.selectedIndex) {
      const rollerValue = roller.valueItems[selectedIndex];
      const {
        setValue
      } = roller;
      let currentValue = new Date(this._getCurrentDate());
      let currentDate = currentValue.getDate();
      const minDate = this.option("minDate");
      const maxDate = this.option("maxDate");
      if (roller.type === ROLLER_TYPE.month) {
        currentDate = Math.min(currentDate, m_date_utils_default.getMaxMonthDay(currentValue.getFullYear(), rollerValue));
      } else if (roller.type === ROLLER_TYPE.year) {
        currentDate = Math.min(currentDate, m_date_utils_default.getMaxMonthDay(rollerValue, currentValue.getMonth()));
      }
      currentValue.setDate(currentDate);
      currentValue[setValue](rollerValue);
      const normalizedDate = date_default.normalizeDate(currentValue, minDate, maxDate);
      currentValue = m_date_utils_default.mergeDates(normalizedDate, currentValue, "time");
      currentValue = date_default.normalizeDate(currentValue, minDate, maxDate);
      this.option("value", currentValue);
      roller.selectedIndex = selectedIndex;
    }
    if (roller.type === ROLLER_TYPE.year) {
      this._refreshRollers();
    }
    if (roller.type === ROLLER_TYPE.month) {
      this._refreshRoller(ROLLER_TYPE.day);
      this._refreshRoller(ROLLER_TYPE.hours);
    }
  },
  _refreshRoller(rollerType) {
    const roller = this._rollers[rollerType];
    if (roller) {
      this._createRollerConfig(rollerType);
      const rollerConfig = this._rollerConfigs[rollerType];
      if (rollerType === ROLLER_TYPE.day || rollerConfig.displayItems.toString() !== roller.option("items").toString()) {
        roller.option({
          items: rollerConfig.displayItems,
          selectedIndex: rollerConfig.selectedIndex
        });
      }
    }
  },
  _getCurrentDate() {
    const curDate = this._valueOption();
    const minDate = this.option("minDate");
    const maxDate = this.option("maxDate");
    return date_default.normalizeDate(curDate, minDate, maxDate);
  },
  _calculateRollerConfigValueRange(componentName) {
    const curDate = this._getCurrentDate();
    const minDate = this.option("minDate");
    const maxDate = this.option("maxDate");
    const minYear = date_default.sameYear(curDate, minDate);
    const minMonth = minYear && curDate.getMonth() === minDate.getMonth();
    const maxYear = date_default.sameYear(curDate, maxDate);
    const maxMonth = maxYear && curDate.getMonth() === maxDate.getMonth();
    const minHour = minMonth && curDate.getDate() === minDate.getDate();
    const maxHour = maxMonth && curDate.getDate() === maxDate.getDate();
    const componentInfo = m_date_utils_default.DATE_COMPONENTS_INFO[componentName];
    let {
      startValue
    } = componentInfo;
    let {
      endValue
    } = componentInfo;
    if (componentName === ROLLER_TYPE.year) {
      startValue = minDate.getFullYear();
      endValue = maxDate.getFullYear();
    }
    if (componentName === ROLLER_TYPE.month) {
      if (minYear) {
        startValue = minDate.getMonth();
      }
      if (maxYear) {
        endValue = maxDate.getMonth();
      }
    }
    if (componentName === ROLLER_TYPE.day) {
      endValue = m_date_utils_default.getMaxMonthDay(curDate.getFullYear(), curDate.getMonth());
      if (minYear && minMonth) {
        startValue = minDate.getDate();
      }
      if (maxYear && maxMonth) {
        endValue = maxDate.getDate();
      }
    }
    if (componentName === ROLLER_TYPE.hours) {
      startValue = minHour ? minDate.getHours() : startValue;
      endValue = maxHour ? maxDate.getHours() : endValue;
    }
    return {
      startValue,
      endValue
    };
  },
  _refreshRollers() {
    this._refreshRoller(ROLLER_TYPE.month);
    this._refreshRoller(ROLLER_TYPE.day);
    this._refreshRoller(ROLLER_TYPE.hours);
  },
  _optionChanged(args) {
    switch (args.name) {
      case "minDate":
      case "maxDate":
      case "type":
        this._renderRollers();
        this._toggleFormatClasses(args.value, args.previousValue);
        break;
      case "visible":
        this.callBase(args);
        if (args.value) {
          this._renderRollers();
        }
        break;
      case "value":
        this.option("value", this._valueOption());
        this._refreshRollers();
        this._updateRollersPosition();
        break;
      default:
        this.callBase(args);
    }
  },
  _clean() {
    this.callBase();
    delete this._$rollersContainer;
  }
});
component_registrator_default("dxDateView", DateView);
var m_date_view_default = DateView;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.date_view.js
var window24 = getWindow();
var DateViewStrategy = m_date_box_strategy_default.inherit({
  NAME: "DateView",
  getDefaultOptions() {
    return extend(this.callBase(), {
      openOnFieldClick: true,
      applyButtonText: message_default.format("OK"),
      "dropDownOptions.showTitle": true
    });
  },
  getDisplayFormat(displayFormat) {
    return displayFormat || m_date_utils_default.FORMATS_MAP[this.dateBox.option("type")];
  },
  popupConfig(config3) {
    return {
      toolbarItems: this.dateBox._popupToolbarItemsConfig(),
      onInitialized: config3.onInitialized,
      defaultOptionsRules: [{
        device: {
          platform: "android"
        },
        options: {
          width: 333,
          height: 331
        }
      }, {
        device(device) {
          const {
            platform
          } = device;
          return "generic" === platform || "ios" === platform;
        },
        options: {
          width: "auto",
          height: "auto"
        }
      }, {
        device(device) {
          const {
            platform
          } = device;
          const {
            phone
          } = device;
          return "generic" === platform && phone;
        },
        options: {
          width: 333,
          maxWidth: "100%",
          maxHeight: "100%",
          height: "auto",
          position: {
            collision: "flipfit flip"
          }
        }
      }, {
        device: {
          platform: "ios",
          phone: true
        },
        options: {
          width: "100%",
          position: {
            my: "bottom",
            at: "bottom",
            of: window24
          }
        }
      }]
    };
  },
  _renderWidget() {
    if (inputType(this.dateBox.option("mode")) && this.dateBox._isNativeType() || this.dateBox.option("readOnly")) {
      if (this._widget) {
        this._widget.$element().remove();
        this._widget = null;
      }
      return;
    }
    const popup = this._getPopup();
    if (this._widget) {
      this._widget.option(this._getWidgetOptions());
    } else {
      const element = renderer_default("<div>").appendTo(popup.$content());
      this._widget = this._createWidget(element);
    }
    this._widget.$element().appendTo(this._getWidgetContainer());
  },
  _getWidgetName: () => m_date_view_default,
  renderOpenedState() {
    this.callBase();
    if (this._widget) {
      this._widget.option("value", this._widget._getCurrentDate());
    }
  },
  _getWidgetOptions() {
    return {
      value: this.dateBoxValue() || /* @__PURE__ */ new Date(),
      type: this.dateBox.option("type"),
      minDate: this.dateBox.dateOption("min") || new Date(1900, 0, 1),
      maxDate: this.dateBox.dateOption("max") || new Date(Date.now() + 50 * m_date_utils_default.ONE_YEAR),
      onDisposing: (function() {
        this._widget = null;
      }).bind(this)
    };
  }
});
var m_date_box_strategy_date_view_default = DateViewStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.list.js
var window25 = getWindow();
var BOUNDARY_VALUES = {
  min: new Date(0, 0, 0, 0, 0),
  max: new Date(0, 0, 0, 23, 59)
};
var ListStrategy = m_date_box_strategy_default.inherit({
  NAME: "List",
  supportedKeys: () => ({
    space: noop2,
    home: noop2,
    end: noop2
  }),
  getDefaultOptions() {
    return extend(this.callBase(), {
      applyValueMode: "instantly"
    });
  },
  getDisplayFormat: (displayFormat) => displayFormat || "shorttime",
  popupConfig: (popupConfig) => popupConfig,
  getValue() {
    const selectedIndex = this._widget.option("selectedIndex");
    if (-1 === selectedIndex) {
      return this.dateBox.option("value");
    }
    const itemData = this._widgetItems[selectedIndex];
    return this._getDateByItemData(itemData);
  },
  useCurrentDateByDefault: () => true,
  getDefaultDate: () => /* @__PURE__ */ new Date(null),
  popupShowingHandler() {
    this.dateBox._dimensionChanged();
  },
  _renderWidget() {
    this.callBase();
    this._refreshItems();
  },
  _getWidgetName: () => list_light_default,
  _getWidgetOptions() {
    return {
      itemTemplate: this._timeListItemTemplate.bind(this),
      onItemClick: this._listItemClickHandler.bind(this),
      tabIndex: -1,
      onFocusedItemChanged: this._refreshActiveDescendant.bind(this),
      selectionMode: "single"
    };
  },
  _refreshActiveDescendant(e) {
    this.dateBox.setAria("activedescendant", "");
    this.dateBox.setAria("activedescendant", e.actionValue);
  },
  _refreshItems() {
    this._widgetItems = this._getTimeListItems();
    this._widget.option("items", this._widgetItems);
  },
  renderOpenedState() {
    if (!this._widget) {
      return;
    }
    this._widget.option("focusedElement", null);
    this._setSelectedItemsByValue();
    if (this._widget.option("templatesRenderAsynchronously")) {
      this._asyncScrollTimeout = setTimeout(this._scrollToSelectedItem.bind(this));
    } else {
      this._scrollToSelectedItem();
    }
  },
  dispose() {
    this.callBase();
    clearTimeout(this._asyncScrollTimeout);
  },
  _updateValue() {
    if (!this._widget) {
      return;
    }
    this._refreshItems();
    this._setSelectedItemsByValue();
    this._scrollToSelectedItem();
  },
  _setSelectedItemsByValue() {
    const value2 = this.dateBoxValue();
    const dateIndex = this._getDateIndex(value2);
    if (-1 === dateIndex) {
      this._widget.option("selectedItems", []);
    } else {
      this._widget.option("selectedIndex", dateIndex);
    }
  },
  _scrollToSelectedItem() {
    this._widget.scrollToItem(this._widget.option("selectedIndex"));
  },
  _getDateIndex(date) {
    let result2 = -1;
    for (let i = 0, n = this._widgetItems.length; i < n; i++) {
      if (this._areDatesEqual(date, this._widgetItems[i])) {
        result2 = i;
        break;
      }
    }
    return result2;
  },
  _areDatesEqual: (first, second) => isDate(first) && isDate(second) && first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes(),
  _getTimeListItems() {
    let min = this.dateBox.dateOption("min") || this._getBoundaryDate("min");
    const max = this.dateBox.dateOption("max") || this._getBoundaryDate("max");
    const value2 = this.dateBox.dateOption("value") || null;
    let delta = max - min;
    const minutes = min.getMinutes() % this.dateBox.option("interval");
    if (delta < 0) {
      return [];
    }
    if (delta > m_date_utils_default.ONE_DAY) {
      delta = m_date_utils_default.ONE_DAY;
    }
    if (value2 - min < m_date_utils_default.ONE_DAY) {
      return this._getRangeItems(min, new Date(min), delta);
    }
    min = this._getBoundaryDate("min");
    min.setMinutes(minutes);
    if (value2 && Math.abs(value2 - max) < m_date_utils_default.ONE_DAY) {
      delta = (60 * max.getHours() + Math.abs(max.getMinutes() - minutes)) * m_date_utils_default.ONE_MINUTE;
    }
    return this._getRangeItems(min, new Date(min), delta);
  },
  _getRangeItems(startValue, currentValue, rangeDuration) {
    const rangeItems = [];
    const interval = this.dateBox.option("interval");
    while (currentValue - startValue <= rangeDuration) {
      rangeItems.push(new Date(currentValue));
      currentValue.setMinutes(currentValue.getMinutes() + interval);
    }
    return rangeItems;
  },
  _getBoundaryDate(boundary) {
    const boundaryValue = BOUNDARY_VALUES[boundary];
    const currentValue = new Date(ensureDefined(this.dateBox.dateOption("value"), 0));
    return new Date(currentValue.getFullYear(), currentValue.getMonth(), currentValue.getDate(), boundaryValue.getHours(), boundaryValue.getMinutes());
  },
  _timeListItemTemplate(itemData) {
    const displayFormat = this.dateBox.option("displayFormat");
    return date_default3.format(itemData, this.getDisplayFormat(displayFormat));
  },
  _listItemClickHandler(e) {
    if ("useButtons" === this.dateBox.option("applyValueMode")) {
      return;
    }
    const date = this._getDateByItemData(e.itemData);
    this.dateBox.option("opened", false);
    this.dateBoxValue(date, e.event);
  },
  _getDateByItemData(itemData) {
    let date = this.dateBox.option("value");
    const hours = itemData.getHours();
    const minutes = itemData.getMinutes();
    const seconds = itemData.getSeconds();
    const year = itemData.getFullYear();
    const month = itemData.getMonth();
    const day = itemData.getDate();
    if (date) {
      if (this.dateBox.option("dateSerializationFormat")) {
        date = date_serialization_default.deserializeDate(date);
      } else {
        date = new Date(date);
      }
      date.setHours(hours);
      date.setMinutes(minutes);
      date.setSeconds(seconds);
      date.setFullYear(year);
      date.setMonth(month);
      date.setDate(day);
    } else {
      date = new Date(year, month, day, hours, minutes, 0, 0);
    }
    return date;
  },
  getKeyboardListener() {
    return this._widget;
  },
  _updatePopupHeight() {
    const dropDownOptionsHeight = getSizeValue(this.dateBox.option("dropDownOptions.height"));
    if (void 0 === dropDownOptionsHeight || "auto" === dropDownOptionsHeight) {
      this.dateBox._setPopupOption("height", "auto");
      const popupHeight = getOuterHeight(this._widget.$element());
      const maxHeight = 0.45 * getHeight(window25);
      this.dateBox._setPopupOption("height", Math.min(popupHeight, maxHeight));
    }
    this.dateBox._timeList && this.dateBox._timeList.updateDimensions();
  },
  getParsedText(text, format2) {
    let value2 = this.callBase(text, format2);
    if (value2) {
      value2 = m_date_utils_default.mergeDates(value2, /* @__PURE__ */ new Date(null), "date");
    }
    return value2;
  }
});
var m_date_box_strategy_list_default = ListStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.native.js
var NativeStrategy2 = m_date_box_strategy_default.inherit({
  NAME: "Native",
  popupConfig: (popupConfig) => extend({}, popupConfig, {
    width: "auto"
  }),
  getParsedText(text) {
    if (!text) {
      return null;
    }
    if ("datetime" === this.dateBox.option("type")) {
      return new Date(text.replace(/-/g, "/").replace("T", " ").split(".")[0]);
    }
    return m_date_utils_default.fromStandardDateFormat(text);
  },
  renderPopupContent: noop2,
  _getWidgetName: noop2,
  _getWidgetOptions: noop2,
  _getDateBoxType() {
    let type2 = this.dateBox.option("type");
    if (!m_date_utils_default.SUPPORTED_FORMATS.includes(type2)) {
      type2 = "date";
    } else if ("datetime" === type2 && !inputType(type2)) {
      type2 = "datetime-local";
    }
    return type2;
  },
  customizeButtons() {
    const dropDownButton = this.dateBox.getButton("dropDown");
    if (devices_default.real().android && dropDownButton) {
      dropDownButton.on("click", () => {
        this.dateBox._input().get(0).click();
      });
    }
  },
  getDefaultOptions() {
    return {
      mode: this._getDateBoxType()
    };
  },
  getDisplayFormat(displayFormat) {
    const type2 = this._getDateBoxType();
    return displayFormat || m_date_utils_default.FORMATS_MAP[type2];
  },
  renderInputMinMax($input) {
    $input.attr({
      min: date_serialization_default.serializeDate(this.dateBox.dateOption("min"), "yyyy-MM-dd"),
      max: date_serialization_default.serializeDate(this.dateBox.dateOption("max"), "yyyy-MM-dd")
    });
  }
});
var m_date_box_strategy_native_default = NativeStrategy2;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.base.js
var window26 = getWindow();
var DX_INVALID_BADGE_CLASS2 = "dx-show-invalid-badge";
var DX_CLEAR_BUTTON_CLASS = "dx-clear-button-area";
var PICKER_TYPE = {
  calendar: "calendar",
  rollers: "rollers",
  list: "list",
  native: "native"
};
var TYPE2 = {
  date: "date",
  datetime: "datetime",
  time: "time"
};
var STRATEGY_NAME = {
  calendar: "Calendar",
  dateView: "DateView",
  native: "Native",
  calendarWithTime: "CalendarWithTime",
  list: "List"
};
var STRATEGY_CLASSES = {
  Calendar: m_date_box_strategy_calendar_default,
  DateView: m_date_box_strategy_date_view_default,
  Native: m_date_box_strategy_native_default,
  CalendarWithTime: m_date_box_strategy_calendar_with_time_default,
  List: m_date_box_strategy_list_default
};
var DateBox = m_drop_down_editor_default.inherit({
  _supportedKeys() {
    return extend(this.callBase(), this._strategy.supportedKeys());
  },
  _renderButtonContainers() {
    this.callBase.apply(this, arguments);
    this._strategy.customizeButtons();
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      type: "date",
      showAnalogClock: true,
      value: null,
      dateSerializationFormat: void 0,
      min: void 0,
      max: void 0,
      displayFormat: null,
      interval: 30,
      disabledDates: null,
      pickerType: PICKER_TYPE.calendar,
      invalidDateMessage: message_default.format("dxDateBox-validation-datetime"),
      dateOutOfRangeMessage: message_default.format("validation-range"),
      applyButtonText: message_default.format("OK"),
      adaptivityEnabled: false,
      calendarOptions: {},
      useHiddenSubmitElement: true,
      _showValidationIcon: true
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: {
        platform: "ios"
      },
      options: {
        "dropDownOptions.showTitle": true
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        buttonsLocation: "bottom after"
      }
    }, {
      device() {
        const realDevice2 = devices_default.real();
        const {
          platform
        } = realDevice2;
        return "ios" === platform || "android" === platform;
      },
      options: {
        pickerType: PICKER_TYPE.native
      }
    }, {
      device: {
        platform: "generic",
        deviceType: "desktop"
      },
      options: {
        buttonsLocation: "bottom after"
      }
    }]);
  },
  _initOptions(options2) {
    this._userOptions = extend({}, options2);
    this.callBase(options2);
    this._updatePickerOptions();
  },
  _updatePickerOptions() {
    let pickerType = this.option("pickerType");
    const type2 = this.option("type");
    if (pickerType === PICKER_TYPE.list && (type2 === TYPE2.datetime || type2 === TYPE2.date)) {
      pickerType = PICKER_TYPE.calendar;
    }
    if (type2 === TYPE2.time && pickerType === PICKER_TYPE.calendar) {
      pickerType = PICKER_TYPE.list;
    }
    this._pickerType = pickerType;
    this._setShowDropDownButtonOption();
  },
  _setShowDropDownButtonOption() {
    const {
      platform
    } = devices_default.real();
    const isMozillaOnAndroid = "android" === platform && browser_default.mozilla;
    const isNativePickerType = this._isNativeType();
    let showDropDownButton = "generic" !== platform || !isNativePickerType;
    if (isNativePickerType && isMozillaOnAndroid) {
      showDropDownButton = false;
    }
    this.option({
      showDropDownButton
    });
  },
  _init() {
    this._initStrategy();
    this.option(extend({}, this._strategy.getDefaultOptions(), this._userOptions));
    delete this._userOptions;
    this.callBase();
  },
  _toLowerCaseFirstLetter: (string) => string.charAt(0).toLowerCase() + string.substr(1),
  _initStrategy() {
    const strategyName = this._getStrategyName(this._getFormatType());
    const strategy4 = STRATEGY_CLASSES[strategyName];
    if (!(this._strategy && this._strategy.NAME === strategyName)) {
      this._strategy = new strategy4(this);
    }
  },
  _getFormatType() {
    const currentType = this.option("type");
    const isTime = /h|m|s/g.test(currentType);
    const isDate3 = /d|M|Y/g.test(currentType);
    let type2 = "";
    if (isDate3) {
      type2 += TYPE2.date;
    }
    if (isTime) {
      type2 += TYPE2.time;
    }
    return type2;
  },
  _getStrategyName(type2) {
    const pickerType = this._pickerType;
    if (pickerType === PICKER_TYPE.rollers) {
      return STRATEGY_NAME.dateView;
    }
    if (pickerType === PICKER_TYPE.native) {
      return STRATEGY_NAME.native;
    }
    if (type2 === TYPE2.date) {
      return STRATEGY_NAME.calendar;
    }
    if (type2 === TYPE2.datetime) {
      return STRATEGY_NAME.calendarWithTime;
    }
    return STRATEGY_NAME.list;
  },
  _initMarkup() {
    this.$element().addClass("dx-datebox");
    this.callBase();
    this._refreshFormatClass();
    this._refreshPickerTypeClass();
    this._strategy.renderInputMinMax(this._input());
  },
  _render() {
    this.callBase();
    this._formatValidationIcon();
  },
  _renderDimensions() {
    this.callBase();
    this.$element().toggleClass("dx-auto-width", !this.option("width"));
    this._updatePopupWidth();
    this._updatePopupHeight();
  },
  _dimensionChanged() {
    this.callBase();
    this._updatePopupHeight();
  },
  _updatePopupHeight() {
    if (this._popup) {
      var _this$_strategy$_upda, _this$_strategy;
      null === (_this$_strategy$_upda = (_this$_strategy = this._strategy)._updatePopupHeight) || void 0 === _this$_strategy$_upda || _this$_strategy$_upda.call(_this$_strategy);
    }
  },
  _refreshFormatClass() {
    const $element = this.$element();
    each(TYPE2, (_, item) => {
      $element.removeClass(`dx-datebox-${item}`);
    });
    $element.addClass(`dx-datebox-${this.option("type")}`);
  },
  _refreshPickerTypeClass() {
    const $element = this.$element();
    each(PICKER_TYPE, (_, item) => {
      $element.removeClass(`dx-datebox-${item}`);
    });
    $element.addClass(`dx-datebox-${this._pickerType}`);
  },
  _formatValidationIcon() {
    if (!hasWindow()) {
      return;
    }
    const inputElement = this._input().get(0);
    const isRtlEnabled = this.option("rtlEnabled");
    const clearButtonWidth = this._getClearButtonWidth();
    const longestElementDimensions = this._getLongestElementDimensions();
    const curWidth = parseFloat(window26.getComputedStyle(inputElement).width) - clearButtonWidth;
    const shouldHideValidationIcon = longestElementDimensions.width > curWidth;
    const {
      style
    } = inputElement;
    this.$element().toggleClass(DX_INVALID_BADGE_CLASS2, !shouldHideValidationIcon && this.option("_showValidationIcon"));
    if (shouldHideValidationIcon) {
      if (void 0 === this._storedPadding) {
        this._storedPadding = isRtlEnabled ? longestElementDimensions.leftPadding : longestElementDimensions.rightPadding;
      }
      isRtlEnabled ? style.paddingLeft = 0 : style.paddingRight = 0;
    } else {
      isRtlEnabled ? style.paddingLeft = `${this._storedPadding}px` : style.paddingRight = `${this._storedPadding}px`;
    }
  },
  _getClearButtonWidth() {
    let clearButtonWidth = 0;
    if (this._isClearButtonVisible() && "" === this._input().val()) {
      const clearButtonElement = this.$element().find(`.${DX_CLEAR_BUTTON_CLASS}`).get(0);
      clearButtonWidth = parseFloat(window26.getComputedStyle(clearButtonElement).width);
    }
    return clearButtonWidth;
  },
  _getLongestElementDimensions() {
    const format2 = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const longestValue = date_default3.format(m_date_utils_default.getLongestDate(format2, date_default3.getMonthNames(), date_default3.getDayNames()), format2);
    const $input = this._input();
    const inputElement = $input.get(0);
    const $longestValueElement = createTextElementHiddenCopy($input, longestValue);
    const isPaddingStored = void 0 !== this._storedPadding;
    const storedPadding = !isPaddingStored ? 0 : this._storedPadding;
    $longestValueElement.appendTo(this.$element());
    const elementWidth = parseFloat(window26.getComputedStyle($longestValueElement.get(0)).width);
    const rightPadding = parseFloat(window26.getComputedStyle(inputElement).paddingRight);
    const leftPadding = parseFloat(window26.getComputedStyle(inputElement).paddingLeft);
    const necessaryWidth = elementWidth + leftPadding + rightPadding + storedPadding;
    $longestValueElement.remove();
    return {
      width: necessaryWidth,
      leftPadding,
      rightPadding
    };
  },
  _getKeyboardListeners() {
    return this.callBase().concat([this._strategy && this._strategy.getKeyboardListener()]);
  },
  _renderPopup() {
    this.callBase();
    this._popup.$wrapper().addClass("dx-datebox-wrapper");
    this._renderPopupWrapper();
  },
  _getPopupToolbarItems() {
    var _this$_strategy$_getP, _this$_strategy2;
    const defaultItems = this.callBase();
    return (null === (_this$_strategy$_getP = (_this$_strategy2 = this._strategy)._getPopupToolbarItems) || void 0 === _this$_strategy$_getP ? void 0 : _this$_strategy$_getP.call(_this$_strategy2, defaultItems)) ?? defaultItems;
  },
  _popupConfig() {
    const popupConfig = this.callBase();
    return extend(this._strategy.popupConfig(popupConfig), {
      title: this._getPopupTitle(),
      dragEnabled: false
    });
  },
  _renderPopupWrapper() {
    if (!this._popup) {
      return;
    }
    const $element = this.$element();
    const classPostfixes = extend({}, TYPE2, PICKER_TYPE);
    each(classPostfixes, (_, item) => {
      $element.removeClass(`dx-datebox-wrapper-${item}`);
    });
    this._popup.$wrapper().addClass(`dx-datebox-wrapper-${this.option("type")}`).addClass(`dx-datebox-wrapper-${this._pickerType}`).addClass("dx-dropdowneditor-overlay");
  },
  _renderPopupContent() {
    this.callBase();
    this._strategy.renderPopupContent();
  },
  _popupShowingHandler() {
    this.callBase();
    this._strategy.popupShowingHandler();
  },
  _popupShownHandler() {
    this.callBase();
    this._strategy.renderOpenedState();
  },
  _popupHiddenHandler() {
    this.callBase();
    this._strategy.renderOpenedState();
    this._strategy.popupHiddenHandler();
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._formatValidationIcon();
    }
  },
  _clearValueHandler(e) {
    this.option("text", "");
    this.callBase(e);
  },
  _readOnlyPropValue() {
    if (this._pickerType === PICKER_TYPE.rollers) {
      return true;
    }
    const {
      platform
    } = devices_default.real();
    const isCustomValueDisabled = this._isNativeType() && ("ios" === platform || "android" === platform);
    if (isCustomValueDisabled) {
      return this.option("readOnly");
    }
    return this.callBase();
  },
  _isClearButtonVisible() {
    return this.callBase() && !this._isNativeType();
  },
  _renderValue() {
    const value2 = this.dateOption("value");
    this.option("text", this._getDisplayedText(value2));
    this._strategy.renderValue();
    return this.callBase();
  },
  _setSubmitValue() {
    const value2 = this.dateOption("value");
    const dateSerializationFormat = this.option("dateSerializationFormat");
    const submitFormat = m_date_utils_default.SUBMIT_FORMATS_MAP[this.option("type")];
    const submitValue = dateSerializationFormat ? date_serialization_default.serializeDate(value2, dateSerializationFormat) : m_date_utils_default.toStandardDateFormat(value2, submitFormat);
    this._getSubmitElement().val(submitValue);
  },
  _getDisplayedText(value2) {
    const mode = this.option("mode");
    let displayedText;
    if ("text" === mode) {
      const displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
      displayedText = date_default3.format(value2, displayFormat);
    } else {
      const format2 = this._getFormatByMode(mode);
      if (format2) {
        displayedText = date_default3.format(value2, format2);
      } else {
        displayedText = m_date_utils_default.toStandardDateFormat(value2, mode);
      }
    }
    return displayedText;
  },
  _getFormatByMode: (mode) => inputType(mode) ? null : m_date_utils_default.FORMATS_MAP[mode],
  _valueChangeEventHandler(e) {
    const {
      text,
      type: type2,
      validationError
    } = this.option();
    const currentValue = this.dateOption("value");
    if (text === this._getDisplayedText(currentValue)) {
      this._recallInternalValidation(currentValue, validationError);
      return;
    }
    const parsedDate = this._getParsedDate(text);
    const value2 = currentValue ?? this._getDateByDefault();
    const newValue = m_date_utils_default.mergeDates(value2, parsedDate, type2);
    const date = parsedDate && "time" === type2 ? newValue : parsedDate;
    if (this._applyInternalValidation(date).isValid) {
      const displayedText = this._getDisplayedText(newValue);
      if (value2 && newValue && value2.getTime() === newValue.getTime() && displayedText !== text) {
        this._renderValue();
      } else {
        this.dateValue(newValue, e);
      }
    }
  },
  _recallInternalValidation(value2, validationError) {
    if (!validationError || validationError.editorSpecific) {
      this._applyInternalValidation(value2);
      this._applyCustomValidation(value2);
    }
  },
  _getDateByDefault() {
    return this._strategy.useCurrentDateByDefault() && this._strategy.getDefaultDate();
  },
  _getParsedDate(text) {
    const displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const parsedText = this._strategy.getParsedText(text, displayFormat);
    return parsedText ?? void 0;
  },
  _applyInternalValidation(value2) {
    const text = this.option("text");
    const hasText = !!text && null !== value2;
    const isDate3 = !!value2 && isDate(value2) && !isNaN(value2.getTime());
    const isDateInRange2 = isDate3 && date_default.dateInRange(value2, this.dateOption("min"), this.dateOption("max"), this.option("type"));
    const isValid = !hasText && !value2 || isDateInRange2;
    let validationMessage = "";
    if (!isDate3) {
      validationMessage = this.option("invalidDateMessage");
    } else if (!isDateInRange2) {
      validationMessage = this.option("dateOutOfRangeMessage");
    }
    this._updateInternalValidationState(isValid, validationMessage);
    return {
      isValid,
      isDate: isDate3
    };
  },
  _updateInternalValidationState(isValid, validationMessage) {
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: validationMessage
      }
    });
  },
  _applyCustomValidation(value2) {
    this.validationRequest.fire({
      editor: this,
      value: this._serializeDate(value2)
    });
  },
  _isValueChanged(newValue) {
    const oldValue = this.dateOption("value");
    const oldTime = oldValue && oldValue.getTime();
    const newTime = newValue && newValue.getTime();
    return oldTime !== newTime;
  },
  _isTextChanged(newValue) {
    const oldText = this.option("text");
    const newText = newValue && this._getDisplayedText(newValue) || "";
    return oldText !== newText;
  },
  _renderProps() {
    this.callBase();
    this._input().attr("autocomplete", "off");
  },
  _renderOpenedState() {
    if (!this._isNativeType()) {
      this.callBase();
    }
    if (this._strategy.isAdaptivityChanged()) {
      this._refreshStrategy();
    }
  },
  _getPopupTitle() {
    const placeholder = this.option("placeholder");
    if (placeholder) {
      return placeholder;
    }
    const type2 = this.option("type");
    if (type2 === TYPE2.time) {
      return message_default.format("dxDateBox-simulatedDataPickerTitleTime");
    }
    if (type2 === TYPE2.date || type2 === TYPE2.datetime) {
      return message_default.format("dxDateBox-simulatedDataPickerTitleDate");
    }
    return "";
  },
  _refreshStrategy() {
    this._strategy.dispose();
    this._initStrategy();
    this.option(this._strategy.getDefaultOptions());
    this._refresh();
  },
  _applyButtonHandler(e) {
    const value2 = this._strategy.getValue();
    this.dateValue(value2, e.event);
    this.callBase();
  },
  _dispose() {
    var _this$_strategy3;
    this.callBase();
    null === (_this$_strategy3 = this._strategy) || void 0 === _this$_strategy3 || _this$_strategy3.dispose();
  },
  _isNativeType() {
    return this._pickerType === PICKER_TYPE.native;
  },
  _updatePopupTitle() {
    var _this$_popup;
    null === (_this$_popup = this._popup) || void 0 === _this$_popup || _this$_popup.option("title", this._getPopupTitle());
  },
  _optionChanged(args) {
    switch (args.name) {
      case "showClearButton":
      case "buttons":
      case "isValid":
      case "readOnly":
        this.callBase.apply(this, arguments);
        this._formatValidationIcon();
        break;
      case "pickerType":
        this._updatePickerOptions({
          pickerType: args.value
        });
        this._refreshStrategy();
        this._refreshPickerTypeClass();
        this._invalidate();
        break;
      case "type":
        this._updatePickerOptions({
          format: args.value
        });
        this._refreshStrategy();
        this._refreshFormatClass();
        this._renderPopupWrapper();
        this._formatValidationIcon();
        this._updateValue();
        break;
      case "placeholder":
        this.callBase.apply(this, arguments);
        this._updatePopupTitle();
        break;
      case "min":
      case "max": {
        const isValid = this.option("isValid");
        this._applyInternalValidation(this.dateOption("value"));
        if (!isValid) {
          this._applyCustomValidation(this.dateOption("value"));
        }
        this._invalidate();
        break;
      }
      case "dateSerializationFormat":
      case "interval":
      case "disabledDates":
      case "calendarOptions":
        this._invalidate();
        break;
      case "displayFormat":
        this.option("text", this._getDisplayedText(this.dateOption("value")));
        this._renderInputValue();
        break;
      case "text":
        this._strategy.textChangedHandler(args.value);
        this.callBase.apply(this, arguments);
        break;
      case "showDropDownButton":
        this._formatValidationIcon();
        this.callBase.apply(this, arguments);
        break;
      case "todayButtonText":
        this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
        break;
      case "invalidDateMessage":
      case "dateOutOfRangeMessage":
      case "adaptivityEnabled":
      case "showAnalogClock":
      case "_showValidationIcon":
        break;
      default:
        this.callBase.apply(this, arguments);
    }
  },
  _getSerializationFormat() {
    const value2 = this.option("value");
    if (this.option("dateSerializationFormat") && config_default().forceIsoDateParsing) {
      return this.option("dateSerializationFormat");
    }
    if (isNumeric(value2)) {
      return "number";
    }
    if (!isString(value2)) {
      return;
    }
    return date_serialization_default.getDateSerializationFormat(value2);
  },
  _updateValue(value2) {
    this.callBase();
    this._applyInternalValidation(value2 ?? this.dateOption("value"));
  },
  dateValue(value2, dxEvent) {
    const isValueChanged = this._isValueChanged(value2);
    if (isValueChanged && dxEvent) {
      this._saveValueChangeEvent(dxEvent);
    }
    if (!isValueChanged) {
      if (this._isTextChanged(value2)) {
        this._updateValue(value2);
      } else if ("" === this.option("text")) {
        this._applyCustomValidation(value2);
      }
    }
    return this.dateOption("value", value2);
  },
  dateOption(optionName, value2) {
    if (1 === arguments.length) {
      return date_serialization_default.deserializeDate(this.option(optionName));
    }
    this.option(optionName, this._serializeDate(value2));
  },
  _serializeDate(date) {
    const serializationFormat = this._getSerializationFormat();
    return date_serialization_default.serializeDate(date, serializationFormat);
  },
  _clearValue() {
    const value2 = this.option("value");
    this.callBase();
    if (null === value2) {
      this._applyCustomValidation(null);
    }
  },
  clear() {
    const value2 = this.option("value");
    this.callBase();
    if (null === value2) {
      this._applyInternalValidation(null);
    }
  }
});
var m_date_box_base_default = DateBox;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.mask.parts.js
var monthGetter = (date) => date.getMonth() + 1;
var monthSetter = (date, value2) => {
  const day = date.getDate();
  const monthLimits = getLimits("M", date);
  const newValue = fitIntoRange(parseInt(value2), monthLimits.min, monthLimits.max);
  date.setMonth(newValue - 1, 1);
  const {
    min,
    max
  } = getLimits("dM", date);
  const newDay = fitIntoRange(day, min, max);
  date.setDate(newDay);
};
var PATTERN_GETTERS = {
  a: (date) => date.getHours() < 12 ? 0 : 1,
  E: "getDay",
  y: "getFullYear",
  M: monthGetter,
  L: monthGetter,
  d: "getDate",
  H: "getHours",
  h: "getHours",
  m: "getMinutes",
  s: "getSeconds",
  S: "getMilliseconds",
  x: "getTimezoneOffset"
};
var PATTERN_SETTERS2 = extend({}, getPatternSetters(), {
  a: (date, value2) => {
    const hours = date.getHours();
    const current2 = hours >= 12;
    if (current2 === !!parseInt(value2)) {
      return;
    }
    date.setHours((hours + 12) % 24);
  },
  d: (date, value2) => {
    const lastDayInMonth = getLimits("dM", date).max;
    if (value2 > lastDayInMonth) {
      date.setMonth(date.getMonth() + 1);
    }
    date.setDate(value2);
  },
  h: (date, value2) => {
    const isPM = date.getHours() >= 12;
    date.setHours(+value2 % 12 + (isPM ? 12 : 0));
  },
  M: monthSetter,
  L: monthSetter,
  E: (date, value2) => {
    if (value2 < 0) {
      return;
    }
    date.setDate(date.getDate() - date.getDay() + parseInt(value2));
  },
  y: (date, value2) => {
    const currentYear = date.getFullYear();
    const valueLength = String(value2).length;
    const maxLimitLength = String(getLimits("y", date).max).length;
    const newValue = parseInt(String(currentYear).substr(0, maxLimitLength - valueLength) + value2);
    date.setFullYear(newValue);
  },
  x: (date) => date
});
var getPatternGetter = (patternChar) => PATTERN_GETTERS[patternChar] || (() => patternChar);
var renderDateParts = (text, regExpInfo) => {
  const result2 = regExpInfo.regexp.exec(text);
  let start = 0;
  let end = 0;
  const sections = [];
  for (let i = 1; i < result2.length; i++) {
    start = end;
    end = start + result2[i].length;
    const pattern = regExpInfo.patterns[i - 1].replace(/^'|'$/g, "");
    const getter = getPatternGetter(pattern[0]);
    sections.push({
      index: i - 1,
      isStub: pattern === result2[i],
      caret: {
        start,
        end
      },
      pattern,
      text: result2[i],
      limits: function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return getLimits(pattern[0], ...args);
      },
      setter: PATTERN_SETTERS2[pattern[0]] || noop2,
      getter
    });
  }
  return sections;
};
var getLimits = (pattern, date, forcedPattern) => {
  const limits = {
    y: {
      min: 0,
      max: 9999
    },
    M: {
      min: 1,
      max: 12
    },
    L: {
      min: 1,
      max: 12
    },
    d: {
      min: 1,
      max: 31
    },
    dM: {
      min: 1,
      max: new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate()
    },
    E: {
      min: 0,
      max: 6
    },
    H: {
      min: 0,
      max: 23
    },
    h: {
      min: 1,
      max: 12
    },
    m: {
      min: 0,
      max: 59
    },
    s: {
      min: 0,
      max: 59
    },
    S: {
      min: 0,
      max: 999
    },
    a: {
      min: 0,
      max: 1
    },
    x: {
      min: 0,
      max: 0
    }
  };
  return limits[forcedPattern || pattern] || limits.getAmPm;
};
var getDatePartIndexByPosition = (dateParts, position3) => {
  for (let i = 0; i < dateParts.length; i++) {
    const caretInGroup = dateParts[i].caret.end >= position3;
    if (!dateParts[i].isStub && caretInGroup) {
      return i;
    }
  }
  return null;
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.mask.js
var DateBoxMask = m_date_box_base_default.inherit({
  _supportedKeys(e) {
    const originalHandlers = this.callBase(e);
    const callOriginalHandler = (e2) => {
      const originalHandler = originalHandlers[normalizeKeyName(e2)];
      return originalHandler && originalHandler.apply(this, [e2]);
    };
    const applyHandler = (e2, maskHandler) => {
      if (this._shouldUseOriginalHandler(e2)) {
        return callOriginalHandler.apply(this, [e2]);
      }
      return maskHandler.apply(this, [e2]);
    };
    return extend({}, originalHandlers, {
      del: (e2) => applyHandler(e2, (event) => {
        this._revertPart(1);
        this._isAllSelected() || event.preventDefault();
      }),
      backspace: (e2) => applyHandler(e2, (event) => {
        this._revertPart(-1);
        this._isAllSelected() || event.preventDefault();
      }),
      home: (e2) => applyHandler(e2, (event) => {
        this._selectFirstPart();
        event.preventDefault();
      }),
      end: (e2) => applyHandler(e2, (event) => {
        this._selectLastPart();
        event.preventDefault();
      }),
      escape: (e2) => applyHandler(e2, (event) => {
        this._revertChanges(event);
      }),
      enter: (e2) => applyHandler(e2, () => {
        this._enterHandler();
      }),
      leftArrow: (e2) => applyHandler(e2, (event) => {
        this._selectNextPart(-1);
        event.preventDefault();
      }),
      rightArrow: (e2) => applyHandler(e2, (event) => {
        this._selectNextPart(1);
        event.preventDefault();
      }),
      upArrow: (e2) => applyHandler(e2, (event) => {
        this._upDownArrowHandler(1);
        event.preventDefault();
      }),
      downArrow: (e2) => applyHandler(e2, (event) => {
        this._upDownArrowHandler(-1);
        event.preventDefault();
      })
    });
  },
  _shouldUseOriginalHandler(e) {
    const isNotDeletingInCalendar = this.option("opened") && e && !["backspace", "del"].includes(normalizeKeyName(e));
    return !this._useMaskBehavior() || isNotDeletingInCalendar || e && e.altKey;
  },
  _upDownArrowHandler(step) {
    this._setNewDateIfEmpty();
    const originalValue = this._getActivePartValue(this._initialMaskValue);
    const currentValue = this._getActivePartValue();
    const delta = currentValue - originalValue;
    this._loadMaskValue(this._initialMaskValue);
    this._changePartValue(delta + step, true);
  },
  _changePartValue(step, lockOtherParts) {
    const activePartPattern = this._getActivePartProp("pattern");
    const isAmPmPartActive = /^a{1,5}$/.test(activePartPattern);
    if (isAmPmPartActive) {
      this._toggleAmPm();
    } else {
      this._partIncrease(step, lockOtherParts);
    }
  },
  _toggleAmPm() {
    const currentValue = this._getActivePartProp("text");
    const indexOfCurrentValue = default_date_names_default.getPeriodNames().indexOf(currentValue);
    const newValue = 1 ^ indexOfCurrentValue;
    this._setActivePartValue(newValue);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      useMaskBehavior: false,
      emptyDateValue: new Date(2e3, 0, 1, 0, 0, 0)
    });
  },
  _isSingleCharKey(_ref) {
    let {
      originalEvent,
      alt
    } = _ref;
    const key = originalEvent.data || originalEvent.key;
    return "string" === typeof key && 1 === key.length && !alt && !isCommandKeyPressed(originalEvent);
  },
  _isSingleDigitKey(e) {
    var _e$originalEvent;
    const data2 = null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.data;
    return 1 === (null === data2 || void 0 === data2 ? void 0 : data2.length) && parseInt(data2, 10);
  },
  _useBeforeInputEvent: () => devices_default.real().android,
  _keyInputHandler(e, key) {
    const oldInputValue = this._input().val();
    this._processInputKey(key);
    e.preventDefault();
    const isValueChanged = oldInputValue !== this._input().val();
    isValueChanged && events_engine_default.trigger(this._input(), "input");
  },
  _keyboardHandler(e) {
    let {
      key
    } = e.originalEvent;
    const result2 = this.callBase(e);
    if (!this._useMaskBehavior() || this._useBeforeInputEvent()) {
      return result2;
    }
    if (browser_default.chrome && "Process" === e.key && 0 === e.code.indexOf("Digit")) {
      key = e.code.replace("Digit", "");
      this._processInputKey(key);
      this._maskInputHandler = () => {
        this._renderSelectedPart();
      };
    } else if (this._isSingleCharKey(e)) {
      this._keyInputHandler(e.originalEvent, key);
    }
    return result2;
  },
  _maskBeforeInputHandler(e) {
    this._maskInputHandler = null;
    const {
      inputType: inputType2
    } = e.originalEvent;
    if ("insertCompositionText" === inputType2) {
      this._maskInputHandler = () => {
        this._renderSelectedPart();
      };
    }
    const isBackwardDeletion = "deleteContentBackward" === inputType2;
    const isForwardDeletion = "deleteContentForward" === inputType2;
    if (isBackwardDeletion || isForwardDeletion) {
      const direction = isBackwardDeletion ? -1 : 1;
      this._maskInputHandler = () => {
        this._revertPart();
        this._selectNextPart(direction);
      };
    }
    if (!this._useMaskBehavior() || !this._isSingleCharKey(e)) {
      return;
    }
    const key = e.originalEvent.data;
    this._keyInputHandler(e, key);
    return true;
  },
  _keyPressHandler(e) {
    const {
      originalEvent: event
    } = e;
    if ("insertCompositionText" === (null === event || void 0 === event ? void 0 : event.inputType) && this._isSingleDigitKey(e)) {
      this._processInputKey(event.data);
      this._renderDisplayText(this._getDisplayedText(this._maskValue));
      this._selectNextPart();
    }
    this.callBase(e);
    if (this._maskInputHandler) {
      this._maskInputHandler();
      this._maskInputHandler = null;
    }
  },
  _processInputKey(key) {
    if (this._isAllSelected()) {
      this._activePartIndex = 0;
    }
    this._setNewDateIfEmpty();
    if (isNaN(parseInt(key))) {
      this._searchString(key);
    } else {
      this._searchNumber(key);
    }
  },
  _isAllSelected() {
    const caret3 = this._caret();
    return caret3.end - caret3.start === this.option("text").length;
  },
  _getFormatPattern() {
    if (this._formatPattern) {
      return this._formatPattern;
    }
    const format2 = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const isLDMLPattern = isString(format2) && !date_default3._getPatternByFormat(format2);
    if (isLDMLPattern) {
      this._formatPattern = format2;
    } else {
      this._formatPattern = getFormat2((value2) => date_default3.format(value2, format2));
    }
    return this._formatPattern;
  },
  _setNewDateIfEmpty() {
    if (!this._maskValue) {
      const value2 = "time" === this.option("type") ? /* @__PURE__ */ new Date(null) : /* @__PURE__ */ new Date();
      this._maskValue = value2;
      this._initialMaskValue = value2;
      this._renderDateParts();
    }
  },
  _partLimitsReached(max) {
    const maxLimitLength = String(max).length;
    const formatLength = this._getActivePartProp("pattern").length;
    const isShortFormat = 1 === formatLength;
    const maxSearchLength = isShortFormat ? maxLimitLength : Math.min(formatLength, maxLimitLength);
    const isLengthExceeded = this._searchValue.length === maxSearchLength;
    const isValueOverflowed = parseInt(`${this._searchValue}0`) > max;
    return isLengthExceeded || isValueOverflowed;
  },
  _searchNumber(char) {
    const {
      max
    } = this._getActivePartLimits();
    const maxLimitLength = String(max).length;
    this._searchValue = (this._searchValue + char).substr(-maxLimitLength);
    if (isNaN(this._searchValue)) {
      this._searchValue = char;
    }
    this._setActivePartValue(this._searchValue);
    if (this._partLimitsReached(max)) {
      this._selectNextPart(1);
    }
  },
  _searchString(char) {
    if (!isNaN(parseInt(this._getActivePartProp("text")))) {
      return;
    }
    const limits = this._getActivePartProp("limits")(this._maskValue);
    const startString = this._searchValue + char.toLowerCase();
    const endLimit = limits.max - limits.min;
    for (let i = 0; i <= endLimit; i++) {
      this._loadMaskValue(this._initialMaskValue);
      this._changePartValue(i + 1);
      if (0 === this._getActivePartProp("text").toLowerCase().indexOf(startString)) {
        this._searchValue = startString;
        return;
      }
    }
    this._setNewDateIfEmpty();
    if (this._searchValue) {
      this._clearSearchValue();
      this._searchString(char);
    }
  },
  _clearSearchValue() {
    this._searchValue = "";
  },
  _revertPart(direction) {
    if (!this._isAllSelected()) {
      const actual = this._getActivePartValue(this.option("emptyDateValue"));
      this._setActivePartValue(actual);
      this._selectNextPart(direction);
    }
    this._clearSearchValue();
  },
  _useMaskBehavior() {
    return this.option("useMaskBehavior") && "text" === this.option("mode");
  },
  _prepareRegExpInfo() {
    this._regExpInfo = getRegExpInfo(this._getFormatPattern(), date_default3);
    const {
      regexp
    } = this._regExpInfo;
    const {
      source
    } = regexp;
    const {
      flags
    } = regexp;
    const quantifierRegexp = new RegExp(/(\{[0-9]+,?[0-9]*\})/);
    const convertedSource = source.split(quantifierRegexp).map((sourcePart) => quantifierRegexp.test(sourcePart) ? sourcePart : number_default2.convertDigits(sourcePart, false)).join("");
    this._regExpInfo.regexp = new RegExp(convertedSource, flags);
  },
  _initMaskState() {
    this._activePartIndex = 0;
    this._formatPattern = null;
    this._prepareRegExpInfo();
    this._loadMaskValue();
  },
  _renderMask() {
    this.callBase();
    this._detachMaskEvents();
    this._clearMaskState();
    if (this._useMaskBehavior()) {
      this._attachMaskEvents();
      this._initMaskState();
      this._renderDateParts();
    }
  },
  _renderDateParts() {
    if (!this._useMaskBehavior()) {
      return;
    }
    const text = this.option("text") || this._getDisplayedText(this._maskValue);
    if (text) {
      this._dateParts = renderDateParts(text, this._regExpInfo);
      if (!this._input().is(":hidden")) {
        this._selectNextPart();
      }
    }
  },
  _detachMaskEvents() {
    events_engine_default.off(this._input(), ".dateBoxMask");
  },
  _attachMaskEvents() {
    events_engine_default.on(this._input(), addNamespace2("dxclick", "dateBoxMask"), this._maskClickHandler.bind(this));
    events_engine_default.on(this._input(), addNamespace2("paste", "dateBoxMask"), this._maskPasteHandler.bind(this));
    events_engine_default.on(this._input(), addNamespace2("drop", "dateBoxMask"), () => {
      this._renderSelectedPart();
    });
    events_engine_default.on(this._input(), addNamespace2("compositionend", "dateBoxMask"), this._maskCompositionEndHandler.bind(this));
    if (this._useBeforeInputEvent()) {
      events_engine_default.on(this._input(), addNamespace2("beforeinput", "dateBoxMask"), this._maskBeforeInputHandler.bind(this));
    }
  },
  _renderSelectedPart() {
    this._renderDisplayText(this._getDisplayedText(this._maskValue));
    this._selectNextPart();
  },
  _selectLastPart() {
    if (this.option("text")) {
      this._activePartIndex = this._dateParts.length;
      this._selectNextPart(-1);
    }
  },
  _selectFirstPart() {
    if (this.option("text")) {
      this._activePartIndex = -1;
      this._selectNextPart(1);
    }
  },
  _onMouseWheel(e) {
    if (this._useMaskBehavior()) {
      this._partIncrease(e.delta > 0 ? 1 : -1, e);
    }
  },
  _selectNextPart() {
    let step = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    if (!this.option("text") || this._disposed) {
      return;
    }
    if (step) {
      this._initialMaskValue = new Date(this._maskValue);
    }
    let index2 = fitIntoRange(this._activePartIndex + step, 0, this._dateParts.length - 1);
    if (this._dateParts[index2].isStub) {
      const isBoundaryIndex = 0 === index2 && step < 0 || index2 === this._dateParts.length - 1 && step > 0;
      if (!isBoundaryIndex) {
        this._selectNextPart(step >= 0 ? step + 1 : step - 1);
        return;
      }
      index2 = this._activePartIndex;
    }
    if (this._activePartIndex !== index2) {
      this._clearSearchValue();
    }
    this._activePartIndex = index2;
    this._caret(this._getActivePartProp("caret"));
  },
  _getRealLimitsPattern() {
    if ("d" === this._getActivePartProp("pattern")[0]) {
      return "dM";
    }
  },
  _getActivePartLimits(lockOtherParts) {
    const limitFunction = this._getActivePartProp("limits");
    return limitFunction(this._maskValue, lockOtherParts && this._getRealLimitsPattern());
  },
  _getActivePartValue(dateValue) {
    dateValue = dateValue || this._maskValue;
    const getter = this._getActivePartProp("getter");
    return isFunction(getter) ? getter(dateValue) : dateValue[getter]();
  },
  _addLeadingZeroes(value2) {
    const zeroes = this._searchValue.match(/^0+/);
    const limits = this._getActivePartLimits();
    const maxLimitLength = String(limits.max).length;
    return ((zeroes && zeroes[0] || "") + String(value2)).substr(-maxLimitLength);
  },
  _setActivePartValue(value2, dateValue) {
    dateValue = dateValue || this._maskValue;
    const setter = this._getActivePartProp("setter");
    const limits = this._getActivePartLimits();
    value2 = inRange(value2, limits.min, limits.max) ? value2 : value2 % 10;
    value2 = this._addLeadingZeroes(fitIntoRange(value2, limits.min, limits.max));
    isFunction(setter) ? setter(dateValue, value2) : dateValue[setter](value2);
    this._renderDisplayText(this._getDisplayedText(dateValue));
    this._renderDateParts();
  },
  _getActivePartProp(property) {
    if (!this._dateParts || !this._dateParts[this._activePartIndex]) {
      return;
    }
    return this._dateParts[this._activePartIndex][property];
  },
  _loadMaskValue() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.dateOption("value");
    this._maskValue = value2 && new Date(value2);
    this._initialMaskValue = value2 && new Date(value2);
  },
  _saveMaskValue() {
    const value2 = this._maskValue && new Date(this._maskValue);
    if (value2 && "date" === this.option("type")) {
      value2.setHours(0, 0, 0, 0);
    }
    this._initialMaskValue = new Date(value2);
    this.dateOption("value", value2);
  },
  _revertChanges() {
    this._loadMaskValue();
    this._renderDisplayText(this._getDisplayedText(this._maskValue));
    this._renderDateParts();
  },
  _renderDisplayText(text) {
    this.callBase(text);
    if (this._useMaskBehavior()) {
      this.option("text", text);
    }
  },
  _partIncrease(step, lockOtherParts) {
    this._setNewDateIfEmpty();
    const {
      max,
      min
    } = this._getActivePartLimits(lockOtherParts);
    let newValue = step + this._getActivePartValue();
    if (newValue > max) {
      newValue = this._applyLimits(newValue, {
        limitBase: min,
        limitClosest: max,
        max
      });
    } else if (newValue < min) {
      newValue = this._applyLimits(newValue, {
        limitBase: max,
        limitClosest: min,
        max
      });
    }
    this._setActivePartValue(newValue);
  },
  _applyLimits(newValue, _ref2) {
    let {
      limitBase,
      limitClosest,
      max
    } = _ref2;
    const delta = (newValue - limitClosest) % max;
    return delta ? limitBase + delta - 1 * sign(delta) : limitClosest;
  },
  _maskClickHandler() {
    this._loadMaskValue(this._maskValue);
    if (this.option("text")) {
      this._activePartIndex = getDatePartIndexByPosition(this._dateParts, this._caret().start);
      if (!this._isAllSelected()) {
        if (isDefined(this._activePartIndex)) {
          this._caret(this._getActivePartProp("caret"));
        } else {
          this._selectLastPart();
        }
      }
    }
  },
  _maskCompositionEndHandler(e) {
    this._input().val(this._getDisplayedText(this._maskValue));
    this._selectNextPart();
    this._maskInputHandler = () => {
      this._renderSelectedPart();
    };
  },
  _maskPasteHandler(e) {
    const newText = this._replaceSelectedText(this.option("text"), this._caret(), clipboardText(e));
    const date = date_default3.parse(newText, this._getFormatPattern());
    if (date && this._isDateValid(date)) {
      this._maskValue = date;
      this._renderDisplayText(this._getDisplayedText(this._maskValue));
      this._renderDateParts();
      this._selectNextPart();
    }
    e.preventDefault();
  },
  _isDateValid: (date) => isDate(date) && !isNaN(date),
  _isValueDirty() {
    const value2 = this.dateOption("value");
    return (this._maskValue && this._maskValue.getTime()) !== (value2 && value2.getTime());
  },
  _fireChangeEvent() {
    this._clearSearchValue();
    if (this._isValueDirty()) {
      events_engine_default.trigger(this._input(), "change");
    }
  },
  _enterHandler() {
    this._fireChangeEvent();
    this._selectNextPart(1);
  },
  _focusOutHandler(e) {
    const shouldFireChangeEvent = this._useMaskBehavior() && !e.isDefaultPrevented();
    if (shouldFireChangeEvent) {
      this._fireChangeEvent();
      this.callBase(e);
      this._selectFirstPart(e);
    } else {
      this.callBase(e);
    }
  },
  _valueChangeEventHandler(e) {
    const text = this.option("text");
    if (this._useMaskBehavior()) {
      this._saveValueChangeEvent(e);
      if (!text) {
        this._maskValue = null;
      } else if (null === this._maskValue) {
        this._loadMaskValue(text);
      }
      this._saveMaskValue();
    } else {
      this.callBase(e);
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "useMaskBehavior":
        this._renderMask();
        break;
      case "displayFormat":
      case "mode":
        this.callBase(args);
        this._renderMask();
        break;
      case "value":
        this._loadMaskValue();
        this.callBase(args);
        this._renderDateParts();
        break;
      case "emptyDateValue":
        break;
      default:
        this.callBase(args);
    }
  },
  _clearMaskState() {
    this._clearSearchValue();
    delete this._dateParts;
    delete this._activePartIndex;
    delete this._maskValue;
  },
  clear() {
    this._clearMaskState();
    this._activePartIndex = 0;
    this.callBase();
  },
  _clean() {
    this.callBase();
    this._detachMaskEvents();
    this._clearMaskState();
  }
});
var m_date_box_mask_default = DateBoxMask;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.js
component_registrator_default("dxDateBox", m_date_box_mask_default);
var m_date_box_default = m_date_box_mask_default;

// ../../../../../../node_modules/devextreme/esm/ui/date_box.js
var date_box_default = m_date_box_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_responsive_box.js
var SCREEN_SIZE_CLASS_PREFIX = "dx-responsivebox-screen-";
var ResponsiveBox = ui_collection_widget_edit_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      rows: [],
      cols: [],
      screenByWidth: null,
      singleColumnScreen: "",
      height: "100%",
      width: "100%",
      activeStateEnabled: false,
      focusStateEnabled: false,
      onItemStateChanged: void 0,
      onLayoutChanged: null,
      currentScreenFactor: void 0
    });
  },
  _init() {
    if (!this.option("screenByWidth")) {
      this._options.silent("screenByWidth", defaultScreenFactorFunc);
    }
    this.callBase();
    this._initLayoutChangedAction();
  },
  _initLayoutChangedAction() {
    this._layoutChangedAction = this._createActionByOption("onLayoutChanged", {
      excludeValidators: ["disabled", "readonly"]
    });
  },
  _itemClass: () => "dx-box-item",
  _itemDataKey: () => "dxBoxItemData",
  _initMarkup() {
    this.callBase();
    this.$element().addClass("dx-responsivebox");
  },
  _renderItems() {
    this._setScreenSize();
    this._screenItems = this._itemsByScreen();
    this._prepareGrid();
    this._spreadItems();
    this._layoutItems();
    this._linkNodeToItem();
  },
  _itemOptionChanged(item) {
    const $item = this._findItemElementByItem(item);
    if (!$item.length) {
      return;
    }
    this._refreshItem($item, item);
    this._clearItemNodeTemplates();
    this._update(true);
  },
  _setScreenSize() {
    const currentScreen = this._getCurrentScreen();
    this._removeScreenSizeClass();
    this.$element().addClass(SCREEN_SIZE_CLASS_PREFIX + currentScreen);
    this.option("currentScreenFactor", currentScreen);
  },
  _removeScreenSizeClass() {
    const currentScreenFactor = this.option("currentScreenFactor");
    currentScreenFactor && this.$element().removeClass(SCREEN_SIZE_CLASS_PREFIX + currentScreenFactor);
  },
  _prepareGrid() {
    const grid = this._grid = [];
    this._prepareRowsAndCols();
    each(this._rows, () => {
      const row = [];
      grid.push(row);
      each(this._cols, () => {
        row.push(this._createEmptyCell());
      });
    });
  },
  getSingleColumnRows() {
    const rows = this.option("rows");
    const screenItemsLength = this._screenItems.length;
    if (rows.length) {
      const filteredRows = this._filterByScreen(rows);
      const result2 = [];
      for (let i = 0; i < screenItemsLength; i++) {
        const sizeConfig = this._defaultSizeConfig();
        if (i < filteredRows.length && isDefined(filteredRows[i].shrink)) {
          sizeConfig.shrink = filteredRows[i].shrink;
        }
        result2.push(sizeConfig);
      }
      return result2;
    }
    return this._defaultSizeConfig(screenItemsLength);
  },
  _prepareRowsAndCols() {
    if (this._isSingleColumnScreen()) {
      this._prepareSingleColumnScreenItems();
      this._rows = this.getSingleColumnRows();
      this._cols = this._defaultSizeConfig(1);
    } else {
      this._rows = this._sizesByScreen(this.option("rows"));
      this._cols = this._sizesByScreen(this.option("cols"));
    }
  },
  _isSingleColumnScreen() {
    return this._screenRegExp().test(this.option("singleColumnScreen")) || !this.option("rows").length || !this.option("cols").length;
  },
  _prepareSingleColumnScreenItems() {
    this._screenItems.sort((item1, item2) => item1.location.row - item2.location.row || item1.location.col - item2.location.col);
    each(this._screenItems, (index2, item) => {
      extend(item.location, {
        row: index2,
        col: 0,
        rowspan: 1,
        colspan: 1
      });
    });
  },
  _sizesByScreen(sizeConfigs) {
    return map(this._filterByScreen(sizeConfigs), (sizeConfig) => extend(this._defaultSizeConfig(), sizeConfig));
  },
  _createDefaultSizeConfig: () => ({
    ratio: 1,
    baseSize: 0,
    minSize: 0,
    maxSize: 0
  }),
  _defaultSizeConfig(size) {
    const defaultSizeConfig = this._createDefaultSizeConfig();
    if (!arguments.length) {
      return defaultSizeConfig;
    }
    const result2 = [];
    for (let i = 0; i < size; i++) {
      result2.push(defaultSizeConfig);
    }
    return result2;
  },
  _filterByScreen(items) {
    const screenRegExp = this._screenRegExp();
    return grep(items, (item) => !item.screen || screenRegExp.test(item.screen));
  },
  _screenRegExp() {
    const screen = this._getCurrentScreen();
    return new RegExp(`(^|\\s)${screen}($|\\s)`, "i");
  },
  _getCurrentScreen() {
    const width = this._screenWidth();
    return this.option("screenByWidth")(width);
  },
  _screenWidth: () => hasWindow() ? getWidth(getWindow()) : 1920,
  _createEmptyCell: () => ({
    item: {},
    location: {
      colspan: 1,
      rowspan: 1
    }
  }),
  _spreadItems() {
    each(this._screenItems, (_, itemInfo) => {
      const location = itemInfo.location || {};
      const itemCol = location.col;
      const itemRow = location.row;
      const row = this._grid[itemRow];
      const itemCell = row && row[itemCol];
      this._occupyCells(itemCell, itemInfo);
    });
  },
  _itemsByScreen() {
    return this.option("items").reduce((result2, item) => {
      let locations = item.location || {};
      locations = isPlainObject(locations) ? [locations] : locations;
      this._filterByScreen(locations).forEach((location) => {
        result2.push({
          item,
          location: extend({
            rowspan: 1,
            colspan: 1
          }, location)
        });
      });
      return result2;
    }, []);
  },
  _occupyCells(itemCell, itemInfo) {
    if (!itemCell || this._isItemCellOccupied(itemCell, itemInfo)) {
      return;
    }
    extend(itemCell, itemInfo);
    this._markSpanningCell(itemCell);
  },
  _isItemCellOccupied(itemCell, itemInfo) {
    if (!isEmptyObject(itemCell.item)) {
      return true;
    }
    let result2 = false;
    this._loopOverSpanning(itemInfo.location, (cell) => {
      result2 = result2 || !isEmptyObject(cell.item);
    });
    return result2;
  },
  _loopOverSpanning(location, callback) {
    const rowEnd = location.row + location.rowspan - 1;
    const colEnd = location.col + location.colspan - 1;
    const boundRowEnd = Math.min(rowEnd, this._rows.length - 1);
    const boundColEnd = Math.min(colEnd, this._cols.length - 1);
    location.rowspan -= rowEnd - boundRowEnd;
    location.colspan -= colEnd - boundColEnd;
    for (let rowIndex = location.row; rowIndex <= boundRowEnd; rowIndex++) {
      for (let colIndex = location.col; colIndex <= boundColEnd; colIndex++) {
        if (rowIndex !== location.row || colIndex !== location.col) {
          callback(this._grid[rowIndex][colIndex]);
        }
      }
    }
  },
  _markSpanningCell(itemCell) {
    this._loopOverSpanning(itemCell.location, (cell) => {
      extend(cell, {
        item: itemCell.item,
        spanningCell: itemCell
      });
    });
  },
  _linkNodeToItem() {
    each(this._itemElements(), (_, itemNode) => {
      const $item = renderer_default(itemNode);
      const item = $item.data("dxBoxItemData");
      if (!item.box) {
        item.node = $item.children();
      }
    });
  },
  _layoutItems() {
    const rowsCount = this._grid.length;
    const colsCount = rowsCount && this._grid[0].length;
    if (!rowsCount && !colsCount) {
      return;
    }
    const result2 = this._layoutBlock({
      direction: "col",
      row: {
        start: 0,
        end: rowsCount - 1
      },
      col: {
        start: 0,
        end: colsCount - 1
      }
    });
    const rootBox = this._prepareBoxConfig(result2.box || {
      direction: "row",
      items: [extend(result2, {
        ratio: 1
      })]
    });
    extend(rootBox, this._rootBoxConfig(rootBox.items));
    this._$root = renderer_default("<div>").appendTo(this._itemContainer());
    this._createComponent(this._$root, box_default, rootBox);
  },
  _rootBoxConfig(items) {
    const rootItems = each(items, (index2, item) => {
      this._needApplyAutoBaseSize(item) && extend(item, {
        baseSize: "auto"
      });
    });
    return {
      width: "100%",
      height: "100%",
      items: rootItems,
      itemTemplate: this._getTemplateByOption("itemTemplate"),
      itemHoldTimeout: this.option("itemHoldTimeout"),
      onItemHold: this._createActionByOption("onItemHold"),
      onItemClick: this._createActionByOption("onItemClick"),
      onItemContextMenu: this._createActionByOption("onItemContextMenu"),
      onItemRendered: this._createActionByOption("onItemRendered")
    };
  },
  _needApplyAutoBaseSize: (item) => !item.baseSize && (!item.minSize || "auto" === item.minSize) && (!item.maxSize || "auto" === item.maxSize),
  _prepareBoxConfig(config3) {
    return extend(config3 || {}, {
      crossAlign: "stretch",
      onItemStateChanged: this.option("onItemStateChanged")
    });
  },
  _layoutBlock(options2) {
    if (this._isSingleItem(options2)) {
      return this._itemByCell(options2.row.start, options2.col.start);
    }
    return this._layoutDirection(options2);
  },
  _isSingleItem(options2) {
    const firstCellLocation = this._grid[options2.row.start][options2.col.start].location;
    const isItemRowSpanned = options2.row.end - options2.row.start === firstCellLocation.rowspan - 1;
    const isItemColSpanned = options2.col.end - options2.col.start === firstCellLocation.colspan - 1;
    return isItemRowSpanned && isItemColSpanned;
  },
  _itemByCell(rowIndex, colIndex) {
    const itemCell = this._grid[rowIndex][colIndex];
    return itemCell.spanningCell ? null : itemCell.item;
  },
  _layoutDirection(options2) {
    const items = [];
    const {
      direction
    } = options2;
    const crossDirection = this._crossDirection(direction);
    let block;
    while (block = this._nextBlock(options2)) {
      if (this._isBlockIndivisible(options2.prevBlockOptions, block)) {
        throw ui_errors_default.Error("E1025");
      }
      const item = this._layoutBlock({
        direction: crossDirection,
        row: block.row,
        col: block.col,
        prevBlockOptions: options2
      });
      if (item) {
        extend(item, this._blockSize(block, crossDirection));
        items.push(item);
      }
      options2[crossDirection].start = block[crossDirection].end + 1;
    }
    return {
      box: this._prepareBoxConfig({
        direction,
        items
      })
    };
  },
  _isBlockIndivisible: (options2, block) => options2 && options2.col.start === block.col.start && options2.col.end === block.col.end && options2.row.start === block.row.start && options2.row.end === block.row.end,
  _crossDirection: (direction) => "col" === direction ? "row" : "col",
  _nextBlock(options2) {
    const {
      direction
    } = options2;
    const crossDirection = this._crossDirection(direction);
    const startIndex = options2[direction].start;
    const endIndex = options2[direction].end;
    const crossStartIndex = options2[crossDirection].start;
    if (crossStartIndex > options2[crossDirection].end) {
      return null;
    }
    let crossSpan = 1;
    for (let crossIndex = crossStartIndex; crossIndex < crossStartIndex + crossSpan; crossIndex++) {
      let lineCrossSpan = 1;
      for (let index2 = startIndex; index2 <= endIndex; index2++) {
        const cell = this._cellByDirection(direction, index2, crossIndex);
        lineCrossSpan = Math.max(lineCrossSpan, cell.location[`${crossDirection}span`]);
      }
      const lineCrossEndIndex = crossIndex + lineCrossSpan;
      const crossEndIndex = crossStartIndex + crossSpan;
      if (lineCrossEndIndex > crossEndIndex) {
        crossSpan += lineCrossEndIndex - crossEndIndex;
      }
    }
    const result2 = {};
    result2[direction] = {
      start: startIndex,
      end: endIndex
    };
    result2[crossDirection] = {
      start: crossStartIndex,
      end: crossStartIndex + crossSpan - 1
    };
    return result2;
  },
  _cellByDirection(direction, index2, crossIndex) {
    return "col" === direction ? this._grid[crossIndex][index2] : this._grid[index2][crossIndex];
  },
  _blockSize(block, direction) {
    const defaultMinSize = "row" === direction ? "auto" : 0;
    const sizeConfigs = "row" === direction ? this._rows : this._cols;
    const result2 = extend(this._createDefaultSizeConfig(), {
      ratio: 0
    });
    for (let index2 = block[direction].start; index2 <= block[direction].end; index2++) {
      const sizeConfig = sizeConfigs[index2];
      result2.ratio += sizeConfig.ratio;
      result2.baseSize += sizeConfig.baseSize;
      result2.minSize += sizeConfig.minSize;
      result2.maxSize += sizeConfig.maxSize;
      if (isDefined(sizeConfig.shrink)) {
        result2.shrink = sizeConfig.shrink;
      }
    }
    result2.minSize = result2.minSize ? result2.minSize : defaultMinSize;
    result2.maxSize = result2.maxSize ? result2.maxSize : "auto";
    this._isSingleColumnScreen() && (result2.baseSize = "auto");
    return result2;
  },
  _update(forceRemoveRoot) {
    const $existingRoot = this._$root;
    this._renderItems();
    if ($existingRoot) {
      if (forceRemoveRoot) {
        $existingRoot.remove();
      } else {
        $existingRoot.detach();
        this._saveAssistantRoot($existingRoot);
      }
    }
    this._layoutChangedAction();
  },
  _saveAssistantRoot($root) {
    this._assistantRoots = this._assistantRoots || [];
    this._assistantRoots.push($root);
  },
  _dispose() {
    this._clearItemNodeTemplates();
    this._cleanUnusedRoots();
    this.callBase.apply(this, arguments);
  },
  _cleanUnusedRoots() {
    if (!this._assistantRoots) {
      return;
    }
    each(this._assistantRoots, (_, item) => {
      renderer_default(item).remove();
    });
  },
  _clearItemNodeTemplates() {
    each(this.option("items"), function() {
      delete this.node;
    });
  },
  _attachClickEvent: noop2,
  _optionChanged(args) {
    switch (args.name) {
      case "rows":
      case "cols":
      case "screenByWidth":
      case "singleColumnScreen":
        this._clearItemNodeTemplates();
        this._invalidate();
        break;
      case "width":
      case "height":
        this.callBase(args);
        this._update();
        break;
      case "onLayoutChanged":
        this._initLayoutChangedAction();
        break;
      case "itemTemplate":
        this._clearItemNodeTemplates();
        this.callBase(args);
        break;
      case "currentScreenFactor":
        break;
      default:
        this.callBase(args);
    }
  },
  _dimensionChanged() {
    if (this._getCurrentScreen() !== this.option("currentScreenFactor")) {
      this._update();
    }
  },
  repaint() {
    this._update();
  }
});
component_registrator_default("dxResponsiveBox", ResponsiveBox);
var m_responsive_box_default = ResponsiveBox;

// ../../../../../../node_modules/devextreme/esm/ui/responsive_box.js
var responsive_box_default = m_responsive_box_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/components/m_button_item.js
function renderButtonItem(_ref) {
  let {
    item,
    $parent,
    rootElementCssClassList,
    validationGroup,
    createComponentCallback
  } = _ref;
  const $rootElement = renderer_default("<div>").appendTo($parent).addClass(rootElementCssClassList.join(" ")).addClass("dx-field-button-item").css("textAlign", convertAlignmentToTextAlign(item.horizontalAlignment));
  $parent.css("justifyContent", convertAlignmentToJustifyContent(item.verticalAlignment));
  const $button = renderer_default("<div>").appendTo($rootElement);
  return {
    $rootElement,
    buttonInstance: createComponentCallback($button, "dxButton", extend({
      validationGroup
    }, item.buttonOptions))
  };
}
function convertAlignmentToTextAlign(horizontalAlignment) {
  return isDefined(horizontalAlignment) ? horizontalAlignment : "right";
}
function convertAlignmentToJustifyContent(verticalAlignment) {
  switch (verticalAlignment) {
    case "center":
      return "center";
    case "bottom":
      return "flex-end";
    default:
      return "flex-start";
  }
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/components/m_empty_item.js
function renderEmptyItem(_ref) {
  let {
    $parent,
    rootElementCssClassList
  } = _ref;
  return renderer_default("<div>").addClass("dx-field-empty-item").html("&nbsp;").addClass(rootElementCssClassList.join(" ")).appendTo($parent);
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/validation/m_default_adapter.js
var DefaultAdapter = class_default.inherit({
  ctor(editor, validator) {
    this.editor = editor;
    this.validator = validator;
    this.validationRequestsCallbacks = [];
    const handler = (args) => {
      this.validationRequestsCallbacks.forEach((item) => item(args));
    };
    editor.validationRequest.add(handler);
    editor.on("disposing", () => {
      editor.validationRequest.remove(handler);
    });
  },
  getValue() {
    return this.editor.option("value");
  },
  getCurrentValidationError() {
    return this.editor.option("validationError");
  },
  bypass() {
    return this.editor.option("disabled");
  },
  applyValidationResults(params) {
    this.editor.option({
      validationErrors: params.brokenRules,
      validationStatus: params.status
    });
  },
  reset() {
    this.editor.clear();
  },
  focus() {
    this.editor.focus();
  }
});
var m_default_adapter_default = DefaultAdapter;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_validator.js
var Validator = dom_component_default.inherit({
  _initOptions(options2) {
    this.callBase.apply(this, arguments);
    this.option(m_validation_engine_default.initValidationOptions(options2));
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      validationRules: []
    });
  },
  _init() {
    this.callBase();
    this._initGroupRegistration();
    this.focused = callbacks_default();
    this._initAdapter();
    this._validationInfo = {
      result: null,
      deferred: null,
      skipValidation: false
    };
  },
  _initGroupRegistration() {
    const group = this._findGroup();
    if (!this._groupWasInit) {
      this.on("disposing", (args) => {
        m_validation_engine_default.removeRegisteredValidator(args.component._validationGroup, args.component);
      });
    }
    if (!this._groupWasInit || this._validationGroup !== group) {
      m_validation_engine_default.removeRegisteredValidator(this._validationGroup, this);
      this._groupWasInit = true;
      this._validationGroup = group;
      m_validation_engine_default.registerValidatorInGroup(group, this);
    }
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      validationGroup: true
    });
  },
  _getEditor() {
    const element = this.$element()[0];
    return data(element, "dx-validation-target");
  },
  _initAdapter() {
    const dxStandardEditor = this._getEditor();
    let adapter = this.option("adapter");
    if (!adapter) {
      if (dxStandardEditor) {
        adapter = new m_default_adapter_default(dxStandardEditor, this);
        adapter.validationRequestsCallbacks.push((args) => {
          if (this._validationInfo.skipValidation) {
            return;
          }
          this.validate(args);
        });
        this.option("adapter", adapter);
        return;
      }
      throw ui_errors_default.Error("E0120");
    }
    const callbacks2 = adapter.validationRequestsCallbacks;
    if (callbacks2) {
      callbacks2.push((args) => {
        this.validate(args);
      });
    }
  },
  _toggleRTLDirection(isRtl) {
    var _this$option;
    const rtlEnabled = (null === (_this$option = this.option("adapter")) || void 0 === _this$option || null === (_this$option = _this$option.editor) || void 0 === _this$option ? void 0 : _this$option.option("rtlEnabled")) ?? isRtl;
    this.callBase(rtlEnabled);
  },
  _initMarkup() {
    this.$element().addClass("dx-validator");
    this.callBase();
  },
  _render() {
    this.callBase();
    this._toggleAccessibilityAttributes();
  },
  _toggleAccessibilityAttributes() {
    const dxStandardEditor = this._getEditor();
    if (dxStandardEditor) {
      const rules = this.option("validationRules") || [];
      const isRequired = rules.some((_ref) => {
        let {
          type: type2
        } = _ref;
        return "required" === type2;
      }) || null;
      if (dxStandardEditor.isInitialized()) {
        dxStandardEditor.setAria("required", isRequired);
      }
      dxStandardEditor.option("_onMarkupRendered", () => {
        dxStandardEditor.setAria("required", isRequired);
      });
    }
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._initGroupRegistration();
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "validationGroup":
        this._initGroupRegistration();
        return;
      case "validationRules":
        this._resetValidationRules();
        this._toggleAccessibilityAttributes();
        void 0 !== this.option("isValid") && this.validate();
        return;
      case "adapter":
        this._initAdapter();
        break;
      case "isValid":
      case "validationStatus":
        this.option(m_validation_engine_default.synchronizeValidationOptions(args, this.option()));
        break;
      default:
        this.callBase(args);
    }
  },
  _getValidationRules() {
    if (!this._validationRules) {
      this._validationRules = map(this.option("validationRules"), (rule, index2) => extend({}, rule, {
        validator: this,
        index: index2
      }));
    }
    return this._validationRules;
  },
  _findGroup() {
    const $element = this.$element();
    return this.option("validationGroup") || m_validation_engine_default.findGroup($element, this._modelByElement($element));
  },
  _resetValidationRules() {
    delete this._validationRules;
  },
  validate(args) {
    const adapter = this.option("adapter");
    const name2 = this.option("name");
    const bypass = adapter.bypass && adapter.bypass();
    const value2 = args && void 0 !== args.value ? args.value : adapter.getValue();
    const currentError = adapter.getCurrentValidationError && adapter.getCurrentValidationError();
    const rules = this._getValidationRules();
    const currentResult = this._validationInfo && this._validationInfo.result;
    if (currentResult && "pending" === currentResult.status && currentResult.value === value2) {
      return extend({}, currentResult);
    }
    let result2;
    if (bypass) {
      result2 = {
        isValid: true,
        status: "valid"
      };
    } else if (currentError && currentError.editorSpecific) {
      currentError.validator = this;
      result2 = {
        isValid: false,
        status: "invalid",
        brokenRule: currentError,
        brokenRules: [currentError]
      };
    } else {
      result2 = m_validation_engine_default.validate(value2, rules, name2);
    }
    result2.id = new guid_default().toString();
    this._applyValidationResult(result2, adapter);
    result2.complete && result2.complete.then((res) => {
      if (res.id === this._validationInfo.result.id) {
        this._applyValidationResult(res, adapter);
      }
    });
    return extend({}, this._validationInfo.result);
  },
  reset() {
    const adapter = this.option("adapter");
    const result2 = {
      id: null,
      isValid: true,
      brokenRule: null,
      brokenRules: null,
      pendingRules: null,
      status: "valid",
      complete: null
    };
    this._validationInfo.skipValidation = true;
    adapter.reset();
    this._validationInfo.skipValidation = false;
    this._resetValidationRules();
    this._applyValidationResult(result2, adapter);
  },
  _updateValidationResult(result2) {
    if (!this._validationInfo.result || this._validationInfo.result.id !== result2.id) {
      const complete = this._validationInfo.deferred && this._validationInfo.result.complete;
      this._validationInfo.result = extend({}, result2, {
        complete
      });
    } else {
      for (const prop in result2) {
        if ("id" !== prop && "complete" !== prop) {
          this._validationInfo.result[prop] = result2[prop];
        }
      }
    }
  },
  _applyValidationResult(result2, adapter) {
    const validatedAction = this._createActionByOption("onValidated", {
      excludeValidators: ["readOnly"]
    });
    result2.validator = this;
    this._updateValidationResult(result2);
    adapter.applyValidationResults && adapter.applyValidationResults(this._validationInfo.result);
    this.option({
      validationStatus: this._validationInfo.result.status
    });
    if ("pending" === this._validationInfo.result.status) {
      if (!this._validationInfo.deferred) {
        this._validationInfo.deferred = Deferred();
        this._validationInfo.result.complete = this._validationInfo.deferred.promise();
      }
      this._eventsStrategy.fireEvent("validating", [this._validationInfo.result]);
      return;
    }
    if ("pending" !== this._validationInfo.result.status) {
      validatedAction(result2);
      if (this._validationInfo.deferred) {
        this._validationInfo.deferred.resolve(result2);
        this._validationInfo.deferred = null;
      }
    }
  },
  focus() {
    const adapter = this.option("adapter");
    adapter && adapter.focus && adapter.focus();
  },
  _useTemplates: () => false
});
component_registrator_default("dxValidator", Validator);
var m_validator_default = Validator;

// ../../../../../../node_modules/devextreme/esm/ui/validator.js
var validator_default = m_validator_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/constants.js
var FORM_CLASS = "dx-form";
var FORM_GROUP_CLASS = "dx-form-group";
var FORM_GROUP_CAPTION_CLASS = "dx-form-group-caption";
var FORM_GROUP_CUSTOM_CAPTION_CLASS = "dx-form-group-custom-caption";
var FORM_FIELD_ITEM_COL_CLASS = "dx-col-";
var FIELD_ITEM_CLASS = "dx-field-item";
var LAYOUT_MANAGER_ONE_COLUMN = "dx-layout-manager-one-col";
var FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content";
var FORM_LAYOUT_MANAGER_CLASS = "dx-layout-manager";
var FIELD_ITEM_LABEL_CLASS = "dx-field-item-label";
var FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content";
var SINGLE_COLUMN_ITEM_CONTENT = "dx-single-column-item-content";
var ROOT_SIMPLE_ITEM_CLASS = "dx-root-simple-item";
var FORM_GROUP_CONTENT_CLASS = "dx-form-group-content";
var FIELD_ITEM_CONTENT_HAS_GROUP_CLASS = "dx-field-item-has-group";
var FIELD_ITEM_CONTENT_HAS_TABS_CLASS = "dx-field-item-has-tabs";
var FORM_GROUP_WITH_CAPTION_CLASS = "dx-form-group-with-caption";
var FIELD_ITEM_TAB_CLASS = "dx-field-item-tab";
var GROUP_COL_COUNT_CLASS = "dx-group-colcount-";
var GROUP_COL_COUNT_ATTR = "group-col-count";
var FORM_VALIDATION_SUMMARY = "dx-form-validation-summary";
var FORM_UNDERLINED_CLASS = "dx-form-styling-mode-underlined";
var SIMPLE_ITEM_TYPE = "simple";

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.layout_manager.utils.js
var EDITORS_WITH_ARRAY_VALUE = ["dxTagBox", "dxRangeSlider", "dxDateRangeBox"];
var EDITORS_WITH_SPECIFIC_LABELS = ["dxRangeSlider", "dxSlider"];
var EDITORS_WITHOUT_LABELS = ["dxCalendar", "dxCheckBox", "dxHtmlEditor", "dxRadioGroup", "dxRangeSlider", "dxSlider", "dxSwitch"];
function convertToRenderFieldItemOptions(_ref) {
  let {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    item,
    template,
    labelTemplate,
    name: name2,
    formLabelLocation,
    requiredMessageTemplate,
    validationGroup,
    editorValue,
    canAssignUndefinedValueToEditor,
    editorValidationBoundary,
    editorStylingMode,
    showColonAfterLabel,
    managerLabelLocation,
    itemId,
    managerMarkOptions,
    labelMode,
    onLabelTemplateRendered
  } = _ref;
  const isRequired = isDefined(item.isRequired) ? item.isRequired : !!_hasRequiredRuleInSet(item.validationRules);
  const isSimpleItem = item.itemType === SIMPLE_ITEM_TYPE;
  const helpID = item.helpText ? `dx-${new guid_default()}` : null;
  const labelOptions = _convertToLabelOptions({
    item,
    id: itemId,
    isRequired,
    managerMarkOptions,
    showColonAfterLabel,
    labelLocation: managerLabelLocation,
    formLabelMode: labelMode,
    labelTemplate,
    onLabelTemplateRendered
  });
  const needRenderLabel = labelOptions.visible && (labelOptions.text || labelOptions.labelTemplate && isSimpleItem);
  const {
    location: labelLocation,
    labelID
  } = labelOptions;
  const labelNeedBaselineAlign = "top" !== labelLocation && ["dxTextArea", "dxRadioGroup", "dxCalendar", "dxHtmlEditor"].includes(item.editorType);
  const editorOptions = _convertToEditorOptions({
    editorType: item.editorType,
    editorValue,
    defaultEditorName: item.dataField,
    canAssignUndefinedValueToEditor,
    externalEditorOptions: item.editorOptions,
    editorInputId: itemId,
    editorValidationBoundary,
    editorStylingMode,
    formLabelMode: labelMode,
    labelText: labelOptions.textWithoutColon,
    labelMark: labelOptions.markOptions.showRequiredMark ? String.fromCharCode(160) + labelOptions.markOptions.requiredMark : ""
  });
  const needRenderOptionalMarkAsHelpText = labelOptions.markOptions.showOptionalMark && !labelOptions.visible && "hidden" !== editorOptions.labelMode && !isDefined(item.helpText);
  const helpText = needRenderOptionalMarkAsHelpText ? labelOptions.markOptions.optionalMark : item.helpText;
  return {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    labelOptions,
    labelNeedBaselineAlign,
    labelLocation,
    needRenderLabel,
    item,
    isSimpleItem,
    isRequired,
    template,
    helpID,
    labelID,
    name: name2,
    helpText,
    formLabelLocation,
    requiredMessageTemplate,
    validationGroup,
    editorOptions
  };
}
function getLabelMarkText(_ref2) {
  let {
    showRequiredMark,
    requiredMark,
    showOptionalMark,
    optionalMark
  } = _ref2;
  if (!showRequiredMark && !showOptionalMark) {
    return "";
  }
  return String.fromCharCode(160) + (showRequiredMark ? requiredMark : optionalMark);
}
function convertToLabelMarkOptions(_ref3, isRequired) {
  let {
    showRequiredMark,
    requiredMark,
    showOptionalMark,
    optionalMark
  } = _ref3;
  return {
    showRequiredMark: showRequiredMark && isRequired,
    requiredMark,
    showOptionalMark: showOptionalMark && !isRequired,
    optionalMark
  };
}
function _convertToEditorOptions(_ref4) {
  let {
    editorType,
    defaultEditorName,
    editorValue,
    canAssignUndefinedValueToEditor,
    externalEditorOptions,
    editorInputId,
    editorValidationBoundary,
    editorStylingMode,
    formLabelMode,
    labelText,
    labelMark
  } = _ref4;
  const editorOptionsWithValue = {};
  if (void 0 !== editorValue || canAssignUndefinedValueToEditor) {
    editorOptionsWithValue.value = editorValue;
  }
  if (EDITORS_WITH_ARRAY_VALUE.includes(editorType)) {
    editorOptionsWithValue.value = editorOptionsWithValue.value || [];
  }
  let labelMode = null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.labelMode;
  if (!isDefined(labelMode)) {
    labelMode = "outside" === formLabelMode ? "hidden" : formLabelMode;
  }
  const stylingMode = (null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.stylingMode) || editorStylingMode;
  const useSpecificLabelOptions = EDITORS_WITH_SPECIFIC_LABELS.includes(editorType);
  const result2 = extend(true, editorOptionsWithValue, externalEditorOptions, {
    inputAttr: {
      id: editorInputId
    },
    validationBoundary: editorValidationBoundary,
    stylingMode,
    label: useSpecificLabelOptions ? null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.label : labelText,
    labelMode,
    labelMark
  });
  if (externalEditorOptions) {
    if (result2.dataSource) {
      result2.dataSource = externalEditorOptions.dataSource;
    }
    if (result2.items) {
      result2.items = externalEditorOptions.items;
    }
  }
  if (defaultEditorName && !result2.name) {
    result2.name = defaultEditorName;
  }
  return result2;
}
function _hasRequiredRuleInSet(rules) {
  let hasRequiredRule;
  if (rules && rules.length) {
    each(rules, (index2, rule) => {
      if ("required" === rule.type) {
        hasRequiredRule = true;
        return false;
      }
    });
  }
  return hasRequiredRule;
}
function _convertToLabelOptions(_ref5) {
  let {
    item,
    id,
    isRequired,
    managerMarkOptions,
    showColonAfterLabel,
    labelLocation,
    labelTemplate,
    formLabelMode,
    onLabelTemplateRendered
  } = _ref5;
  const isEditorWithoutLabels = EDITORS_WITHOUT_LABELS.includes(item.editorType);
  const labelOptions = extend({
    showColon: showColonAfterLabel,
    location: labelLocation,
    id,
    visible: "outside" === formLabelMode || isEditorWithoutLabels && "hidden" !== formLabelMode,
    isRequired
  }, item ? item.label : {}, {
    markOptions: convertToLabelMarkOptions(managerMarkOptions, isRequired),
    labelTemplate,
    onLabelTemplateRendered
  });
  if (["dxRadioGroup", "dxCheckBox", "dxLookup", "dxSlider", "dxRangeSlider", "dxSwitch", "dxHtmlEditor", "dxDateRangeBox"].includes(item.editorType)) {
    labelOptions.labelID = `dx-label-${new guid_default()}`;
  }
  if (!labelOptions.text && item.dataField) {
    labelOptions.text = captionize(item.dataField);
  }
  if (labelOptions.text) {
    labelOptions.textWithoutColon = labelOptions.text;
    labelOptions.text += labelOptions.showColon ? ":" : "";
  }
  return labelOptions;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/components/m_label.js
var FIELD_ITEM_REQUIRED_MARK_CLASS = "dx-field-item-required-mark";
var FIELD_ITEM_OPTIONAL_MARK_CLASS = "dx-field-item-optional-mark";
function renderLabel(_ref) {
  let {
    text,
    id,
    location,
    alignment,
    labelID = null,
    markOptions = {},
    labelTemplate,
    labelTemplateData,
    onLabelTemplateRendered
  } = _ref;
  if ((!isDefined(text) || text.length <= 0) && !isDefined(labelTemplate)) {
    return null;
  }
  const $label = renderer_default("<label>").addClass(`${FIELD_ITEM_LABEL_CLASS} dx-field-item-label-location-${location}`).attr("for", id).attr("id", labelID).css("textAlign", alignment);
  const $labelContainer = renderer_default("<span>").addClass(FIELD_ITEM_LABEL_CONTENT_CLASS);
  let $labelContent = renderer_default("<span>").addClass("dx-field-item-label-text").text(text);
  if (labelTemplate) {
    $labelContent = renderer_default("<div>").addClass("dx-field-item-custom-label-content");
    labelTemplateData.text = text;
    labelTemplate.render({
      container: getPublicElement($labelContent),
      model: labelTemplateData,
      onRendered() {
        null === onLabelTemplateRendered || void 0 === onLabelTemplateRendered || onLabelTemplateRendered();
      }
    });
  }
  return $label.append($labelContainer.append($labelContent, _renderLabelMark(markOptions)));
}
function _renderLabelMark(markOptions) {
  const markText = getLabelMarkText(markOptions);
  if ("" === markText) {
    return null;
  }
  return renderer_default("<span>").addClass(markOptions.showRequiredMark ? FIELD_ITEM_REQUIRED_MARK_CLASS : FIELD_ITEM_OPTIONAL_MARK_CLASS).text(markText);
}
function setLabelWidthByMaxLabelWidth($targetContainer, labelsSelector, labelMarkOptions) {
  const FIELD_ITEM_LABEL_CONTENT_CLASS_Selector = `${labelsSelector} > .${FIELD_ITEM_LABEL_CLASS}:not(.dx-field-item-label-location-top) > .${FIELD_ITEM_LABEL_CONTENT_CLASS}`;
  const $FIELD_ITEM_LABEL_CONTENT_CLASS_Items = $targetContainer.find(FIELD_ITEM_LABEL_CONTENT_CLASS_Selector);
  const FIELD_ITEM_LABEL_CONTENT_CLASS_Length = $FIELD_ITEM_LABEL_CONTENT_CLASS_Items.length;
  let labelWidth;
  let i;
  let maxWidth = 0;
  for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
    labelWidth = getLabelWidthByHTML($FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i]);
    if (labelWidth > maxWidth) {
      maxWidth = labelWidth;
    }
  }
  for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
    $FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i].style.width = `${maxWidth}px`;
  }
}
function getLabelWidthByHTML(labelContent) {
  let result2 = 0;
  const itemsCount = labelContent.children.length;
  for (let i = 0; i < itemsCount; i++) {
    const child = labelContent.children[i];
    result2 += child.offsetWidth;
  }
  return result2;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/components/m_field_item.js
var FIELD_ITEM_CONTENT_WRAPPER_CLASS = "dx-field-item-content-wrapper";
var TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var VALIDATION_TARGET_CLASS = "dx-validation-target";
var INVALID_CLASS = "dx-invalid";
function renderFieldItem(_ref) {
  let {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    labelOptions,
    labelNeedBaselineAlign,
    labelLocation,
    needRenderLabel,
    formLabelLocation,
    item,
    editorOptions,
    isSimpleItem,
    isRequired,
    template,
    helpID,
    labelID,
    name: name2,
    helpText,
    requiredMessageTemplate,
    validationGroup
  } = _ref;
  const $rootElement = renderer_default("<div>").addClass(rootElementCssClassList.join(" ")).appendTo($parent);
  $rootElement.addClass(isRequired ? "dx-field-item-required" : "dx-field-item-optional");
  if (isSimpleItem) {
    $rootElement.addClass("dx-flex-layout");
  }
  if (isSimpleItem && labelNeedBaselineAlign) {
    $rootElement.addClass("dx-field-item-label-align");
  }
  const $fieldEditorContainer = renderer_default("<div>");
  $fieldEditorContainer.data("dx-form-item", item);
  $fieldEditorContainer.addClass(FIELD_ITEM_CONTENT_CLASS).addClass("dx-field-item-content-location-" + {
    right: "left",
    left: "right",
    top: "bottom"
  }[formLabelLocation]);
  let $label = null;
  if (needRenderLabel) {
    if (labelOptions.labelTemplate) {
      labelOptions.labelTemplateData = getTemplateData(item, editorOptions, formOrLayoutManager);
    }
    $label = renderLabel(labelOptions);
  }
  if ($label) {
    const {
      editorType
    } = item;
    $rootElement.append($label);
    if ("top" === labelLocation || "left" === labelLocation) {
      $rootElement.append($fieldEditorContainer);
    }
    if ("right" === labelLocation) {
      $rootElement.prepend($fieldEditorContainer);
    }
    if ("top" === labelLocation) {
      $rootElement.addClass("dx-label-v-align");
    } else {
      $rootElement.addClass("dx-label-h-align");
    }
    if ("dxCheckBox" === editorType || "dxSwitch" === editorType) {
      events_engine_default.on($label, CLICK_EVENT_NAME, () => {
        events_engine_default.trigger($fieldEditorContainer.children(), CLICK_EVENT_NAME);
      });
    }
    const toggleControls = ["dxCheckBox", "dxSwitch", "dxRadioGroup"];
    const isToggleControls = toggleControls.includes(editorType);
    const labelAlignment = labelOptions.alignment;
    const isLabelAlignmentLeft = "left" === labelAlignment || !labelAlignment;
    const hasNotTemplate = !template;
    const isLabelOnTop = "top" === labelLocation;
    if (hasNotTemplate && isToggleControls && isLabelOnTop && isLabelAlignmentLeft) {
      $fieldEditorContainer.addClass("dx-toggle-controls-paddings");
    }
  } else {
    $rootElement.append($fieldEditorContainer);
  }
  let widgetInstance;
  if (template) {
    template.render({
      container: getPublicElement($fieldEditorContainer),
      model: getTemplateData(item, editorOptions, formOrLayoutManager),
      onRendered() {
        const $validationTarget2 = getValidationTarget($fieldEditorContainer);
        const validationTargetInstance2 = tryGetValidationTargetInstance($validationTarget2);
        subscribeWrapperInvalidClassToggle(validationTargetInstance2);
      }
    });
  } else {
    const $div = renderer_default("<div>").appendTo($fieldEditorContainer);
    try {
      widgetInstance = createComponentCallback($div, item.editorType, editorOptions);
      widgetInstance.setAria("describedby", helpID);
      if (labelID) {
        widgetInstance.setAria("labelledby", labelID);
      }
      widgetInstance.setAria("required", isRequired);
    } catch (e) {
      ui_errors_default.log("E1035", e.message);
    }
  }
  const $validationTarget = getValidationTarget($fieldEditorContainer);
  const validationTargetInstance = $validationTarget && $validationTarget.data(VALIDATION_TARGET_CLASS);
  if (validationTargetInstance) {
    const isItemHaveCustomLabel = item.label && item.label.text;
    const itemName = isItemHaveCustomLabel ? null : name2;
    const fieldName = isItemHaveCustomLabel ? item.label.text : itemName && captionize(itemName);
    let validationRules;
    if (isSimpleItem) {
      if (item.validationRules) {
        validationRules = item.validationRules;
      } else {
        const requiredMessage = format(requiredMessageTemplate, fieldName || "");
        validationRules = item.isRequired ? [{
          type: "required",
          message: requiredMessage
        }] : null;
      }
    }
    if (Array.isArray(validationRules) && validationRules.length) {
      createComponentCallback($validationTarget, validator_default, {
        validationRules,
        validationGroup,
        dataGetter: () => ({
          formItem: item
        })
      });
    }
    subscribeWrapperInvalidClassToggle(validationTargetInstance);
  }
  if (helpText && isSimpleItem) {
    const $editorParent = $fieldEditorContainer.parent();
    $editorParent.append(renderer_default("<div>").addClass(FIELD_ITEM_CONTENT_WRAPPER_CLASS).append($fieldEditorContainer).append(renderer_default("<div>").addClass("dx-field-item-help-text").attr("id", helpID).text(helpText)));
  }
  return {
    $fieldEditorContainer,
    $rootElement,
    widgetInstance
  };
}
function getValidationTarget($fieldEditorContainer) {
  const $editor = $fieldEditorContainer.children().first();
  return $editor.hasClass(TEMPLATE_WRAPPER_CLASS) ? $editor.children().first() : $editor;
}
function tryGetValidationTargetInstance($validationTarget) {
  var _$validationTarget$pa;
  return (null === $validationTarget || void 0 === $validationTarget ? void 0 : $validationTarget.data(VALIDATION_TARGET_CLASS)) || (null === $validationTarget || void 0 === $validationTarget || null === (_$validationTarget$pa = $validationTarget.parent) || void 0 === _$validationTarget$pa || null === (_$validationTarget$pa = _$validationTarget$pa.call($validationTarget)) || void 0 === _$validationTarget$pa ? void 0 : _$validationTarget$pa.data(VALIDATION_TARGET_CLASS));
}
function subscribeWrapperInvalidClassToggle(validationTargetInstance) {
  if (validationTargetInstance && isMaterialBased()) {
    const wrapperClass = `.${FIELD_ITEM_CONTENT_WRAPPER_CLASS}`;
    const toggleInvalidClass = (_ref2) => {
      let {
        element,
        component
      } = _ref2;
      const {
        isValid,
        validationMessageMode
      } = component.option();
      renderer_default(element).parents(wrapperClass).toggleClass(INVALID_CLASS, false === isValid && (component._isFocused() || "always" === validationMessageMode));
    };
    validationTargetInstance.on("optionChanged", (e) => {
      if ("isValid" !== e.name) {
        return;
      }
      toggleInvalidClass(e);
    });
    validationTargetInstance.on("focusIn", toggleInvalidClass).on("focusOut", toggleInvalidClass).on("enterKey", toggleInvalidClass);
  }
}
function getTemplateData(item, editorOptions, formOrLayoutManager) {
  return {
    dataField: item.dataField,
    editorType: item.editorType,
    editorOptions,
    component: formOrLayoutManager,
    name: item.name
  };
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.items_runtime_info.js
var FormItemsRunTimeInfo = class {
  constructor() {
    this._map = {};
  }
  _findWidgetInstance(condition) {
    let result2;
    each(this._map, (guid2, _ref) => {
      let {
        widgetInstance,
        item
      } = _ref;
      if (condition(item)) {
        result2 = widgetInstance;
        return false;
      }
    });
    return result2;
  }
  _findFieldByCondition(callback, valueExpr) {
    let result2;
    each(this._map, (key, value2) => {
      if (callback(value2)) {
        result2 = "guid" === valueExpr ? key : value2[valueExpr];
        return false;
      }
    });
    return result2;
  }
  clear() {
    this._map = {};
  }
  removeItemsByItems(itemsRunTimeInfo) {
    each(itemsRunTimeInfo.getItems(), (guid2) => this.removeItemByKey(guid2));
  }
  removeItemByKey(key) {
    delete this._map[key];
  }
  add(options2) {
    const key = options2.guid || new guid_default();
    this._map[key] = options2;
    return key;
  }
  addItemsOrExtendFrom(itemsRunTimeInfo) {
    itemsRunTimeInfo.each((key, itemRunTimeInfo) => {
      if (this._map[key]) {
        if (itemRunTimeInfo.widgetInstance) {
          this._map[key].widgetInstance = itemRunTimeInfo.widgetInstance;
        }
        this._map[key].$itemContainer = itemRunTimeInfo.$itemContainer;
      } else {
        this.add({
          item: itemRunTimeInfo.item,
          widgetInstance: itemRunTimeInfo.widgetInstance,
          guid: key,
          $itemContainer: itemRunTimeInfo.$itemContainer
        });
      }
    });
  }
  extendRunTimeItemInfoByKey(key, options2) {
    if (this._map[key]) {
      this._map[key] = extend(this._map[key], options2);
    }
  }
  findWidgetInstanceByItem(item) {
    return this._findWidgetInstance((storedItem) => storedItem === item);
  }
  findGroupOrTabLayoutManagerByPath(targetPath) {
    return this._findFieldByCondition((_ref2) => {
      let {
        path
      } = _ref2;
      return path === targetPath;
    }, "layoutManager");
  }
  findKeyByPath(targetPath) {
    return this._findFieldByCondition((_ref3) => {
      let {
        path
      } = _ref3;
      return path === targetPath;
    }, "guid");
  }
  findWidgetInstanceByName(name2) {
    return this._findWidgetInstance((item) => name2 === item.name);
  }
  findWidgetInstanceByDataField(dataField) {
    return this._findWidgetInstance((item) => dataField === (isString(item) ? item : item.dataField));
  }
  findItemContainerByItem(item) {
    for (const key in this._map) {
      if (this._map[key].item === item) {
        return this._map[key].$itemContainer;
      }
    }
    return null;
  }
  findItemIndexByItem(targetItem) {
    return this._findFieldByCondition((_ref4) => {
      let {
        item
      } = _ref4;
      return item === targetItem;
    }, "itemIndex");
  }
  findPreparedItemByItem(item) {
    return this._findFieldByCondition((_ref5) => {
      let {
        item: currentItem
      } = _ref5;
      return currentItem === item;
    }, "preparedItem");
  }
  getItems() {
    return this._map;
  }
  each(handler) {
    each(this._map, (key, itemRunTimeInfo) => {
      handler(key, itemRunTimeInfo);
    });
  }
  removeItemsByPathStartWith(path) {
    const keys = Object.keys(this._map);
    const filteredKeys = keys.filter((key) => {
      if (this._map[key].path) {
        return this._map[key].path.indexOf(path, 0) > -1;
      }
      return false;
    });
    filteredKeys.forEach((key) => this.removeItemByKey(key));
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.layout_manager.js
var LayoutManager = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      layoutData: {},
      readOnly: false,
      colCount: 1,
      colCountByScreen: void 0,
      labelLocation: "left",
      onFieldDataChanged: null,
      onEditorEnterKey: null,
      customizeItem: null,
      alignItemLabels: true,
      minColWidth: 200,
      showRequiredMark: true,
      screenByWidth: null,
      showOptionalMark: false,
      requiredMark: "*",
      labelMode: "outside",
      optionalMark: message_default.format("dxForm-optionalMark"),
      requiredMessage: message_default.getFormatter("dxForm-requiredMessage")
    });
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      layoutData: true,
      validationGroup: true
    });
  },
  _init() {
    const layoutData = this.option("layoutData");
    this.callBase();
    this._itemWatchers = [];
    this._itemsRunTimeInfo = new FormItemsRunTimeInfo();
    this._updateReferencedOptions(layoutData);
    this._initDataAndItems(layoutData);
  },
  _dispose() {
    this.callBase();
    this._cleanItemWatchers();
  },
  _initDataAndItems(initialData) {
    this._syncDataWithItems();
    this._updateItems(initialData);
  },
  _syncDataWithItems() {
    const layoutData = this.option("layoutData");
    const userItems = this.option("items");
    if (isDefined(userItems)) {
      userItems.forEach((item) => {
        if (item.dataField && void 0 === this._getDataByField(item.dataField)) {
          let value2;
          if (item.editorOptions) {
            value2 = item.editorOptions.value;
          }
          if (isDefined(value2) || item.dataField in layoutData) {
            this._updateFieldValue(item.dataField, value2);
          }
        }
      });
    }
  },
  _getDataByField(dataField) {
    return dataField ? this.option(`layoutData.${dataField}`) : null;
  },
  _isCheckboxUndefinedStateEnabled(_ref) {
    let {
      allowIndeterminateState,
      editorType,
      dataField
    } = _ref;
    if (true === allowIndeterminateState && "dxCheckBox" === editorType) {
      const nameParts = ["layoutData", ...dataField.split(".")];
      const propertyName = nameParts.pop();
      const layoutData = this.option(nameParts.join("."));
      return layoutData && propertyName in layoutData;
    }
    return false;
  },
  _updateFieldValue(dataField, value2) {
    const layoutData = this.option("layoutData");
    let newValue = value2;
    if (!variable_wrapper_default.isWrapped(layoutData[dataField]) && isDefined(dataField)) {
      this.option(`layoutData.${dataField}`, newValue);
    } else if (variable_wrapper_default.isWritableWrapped(layoutData[dataField])) {
      newValue = isFunction(newValue) ? newValue() : newValue;
      layoutData[dataField](newValue);
    }
    this._triggerOnFieldDataChanged({
      dataField,
      value: newValue
    });
  },
  _triggerOnFieldDataChanged(args) {
    this._createActionByOption("onFieldDataChanged")(args);
  },
  _updateItems(layoutData) {
    const that = this;
    const userItems = this.option("items");
    const isUserItemsExist = isDefined(userItems);
    const customizeItem = that.option("customizeItem");
    const items = isUserItemsExist ? userItems : this._generateItemsByData(layoutData);
    if (isDefined(items)) {
      const processedItems = [];
      each(items, (index2, item) => {
        if (that._isAcceptableItem(item)) {
          item = that._processItem(item);
          customizeItem && customizeItem(item);
          if (isObject(item) && false !== variable_wrapper_default.unwrap(item.visible)) {
            processedItems.push(item);
          }
        }
      });
      if (!that._itemWatchers.length || !isUserItemsExist) {
        that._updateItemWatchers(items);
      }
      this._setItems(processedItems);
      this._sortItems();
    }
  },
  _cleanItemWatchers() {
    this._itemWatchers.forEach((dispose) => {
      dispose();
    });
    this._itemWatchers = [];
  },
  _updateItemWatchers(items) {
    const that = this;
    const watch = that._getWatch();
    items.forEach((item) => {
      if (isObject(item) && isDefined(item.visible) && isFunction(watch)) {
        that._itemWatchers.push(watch(() => variable_wrapper_default.unwrap(item.visible), () => {
          that._updateItems(that.option("layoutData"));
          that.repaint();
        }, {
          skipImmediate: true
        }));
      }
    });
  },
  _generateItemsByData(layoutData) {
    const result2 = [];
    if (isDefined(layoutData)) {
      each(layoutData, (dataField) => {
        result2.push({
          dataField
        });
      });
    }
    return result2;
  },
  _isAcceptableItem(item) {
    const itemField = item.dataField || item;
    const itemData = this._getDataByField(itemField);
    return !(isFunction(itemData) && !variable_wrapper_default.isWrapped(itemData));
  },
  _processItem(item) {
    if ("string" === typeof item) {
      item = {
        dataField: item
      };
    }
    if ("object" === typeof item && !item.itemType) {
      item.itemType = SIMPLE_ITEM_TYPE;
    }
    if (!isDefined(item.editorType) && isDefined(item.dataField)) {
      const value2 = this._getDataByField(item.dataField);
      item.editorType = isDefined(value2) ? this._getEditorTypeByDataType(type(value2)) : "dxTextBox";
    }
    if ("dxCheckBox" === item.editorType) {
      item.allowIndeterminateState = item.allowIndeterminateState ?? true;
    }
    return item;
  },
  _getEditorTypeByDataType(dataType) {
    switch (dataType) {
      case "number":
        return "dxNumberBox";
      case "date":
        return "dxDateBox";
      case "boolean":
        return "dxCheckBox";
      default:
        return "dxTextBox";
    }
  },
  _sortItems() {
    normalizeIndexes(this._items, "visibleIndex");
    this._sortIndexes();
  },
  _sortIndexes() {
    this._items.sort((itemA, itemB) => {
      const indexA = itemA.visibleIndex;
      const indexB = itemB.visibleIndex;
      let result2;
      if (indexA > indexB) {
        result2 = 1;
      } else if (indexA < indexB) {
        result2 = -1;
      } else {
        result2 = 0;
      }
      return result2;
    });
  },
  _initMarkup() {
    this._itemsRunTimeInfo.clear();
    this.$element().addClass(FORM_LAYOUT_MANAGER_CLASS);
    this.callBase();
    this._renderResponsiveBox();
  },
  _renderResponsiveBox() {
    const that = this;
    const templatesInfo = [];
    if (that._items && that._items.length) {
      const colCount = that._getColCount();
      const $container = renderer_default("<div>").appendTo(that.$element());
      that._prepareItemsWithMerging(colCount);
      const layoutItems = that._generateLayoutItems();
      that._responsiveBox = that._createComponent($container, responsive_box_default, that._getResponsiveBoxConfig(layoutItems, colCount, templatesInfo));
      if (!hasWindow()) {
        that._renderTemplates(templatesInfo);
      }
    }
  },
  _itemStateChangedHandler(e) {
    this._refresh();
  },
  _renderTemplates(templatesInfo) {
    const that = this;
    let itemsWithLabelTemplateCount = 0;
    templatesInfo.forEach((_ref2) => {
      var _item$label;
      let {
        item
      } = _ref2;
      if (null !== item && void 0 !== item && null !== (_item$label = item.label) && void 0 !== _item$label && _item$label.template) {
        itemsWithLabelTemplateCount++;
      }
    });
    each(templatesInfo, (index2, info) => {
      switch (info.itemType) {
        case "empty":
          renderEmptyItem(info);
          break;
        case "button":
          that._renderButtonItem(info);
          break;
        default:
          that._renderFieldItem(info, itemsWithLabelTemplateCount);
      }
    });
  },
  _getResponsiveBoxConfig(layoutItems, colCount, templatesInfo) {
    const that = this;
    const colCountByScreen = that.option("colCountByScreen");
    const xsColCount = colCountByScreen && colCountByScreen.xs;
    return {
      onItemStateChanged: this._itemStateChangedHandler.bind(this),
      onLayoutChanged() {
        const onLayoutChanged = that.option("onLayoutChanged");
        const isSingleColumnMode = that.isSingleColumnMode();
        if (onLayoutChanged) {
          that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, isSingleColumnMode);
          onLayoutChanged(isSingleColumnMode);
        }
      },
      onContentReady(e) {
        if (hasWindow()) {
          that._renderTemplates(templatesInfo);
        }
        if (that.option("onLayoutChanged")) {
          that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, that.isSingleColumnMode(e.component));
        }
      },
      itemTemplate(e, itemData, itemElement) {
        if (!e.location) {
          return;
        }
        const $itemElement = renderer_default(itemElement);
        const itemRenderedCountInPreviousRows = e.location.row * colCount;
        const item = that._items[e.location.col + itemRenderedCountInPreviousRows];
        if (!item) {
          return;
        }
        const itemCssClassList = [item.cssClass];
        $itemElement.toggleClass(SINGLE_COLUMN_ITEM_CONTENT, that.isSingleColumnMode(this));
        if (0 === e.location.row) {
          itemCssClassList.push("dx-first-row");
        }
        if (0 === e.location.col) {
          itemCssClassList.push("dx-first-col");
        }
        if (item.itemType === SIMPLE_ITEM_TYPE && that.option("isRoot")) {
          $itemElement.addClass(ROOT_SIMPLE_ITEM_CLASS);
        }
        const isLastColumn = e.location.col === colCount - 1 || e.location.col + e.location.colspan === colCount;
        const rowsCount = that._getRowsCount();
        const isLastRow = e.location.row === rowsCount - 1;
        if (isLastColumn) {
          itemCssClassList.push("dx-last-col");
        }
        if (isLastRow) {
          itemCssClassList.push("dx-last-row");
        }
        if ("empty" !== item.itemType) {
          itemCssClassList.push(FIELD_ITEM_CLASS);
          itemCssClassList.push(that.option("cssItemClass"));
          if (isDefined(item.col)) {
            itemCssClassList.push(`dx-col-${item.col}`);
          }
        }
        templatesInfo.push({
          itemType: item.itemType,
          item,
          $parent: $itemElement,
          rootElementCssClassList: itemCssClassList
        });
      },
      cols: that._generateRatio(colCount),
      rows: that._generateRatio(that._getRowsCount(), true),
      dataSource: layoutItems,
      screenByWidth: that.option("screenByWidth"),
      singleColumnScreen: xsColCount ? false : "xs"
    };
  },
  _getColCount() {
    let colCount = this.option("colCount");
    const colCountByScreen = this.option("colCountByScreen");
    if (colCountByScreen) {
      let screenFactor = this.option("form").getTargetScreenFactor();
      if (!screenFactor) {
        screenFactor = hasWindow() ? getCurrentScreenFactor(this.option("screenByWidth")) : "lg";
      }
      colCount = colCountByScreen[screenFactor] || colCount;
    }
    if ("auto" === colCount) {
      if (this._cashedColCount) {
        return this._cashedColCount;
      }
      this._cashedColCount = colCount = this._getMaxColCount();
    }
    return colCount < 1 ? 1 : colCount;
  },
  _getMaxColCount() {
    if (!hasWindow()) {
      return 1;
    }
    const minColWidth = this.option("minColWidth");
    const width = getWidth(this.$element());
    const itemsCount = this._items.length;
    const maxColCount = Math.floor(width / minColWidth) || 1;
    return itemsCount < maxColCount ? itemsCount : maxColCount;
  },
  isCachedColCountObsolete() {
    return this._cashedColCount && this._getMaxColCount() !== this._cashedColCount;
  },
  _prepareItemsWithMerging(colCount) {
    const items = this._items.slice(0);
    let item;
    let itemsMergedByCol;
    let result2 = [];
    let j;
    let i;
    for (i = 0; i < items.length; i++) {
      item = items[i];
      result2.push(item);
      if (this.option("alignItemLabels") || item.alignItemLabels || item.colSpan) {
        item.col = this._getColByIndex(result2.length - 1, colCount);
      }
      if (item.colSpan > 1 && item.col + item.colSpan <= colCount) {
        itemsMergedByCol = [];
        for (j = 0; j < item.colSpan - 1; j++) {
          itemsMergedByCol.push({
            merged: true
          });
        }
        result2 = result2.concat(itemsMergedByCol);
      } else {
        delete item.colSpan;
      }
    }
    this._setItems(result2);
  },
  _getColByIndex: (index2, colCount) => index2 % colCount,
  _setItems(items) {
    this._items = items;
    this._cashedColCount = null;
  },
  _generateLayoutItems() {
    const items = this._items;
    const colCount = this._getColCount();
    const result2 = [];
    let item;
    let i;
    for (i = 0; i < items.length; i++) {
      item = items[i];
      if (!item.merged) {
        const generatedItem = {
          location: {
            row: parseInt(i / colCount),
            col: this._getColByIndex(i, colCount)
          }
        };
        if (isDefined(item.disabled)) {
          generatedItem.disabled = item.disabled;
        }
        if (isDefined(item.visible)) {
          generatedItem.visible = item.visible;
        }
        if (isDefined(item.colSpan)) {
          generatedItem.location.colspan = item.colSpan;
        }
        if (isDefined(item.rowSpan)) {
          generatedItem.location.rowspan = item.rowSpan;
        }
        result2.push(generatedItem);
      }
    }
    return result2;
  },
  _renderEmptyItem($container) {
    renderEmptyItem({
      $container
    });
  },
  _renderButtonItem(_ref3) {
    let {
      item,
      $parent,
      rootElementCssClassList
    } = _ref3;
    const {
      $rootElement,
      buttonInstance
    } = renderButtonItem({
      item,
      $parent,
      rootElementCssClassList,
      validationGroup: this.option("validationGroup"),
      createComponentCallback: this._createComponent.bind(this)
    });
    this._itemsRunTimeInfo.add({
      item,
      widgetInstance: buttonInstance,
      guid: item.guid,
      $itemContainer: $rootElement
    });
  },
  _renderFieldItem(_ref4, itemsWithLabelTemplateCount) {
    var _item$label2, _this$option;
    let {
      item,
      $parent,
      rootElementCssClassList
    } = _ref4;
    const editorValue = this._getDataByField(item.dataField);
    let canAssignUndefinedValueToEditor = false;
    if (void 0 === editorValue) {
      const {
        allowIndeterminateState,
        editorType,
        dataField
      } = item;
      canAssignUndefinedValueToEditor = this._isCheckboxUndefinedStateEnabled({
        allowIndeterminateState,
        editorType,
        dataField
      });
    }
    const name2 = item.dataField || item.name;
    const formOrLayoutManager = this._getFormOrThis();
    const {
      $fieldEditorContainer,
      widgetInstance,
      $rootElement
    } = renderFieldItem(convertToRenderFieldItemOptions({
      $parent,
      rootElementCssClassList,
      item,
      name: name2,
      editorValue,
      canAssignUndefinedValueToEditor,
      formOrLayoutManager: this._getFormOrThis(),
      createComponentCallback: this._createComponent.bind(this),
      formLabelLocation: this.option("labelLocation"),
      requiredMessageTemplate: this.option("requiredMessage"),
      validationGroup: this.option("validationGroup"),
      editorValidationBoundary: this.option("validationBoundary"),
      editorStylingMode: this.option("form") && this.option("form").option("stylingMode"),
      showColonAfterLabel: this.option("showColonAfterLabel"),
      managerLabelLocation: this.option("labelLocation"),
      template: item.template ? this._getTemplate(item.template) : null,
      labelTemplate: null !== (_item$label2 = item.label) && void 0 !== _item$label2 && _item$label2.template ? this._getTemplate(item.label.template) : null,
      itemId: this.option("form") && this.option("form").getItemID(name2),
      managerMarkOptions: this._getMarkOptions(),
      labelMode: this.option("labelMode"),
      onLabelTemplateRendered: () => {
        this._incTemplateRenderedCallCount();
        if (this._shouldAlignLabelsOnTemplateRendered(formOrLayoutManager, itemsWithLabelTemplateCount)) {
          formOrLayoutManager._alignLabels(this, this.isSingleColumnMode(formOrLayoutManager));
        }
      }
    }));
    null === (_this$option = this.option("onFieldItemRendered")) || void 0 === _this$option || _this$option();
    if (widgetInstance && item.dataField) {
      this._bindDataField(widgetInstance, item.dataField, item.editorType, $fieldEditorContainer);
    }
    this._itemsRunTimeInfo.add({
      item,
      widgetInstance,
      guid: item.guid,
      $itemContainer: $rootElement
    });
  },
  _incTemplateRenderedCallCount() {
    this._labelTemplateRenderedCallCount = (this._labelTemplateRenderedCallCount ?? 0) + 1;
  },
  _shouldAlignLabelsOnTemplateRendered(formOrLayoutManager, totalItemsWithLabelTemplate) {
    return formOrLayoutManager.option("templatesRenderAsynchronously") && this._labelTemplateRenderedCallCount === totalItemsWithLabelTemplate;
  },
  _getMarkOptions() {
    return {
      showRequiredMark: this.option("showRequiredMark"),
      requiredMark: this.option("requiredMark"),
      showOptionalMark: this.option("showOptionalMark"),
      optionalMark: this.option("optionalMark")
    };
  },
  _getFormOrThis() {
    return this.option("form") || this;
  },
  _bindDataField(editorInstance, dataField, editorType, $container) {
    const formOrThis = this._getFormOrThis();
    editorInstance.on("enterKey", (args) => {
      formOrThis._createActionByOption("onEditorEnterKey")(extend(args, {
        dataField
      }));
    });
    this._createWatcher(editorInstance, $container, dataField);
    this.linkEditorToDataField(editorInstance, dataField, editorType);
  },
  _createWatcher(editorInstance, $container, dataField) {
    const that = this;
    const watch = that._getWatch();
    if (!isFunction(watch)) {
      return;
    }
    const dispose = watch(() => that._getDataByField(dataField), () => {
      const fieldValue = that._getDataByField(dataField);
      if ("dxTagBox" === editorInstance.NAME) {
        const editorValue = editorInstance.option("value");
        if (fieldValue !== editorValue && function(array1, array2) {
          if (!Array.isArray(array1) || !Array.isArray(array2) || array1.length !== array2.length) {
            return false;
          }
          for (let i = 0; i < array1.length; i++) {
            if (array1[i] !== array2[i]) {
              return false;
            }
          }
          return true;
        }(fieldValue, editorValue)) {
          return;
        }
      }
      editorInstance.option("value", fieldValue);
    }, {
      deep: true,
      skipImmediate: true
    }, {
      createWatcherDataField: dataField
    });
    events_engine_default.on($container, removeEvent, dispose);
  },
  _getWatch() {
    if (!isDefined(this._watch)) {
      const formInstance = this.option("form");
      this._watch = formInstance && formInstance.option("integrationOptions.watchMethod");
    }
    return this._watch;
  },
  _createComponent($editor, type2, editorOptions) {
    const readOnlyState = this.option("readOnly");
    let hasEditorReadOnly = Object.hasOwn(editorOptions, "readOnly");
    const instance = this.callBase($editor, type2, _extends({}, editorOptions, {
      readOnly: !hasEditorReadOnly ? readOnlyState : editorOptions.readOnly
    }));
    let isChangeByForm = false;
    instance.on("optionChanged", (args) => {
      if ("readOnly" === args.name && !isChangeByForm) {
        hasEditorReadOnly = true;
      }
    });
    this.on("optionChanged", (args) => {
      if ("readOnly" === args.name && !hasEditorReadOnly) {
        isChangeByForm = true;
        instance.option(args.name, args.value);
        isChangeByForm = false;
      }
    });
    return instance;
  },
  _generateRatio(count, isAutoSize) {
    const result2 = [];
    let ratio;
    let i;
    for (i = 0; i < count; i++) {
      ratio = {
        ratio: 1
      };
      if (isAutoSize) {
        ratio.baseSize = "auto";
      }
      result2.push(ratio);
    }
    return result2;
  },
  _getRowsCount() {
    return Math.ceil(this._items.length / this._getColCount());
  },
  _updateReferencedOptions(newLayoutData) {
    const layoutData = this.option("layoutData");
    if (isObject(layoutData)) {
      Object.getOwnPropertyNames(layoutData).forEach((property) => delete this._optionsByReference[`layoutData.${property}`]);
    }
    if (isObject(newLayoutData)) {
      Object.getOwnPropertyNames(newLayoutData).forEach((property) => this._optionsByReference[`layoutData.${property}`] = true);
    }
  },
  _clearWidget(instance) {
    this._disableEditorValueChangedHandler = true;
    instance.clear();
    this._disableEditorValueChangedHandler = false;
    instance.option("isValid", true);
  },
  _optionChanged(args) {
    if (0 === args.fullName.search("layoutData.")) {
      return;
    }
    switch (args.name) {
      case "showRequiredMark":
      case "showOptionalMark":
      case "requiredMark":
      case "optionalMark":
        this._cashedRequiredConfig = null;
        this._invalidate();
        break;
      case "layoutData":
        this._updateReferencedOptions(args.value);
        if (this.option("items")) {
          if (!isEmptyObject(args.value)) {
            this._itemsRunTimeInfo.each((_, itemRunTimeInfo) => {
              if (isDefined(itemRunTimeInfo.item)) {
                const {
                  dataField
                } = itemRunTimeInfo.item;
                if (dataField && isDefined(itemRunTimeInfo.widgetInstance)) {
                  const valueGetter = compileGetter(dataField);
                  const dataValue = valueGetter(args.value);
                  const {
                    allowIndeterminateState,
                    editorType
                  } = itemRunTimeInfo.item;
                  if (void 0 !== dataValue || this._isCheckboxUndefinedStateEnabled({
                    allowIndeterminateState,
                    editorType,
                    dataField
                  })) {
                    itemRunTimeInfo.widgetInstance.option("value", dataValue);
                  } else {
                    this._clearWidget(itemRunTimeInfo.widgetInstance);
                  }
                }
              }
            });
          }
        } else {
          this._initDataAndItems(args.value);
          this._invalidate();
        }
        break;
      case "items":
        this._cleanItemWatchers();
        this._initDataAndItems(args.value);
        this._invalidate();
        break;
      case "alignItemLabels":
      case "labelLocation":
      case "labelMode":
      case "requiredMessage":
        this._invalidate();
        break;
      case "customizeItem":
        this._updateItems(this.option("layoutData"));
        this._invalidate();
        break;
      case "colCount":
      case "colCountByScreen":
        this._resetColCount();
        break;
      case "minColWidth":
        if ("auto" === this.option("colCount")) {
          this._resetColCount();
        }
        break;
      case "readOnly":
      case "onFieldDataChanged":
        break;
      case "width":
        this.callBase(args);
        if ("auto" === this.option("colCount")) {
          this._resetColCount();
        }
        break;
      default:
        this.callBase(args);
    }
  },
  _resetColCount() {
    this._cashedColCount = null;
    this._invalidate();
  },
  linkEditorToDataField(editorInstance, dataField) {
    this.on("optionChanged", (args) => {
      if (args.fullName === `layoutData.${dataField}`) {
        editorInstance._setOptionWithoutOptionChange("value", args.value);
      }
    });
    editorInstance.on("valueChanged", (args) => {
      const isValueReferenceType = isObject(args.value) || Array.isArray(args.value);
      if (!this._disableEditorValueChangedHandler && !(isValueReferenceType && args.value === args.previousValue)) {
        this._updateFieldValue(dataField, args.value);
      }
    });
  },
  _dimensionChanged() {
    if ("auto" === this.option("colCount") && this.isCachedColCountObsolete()) {
      this._eventsStrategy.fireEvent("autoColCountChanged");
    }
  },
  updateData(data2, value2) {
    const that = this;
    if (isObject(data2)) {
      each(data2, (dataField, fieldValue) => {
        that._updateFieldValue(dataField, fieldValue);
      });
    } else if ("string" === typeof data2) {
      that._updateFieldValue(data2, value2);
    }
  },
  getEditor(field) {
    return this._itemsRunTimeInfo.findWidgetInstanceByDataField(field) || this._itemsRunTimeInfo.findWidgetInstanceByName(field);
  },
  isSingleColumnMode(component) {
    const responsiveBox = this._responsiveBox || component;
    if (responsiveBox) {
      return responsiveBox.option("currentScreenFactor") === responsiveBox.option("singleColumnScreen");
    }
  },
  getItemsRunTimeInfo() {
    return this._itemsRunTimeInfo;
  }
});
component_registrator_default("dxLayoutManager", LayoutManager);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_validation_summary.js
var ITEM_CLASS2 = "dx-validationsummary-item";
var ITEM_DATA_KEY = "dx-validationsummary-item-data";
var ValidationSummary = ui_collection_widget_edit_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      focusStateEnabled: false,
      noDataText: null
    });
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      validationGroup: true
    });
  },
  _init() {
    this.callBase();
    this._initGroupRegistration();
  },
  _initGroupRegistration() {
    const $element = this.$element();
    const group = this.option("validationGroup") || m_validation_engine_default.findGroup($element, this._modelByElement($element));
    const groupConfig = m_validation_engine_default.addGroup(group, true);
    this._unsubscribeGroup();
    this._groupWasInit = true;
    this._validationGroup = group;
    this.groupSubscription = this._groupValidationHandler.bind(this);
    groupConfig.on("validated", this.groupSubscription);
  },
  _unsubscribeGroup() {
    const groupConfig = m_validation_engine_default.getGroupConfig(this._validationGroup);
    groupConfig && groupConfig.off("validated", this.groupSubscription);
  },
  _getOrderedItems(validators, items) {
    let orderedItems = [];
    each(validators, (_, validator) => {
      const foundItems = grep(items, (item) => {
        if (item.validator === validator) {
          return true;
        }
      });
      if (foundItems.length) {
        orderedItems = orderedItems.concat(foundItems);
      }
    });
    return orderedItems;
  },
  _groupValidationHandler(params) {
    const items = this._getOrderedItems(params.validators, map(params.brokenRules, (rule) => ({
      text: rule.message,
      validator: rule.validator,
      index: rule.index
    })));
    this.validators = params.validators;
    each(this.validators, (_, validator) => {
      if (validator._validationSummary !== this) {
        let handler = this._itemValidationHandler.bind(this);
        const disposingHandler = function() {
          validator.off("validated", handler);
          validator._validationSummary = null;
          handler = null;
        };
        validator.on("validated", handler);
        validator.on("disposing", disposingHandler);
        validator._validationSummary = this;
      }
    });
    this.option("items", items);
  },
  _itemValidationHandler(_ref) {
    let {
      isValid,
      validator,
      brokenRules
    } = _ref;
    let items = this.option("items");
    let itemsChanged = false;
    let itemIndex = 0;
    while (itemIndex < items.length) {
      const item = items[itemIndex];
      if (item.validator === validator) {
        const foundRule = grep(brokenRules || [], (rule) => rule.index === item.index)[0];
        if (isValid || !foundRule) {
          items.splice(itemIndex, 1);
          itemsChanged = true;
          continue;
        }
        if (foundRule.message !== item.text) {
          item.text = foundRule.message;
          itemsChanged = true;
        }
      }
      itemIndex++;
    }
    each(brokenRules, (_, rule) => {
      const foundItem = grep(items, (item) => item.validator === validator && item.index === rule.index)[0];
      if (!foundItem) {
        items.push({
          text: rule.message,
          validator,
          index: rule.index
        });
        itemsChanged = true;
      }
    });
    if (itemsChanged) {
      items = this._getOrderedItems(this.validators, items);
      this.option("items", items);
    }
  },
  _initMarkup() {
    this.$element().addClass("dx-validationsummary");
    this.callBase();
  },
  _optionChanged(args) {
    if ("validationGroup" === args.name) {
      this._initGroupRegistration();
    } else {
      this.callBase(args);
    }
  },
  _itemClass: () => ITEM_CLASS2,
  _itemDataKey: () => ITEM_DATA_KEY,
  _postprocessRenderItem(params) {
    events_engine_default.on(params.itemElement, "click", () => {
      params.itemData.validator && params.itemData.validator.focus && params.itemData.validator.focus();
    });
  },
  _dispose() {
    this.callBase();
    this._unsubscribeGroup();
  },
  refreshValidationGroup() {
    this._initGroupRegistration();
  }
});
component_registrator_default("dxValidationSummary", ValidationSummary);
var m_validation_summary_default = ValidationSummary;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_validation_group.js
var ValidationGroup = class extends dom_component_default {
  _getDefaultOptions() {
    return super._getDefaultOptions();
  }
  _init() {
    super._init();
    m_validation_engine_default.addGroup(this, false);
  }
  _initMarkup() {
    const $element = this.$element();
    $element.addClass("dx-validationgroup");
    $element.find(".dx-validator").each((_, validatorContainer) => {
      m_validator_default.getInstance(renderer_default(validatorContainer))._initGroupRegistration();
    });
    $element.find(".dx-validationsummary").each((_, summaryContainer) => {
      m_validation_summary_default.getInstance(renderer_default(summaryContainer)).refreshValidationGroup();
    });
    super._initMarkup();
  }
  validate() {
    return m_validation_engine_default.validateGroup(this);
  }
  reset() {
    return m_validation_engine_default.resetGroup(this);
  }
  _dispose() {
    m_validation_engine_default.removeGroup(this);
    this.$element().removeClass("dx-validationgroup");
    super._dispose();
  }
  _useTemplates() {
    return false;
  }
};
component_registrator_default("dxValidationGroup", ValidationGroup);

// ../../../../../../node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.js
var ui_scrollable_default = m_scrollable_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/multi_view/m_multi_view.animation.js
var _translator = {
  move($element, position3) {
    move($element, {
      left: position3
    });
  }
};
var animation2 = {
  moveTo($element, position3, duration, completeAction) {
    fx_default.animate($element, {
      type: "slide",
      to: {
        left: position3
      },
      duration,
      complete: completeAction
    });
  },
  complete($element) {
    fx_default.stop($element, true);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_multi_view.js
var toNumber2 = (value2) => +value2;
var position2 = ($element) => locate($element).left;
var MultiView = ui_collection_widget_live_update_default.inherit({
  _activeStateUnit: ".dx-multiview-item",
  _supportedKeys() {
    return extend(this.callBase(), {
      pageUp: noop2,
      pageDown: noop2
    });
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      selectedIndex: 0,
      swipeEnabled: true,
      animationEnabled: true,
      loop: false,
      deferRendering: true,
      loopItemFocus: false,
      selectOnFocus: true,
      selectionMode: "single",
      selectionRequired: true,
      selectByClick: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  },
  _itemClass: () => "dx-multiview-item",
  _itemDataKey: () => "dxMultiViewItemData",
  _itemContainer() {
    return this._$itemContainer;
  },
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  },
  _itemWidth() {
    if (!this._itemWidthValue) {
      this._itemWidthValue = getWidth(this._$wrapper);
    }
    return this._itemWidthValue;
  },
  _clearItemWidthCache() {
    delete this._itemWidthValue;
  },
  _itemsCount() {
    return this.option("items").length;
  },
  _normalizeIndex(index2) {
    const count = this._itemsCount();
    if (index2 < 0) {
      index2 += count;
    }
    if (index2 >= count) {
      index2 -= count;
    }
    return index2;
  },
  _getRTLSignCorrection() {
    return this.option("rtlEnabled") ? -1 : 1;
  },
  _init() {
    this.callBase.apply(this, arguments);
    const $element = this.$element();
    $element.addClass("dx-multiview");
    this._$wrapper = renderer_default("<div>").addClass("dx-multiview-wrapper");
    this._$wrapper.appendTo($element);
    this._$itemContainer = renderer_default("<div>").addClass("dx-multiview-item-container");
    this._$itemContainer.appendTo(this._$wrapper);
    this.option("loopItemFocus", this.option("loop"));
    this._findBoundaryIndices();
    this._initSwipeable();
  },
  _initMarkup() {
    this._deferredItems = [];
    this.callBase();
    const selectedItemIndices = this._getSelectedItemIndices();
    this._updateItemsVisibility(selectedItemIndices[0]);
    this._setElementAria();
    this._setItemsAria();
  },
  _afterItemElementDeleted($item, deletedActionArgs) {
    this.callBase($item, deletedActionArgs);
    if (this._deferredItems) {
      this._deferredItems.splice(deletedActionArgs.itemIndex, 1);
    }
  },
  _beforeItemElementInserted(change) {
    this.callBase.apply(this, arguments);
    if (this._deferredItems) {
      this._deferredItems.splice(change.index, 0, null);
    }
  },
  _executeItemRenderAction(index2, itemData, itemElement) {
    index2 = (this.option("items") || []).indexOf(itemData);
    this.callBase(index2, itemData, itemElement);
  },
  _renderItemContent(args) {
    const renderContentDeferred = Deferred();
    const that = this;
    const {
      callBase
    } = this;
    const deferred = Deferred();
    deferred.done(() => {
      const $itemContent = callBase.call(that, args);
      renderContentDeferred.resolve($itemContent);
    });
    this._deferredItems[args.index] = deferred;
    this.option("deferRendering") || deferred.resolve();
    return renderContentDeferred.promise();
  },
  _render() {
    this.callBase();
    deferRender(() => {
      const selectedItemIndices = this._getSelectedItemIndices();
      this._updateItems(selectedItemIndices[0]);
    });
  },
  _getElementAria: () => ({
    role: "group",
    roledescription: message_default.format("dxMultiView-elementAriaRoleDescription"),
    label: message_default.format("dxMultiView-elementAriaLabel")
  }),
  _setElementAria() {
    const aria = this._getElementAria();
    this.setAria(aria, this.$element());
  },
  _setItemsAria() {
    const $itemElements = this._itemElements();
    const itemsCount = this._itemsCount();
    $itemElements.each((itemIndex, item) => {
      const aria = this._getItemAria({
        itemIndex,
        itemsCount
      });
      this.setAria(aria, renderer_default(item));
    });
  },
  _getItemAria(_ref) {
    let {
      itemIndex,
      itemsCount
    } = _ref;
    const aria = {
      role: "group",
      roledescription: message_default.format("dxMultiView-itemAriaRoleDescription"),
      label: message_default.format("dxMultiView-itemAriaLabel", itemIndex + 1, itemsCount)
    };
    return aria;
  },
  _updateItems(selectedIndex, newIndex) {
    this._updateItemsPosition(selectedIndex, newIndex);
    this._updateItemsVisibility(selectedIndex, newIndex);
  },
  _modifyByChanges() {
    this.callBase.apply(this, arguments);
    const selectedItemIndices = this._getSelectedItemIndices();
    this._updateItemsVisibility(selectedItemIndices[0]);
  },
  _updateItemsPosition(selectedIndex, newIndex) {
    const $itemElements = this._itemElements();
    const positionSign = isDefined(newIndex) ? -this._animationDirection(newIndex, selectedIndex) : void 0;
    const $selectedItem = $itemElements.eq(selectedIndex);
    _translator.move($selectedItem, 0);
    if (isDefined(newIndex)) {
      _translator.move($itemElements.eq(newIndex), 100 * positionSign + "%");
    }
  },
  _updateItemsVisibility(selectedIndex, newIndex) {
    const $itemElements = this._itemElements();
    $itemElements.each((itemIndex, item) => {
      const $item = renderer_default(item);
      const isHidden = itemIndex !== selectedIndex && itemIndex !== newIndex;
      if (!isHidden) {
        this._renderSpecificItem(itemIndex);
      }
      $item.toggleClass("dx-multiview-item-hidden", isHidden);
      this.setAria("hidden", isHidden || void 0, $item);
    });
  },
  _renderSpecificItem(index2) {
    const $item = this._itemElements().eq(index2);
    const hasItemContent = $item.find(this._itemContentClass()).length > 0;
    if (isDefined(index2) && !hasItemContent) {
      this._deferredItems[index2].resolve();
      triggerResizeEvent($item);
    }
  },
  _refreshItem($item, item) {
    this.callBase($item, item);
    this._updateItemsVisibility(this.option("selectedIndex"));
  },
  _setAriaSelectionAttribute: noop2,
  _updateSelection(addedSelection, removedSelection) {
    const newIndex = addedSelection[0];
    const prevIndex = removedSelection[0];
    animation2.complete(this._$itemContainer);
    this._updateItems(prevIndex, newIndex);
    const animationDirection = this._animationDirection(newIndex, prevIndex);
    this._animateItemContainer(animationDirection * this._itemWidth(), () => {
      _translator.move(this._$itemContainer, 0);
      this._updateItems(newIndex);
      getWidth(this._$itemContainer);
    });
  },
  _animateItemContainer(position3, completeCallback) {
    const duration = this.option("animationEnabled") ? 200 : 0;
    animation2.moveTo(this._$itemContainer, position3, duration, completeCallback);
  },
  _animationDirection(newIndex, prevIndex) {
    const containerPosition = position2(this._$itemContainer);
    const indexDifference = (prevIndex - newIndex) * this._getRTLSignCorrection() * this._getItemFocusLoopSignCorrection();
    const isSwipePresent = 0 !== containerPosition;
    const directionSignVariable = isSwipePresent ? containerPosition : indexDifference;
    return sign(directionSignVariable);
  },
  _getSwipeDisabledState() {
    return !this.option("swipeEnabled") || this._itemsCount() <= 1;
  },
  _initSwipeable() {
    this._createComponent(this.$element(), swipeable_default, {
      disabled: this._getSwipeDisabledState(),
      elastic: false,
      itemSizeFunc: this._itemWidth.bind(this),
      onStart: (args) => this._swipeStartHandler(args.event),
      onUpdated: (args) => this._swipeUpdateHandler(args.event),
      onEnd: (args) => this._swipeEndHandler(args.event)
    });
  },
  _findBoundaryIndices() {
    const items = this.option("items");
    let firstIndex;
    let lastIndex;
    items.forEach((item, index2) => {
      const isDisabled = Boolean(null === item || void 0 === item ? void 0 : item.disabled);
      if (!isDisabled) {
        firstIndex ?? (firstIndex = index2);
        lastIndex = index2;
      }
    });
    this._boundaryIndices = {
      firstAvailableIndex: firstIndex ?? 0,
      lastAvailableIndex: lastIndex ?? items.length - 1,
      firstTrueIndex: 0,
      lastTrueIndex: items.length - 1
    };
  },
  _swipeStartHandler(e) {
    animation2.complete(this._$itemContainer);
    const selectedIndex = this.option("selectedIndex");
    const loop = this.option("loop");
    const {
      firstAvailableIndex,
      lastAvailableIndex
    } = this._boundaryIndices;
    const rtl = this.option("rtlEnabled");
    e.maxLeftOffset = toNumber2(loop || (rtl ? selectedIndex > firstAvailableIndex : selectedIndex < lastAvailableIndex));
    e.maxRightOffset = toNumber2(loop || (rtl ? selectedIndex < lastAvailableIndex : selectedIndex > firstAvailableIndex));
    this._swipeDirection = null;
  },
  _swipeUpdateHandler(e) {
    const {
      offset: offset2
    } = e;
    const swipeDirection = sign(offset2) * this._getRTLSignCorrection();
    _translator.move(this._$itemContainer, offset2 * this._itemWidth());
    if (swipeDirection !== this._swipeDirection) {
      this._swipeDirection = swipeDirection;
      const selectedIndex = this.option("selectedIndex");
      const newIndex = this._normalizeIndex(selectedIndex - swipeDirection);
      this._updateItems(selectedIndex, newIndex);
    }
  },
  _findNextAvailableIndex(index2, offset2) {
    const {
      items,
      loop
    } = this.option();
    const {
      firstAvailableIndex,
      lastAvailableIndex,
      firstTrueIndex,
      lastTrueIndex
    } = this._boundaryIndices;
    const isFirstActive = [firstTrueIndex, firstAvailableIndex].includes(index2);
    const isLastActive = [lastTrueIndex, lastAvailableIndex].includes(index2);
    if (loop) {
      if (isFirstActive && offset2 < 0) {
        return lastAvailableIndex;
      }
      if (isLastActive && offset2 > 0) {
        return firstAvailableIndex;
      }
    }
    for (let i = index2 + offset2; i >= firstAvailableIndex && i <= lastAvailableIndex; i += offset2) {
      const isDisabled = Boolean(items[i].disabled);
      if (!isDisabled) {
        return i;
      }
    }
    return index2;
  },
  _swipeEndHandler(e) {
    const targetOffset = e.targetOffset * this._getRTLSignCorrection();
    if (targetOffset) {
      const newSelectedIndex = this._findNextAvailableIndex(this.option("selectedIndex"), -targetOffset);
      this.option("selectedIndex", newSelectedIndex);
      const $selectedElement = this.itemElements().filter(".dx-item-selected");
      this.option("focusStateEnabled") && this.option("focusedElement", getPublicElement($selectedElement));
    } else {
      this._animateItemContainer(0, noop2);
    }
  },
  _getItemFocusLoopSignCorrection() {
    return this._itemFocusLooped ? -1 : 1;
  },
  _moveFocus() {
    this.callBase.apply(this, arguments);
    this._itemFocusLooped = false;
  },
  _prevItem($items) {
    const $result = this.callBase.apply(this, arguments);
    this._itemFocusLooped = $result.is($items.last());
    return $result;
  },
  _nextItem($items) {
    const $result = this.callBase.apply(this, arguments);
    this._itemFocusLooped = $result.is($items.first());
    return $result;
  },
  _dimensionChanged() {
    this._clearItemWidthCache();
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._dimensionChanged();
    }
  },
  _updateSwipeDisabledState() {
    const disabled = this._getSwipeDisabledState();
    swipeable_default.getInstance(this.$element()).option("disabled", disabled);
  },
  _dispose() {
    delete this._boundaryIndices;
    this.callBase();
  },
  _optionChanged(args) {
    const {
      value: value2
    } = args;
    switch (args.name) {
      case "loop":
        this.option("loopItemFocus", value2);
        break;
      case "animationEnabled":
        break;
      case "swipeEnabled":
        this._updateSwipeDisabledState();
        break;
      case "deferRendering":
        this._invalidate();
        break;
      case "items":
        this._updateSwipeDisabledState();
        this._findBoundaryIndices();
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxMultiView", MultiView);
var m_multi_view_default = MultiView;

// ../../../../../../node_modules/devextreme/esm/ui/multi_view.js
var multi_view_default = m_multi_view_default;

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_scroll_left_max.js
function getScrollLeftMax(element) {
  return element.scrollWidth - element.clientWidth;
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_scroll_top_max.js
function getScrollTopMax(element) {
  return element.scrollHeight - element.clientHeight;
}

// ../../../../../../node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_boundary_props.js
function isReachedLeft(scrollOffsetLeft, epsilon) {
  return Math.round(scrollOffsetLeft) <= epsilon;
}
function isReachedRight(element, scrollOffsetLeft, epsilon) {
  return Math.round(getScrollLeftMax(element) - scrollOffsetLeft) <= epsilon;
}
function isReachedTop(scrollOffsetTop, epsilon) {
  return Math.round(scrollOffsetTop) <= epsilon;
}
function isReachedBottom(element, scrollOffsetTop, pocketHeight, epsilon) {
  return Math.round(getScrollTopMax(element) - scrollOffsetTop - pocketHeight) <= epsilon;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tabs/constants.js
var TABS_EXPANDED_CLASS = "dx-tabs-expanded";

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tabs/m_item.js
var TabsItem = m_item_default.inherit({
  _renderWatchers() {
    this.callBase();
    this._startWatcher("badge", this._renderBadge.bind(this));
  },
  _renderBadge(badge) {
    this._$element.children(".dx-badge").remove();
    if (!badge) {
      return;
    }
    const $badge = renderer_default("<div>").addClass("dx-tabs-item-badge").addClass("dx-badge").text(badge);
    this._$element.append($badge);
  }
});
var m_item_default3 = TabsItem;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tabs/m_tabs.js
var TABS_ORIENTATION_CLASS = {
  vertical: "dx-tabs-vertical",
  horizontal: "dx-tabs-horizontal"
};
var INDICATOR_POSITION_CLASS = {
  top: "dx-tab-indicator-position-top",
  right: "dx-tab-indicator-position-right",
  bottom: "dx-tab-indicator-position-bottom",
  left: "dx-tab-indicator-position-left"
};
var TABS_ICON_POSITION_CLASS = {
  top: "dx-tabs-icon-position-top",
  end: "dx-tabs-icon-position-end",
  bottom: "dx-tabs-icon-position-bottom",
  start: "dx-tabs-icon-position-start"
};
var TABS_STYLING_MODE_CLASS = {
  primary: "dx-tabs-styling-mode-primary",
  secondary: "dx-tabs-styling-mode-secondary"
};
var ORIENTATION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var INDICATOR_POSITION = {
  top: "top",
  right: "right",
  bottom: "bottom",
  left: "left"
};
var SCROLLABLE_DIRECTION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var ICON_POSITION = {
  top: "top",
  end: "end",
  bottom: "bottom",
  start: "start"
};
var STYLING_MODE = {
  primary: "primary",
  secondary: "secondary"
};
var Tabs = ui_collection_widget_live_update_default.inherit({
  _activeStateUnit: ".dx-tab",
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      showNavButtons: true,
      scrollByContent: true,
      scrollingEnabled: true,
      selectionMode: "single",
      orientation: ORIENTATION.horizontal,
      iconPosition: ICON_POSITION.start,
      stylingMode: STYLING_MODE.primary,
      activeStateEnabled: true,
      selectionRequired: false,
      selectOnFocus: true,
      loopItemFocus: false,
      useInkRipple: false,
      badgeExpr: (data2) => data2 ? data2.badge : void 0,
      _itemAttributes: {
        role: "tab"
      },
      _indicatorPosition: null
    });
  },
  _defaultOptionsRules() {
    const themeName = current();
    return this.callBase().concat([{
      device: () => "desktop" !== devices_default.real().deviceType,
      options: {
        showNavButtons: false
      }
    }, {
      device: {
        deviceType: "desktop"
      },
      options: {
        scrollByContent: false
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isFluent(themeName),
      options: {
        iconPosition: ICON_POSITION.top,
        stylingMode: STYLING_MODE.secondary
      }
    }, {
      device: () => isMaterial(themeName),
      options: {
        useInkRipple: true,
        selectOnFocus: false,
        iconPosition: ICON_POSITION.top
      }
    }]);
  },
  _init() {
    const {
      orientation,
      stylingMode,
      scrollingEnabled
    } = this.option();
    const indicatorPosition = this._getIndicatorPosition();
    this.callBase();
    this.setAria("role", "tablist");
    this.$element().addClass("dx-tabs");
    this._toggleScrollingEnabledClass(scrollingEnabled);
    this._toggleOrientationClass(orientation);
    this._toggleIndicatorPositionClass(indicatorPosition);
    this._toggleIconPositionClass();
    this._toggleStylingModeClass(stylingMode);
    this._renderWrapper();
    this._renderMultiple();
    this._feedbackHideTimeout = 100;
  },
  _prepareDefaultItemTemplate(data2, $container) {
    const text = isPlainObject(data2) ? null === data2 || void 0 === data2 ? void 0 : data2.text : data2;
    if (isDefined(text)) {
      const $tabTextSpan = renderer_default("<span>").addClass("dx-tab-text-span");
      $tabTextSpan.text(text);
      const $tabTextSpanPseudo = renderer_default("<span>").addClass("dx-tab-text-span-pseudo");
      $tabTextSpanPseudo.text(text);
      $tabTextSpanPseudo.appendTo($tabTextSpan);
      $tabTextSpan.appendTo($container);
    }
    if (isDefined(data2.html)) {
      $container.html(data2.html);
    }
  },
  _initTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data2) => {
        this._prepareDefaultItemTemplate(data2, $container);
        const $iconElement = getImageContainer(data2.icon);
        $iconElement && $iconElement.prependTo($container);
        const $tabItem = renderer_default("<div>").addClass("dx-tab-text");
        $container.wrapInner($tabItem);
      }, ["text", "html", "icon"], this.option("integrationOptions.watchMethod"))
    });
  },
  _createItemByTemplate: function(itemTemplate, renderArgs) {
    const {
      itemData,
      container,
      index: index2
    } = renderArgs;
    this._deferredTemplates[index2] = Deferred();
    return itemTemplate.render({
      model: itemData,
      container,
      index: index2,
      onRendered: () => this._deferredTemplates[index2].resolve()
    });
  },
  _itemClass: () => "dx-tab",
  _selectedItemClass: () => "dx-tab-selected",
  _itemDataKey: () => "dxTabData",
  _initMarkup() {
    this._deferredTemplates = [];
    this.callBase();
    this.option("useInkRipple") && this._renderInkRipple();
    this.$element().addClass("dx-overflow-hidden");
  },
  _render() {
    this.callBase();
    this._deferRenderScrolling();
  },
  _deferRenderScrolling() {
    when.apply(this, this._deferredTemplates).done(() => this._renderScrolling());
  },
  _renderScrolling() {
    const removeClasses = ["dx-tabs-stretched", TABS_EXPANDED_CLASS, "dx-overflow-hidden"];
    this.$element().removeClass(removeClasses.join(" "));
    if (this.option("scrollingEnabled") && this._isItemsSizeExceeded()) {
      if (!this._scrollable) {
        this._renderScrollable();
        this._renderNavButtons();
      }
      const scrollable = this.getScrollable();
      scrollable.update();
      if (this.option("rtlEnabled")) {
        const maxLeftOffset = getScrollLeftMax(renderer_default(this.getScrollable().container()).get(0));
        scrollable.scrollTo({
          left: maxLeftOffset
        });
      }
      this._updateNavButtonsState();
      this._scrollToItem(this.option("selectedItem"));
    }
    if (!(this.option("scrollingEnabled") && this._isItemsSizeExceeded())) {
      this._cleanScrolling();
      if (this._needStretchItems()) {
        this.$element().addClass("dx-tabs-stretched");
      }
      this.$element().removeClass("dx-tabs-nav-buttons").addClass(TABS_EXPANDED_CLASS);
    }
  },
  _isVertical() {
    return this.option("orientation") === ORIENTATION.vertical;
  },
  _isItemsSizeExceeded() {
    const isVertical = this._isVertical();
    const isItemsSizeExceeded = isVertical ? this._isItemsHeightExceeded() : this._isItemsWidthExceeded();
    return isItemsSizeExceeded;
  },
  _isItemsWidthExceeded() {
    const $visibleItems = this._getVisibleItems();
    const tabItemTotalWidth = this._getSummaryItemsSize("width", $visibleItems, true);
    const elementWidth = getWidth(this.$element());
    if ([tabItemTotalWidth, elementWidth].includes(0)) {
      return false;
    }
    const isItemsWidthExceeded = tabItemTotalWidth > elementWidth - 1;
    return isItemsWidthExceeded;
  },
  _isItemsHeightExceeded() {
    const $visibleItems = this._getVisibleItems();
    const itemsHeight = this._getSummaryItemsSize("height", $visibleItems, true);
    const elementHeight = getHeight(this.$element());
    const isItemsHeightExceeded = itemsHeight - 1 > elementHeight;
    return isItemsHeightExceeded;
  },
  _needStretchItems() {
    const $visibleItems = this._getVisibleItems();
    const elementWidth = getWidth(this.$element());
    const itemsWidth = [];
    each($visibleItems, (_, item) => {
      itemsWidth.push(getOuterWidth(item, true));
    });
    const maxTabItemWidth = Math.max.apply(null, itemsWidth);
    const requireWidth = elementWidth / $visibleItems.length;
    const needStretchItems = maxTabItemWidth > requireWidth + 1;
    return needStretchItems;
  },
  _cleanNavButtons() {
    if (!this._leftButton || !this._rightButton) {
      return;
    }
    this._leftButton.$element().remove();
    this._rightButton.$element().remove();
    this._leftButton = null;
    this._rightButton = null;
  },
  _cleanScrolling() {
    if (!this._scrollable) {
      return;
    }
    this._$wrapper.appendTo(this.$element());
    this._scrollable.$element().remove();
    this._scrollable = null;
    this._cleanNavButtons();
  },
  _renderInkRipple() {
    this._inkRipple = render3();
  },
  _getPointerEvent: () => pointer_default.up,
  _toggleActiveState($element, value2, e) {
    this.callBase.apply(this, arguments);
    if (!this._inkRipple) {
      return;
    }
    const config3 = {
      element: $element,
      event: e
    };
    if (value2) {
      this._inkRipple.showWave(config3);
    } else {
      this._inkRipple.hideWave(config3);
    }
  },
  _renderMultiple() {
    if ("multiple" === this.option("selectionMode")) {
      this.option("selectOnFocus", false);
    }
  },
  _renderWrapper() {
    this._$wrapper = renderer_default("<div>").addClass("dx-tabs-wrapper");
    this.$element().append(this._$wrapper);
  },
  _itemContainer() {
    return this._$wrapper;
  },
  _getScrollableDirection() {
    const isVertical = this._isVertical();
    const scrollableDirection = isVertical ? SCROLLABLE_DIRECTION.vertical : SCROLLABLE_DIRECTION.horizontal;
    return scrollableDirection;
  },
  _updateScrollable() {
    if (this.getScrollable()) {
      this._cleanScrolling();
    }
    this._renderScrolling();
  },
  _renderScrollable() {
    const $itemContainer = this.$element().wrapInner(renderer_default("<div>").addClass("dx-tabs-scrollable")).children();
    this._scrollable = this._createComponent($itemContainer, ui_scrollable_default, {
      direction: this._getScrollableDirection(),
      showScrollbar: "never",
      useKeyboard: false,
      useNative: false,
      scrollByContent: this.option("scrollByContent"),
      onScroll: () => {
        this._updateNavButtonsState();
      }
    });
    this.$element().append(this._scrollable.$element());
  },
  _scrollToItem(itemData) {
    if (!this._scrollable) {
      return;
    }
    const $item = this._editStrategy.getItemElement(itemData);
    this._scrollable.scrollToElement($item);
  },
  _renderNavButtons() {
    const {
      showNavButtons,
      rtlEnabled
    } = this.option();
    this.$element().toggleClass("dx-tabs-nav-buttons", showNavButtons);
    if (!showNavButtons) {
      return;
    }
    this._leftButton = this._createNavButton(-30, rtlEnabled ? "chevronnext" : "chevronprev");
    const $leftButton = this._leftButton.$element();
    $leftButton.addClass("dx-tabs-nav-button-left");
    this.$element().prepend($leftButton);
    this._rightButton = this._createNavButton(30, rtlEnabled ? "chevronprev" : "chevronnext");
    const $rightButton = this._rightButton.$element();
    $rightButton.addClass("dx-tabs-nav-button-right");
    this.$element().append($rightButton);
  },
  _updateNavButtonsAriaDisabled() {
    const buttons = [this._leftButton, this._rightButton];
    buttons.forEach((button) => {
      null === button || void 0 === button || button.$element().attr({
        "aria-disabled": null
      });
    });
  },
  _updateNavButtonsState() {
    const isVertical = this._isVertical();
    const scrollable = this.getScrollable();
    if (isVertical) {
      var _this$_leftButton, _this$_rightButton;
      null === (_this$_leftButton = this._leftButton) || void 0 === _this$_leftButton || _this$_leftButton.option("disabled", isReachedTop(scrollable.scrollTop(), 1));
      null === (_this$_rightButton = this._rightButton) || void 0 === _this$_rightButton || _this$_rightButton.option("disabled", isReachedBottom(renderer_default(scrollable.container()).get(0), scrollable.scrollTop(), 0, 1));
    } else {
      var _this$_leftButton2, _this$_rightButton2;
      null === (_this$_leftButton2 = this._leftButton) || void 0 === _this$_leftButton2 || _this$_leftButton2.option("disabled", isReachedLeft(scrollable.scrollLeft(), 1));
      null === (_this$_rightButton2 = this._rightButton) || void 0 === _this$_rightButton2 || _this$_rightButton2.option("disabled", isReachedRight(renderer_default(scrollable.container()).get(0), scrollable.scrollLeft(), 1));
    }
    this._updateNavButtonsAriaDisabled();
  },
  _updateScrollPosition(offset2, duration) {
    this._scrollable.update();
    this._scrollable.scrollBy(offset2 / duration);
  },
  _createNavButton(offset2, icon) {
    const holdAction = this._createAction(() => {
      this._holdInterval = setInterval(() => {
        this._updateScrollPosition(offset2, 5);
      }, 5);
    });
    const holdEventName = addNamespace2(hold_default.name, "dxNavButton");
    const pointerUpEventName = addNamespace2(pointer_default.up, "dxNavButton");
    const pointerOutEventName = addNamespace2(pointer_default.out, "dxNavButton");
    const navButton = this._createComponent(renderer_default("<div>").addClass("dx-tabs-nav-button"), button_default, {
      focusStateEnabled: false,
      icon,
      integrationOptions: {},
      elementAttr: {
        role: null,
        "aria-label": null,
        "aria-disabled": null
      },
      onClick: () => {
        this._updateScrollPosition(offset2, 1);
      }
    });
    const $navButton = navButton.$element();
    events_engine_default.on($navButton, holdEventName, {
      timeout: 300
    }, (e) => {
      holdAction({
        event: e
      });
    });
    events_engine_default.on($navButton, pointerUpEventName, () => {
      this._clearInterval();
    });
    events_engine_default.on($navButton, pointerOutEventName, () => {
      this._clearInterval();
    });
    return navButton;
  },
  _clearInterval() {
    if (this._holdInterval) {
      clearInterval(this._holdInterval);
    }
  },
  _updateSelection(addedSelection) {
    this._scrollable && this._scrollable.scrollToElement(this.itemElements().eq(addedSelection[0]));
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._dimensionChanged();
    }
  },
  _dimensionChanged() {
    this._renderScrolling();
  },
  _itemSelectHandler(e) {
    if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
      return;
    }
    this.callBase(e);
  },
  _clean() {
    this._deferredTemplates = [];
    this._cleanScrolling();
    this.callBase();
  },
  _toggleTabsVerticalClass(value2) {
    this.$element().toggleClass(TABS_ORIENTATION_CLASS.vertical, value2);
  },
  _toggleTabsHorizontalClass(value2) {
    this.$element().toggleClass(TABS_ORIENTATION_CLASS.horizontal, value2);
  },
  _getIndicatorPositionClass: (indicatorPosition) => INDICATOR_POSITION_CLASS[indicatorPosition],
  _getIndicatorPosition() {
    const {
      _indicatorPosition,
      rtlEnabled
    } = this.option();
    if (_indicatorPosition) {
      return _indicatorPosition;
    }
    const isVertical = this._isVertical();
    if (rtlEnabled) {
      return isVertical ? INDICATOR_POSITION.left : INDICATOR_POSITION.bottom;
    }
    return isVertical ? INDICATOR_POSITION.right : INDICATOR_POSITION.bottom;
  },
  _toggleIndicatorPositionClass(indicatorPosition) {
    const newClass = this._getIndicatorPositionClass(indicatorPosition);
    this._toggleElementClasses(INDICATOR_POSITION_CLASS, newClass);
  },
  _toggleScrollingEnabledClass(scrollingEnabled) {
    this.$element().toggleClass("dx-tabs-scrolling-enabled", Boolean(scrollingEnabled));
  },
  _toggleOrientationClass(orientation) {
    const isVertical = orientation === ORIENTATION.vertical;
    this._toggleTabsVerticalClass(isVertical);
    this._toggleTabsHorizontalClass(!isVertical);
  },
  _getTabsIconPositionClass() {
    const position3 = this.option("iconPosition");
    switch (position3) {
      case ICON_POSITION.top:
        return TABS_ICON_POSITION_CLASS.top;
      case ICON_POSITION.end:
        return TABS_ICON_POSITION_CLASS.end;
      case ICON_POSITION.bottom:
        return TABS_ICON_POSITION_CLASS.bottom;
      default:
        return TABS_ICON_POSITION_CLASS.start;
    }
  },
  _toggleIconPositionClass() {
    const newClass = this._getTabsIconPositionClass();
    this._toggleElementClasses(TABS_ICON_POSITION_CLASS, newClass);
  },
  _toggleStylingModeClass(value2) {
    const newClass = TABS_STYLING_MODE_CLASS[value2] ?? TABS_STYLING_MODE_CLASS.primary;
    this._toggleElementClasses(TABS_STYLING_MODE_CLASS, newClass);
  },
  _toggleElementClasses(classMap, newClass) {
    for (const key in classMap) {
      this.$element().removeClass(classMap[key]);
    }
    this.$element().addClass(newClass);
  },
  _toggleFocusedDisabledNextClass(currentIndex, isNextDisabled) {
    this._itemElements().eq(currentIndex).toggleClass("dx-focused-disabled-next-tab", isNextDisabled);
  },
  _toggleFocusedDisabledPrevClass(currentIndex, isPrevDisabled) {
    this._itemElements().eq(currentIndex).toggleClass("dx-focused-disabled-prev-tab", isPrevDisabled);
  },
  _toggleFocusedDisabledClasses(value2) {
    const {
      selectedIndex: currentIndex
    } = this.option();
    this._itemElements().removeClass("dx-focused-disabled-next-tab").removeClass("dx-focused-disabled-prev-tab");
    const prevItemIndex = currentIndex - 1;
    const nextItemIndex = currentIndex + 1;
    const nextFocusedIndex = renderer_default(value2).index();
    const isNextDisabled = this._itemElements().eq(nextItemIndex).hasClass("dx-state-disabled");
    const isPrevDisabled = this._itemElements().eq(prevItemIndex).hasClass("dx-state-disabled");
    const shouldNextClassBeSetted = isNextDisabled && nextFocusedIndex === nextItemIndex;
    const shouldPrevClassBeSetted = isPrevDisabled && nextFocusedIndex === prevItemIndex;
    this._toggleFocusedDisabledNextClass(currentIndex, shouldNextClassBeSetted);
    this._toggleFocusedDisabledPrevClass(currentIndex, shouldPrevClassBeSetted);
  },
  _updateFocusedElement() {
    const {
      focusStateEnabled,
      selectedIndex
    } = this.option();
    const itemElements = this._itemElements();
    if (focusStateEnabled && itemElements.length) {
      const selectedItem = itemElements.get(selectedIndex);
      this.option({
        focusedElement: selectedItem
      });
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "useInkRipple":
      case "scrollingEnabled":
        this._toggleScrollingEnabledClass(args.value);
        this._invalidate();
        break;
      case "showNavButtons":
      case "badgeExpr":
        this._invalidate();
        break;
      case "scrollByContent":
        this._scrollable && this._scrollable.option(args.name, args.value);
        break;
      case "width":
      case "height":
        this.callBase(args);
        this._dimensionChanged();
        break;
      case "selectionMode":
        this._renderMultiple();
        this.callBase(args);
        break;
      case "focusedElement":
        this._toggleFocusedDisabledClasses(args.value);
        this.callBase(args);
        this._scrollToItem(args.value);
        break;
      case "rtlEnabled": {
        this.callBase(args);
        const indicatorPosition = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(indicatorPosition);
        break;
      }
      case "orientation": {
        this._toggleOrientationClass(args.value);
        const indicatorPosition = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(indicatorPosition);
        if (hasWindow()) {
          this._updateScrollable();
        }
        break;
      }
      case "iconPosition":
        this._toggleIconPositionClass();
        if (hasWindow()) {
          this._dimensionChanged();
        }
        break;
      case "stylingMode":
        this._toggleStylingModeClass(args.value);
        if (hasWindow()) {
          this._dimensionChanged();
        }
        break;
      case "_indicatorPosition":
        this._toggleIndicatorPositionClass(args.value);
        break;
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
        this.callBase(args);
        this._updateFocusedElement();
        break;
      default:
        this.callBase(args);
    }
  },
  _afterItemElementInserted() {
    this.callBase();
    this._deferRenderScrolling();
  },
  _afterItemElementDeleted($item, deletedActionArgs) {
    this.callBase($item, deletedActionArgs);
    this._renderScrolling();
  },
  getScrollable() {
    return this._scrollable;
  }
});
Tabs.ItemClass = m_item_default3;
component_registrator_default("dxTabs", Tabs);
var m_tabs_default = Tabs;

// ../../../../../../node_modules/devextreme/esm/ui/tabs.js
var tabs_default = m_tabs_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tab_panel/m_item.js
var TabPanelItem = class extends m_item_default {
  _renderWatchers() {
    this._startWatcher("badge", noop2);
    return super._renderWatchers();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tab_panel/m_tab_panel.js
var TABPANEL_TABS_POSITION_CLASS = {
  top: "dx-tabpanel-tabs-position-top",
  right: "dx-tabpanel-tabs-position-right",
  bottom: "dx-tabpanel-tabs-position-bottom",
  left: "dx-tabpanel-tabs-position-left"
};
var TABS_POSITION = {
  top: "top",
  right: "right",
  bottom: "bottom",
  left: "left"
};
var TABS_INDICATOR_POSITION_BY_TABS_POSITION = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var TABS_ORIENTATION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var ICON_POSITION2 = {
  top: "top",
  end: "end",
  bottom: "bottom",
  start: "start"
};
var STYLING_MODE2 = {
  primary: "primary",
  secondary: "secondary"
};
var TabPanel = multi_view_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      itemTitleTemplate: "title",
      hoverStateEnabled: true,
      showNavButtons: false,
      scrollByContent: true,
      scrollingEnabled: true,
      tabsPosition: TABS_POSITION.top,
      iconPosition: ICON_POSITION2.start,
      stylingMode: STYLING_MODE2.primary,
      onTitleClick: null,
      onTitleHold: null,
      onTitleRendered: null,
      badgeExpr: (data2) => data2 ? data2.badge : void 0,
      _tabsIndicatorPosition: null
    });
  },
  _defaultOptionsRules() {
    const themeName = current();
    return this.callBase().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => !touch,
      options: {
        swipeEnabled: false
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        animationEnabled: false
      }
    }, {
      device: () => isFluent(themeName),
      options: {
        stylingMode: STYLING_MODE2.secondary
      }
    }, {
      device: () => isMaterialBased(themeName),
      options: {
        iconPosition: ICON_POSITION2.top
      }
    }]);
  },
  _init() {
    this.callBase();
    this.$element().addClass("dx-tabpanel");
    this._toggleTabPanelTabsPositionClass();
  },
  _getElementAria: () => ({
    role: "tabpanel"
  }),
  _getItemAria: () => ({
    role: "tabpanel"
  }),
  _initMarkup() {
    this.callBase();
    this._createTitleActions();
    this._renderLayout();
  },
  _prepareTabsItemTemplate(data2, $container) {
    const $iconElement = getImageContainer(null === data2 || void 0 === data2 ? void 0 : data2.icon);
    if ($iconElement) {
      $container.append($iconElement);
    }
    const title = isPlainObject(data2) ? null === data2 || void 0 === data2 ? void 0 : data2.title : data2;
    if (isDefined(title) && !isPlainObject(title)) {
      const $tabTextSpan = renderer_default("<span>").addClass("dx-tab-text-span");
      $tabTextSpan.append(dom_adapter_default.createTextNode(title));
      const $tabTextSpanPseudo = renderer_default("<span>").addClass("dx-tab-text-span-pseudo");
      $tabTextSpanPseudo.append(dom_adapter_default.createTextNode(title));
      $tabTextSpanPseudo.appendTo($tabTextSpan);
      $tabTextSpan.appendTo($container);
    }
  },
  _initTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      title: new BindableTemplate(($container, data2) => {
        this._prepareTabsItemTemplate(data2, $container);
        const $tabItem = renderer_default("<div>").addClass("dx-tab-text");
        $container.wrapInner($tabItem);
      }, ["title", "icon"], this.option("integrationOptions.watchMethod"))
    });
  },
  _createTitleActions() {
    this._createTitleClickAction();
    this._createTitleHoldAction();
    this._createTitleRenderedAction();
  },
  _createTitleClickAction() {
    this._titleClickAction = this._createActionByOption("onTitleClick");
  },
  _createTitleHoldAction() {
    this._titleHoldAction = this._createActionByOption("onTitleHold");
  },
  _createTitleRenderedAction() {
    this._titleRenderedAction = this._createActionByOption("onTitleRendered");
  },
  _renderLayout() {
    if (this._tabs) {
      return;
    }
    const $element = this.$element();
    this._$tabContainer = renderer_default("<div>").addClass("dx-tabpanel-tabs").appendTo($element);
    const $tabs = renderer_default("<div>").appendTo(this._$tabContainer);
    this._tabs = this._createComponent($tabs, tabs_default, this._tabConfig());
    this._$container = renderer_default("<div>").addClass("dx-tabpanel-container").appendTo($element);
    this._$container.append(this._$wrapper);
  },
  _refreshActiveDescendant() {
    if (!this._tabs) {
      return;
    }
    const tabs = this._tabs;
    const tabItems = tabs.itemElements();
    const $activeTab = renderer_default(tabItems[tabs.option("selectedIndex")]);
    const id = this.getFocusedItemId();
    this.setAria("controls", void 0, renderer_default(tabItems));
    this.setAria("controls", id, $activeTab);
  },
  _getTabsIndicatorPosition() {
    const {
      _tabsIndicatorPosition,
      tabsPosition
    } = this.option();
    return _tabsIndicatorPosition ?? TABS_INDICATOR_POSITION_BY_TABS_POSITION[tabsPosition];
  },
  _tabConfig() {
    const tabsIndicatorPosition = this._getTabsIndicatorPosition();
    return {
      selectOnFocus: true,
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      repaintChangesOnly: this.option("repaintChangesOnly"),
      tabIndex: this.option("tabIndex"),
      selectedIndex: this.option("selectedIndex"),
      badgeExpr: this.option("badgeExpr"),
      onItemClick: this._titleClickAction.bind(this),
      onItemHold: this._titleHoldAction.bind(this),
      itemHoldTimeout: this.option("itemHoldTimeout"),
      onSelectionChanged: (function(e) {
        this.option("selectedIndex", e.component.option("selectedIndex"));
        this._refreshActiveDescendant();
      }).bind(this),
      onItemRendered: this._titleRenderedAction.bind(this),
      itemTemplate: this._getTemplateByOption("itemTitleTemplate"),
      items: this.option("items"),
      noDataText: null,
      scrollingEnabled: this.option("scrollingEnabled"),
      scrollByContent: this.option("scrollByContent"),
      showNavButtons: this.option("showNavButtons"),
      itemTemplateProperty: "tabTemplate",
      loopItemFocus: this.option("loop"),
      selectionRequired: true,
      onOptionChanged: (function(args) {
        if ("focusedElement" === args.name) {
          if (args.value) {
            const $value = renderer_default(args.value);
            const $newItem = this._itemElements().eq($value.index());
            this.option("focusedElement", getPublicElement($newItem));
          } else {
            this.option("focusedElement", args.value);
          }
        }
      }).bind(this),
      onFocusIn: (function(args) {
        this._focusInHandler(args.event);
      }).bind(this),
      onFocusOut: (function(args) {
        if (!this._isFocusOutHandlerExecuting) {
          this._focusOutHandler(args.event);
        }
      }).bind(this),
      orientation: this._getTabsOrientation(),
      iconPosition: this.option("iconPosition"),
      stylingMode: this.option("stylingMode"),
      _itemAttributes: {
        class: "dx-tabpanel-tab"
      },
      _indicatorPosition: tabsIndicatorPosition
    };
  },
  _renderFocusTarget() {
    this._focusTarget().attr("tabIndex", -1);
  },
  _getTabsOrientation() {
    const {
      tabsPosition
    } = this.option();
    if ([TABS_POSITION.right, TABS_POSITION.left].includes(tabsPosition)) {
      return TABS_ORIENTATION.vertical;
    }
    return TABS_ORIENTATION.horizontal;
  },
  _getTabPanelTabsPositionClass() {
    const position3 = this.option("tabsPosition");
    switch (position3) {
      case TABS_POSITION.right:
        return TABPANEL_TABS_POSITION_CLASS.right;
      case TABS_POSITION.bottom:
        return TABPANEL_TABS_POSITION_CLASS.bottom;
      case TABS_POSITION.left:
        return TABPANEL_TABS_POSITION_CLASS.left;
      case TABS_POSITION.top:
      default:
        return TABPANEL_TABS_POSITION_CLASS.top;
    }
  },
  _toggleTabPanelTabsPositionClass() {
    for (const key in TABPANEL_TABS_POSITION_CLASS) {
      this.$element().removeClass(TABPANEL_TABS_POSITION_CLASS[key]);
    }
    const newClass = this._getTabPanelTabsPositionClass();
    this.$element().addClass(newClass);
  },
  _updateTabsOrientation() {
    const orientation = this._getTabsOrientation();
    this._setTabsOption("orientation", orientation);
  },
  _toggleWrapperFocusedClass(isFocused) {
    this._toggleFocusClass(isFocused, this._$wrapper);
  },
  _toggleDisabledFocusedClass(isFocused) {
    this._focusTarget().toggleClass("dx-disabled-focused-tab", isFocused);
  },
  _updateFocusState(e, isFocused) {
    this.callBase(e, isFocused);
    const isTabsTarget = e.target === this._tabs._focusTarget().get(0);
    const isMultiViewTarget = e.target === this._focusTarget().get(0);
    if (isTabsTarget) {
      this._toggleFocusClass(isFocused, this._focusTarget());
    }
    if (isTabsTarget || isMultiViewTarget) {
      const isDisabled = this._isDisabled(this.option("focusedElement"));
      this._toggleWrapperFocusedClass(isFocused && !isDisabled);
      this._toggleDisabledFocusedClass(isFocused && isDisabled);
    }
    if (isMultiViewTarget) {
      this._toggleFocusClass(isFocused, this._tabs.option("focusedElement"));
    }
  },
  _focusOutHandler(e) {
    this._isFocusOutHandlerExecuting = true;
    this.callBase.apply(this, arguments);
    this._tabs._focusOutHandler(e);
    this._isFocusOutHandlerExecuting = false;
  },
  _setTabsOption(name2, value2) {
    if (this._tabs) {
      this._tabs.option(name2, value2);
    }
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this._tabs._dimensionChanged();
    }
  },
  registerKeyHandler(key, handler) {
    this.callBase(key, handler);
    if (this._tabs) {
      this._tabs.registerKeyHandler(key, handler);
    }
  },
  repaint() {
    this.callBase();
    this._tabs.repaint();
  },
  _updateTabsIndicatorPosition() {
    const value2 = this._getTabsIndicatorPosition();
    this._setTabsOption("_indicatorPosition", value2);
  },
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      fullName
    } = args;
    switch (name2) {
      case "dataSource":
      default:
        this.callBase(args);
        break;
      case "items":
        this._setTabsOption(name2, this.option(name2));
        if (!this.option("repaintChangesOnly")) {
          this._tabs.repaint();
        }
        this.callBase(args);
        break;
      case "width":
        this.callBase(args);
        this._tabs.repaint();
        break;
      case "selectedIndex":
      case "selectedItem":
        this._setTabsOption(fullName, value2);
        this.callBase(args);
        if (true === this.option("focusStateEnabled")) {
          const selectedIndex = this.option("selectedIndex");
          const selectedTabContent = this._itemElements().eq(selectedIndex);
          this.option("focusedElement", getPublicElement(selectedTabContent));
        }
        break;
      case "itemHoldTimeout":
      case "focusStateEnabled":
      case "hoverStateEnabled":
        this._setTabsOption(fullName, value2);
        this.callBase(args);
        break;
      case "scrollingEnabled":
      case "scrollByContent":
      case "showNavButtons":
        this._setTabsOption(fullName, value2);
        break;
      case "focusedElement": {
        const id = value2 ? renderer_default(value2).index() : value2;
        const newItem = value2 ? this._tabs._itemElements().eq(id) : value2;
        this._setTabsOption("focusedElement", getPublicElement(newItem));
        if (value2) {
          const isDisabled = this._isDisabled(value2);
          this._toggleWrapperFocusedClass(!isDisabled);
          this._toggleDisabledFocusedClass(isDisabled);
        }
        this.callBase(args);
        break;
      }
      case "itemTitleTemplate":
        this._setTabsOption("itemTemplate", this._getTemplateByOption("itemTitleTemplate"));
        break;
      case "onTitleClick":
        this._createTitleClickAction();
        this._setTabsOption("onItemClick", this._titleClickAction.bind(this));
        break;
      case "onTitleHold":
        this._createTitleHoldAction();
        this._setTabsOption("onItemHold", this._titleHoldAction.bind(this));
        break;
      case "onTitleRendered":
        this._createTitleRenderedAction();
        this._setTabsOption("onItemRendered", this._titleRenderedAction.bind(this));
        break;
      case "loop":
        this._setTabsOption("loopItemFocus", value2);
        break;
      case "badgeExpr":
        this._invalidate();
        break;
      case "tabsPosition":
        this._toggleTabPanelTabsPositionClass();
        this._updateTabsIndicatorPosition();
        this._updateTabsOrientation();
        break;
      case "iconPosition":
        this._setTabsOption("iconPosition", value2);
        break;
      case "stylingMode":
        this._setTabsOption("stylingMode", value2);
        break;
      case "_tabsIndicatorPosition":
        this._setTabsOption("_indicatorPosition", value2);
    }
  }
});
TabPanel.ItemClass = TabPanelItem;
component_registrator_default("dxTabPanel", TabPanel);
var m_tab_panel_default = TabPanel;

// ../../../../../../node_modules/devextreme/esm/ui/tab_panel.js
var tab_panel_default = m_tab_panel_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.item_option_action.js
var ItemOptionAction = class {
  constructor(options2) {
    this._options = options2;
    this._itemsRunTimeInfo = this._options.itemsRunTimeInfo;
  }
  findInstance() {
    return this._itemsRunTimeInfo.findWidgetInstanceByItem(this._options.item);
  }
  findItemContainer() {
    return this._itemsRunTimeInfo.findItemContainerByItem(this._options.item);
  }
  findPreparedItem() {
    return this._itemsRunTimeInfo.findPreparedItemByItem(this._options.item);
  }
  tryExecute() {
    class_default.abstract();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.utils.js
var createItemPathByIndex = (index2, isTabs) => `${isTabs ? "tabs" : "items"}[${index2}]`;
var concatPaths = (path1, path2) => {
  if (isDefined(path1) && isDefined(path2)) {
    return `${path1}.${path2}`;
  }
  return path1 || path2;
};
var getTextWithoutSpaces = (text) => text ? text.replace(/\s/g, "") : void 0;
var isEqualToDataFieldOrNameOrTitleOrCaption = (item, fieldName) => {
  if (item) {
    return item.dataField === fieldName || item.name === fieldName || getTextWithoutSpaces(item.title) === fieldName || "group" === item.itemType && getTextWithoutSpaces(item.caption) === fieldName;
  }
  return false;
};
var getFullOptionName = (path, optionName) => `${path}.${optionName}`;
var getOptionNameFromFullName = (fullName) => {
  const parts = fullName.split(".");
  return parts[parts.length - 1].replace(/\[\d+]/, "");
};
var tryGetTabPath = (fullPath) => {
  const pathParts = fullPath.split(".");
  const resultPathParts = [...pathParts];
  for (let i = pathParts.length - 1; i >= 0; i--) {
    if (isFullPathContainsTabs(pathParts[i])) {
      return resultPathParts.join(".");
    }
    resultPathParts.splice(i, 1);
  }
  return "";
};
var isFullPathContainsTabs = (fullPath) => fullPath.indexOf("tabs") > -1;
var getItemPath = (items, item, isTabs) => {
  const index2 = items.indexOf(item);
  if (index2 > -1) {
    return createItemPathByIndex(index2, isTabs);
  }
  for (let i = 0; i < items.length; i++) {
    const targetItem = items[i];
    const tabOrGroupItems = targetItem.tabs || targetItem.items;
    if (tabOrGroupItems) {
      const itemPath = getItemPath(tabOrGroupItems, item, targetItem.tabs);
      if (itemPath) {
        return concatPaths(createItemPathByIndex(i, isTabs), itemPath);
      }
    }
  }
};
function convertToLayoutManagerOptions(_ref) {
  let {
    form,
    $formElement,
    formOptions,
    items,
    validationGroup,
    extendedLayoutManagerOptions,
    onFieldDataChanged,
    onContentReady,
    onDisposing,
    onFieldItemRendered
  } = _ref;
  const baseOptions = {
    form,
    items,
    $formElement,
    validationGroup,
    onFieldDataChanged,
    onContentReady,
    onDisposing,
    onFieldItemRendered,
    validationBoundary: formOptions.scrollingEnabled ? $formElement : void 0,
    scrollingEnabled: formOptions.scrollingEnabled,
    showRequiredMark: formOptions.showRequiredMark,
    showOptionalMark: formOptions.showOptionalMark,
    requiredMark: formOptions.requiredMark,
    optionalMark: formOptions.optionalMark,
    requiredMessage: formOptions.requiredMessage,
    screenByWidth: formOptions.screenByWidth,
    layoutData: formOptions.formData,
    labelLocation: formOptions.labelLocation,
    customizeItem: formOptions.customizeItem,
    minColWidth: formOptions.minColWidth,
    showColonAfterLabel: formOptions.showColonAfterLabel,
    onEditorEnterKey: formOptions.onEditorEnterKey,
    labelMode: formOptions.labelMode
  };
  const result2 = extend(baseOptions, {
    isRoot: extendedLayoutManagerOptions.isRoot,
    colCount: extendedLayoutManagerOptions.colCount,
    alignItemLabels: extendedLayoutManagerOptions.alignItemLabels,
    cssItemClass: extendedLayoutManagerOptions.cssItemClass,
    colCountByScreen: extendedLayoutManagerOptions.colCountByScreen,
    onLayoutChanged: extendedLayoutManagerOptions.onLayoutChanged,
    width: extendedLayoutManagerOptions.width
  });
  return result2;
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.item_options_actions.js
var WidgetOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const {
      value: value2
    } = this._options;
    const instance = this.findInstance();
    if (instance) {
      instance.option(value2);
      return true;
    }
    return false;
  }
};
var TabOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const tabPanel = this.findInstance();
    if (tabPanel) {
      const {
        optionName,
        item,
        value: value2
      } = this._options;
      const itemIndex = this._itemsRunTimeInfo.findItemIndexByItem(item);
      if (itemIndex >= 0) {
        tabPanel.option(getFullOptionName(`items[${itemIndex}]`, optionName), value2);
        return true;
      }
    }
    return false;
  }
};
var SimpleItemTemplateChangedAction = class extends ItemOptionAction {
  tryExecute() {
    return false;
  }
};
var GroupItemTemplateChangedAction = class extends ItemOptionAction {
  tryExecute() {
    const preparedItem = this.findPreparedItem();
    if (null != preparedItem && preparedItem._prepareGroupItemTemplate && preparedItem._renderGroupContentTemplate) {
      preparedItem._prepareGroupItemTemplate(this._options.item.template);
      preparedItem._renderGroupContentTemplate();
      return true;
    }
    return false;
  }
};
var TabsOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const tabPanel = this.findInstance();
    if (tabPanel) {
      const {
        value: value2
      } = this._options;
      tabPanel.option("dataSource", value2);
      return true;
    }
    return false;
  }
};
var ValidationRulesItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const {
      item
    } = this._options;
    const instance = this.findInstance();
    const validator = instance && data(instance.$element()[0], "dxValidator");
    if (validator && item) {
      const filterRequired = (item2) => "required" === item2.type;
      const oldContainsRequired = (validator.option("validationRules") || []).some(filterRequired);
      const newContainsRequired = (item.validationRules || []).some(filterRequired);
      if (!oldContainsRequired && !newContainsRequired || oldContainsRequired && newContainsRequired) {
        validator.option("validationRules", item.validationRules);
        return true;
      }
    }
    return false;
  }
};
var CssClassItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const $itemContainer = this.findItemContainer();
    const {
      previousValue,
      value: value2
    } = this._options;
    if ($itemContainer) {
      $itemContainer.removeClass(previousValue).addClass(value2);
      return true;
    }
    return false;
  }
};
var tryCreateItemOptionAction = (optionName, itemActionOptions) => {
  switch (optionName) {
    case "editorOptions":
    case "buttonOptions":
      return new WidgetOptionItemOptionAction(itemActionOptions);
    case "validationRules":
      return new ValidationRulesItemOptionAction(itemActionOptions);
    case "cssClass":
      return new CssClassItemOptionAction(itemActionOptions);
    case "badge":
    case "disabled":
    case "icon":
    case "tabTemplate":
    case "title":
      return new TabOptionItemOptionAction(extend(itemActionOptions, {
        optionName
      }));
    case "tabs":
      return new TabsOptionItemOptionAction(itemActionOptions);
    case "template": {
      var _itemActionOptions$it, _itemActionOptions$it2;
      const itemType = (null === itemActionOptions || void 0 === itemActionOptions || null === (_itemActionOptions$it = itemActionOptions.item) || void 0 === _itemActionOptions$it ? void 0 : _itemActionOptions$it.itemType) ?? (null === (_itemActionOptions$it2 = itemActionOptions.itemsRunTimeInfo.findPreparedItemByItem(null === itemActionOptions || void 0 === itemActionOptions ? void 0 : itemActionOptions.item)) || void 0 === _itemActionOptions$it2 ? void 0 : _itemActionOptions$it2.itemType);
      if ("simple" === itemType) {
        return new SimpleItemTemplateChangedAction(itemActionOptions);
      }
      if ("group" === itemType) {
        return new GroupItemTemplateChangedAction(itemActionOptions);
      }
      return new TabOptionItemOptionAction(extend(itemActionOptions, {
        optionName
      }));
    }
    default:
      return null;
  }
};
var m_form_item_options_actions_default = tryCreateItemOptionAction;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/form/m_form.js
var ITEM_OPTIONS_FOR_VALIDATION_UPDATING = ["items", "isRequired", "validationRules", "visible"];
var Form = ui_widget_default.inherit({
  _init() {
    this.callBase();
    this._dirtyFields = /* @__PURE__ */ new Set();
    this._cachedColCountOptions = [];
    this._itemsRunTimeInfo = new FormItemsRunTimeInfo();
    this._groupsColCount = [];
    this._attachSyncSubscriptions();
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      formID: `dx-${new guid_default()}`,
      formData: {},
      colCount: 1,
      screenByWidth: defaultScreenFactorFunc,
      colCountByScreen: void 0,
      labelLocation: "left",
      readOnly: false,
      onFieldDataChanged: null,
      customizeItem: null,
      onEditorEnterKey: null,
      minColWidth: 200,
      alignItemLabels: true,
      alignItemLabelsInAllGroups: true,
      alignRootItemLabels: true,
      showColonAfterLabel: true,
      showRequiredMark: true,
      showOptionalMark: false,
      requiredMark: "*",
      optionalMark: message_default.format("dxForm-optionalMark"),
      requiredMessage: message_default.getFormatter("dxForm-requiredMessage"),
      showValidationSummary: false,
      items: void 0,
      scrollingEnabled: false,
      validationGroup: void 0,
      stylingMode: config_default().editorStylingMode,
      labelMode: "outside",
      isDirty: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => isMaterialBased(),
      options: {
        labelLocation: "top"
      }
    }, {
      device: () => isMaterial(),
      options: {
        showColonAfterLabel: false
      }
    }]);
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      formData: true,
      validationGroup: true
    });
  },
  _getGroupColCount: ($element) => parseInt($element.attr(GROUP_COL_COUNT_ATTR)),
  _applyLabelsWidthByCol($container, index2) {
    let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    let labelMarkOptions = arguments.length > 3 ? arguments[3] : void 0;
    const fieldItemClass = options2.inOneColumn ? FIELD_ITEM_CLASS : FORM_FIELD_ITEM_COL_CLASS + index2;
    const cssExcludeTabbedSelector = options2.excludeTabbed ? `:not(.${FIELD_ITEM_TAB_CLASS})` : "";
    setLabelWidthByMaxLabelWidth($container, `.${fieldItemClass}${cssExcludeTabbedSelector}`, labelMarkOptions);
  },
  _applyLabelsWidth($container, excludeTabbed, inOneColumn, colCount, labelMarkOptions) {
    colCount = inOneColumn ? 1 : colCount || this._getGroupColCount($container);
    const applyLabelsOptions = {
      excludeTabbed,
      inOneColumn
    };
    let i;
    for (i = 0; i < colCount; i++) {
      this._applyLabelsWidthByCol($container, i, applyLabelsOptions, labelMarkOptions);
    }
  },
  _getGroupElementsInColumn($container, columnIndex, colCount) {
    const cssColCountSelector = isDefined(colCount) ? `.${GROUP_COL_COUNT_CLASS}${colCount}` : "";
    const groupSelector = `.${FORM_FIELD_ITEM_COL_CLASS}${columnIndex} > .${FIELD_ITEM_CONTENT_CLASS} > .${FORM_GROUP_CLASS}${cssColCountSelector}`;
    return $container.find(groupSelector);
  },
  _applyLabelsWidthWithGroups($container, colCount, excludeTabbed, labelMarkOptions) {
    if (true === this.option("alignRootItemLabels")) {
      const $rootSimpleItems = $container.find(`.${ROOT_SIMPLE_ITEM_CLASS}`);
      for (let colIndex = 0; colIndex < colCount; colIndex++) {
        this._applyLabelsWidthByCol($rootSimpleItems, colIndex, excludeTabbed, labelMarkOptions);
      }
    }
    const alignItemLabelsInAllGroups = this.option("alignItemLabelsInAllGroups");
    if (alignItemLabelsInAllGroups) {
      this._applyLabelsWidthWithNestedGroups($container, colCount, excludeTabbed, labelMarkOptions);
    } else {
      const $groups = this.$element().find(`.${FORM_GROUP_CLASS}`);
      let i;
      for (i = 0; i < $groups.length; i++) {
        this._applyLabelsWidth($groups.eq(i), excludeTabbed, void 0, void 0, labelMarkOptions);
      }
    }
  },
  _applyLabelsWidthWithNestedGroups($container, colCount, excludeTabbed, labelMarkOptions) {
    const applyLabelsOptions = {
      excludeTabbed
    };
    let colIndex;
    let groupsColIndex;
    let groupColIndex;
    let $groupsByCol;
    for (colIndex = 0; colIndex < colCount; colIndex++) {
      $groupsByCol = this._getGroupElementsInColumn($container, colIndex);
      this._applyLabelsWidthByCol($groupsByCol, 0, applyLabelsOptions, labelMarkOptions);
      for (groupsColIndex = 0; groupsColIndex < this._groupsColCount.length; groupsColIndex++) {
        $groupsByCol = this._getGroupElementsInColumn($container, colIndex, this._groupsColCount[groupsColIndex]);
        const groupColCount = this._getGroupColCount($groupsByCol);
        for (groupColIndex = 1; groupColIndex < groupColCount; groupColIndex++) {
          this._applyLabelsWidthByCol($groupsByCol, groupColIndex, applyLabelsOptions, labelMarkOptions);
        }
      }
    }
  },
  _labelLocation() {
    return this.option("labelLocation");
  },
  _alignLabelsInColumn(_ref) {
    let {
      layoutManager,
      inOneColumn,
      $container,
      excludeTabbed,
      items
    } = _ref;
    if (!hasWindow() || "top" === this._labelLocation()) {
      return;
    }
    const labelMarkOptions = convertToLabelMarkOptions(layoutManager._getMarkOptions());
    if (inOneColumn) {
      this._applyLabelsWidth($container, excludeTabbed, true, void 0, labelMarkOptions);
    } else if (this._checkGrouping(items)) {
      this._applyLabelsWidthWithGroups($container, layoutManager._getColCount(), excludeTabbed, labelMarkOptions);
    } else {
      this._applyLabelsWidth($container, excludeTabbed, false, layoutManager._getColCount(), labelMarkOptions);
    }
  },
  _prepareFormData() {
    if (!isDefined(this.option("formData"))) {
      this.option("formData", {});
    }
  },
  _setStylingModeClass() {
    if ("underlined" === this.option("stylingMode")) {
      this.$element().addClass(FORM_UNDERLINED_CLASS);
    }
  },
  _initMarkup() {
    validation_engine_default.addGroup(this._getValidationGroup(), false);
    this._clearCachedInstances();
    this._prepareFormData();
    this.$element().addClass(FORM_CLASS);
    this._setStylingModeClass();
    this.callBase();
    this.setAria("role", "form", this.$element());
    if (this.option("scrollingEnabled")) {
      this._renderScrollable();
    }
    this._renderLayout();
    this._renderValidationSummary();
    this._lastMarkupScreenFactor = this._targetScreenFactor || this._getCurrentScreenFactor();
    this._attachResizeObserverSubscription();
  },
  _attachResizeObserverSubscription() {
    if (hasWindow()) {
      const formRootElement = this.$element().get(0);
      resize_observer_default.unobserve(formRootElement);
      resize_observer_default.observe(formRootElement, () => {
        this._resizeHandler();
      });
    }
  },
  _resizeHandler() {
    if (this._cachedLayoutManagers.length) {
      each(this._cachedLayoutManagers, (_, layoutManager) => {
        var _layoutManager$option;
        null === (_layoutManager$option = layoutManager.option("onLayoutChanged")) || void 0 === _layoutManager$option || _layoutManager$option(layoutManager.isSingleColumnMode());
      });
    }
  },
  _getCurrentScreenFactor() {
    return hasWindow() ? getCurrentScreenFactor(this.option("screenByWidth")) : "lg";
  },
  _clearCachedInstances() {
    this._itemsRunTimeInfo.clear();
    this._cachedLayoutManagers = [];
  },
  _alignLabels(layoutManager, inOneColumn) {
    this._alignLabelsInColumn({
      $container: this.$element(),
      layoutManager,
      excludeTabbed: true,
      items: this.option("items"),
      inOneColumn
    });
    triggerResizeEvent(this.$element().find(`.${TOOLBAR_CLASS}`));
  },
  _clean() {
    this._clearValidationSummary();
    this.callBase();
    this._groupsColCount = [];
    this._cachedColCountOptions = [];
    this._lastMarkupScreenFactor = void 0;
    resize_observer_default.unobserve(this.$element().get(0));
  },
  _renderScrollable() {
    const useNativeScrolling = this.option("useNativeScrolling");
    this._scrollable = new ui_scrollable_default(this.$element(), {
      useNative: !!useNativeScrolling,
      useSimulatedScrollbar: !useNativeScrolling,
      useKeyboard: false,
      direction: "both",
      bounceEnabled: false
    });
  },
  _getContent() {
    return this.option("scrollingEnabled") ? renderer_default(this._scrollable.content()) : this.$element();
  },
  _clearValidationSummary() {
    var _this$_$validationSum;
    null === (_this$_$validationSum = this._$validationSummary) || void 0 === _this$_$validationSum || _this$_$validationSum.remove();
    this._$validationSummary = void 0;
    this._validationSummary = void 0;
  },
  _renderValidationSummary() {
    this._clearValidationSummary();
    if (this.option("showValidationSummary")) {
      this._$validationSummary = renderer_default("<div>").addClass(FORM_VALIDATION_SUMMARY).appendTo(this._getContent());
      this._validationSummary = this._$validationSummary.dxValidationSummary({
        validationGroup: this._getValidationGroup()
      }).dxValidationSummary("instance");
    }
  },
  _prepareItems(items, parentIsTabbedItem, currentPath, isTabs) {
    if (items) {
      const result2 = [];
      for (let i = 0; i < items.length; i++) {
        let item = items[i];
        const path = concatPaths(currentPath, createItemPathByIndex(i, isTabs));
        const itemRunTimeInfo = {
          item,
          itemIndex: i,
          path
        };
        const guid2 = this._itemsRunTimeInfo.add(itemRunTimeInfo);
        if (isString(item)) {
          item = {
            dataField: item
          };
        }
        if (isObject(item)) {
          const preparedItem = _extends({}, item);
          itemRunTimeInfo.preparedItem = preparedItem;
          preparedItem.guid = guid2;
          this._tryPrepareGroupItemCaption(preparedItem);
          this._tryPrepareGroupItem(preparedItem);
          this._tryPrepareTabbedItem(preparedItem, path);
          this._tryPrepareItemTemplate(preparedItem);
          if (parentIsTabbedItem) {
            preparedItem.cssItemClass = FIELD_ITEM_TAB_CLASS;
          }
          if (preparedItem.items) {
            preparedItem.items = this._prepareItems(preparedItem.items, parentIsTabbedItem, path);
          }
          result2.push(preparedItem);
        } else {
          result2.push(item);
        }
      }
      return result2;
    }
  },
  _tryPrepareGroupItemCaption(item) {
    if ("group" === item.itemType) {
      item._prepareGroupCaptionTemplate = (captionTemplate) => {
        if (item.captionTemplate) {
          item.groupCaptionTemplate = this._getTemplate(captionTemplate);
        }
        item.captionTemplate = this._itemGroupTemplate.bind(this, item);
      };
      item._prepareGroupCaptionTemplate(item.captionTemplate);
    }
  },
  _tryPrepareGroupItem(item) {
    if ("group" === item.itemType) {
      item.alignItemLabels = ensureDefined(item.alignItemLabels, true);
      item._prepareGroupItemTemplate = (itemTemplate) => {
        if (item.template) {
          item.groupContentTemplate = this._getTemplate(itemTemplate);
        }
        item.template = this._itemGroupTemplate.bind(this, item);
      };
      item._prepareGroupItemTemplate(item.template);
    }
  },
  _tryPrepareTabbedItem(item, path) {
    if ("tabbed" === item.itemType) {
      item.template = this._itemTabbedTemplate.bind(this, item);
      item.tabs = this._prepareItems(item.tabs, true, path, true);
    }
  },
  _tryPrepareItemTemplate(item) {
    if (item.template) {
      item.template = this._getTemplate(item.template);
    }
  },
  _checkGrouping(items) {
    if (items) {
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if ("group" === item.itemType) {
          return true;
        }
      }
    }
  },
  _renderLayout() {
    const that = this;
    let items = that.option("items");
    const $content = that._getContent();
    items = that._prepareItems(items);
    that._rootLayoutManager = that._renderLayoutManager($content, this._createLayoutManagerOptions(items, {
      isRoot: true,
      colCount: that.option("colCount"),
      alignItemLabels: that.option("alignItemLabels"),
      screenByWidth: this.option("screenByWidth"),
      colCountByScreen: this.option("colCountByScreen"),
      onLayoutChanged(inOneColumn) {
        that._alignLabels.bind(that)(that._rootLayoutManager, inOneColumn);
      },
      onContentReady(e) {
        that._alignLabels(e.component, e.component.isSingleColumnMode());
      }
    }));
  },
  _tryGetItemsForTemplate: (item) => item.items || [],
  _itemTabbedTemplate(item, e, $container) {
    const $tabPanel = renderer_default("<div>").appendTo($container);
    const tabPanelOptions = extend({}, item.tabPanelOptions, {
      dataSource: item.tabs,
      onItemRendered: (args) => {
        var _item$tabPanelOptions, _item$tabPanelOptions2;
        null === (_item$tabPanelOptions = item.tabPanelOptions) || void 0 === _item$tabPanelOptions || null === (_item$tabPanelOptions2 = _item$tabPanelOptions.onItemRendered) || void 0 === _item$tabPanelOptions2 || _item$tabPanelOptions2.call(_item$tabPanelOptions, args);
        triggerShownEvent(args.itemElement);
      },
      itemTemplate: (itemData, e2, container) => {
        const $container2 = renderer_default(container);
        const alignItemLabels = ensureDefined(itemData.alignItemLabels, true);
        const layoutManager = this._renderLayoutManager($container2, this._createLayoutManagerOptions(this._tryGetItemsForTemplate(itemData), {
          colCount: itemData.colCount,
          alignItemLabels,
          screenByWidth: this.option("screenByWidth"),
          colCountByScreen: itemData.colCountByScreen,
          cssItemClass: itemData.cssItemClass,
          onLayoutChanged: (inOneColumn) => {
            this._alignLabelsInColumn({
              $container: $container2,
              layoutManager,
              items: itemData.items,
              inOneColumn
            });
          }
        }));
        if (this._itemsRunTimeInfo) {
          this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(itemData.guid, {
            layoutManager
          });
        }
        if (alignItemLabels) {
          this._alignLabelsInColumn({
            $container: $container2,
            layoutManager,
            items: itemData.items,
            inOneColumn: layoutManager.isSingleColumnMode()
          });
        }
      }
    });
    const tryUpdateTabPanelInstance = (items, instance) => {
      if (Array.isArray(items)) {
        items.forEach((item2) => this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(item2.guid, {
          widgetInstance: instance
        }));
      }
    };
    const tabPanel = this._createComponent($tabPanel, tab_panel_default, tabPanelOptions);
    renderer_default($container).parent().addClass(FIELD_ITEM_CONTENT_HAS_TABS_CLASS);
    tabPanel.on("optionChanged", (e2) => {
      if ("dataSource" === e2.fullName) {
        tryUpdateTabPanelInstance(e2.value, e2.component);
      }
    });
    tryUpdateTabPanelInstance([{
      guid: item.guid
    }, ...item.tabs ?? []], tabPanel);
  },
  _itemGroupCaptionTemplate(item, $group, id) {
    if (item.groupCaptionTemplate) {
      const $captionTemplate = renderer_default("<div>").addClass(FORM_GROUP_CUSTOM_CAPTION_CLASS).attr("id", id).appendTo($group);
      item._renderGroupCaptionTemplate = () => {
        const data2 = {
          component: this,
          caption: item.caption,
          name: item.name
        };
        item.groupCaptionTemplate.render({
          model: data2,
          container: getPublicElement($captionTemplate)
        });
      };
      item._renderGroupCaptionTemplate();
      return;
    }
    if (item.caption) {
      renderer_default("<span>").addClass(FORM_GROUP_CAPTION_CLASS).text(item.caption).attr("id", id).appendTo($group);
    }
  },
  _itemGroupContentTemplate(item, $group) {
    const $groupContent = renderer_default("<div>").addClass(FORM_GROUP_CONTENT_CLASS).appendTo($group);
    if (item.groupContentTemplate) {
      item._renderGroupContentTemplate = () => {
        $groupContent.empty();
        const data2 = {
          formData: this.option("formData"),
          component: this
        };
        item.groupContentTemplate.render({
          model: data2,
          container: getPublicElement($groupContent)
        });
      };
      item._renderGroupContentTemplate();
    } else {
      const layoutManager = this._renderLayoutManager($groupContent, this._createLayoutManagerOptions(this._tryGetItemsForTemplate(item), {
        colCount: item.colCount,
        colCountByScreen: item.colCountByScreen,
        alignItemLabels: item.alignItemLabels,
        cssItemClass: item.cssItemClass
      }));
      this._itemsRunTimeInfo && this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(item.guid, {
        layoutManager
      });
      const colCount = layoutManager._getColCount();
      if (!this._groupsColCount.includes(colCount)) {
        this._groupsColCount.push(colCount);
      }
      $group.addClass(GROUP_COL_COUNT_CLASS + colCount);
      $group.attr(GROUP_COL_COUNT_ATTR, colCount);
    }
  },
  _itemGroupTemplate(item, options2, $container) {
    const {
      id
    } = options2.editorOptions.inputAttr;
    const $group = renderer_default("<div>").toggleClass(FORM_GROUP_WITH_CAPTION_CLASS, isDefined(item.caption) && item.caption.length).addClass(FORM_GROUP_CLASS).appendTo($container);
    const groupAria = {
      role: "group",
      labelledby: id
    };
    this.setAria(groupAria, $group);
    renderer_default($container).parent().addClass(FIELD_ITEM_CONTENT_HAS_GROUP_CLASS);
    this._itemGroupCaptionTemplate(item, $group, id);
    this._itemGroupContentTemplate(item, $group);
  },
  _createLayoutManagerOptions(items, extendedLayoutManagerOptions) {
    return convertToLayoutManagerOptions({
      form: this,
      formOptions: this.option(),
      $formElement: this.$element(),
      items,
      validationGroup: this._getValidationGroup(),
      extendedLayoutManagerOptions,
      onFieldDataChanged: (args) => {
        if (!this._isDataUpdating) {
          this._triggerOnFieldDataChanged(args);
        }
      },
      onContentReady: (args) => {
        this._itemsRunTimeInfo.addItemsOrExtendFrom(args.component._itemsRunTimeInfo);
        extendedLayoutManagerOptions.onContentReady && extendedLayoutManagerOptions.onContentReady(args);
      },
      onDisposing: (_ref2) => {
        let {
          component
        } = _ref2;
        const nestedItemsRunTimeInfo = component.getItemsRunTimeInfo();
        this._itemsRunTimeInfo.removeItemsByItems(nestedItemsRunTimeInfo);
      },
      onFieldItemRendered: () => {
        var _this$_validationSumm;
        null === (_this$_validationSumm = this._validationSummary) || void 0 === _this$_validationSumm || _this$_validationSumm.refreshValidationGroup();
      }
    });
  },
  _renderLayoutManager($parent, layoutManagerOptions) {
    const baseColCountByScreen = {
      lg: layoutManagerOptions.colCount,
      md: layoutManagerOptions.colCount,
      sm: layoutManagerOptions.colCount,
      xs: 1
    };
    this._cachedColCountOptions.push({
      colCountByScreen: extend(baseColCountByScreen, layoutManagerOptions.colCountByScreen)
    });
    const $element = renderer_default("<div>");
    $element.appendTo($parent);
    const instance = this._createComponent($element, "dxLayoutManager", layoutManagerOptions);
    instance.on("autoColCountChanged", () => {
      this._clearAutoColCountChangedTimeout();
      this.autoColCountChangedTimeoutId = setTimeout(() => !this._disposed && this._refresh(), 0);
    });
    this._cachedLayoutManagers.push(instance);
    return instance;
  },
  _getValidationGroup() {
    return this.option("validationGroup") || this;
  },
  _createComponent($element, type2, config3) {
    config3 = config3 || {};
    this._extendConfig(config3, {
      readOnly: this.option("readOnly")
    });
    return this.callBase($element, type2, config3);
  },
  _attachSyncSubscriptions() {
    const that = this;
    that.on("optionChanged", (args) => {
      const optionFullName = args.fullName;
      if ("formData" === optionFullName) {
        if (!isDefined(args.value)) {
          that._options.silent("formData", args.value = {});
        }
        that._triggerOnFieldDataChangedByDataSet(args.value);
      }
      if (that._cachedLayoutManagers.length) {
        each(that._cachedLayoutManagers, (index2, layoutManager) => {
          if ("formData" === optionFullName) {
            that._isDataUpdating = true;
            layoutManager.option("layoutData", args.value);
            that._isDataUpdating = false;
          }
          if ("readOnly" === args.name || "disabled" === args.name) {
            layoutManager.option(optionFullName, args.value);
          }
        });
      }
    });
  },
  _optionChanged(args) {
    const splitFullName = args.fullName.split(".");
    if (splitFullName.length > 1 && -1 !== splitFullName[0].search("items") && this._itemsOptionChangedHandler(args)) {
      return;
    }
    if (splitFullName.length > 1 && -1 !== splitFullName[0].search("formData") && this._formDataOptionChangedHandler(args)) {
      return;
    }
    this._defaultOptionChangedHandler(args);
  },
  _defaultOptionChangedHandler(args) {
    switch (args.name) {
      case "formData":
        if (!this.option("items")) {
          this._invalidate();
        } else if (isEmptyObject(args.value)) {
          this._clear();
        }
        break;
      case "onFieldDataChanged":
      case "alignRootItemLabels":
      case "readOnly":
      case "isDirty":
        break;
      case "items":
      case "colCount":
      case "onEditorEnterKey":
      case "labelLocation":
      case "labelMode":
      case "alignItemLabels":
      case "showColonAfterLabel":
      case "customizeItem":
      case "alignItemLabelsInAllGroups":
      case "showRequiredMark":
      case "showOptionalMark":
      case "requiredMark":
      case "optionalMark":
      case "requiredMessage":
      case "scrollingEnabled":
      case "formID":
      case "colCountByScreen":
      case "screenByWidth":
      case "stylingMode":
        this._invalidate();
        break;
      case "showValidationSummary":
        this._renderValidationSummary();
        break;
      case "minColWidth":
        if ("auto" === this.option("colCount")) {
          this._invalidate();
        }
        break;
      case "width":
        this.callBase(args);
        this._rootLayoutManager.option(args.name, args.value);
        this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
        break;
      case "validationGroup":
        validation_engine_default.removeGroup(args.previousValue || this);
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  },
  _itemsOptionChangedHandler(args) {
    const nameParts = args.fullName.split(".");
    const {
      value: value2
    } = args;
    const itemPath = this._getItemPath(nameParts);
    const item = this.option(itemPath);
    const optionNameWithoutPath = args.fullName.replace(`${itemPath}.`, "");
    const simpleOptionName = optionNameWithoutPath.split(".")[0].replace(/\[\d+]/, "");
    const itemAction = this._tryCreateItemOptionAction(simpleOptionName, item, item[simpleOptionName], args.previousValue, itemPath);
    let result2 = this._tryExecuteItemOptionAction(itemAction) || this._tryChangeLayoutManagerItemOption(args.fullName, value2);
    if (!result2 && item) {
      this._changeItemOption(item, optionNameWithoutPath, value2);
      const items = this._generateItemsFromData(this.option("items"));
      this.option("items", items);
      result2 = true;
    }
    return result2;
  },
  _formDataOptionChangedHandler(args) {
    const nameParts = args.fullName.split(".");
    const {
      value: value2
    } = args;
    const dataField = nameParts.slice(1).join(".");
    const editor = this.getEditor(dataField);
    if (editor) {
      editor.option("value", value2);
    } else {
      this._triggerOnFieldDataChanged({
        dataField,
        value: value2
      });
    }
    return true;
  },
  _tryCreateItemOptionAction(optionName, item, value2, previousValue, itemPath) {
    if ("tabs" === optionName) {
      this._itemsRunTimeInfo.removeItemsByPathStartWith(`${itemPath}.tabs`);
      value2 = this._prepareItems(value2, true, itemPath, true);
    }
    return m_form_item_options_actions_default(optionName, {
      item,
      value: value2,
      previousValue,
      itemsRunTimeInfo: this._itemsRunTimeInfo
    });
  },
  _tryExecuteItemOptionAction: (action) => action && action.tryExecute(),
  _updateValidationGroupAndSummaryIfNeeded(fullName) {
    const optionName = getOptionNameFromFullName(fullName);
    if (ITEM_OPTIONS_FOR_VALIDATION_UPDATING.includes(optionName)) {
      validation_engine_default.addGroup(this._getValidationGroup(), false);
      if (this.option("showValidationSummary")) {
        var _this$_validationSumm2;
        null === (_this$_validationSumm2 = this._validationSummary) || void 0 === _this$_validationSumm2 || _this$_validationSumm2.refreshValidationGroup();
      }
    }
  },
  _setLayoutManagerItemOption(layoutManager, optionName, value2, path) {
    if (this._updateLockCount > 0) {
      !layoutManager._updateLockCount && layoutManager.beginUpdate();
      const key = this._itemsRunTimeInfo.findKeyByPath(path);
      this.postponedOperations.add(key, () => {
        !layoutManager._disposed && layoutManager.endUpdate();
        return Deferred().resolve();
      });
    }
    const contentReadyHandler = (e) => {
      e.component.off("contentReady", contentReadyHandler);
      if (isFullPathContainsTabs(path)) {
        const tabPath = tryGetTabPath(path);
        const tabLayoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(tabPath);
        if (tabLayoutManager) {
          this._alignLabelsInColumn({
            items: tabLayoutManager.option("items"),
            layoutManager: tabLayoutManager,
            $container: tabLayoutManager.$element(),
            inOneColumn: tabLayoutManager.isSingleColumnMode()
          });
        }
      } else {
        this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
      }
    };
    layoutManager.on("contentReady", contentReadyHandler);
    layoutManager.option(optionName, value2);
    this._updateValidationGroupAndSummaryIfNeeded(optionName);
  },
  _tryChangeLayoutManagerItemOption(fullName, value2) {
    const nameParts = fullName.split(".");
    const optionName = getOptionNameFromFullName(fullName);
    if ("items" === optionName && nameParts.length > 1) {
      const itemPath = this._getItemPath(nameParts);
      const layoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(itemPath);
      if (layoutManager) {
        this._itemsRunTimeInfo.removeItemsByItems(layoutManager.getItemsRunTimeInfo());
        const items = this._prepareItems(value2, false, itemPath);
        this._setLayoutManagerItemOption(layoutManager, optionName, items, itemPath);
        return true;
      }
    } else if (nameParts.length > 2) {
      const endPartIndex = nameParts.length - 2;
      const itemPath = this._getItemPath(nameParts.slice(0, endPartIndex));
      const layoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(itemPath);
      if (layoutManager) {
        const fullOptionName = getFullOptionName(nameParts[endPartIndex], optionName);
        if ("editorType" === optionName) {
          if (layoutManager.option(fullOptionName) !== value2) {
            return false;
          }
        }
        if ("visible" === optionName) {
          const formItems = this.option(getFullOptionName(itemPath, "items"));
          if (formItems && formItems.length) {
            const layoutManagerItems = layoutManager.option("items");
            formItems.forEach((item, index2) => {
              const layoutItem = layoutManagerItems[index2];
              layoutItem.visibleIndex = item.visibleIndex;
            });
          }
        }
        this._setLayoutManagerItemOption(layoutManager, fullOptionName, value2, itemPath);
        return true;
      }
    }
    return false;
  },
  _tryChangeLayoutManagerItemOptions(itemPath, options2) {
    let result2;
    this.beginUpdate();
    each(options2, (optionName, optionValue) => {
      result2 = this._tryChangeLayoutManagerItemOption(getFullOptionName(itemPath, optionName), optionValue);
      if (!result2) {
        return false;
      }
    });
    this.endUpdate();
    return result2;
  },
  _getItemPath(nameParts) {
    let itemPath = nameParts[0];
    let i;
    for (i = 1; i < nameParts.length; i++) {
      if (-1 !== nameParts[i].search(/items\[\d+]|tabs\[\d+]/)) {
        itemPath += `.${nameParts[i]}`;
      } else {
        break;
      }
    }
    return itemPath;
  },
  _triggerOnFieldDataChanged(args) {
    this._updateIsDirty(args.dataField);
    this._createActionByOption("onFieldDataChanged")(args);
  },
  _triggerOnFieldDataChangedByDataSet(data2) {
    if (data2 && isObject(data2)) {
      Object.keys(data2).forEach((key) => {
        this._triggerOnFieldDataChanged({
          dataField: key,
          value: data2[key]
        });
      });
    }
  },
  _updateFieldValue(dataField, value2) {
    if (isDefined(this.option("formData"))) {
      const editor = this.getEditor(dataField);
      this.option(`formData.${dataField}`, value2);
      if (editor) {
        const editorValue = editor.option("value");
        if (editorValue !== value2) {
          editor.option("value", value2);
        }
      }
    }
  },
  _generateItemsFromData(items) {
    const formData = this.option("formData");
    const result2 = [];
    if (!items && isDefined(formData)) {
      each(formData, (dataField) => {
        result2.push({
          dataField
        });
      });
    }
    if (items) {
      each(items, (index2, item) => {
        if (isObject(item)) {
          result2.push(item);
        } else {
          result2.push({
            dataField: item
          });
        }
      });
    }
    return result2;
  },
  _getItemByField(field, items) {
    const that = this;
    const fieldParts = isObject(field) ? field : that._getFieldParts(field);
    const {
      fieldName
    } = fieldParts;
    const {
      fieldPath
    } = fieldParts;
    let resultItem;
    if (items.length) {
      each(items, (index2, item) => {
        const {
          itemType
        } = item;
        if (fieldPath.length) {
          const path = fieldPath.slice();
          item = that._getItemByFieldPath(path, fieldName, item);
        } else if ("group" === itemType && !(item.caption || item.name) || "tabbed" === itemType && !item.name) {
          const subItemsField = that._getSubItemField(itemType);
          item.items = that._generateItemsFromData(item.items);
          item = that._getItemByField({
            fieldName,
            fieldPath
          }, item[subItemsField]);
        }
        if (isEqualToDataFieldOrNameOrTitleOrCaption(item, fieldName)) {
          resultItem = item;
          return false;
        }
      });
    }
    return resultItem;
  },
  _getFieldParts(field) {
    let fieldName = field;
    let separatorIndex = fieldName.indexOf(".");
    const resultPath = [];
    while (-1 !== separatorIndex) {
      resultPath.push(fieldName.substr(0, separatorIndex));
      fieldName = fieldName.substr(separatorIndex + 1);
      separatorIndex = fieldName.indexOf(".");
    }
    return {
      fieldName,
      fieldPath: resultPath.reverse()
    };
  },
  _getItemByFieldPath(path, fieldName, item) {
    const that = this;
    const {
      itemType
    } = item;
    const subItemsField = that._getSubItemField(itemType);
    const isItemWithSubItems = "group" === itemType || "tabbed" === itemType || item.title;
    let result2;
    do {
      if (isItemWithSubItems) {
        const name2 = item.name || item.caption || item.title;
        const isGroupWithName = isDefined(name2);
        const nameWithoutSpaces = getTextWithoutSpaces(name2);
        let pathNode;
        item[subItemsField] = that._generateItemsFromData(item[subItemsField]);
        if (isGroupWithName) {
          pathNode = path.pop();
        }
        if (!path.length) {
          result2 = that._getItemByField(fieldName, item[subItemsField]);
          if (result2) {
            break;
          }
        }
        if (!isGroupWithName || isGroupWithName && nameWithoutSpaces === pathNode) {
          if (path.length) {
            result2 = that._searchItemInEverySubItem(path, fieldName, item[subItemsField]);
          }
        }
      } else {
        break;
      }
    } while (path.length && !isDefined(result2));
    return result2;
  },
  _getSubItemField: (itemType) => "tabbed" === itemType ? "tabs" : "items",
  _searchItemInEverySubItem(path, fieldName, items) {
    const that = this;
    let result2;
    each(items, (index2, groupItem) => {
      result2 = that._getItemByFieldPath(path.slice(), fieldName, groupItem);
      if (result2) {
        return false;
      }
    });
    if (!result2) {
      result2 = false;
    }
    return result2;
  },
  _changeItemOption(item, option, value2) {
    if (isObject(item)) {
      item[option] = value2;
    }
  },
  _dimensionChanged() {
    const currentScreenFactor = this._getCurrentScreenFactor();
    if (this._lastMarkupScreenFactor !== currentScreenFactor) {
      if (this._isColCountChanged(this._lastMarkupScreenFactor, currentScreenFactor)) {
        this._targetScreenFactor = currentScreenFactor;
        this._refresh();
        this._targetScreenFactor = void 0;
      }
      this._lastMarkupScreenFactor = currentScreenFactor;
    }
  },
  _isColCountChanged(oldScreenSize, newScreenSize) {
    let isChanged = false;
    each(this._cachedColCountOptions, (index2, item) => {
      if (item.colCountByScreen[oldScreenSize] !== item.colCountByScreen[newScreenSize]) {
        isChanged = true;
        return false;
      }
    });
    return isChanged;
  },
  _refresh() {
    events_engine_default.trigger(this.$element().find(".dx-state-focused > :not(.dx-dropdowneditor-input-wrapper) input, .dx-state-focused textarea"), "change");
    this.callBase();
  },
  _updateIsDirty(dataField) {
    const editor = this.getEditor(dataField);
    if (!editor) {
      return;
    }
    if (editor.option("isDirty")) {
      this._dirtyFields.add(dataField);
    } else {
      this._dirtyFields.delete(dataField);
    }
    this.option("isDirty", !!this._dirtyFields.size);
  },
  updateRunTimeInfoForEachEditor(editorAction) {
    this._itemsRunTimeInfo.each((_, itemRunTimeInfo) => {
      const {
        widgetInstance
      } = itemRunTimeInfo;
      if (isDefined(widgetInstance) && editor_default.isEditor(widgetInstance)) {
        editorAction(widgetInstance);
      }
    });
  },
  _clear() {
    this.updateRunTimeInfoForEachEditor((editor) => {
      editor.clear();
      editor.option("isValid", true);
    });
    validation_engine_default.resetGroup(this._getValidationGroup());
  },
  _updateData(data2, value2, isComplexData) {
    const that = this;
    const _data = isComplexData ? value2 : data2;
    if (isObject(_data)) {
      each(_data, (dataField, fieldValue) => {
        that._updateData(isComplexData ? `${data2}.${dataField}` : dataField, fieldValue, isObject(fieldValue));
      });
    } else if (isString(data2)) {
      that._updateFieldValue(data2, value2);
    }
  },
  registerKeyHandler(key, handler) {
    this.callBase(key, handler);
    this._itemsRunTimeInfo.each((_, itemRunTimeInfo) => {
      if (isDefined(itemRunTimeInfo.widgetInstance)) {
        itemRunTimeInfo.widgetInstance.registerKeyHandler(key, handler);
      }
    });
  },
  _focusTarget() {
    return this.$element().find(`.${FIELD_ITEM_CONTENT_CLASS} [tabindex]`).first();
  },
  _visibilityChanged() {
    this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
  },
  _clearAutoColCountChangedTimeout() {
    if (this.autoColCountChangedTimeoutId) {
      clearTimeout(this.autoColCountChangedTimeoutId);
      this.autoColCountChangedTimeoutId = void 0;
    }
  },
  _dispose() {
    this._clearAutoColCountChangedTimeout();
    validation_engine_default.removeGroup(this._getValidationGroup());
    this.callBase();
  },
  clear() {
    this._clear();
  },
  resetValues() {
    this._clear();
  },
  reset(editorsData) {
    this.updateRunTimeInfoForEachEditor((editor) => {
      const editorName = editor.option("name");
      if (editorsData && editorName in editorsData) {
        editor.reset(editorsData[editorName]);
      } else {
        editor.reset();
      }
    });
    this._renderValidationSummary();
  },
  updateData(data2, value2) {
    this._updateData(data2, value2);
  },
  getEditor(dataField) {
    return this._itemsRunTimeInfo.findWidgetInstanceByDataField(dataField) || this._itemsRunTimeInfo.findWidgetInstanceByName(dataField);
  },
  getButton(name2) {
    return this._itemsRunTimeInfo.findWidgetInstanceByName(name2);
  },
  updateDimensions() {
    const that = this;
    const deferred = Deferred();
    if (that._scrollable) {
      that._scrollable.update().done(() => {
        deferred.resolveWith(that);
      });
    } else {
      deferred.resolveWith(that);
    }
    return deferred.promise();
  },
  itemOption(id, option, value2) {
    const items = this._generateItemsFromData(this.option("items"));
    const item = this._getItemByField(id, items);
    const path = getItemPath(items, item);
    if (!item) {
      return;
    }
    switch (arguments.length) {
      case 1:
        return item;
      case 3: {
        const itemAction = this._tryCreateItemOptionAction(option, item, value2, item[option], path);
        this._changeItemOption(item, option, value2);
        const fullName = getFullOptionName(path, option);
        if (!this._tryExecuteItemOptionAction(itemAction) && !this._tryChangeLayoutManagerItemOption(fullName, value2)) {
          this.option("items", items);
        }
        break;
      }
      default:
        if (isObject(option)) {
          if (!this._tryChangeLayoutManagerItemOptions(path, option)) {
            let allowUpdateItems;
            each(option, (optionName, optionValue) => {
              const itemAction = this._tryCreateItemOptionAction(optionName, item, optionValue, item[optionName], path);
              this._changeItemOption(item, optionName, optionValue);
              if (!allowUpdateItems && !this._tryExecuteItemOptionAction(itemAction)) {
                allowUpdateItems = true;
              }
            });
            allowUpdateItems && this.option("items", items);
          }
        }
    }
  },
  validate() {
    return validation_engine_default.validateGroup(this._getValidationGroup());
  },
  getItemID(name2) {
    return `dx_${this.option("formID")}_${name2 || new guid_default()}`;
  },
  getTargetScreenFactor() {
    return this._targetScreenFactor;
  }
});
component_registrator_default("dxForm", Form);
var m_form_default = Form;

// ../../../../../../node_modules/devextreme/esm/ui/form/ui.form.js
var ui_form_default = m_form_default;

// ../../../../../../node_modules/devextreme/esm/ui/form.js
var form_default = ui_form_default;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_recurrence_editor.js
var RECURRENCE_EDITOR = "dx-recurrence-editor";
var RECURRENCE_EDITOR_CONTAINER = "dx-recurrence-editor-container";
var REPEAT_END_EDITOR = "dx-recurrence-repeat-end";
var REPEAT_END_TYPE_EDITOR = "dx-recurrence-radiogroup-repeat-type";
var REPEAT_COUNT_EDITOR = "dx-recurrence-numberbox-repeat-count";
var REPEAT_UNTIL_DATE_EDITOR = "dx-recurrence-datebox-until-date";
var RECURRENCE_BUTTON_GROUP = "dx-recurrence-button-group";
var FREQUENCY_EDITOR = "dx-recurrence-selectbox-freq";
var INTERVAL_EDITOR = "dx-recurrence-numberbox-interval";
var REPEAT_ON_EDITOR = "dx-recurrence-repeat-on";
var DAY_OF_MONTH = "dx-recurrence-numberbox-day-of-month";
var MONTH_OF_YEAR = "dx-recurrence-selectbox-month-of-year";
var frequenciesMessages = [{
  recurrence: "dxScheduler-recurrenceHourly",
  value: "hourly"
}, {
  recurrence: "dxScheduler-recurrenceDaily",
  value: "daily"
}, {
  recurrence: "dxScheduler-recurrenceWeekly",
  value: "weekly"
}, {
  recurrence: "dxScheduler-recurrenceMonthly",
  value: "monthly"
}, {
  recurrence: "dxScheduler-recurrenceYearly",
  value: "yearly"
}];
var frequencies = frequenciesMessages.map((item) => ({
  text: () => message_default.format(item.recurrence),
  value: item.value
}));
var repeatEndTypes = [{
  type: "never"
}, {
  type: "until"
}, {
  type: "count"
}];
var days2 = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var getStylingModeFunc = () => isFluent(current()) ? "filled" : void 0;
var RecurrenceRule = class {
  constructor(rule) {
    this._recurrenceProcessor = getRecurrenceProcessor();
    this._recurrenceProcessor = getRecurrenceProcessor();
    this._recurrenceRule = this._recurrenceProcessor.evalRecurrenceRule(rule).rule;
  }
  makeRules(string) {
    this._recurrenceRule = this._recurrenceProcessor.evalRecurrenceRule(string).rule;
  }
  makeRule(field, value2) {
    if (!value2 || Array.isArray(value2) && !value2.length) {
      delete this._recurrenceRule[field];
      return;
    }
    if (isDefined(field)) {
      if ("until" === field) {
        delete this._recurrenceRule.count;
      }
      if ("count" === field) {
        delete this._recurrenceRule.until;
      }
      this._recurrenceRule[field] = value2;
    }
  }
  getRepeatEndRule() {
    const rules = this._recurrenceRule;
    if ("count" in rules) {
      return "count";
    }
    if ("until" in rules) {
      return "until";
    }
    return "never";
  }
  getRecurrenceString() {
    return this._recurrenceProcessor.getRecurrenceString(this._recurrenceRule);
  }
  getRules() {
    return this._recurrenceRule;
  }
  getDaysFromByDayRule() {
    return this._recurrenceProcessor.daysFromByDayRule(this._recurrenceRule);
  }
};
var RecurrenceEditor = class extends editor_default {
  _getDefaultOptions() {
    const defaultOptions3 = super._getDefaultOptions();
    return extend(defaultOptions3, {
      value: null,
      startDate: /* @__PURE__ */ new Date(),
      firstDayOfWeek: void 0
    });
  }
  _getFirstDayOfWeek() {
    const firstDayOfWeek = this.option("firstDayOfWeek");
    return isDefined(firstDayOfWeek) ? firstDayOfWeek : date_default3.firstDayOfWeekIndex();
  }
  _createComponent(element, name2) {
    let config3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    this._extendConfig(config3, {
      readOnly: this.option("readOnly")
    });
    return super._createComponent(element, name2, config3);
  }
  _init() {
    super._init();
    this._recurrenceRule = new RecurrenceRule(this.option("value"));
  }
  _render() {
    super._render();
    this.$element().addClass(RECURRENCE_EDITOR);
    this._$container = renderer_default("<div>").addClass(RECURRENCE_EDITOR_CONTAINER).appendTo(this.$element());
    this._prepareEditors();
    this._renderEditors(this._$container);
  }
  getEditorByField(fieldName) {
    let editor = this.getRecurrenceForm().getEditor(fieldName);
    if (!isDefined(editor)) {
      switch (fieldName) {
        case "byday":
          editor = this._weekEditor;
          break;
        case "count":
          editor = this._repeatCountEditor;
          break;
        case "until":
          editor = this._repeatUntilDate;
      }
    }
    return editor;
  }
  _prepareEditors() {
    const freq = (this._recurrenceRule.getRules().freq || frequenciesMessages[1].value).toLowerCase();
    this._editors = [this._createFreqEditor(freq), this._createIntervalEditor(freq), this._createRepeatOnLabel(freq), {
      itemType: "group",
      cssClass: REPEAT_ON_EDITOR,
      colCount: 2,
      colCountByScreen: {
        xs: 2
      },
      items: this._createRepeatOnEditor(freq)
    }, {
      itemType: "group",
      items: this._createRepeatEndEditor()
    }];
    return this._editors;
  }
  _createFreqEditor(freq) {
    return {
      dataField: "freq",
      name: "FREQ",
      editorType: "dxSelectBox",
      cssClass: FREQUENCY_EDITOR,
      editorOptions: {
        stylingMode: getStylingModeFunc(),
        items: frequencies,
        value: freq,
        field: "freq",
        valueExpr: "value",
        displayExpr: "text",
        layout: "horizontal",
        elementAttr: {
          class: FREQUENCY_EDITOR
        },
        onValueChanged: (args) => this._valueChangedHandler(args)
      },
      label: {
        text: message_default.format("dxScheduler-editorLabelRecurrence")
      }
    };
  }
  _createIntervalEditor(freq) {
    const interval = this._recurrenceRule.getRules().interval || 1;
    return {
      itemType: "group",
      colCount: 2,
      cssClass: `${INTERVAL_EDITOR}-wrapper`,
      colCountByScreen: {
        xs: 2
      },
      items: [{
        dataField: "interval",
        editorType: "dxNumberBox",
        editorOptions: {
          stylingMode: getStylingModeFunc(),
          format: "#",
          width: 70,
          min: 1,
          field: "interval",
          value: interval,
          showSpinButtons: true,
          useLargeSpinButtons: false,
          elementAttr: {
            class: INTERVAL_EDITOR
          },
          onValueChanged: (args) => this._valueChangedHandler(args)
        },
        label: {
          text: message_default.format("dxScheduler-recurrenceRepeatEvery")
        }
      }, {
        name: "intervalLabel",
        cssClass: `${INTERVAL_EDITOR}-label`,
        template: () => message_default.format(`dxScheduler-recurrenceRepeat${freq.charAt(0).toUpperCase()}${freq.substr(1).toLowerCase()}`)
      }]
    };
  }
  _createRepeatOnLabel(freq) {
    return {
      itemType: "group",
      cssClass: `${REPEAT_ON_EDITOR}-label`,
      items: [{
        name: "repeatOnLabel",
        colSpan: 2,
        template: () => message_default.format("dxScheduler-recurrenceRepeatOn"),
        visible: freq && "daily" !== freq && "hourly" !== freq
      }]
    };
  }
  _createRepeatOnEditor(freq) {
    return [this._createByDayEditor(freq), this._createByMonthEditor(freq), this._createByMonthDayEditor(freq)];
  }
  _createByDayEditor(freq) {
    return {
      dataField: "byday",
      colSpan: 2,
      template: (_, itemElement) => {
        const firstDayOfWeek = this._getFirstDayOfWeek();
        const byDay = this._daysOfWeekByRules();
        const localDaysNames = date_default3.getDayNames("abbreviated");
        const dayNames = days2.slice(firstDayOfWeek).concat(days2.slice(0, firstDayOfWeek));
        const itemsButtonGroup = localDaysNames.slice(firstDayOfWeek).concat(localDaysNames.slice(0, firstDayOfWeek)).map((item, index2) => ({
          text: item,
          key: dayNames[index2]
        }));
        this._$repeatOnWeek = renderer_default("<div>").addClass(RECURRENCE_BUTTON_GROUP).appendTo(itemElement);
        this._weekEditor = this._createComponent(this._$repeatOnWeek, button_group_default, {
          items: itemsButtonGroup,
          field: "byday",
          selectionMode: "multiple",
          selectedItemKeys: byDay,
          keyExpr: "key",
          onSelectionChanged: (e) => {
            const selectedItemKeys = e.component.option("selectedItemKeys");
            const selectedKeys = null !== selectedItemKeys && void 0 !== selectedItemKeys && selectedItemKeys.length ? selectedItemKeys : this._getDefaultByDayValue();
            this._recurrenceRule.makeRule("byday", selectedKeys);
            this._changeEditorValue();
          }
        });
      },
      visible: "weekly" === freq,
      label: {
        visible: false
      }
    };
  }
  _createByMonthEditor(freq) {
    const monthsName = date_default3.getMonthNames("wide");
    const months = [...Array(12)].map((_, i) => ({
      value: `${i + 1}`,
      text: monthsName[i]
    }));
    return {
      dataField: "bymonth",
      editorType: "dxSelectBox",
      editorOptions: {
        stylingMode: getStylingModeFunc(),
        field: "bymonth",
        items: months,
        value: this._monthOfYearByRules(),
        width: 120,
        displayExpr: "text",
        valueExpr: "value",
        elementAttr: {
          class: MONTH_OF_YEAR
        },
        onValueChanged: (args) => this._valueChangedHandler(args)
      },
      visible: "yearly" === freq,
      label: {
        visible: false
      }
    };
  }
  _createByMonthDayEditor(freq) {
    return {
      dataField: "bymonthday",
      editorType: "dxNumberBox",
      editorOptions: {
        stylingMode: getStylingModeFunc(),
        min: 1,
        max: 31,
        format: "#",
        width: 70,
        field: "bymonthday",
        showSpinButtons: true,
        useLargeSpinButtons: false,
        value: this._dayOfMonthByRules(),
        elementAttr: {
          class: DAY_OF_MONTH
        },
        onValueChanged: (args) => this._valueChangedHandler(args)
      },
      visible: "monthly" === freq || "yearly" === freq,
      label: {
        visible: false
      }
    };
  }
  _createRepeatEndEditor() {
    const repeatType = this._recurrenceRule.getRepeatEndRule();
    return [{
      dataField: "repeatEnd",
      editorType: "dxRadioGroup",
      editorOptions: {
        items: repeatEndTypes,
        value: repeatType,
        valueExpr: "type",
        field: "repeatEnd",
        itemTemplate: (itemData) => {
          if ("count" === itemData.type) {
            return this._renderRepeatCountEditor();
          }
          if ("until" === itemData.type) {
            return this._renderRepeatUntilEditor();
          }
          return this._renderDefaultRepeatEnd();
        },
        layout: "vertical",
        elementAttr: {
          class: REPEAT_END_TYPE_EDITOR
        },
        onValueChanged: (args) => this._repeatEndValueChangedHandler(args)
      },
      label: {
        text: message_default.format("dxScheduler-recurrenceEnd")
      }
    }];
  }
  _renderEditors($container) {
    this._recurrenceForm = this._createComponent($container, form_default, {
      items: this._editors,
      showValidationSummary: false,
      scrollingEnabled: true,
      showColonAfterLabel: false,
      labelLocation: "top"
    });
    this._disableRepeatEndParts();
  }
  _setAriaDescribedBy(editor, $label) {
    const labelId = `label-${new guid_default()}`;
    editor.setAria("describedby", labelId);
    editor.setAria("id", labelId, $label);
  }
  getRecurrenceForm() {
    return this._recurrenceForm;
  }
  changeValueByVisibility(value2) {
    if (value2) {
      if (!this.option("value")) {
        this._handleDefaults();
      }
    } else {
      this._recurrenceRule.makeRules("");
      this.option("value", "");
    }
  }
  _handleDefaults() {
    this._recurrenceRule.makeRule("freq", frequenciesMessages[1].value);
    this._changeEditorValue();
  }
  _changeEditorValue() {
    this.option("value", this._recurrenceRule.getRecurrenceString() || "");
  }
  _daysOfWeekByRules() {
    let daysByRule = this._recurrenceRule.getDaysFromByDayRule();
    if (!daysByRule.length) {
      daysByRule = this._getDefaultByDayValue();
    }
    return daysByRule;
  }
  _getDefaultByDayValue() {
    const startDate = this.option("startDate");
    const startDay = startDate.getDay();
    return [days2[startDay]];
  }
  _dayOfMonthByRules() {
    let dayByRule = this._recurrenceRule.getRules().bymonthday;
    if (!dayByRule) {
      dayByRule = this.option("startDate").getDate();
    }
    return dayByRule;
  }
  _monthOfYearByRules() {
    let monthByRule = this._recurrenceRule.getRules().bymonth;
    if (!monthByRule) {
      monthByRule = this.option("startDate").getMonth() + 1;
    }
    return String(monthByRule);
  }
  _renderDefaultRepeatEnd() {
    const $editorTemplate = renderer_default("<div>").addClass(REPEAT_END_EDITOR + "-wrapper");
    renderer_default("<div>").text(message_default.format("dxScheduler-recurrenceNever")).addClass(REPEAT_END_EDITOR + "-label").appendTo($editorTemplate);
    return $editorTemplate;
  }
  _repeatEndValueChangedHandler(args) {
    const {
      value: value2
    } = args;
    this._disableRepeatEndParts(value2);
    if ("until" === value2) {
      this._recurrenceRule.makeRule(value2, this._getUntilValue());
    }
    if ("count" === value2) {
      this._recurrenceRule.makeRule(value2, this._repeatCountEditor.option("value"));
    }
    if ("never" === value2) {
      this._recurrenceRule.makeRule("count", "");
      this._recurrenceRule.makeRule("until", "");
    }
    this._changeEditorValue();
  }
  _disableRepeatEndParts() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._recurrenceRule.getRepeatEndRule();
    if ("until" === value2) {
      this._repeatCountEditor.option("disabled", true);
      this._repeatUntilDate.option("disabled", false);
    }
    if ("count" === value2) {
      this._repeatCountEditor.option("disabled", false);
      this._repeatUntilDate.option("disabled", true);
    }
    if ("never" === value2) {
      this._repeatCountEditor.option("disabled", true);
      this._repeatUntilDate.option("disabled", true);
    }
  }
  _renderRepeatCountEditor() {
    const repeatCount = this._recurrenceRule.getRules().count || 1;
    const $editorWrapper = renderer_default("<div>").addClass(REPEAT_END_EDITOR + "-wrapper");
    renderer_default("<div>").text(message_default.format("dxScheduler-recurrenceAfter")).addClass(REPEAT_END_EDITOR + "-label").appendTo($editorWrapper);
    this._$repeatCountEditor = renderer_default("<div>").addClass(REPEAT_COUNT_EDITOR).appendTo($editorWrapper);
    renderer_default("<div>").text(message_default.format("dxScheduler-recurrenceRepeatCount")).addClass(REPEAT_END_EDITOR + "-label").appendTo($editorWrapper);
    this._repeatCountEditor = this._createComponent(this._$repeatCountEditor, number_box_default, {
      stylingMode: getStylingModeFunc(),
      field: "count",
      format: "#",
      width: 70,
      min: 1,
      showSpinButtons: true,
      useLargeSpinButtons: false,
      value: repeatCount,
      onValueChanged: this._repeatCountValueChangeHandler.bind(this)
    });
    return $editorWrapper;
  }
  _repeatCountValueChangeHandler(args) {
    if ("count" === this._recurrenceRule.getRepeatEndRule()) {
      const {
        value: value2
      } = args;
      this._recurrenceRule.makeRule("count", value2);
      this._changeEditorValue();
    }
  }
  _formatUntilDate(date) {
    if (this._recurrenceRule.getRules().until && date_default.sameDate(this._recurrenceRule.getRules().until, date)) {
      return date;
    }
    return date_default.setToDayEnd(date);
  }
  _renderRepeatUntilEditor() {
    const repeatUntil = this._getUntilValue();
    const $editorWrapper = renderer_default("<div>").addClass(REPEAT_END_EDITOR + "-wrapper");
    renderer_default("<div>").text(message_default.format("dxScheduler-recurrenceOn")).addClass(REPEAT_END_EDITOR + "-label").appendTo($editorWrapper);
    this._$repeatDateEditor = renderer_default("<div>").addClass(REPEAT_UNTIL_DATE_EDITOR).appendTo($editorWrapper);
    this._repeatUntilDate = this._createComponent(this._$repeatDateEditor, date_box_default, {
      stylingMode: getStylingModeFunc(),
      field: "until",
      value: repeatUntil,
      type: "date",
      onValueChanged: this._repeatUntilValueChangeHandler.bind(this),
      calendarOptions: {
        firstDayOfWeek: this._getFirstDayOfWeek()
      },
      useMaskBehavior: true
    });
    return $editorWrapper;
  }
  _repeatUntilValueChangeHandler(args) {
    if ("until" === this._recurrenceRule.getRepeatEndRule()) {
      const dateInTimeZone2 = this._formatUntilDate(new Date(args.value));
      const getStartDateTimeZone = this.option("getStartDateTimeZone");
      const appointmentTimeZone = getStartDateTimeZone();
      const path = appointmentTimeZone ? PathTimeZoneConversion.fromAppointmentToSource : PathTimeZoneConversion.fromGridToSource;
      const dateInLocaleTimeZone = this.option("timeZoneCalculator").createDate(dateInTimeZone2, {
        path,
        appointmentTimeZone
      });
      this._recurrenceRule.makeRule("until", dateInLocaleTimeZone);
      this._changeEditorValue();
    }
  }
  _valueChangedHandler(args) {
    const {
      value: value2,
      previousValue
    } = args;
    const field = args.component.option("field");
    if (!this.option("visible")) {
      this.option("value", "");
    } else {
      this._recurrenceRule.makeRule(field, value2);
      if ("freq" === field) {
        this._makeRepeatOnRule(value2);
        this._changeRepeatOnVisibility(value2, previousValue);
      }
      this._changeEditorValue();
    }
  }
  _makeRepeatOnRule(value2) {
    if ("daily" === value2 || "hourly" === value2) {
      this._recurrenceRule.makeRule("byday", "");
      this._recurrenceRule.makeRule("bymonth", "");
      this._recurrenceRule.makeRule("bymonthday", "");
    }
    if ("weekly" === value2) {
      this._recurrenceRule.makeRule("byday", this._daysOfWeekByRules());
      this._recurrenceRule.makeRule("bymonth", "");
      this._recurrenceRule.makeRule("bymonthday", "");
    }
    if ("monthly" === value2) {
      this._recurrenceRule.makeRule("bymonthday", this._dayOfMonthByRules());
      this._recurrenceRule.makeRule("bymonth", "");
      this._recurrenceRule.makeRule("byday", "");
    }
    if ("yearly" === value2) {
      this._recurrenceRule.makeRule("bymonthday", this._dayOfMonthByRules());
      this._recurrenceRule.makeRule("bymonth", this._monthOfYearByRules());
      this._recurrenceRule.makeRule("byday", "");
    }
  }
  _optionChanged(args) {
    var _this$_recurrenceForm, _this$_repeatCountEdi, _this$_weekEditor, _this$_repeatUntilDat;
    switch (args.name) {
      case "readOnly":
        null === (_this$_recurrenceForm = this._recurrenceForm) || void 0 === _this$_recurrenceForm || _this$_recurrenceForm.option("readOnly", args.value);
        null === (_this$_repeatCountEdi = this._repeatCountEditor) || void 0 === _this$_repeatCountEdi || _this$_repeatCountEdi.option("readOnly", args.value);
        null === (_this$_weekEditor = this._weekEditor) || void 0 === _this$_weekEditor || _this$_weekEditor.option("readOnly", args.value);
        null === (_this$_repeatUntilDat = this._repeatUntilDate) || void 0 === _this$_repeatUntilDat || _this$_repeatUntilDat.option("readOnly", args.value);
        super._optionChanged(args);
        break;
      case "value":
        this._recurrenceRule.makeRules(args.value);
        this._changeRepeatIntervalLabel();
        this._disableRepeatEndParts();
        this._changeEditorsValue(this._recurrenceRule.getRules());
        super._optionChanged(args);
        break;
      case "startDate":
        this._makeRepeatOnRule(this._recurrenceRule.getRules().freq);
        if (isDefined(this._recurrenceRule.getRecurrenceString())) {
          this._changeEditorValue();
        }
        break;
      case "firstDayOfWeek":
        if (this._weekEditor) {
          const localDaysNames = date_default3.getDayNames("abbreviated");
          const dayNames = days2.slice(args.value).concat(days2.slice(0, args.value));
          const itemsButtonGroup = localDaysNames.slice(args.value).concat(localDaysNames.slice(0, args.value)).map((item, index2) => ({
            text: item,
            key: dayNames[index2]
          }));
          this._weekEditor.option("items", itemsButtonGroup);
        }
        if (this._$repeatDateEditor) {
          this._repeatUntilDate.option("calendarOptions.firstDayOfWeek", this._getFirstDayOfWeek());
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
  _changeRepeatOnVisibility(freq, previousFreq) {
    if (freq !== previousFreq) {
      this._recurrenceForm.itemOption("byday", "visible", false);
      this._recurrenceForm.itemOption("bymonthday", "visible", false);
      this._recurrenceForm.itemOption("bymonth", "visible", false);
      this._recurrenceForm.itemOption("repeatOnLabel", "visible", freq && "daily" !== freq && "hourly" !== freq);
      if ("weekly" === freq) {
        this._recurrenceForm.itemOption("byday", "visible", true);
      }
      if ("monthly" === freq) {
        this._recurrenceForm.itemOption("bymonthday", "visible", true);
      }
      if ("yearly" === freq) {
        this._recurrenceForm.itemOption("bymonthday", "visible", true);
        this._recurrenceForm.itemOption("bymonth", "visible", true);
      }
    }
  }
  _changeRepeatIntervalLabel() {
    const {
      freq
    } = this._recurrenceRule.getRules();
    freq && this._recurrenceForm.itemOption("intervalLabel", "template", message_default.format(`dxScheduler-recurrenceRepeat${freq.charAt(0).toUpperCase()}${freq.substr(1).toLowerCase()}`));
  }
  _changeEditorsValue(rules) {
    this._recurrenceForm.getEditor("freq").option("value", (rules.freq || frequenciesMessages[1].value).toLowerCase());
    this._changeDayOfWeekValue();
    this._changeDayOfMonthValue();
    this._changeMonthOfYearValue();
    this._changeIntervalValue(rules.interval);
    this._changeRepeatCountValue();
    this._changeRepeatEndValue();
    this._changeRepeatUntilValue();
  }
  _changeIntervalValue(value2) {
    this._recurrenceForm.getEditor("interval").option("value", value2 || 1);
  }
  _changeRepeatEndValue() {
    const repeatType = this._recurrenceRule.getRepeatEndRule();
    this._recurrenceForm.getEditor("repeatEnd").option("value", repeatType);
  }
  _changeDayOfWeekValue() {
    const isEditorVisible = this._recurrenceForm.itemOption("byday").visible;
    if (isEditorVisible) {
      const days3 = this._daysOfWeekByRules();
      this.getEditorByField("byday").option("selectedItemKeys", days3);
    }
  }
  _changeDayOfMonthValue() {
    const isEditorVisible = this._recurrenceForm.itemOption("bymonthday").visible;
    if (isEditorVisible) {
      const day = this._dayOfMonthByRules();
      this._recurrenceForm.getEditor("bymonthday").option("value", day);
    }
  }
  _changeMonthOfYearValue() {
    const isEditorVisible = this._recurrenceForm.itemOption("bymonth").visible;
    if (isEditorVisible) {
      const month = this._monthOfYearByRules();
      this._recurrenceForm.getEditor("bymonth").option("value", month);
    }
  }
  _changeRepeatCountValue() {
    const count = this._recurrenceRule.getRules().count || 1;
    this._repeatCountEditor.option("value", count);
  }
  _changeRepeatUntilValue() {
    this._repeatUntilDate.option("value", this._getUntilValue());
  }
  _getUntilValue() {
    const untilDate = this._recurrenceRule.getRules().until;
    if (!untilDate) {
      return this._formatUntilDate(/* @__PURE__ */ new Date());
    }
    const getStartDateTimeZone = this.option("getStartDateTimeZone");
    const appointmentTimeZone = getStartDateTimeZone();
    const path = appointmentTimeZone ? PathTimeZoneConversion.fromSourceToAppointment : PathTimeZoneConversion.fromSourceToGrid;
    return this.option("timeZoneCalculator").createDate(untilDate, {
      path,
      appointmentTimeZone
    });
  }
  toggle() {
    this._freqEditor.focus();
  }
  setAria() {
    if (this._switchEditor) {
      this._switchEditor.setAria(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1]);
    }
  }
};
component_registrator_default("dxRecurrenceEditor", RecurrenceEditor);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/text_box/m_utils.scroll.js
var allowScroll = function(container, delta, shiftKey) {
  const $container = renderer_default(container);
  const scrollTopPos = shiftKey ? $container.scrollLeft() : $container.scrollTop();
  const prop = shiftKey ? "Width" : "Height";
  const scrollSize = $container.prop(`scroll${prop}`);
  const clientSize = $container.prop(`client${prop}`);
  const scrollBottomPos = scrollSize - clientSize - scrollTopPos | 0;
  if (0 === scrollTopPos && 0 === scrollBottomPos) {
    return false;
  }
  const isScrollFromTop = 0 === scrollTopPos && delta >= 0;
  const isScrollFromBottom = 0 === scrollBottomPos && delta <= 0;
  const isScrollFromMiddle = scrollTopPos > 0 && scrollBottomPos > 0;
  if (isScrollFromTop || isScrollFromBottom || isScrollFromMiddle) {
    return true;
  }
};
var prepareScrollData = function(container, validateTarget) {
  const $container = renderer_default(container);
  return {
    validate(e) {
      if (isDxMouseWheelEvent(e) && (eventTarget = e.target, validateTarget ? renderer_default(eventTarget).is(container) : true)) {
        if (allowScroll($container, -e.delta, e.shiftKey)) {
          e._needSkipEvent = true;
          return true;
        }
        return false;
      }
      var eventTarget;
    }
  };
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_text_area.js
var TextArea = text_box_default2.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      spellcheck: true,
      minHeight: void 0,
      maxHeight: void 0,
      autoResizeEnabled: false
    });
  },
  _initMarkup() {
    this.$element().addClass("dx-textarea");
    this.callBase();
    this.setAria("multiline", "true");
  },
  _renderContentImpl() {
    this._updateInputHeight();
    this.callBase();
  },
  _renderInput() {
    this.callBase();
    this._renderScrollHandler();
  },
  _createInput() {
    const $input = renderer_default("<textarea>");
    this._applyInputAttributes($input, this.option("inputAttr"));
    this._updateInputAutoResizeAppearance($input);
    return $input;
  },
  _setInputMinHeight: noop2,
  _renderScrollHandler() {
    this._eventY = 0;
    const $input = this._input();
    const initScrollData = prepareScrollData($input, true);
    events_engine_default.on($input, addNamespace2(emitter_gesture_scroll_default.init, this.NAME), initScrollData, noop2);
    events_engine_default.on($input, addNamespace2(pointer_default.down, this.NAME), this._pointerDownHandler.bind(this));
    events_engine_default.on($input, addNamespace2(pointer_default.move, this.NAME), this._pointerMoveHandler.bind(this));
  },
  _pointerDownHandler(e) {
    this._eventY = eventData(e).y;
  },
  _pointerMoveHandler(e) {
    const currentEventY = eventData(e).y;
    const delta = this._eventY - currentEventY;
    if (allowScroll(this._input(), delta)) {
      e.isScrollingEvent = true;
      e.stopPropagation();
    }
    this._eventY = currentEventY;
  },
  _renderDimensions() {
    const $element = this.$element();
    const element = $element.get(0);
    const width = this._getOptionValue("width", element);
    const height = this._getOptionValue("height", element);
    const minHeight = this.option("minHeight");
    const maxHeight = this.option("maxHeight");
    $element.css({
      minHeight: void 0 !== minHeight ? minHeight : "",
      maxHeight: void 0 !== maxHeight ? maxHeight : "",
      width,
      height
    });
  },
  _resetDimensions() {
    this.$element().css({
      height: "",
      minHeight: "",
      maxHeight: ""
    });
  },
  _renderEvents() {
    if (this.option("autoResizeEnabled")) {
      events_engine_default.on(this._input(), addNamespace2("input paste", this.NAME), this._updateInputHeight.bind(this));
    }
    this.callBase();
  },
  _refreshEvents() {
    events_engine_default.off(this._input(), addNamespace2("input paste", this.NAME));
    this.callBase();
  },
  _getHeightDifference($input) {
    return getVerticalOffsets(this._$element.get(0), false) + getVerticalOffsets(this._$textEditorContainer.get(0), false) + getVerticalOffsets(this._$textEditorInputContainer.get(0), true) + getElementBoxParams("height", getWindow().getComputedStyle($input.get(0))).margin;
  },
  _updateInputHeight() {
    if (!hasWindow()) {
      return;
    }
    const $input = this._input();
    const height = this.option("height");
    const autoHeightResizing = void 0 === height && this.option("autoResizeEnabled");
    const shouldCalculateInputHeight = autoHeightResizing || void 0 === height && this.option("minHeight");
    if (!shouldCalculateInputHeight) {
      $input.css("height", "");
      return;
    }
    this._resetDimensions();
    this._$element.css("height", getOuterHeight(this._$element));
    $input.css("height", 0);
    const heightDifference = this._getHeightDifference($input);
    this._renderDimensions();
    const minHeight = this._getBoundaryHeight("minHeight");
    const maxHeight = this._getBoundaryHeight("maxHeight");
    let inputHeight = $input[0].scrollHeight;
    if (void 0 !== minHeight) {
      inputHeight = Math.max(inputHeight, minHeight - heightDifference);
    }
    if (void 0 !== maxHeight) {
      const adjustedMaxHeight = maxHeight - heightDifference;
      const needScroll = inputHeight > adjustedMaxHeight;
      inputHeight = Math.min(inputHeight, adjustedMaxHeight);
      this._updateInputAutoResizeAppearance($input, !needScroll);
    }
    $input.css("height", inputHeight);
    if (autoHeightResizing) {
      this._$element.css("height", "auto");
    }
  },
  _getBoundaryHeight(optionName) {
    const boundaryValue = this.option(optionName);
    if (isDefined(boundaryValue)) {
      return "number" === typeof boundaryValue ? boundaryValue : parseHeight(boundaryValue, this.$element().get(0).parentElement, this._$element.get(0));
    }
  },
  _renderInputType: noop2,
  _visibilityChanged(visible2) {
    if (visible2) {
      this._updateInputHeight();
    }
  },
  _updateInputAutoResizeAppearance($input, isAutoResizeEnabled) {
    if ($input) {
      const autoResizeEnabled = ensureDefined(isAutoResizeEnabled, this.option("autoResizeEnabled"));
      $input.toggleClass("dx-texteditor-input-auto-resize", autoResizeEnabled);
    }
  },
  _dimensionChanged() {
    if (this.option("visible")) {
      this._updateInputHeight();
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "autoResizeEnabled":
        this._updateInputAutoResizeAppearance(this._input(), args.value);
        this._refreshEvents();
        this._updateInputHeight();
        break;
      case "value":
      case "height":
        this.callBase(args);
        this._updateInputHeight();
        break;
      case "minHeight":
      case "maxHeight":
        this._renderDimensions();
        this._updateInputHeight();
        break;
      case "visible":
        this.callBase(args);
        args.value && this._updateInputHeight();
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxTextArea", TextArea);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_tag_box.js
function xor(a, b) {
  return (a || b) && !(a && b);
}
var TagBox = select_box_default.inherit({
  _supportedKeys() {
    const parent = this.callBase();
    const sendToList = (options2) => this._list._keyboardHandler(options2);
    const rtlEnabled = this.option("rtlEnabled");
    return extend({}, parent, {
      backspace(e) {
        if (!this._isCaretAtTheStart()) {
          return;
        }
        this._processKeyboardEvent(e);
        this._isTagRemoved = true;
        const $tagToDelete = this._$focusedTag || this._tagElements().last();
        if (this._$focusedTag) {
          this._moveTagFocus("prev", true);
        }
        if (0 === $tagToDelete.length) {
          return;
        }
        this._preserveFocusedTag = true;
        this._removeTagElement($tagToDelete);
        delete this._preserveFocusedTag;
      },
      upArrow: (e, opts) => e.altKey || !this._list ? parent.upArrow.call(this, e) : sendToList(opts),
      downArrow: (e, opts) => e.altKey || !this._list ? parent.downArrow.call(this, e) : sendToList(opts),
      del(e) {
        if (!this._$focusedTag || !this._isCaretAtTheStart()) {
          return;
        }
        this._processKeyboardEvent(e);
        this._isTagRemoved = true;
        const $tagToDelete = this._$focusedTag;
        this._moveTagFocus("next", true);
        this._preserveFocusedTag = true;
        this._removeTagElement($tagToDelete);
        delete this._preserveFocusedTag;
      },
      enter(e, options2) {
        const isListItemFocused = this._list && null !== this._list.option("focusedElement");
        const isCustomItem = this.option("acceptCustomValue") && !isListItemFocused;
        if (isCustomItem) {
          e.preventDefault();
          "" !== this._searchValue() && this._customItemAddedHandler(e);
          return;
        }
        if (this.option("opened")) {
          this._saveValueChangeEvent(e);
          sendToList(options2);
          e.preventDefault();
        }
      },
      space(e, options2) {
        const isOpened = this.option("opened");
        const isInputActive = this._shouldRenderSearchEvent();
        if (isOpened && !isInputActive) {
          this._saveValueChangeEvent(e);
          sendToList(options2);
          e.preventDefault();
        }
      },
      leftArrow(e) {
        if (!this._isCaretAtTheStart() || this._isEmpty() || this._isEditable() && rtlEnabled && !this._$focusedTag) {
          return;
        }
        e.preventDefault();
        const direction = rtlEnabled ? "next" : "prev";
        this._moveTagFocus(direction);
        !this.option("multiline") && this._scrollContainer(direction);
      },
      rightArrow(e) {
        if (!this._isCaretAtTheStart() || this._isEmpty() || this._isEditable() && !rtlEnabled && !this._$focusedTag) {
          return;
        }
        e.preventDefault();
        const direction = rtlEnabled ? "prev" : "next";
        this._moveTagFocus(direction);
        !this.option("multiline") && this._scrollContainer(direction);
      }
    });
  },
  _processKeyboardEvent(e) {
    e.preventDefault();
    e.stopPropagation();
    this._saveValueChangeEvent(e);
  },
  _isEmpty() {
    return 0 === this._getValue().length;
  },
  _updateTagsContainer($element) {
    this._$tagsContainer = $element.addClass("dx-tag-container");
  },
  _allowSelectItemByTab: () => false,
  _isCaretAtTheStart() {
    const position3 = m_utils_caret_default(this._input());
    return 0 === (null === position3 || void 0 === position3 ? void 0 : position3.start) && 0 === position3.end;
  },
  _updateInputAriaActiveDescendant(id) {
    this.setAria("activedescendant", id, this._input());
  },
  _moveTagFocus(direction, clearOnBoundary) {
    if (!this._$focusedTag) {
      const tagElements = this._tagElements();
      this._$focusedTag = "next" === direction ? tagElements.first() : tagElements.last();
      this._toggleFocusClass(true, this._$focusedTag);
      this._updateInputAriaActiveDescendant(this._$focusedTag.attr("id"));
      return;
    }
    const $nextFocusedTag = this._$focusedTag[direction](".dx-tag");
    if ($nextFocusedTag.length > 0) {
      this._replaceFocusedTag($nextFocusedTag);
      this._updateInputAriaActiveDescendant($nextFocusedTag.attr("id"));
    } else if (clearOnBoundary || "next" === direction && this._isEditable()) {
      this._clearTagFocus();
      this._updateInputAriaActiveDescendant();
    }
  },
  _replaceFocusedTag($nextFocusedTag) {
    this._toggleFocusClass(false, this._$focusedTag);
    this._$focusedTag = $nextFocusedTag;
    this._toggleFocusClass(true, this._$focusedTag);
  },
  _clearTagFocus() {
    if (!this._$focusedTag) {
      return;
    }
    this._toggleFocusClass(false, this._$focusedTag);
    this._updateInputAriaActiveDescendant();
    delete this._$focusedTag;
  },
  _focusClassTarget($element) {
    if ($element && $element.length && $element[0] !== this._focusTarget()[0]) {
      return $element;
    }
    return this.callBase();
  },
  _getLabelContainer() {
    return this._$tagsContainer;
  },
  _getFieldElement() {
    return this._input();
  },
  _scrollContainer(direction) {
    if (this.option("multiline") || !hasWindow()) {
      return;
    }
    if (!this._$tagsContainer) {
      return;
    }
    const scrollPosition = this._getScrollPosition(direction);
    this._$tagsContainer.scrollLeft(scrollPosition);
  },
  _getScrollPosition(direction) {
    if ("start" === direction || "end" === direction) {
      return this._getBorderPosition(direction);
    }
    return this._$focusedTag ? this._getFocusedTagPosition(direction) : this._getBorderPosition("end");
  },
  _getBorderPosition(direction) {
    const rtlEnabled = this.option("rtlEnabled");
    const isScrollLeft = xor("end" === direction, rtlEnabled);
    const scrollSign = rtlEnabled ? -1 : 1;
    return xor(isScrollLeft, !rtlEnabled) ? 0 : scrollSign * (this._$tagsContainer.get(0).scrollWidth - getOuterWidth(this._$tagsContainer));
  },
  _getFocusedTagPosition(direction) {
    const rtlEnabled = this.option("rtlEnabled");
    const isScrollLeft = xor("next" === direction, rtlEnabled);
    let {
      left: scrollOffset
    } = this._$focusedTag.position();
    let scrollLeft = this._$tagsContainer.scrollLeft();
    if (isScrollLeft) {
      scrollOffset += getOuterWidth(this._$focusedTag, true) - getOuterWidth(this._$tagsContainer);
    }
    if (xor(isScrollLeft, scrollOffset < 0)) {
      scrollLeft += scrollOffset;
    }
    return scrollLeft;
  },
  _setNextValue: noop2,
  _getDefaultOptions() {
    return extend(this.callBase(), {
      value: [],
      showDropDownButton: false,
      maxFilterQueryLength: 1500,
      tagTemplate: "tag",
      selectAllText: message_default.format("dxList-selectAll"),
      hideSelectedItems: false,
      selectedItems: [],
      selectAllMode: "page",
      onSelectAllValueChanged: null,
      maxDisplayedTags: void 0,
      showMultiTagOnly: true,
      onMultiTagPreparing: null,
      multiline: true,
      useSubmitBehavior: true
    });
  },
  _init() {
    this.callBase();
    this._selectedItems = [];
    this._initSelectAllValueChangedAction();
  },
  _initActions() {
    this.callBase();
    this._initMultiTagPreparingAction();
  },
  _initMultiTagPreparingAction() {
    this._multiTagPreparingAction = this._createActionByOption("onMultiTagPreparing", {
      beforeExecute: (e) => {
        this._multiTagPreparingHandler(e.args[0]);
      },
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _multiTagPreparingHandler(args) {
    const {
      length: selectedCount
    } = this._getValue();
    if (!this.option("showMultiTagOnly")) {
      args.text = message_default.getFormatter("dxTagBox-moreSelected")(selectedCount - this.option("maxDisplayedTags") + 1);
    } else {
      args.text = message_default.getFormatter("dxTagBox-selected")(selectedCount);
    }
  },
  _initDynamicTemplates() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      tag: new BindableTemplate(($container, data2) => {
        const $tagContent = renderer_default("<div>").addClass("dx-tag-content");
        renderer_default("<span>").text(data2.text ?? data2).appendTo($tagContent);
        renderer_default("<div>").addClass("dx-tag-remove-button").appendTo($tagContent);
        $container.append($tagContent);
      }, ["text"], this.option("integrationOptions.watchMethod"), {
        text: this._displayGetter
      })
    });
  },
  _toggleSubmitElement(enabled) {
    if (enabled) {
      this._renderSubmitElement();
      this._setSubmitValue();
    } else {
      this._$submitElement && this._$submitElement.remove();
      delete this._$submitElement;
    }
  },
  _renderSubmitElement() {
    if (!this.option("useSubmitBehavior")) {
      return;
    }
    this._$submitElement = renderer_default("<select>").attr({
      multiple: "multiple",
      "aria-label": "Selected items"
    }).css("display", "none").appendTo(this.$element());
  },
  _setSubmitValue() {
    if (!this.option("useSubmitBehavior")) {
      return;
    }
    const value2 = this._getValue();
    const $options = [];
    for (let i = 0, n = value2.length; i < n; i++) {
      const useDisplayText = this._shouldUseDisplayValue(value2[i]);
      $options.push(renderer_default("<option>").val(useDisplayText ? this._displayGetter(value2[i]) : value2[i]).attr("selected", "selected"));
    }
    this._getSubmitElement().empty().append($options);
  },
  _initMarkup() {
    this._tagElementsCache = renderer_default();
    const isSingleLineMode = !this.option("multiline");
    this.$element().addClass("dx-tagbox").toggleClass("dx-tagbox-only-select", !(this.option("searchEnabled") || this.option("acceptCustomValue"))).toggleClass("dx-tagbox-single-line", isSingleLineMode);
    this.setAria({
      role: "application",
      roledescription: "tagbox"
    }, this.$element());
    this._initTagTemplate();
    this.callBase();
  },
  _getNewLabelId(actualId, newId, shouldRemove) {
    if (!actualId) {
      return newId;
    }
    if (shouldRemove) {
      if (actualId === newId) {
        return;
      }
      return actualId.split(" ").filter((id) => id !== newId).join(" ");
    }
    return `${actualId} ${newId}`;
  },
  _updateElementAria(id, shouldRemove) {
    const shouldClearLabel = !id;
    if (shouldClearLabel) {
      this.setAria("labelledby", void 0, this.$element());
      return;
    }
    const labelId = this.$element().attr("aria-labelledby");
    const newLabelId = this._getNewLabelId(labelId, id, shouldRemove);
    this.setAria("labelledby", newLabelId, this.$element());
  },
  _render() {
    this.callBase();
    this._renderTagRemoveAction();
    this._renderSingleLineScroll();
    this._scrollContainer("start");
  },
  _initTagTemplate() {
    this._tagTemplate = this._getTemplateByOption("tagTemplate");
  },
  _renderField() {
    const isDefaultFieldTemplate = !isDefined(this.option("fieldTemplate"));
    this.$element().toggleClass("dx-tagbox-default-template", isDefaultFieldTemplate).toggleClass("dx-tagbox-custom-template", !isDefaultFieldTemplate);
    this.callBase();
  },
  _renderTagRemoveAction() {
    const tagRemoveAction = this._createAction(this._removeTagHandler.bind(this));
    const eventName = addNamespace2(CLICK_EVENT_NAME, "dxTagBoxTagRemove");
    events_engine_default.off(this._$tagsContainer, eventName);
    events_engine_default.on(this._$tagsContainer, eventName, ".dx-tag-remove-button", (event) => {
      tagRemoveAction({
        event
      });
    });
  },
  _renderSingleLineScroll() {
    const mouseWheelEvent = addNamespace2("dxmousewheel", this.NAME);
    const $element = this.$element();
    const isMultiline = this.option("multiline");
    events_engine_default.off($element, mouseWheelEvent);
    if ("desktop" !== devices_default.real().deviceType) {
      this._$tagsContainer && this._$tagsContainer.css("overflowX", isMultiline ? "" : "auto");
      return;
    }
    if (isMultiline) {
      return;
    }
    events_engine_default.on($element, mouseWheelEvent, this._tagContainerMouseWheelHandler.bind(this));
  },
  _tagContainerMouseWheelHandler(e) {
    const scrollLeft = this._$tagsContainer.scrollLeft();
    const delta = -0.3 * e.delta;
    if (!isCommandKeyPressed(e) && allowScroll(this._$tagsContainer, delta, true)) {
      this._$tagsContainer.scrollLeft(scrollLeft + delta);
      return false;
    }
    return;
  },
  _renderEvents() {
    this.callBase();
    const input = this._input();
    const namespace = addNamespace2("keydown", this.NAME);
    events_engine_default.on(input, namespace, (e) => {
      const keyName = normalizeKeyName(e);
      if (!this._isControlKey(keyName) && this._isEditable()) {
        this._clearTagFocus();
      }
    });
  },
  _popupWrapperClass() {
    return `${this.callBase()} dx-tagbox-popup-wrapper`;
  },
  _renderInput() {
    this.callBase();
    this._renderPreventBlurOnInputClick();
  },
  _renderPreventBlurOnInputClick() {
    const eventName = addNamespace2("mousedown", "dxTagBox");
    events_engine_default.off(this._inputWrapper(), eventName);
    events_engine_default.on(this._inputWrapper(), eventName, (e) => {
      if (e.target !== this._input()[0] && this._isFocused()) {
        e.preventDefault();
      }
    });
  },
  _renderInputValueImpl() {
    return this._renderMultiSelect();
  },
  _loadInputValue: () => when(),
  _clearTextValue() {
    this._input().val("");
    this._toggleEmptinessEventHandler();
    this.option("text", "");
  },
  _focusInHandler(e) {
    if (!this._preventNestedFocusEvent(e)) {
      this._scrollContainer("end");
    }
    this.callBase(e);
  },
  _renderInputValue() {
    this.option("displayValue", this._searchValue());
    return this.callBase();
  },
  _restoreInputText(saveEditingValue) {
    if (!saveEditingValue) {
      this._clearTextValue();
    }
  },
  _focusOutHandler(e) {
    if (!this._preventNestedFocusEvent(e)) {
      this._clearTagFocus();
      this._scrollContainer("start");
    }
    this.callBase(e);
  },
  _initSelectAllValueChangedAction() {
    this._selectAllValueChangeAction = this._createActionByOption("onSelectAllValueChanged");
  },
  _renderList() {
    this.callBase();
    this._setListDataSourceFilter();
  },
  _canListHaveFocus() {
    return "useButtons" === this.option("applyValueMode");
  },
  _listConfig() {
    const selectionMode = this.option("showSelectionControls") ? "all" : "multiple";
    return extend(this.callBase(), {
      maxFilterLengthInRequest: this.option("maxFilterQueryLength"),
      selectionMode,
      selectAllText: this.option("selectAllText"),
      onSelectAllValueChanged: (_ref) => {
        let {
          value: value2
        } = _ref;
        this._selectAllValueChangeAction({
          value: value2
        });
      },
      selectAllMode: this.option("selectAllMode"),
      selectedItems: this._selectedItems,
      onFocusedItemChanged: null
    });
  },
  _renderMultiSelect() {
    const d = Deferred();
    this._updateTagsContainer(this._$textEditorInputContainer);
    this._renderInputSize();
    this._renderTags().done(() => {
      this._popup && this._popup.refreshPosition();
      d.resolve();
    }).fail(d.reject);
    return d.promise();
  },
  _listItemClickHandler(e) {
    !this.option("showSelectionControls") && this._clearTextValue();
    if ("useButtons" === this.option("applyValueMode")) {
      return;
    }
    this.callBase(e);
    this._saveValueChangeEvent(void 0);
  },
  _shouldClearFilter() {
    const shouldClearFilter = this.callBase();
    const showSelectionControls = this.option("showSelectionControls");
    return !showSelectionControls && shouldClearFilter;
  },
  _renderInputSize() {
    const $input = this._input();
    const value2 = $input.val();
    const isEmptyInput = isString(value2) && value2;
    let width = "";
    let size;
    const canTypeText = this.option("searchEnabled") || this.option("acceptCustomValue");
    if (isEmptyInput && canTypeText) {
      const $calculationElement = createTextElementHiddenCopy($input, value2, {
        includePaddings: true
      });
      $calculationElement.insertAfter($input);
      width = getOuterWidth($calculationElement) + 5;
      $calculationElement.remove();
    } else if (!value2) {
      size = 1;
    }
    $input.css("width", width);
    $input.attr("size", size ?? "");
  },
  _renderInputSubstitution() {
    this.callBase();
    this._updateWidgetHeight();
  },
  _getValue() {
    return this.option("value") || [];
  },
  _multiTagRequired() {
    const values = this._getValue();
    const maxDisplayedTags = this.option("maxDisplayedTags");
    return isDefined(maxDisplayedTags) && values.length > maxDisplayedTags;
  },
  _renderMultiTag($input) {
    const tagId = `dx-${new guid_default()}`;
    const $tag = renderer_default("<div>").attr("id", tagId).addClass("dx-tag").addClass("dx-tagbox-multi-tag");
    const args = {
      multiTagElement: getPublicElement($tag),
      selectedItems: this.option("selectedItems")
    };
    this._multiTagPreparingAction(args);
    if (args.cancel) {
      return false;
    }
    $tag.data("dxTagData", args.text);
    $tag.insertBefore($input);
    this._tagTemplate.render({
      model: args.text,
      container: getPublicElement($tag)
    });
    const tagText = args.text;
    this._setTagAria($tag, tagText);
    this._updateElementAria(tagId);
    return $tag;
  },
  _getFilter(creator) {
    const dataSourceFilter = this._dataController.filter();
    const filterExpr = creator.getCombinedFilter(this.option("valueExpr"), dataSourceFilter);
    const filterQueryLength = encodeURI(JSON.stringify(filterExpr)).length;
    const maxFilterQueryLength = this.option("maxFilterQueryLength");
    if (filterQueryLength <= maxFilterQueryLength) {
      return filterExpr;
    }
    ui_errors_default.log("W1019", maxFilterQueryLength);
  },
  _getFilteredItems(values) {
    var _this$_loadFilteredIt, _this$_list;
    null === (_this$_loadFilteredIt = this._loadFilteredItemsPromise) || void 0 === _this$_loadFilteredIt || _this$_loadFilteredIt.reject();
    const creator = new SelectionFilterCreator(values);
    const listSelectedItems = null === (_this$_list = this._list) || void 0 === _this$_list ? void 0 : _this$_list.option("selectedItems");
    const isListItemsLoaded = !!listSelectedItems && this._list._dataController.isLoaded();
    const selectedItems = listSelectedItems || this.option("selectedItems");
    const clientFilterFunction = creator.getLocalFilter(this._valueGetter);
    const filteredItems = selectedItems.filter(clientFilterFunction);
    const selectedItemsAlreadyLoaded = filteredItems.length === values.length;
    const d = Deferred();
    const dataController = this._dataController;
    if ((!this._isDataSourceChanged || isListItemsLoaded) && selectedItemsAlreadyLoaded) {
      return d.resolve(filteredItems).promise();
    }
    const {
      customQueryParams,
      expand,
      select
    } = dataController.loadOptions();
    const filter = this._getFilter(creator);
    dataController.loadFromStore({
      filter,
      customQueryParams,
      expand,
      select
    }).done((data2, extra) => {
      this._isDataSourceChanged = false;
      if (this._disposed) {
        d.reject();
        return;
      }
      const {
        data: items
      } = normalizeLoadResult(data2, extra);
      const mappedItems = dataController.applyMapFunction(items);
      d.resolve(mappedItems.filter(clientFilterFunction));
    }).fail(d.reject);
    this._loadFilteredItemsPromise = d;
    return d.promise();
  },
  _createTagsData(values, filteredItems) {
    const items = [];
    const cache = {};
    const isValueExprSpecified = "this" === this._valueGetterExpr();
    const filteredValues = {};
    filteredItems.forEach((filteredItem) => {
      const filteredItemValue = isValueExprSpecified ? JSON.stringify(filteredItem) : this._valueGetter(filteredItem);
      filteredValues[filteredItemValue] = filteredItem;
    });
    const loadItemPromises = [];
    values.forEach((value2, index2) => {
      const currentItem = filteredValues[isValueExprSpecified ? JSON.stringify(value2) : value2];
      if (isValueExprSpecified && !isDefined(currentItem)) {
        loadItemPromises.push(this._loadItem(value2, cache).always((item) => {
          const newItem = this._createTagData(item, value2);
          items.splice(index2, 0, newItem);
        }));
      } else {
        const newItem = this._createTagData(currentItem, value2);
        items.splice(index2, 0, newItem);
      }
    });
    const d = Deferred();
    when.apply(this, loadItemPromises).always(() => {
      d.resolve(items);
    });
    return d.promise();
  },
  _createTagData(item, value2) {
    if (isDefined(item)) {
      this._selectedItems.push(item);
      return item;
    }
    const selectedItem = this.option("selectedItem");
    const customItem = this._valueGetter(selectedItem) === value2 ? selectedItem : value2;
    return customItem;
  },
  _isGroupedData() {
    return this.option("grouped") && !this._dataController.group();
  },
  _getItemsByValues(values) {
    const resultItems = [];
    values.forEach((value2) => {
      const item = this._getItemFromPlain(value2);
      if (isDefined(item)) {
        resultItems.push(item);
      }
    });
    return resultItems;
  },
  _getFilteredGroupedItems(values) {
    const selectedItems = Deferred();
    if (this._filteredGroupedItemsLoadPromise) {
      this._dataController.cancel(this._filteredGroupedItemsLoadPromise.operationId);
    }
    if (!this._dataController.items().length) {
      this._filteredGroupedItemsLoadPromise = this._dataController.load().done(() => {
        selectedItems.resolve(this._getItemsByValues(values));
      }).fail(() => {
        selectedItems.resolve([]);
      }).always(() => {
        this._filteredGroupedItemsLoadPromise = void 0;
      });
    } else {
      selectedItems.resolve(this._getItemsByValues(values));
    }
    return selectedItems.promise();
  },
  _loadTagsData() {
    const values = this._getValue();
    const tagData = Deferred();
    this._selectedItems = [];
    const filteredItemsPromise = this._isGroupedData() ? this._getFilteredGroupedItems(values) : this._getFilteredItems(values);
    filteredItemsPromise.done((filteredItems) => {
      const items = this._createTagsData(values, filteredItems);
      items.always((data2) => {
        tagData.resolve(data2);
      });
    }).fail(tagData.reject.bind(this));
    return tagData.promise();
  },
  _renderTags() {
    const d = Deferred();
    let isPlainDataUsed = false;
    if (this._shouldGetItemsFromPlain(this._valuesToUpdate)) {
      this._selectedItems = this._getItemsFromPlain(this._valuesToUpdate);
      if (this._selectedItems.length === this._valuesToUpdate.length) {
        this._renderTagsImpl(this._selectedItems);
        isPlainDataUsed = true;
        d.resolve();
      }
    }
    if (!isPlainDataUsed) {
      this._loadTagsData().done((items) => {
        if (this._disposed) {
          d.reject();
          return;
        }
        this._renderTagsImpl(items);
        d.resolve();
      }).fail(d.reject);
    }
    return d.promise();
  },
  _renderTagsImpl(items) {
    this._renderTagsCore(items);
    this._renderEmptyState();
    if (!this._preserveFocusedTag) {
      this._clearTagFocus();
    }
  },
  _shouldGetItemsFromPlain(values) {
    return values && this._dataController.isLoaded() && values.length <= this._getPlainItems().length;
  },
  _getItemsFromPlain(values) {
    let selectedItems = this._getSelectedItemsFromList(values);
    const needFilterPlainItems = 0 === selectedItems.length && values.length > 0 || selectedItems.length < values.length;
    if (needFilterPlainItems) {
      const plainItems = this._getPlainItems();
      selectedItems = this._filterSelectedItems(plainItems, values);
    }
    return selectedItems;
  },
  _getSelectedItemsFromList(values) {
    var _this$_list2;
    const listSelectedItems = null === (_this$_list2 = this._list) || void 0 === _this$_list2 ? void 0 : _this$_list2.option("selectedItems");
    let selectedItems = [];
    if (values.length === (null === listSelectedItems || void 0 === listSelectedItems ? void 0 : listSelectedItems.length)) {
      selectedItems = this._filterSelectedItems(listSelectedItems, values);
    }
    return selectedItems;
  },
  _filterSelectedItems(plainItems, values) {
    const selectedItems = plainItems.filter((dataItem) => {
      let currentValue;
      for (let i = 0; i < values.length; i++) {
        currentValue = values[i];
        if (isObject(currentValue)) {
          if (this._isValueEquals(dataItem, currentValue)) {
            return true;
          }
        } else if (this._isValueEquals(this._valueGetter(dataItem), currentValue)) {
          return true;
        }
      }
      return false;
    }, this);
    return selectedItems;
  },
  _integrateInput() {
    this._isInputReady.resolve();
    this.callBase();
    const tagsContainer = this.$element().find(".dx-texteditor-input-container");
    this._updateTagsContainer(tagsContainer);
    this._renderTagRemoveAction();
  },
  _renderTagsCore(items) {
    var _this$_isInputReady;
    null === (_this$_isInputReady = this._isInputReady) || void 0 === _this$_isInputReady || _this$_isInputReady.reject();
    this._isInputReady = Deferred();
    this._renderField();
    this.option("selectedItems", this._selectedItems.slice());
    this._cleanTags();
    if (this._input().length > 0) {
      this._isInputReady.resolve();
    }
    when(this._isInputReady).done(() => {
      this._renderTagsElements(items);
    });
  },
  _renderTagsElements(items) {
    const $multiTag = this._multiTagRequired() && this._renderMultiTag(this._input());
    const showMultiTagOnly = this.option("showMultiTagOnly");
    const maxDisplayedTags = this.option("maxDisplayedTags");
    items.forEach((item, index2) => {
      if ($multiTag && showMultiTagOnly || $multiTag && !showMultiTagOnly && index2 - maxDisplayedTags >= -1) {
        return false;
      }
      this._renderTag(item, $multiTag || this._input());
      return;
    });
    if (this._isFocused()) {
      this._scrollContainer("end");
    }
    this._refreshTagElements();
  },
  _cleanTags() {
    if (this._multiTagRequired()) {
      this._tagElements().remove();
    } else {
      const $tags = this._tagElements();
      const values = this._getValue();
      each($tags, (_, tag) => {
        const $tag = renderer_default(tag);
        const tagData = $tag.data("dxTagData");
        if (!(null !== values && void 0 !== values && values.includes(tagData))) {
          $tag.remove();
        }
      });
    }
    this._updateElementAria();
  },
  _renderEmptyState() {
    const isEmpty2 = !(this._getValue().length || this._selectedItems.length || this._searchValue());
    this._toggleEmptiness(isEmpty2);
    this._renderDisplayText();
  },
  _renderDisplayText() {
    this._renderInputSize();
  },
  _refreshTagElements() {
    this._tagElementsCache = this.$element().find(".dx-tag");
  },
  _tagElements() {
    return this._tagElementsCache;
  },
  _applyTagTemplate(item, $tag) {
    this._tagTemplate.render({
      model: item,
      container: getPublicElement($tag)
    });
  },
  _renderTag(item, $input) {
    const value2 = this._valueGetter(item);
    if (!isDefined(value2)) {
      return;
    }
    let $tag = this._getTag(value2);
    const displayValue = this._displayGetter(item);
    const itemModel = this._getItemModel(item, displayValue);
    if ($tag) {
      if (isDefined(displayValue)) {
        $tag.empty();
        this._applyTagTemplate(itemModel, $tag);
      }
      $tag.removeClass("dx-tag-custom");
      this._updateElementAria($tag.attr("id"));
    } else {
      const tagId = `dx-${new guid_default()}`;
      $tag = this._createTag(value2, $input, tagId);
      this._setTagAria($tag, isDefined(displayValue) ? displayValue : value2);
      if (isDefined(item)) {
        this._applyTagTemplate(itemModel, $tag);
      } else {
        $tag.addClass("dx-tag-custom");
        this._applyTagTemplate(value2, $tag);
      }
      this._updateElementAria(tagId);
    }
  },
  _setTagAria($tag, tagText) {
    const aria = {
      role: "button",
      label: tagText,
      roledescription: message_default.format("dxTagBox-tagRoleDescription")
    };
    this.setAria(aria, $tag);
  },
  _getItemModel(item, displayValue) {
    if (isObject(item) && isDefined(displayValue)) {
      return item;
    }
    return ensureDefined(displayValue, "");
  },
  _getTag(value2) {
    const $tags = this._tagElements();
    const tagsLength = $tags.length;
    let result2 = false;
    for (let i = 0; i < tagsLength; i++) {
      const $tag = $tags[i];
      const tagData = data($tag, "dxTagData");
      if (value2 === tagData || equalByValue(value2, tagData)) {
        result2 = renderer_default($tag);
        break;
      }
    }
    return result2;
  },
  _createTag: (value2, $input, tagId) => renderer_default("<div>").attr("id", tagId).addClass("dx-tag").data("dxTagData", value2).insertBefore($input),
  _toggleEmptinessEventHandler() {
    this._toggleEmptiness(!this._getValue().length && !this._searchValue().length);
  },
  _customItemAddedHandler(e) {
    this.callBase(e);
    this._clearTextValue();
  },
  _removeTagHandler(args) {
    const e = args.event;
    e.stopPropagation();
    this._saveValueChangeEvent(e);
    const $tag = renderer_default(e.target).closest(".dx-tag");
    this._removeTagElement($tag);
  },
  _removeTagElement($tag) {
    if ($tag.hasClass("dx-tagbox-multi-tag")) {
      if (!this.option("showMultiTagOnly")) {
        this.option("value", this._getValue().slice(0, this.option("maxDisplayedTags")));
      } else {
        this.clear();
      }
      return;
    }
    const itemValue = $tag.data("dxTagData");
    const itemId = $tag.attr("id");
    this._removeTagWithUpdate(itemValue);
    this._updateElementAria(itemId, true);
    this._refreshTagElements();
  },
  _updateField: noop2,
  _removeTagWithUpdate(itemValue) {
    const value2 = this._getValue().slice();
    this._removeTag(value2, itemValue);
    this.option("value", value2);
    this.option("selectedItem", null);
    if (0 === value2.length) {
      this._clearTagFocus();
    }
  },
  _getCurrentValue() {
    return this._lastValue();
  },
  _selectionChangeHandler(e) {
    if ("useButtons" === this.option("applyValueMode")) {
      return;
    }
    const value2 = this._getValue().slice();
    each(e.removedItems || [], (_, removedItem) => {
      this._removeTag(value2, this._valueGetter(removedItem));
    });
    each(e.addedItems || [], (_, addedItem) => {
      this._addTag(value2, this._valueGetter(addedItem));
    });
    this._updateWidgetHeight();
    if (!equalByValue(this._list.option("selectedItemKeys"), this.option("value"))) {
      const listSelectionChangeEvent = this._list._getSelectionChangeEvent();
      listSelectionChangeEvent && this._saveValueChangeEvent(listSelectionChangeEvent);
      this.option("value", value2);
    }
    this._list._saveSelectionChangeEvent(void 0);
  },
  _removeTag(value2, item) {
    const index2 = this._valueIndex(item, value2);
    if (index2 >= 0) {
      value2.splice(index2, 1);
    }
  },
  _addTag(value2, item) {
    const index2 = this._valueIndex(item);
    if (index2 < 0) {
      value2.push(item);
    }
  },
  _fieldRenderData() {
    return this._selectedItems.slice();
  },
  _completeSelection(value2) {
    if (!this.option("showSelectionControls")) {
      this._setValue(value2);
    }
  },
  _setValue(value2) {
    var _this$_list3;
    if (null === value2) {
      return;
    }
    const useButtons = "useButtons" === this.option("applyValueMode");
    const valueIndex = this._valueIndex(value2);
    const values = (useButtons ? (null === (_this$_list3 = this._list) || void 0 === _this$_list3 ? void 0 : _this$_list3.option("selectedItemKeys")) || [] : this._getValue()).slice();
    if (valueIndex >= 0) {
      values.splice(valueIndex, 1);
    } else {
      values.push(value2);
    }
    if (useButtons) {
      var _this$_list4;
      null === (_this$_list4 = this._list) || void 0 === _this$_list4 || _this$_list4.option("selectedItemKeys", values);
    } else {
      this.option("value", values);
    }
  },
  _isSelectedValue(value2, cache) {
    return this._valueIndex(value2, null, cache) > -1;
  },
  _valueIndex(value2, values, cache) {
    let result2 = -1;
    if (cache && "object" !== typeof value2) {
      if (!cache.indexByValues) {
        cache.indexByValues = {};
        values = values || this._getValue();
        values.forEach((value3, index2) => {
          cache.indexByValues[value3] = index2;
        });
      }
      if (value2 in cache.indexByValues) {
        return cache.indexByValues[value2];
      }
    }
    values = values || this._getValue();
    each(values, (index2, selectedValue) => {
      if (this._isValueEquals(value2, selectedValue)) {
        result2 = index2;
        return false;
      }
      return;
    });
    return result2;
  },
  _lastValue() {
    const values = this._getValue();
    const lastValue = values[values.length - 1];
    return lastValue ?? null;
  },
  _shouldRenderSearchEvent() {
    return this.option("searchEnabled") || this.option("acceptCustomValue");
  },
  _searchHandler(e) {
    if (this.option("searchEnabled") && !!e && !this._isTagRemoved) {
      this.callBase(arguments);
      this._setListDataSourceFilter();
    }
    this._updateWidgetHeight();
    delete this._isTagRemoved;
  },
  _updateWidgetHeight() {
    const element = this.$element();
    const originalHeight = getHeight(element);
    this._renderInputSize();
    const currentHeight = getHeight(element);
    if (this._popup && this.option("opened") && this._isEditable() && currentHeight !== originalHeight) {
      this._popup.repaint();
    }
  },
  _refreshSelected() {
    var _this$_list5;
    (null === (_this$_list5 = this._list) || void 0 === _this$_list5 ? void 0 : _this$_list5.getDataSource()) && this._list.option("selectedItems", this._selectedItems);
  },
  _resetListDataSourceFilter() {
    const dataController = this._dataController;
    delete this._userFilter;
    dataController.filter(null);
    dataController.reload();
  },
  _setListDataSourceFilter() {
    if (!this.option("hideSelectedItems") || !this._list) {
      return;
    }
    const dataController = this._dataController;
    const valueGetterExpr = this._valueGetterExpr();
    if (isString(valueGetterExpr) && "this" !== valueGetterExpr) {
      const filter = this._dataSourceFilterExpr();
      if (void 0 === this._userFilter) {
        this._userFilter = dataController.filter() || null;
      }
      this._userFilter && filter.push(this._userFilter);
      filter.length ? dataController.filter(filter) : dataController.filter(null);
    } else {
      dataController.filter(this._dataSourceFilterFunction.bind(this));
    }
    dataController.load();
  },
  _dataSourceFilterExpr() {
    const filter = [];
    this._getValue().forEach((value2) => filter.push(["!", [this._valueGetterExpr(), value2]]));
    return filter;
  },
  _dataSourceFilterFunction(itemData) {
    const itemValue = this._valueGetter(itemData);
    let result2 = true;
    each(this._getValue(), (index2, value2) => {
      if (this._isValueEquals(value2, itemValue)) {
        result2 = false;
        return false;
      }
      return;
    });
    return result2;
  },
  _dataSourceChangedHandler() {
    this._isDataSourceChanged = true;
    this.callBase.apply(this, arguments);
  },
  _applyButtonHandler(args) {
    this._saveValueChangeEvent(args.event);
    this.option("value", this._getSortedListValues());
    this._clearTextValue();
    this.callBase();
    this._cancelSearchIfNeed();
  },
  _getSortedListValues() {
    const listValues = this._getListValues();
    const currentValue = this.option("value") || [];
    const existedItems = listValues.length ? getIntersection(currentValue, listValues) : [];
    const newItems = existedItems.length ? removeDuplicates(listValues, currentValue) : listValues;
    return existedItems.concat(newItems);
  },
  _getListValues() {
    if (!this._list) {
      return [];
    }
    return this._getPlainItems(this._list.option("selectedItems")).map((item) => this._valueGetter(item));
  },
  _setListDataSource() {
    const currentValue = this._getValue();
    this.callBase();
    if (currentValue !== this.option("value")) {
      this.option("value", currentValue);
    }
    this._refreshSelected();
  },
  _renderOpenedState() {
    this.callBase();
    if ("useButtons" === this.option("applyValueMode") && !this.option("opened")) {
      this._refreshSelected();
    }
  },
  clear() {
    this._restoreInputText();
    const defaultValue = this._getDefaultOptions().value;
    const currentValue = this.option("value");
    if (defaultValue && 0 === defaultValue.length && currentValue && defaultValue.length === currentValue.length) {
      return;
    }
    this.callBase();
  },
  _clean() {
    this.callBase();
    delete this._defaultTagTemplate;
    delete this._valuesToUpdate;
    delete this._tagTemplate;
  },
  _getSelectedItemsDifference(newItems, previousItems) {
    if (!newItems.length) {
      return {
        addedItems: [],
        removedItems: previousItems.slice()
      };
    }
    if (!previousItems.length) {
      return {
        addedItems: newItems.slice(),
        removedItems: []
      };
    }
    const previousItemsValuesMap = previousItems.reduce((map2, item) => {
      const value2 = this._valueGetter(item);
      map2[value2] = item;
      return map2;
    }, {});
    const addedItems = [];
    newItems.forEach((item) => {
      const value2 = this._valueGetter(item);
      if (!previousItemsValuesMap[value2]) {
        addedItems.push(item);
      }
      delete previousItemsValuesMap[value2];
    });
    return {
      addedItems,
      removedItems: Object.values(previousItemsValuesMap)
    };
  },
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "onSelectAllValueChanged":
        this._initSelectAllValueChangedAction();
        break;
      case "onMultiTagPreparing":
        this._initMultiTagPreparingAction();
        this._renderTags();
        break;
      case "hideSelectedItems":
        if (value2) {
          this._setListDataSourceFilter();
        } else {
          this._resetListDataSourceFilter();
        }
        break;
      case "useSubmitBehavior":
        this._toggleSubmitElement(value2);
        break;
      case "displayExpr":
        this.callBase(args);
        this._initTemplates();
        this._invalidate();
        break;
      case "tagTemplate":
        this._initTagTemplate();
        this._invalidate();
        break;
      case "selectAllText":
        this._setListOption("selectAllText", this.option("selectAllText"));
        break;
      case "readOnly":
      case "disabled":
        this.callBase(args);
        !value2 && this._refreshEvents();
        break;
      case "value":
        this._valuesToUpdate = value2;
        this.callBase(args);
        this._valuesToUpdate = void 0;
        this._setListDataSourceFilter();
        break;
      case "maxDisplayedTags":
      case "showMultiTagOnly":
        this._renderTags();
        break;
      case "selectAllMode":
        this._setListOption(name2, value2);
        break;
      case "selectedItem":
      case "maxFilterQueryLength":
        break;
      case "selectedItems":
        this._selectionChangedAction(this._getSelectedItemsDifference(value2, previousValue));
        break;
      case "multiline":
        this.$element().toggleClass("dx-tagbox-single-line", !value2);
        this._renderSingleLineScroll();
        break;
      default:
        this.callBase(args);
    }
  },
  _getActualSearchValue() {
    return this.callBase() || this._searchValue();
  },
  _popupHidingHandler() {
    this.callBase();
    this._clearFilter();
  }
});
component_registrator_default("dxTagBox", TagBox);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_switch.js
var Switch = editor_default.inherit({
  _supportedKeys() {
    const isRTL = this.option("rtlEnabled");
    const click2 = function(e) {
      e.preventDefault();
      this._clickAction({
        event: e
      });
    };
    const move2 = function(value2, e) {
      e.preventDefault();
      e.stopPropagation();
      this._saveValueChangeEvent(e);
      this._animateValue(value2);
    };
    return extend(this.callBase(), {
      space: click2,
      enter: click2,
      leftArrow: move2.bind(this, !!isRTL),
      rightArrow: move2.bind(this, !isRTL)
    });
  },
  _useTemplates: () => false,
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      switchedOnText: message_default.format("dxSwitch-switchedOnText"),
      switchedOffText: message_default.format("dxSwitch-switchedOffText"),
      value: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  },
  _feedbackHideTimeout: 0,
  _animating: false,
  _initMarkup() {
    this._renderContainers();
    this.$element().addClass("dx-switch").append(this._$switchWrapper);
    this._renderSubmitElement();
    this._renderClick();
    this.setAria("role", "switch");
    this._renderSwipeable();
    this.callBase();
    this._renderSwitchInner();
    this._renderLabels();
    this._renderValue();
  },
  _getInnerOffset(value2, offset2) {
    const ratio = (offset2 - this._offsetDirection() * Number(!value2)) / 2;
    return 100 * ratio + "%";
  },
  _getHandleOffset(value2, offset2) {
    if (this.option("rtlEnabled")) {
      value2 = !value2;
    }
    if (value2) {
      const calcValue = 100 * -offset2 - 100;
      return `${calcValue}%`;
    }
    return 100 * -offset2 + "%";
  },
  _renderSwitchInner() {
    this._$switchInner = renderer_default("<div>").addClass("dx-switch-inner").appendTo(this._$switchContainer);
    this._$handle = renderer_default("<div>").addClass("dx-switch-handle").appendTo(this._$switchInner);
  },
  _renderLabels() {
    this._$labelOn = renderer_default("<div>").addClass("dx-switch-on").prependTo(this._$switchInner);
    this._$labelOff = renderer_default("<div>").addClass("dx-switch-off").appendTo(this._$switchInner);
    this._setLabelsText();
  },
  _renderContainers() {
    this._$switchContainer = renderer_default("<div>").addClass("dx-switch-container");
    this._$switchWrapper = renderer_default("<div>").addClass("dx-switch-wrapper").append(this._$switchContainer);
  },
  _renderSwipeable() {
    this._createComponent(this.$element(), swipeable_default, {
      elastic: false,
      immediate: true,
      onStart: this._swipeStartHandler.bind(this),
      onUpdated: this._swipeUpdateHandler.bind(this),
      onEnd: this._swipeEndHandler.bind(this),
      itemSizeFunc: this._getItemSizeFunc.bind(this)
    });
  },
  _getItemSizeFunc() {
    return getOuterWidth(this._$switchContainer, true) - getBoundingRect(this._$handle.get(0)).width;
  },
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
  },
  _getSubmitElement() {
    return this._$submitElement;
  },
  _offsetDirection() {
    return this.option("rtlEnabled") ? -1 : 1;
  },
  _renderPosition(state, swipeOffset) {
    const innerOffset = this._getInnerOffset(state, swipeOffset);
    const handleOffset = this._getHandleOffset(state, swipeOffset);
    this._$switchInner.css("transform", ` translateX(${innerOffset})`);
    this._$handle.css("transform", ` translateX(${handleOffset})`);
  },
  _validateValue() {
    const check = this.option("value");
    if ("boolean" !== typeof check) {
      this._options.silent("value", !!check);
    }
  },
  _renderClick() {
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const $element = this.$element();
    this._clickAction = this._createAction(this._clickHandler.bind(this));
    events_engine_default.off($element, eventName);
    events_engine_default.on($element, eventName, (e) => {
      this._clickAction({
        event: e
      });
    });
  },
  _clickHandler(args) {
    const e = args.event;
    this._saveValueChangeEvent(e);
    if (this._animating || this._swiping) {
      return;
    }
    this._animateValue(!this.option("value"));
  },
  _animateValue(value2) {
    const startValue = this.option("value");
    const endValue = value2;
    if (startValue === endValue) {
      return;
    }
    this._animating = true;
    const fromInnerOffset = this._getInnerOffset(startValue, 0);
    const toInnerOffset = this._getInnerOffset(endValue, 0);
    const fromHandleOffset = this._getHandleOffset(startValue, 0);
    const toHandleOffset = this._getHandleOffset(endValue, 0);
    const that = this;
    const fromInnerConfig = {};
    const toInnerConfig = {};
    const fromHandleConfig = {};
    const toHandlerConfig = {};
    fromInnerConfig.transform = ` translateX(${fromInnerOffset})`;
    toInnerConfig.transform = ` translateX(${toInnerOffset})`;
    fromHandleConfig.transform = ` translateX(${fromHandleOffset})`;
    toHandlerConfig.transform = ` translateX(${toHandleOffset})`;
    this.$element().toggleClass("dx-switch-on-value", endValue);
    fx_default.animate(this._$handle, {
      from: fromHandleConfig,
      to: toHandlerConfig,
      duration: 100
    });
    fx_default.animate(this._$switchInner, {
      from: fromInnerConfig,
      to: toInnerConfig,
      duration: 100,
      complete() {
        that._animating = false;
        that.option("value", endValue);
      }
    });
  },
  _swipeStartHandler(e) {
    const state = this.option("value");
    const rtlEnabled = this.option("rtlEnabled");
    const maxOffOffset = rtlEnabled ? 0 : 1;
    const maxOnOffset = rtlEnabled ? 1 : 0;
    e.event.maxLeftOffset = state ? maxOffOffset : maxOnOffset;
    e.event.maxRightOffset = state ? maxOnOffset : maxOffOffset;
    this._swiping = true;
    this._feedbackDeferred = Deferred();
    lock(this._feedbackDeferred);
    this._toggleActiveState(this.$element(), this.option("activeStateEnabled"));
  },
  _swipeUpdateHandler(e) {
    this._renderPosition(this.option("value"), e.event.offset);
  },
  _swipeEndHandler(e) {
    const that = this;
    const offsetDirection = this._offsetDirection();
    const toInnerConfig = {};
    const toHandleConfig = {};
    const innerOffset = this._getInnerOffset(that.option("value"), e.event.targetOffset);
    const handleOffset = this._getHandleOffset(that.option("value"), e.event.targetOffset);
    toInnerConfig.transform = ` translateX(${innerOffset})`;
    toHandleConfig.transform = ` translateX(${handleOffset})`;
    fx_default.animate(this._$handle, {
      to: toHandleConfig,
      duration: 100
    });
    fx_default.animate(this._$switchInner, {
      to: toInnerConfig,
      duration: 100,
      complete() {
        that._swiping = false;
        const pos = that.option("value") + offsetDirection * e.event.targetOffset;
        that._saveValueChangeEvent(e.event);
        that.option("value", Boolean(pos));
        that._feedbackDeferred.resolve();
        that._toggleActiveState(that.$element(), false);
      }
    });
  },
  _renderValue() {
    this._validateValue();
    const value2 = this.option("value");
    this._renderPosition(value2, 0);
    this.$element().toggleClass("dx-switch-on-value", value2);
    this._getSubmitElement().val(value2);
    this.setAria({
      checked: value2,
      label: value2 ? this.option("switchedOnText") : this.option("switchedOffText")
    });
  },
  _setLabelsText() {
    this._$labelOn && this._$labelOn.text(this.option("switchedOnText"));
    this._$labelOff && this._$labelOff.text(this.option("switchedOffText"));
  },
  _visibilityChanged(visible2) {
    if (visible2) {
      this.repaint();
    }
  },
  _optionChanged(args) {
    switch (args.name) {
      case "width":
        delete this._marginBound;
        this._refresh();
        break;
      case "switchedOnText":
      case "switchedOffText":
        this._setLabelsText();
        break;
      case "value":
        this._renderValue();
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  }
});
component_registrator_default("dxSwitch", Switch);

// ../../../../../../node_modules/devextreme/esm/data/data_source.js
var data_source_default = DataSource;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/semaphore/index.js
var Semaphore = class {
  constructor() {
    this.counter = 0;
  }
  isFree() {
    return 0 === this.counter;
  }
  take() {
    this.counter += 1;
  }
  release() {
    this.counter -= 1;
    if (this.counter < 0) {
      this.counter = 0;
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointment_popup/m_form.js
var APPOINTMENT_FORM_GROUP_NAMES = {
  Main: "mainGroup",
  Recurrence: "recurrenceGroup"
};
var E2E_TEST_CLASSES = {
  form: "e2e-dx-scheduler-form",
  textEditor: "e2e-dx-scheduler-form-text",
  descriptionEditor: "e2e-dx-scheduler-form-description",
  startDateEditor: "e2e-dx-scheduler-form-start-date",
  endDateEditor: "e2e-dx-scheduler-form-end-date",
  startDateTimeZoneEditor: "e2e-dx-scheduler-form-start-date-timezone",
  endDateTimeZoneEditor: "e2e-dx-scheduler-form-end-date-timezone",
  allDaySwitch: "e2e-dx-scheduler-form-all-day-switch",
  recurrenceSwitch: "e2e-dx-scheduler-form-recurrence-switch"
};
var getStylingModeFunc2 = () => isFluent(current()) ? "filled" : void 0;
var getStartDateWithStartHour = (startDate, startDayHour) => new Date(new Date(startDate).setHours(startDayHour));
var validateAppointmentFormDate = (editor, value2, previousValue) => {
  const isCurrentDateCorrect = null === value2 || !!value2;
  const isPreviousDateCorrect = null === previousValue || !!previousValue;
  if (!isCurrentDateCorrect && isPreviousDateCorrect) {
    editor.option("value", previousValue);
  }
};
var updateRecurrenceItemVisibility = (recurrenceRuleExpr, value2, form) => {
  var _form$getEditor;
  form.itemOption(APPOINTMENT_FORM_GROUP_NAMES.Recurrence, "visible", value2);
  null === (_form$getEditor = form.getEditor(recurrenceRuleExpr)) || void 0 === _form$getEditor || _form$getEditor.changeValueByVisibility(value2);
};
var AppointmentForm = class {
  constructor(scheduler) {
    this.scheduler = scheduler;
    this.form = null;
    this.semaphore = new Semaphore();
  }
  get dxForm() {
    return this.form;
  }
  set readOnly(value2) {
    this.form.option("readOnly", value2);
    const {
      recurrenceRuleExpr
    } = this.scheduler.getDataAccessors().expr;
    const recurrenceEditor = this.form.getEditor(recurrenceRuleExpr);
    null === recurrenceEditor || void 0 === recurrenceEditor || recurrenceEditor.option("readOnly", value2);
  }
  get formData() {
    return this.form.option("formData");
  }
  set formData(value2) {
    this.form.option("formData", value2);
  }
  create(triggerResize, changeSize, formData) {
    const {
      allowTimeZoneEditing
    } = this.scheduler.getEditingConfig();
    const dataAccessors = this.scheduler.getDataAccessors();
    const {
      expr
    } = dataAccessors;
    const isRecurrence = !!ExpressionUtils.getField(dataAccessors, "recurrenceRule", formData);
    const colSpan = isRecurrence ? 1 : 2;
    const mainItems = [...this._createMainItems(expr, triggerResize, changeSize, allowTimeZoneEditing), ...this.scheduler.createResourceEditorModel()];
    changeSize(isRecurrence);
    const items = [{
      itemType: "group",
      name: APPOINTMENT_FORM_GROUP_NAMES.Main,
      colCountByScreen: {
        lg: 2,
        xs: 1
      },
      colSpan,
      items: mainItems
    }, {
      itemType: "group",
      name: APPOINTMENT_FORM_GROUP_NAMES.Recurrence,
      visible: isRecurrence,
      colSpan,
      items: this._createRecurrenceEditor(expr)
    }];
    const element = renderer_default("<div>");
    this.scheduler.createComponent(element, form_default, {
      items,
      showValidationSummary: true,
      scrollingEnabled: true,
      colCount: "auto",
      colCountByScreen: {
        lg: 2,
        xs: 1
      },
      formData,
      showColonAfterLabel: false,
      labelLocation: "top",
      onInitialized: (e) => {
        this.form = e.component;
      },
      customizeItem: (e) => {
        if (this.form && "group" === e.itemType) {
          const dataExprs = this.scheduler.getDataAccessors().expr;
          const startDate = new Date(this.formData[dataExprs.startDateExpr]);
          const endDate = new Date(this.formData[dataExprs.endDateExpr]);
          const startTimeZoneEditor = e.items.find((i) => i.dataField === dataExprs.startDateTimeZoneExpr);
          const endTimeZoneEditor = e.items.find((i) => i.dataField === dataExprs.endDateTimeZoneExpr);
          if (startTimeZoneEditor) {
            startTimeZoneEditor.editorOptions.dataSource = this.createTimeZoneDataSource(startDate);
          }
          if (endTimeZoneEditor) {
            endTimeZoneEditor.editorOptions.dataSource = this.createTimeZoneDataSource(endDate);
          }
        }
      },
      screenByWidth: (width) => width < 600 || "desktop" !== devices_default.current().deviceType ? "xs" : "lg",
      elementAttr: {
        class: E2E_TEST_CLASSES.form
      }
    });
  }
  createTimeZoneDataSource(date) {
    return new data_source_default({
      store: m_utils_time_zone_default.getTimeZones(date),
      paginate: true,
      pageSize: 10
    });
  }
  _createAppointmentAdapter(rawAppointment) {
    return createAppointmentAdapter(rawAppointment, this.scheduler.getDataAccessors());
  }
  _dateBoxValueChanged(args, dateExpr, isNeedCorrect) {
    validateAppointmentFormDate(args.component, args.value, args.previousValue);
    const value2 = date_serialization_default.deserializeDate(args.value);
    const previousValue = date_serialization_default.deserializeDate(args.previousValue);
    const dateEditor = this.form.getEditor(dateExpr);
    const dateValue = date_serialization_default.deserializeDate(dateEditor.option("value"));
    if (this.semaphore.isFree() && dateValue && value2 && isNeedCorrect(dateValue, value2)) {
      const duration = previousValue ? dateValue.getTime() - previousValue.getTime() : 0;
      dateEditor.option("value", new Date(value2.getTime() + duration));
    }
  }
  _createTimezoneEditor(timeZoneExpr, secondTimeZoneExpr, visibleIndex, colSpan, isMainTimeZone, cssClass) {
    let visible2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : false;
    const noTzTitle = message_default.format("dxScheduler-noTimezoneTitle");
    return {
      name: this.normalizeEditorName(timeZoneExpr),
      dataField: timeZoneExpr,
      editorType: "dxSelectBox",
      visibleIndex,
      colSpan,
      cssClass,
      label: {
        text: " "
      },
      editorOptions: {
        displayExpr: "title",
        valueExpr: "id",
        placeholder: noTzTitle,
        searchEnabled: true,
        onValueChanged: (args) => {
          const {
            form
          } = this;
          const secondTimezoneEditor = form.getEditor(secondTimeZoneExpr);
          if (isMainTimeZone) {
            secondTimezoneEditor.option("value", args.value);
          }
        }
      },
      visible: visible2
    };
  }
  _createDateBoxItems(dataExprs, allowTimeZoneEditing) {
    const colSpan = allowTimeZoneEditing ? 2 : 1;
    const firstDayOfWeek = this.scheduler.getFirstDayOfWeek();
    return [this.createDateBoxEditor(dataExprs.startDateExpr, colSpan, firstDayOfWeek, "dxScheduler-editorLabelStartDate", E2E_TEST_CLASSES.startDateEditor, (args) => {
      this._dateBoxValueChanged(args, dataExprs.endDateExpr, (endValue, startValue) => endValue < startValue);
    }), this._createTimezoneEditor(dataExprs.startDateTimeZoneExpr, dataExprs.endDateTimeZoneExpr, 1, colSpan, true, E2E_TEST_CLASSES.startDateTimeZoneEditor, allowTimeZoneEditing), this.createDateBoxEditor(dataExprs.endDateExpr, colSpan, firstDayOfWeek, "dxScheduler-editorLabelEndDate", E2E_TEST_CLASSES.endDateEditor, (args) => {
      this._dateBoxValueChanged(args, dataExprs.startDateExpr, (startValue, endValue) => endValue < startValue);
    }), this._createTimezoneEditor(dataExprs.endDateTimeZoneExpr, dataExprs.startDateTimeZoneExpr, 3, colSpan, false, E2E_TEST_CLASSES.endDateTimeZoneEditor, allowTimeZoneEditing)];
  }
  _changeFormItemDateType(name2, groupName, isAllDay) {
    const editorPath = this.getEditorPath(name2, groupName);
    const itemEditorOptions = this.form.itemOption(editorPath).editorOptions;
    const type2 = isAllDay ? "date" : "datetime";
    const newEditorOption = _extends({}, itemEditorOptions, {
      type: type2
    });
    this.form.itemOption(editorPath, "editorOptions", newEditorOption);
  }
  _createMainItems(dataExprs, triggerResize, changeSize, allowTimeZoneEditing) {
    return [{
      name: this.normalizeEditorName(dataExprs.textExpr),
      dataField: dataExprs.textExpr,
      cssClass: E2E_TEST_CLASSES.textEditor,
      editorType: "dxTextBox",
      colSpan: 2,
      label: {
        text: message_default.format("dxScheduler-editorLabelTitle")
      },
      editorOptions: {
        stylingMode: getStylingModeFunc2()
      }
    }, {
      itemType: "group",
      colSpan: 2,
      colCountByScreen: {
        lg: 2,
        xs: 1
      },
      items: this._createDateBoxItems(dataExprs, allowTimeZoneEditing)
    }, {
      itemType: "group",
      colSpan: 2,
      colCountByScreen: {
        lg: 2,
        xs: 2
      },
      items: [{
        name: this.normalizeEditorName(dataExprs.allDayExpr),
        dataField: dataExprs.allDayExpr,
        cssClass: `dx-appointment-form-switch ${E2E_TEST_CLASSES.allDaySwitch}`,
        editorType: "dxSwitch",
        label: {
          text: message_default.format("dxScheduler-allDay"),
          location: "right"
        },
        editorOptions: {
          onValueChanged: (args) => {
            const {
              value: value2
            } = args;
            const startDateEditor = this.form.getEditor(dataExprs.startDateExpr);
            const endDateEditor = this.form.getEditor(dataExprs.endDateExpr);
            const startDate = date_serialization_default.deserializeDate(startDateEditor.option("value"));
            if (this.semaphore.isFree() && startDate) {
              if (value2) {
                const allDayStartDate = date_default.trimTime(startDate);
                startDateEditor.option("value", new Date(allDayStartDate));
                endDateEditor.option("value", new Date(allDayStartDate));
              } else {
                const startDateWithStartHour = getStartDateWithStartHour(startDate, this.scheduler.getStartDayHour());
                const endDate = this.scheduler.getCalculatedEndDate(startDateWithStartHour);
                startDateEditor.option("value", startDateWithStartHour);
                endDateEditor.option("value", endDate);
              }
            }
            this._changeFormItemDateType(dataExprs.startDateExpr, "Main", value2);
            this._changeFormItemDateType(dataExprs.endDateExpr, "Main", value2);
          }
        }
      }, {
        editorType: "dxSwitch",
        dataField: "repeat",
        cssClass: `dx-appointment-form-switch ${E2E_TEST_CLASSES.recurrenceSwitch}`,
        name: "visibilityChanged",
        label: {
          text: message_default.format("dxScheduler-editorLabelRecurrence"),
          location: "right"
        },
        editorOptions: {
          onValueChanged: (args) => {
            const {
              form
            } = this;
            const colSpan = args.value ? 1 : 2;
            form.itemOption(APPOINTMENT_FORM_GROUP_NAMES.Main, "colSpan", colSpan);
            form.itemOption(APPOINTMENT_FORM_GROUP_NAMES.Recurrence, "colSpan", colSpan);
            updateRecurrenceItemVisibility(dataExprs.recurrenceRuleExpr, args.value, form);
            changeSize(args.value);
            triggerResize();
          }
        }
      }]
    }, {
      itemType: "empty",
      colSpan: 2
    }, {
      name: this.normalizeEditorName(dataExprs.descriptionExpr),
      dataField: dataExprs.descriptionExpr,
      cssClass: E2E_TEST_CLASSES.descriptionEditor,
      editorType: "dxTextArea",
      colSpan: 2,
      label: {
        text: message_default.format("dxScheduler-editorLabelDescription")
      },
      editorOptions: {
        stylingMode: getStylingModeFunc2()
      }
    }, {
      itemType: "empty",
      colSpan: 2
    }];
  }
  _createRecurrenceEditor(dataExprs) {
    return [{
      name: this.normalizeEditorName(dataExprs.recurrenceRuleExpr),
      dataField: dataExprs.recurrenceRuleExpr,
      editorType: "dxRecurrenceEditor",
      editorOptions: {
        firstDayOfWeek: this.scheduler.getFirstDayOfWeek(),
        timeZoneCalculator: this.scheduler.getTimeZoneCalculator(),
        getStartDateTimeZone: () => this._createAppointmentAdapter(this.formData).startDateTimeZone
      },
      label: {
        text: " ",
        visible: false
      }
    }];
  }
  setEditorsType(allDay) {
    const {
      startDateExpr,
      endDateExpr
    } = this.scheduler.getDataAccessors().expr;
    const startDateItemPath = this.getEditorPath(startDateExpr, "Main");
    const endDateItemPath = this.getEditorPath(endDateExpr, "Main");
    const startDateFormItem = this.form.itemOption(startDateItemPath);
    const endDateFormItem = this.form.itemOption(endDateItemPath);
    if (startDateFormItem && endDateFormItem) {
      const startDateEditorOptions = startDateFormItem.editorOptions;
      const endDateEditorOptions = endDateFormItem.editorOptions;
      startDateEditorOptions.type = endDateEditorOptions.type = allDay ? "date" : "datetime";
      this.form.itemOption(startDateItemPath, "editorOptions", startDateEditorOptions);
      this.form.itemOption(endDateItemPath, "editorOptions", endDateEditorOptions);
    }
  }
  updateRecurrenceEditorStartDate(date, expression) {
    const options2 = {
      startDate: date
    };
    this.setEditorOptions(expression, "Recurrence", options2);
  }
  setEditorOptions(name2, groupName, options2) {
    const editorPath = this.getEditorPath(name2, groupName);
    const editor = this.form.itemOption(editorPath);
    editor && this.form.itemOption(editorPath, "editorOptions", extend({}, editor.editorOptions, options2));
  }
  setTimeZoneEditorDataSource(date, name2) {
    const dataSource = this.createTimeZoneDataSource(date);
    this.setEditorOptions(name2, "Main", {
      dataSource
    });
  }
  updateFormData(formData) {
    this.semaphore.take();
    this.form.option("formData", formData);
    const dataAccessors = this.scheduler.getDataAccessors();
    const {
      expr
    } = dataAccessors;
    const rawStartDate = ExpressionUtils.getField(dataAccessors, "startDate", formData);
    const rawEndDate = ExpressionUtils.getField(dataAccessors, "endDate", formData);
    const allDay = ExpressionUtils.getField(dataAccessors, "allDay", formData);
    const startDate = new Date(rawStartDate);
    const endDate = new Date(rawEndDate);
    this.setTimeZoneEditorDataSource(startDate, expr.startDateTimeZoneExpr);
    this.setTimeZoneEditorDataSource(endDate, expr.endDateTimeZoneExpr);
    this.updateRecurrenceEditorStartDate(startDate, expr.recurrenceRuleExpr);
    this.setEditorsType(allDay);
    this.semaphore.release();
  }
  createDateBoxEditor(dataField, colSpan, firstDayOfWeek, label, cssClass, onValueChanged) {
    return {
      editorType: "dxDateBox",
      name: this.normalizeEditorName(dataField),
      dataField,
      colSpan,
      cssClass,
      label: {
        text: message_default.format(label)
      },
      validationRules: [{
        type: "required"
      }],
      editorOptions: {
        stylingMode: getStylingModeFunc2(),
        width: "100%",
        calendarOptions: {
          firstDayOfWeek
        },
        onValueChanged,
        useMaskBehavior: true
      }
    };
  }
  getEditorPath(name2, groupName) {
    const normalizedName = this.normalizeEditorName(name2);
    return `${APPOINTMENT_FORM_GROUP_NAMES[groupName]}.${normalizedName}`;
  }
  normalizeEditorName(name2) {
    return name2 ? name2.replace(/\./g, "_") : name2;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/appointment_popup/config.js
var POPUP_WIDTH = {
  DEFAULT: 485,
  RECURRENCE: 970,
  FULLSCREEN: 1e3,
  MOBILE: {
    DEFAULT: 350,
    FULLSCREEN: 500
  }
};
var isMobile = () => "desktop" !== devices_default.current().deviceType;
var isIOSPlatform = () => "ios" === devices_default.current().platform;
var TOOLBAR_LOCATION = {
  AFTER: "after",
  BEFORE: "before"
};
var getButtonsConfig = () => ({
  doneButton: {
    shortcut: "done",
    options: {
      text: message_default.format("Done")
    },
    location: TOOLBAR_LOCATION.AFTER
  },
  cancelButton: {
    shortcut: "cancel",
    location: isIOSPlatform() ? TOOLBAR_LOCATION.BEFORE : TOOLBAR_LOCATION.AFTER
  }
});
var getPopupToolbarItems = (allowUpdating, doneClick) => {
  const result2 = [];
  const buttonsConfig = getButtonsConfig();
  if (allowUpdating) {
    result2.push(_extends({}, buttonsConfig.doneButton, {
      onClick: doneClick
    }));
  }
  result2.push(buttonsConfig.cancelButton);
  return result2;
};
var isPopupFullScreenNeeded = () => {
  const window28 = getWindow();
  const width = window28 && getWidth(window28);
  if (width) {
    return isMobile() ? width < POPUP_WIDTH.MOBILE.FULLSCREEN : width < POPUP_WIDTH.FULLSCREEN;
  }
  return false;
};
var getMaxWidth = (isRecurrence) => {
  if (isMobile()) {
    return POPUP_WIDTH.MOBILE.DEFAULT;
  }
  return isRecurrence ? POPUP_WIDTH.RECURRENCE : POPUP_WIDTH.DEFAULT;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_loading.js
var loading = null;
var createLoadPanel = function(options2) {
  return new load_panel_default(renderer_default("<div>").appendTo(options2 && options2.container || value()), options2);
};
var removeLoadPanel = function() {
  if (!loading) {
    return;
  }
  loading.$element().remove();
  loading = null;
};
function show(options2) {
  removeLoadPanel();
  loading = createLoadPanel(options2);
  return loading.show();
}
function hide() {
  if (!loading) {
    return new Deferred().resolve();
  }
  return loading.hide().done(removeLoadPanel).promise();
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/resources/m_utils.js
var getValueExpr = (resource) => resource.valueExpr || "id";
var getDisplayExpr = (resource) => resource.displayExpr || "text";
var getFieldExpr = (resource) => resource.fieldExpr || resource.field;
var getWrappedDataSource = (dataSource) => {
  if (dataSource instanceof DataSource) {
    return dataSource;
  }
  const result2 = _extends({}, normalizeDataSourceOptions(dataSource), {
    pageSize: 0
  });
  if (!Array.isArray(dataSource)) {
    result2.filter = dataSource.filter;
  }
  return new DataSource(result2);
};
var createResourcesTree = (groups) => {
  let leafIndex = 0;
  const make = (group, groupIndex, result2, parent) => {
    result2 = result2 || [];
    for (let itemIndex = 0; itemIndex < group.items.length; itemIndex++) {
      var _group$data;
      const currentGroupItem = group.items[itemIndex];
      const resultItem = {
        name: group.name,
        value: currentGroupItem.id,
        title: currentGroupItem.text,
        data: null === (_group$data = group.data) || void 0 === _group$data ? void 0 : _group$data[itemIndex],
        children: [],
        parent: parent || null
      };
      const nextGroupIndex = groupIndex + 1;
      if (groups[nextGroupIndex]) {
        make(groups[nextGroupIndex], nextGroupIndex, resultItem.children, resultItem);
      }
      if (!resultItem.children.length) {
        resultItem.leafIndex = leafIndex;
        leafIndex++;
      }
      result2.push(resultItem);
    }
    return result2;
  };
  return make(groups[0], 0);
};
var getPathToLeaf = (leafIndex, groups) => {
  const tree = createResourcesTree(groups);
  const findLeafByIndex = (data2, index2) => {
    for (let i = 0; i < data2.length; i++) {
      if (data2[i].leafIndex === index2) {
        return data2[i];
      }
      const leaf2 = findLeafByIndex(data2[i].children, index2);
      if (leaf2) {
        return leaf2;
      }
    }
  };
  const makeBranch = (leaf2, result2) => {
    result2 = result2 || [];
    result2.push(leaf2.value);
    if (leaf2.parent) {
      makeBranch(leaf2.parent, result2);
    }
    return result2;
  };
  const leaf = findLeafByIndex(tree, leafIndex);
  return makeBranch(leaf).reverse();
};
var getCellGroups = (groupIndex, groups) => {
  const result2 = [];
  if (getGroupCount(groups)) {
    if (groupIndex < 0) {
      return;
    }
    const path = getPathToLeaf(groupIndex, groups);
    for (let i = 0; i < groups.length; i++) {
      result2.push({
        name: groups[i].name,
        id: path[i]
      });
    }
  }
  return result2;
};
var getGroupsObjectFromGroupsArray = (groupsArray) => groupsArray.reduce((currentGroups, _ref) => {
  let {
    name: name2,
    id
  } = _ref;
  return _extends({}, currentGroups, {
    [name2]: id
  });
}, {});
var getAllGroups = (groups) => {
  const groupCount = getGroupCount(groups);
  return [...new Array(groupCount)].map((_, groupIndex) => {
    const groupsArray = getCellGroups(groupIndex, groups);
    return getGroupsObjectFromGroupsArray(groupsArray);
  });
};
var getResourceByField = (fieldName, loadedResources) => {
  for (let i = 0; i < loadedResources.length; i++) {
    const resource = loadedResources[i];
    if (resource.name === fieldName) {
      return resource.data;
    }
  }
  return [];
};
var createResourceEditorModel = (resources, loadedResources) => resources.map((resource) => {
  const dataField = getFieldExpr(resource);
  const dataSource = getResourceByField(dataField, loadedResources);
  return {
    editorOptions: {
      dataSource: dataSource.length ? dataSource : getWrappedDataSource(resource.dataSource),
      displayExpr: getDisplayExpr(resource),
      valueExpr: getValueExpr(resource),
      stylingMode: isFluent(current()) ? "filled" : "outlined"
    },
    dataField,
    editorType: resource.allowMultiple ? "dxTagBox" : "dxSelectBox",
    label: {
      text: resource.label || dataField
    }
  };
});
var isResourceMultiple = (resources, resourceField) => {
  const resource = resources.find((resource2) => {
    const field = getFieldExpr(resource2);
    return field === resourceField;
  });
  return !!(null !== resource && void 0 !== resource && resource.allowMultiple);
};
var filterResources = (resources, fields) => resources.filter((resource) => {
  const field = getFieldExpr(resource);
  return fields.indexOf(field) > -1;
});
var getPaintedResources = (resources, groups) => {
  const newGroups = groups || [];
  const result2 = resources.find((resource) => resource.useColorAsDefault);
  if (result2) {
    return result2;
  }
  const newResources = newGroups.length ? filterResources(resources, newGroups) : resources;
  return newResources[newResources.length - 1];
};
var getOrLoadResourceItem = (resources, resourceLoaderMap, field, value2) => {
  const result2 = new Deferred();
  resources.filter((resource) => getFieldExpr(resource) === field && isDefined(resource.dataSource)).forEach((resource) => {
    const wrappedDataSource = getWrappedDataSource(resource.dataSource);
    const valueExpr = getValueExpr(resource);
    if (!resourceLoaderMap.has(field)) {
      resourceLoaderMap.set(field, wrappedDataSource.load());
    }
    resourceLoaderMap.get(field).done((data2) => {
      const getter = compileGetter(valueExpr);
      const filteredData = data2.filter((resource2) => equalByValue(getter(resource2), value2));
      result2.resolve(filteredData[0]);
    }).fail(() => {
      resourceLoaderMap.delete(field);
      result2.reject();
    });
  });
  return result2.promise();
};
var getDataAccessors = (dataAccessors, fieldName, type2) => {
  const actions = dataAccessors[type2];
  return actions[fieldName];
};
var groupAppointmentsByResources = function(config3, appointments) {
  let groups = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
  let result2 = {
    0: appointments
  };
  if (groups.length && config3.loadedResources.length) {
    result2 = groupAppointmentsByResourcesCore(config3, appointments, config3.loadedResources);
  }
  let totalResourceCount = 0;
  config3.loadedResources.forEach((resource, index2) => {
    if (!index2) {
      totalResourceCount = resource.items.length;
    } else {
      totalResourceCount *= resource.items.length;
    }
  });
  for (let index2 = 0; index2 < totalResourceCount; index2++) {
    const key = index2.toString();
    if (result2[key]) {
      continue;
    }
    result2[key] = [];
  }
  return result2;
};
var groupAppointmentsByResourcesCore = (config3, appointments, resources) => {
  const tree = createResourcesTree(resources);
  const result2 = {};
  appointments.forEach((appointment) => {
    const treeLeaves = getResourceTreeLeaves((field, action) => getDataAccessors(config3.dataAccessors, field, action), tree, appointment);
    for (let i = 0; i < treeLeaves.length; i++) {
      if (!result2[treeLeaves[i]]) {
        result2[treeLeaves[i]] = [];
      }
      result2[treeLeaves[i]].push(deepExtendArraySafe({}, appointment, true));
    }
  });
  return result2;
};
var getResourceTreeLeaves = (getDataAccessors2, tree, rawAppointment, result2) => {
  result2 = result2 || [];
  for (let i = 0; i < tree.length; i++) {
    if (!hasGroupItem(getDataAccessors2, rawAppointment, tree[i].name, tree[i].value)) {
      continue;
    }
    if (isDefined(tree[i].leafIndex)) {
      result2.push(tree[i].leafIndex);
    }
    if (tree[i].children) {
      getResourceTreeLeaves(getDataAccessors2, tree[i].children, rawAppointment, result2);
    }
  }
  return result2;
};
var hasGroupItem = (getDataAccessors2, rawAppointment, groupName, itemValue) => {
  const resourceValue = getDataAccessors2(groupName, "getter")(rawAppointment);
  return hasResourceValue(wrapToArray(resourceValue), itemValue);
};
var createReducedResourcesTree = (loadedResources, getDataAccessors2, appointments) => {
  const tree = createResourcesTree(loadedResources);
  return reduceResourcesTree(getDataAccessors2, tree, appointments);
};
var reduceResourcesTree = (getDataAccessors2, tree, existingAppointments, _result) => {
  _result = _result ? _result.children : [];
  tree.forEach((node, index2) => {
    let ok = false;
    const resourceName = node.name;
    const resourceValue = node.value;
    const resourceTitle = node.title;
    const resourceData = node.data;
    const resourceGetter = getDataAccessors2(resourceName, "getter");
    existingAppointments.forEach((appointment) => {
      if (!ok) {
        const resourceFromAppointment = resourceGetter(appointment);
        if (Array.isArray(resourceFromAppointment)) {
          if (resourceFromAppointment.includes(resourceValue)) {
            _result.push({
              name: resourceName,
              value: resourceValue,
              title: resourceTitle,
              data: resourceData,
              children: []
            });
            ok = true;
          }
        } else if (resourceFromAppointment === resourceValue) {
          _result.push({
            name: resourceName,
            value: resourceValue,
            title: resourceTitle,
            data: resourceData,
            children: []
          });
          ok = true;
        }
      }
    });
    if (ok && node.children && node.children.length) {
      reduceResourcesTree(getDataAccessors2, node.children, existingAppointments, _result[index2]);
    }
  });
  return _result;
};
var getResourcesDataByGroups = (loadedResources, resources, groups) => {
  if (!groups || !groups.length) {
    return loadedResources;
  }
  const fieldNames = {};
  const currentResourcesData = [];
  groups.forEach((group) => {
    each(group, (name2, value2) => {
      fieldNames[name2] = value2;
    });
  });
  const resourceData = loadedResources.filter((_ref2) => {
    let {
      name: name2
    } = _ref2;
    return isDefined(fieldNames[name2]);
  });
  resourceData.forEach((data2) => currentResourcesData.push(extend({}, data2)));
  currentResourcesData.forEach((currentResource) => {
    const {
      items,
      data: data2,
      name: resourceName
    } = currentResource;
    const resource = filterResources(resources, [resourceName])[0] || {};
    const valueExpr = getValueExpr(resource);
    const filteredItems = [];
    const filteredData = [];
    groups.filter((group) => isDefined(group[resourceName])).forEach((group) => {
      each(group, (name2, value2) => {
        if (!filteredItems.filter((item) => item.id === value2 && item[valueExpr] === name2).length) {
          const currentItems = items.filter((item) => item.id === value2);
          const currentData = data2.filter((item) => item[valueExpr] === value2);
          filteredItems.push(...currentItems);
          filteredData.push(...currentData);
        }
      });
    });
    currentResource.items = filteredItems;
    currentResource.data = filteredData;
  });
  return currentResourcesData;
};
var setResourceToAppointment = (resources, dataAccessors, appointment, groups) => {
  const resourcesSetter = dataAccessors.setter;
  for (const name2 in groups) {
    const resourceData = groups[name2];
    const value2 = isResourceMultiple(resources, name2) ? wrapToArray(resourceData) : resourceData;
    resourcesSetter[name2](appointment, value2);
  }
};
var getResourceColor = (resources, resourceLoaderMap, field, value2) => {
  const result2 = new Deferred();
  const resource = filterResources(resources, [field])[0] || {};
  const colorExpr = resource.colorExpr || "color";
  const colorGetter = compileGetter(colorExpr);
  getOrLoadResourceItem(resources, resourceLoaderMap, field, value2).done((resource2) => result2.resolve(colorGetter(resource2))).fail(() => result2.reject());
  return result2.promise();
};
var getAppointmentColor = (resourceConfig, appointmentConfig) => {
  const {
    resources,
    dataAccessors,
    loadedResources,
    resourceLoaderMap
  } = resourceConfig;
  const {
    groupIndex,
    groups,
    itemData
  } = appointmentConfig;
  const paintedResources = getPaintedResources(resources || [], groups);
  if (paintedResources) {
    const field = getFieldExpr(paintedResources);
    const cellGroups = getCellGroups(groupIndex, loadedResources);
    const resourcesDataAccessors = getDataAccessors(dataAccessors, field, "getter");
    const resourceValues = wrapToArray(resourcesDataAccessors(itemData));
    let groupId = resourceValues[0];
    for (let i = 0; i < cellGroups.length; i++) {
      if (cellGroups[i].name === field) {
        groupId = cellGroups[i].id;
        break;
      }
    }
    return getResourceColor(resources, resourceLoaderMap, field, groupId);
  }
  return new Deferred().resolve().promise();
};
var createExpressions = function() {
  let resources = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  const result2 = {
    getter: {},
    setter: {}
  };
  resources.forEach((resource) => {
    const field = getFieldExpr(resource);
    result2.getter[field] = compileGetter(field);
    result2.setter[field] = compileSetter(field);
  });
  return result2;
};
var getTransformedResourceData = (resource, data2) => {
  const valueGetter = compileGetter(getValueExpr(resource));
  const displayGetter = compileGetter(getDisplayExpr(resource));
  return data2.map((item) => {
    const result2 = {
      id: valueGetter(item),
      text: displayGetter(item)
    };
    if (item.color) {
      result2.color = item.color;
    }
    return result2;
  });
};
var loadResources = (groups, resources, resourceLoaderMap) => {
  const result2 = new Deferred();
  const deferreds = [];
  const newGroups = groups || [];
  const newResources = resources || [];
  let loadedResources = [];
  filterResources(newResources, newGroups).forEach((resource) => {
    const deferred = new Deferred();
    const name2 = getFieldExpr(resource);
    deferreds.push(deferred);
    const dataSourcePromise = getWrappedDataSource(resource.dataSource).load();
    resourceLoaderMap.set(name2, dataSourcePromise);
    dataSourcePromise.done((data2) => {
      const items = getTransformedResourceData(resource, data2);
      deferred.resolve({
        name: name2,
        items,
        data: data2
      });
    }).fail(() => deferred.reject());
  });
  if (!deferreds.length) {
    return result2.resolve(loadedResources);
  }
  when.apply(null, deferreds).done(function() {
    for (var _len = arguments.length, resources2 = new Array(_len), _key = 0; _key < _len; _key++) {
      resources2[_key] = arguments[_key];
    }
    const hasEmpty = resources2.some((r) => 0 === r.items.length);
    loadedResources = hasEmpty ? [] : resources2;
    result2.resolve(loadedResources);
  }).fail(() => result2.reject());
  return result2.promise();
};
var getNormalizedResources = (rawAppointment, dataAccessors, resources) => {
  const result2 = {};
  each(dataAccessors.resources.getter, (fieldName) => {
    const value2 = dataAccessors.resources.getter[fieldName](rawAppointment);
    if (isDefined(value2)) {
      const isMultiple = isResourceMultiple(resources, fieldName);
      const resourceValue = isMultiple ? wrapToArray(value2) : value2;
      result2[fieldName] = resourceValue;
    }
  });
  return result2;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointment_popup/m_popup.js
var toMs7 = date_default.dateToMilliseconds;
var APPOINTMENT_POPUP_CLASS = "dx-scheduler-appointment-popup";
var DAY_IN_MS = toMs7("day");
var POPUP_CONFIG = {
  height: "auto",
  maxHeight: "100%",
  showCloseButton: false,
  showTitle: false,
  preventScrollEvents: false,
  enableBodyScroll: false,
  defaultOptionsRules: [{
    device: () => devices_default.current().android,
    options: {
      showTitle: false
    }
  }],
  _ignorePreventScrollEventsDeprecation: true
};
var ACTION_TO_APPOINTMENT = {
  CREATE: 0,
  UPDATE: 1,
  EXCLUDE_FROM_SERIES: 2
};
var AppointmentPopup = class {
  constructor(scheduler, form) {
    this.scheduler = scheduler;
    this.form = form;
    this.popup = null;
    this.state = {
      action: null,
      lastEditData: null,
      saveChangesLocker: false,
      appointment: {
        data: null
      }
    };
  }
  get visible() {
    return this.popup ? this.popup.option("visible") : false;
  }
  show(appointment, config3) {
    this.state.appointment.data = appointment;
    this.state.action = config3.action;
    this.state.excludeInfo = config3.excludeInfo;
    if (!this.popup) {
      const popupConfig = this._createPopupConfig();
      this.popup = this._createPopup(popupConfig);
    }
    this.popup.option("toolbarItems", getPopupToolbarItems(config3.isToolbarVisible, (e) => this._doneButtonClickHandler(e)));
    this.popup.show();
  }
  hide() {
    this.popup.hide();
  }
  dispose() {
    var _this$popup;
    null === (_this$popup = this.popup) || void 0 === _this$popup || _this$popup.$element().remove();
  }
  _createPopup(options2) {
    const popupElement = renderer_default("<div>").addClass(APPOINTMENT_POPUP_CLASS).appendTo(this.scheduler.getElement());
    return this.scheduler.createComponent(popupElement, ui_popup_default, options2);
  }
  _createPopupConfig() {
    return _extends({}, POPUP_CONFIG, {
      onHiding: () => this.scheduler.focus(),
      contentTemplate: () => this._createPopupContent(),
      onShowing: (e) => this._onShowing(e),
      wrapperAttr: {
        class: APPOINTMENT_POPUP_CLASS
      }
    });
  }
  _onShowing(e) {
    this._updateForm();
    const arg = {
      form: this.form.dxForm,
      popup: this.popup,
      appointmentData: this.state.appointment.data,
      cancel: false
    };
    this.scheduler.getAppointmentFormOpening()(arg);
    this.scheduler.processActionResult(arg, (canceled) => {
      if (canceled) {
        e.cancel = true;
      } else {
        this.updatePopupFullScreenMode();
      }
    });
  }
  _createPopupContent() {
    this._createForm();
    return this.form.dxForm.$element();
  }
  _createFormData(rawAppointment) {
    const appointment = this._createAppointmentAdapter(rawAppointment);
    const dataAccessors = this.scheduler.getDataAccessors();
    const resources = this.scheduler.getResources();
    const normalizedResources = getNormalizedResources(rawAppointment, dataAccessors, resources);
    return _extends({}, rawAppointment, normalizedResources, {
      repeat: !!appointment.recurrenceRule
    });
  }
  _createForm() {
    const rawAppointment = this.state.appointment.data;
    const formData = this._createFormData(rawAppointment);
    this.form.create(this.triggerResize.bind(this), this.changeSize.bind(this), formData);
  }
  _isReadOnly(rawAppointment) {
    const appointment = this._createAppointmentAdapter(rawAppointment);
    if (rawAppointment && appointment.disabled) {
      return true;
    }
    if (this.state.action === ACTION_TO_APPOINTMENT.CREATE) {
      return false;
    }
    return !this.scheduler.getEditingConfig().allowUpdating;
  }
  _createAppointmentAdapter(rawAppointment) {
    return createAppointmentAdapter(rawAppointment, this.scheduler.getDataAccessors(), this.scheduler.getTimeZoneCalculator());
  }
  _updateForm() {
    const {
      data: data2
    } = this.state.appointment;
    const appointment = this._createAppointmentAdapter(this._createFormData(data2));
    if (appointment.startDate) {
      appointment.startDate = appointment.calculateStartDate("toAppointment");
    }
    if (appointment.endDate) {
      appointment.endDate = appointment.calculateEndDate("toAppointment");
    }
    const formData = appointment.clone().source();
    this.form.readOnly = this._isReadOnly(formData);
    this.form.updateFormData(formData);
  }
  triggerResize() {
    if (this.popup) {
      triggerResizeEvent(this.popup.$element());
    }
  }
  changeSize(isRecurrence) {
    if (this.popup) {
      const isFullScreen = isPopupFullScreenNeeded();
      const maxWidth = isFullScreen ? "100%" : getMaxWidth(isRecurrence);
      this.popup.option("fullScreen", isFullScreen);
      this.popup.option("maxWidth", maxWidth);
    }
  }
  updatePopupFullScreenMode() {
    if (this.form.dxForm && this.visible) {
      const {
        formData
      } = this.form;
      const dataAccessors = this.scheduler.getDataAccessors();
      const isRecurrence = ExpressionUtils.getField(dataAccessors, "recurrenceRule", formData);
      this.changeSize(isRecurrence);
    }
  }
  saveChangesAsync(isShowLoadPanel) {
    const deferred = new Deferred();
    const validation = this.form.dxForm.validate();
    isShowLoadPanel && this._showLoadPanel();
    when(validation && validation.complete || validation).done((validation2) => {
      if (validation2 && !validation2.isValid) {
        hide();
        deferred.resolve(false);
        return;
      }
      const {
        repeat: repeat2
      } = this.form.formData;
      const adapter = this._createAppointmentAdapter(this.form.formData);
      const clonedAdapter = adapter.clone({
        pathTimeZone: "fromAppointment"
      });
      const shouldClearRecurrenceRule = !repeat2 && !!clonedAdapter.recurrenceRule;
      this._addMissingDSTTime(adapter, clonedAdapter);
      if (shouldClearRecurrenceRule) {
        clonedAdapter.recurrenceRule = "";
      }
      const appointment = clonedAdapter.source();
      delete appointment.repeat;
      switch (this.state.action) {
        case ACTION_TO_APPOINTMENT.CREATE:
          this.scheduler.addAppointment(appointment).done(deferred.resolve);
          break;
        case ACTION_TO_APPOINTMENT.UPDATE:
          this.scheduler.updateAppointment(this.state.appointment.data, appointment).done(deferred.resolve);
          break;
        case ACTION_TO_APPOINTMENT.EXCLUDE_FROM_SERIES:
          this.scheduler.updateAppointment(this.state.excludeInfo.sourceAppointment, this.state.excludeInfo.updatedAppointment);
          this.scheduler.addAppointment(appointment).done(deferred.resolve);
      }
      deferred.done(() => {
        hide();
        this.state.lastEditData = appointment;
      });
    });
    return deferred.promise();
  }
  _doneButtonClickHandler(e) {
    e.cancel = true;
    this.saveEditDataAsync();
  }
  saveEditDataAsync() {
    const deferred = new Deferred();
    if (this._tryLockSaveChanges()) {
      when(this.saveChangesAsync(true)).done(() => {
        if (this.state.lastEditData) {
          const adapter = this._createAppointmentAdapter(this.state.lastEditData);
          const {
            startDate,
            endDate,
            allDay
          } = adapter;
          const startTime = startDate.getTime();
          const endTime = endDate.getTime();
          const inAllDayRow = allDay || endTime - startTime >= DAY_IN_MS;
          const dataAccessors = this.scheduler.getDataAccessors();
          const resourceList = this.scheduler.getResources();
          const normalizedResources = getNormalizedResources(this.state.lastEditData, dataAccessors, resourceList);
          this.scheduler.updateScrollPosition(startDate, normalizedResources, inAllDayRow);
          this.state.lastEditData = null;
        }
        this._unlockSaveChanges();
        deferred.resolve();
      });
    }
    return deferred.promise();
  }
  _showLoadPanel() {
    const container = this.popup.$overlayContent();
    show({
      container,
      position: {
        of: container
      }
    });
  }
  _tryLockSaveChanges() {
    if (false === this.state.saveChangesLocker) {
      this.state.saveChangesLocker = true;
      return true;
    }
    return false;
  }
  _unlockSaveChanges() {
    this.state.saveChangesLocker = false;
  }
  _addMissingDSTTime(formAppointmentAdapter, clonedAppointmentAdapter) {
    const timeZoneCalculator = this.scheduler.getTimeZoneCalculator();
    clonedAppointmentAdapter.startDate = this._addMissingDSTShiftToDate(timeZoneCalculator, formAppointmentAdapter.startDate, clonedAppointmentAdapter.startDate);
    if (clonedAppointmentAdapter.endDate) {
      clonedAppointmentAdapter.endDate = this._addMissingDSTShiftToDate(timeZoneCalculator, formAppointmentAdapter.endDate, clonedAppointmentAdapter.endDate);
    }
  }
  _addMissingDSTShiftToDate(timeZoneCalculator, originFormDate, clonedDate) {
    var _timeZoneCalculator$g, _timeZoneCalculator$g2;
    const originTimezoneShift = null === (_timeZoneCalculator$g = timeZoneCalculator.getOffsets(originFormDate)) || void 0 === _timeZoneCalculator$g ? void 0 : _timeZoneCalculator$g.common;
    const clonedTimezoneShift = null === (_timeZoneCalculator$g2 = timeZoneCalculator.getOffsets(clonedDate)) || void 0 === _timeZoneCalculator$g2 ? void 0 : _timeZoneCalculator$g2.common;
    const shiftDifference = originTimezoneShift - clonedTimezoneShift;
    return shiftDifference ? new Date(clonedDate.getTime() + shiftDifference * toMs7("hour")) : clonedDate;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/filterting/remote.js
var FilterPosition = {
  dateFilter: 0,
  userFilter: 1
};
var RemoteFilterCombiner = class {
  constructor(options2) {
    this.options = options2;
  }
  get dataAccessors() {
    return this.options.dataAccessors;
  }
  get dataSourceFilter() {
    return this.options.dataSourceFilter;
  }
  get dateSerializationFormat() {
    return this.options.dateSerializationFormat;
  }
  get forceIsoDateParsing() {
    return isDefined(this.options.forceIsoDateParsing) ? this.options.forceIsoDateParsing : true;
  }
  makeDateFilter(min, max) {
    const {
      startDateExpr,
      endDateExpr,
      recurrenceRuleExpr
    } = this.dataAccessors.expr;
    const dateFilter = [
      [
        [endDateExpr, ">=", min],
        [startDateExpr, "<", max]
      ],
      "or",
      [recurrenceRuleExpr, "startswith", "freq"],
      "or",
      [
        [endDateExpr, min],
        [startDateExpr, min]
      ]
    ];
    if (!recurrenceRuleExpr) {
      dateFilter.splice(1, 2);
    }
    return dateFilter;
  }
  combineFilters(dateFilter, userFilter) {
    const combinedFilter = [];
    if (dateFilter) {
      combinedFilter.push(dateFilter);
    }
    if (userFilter) {
      combinedFilter.push(userFilter);
    }
    return this.serializeRemoteFilter(combinedFilter);
  }
  serializeRemoteFilter(combinedFilter) {
    if (!Array.isArray(combinedFilter)) {
      return combinedFilter;
    }
    const {
      startDateExpr,
      endDateExpr
    } = this.dataAccessors.expr;
    const filter = extend([], combinedFilter);
    if (isString(filter[0])) {
      if (this.forceIsoDateParsing && filter.length > 1) {
        if (filter[0] === startDateExpr || filter[0] === endDateExpr) {
          const lastFilterValue = filter[filter.length - 1];
          filter[filter.length - 1] = date_serialization_default.serializeDate(new Date(lastFilterValue), this.dateSerializationFormat);
        }
      }
    }
    for (let i = 0; i < filter.length; i += 1) {
      filter[i] = this.serializeRemoteFilter(filter[i]);
    }
    return filter;
  }
  getUserFilter(dateFilter) {
    if (!this.dataSourceFilter || equalByValue(this.dataSourceFilter, dateFilter)) {
      return;
    }
    const containsDateFilter = this.dataSourceFilter.length > 0 && equalByValue(this.dataSourceFilter[FilterPosition.dateFilter], dateFilter);
    const userFilter = containsDateFilter ? this.dataSourceFilter[FilterPosition.userFilter] : this.dataSourceFilter;
    return userFilter;
  }
  combine(min, max) {
    const [trimMin, trimMax] = getDatesWithoutTime(min, max);
    const dateFilter = this.makeDateFilter(trimMin, trimMax);
    const userFilter = this.getUserFilter(dateFilter);
    const combinedFilter = this.combineFilters(dateFilter, userFilter);
    return combinedFilter;
  }
};
var combineRemoteFilter = (options2) => new RemoteFilterCombiner(options2).combine(options2.min, options2.max);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/data_provider/m_appointment_data_source.js
var STORE_EVENTS = {
  updating: "updating",
  push: "push"
};
var AppointmentDataSource = class {
  constructor(dataSource) {
    this.setDataSource(dataSource);
    this._updatedAppointmentKeys = [];
  }
  get keyName() {
    const store = this._dataSource.store();
    return store.key();
  }
  get isDataSourceInit() {
    return !!this._dataSource;
  }
  _getStoreKey(target) {
    const store = this._dataSource.store();
    return store.keyOf(target);
  }
  setDataSource(dataSource) {
    this._dataSource = dataSource;
    this.cleanState();
    this._initStoreChangeHandlers();
  }
  _initStoreChangeHandlers() {
    const dataSource = this._dataSource;
    const store = null === dataSource || void 0 === dataSource ? void 0 : dataSource.store();
    if (store) {
      store.on(STORE_EVENTS.updating, (key) => {
        const keyName = store.key();
        if (keyName) {
          this._updatedAppointmentKeys.push({
            key: keyName,
            value: key
          });
        } else {
          this._updatedAppointment = key;
        }
      });
      store.on(STORE_EVENTS.push, (pushItems) => {
        const items = dataSource.items();
        const keyName = store.key();
        pushItems.forEach((pushItem) => {
          const itemExists = 0 !== items.filter((item) => item[keyName] === pushItem.key).length;
          if (itemExists) {
            this._updatedAppointmentKeys.push({
              key: keyName,
              value: pushItem.key
            });
          } else {
            const {
              data: data2
            } = pushItem;
            data2 && items.push(data2);
          }
        });
        dataSource.load();
      });
    }
  }
  getUpdatedAppointment() {
    return this._updatedAppointment;
  }
  getUpdatedAppointmentKeys() {
    return this._updatedAppointmentKeys;
  }
  cleanState() {
    this._updatedAppointment = null;
    this._updatedAppointmentKeys = [];
  }
  add(rawAppointment) {
    return this._dataSource.store().insert(rawAppointment).done(() => this._dataSource.load());
  }
  update(target, data2) {
    const key = this._getStoreKey(target);
    const d = new Deferred();
    this._dataSource.store().update(key, data2).done((result2) => this._dataSource.load().done(() => d.resolve(result2)).fail(d.reject)).fail(d.reject);
    return d.promise();
  }
  remove(rawAppointment) {
    const key = this._getStoreKey(rawAppointment);
    return this._dataSource.store().remove(key).done(() => this._dataSource.load());
  }
  destroy() {
    var _this$_dataSource;
    const store = null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.store();
    if (store) {
      store.off(STORE_EVENTS.updating);
      store.off(STORE_EVENTS.push);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/data_provider/m_appointment_filter.js
var toMs8 = date_default.dateToMilliseconds;
var FilterStrategies = {
  virtual: "virtual",
  standard: "standard"
};
var AppointmentFilterBaseStrategy = class {
  constructor(options2) {
    this.options = options2;
    this.dataAccessors = this.options.dataAccessors;
    this._init();
  }
  get strategyName() {
    return FilterStrategies.standard;
  }
  get timeZoneCalculator() {
    return this.options.timeZoneCalculator;
  }
  get viewStartDayHour() {
    return this.options.startDayHour;
  }
  get viewEndDayHour() {
    return this.options.endDayHour;
  }
  get timezone() {
    return this.options.timezone;
  }
  get firstDayOfWeek() {
    return this.options.firstDayOfWeek;
  }
  get showAllDayPanel() {
    return this.options.showAllDayPanel;
  }
  get loadedResources() {
    return this._resolveOption("loadedResources");
  }
  get supportAllDayRow() {
    return this._resolveOption("supportAllDayRow");
  }
  get viewType() {
    return this._resolveOption("viewType");
  }
  get viewDirection() {
    return this._resolveOption("viewDirection");
  }
  get dateRange() {
    return this._resolveOption("dateRange");
  }
  get groupCount() {
    return this._resolveOption("groupCount");
  }
  get viewDataProvider() {
    return this._resolveOption("viewDataProvider");
  }
  get allDayPanelMode() {
    return this._resolveOption("allDayPanelMode");
  }
  _resolveOption(name2) {
    const result2 = this.options[name2];
    return "function" === typeof result2 ? result2() : result2;
  }
  _init() {
    this.setDataAccessors(this.dataAccessors);
  }
  filter(preparedItems) {
    const [min, max] = this.dateRange;
    const {
      viewOffset
    } = this.options;
    const allDay = !this.showAllDayPanel && this.supportAllDayRow ? false : void 0;
    return this.filterLoadedAppointments({
      startDayHour: this.viewStartDayHour,
      endDayHour: this.viewEndDayHour,
      viewOffset,
      viewStartDayHour: this.viewStartDayHour,
      viewEndDayHour: this.viewEndDayHour,
      min,
      max,
      resources: this.loadedResources,
      allDay,
      supportMultiDayAppointments: isTimelineView(this.viewType),
      firstDayOfWeek: this.firstDayOfWeek
    }, preparedItems);
  }
  hasAllDayAppointments(filteredItems, preparedItems) {
    const adapters = filteredItems.map((item) => createAppointmentAdapter(item, this.dataAccessors, this.timeZoneCalculator));
    let result2 = false;
    each(adapters, (_, item) => {
      if (getAppointmentTakesAllDay(item, this.allDayPanelMode)) {
        result2 = true;
        return false;
      }
    });
    return result2;
  }
  setDataAccessors(dataAccessors) {
    this.dataAccessors = dataAccessors;
  }
  _createAllDayAppointmentFilter() {
    return [
      [(appointment) => getAppointmentTakesAllDay(appointment, this.allDayPanelMode)]
    ];
  }
  _createCombinedFilter(filterOptions) {
    const min = new Date(filterOptions.min);
    const max = new Date(filterOptions.max);
    const {
      startDayHour,
      endDayHour,
      viewOffset,
      viewStartDayHour,
      viewEndDayHour,
      resources,
      firstDayOfWeek,
      checkIntersectViewport,
      supportMultiDayAppointments
    } = filterOptions;
    const [trimMin, trimMax] = getDatesWithoutTime(min, max);
    const useRecurrence = isDefined(this.dataAccessors.getter.recurrenceRule);
    return [
      [(appointment) => {
        const appointmentVisible = appointment.visible ?? true;
        if (!appointmentVisible) {
          return false;
        }
        const {
          allDay: isAllDay,
          hasRecurrenceRule
        } = appointment;
        const startDate = dateUtilsTs.addOffsets(appointment.startDate, [-viewOffset]);
        const endDate = dateUtilsTs.addOffsets(appointment.endDate, [-viewOffset]);
        const appointmentTakesAllDay = getAppointmentTakesAllDay(appointment, this.allDayPanelMode);
        if (!hasRecurrenceRule) {
          if (!(endDate >= trimMin && startDate < trimMax || date_default.sameDate(endDate, trimMin) && date_default.sameDate(startDate, trimMin))) {
            return false;
          }
        }
        const appointmentTakesSeveralDays = getAppointmentTakesSeveralDays(appointment);
        const isLongAppointment = appointmentTakesSeveralDays || appointmentTakesAllDay;
        if (null !== resources && void 0 !== resources && resources.length && !this._filterAppointmentByResources(appointment.rawAppointment, resources)) {
          return false;
        }
        if (appointmentTakesAllDay && false === filterOptions.allDay) {
          return false;
        }
        if (hasRecurrenceRule) {
          const recurrenceException = getRecurrenceException(appointment, this.timeZoneCalculator, this.timezone);
          if (!this._filterAppointmentByRRule(_extends({}, appointment, {
            recurrenceException,
            allDay: appointmentTakesAllDay
          }), min, max, startDayHour, endDayHour, firstDayOfWeek)) {
            return false;
          }
        }
        if (!isAllDay && supportMultiDayAppointments && isLongAppointment) {
          if (endDate < min && (!useRecurrence || useRecurrence && !hasRecurrenceRule)) {
            return false;
          }
        }
        if (!isAllDay && isDefined(startDayHour) && (!useRecurrence || !filterOptions.isVirtualScrolling)) {
          if (!compareDateWithStartDayHour(startDate, endDate, startDayHour, appointmentTakesAllDay, appointmentTakesSeveralDays)) {
            return false;
          }
        }
        if (!isAllDay && isDefined(endDayHour)) {
          if (!compareDateWithEndDayHour({
            startDate,
            endDate,
            startDayHour,
            endDayHour,
            viewOffset,
            viewStartDayHour,
            viewEndDayHour,
            allDay: appointmentTakesAllDay,
            severalDays: appointmentTakesSeveralDays,
            min,
            max,
            checkIntersectViewport
          })) {
            return false;
          }
        }
        if (!isAllDay && (!isLongAppointment || supportMultiDayAppointments)) {
          if (endDate < min && useRecurrence && !hasRecurrenceRule) {
            return false;
          }
        }
        return true;
      }]
    ];
  }
  _createAppointmentFilter(filterOptions) {
    return this._createCombinedFilter(filterOptions);
  }
  _filterAppointmentByResources(appointment, resources) {
    const checkAppointmentResourceValues = (resourceName, resourceIndex) => {
      const resourceGetter = this.dataAccessors.resources.getter[resourceName];
      let resource;
      if (isFunction(resourceGetter)) {
        resource = resourceGetter(appointment);
      }
      const appointmentResourceValues = wrapToArray(resource);
      const resourceData = map(resources[resourceIndex].items, (_ref) => {
        let {
          id
        } = _ref;
        return id;
      });
      for (let i = 0; i < appointmentResourceValues.length; i++) {
        if (hasResourceValue(resourceData, appointmentResourceValues[i])) {
          return true;
        }
      }
      return false;
    };
    let result2 = false;
    for (let i = 0; i < resources.length; i++) {
      const resourceName = resources[i].name;
      result2 = checkAppointmentResourceValues(resourceName, i);
      if (!result2) {
        return false;
      }
    }
    return result2;
  }
  _filterAppointmentByRRule(appointment, min, max, startDayHour, endDayHour, firstDayOfWeek) {
    const {
      recurrenceRule
    } = appointment;
    const {
      recurrenceException
    } = appointment;
    const {
      allDay
    } = appointment;
    let result2 = true;
    const appointmentStartDate = appointment.startDate;
    const appointmentEndDate = appointment.endDate;
    const recurrenceProcessor = getRecurrenceProcessor();
    if (allDay || _appointmentPartInInterval(appointmentStartDate, appointmentEndDate, startDayHour, endDayHour)) {
      const [trimMin, trimMax] = getDatesWithoutTime(min, max);
      min = trimMin;
      max = new Date(trimMax.getTime() - toMs8("minute"));
    }
    if (recurrenceRule && !recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {
      result2 = appointmentEndDate > min && appointmentStartDate <= max;
    }
    if (result2 && recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {
      const {
        viewOffset
      } = this.options;
      result2 = recurrenceProcessor.hasRecurrence({
        rule: recurrenceRule,
        exception: recurrenceException,
        start: appointmentStartDate,
        end: appointmentEndDate,
        min: dateUtilsTs.addOffsets(min, [viewOffset]),
        max: dateUtilsTs.addOffsets(max, [viewOffset]),
        firstDayOfWeek,
        appointmentTimezoneOffset: this.timeZoneCalculator.getOriginStartDateOffsetInMs(appointmentStartDate, appointment.startDateTimeZone, false)
      });
    }
    return result2;
  }
  filterLoadedAppointments(filterOptions, preparedItems) {
    const filteredItems = this.filterPreparedItems(filterOptions, preparedItems);
    return filteredItems.map((_ref2) => {
      let {
        rawAppointment
      } = _ref2;
      return rawAppointment;
    });
  }
  filterPreparedItems(filterOptions, preparedItems) {
    const combinedFilter = this._createAppointmentFilter(filterOptions);
    return query_default(preparedItems).filter(combinedFilter).toArray();
  }
  filterAllDayAppointments(preparedItems) {
    const combinedFilter = this._createAllDayAppointmentFilter();
    return query_default(preparedItems).filter(combinedFilter).toArray().map((_ref3) => {
      let {
        rawAppointment
      } = _ref3;
      return rawAppointment;
    });
  }
};
var AppointmentFilterVirtualStrategy = class extends AppointmentFilterBaseStrategy {
  get strategyName() {
    return FilterStrategies.virtual;
  }
  get resources() {
    return this.options.resources;
  }
  filter(preparedItems) {
    const {
      viewOffset
    } = this.options;
    const hourMs = toMs8("hour");
    const isCalculateStartAndEndDayHour = isDateAndTimeView(this.viewType);
    const checkIntersectViewport = isCalculateStartAndEndDayHour && "horizontal" === this.viewDirection;
    const isAllDayWorkspace = !this.supportAllDayRow;
    const showAllDayAppointments = this.showAllDayPanel || isAllDayWorkspace;
    const endViewDate = this.viewDataProvider.getLastViewDateByEndDayHour(this.viewEndDayHour);
    const shiftedEndViewDate = dateUtilsTs.addOffsets(endViewDate, [viewOffset]);
    const filterOptions = [];
    const groupsInfo = this.viewDataProvider.getCompletedGroupsInfo();
    groupsInfo.forEach((item) => {
      const {
        groupIndex
      } = item;
      const groupStartDate = item.startDate;
      const groupEndDate = new Date(Math.min(item.endDate.getTime(), shiftedEndViewDate.getTime()));
      const startDayHour = isCalculateStartAndEndDayHour ? groupStartDate.getHours() : this.viewStartDayHour;
      const endDayHour = isCalculateStartAndEndDayHour ? startDayHour + groupStartDate.getMinutes() / 60 + (groupEndDate.getTime() - groupStartDate.getTime()) / hourMs : this.viewEndDayHour;
      const resources = this._getPrerenderFilterResources(groupIndex);
      const hasAllDayPanel = this.viewDataProvider.hasGroupAllDayPanel(groupIndex);
      const supportAllDayAppointment = isAllDayWorkspace || !!showAllDayAppointments && hasAllDayPanel;
      filterOptions.push({
        isVirtualScrolling: true,
        startDayHour,
        endDayHour,
        viewOffset,
        viewStartDayHour: this.viewStartDayHour,
        viewEndDayHour: this.viewEndDayHour,
        min: dateUtilsTs.addOffsets(groupStartDate, [-viewOffset]),
        max: dateUtilsTs.addOffsets(groupEndDate, [-viewOffset]),
        supportMultiDayAppointments: isTimelineView(this.viewType),
        allDay: supportAllDayAppointment,
        resources,
        firstDayOfWeek: this.firstDayOfWeek,
        checkIntersectViewport
      });
    });
    return this.filterLoadedAppointments({
      filterOptions,
      groupCount: this.groupCount
    }, preparedItems);
  }
  filterPreparedItems(_ref4, preparedItems) {
    let {
      filterOptions,
      groupCount
    } = _ref4;
    const combinedFilters = [];
    let itemsToFilter = preparedItems;
    const needPreFilter = groupCount > 0;
    if (needPreFilter) {
      itemsToFilter = itemsToFilter.filter((_ref5) => {
        let {
          rawAppointment
        } = _ref5;
        for (let i = 0; i < filterOptions.length; ++i) {
          const {
            resources
          } = filterOptions[i];
          if (this._filterAppointmentByResources(rawAppointment, resources)) {
            return true;
          }
        }
      });
    }
    filterOptions.forEach((option) => {
      combinedFilters.length && combinedFilters.push("or");
      const filter = this._createAppointmentFilter(option);
      combinedFilters.push(filter);
    });
    return query_default(itemsToFilter).filter(combinedFilters).toArray();
  }
  hasAllDayAppointments(filteredItems, preparedItems) {
    return this.filterAllDayAppointments(preparedItems).length > 0;
  }
  _getPrerenderFilterResources(groupIndex) {
    const cellGroup = this.viewDataProvider.getCellsGroup(groupIndex);
    return getResourcesDataByGroups(this.loadedResources, this.resources, [cellGroup]);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/data_provider/m_appointment_data_provider.js
var FilterStrategies2 = {
  virtual: "virtual",
  standard: "standard"
};
var AppointmentDataProvider = class {
  constructor(options2) {
    this.options = options2;
    this.dataSource = this.options.dataSource;
    this.dataAccessors = this.options.dataAccessors;
    this.timeZoneCalculator = this.options.timeZoneCalculator;
    this.appointmentDataSource = new AppointmentDataSource(this.dataSource);
    this.initFilterStrategy();
  }
  get keyName() {
    return this.appointmentDataSource.keyName;
  }
  get isDataSourceInit() {
    return !!this.dataSource;
  }
  get filterStrategyName() {
    return this.options.getIsVirtualScrolling() ? FilterStrategies2.virtual : FilterStrategies2.standard;
  }
  getFilterStrategy() {
    if (!this.filterStrategy || this.filterStrategy.strategyName !== this.filterStrategyName) {
      this.initFilterStrategy();
    }
    return this.filterStrategy;
  }
  initFilterStrategy() {
    const filterOptions = {
      resources: this.options.resources,
      dataAccessors: this.dataAccessors,
      startDayHour: this.options.startDayHour,
      endDayHour: this.options.endDayHour,
      viewOffset: this.options.viewOffset,
      showAllDayPanel: this.options.showAllDayPanel,
      timeZoneCalculator: this.options.timeZoneCalculator,
      loadedResources: this.options.getLoadedResources,
      supportAllDayRow: this.options.getSupportAllDayRow,
      viewType: this.options.getViewType,
      viewDirection: this.options.getViewDirection,
      dateRange: this.options.getDateRange,
      groupCount: this.options.getGroupCount,
      viewDataProvider: this.options.getViewDataProvider,
      allDayPanelMode: this.options.allDayPanelMode
    };
    this.filterStrategy = this.filterStrategyName === FilterStrategies2.virtual ? new AppointmentFilterVirtualStrategy(filterOptions) : new AppointmentFilterBaseStrategy(filterOptions);
  }
  setDataSource(dataSource) {
    this.dataSource = dataSource;
    this.initFilterStrategy();
    this.appointmentDataSource.setDataSource(this.dataSource);
  }
  updateDataAccessors(dataAccessors) {
    this.dataAccessors = dataAccessors;
    this.initFilterStrategy();
  }
  filter(preparedItems) {
    return this.getFilterStrategy().filter(preparedItems);
  }
  filterByDate(min, max, remoteFiltering, dateSerializationFormat) {
    if (!this.dataSource || !remoteFiltering) {
      return;
    }
    const dataSourceFilter = this.dataSource.filter();
    const filter = combineRemoteFilter({
      dataSourceFilter,
      dataAccessors: this.dataAccessors,
      min,
      max,
      dateSerializationFormat,
      forceIsoDateParsing: config_default().forceIsoDateParsing
    });
    this.dataSource.filter(filter);
  }
  hasAllDayAppointments(filteredItems, preparedItems) {
    return this.getFilterStrategy().hasAllDayAppointments(filteredItems, preparedItems);
  }
  filterLoadedAppointments(filterOption, preparedItems) {
    return this.getFilterStrategy().filterLoadedAppointments(filterOption, preparedItems);
  }
  calculateAppointmentEndDate(isAllDay, startDate) {
    return this.getFilterStrategy().calculateAppointmentEndDate(isAllDay, startDate);
  }
  cleanState() {
    this.appointmentDataSource.cleanState();
  }
  getUpdatedAppointment() {
    return this.appointmentDataSource._updatedAppointment;
  }
  getUpdatedAppointmentKeys() {
    return this.appointmentDataSource._updatedAppointmentKeys;
  }
  add(rawAppointment) {
    return this.appointmentDataSource.add(rawAppointment);
  }
  update(target, rawAppointment) {
    return this.appointmentDataSource.update(target, rawAppointment);
  }
  remove(rawAppointment) {
    return this.appointmentDataSource.remove(rawAppointment);
  }
  destroy() {
    this.appointmentDataSource.destroy();
  }
};

// ../../../../../../node_modules/devextreme/esm/renovation/ui/resizable/utils.js
var borderWidthStyles = {
  left: "borderLeftWidth",
  top: "borderTopWidth",
  right: "borderRightWidth",
  bottom: "borderBottomWidth"
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popover/m_popover_position_controller.js
var _excluded15 = ["shading", "target", "$arrow"];
var WEIGHT_OF_SIDES = {
  left: -1,
  top: -1,
  center: 0,
  right: 1,
  bottom: 1
};
var POPOVER_POSITION_ALIASES = {
  top: {
    my: "bottom center",
    at: "top center",
    collision: "fit flip"
  },
  bottom: {
    my: "top center",
    at: "bottom center",
    collision: "fit flip"
  },
  right: {
    my: "left center",
    at: "right center",
    collision: "flip fit"
  },
  left: {
    my: "right center",
    at: "left center",
    collision: "flip fit"
  }
};
var POPOVER_DEFAULT_BOUNDARY_OFFSET = {
  h: 10,
  v: 10
};
var PopoverPositionController = class extends OverlayPositionController {
  constructor(_ref) {
    let {
      shading,
      target,
      $arrow
    } = _ref, args = _objectWithoutPropertiesLoose(_ref, _excluded15);
    super(args);
    this._props = _extends({}, this._props, {
      shading,
      target
    });
    this._$arrow = $arrow;
    this._positionSide = void 0;
    this.updatePosition(this._props.position);
  }
  positionWrapper() {
    if (this._props.shading) {
      this._$wrapper.css({
        top: 0,
        left: 0
      });
    }
  }
  updateTarget(target) {
    this._props.target = target;
    this.updatePosition(this._props.position);
  }
  _renderBoundaryOffset() {
  }
  _getContainerPosition() {
    const offset2 = pairToObject(this._position.offset || "");
    let {
      h: hOffset,
      v: vOffset
    } = offset2;
    const isVerticalSide = this._isVerticalSide();
    const isHorizontalSide = this._isHorizontalSide();
    if (isVerticalSide || isHorizontalSide) {
      const isPopoverInside = this._isPopoverInside();
      const sign2 = (isPopoverInside ? -1 : 1) * WEIGHT_OF_SIDES[this._positionSide];
      const arrowSize = isVerticalSide ? getHeight(this._$arrow) : getWidth(this._$arrow);
      const arrowSizeCorrection = this._getContentBorderWidth(this._positionSide);
      const arrowOffset = sign2 * (arrowSize - arrowSizeCorrection);
      isVerticalSide ? vOffset += arrowOffset : hOffset += arrowOffset;
    }
    return extend({}, this._position, {
      offset: `${hOffset} ${vOffset}`
    });
  }
  _getContentBorderWidth(side) {
    const borderWidth = this._$content.css(borderWidthStyles[side]);
    return parseInt(borderWidth) || 0;
  }
  _isPopoverInside() {
    const my = position_default.setup.normalizeAlign(this._position.my);
    const at = position_default.setup.normalizeAlign(this._position.at);
    return my.h === at.h && my.v === at.v;
  }
  _isVerticalSide() {
    let side = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._positionSide;
    return "top" === side || "bottom" === side;
  }
  _isHorizontalSide() {
    let side = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._positionSide;
    return "left" === side || "right" === side;
  }
  _getDisplaySide(position3) {
    const my = position_default.setup.normalizeAlign(position3.my);
    const at = position_default.setup.normalizeAlign(position3.at);
    const weightSign = WEIGHT_OF_SIDES[my.h] === WEIGHT_OF_SIDES[at.h] && WEIGHT_OF_SIDES[my.v] === WEIGHT_OF_SIDES[at.v] ? -1 : 1;
    const horizontalWeight = Math.abs(WEIGHT_OF_SIDES[my.h] - weightSign * WEIGHT_OF_SIDES[at.h]);
    const verticalWeight = Math.abs(WEIGHT_OF_SIDES[my.v] - weightSign * WEIGHT_OF_SIDES[at.v]);
    return horizontalWeight > verticalWeight ? at.h : at.v;
  }
  _normalizePosition(positionProp) {
    const defaultPositionConfig = {
      of: this._props.target,
      boundaryOffset: POPOVER_DEFAULT_BOUNDARY_OFFSET
    };
    let resultPosition;
    if (isDefined(positionProp)) {
      resultPosition = extend(true, {}, defaultPositionConfig, this._positionToObject(positionProp));
    } else {
      resultPosition = defaultPositionConfig;
    }
    this._positionSide = this._getDisplaySide(resultPosition);
    return resultPosition;
  }
  _positionToObject(positionProp) {
    if (isString(positionProp)) {
      return extend({}, POPOVER_POSITION_ALIASES[positionProp]);
    }
    return positionProp;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/popover/m_popover.js
var POSITION_FLIP_MAP = {
  left: "right",
  top: "bottom",
  right: "left",
  bottom: "top",
  center: "center"
};
var getEventNameByOption = function(optionValue) {
  return isObject(optionValue) ? optionValue.name : optionValue;
};
var getEventName2 = function(that, optionName) {
  const optionValue = that.option(optionName);
  return getEventNameByOption(optionValue);
};
var getEventDelay = function(that, optionName) {
  const optionValue = that.option(optionName);
  return isObject(optionValue) && optionValue.delay;
};
var attachEvent2 = function(that, name2) {
  const {
    target,
    shading,
    disabled,
    hideEvent
  } = that.option();
  const isSelector = isString(target);
  const shouldIgnoreHideEvent = shading && "hide" === name2;
  const event = shouldIgnoreHideEvent ? null : getEventName2(that, `${name2}Event`);
  if (shouldIgnoreHideEvent && hideEvent) {
    ui_errors_default.log("W1020");
  }
  if (!event || disabled) {
    return;
  }
  const eventName = addNamespace2(event, that.NAME);
  const action = that._createAction((function() {
    const delay = getEventDelay(that, `${name2}Event`);
    this._clearEventsTimeouts();
    if (delay) {
      this._timeouts[name2] = setTimeout(() => {
        that[name2]();
      }, delay);
    } else {
      that[name2]();
    }
  }).bind(that), {
    validatingTargetName: "target"
  });
  const handler = function(e) {
    action({
      event: e,
      target: renderer_default(e.currentTarget)
    });
  };
  const EVENT_HANDLER_NAME = `_${name2}EventHandler`;
  if (isSelector) {
    that[EVENT_HANDLER_NAME] = handler;
    events_engine_default.on(dom_adapter_default.getDocument(), eventName, target, handler);
  } else {
    const targetElement = getPublicElement(renderer_default(target));
    that[EVENT_HANDLER_NAME] = void 0;
    events_engine_default.on(targetElement, eventName, handler);
  }
};
var detachEvent = function(that, target, name2, event) {
  let eventName = event || getEventName2(that, `${name2}Event`);
  if (!eventName) {
    return;
  }
  eventName = addNamespace2(eventName, that.NAME);
  const EVENT_HANDLER_NAME = `_${name2}EventHandler`;
  if (that[EVENT_HANDLER_NAME]) {
    events_engine_default.off(dom_adapter_default.getDocument(), eventName, target, that[EVENT_HANDLER_NAME]);
  } else {
    events_engine_default.off(getPublicElement(renderer_default(target)), eventName);
  }
};
var Popover = ui_popup_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      target: void 0,
      shading: false,
      position: extend({}, POPOVER_POSITION_ALIASES.bottom),
      hideOnOutsideClick: true,
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          from: 1,
          to: 0
        }
      },
      showTitle: false,
      width: "auto",
      height: "auto",
      dragEnabled: false,
      resizeEnabled: false,
      fullScreen: false,
      hideOnParentScroll: true,
      arrowPosition: "",
      arrowOffset: 0,
      _fixWrapperPosition: true
    });
  },
  _defaultOptionsRules: () => [{
    device: {
      platform: "ios"
    },
    options: {
      arrowPosition: {
        boundaryOffset: {
          h: 20,
          v: -10
        },
        collision: "fit"
      }
    }
  }, {
    device: () => !hasWindow(),
    options: {
      animation: null
    }
  }, {
    device: () => isMaterialBased(),
    options: {
      useFlatToolbarButtons: true
    }
  }, {
    device: () => isMaterial(),
    options: {
      useDefaultToolbarButtons: true,
      showCloseButton: false
    }
  }],
  _init() {
    var _this$option;
    this.callBase();
    this._renderArrow();
    this._timeouts = {};
    this.$element().addClass("dx-popover");
    this.$wrapper().addClass("dx-popover-wrapper");
    const isInteractive = null === (_this$option = this.option("toolbarItems")) || void 0 === _this$option ? void 0 : _this$option.length;
    this.setAria("role", isInteractive ? "dialog" : "tooltip");
  },
  _render() {
    this.callBase.apply(this, arguments);
    this._detachEvents(this.option("target"));
    this._attachEvents();
  },
  _detachEvents(target) {
    detachEvent(this, target, "show");
    detachEvent(this, target, "hide");
  },
  _attachEvents() {
    attachEvent2(this, "show");
    attachEvent2(this, "hide");
  },
  _renderArrow() {
    this._$arrow = renderer_default("<div>").addClass("dx-popover-arrow").prependTo(this.$overlayContent());
  },
  _documentDownHandler(e) {
    if (this._isOutsideClick(e)) {
      return this.callBase(e);
    }
    return true;
  },
  _isOutsideClick(e) {
    return !renderer_default(e.target).closest(this.option("target")).length;
  },
  _animate(animation3) {
    if (animation3 && animation3.to && "object" === typeof animation3.to) {
      extend(animation3.to, {
        position: this._getContainerPosition()
      });
    }
    this.callBase.apply(this, arguments);
  },
  _stopAnimation() {
    this.callBase.apply(this, arguments);
  },
  _renderTitle() {
    this.$wrapper().toggleClass("dx-popover-without-title", !this.option("showTitle"));
    this.callBase();
  },
  _renderPosition() {
    let shouldUpdateDimensions = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;
    this.callBase();
    this._renderOverlayPosition(shouldUpdateDimensions);
    this._actions.onPositioned();
  },
  _renderOverlayPosition(shouldUpdateDimensions) {
    this._resetOverlayPosition(shouldUpdateDimensions);
    this._updateContentSize(shouldUpdateDimensions);
    const contentPosition = this._getContainerPosition();
    const resultLocation = position_default.setup(this.$overlayContent(), contentPosition);
    const positionSide = this._getSideByLocation(resultLocation);
    this._togglePositionClass(`dx-position-${positionSide}`);
    this._toggleFlippedClass(resultLocation.h.flip, resultLocation.v.flip);
    const isArrowVisible = this._isHorizontalSide() || this._isVerticalSide();
    if (isArrowVisible) {
      this._renderArrowPosition(positionSide);
    }
  },
  _resetOverlayPosition(shouldUpdateDimensions) {
    this._setContentHeight(shouldUpdateDimensions);
    this._togglePositionClass(`dx-position-${this._positionController._positionSide}`);
    move(this.$overlayContent(), {
      left: 0,
      top: 0
    });
    this._$arrow.css({
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    });
  },
  _updateContentSize(shouldUpdateDimensions) {
    if (!this.$content() || !shouldUpdateDimensions) {
      return;
    }
    const containerLocation = position_default.calculate(this.$overlayContent(), this._getContainerPosition());
    if (containerLocation.h.oversize > 0 && this._isHorizontalSide() && !containerLocation.h.fit) {
      const newContainerWidth = getWidth(this.$overlayContent()) - containerLocation.h.oversize;
      setWidth(this.$overlayContent(), newContainerWidth);
    }
    if (containerLocation.v.oversize > 0 && this._isVerticalSide() && !containerLocation.v.fit) {
      const newOverlayContentHeight = getHeight(this.$overlayContent()) - containerLocation.v.oversize;
      const newPopupContentHeight = getHeight(this.$content()) - containerLocation.v.oversize;
      setHeight(this.$overlayContent(), newOverlayContentHeight);
      setHeight(this.$content(), newPopupContentHeight);
    }
  },
  _getContainerPosition() {
    return this._positionController._getContainerPosition();
  },
  _getHideOnParentScrollTarget() {
    return renderer_default(this._positionController._position.of || this.callBase());
  },
  _getSideByLocation(location) {
    const isFlippedByVertical = location.v.flip;
    const isFlippedByHorizontal = location.h.flip;
    return this._isVerticalSide() && isFlippedByVertical || this._isHorizontalSide() && isFlippedByHorizontal || this._isPopoverInside() ? POSITION_FLIP_MAP[this._positionController._positionSide] : this._positionController._positionSide;
  },
  _togglePositionClass(positionClass) {
    this.$wrapper().removeClass("dx-position-left dx-position-right dx-position-top dx-position-bottom").addClass(positionClass);
  },
  _toggleFlippedClass(isFlippedHorizontal, isFlippedVertical) {
    this.$wrapper().toggleClass("dx-popover-flipped-horizontal", isFlippedHorizontal).toggleClass("dx-popover-flipped-vertical", isFlippedVertical);
  },
  _renderArrowPosition(side) {
    const arrowRect = getBoundingRect(this._$arrow.get(0));
    const arrowFlip = -(this._isVerticalSide(side) ? arrowRect.height : arrowRect.width);
    this._$arrow.css(POSITION_FLIP_MAP[side], arrowFlip);
    const axis = this._isVerticalSide(side) ? "left" : "top";
    const sizeProperty = this._isVerticalSide(side) ? "width" : "height";
    const $target = renderer_default(this._positionController._position.of);
    const targetOffset = position_default.offset($target) || {
      top: 0,
      left: 0
    };
    const contentOffset = position_default.offset(this.$overlayContent());
    const arrowSize = arrowRect[sizeProperty];
    const contentLocation = contentOffset[axis];
    const contentSize = getBoundingRect(this.$overlayContent().get(0))[sizeProperty];
    const targetLocation = targetOffset[axis];
    const targetElement = $target.get(0);
    const targetSize = targetElement && !targetElement.preventDefault ? getBoundingRect(targetElement)[sizeProperty] : 0;
    const min = Math.max(contentLocation, targetLocation);
    const max = Math.min(contentLocation + contentSize, targetLocation + targetSize);
    let arrowLocation;
    if ("start" === this.option("arrowPosition")) {
      arrowLocation = min - contentLocation;
    } else if ("end" === this.option("arrowPosition")) {
      arrowLocation = max - contentLocation - arrowSize;
    } else {
      arrowLocation = (min + max) / 2 - contentLocation - arrowSize / 2;
    }
    const borderWidth = this._positionController._getContentBorderWidth(side);
    const finalArrowLocation = fitIntoRange(arrowLocation - borderWidth + this.option("arrowOffset"), borderWidth, contentSize - arrowSize - 2 * borderWidth);
    this._$arrow.css(axis, finalArrowLocation);
  },
  _isPopoverInside() {
    return this._positionController._isPopoverInside();
  },
  _setContentHeight(fullUpdate) {
    if (fullUpdate) {
      this.callBase();
    }
  },
  _getPositionControllerConfig() {
    const {
      shading,
      target
    } = this.option();
    return extend({}, this.callBase(), {
      target,
      shading,
      $arrow: this._$arrow
    });
  },
  _initPositionController() {
    this._positionController = new PopoverPositionController(this._getPositionControllerConfig());
  },
  _renderWrapperDimensions() {
    if (this.option("shading")) {
      this.$wrapper().css({
        width: "100%",
        height: "100%"
      });
    }
  },
  _isVerticalSide(side) {
    return this._positionController._isVerticalSide(side);
  },
  _isHorizontalSide(side) {
    return this._positionController._isHorizontalSide(side);
  },
  _clearEventTimeout(name2) {
    clearTimeout(this._timeouts[name2]);
  },
  _clearEventsTimeouts() {
    this._clearEventTimeout("show");
    this._clearEventTimeout("hide");
  },
  _clean() {
    this._detachEvents(this.option("target"));
    this.callBase.apply(this, arguments);
  },
  _optionChanged(args) {
    switch (args.name) {
      case "arrowPosition":
      case "arrowOffset":
        this._renderGeometry();
        break;
      case "fullScreen":
        if (args.value) {
          this.option("fullScreen", false);
        }
        break;
      case "target":
        args.previousValue && this._detachEvents(args.previousValue);
        this._positionController.updateTarget(args.value);
        this._invalidate();
        break;
      case "showEvent":
      case "hideEvent": {
        const name2 = args.name.substring(0, 4);
        const event = getEventNameByOption(args.previousValue);
        this.hide();
        detachEvent(this, this.option("target"), name2, event);
        attachEvent2(this, name2);
        break;
      }
      case "visible":
        this._clearEventTimeout(args.value ? "show" : "hide");
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  },
  show(target) {
    if (target) {
      this.option("target", target);
    }
    return this.callBase();
  }
});
component_registrator_default("dxPopover", Popover);
var m_popover_default = Popover;

// ../../../../../../node_modules/devextreme/esm/ui/popover/ui.popover.js
var ui_popover_default = m_popover_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_tooltip.js
var Tooltip = ui_popover_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      toolbarItems: [],
      showCloseButton: false,
      enableBodyScroll: true,
      showTitle: false,
      title: null,
      titleTemplate: null,
      onTitleRendered: null,
      bottomTemplate: null,
      preventScrollEvents: false,
      propagateOutsideClick: true
    });
  },
  _render() {
    this.$element().addClass("dx-tooltip");
    this.$wrapper().addClass("dx-tooltip-wrapper");
    this.callBase();
  },
  _renderContent() {
    this.callBase();
    this._toggleAriaAttributes();
  },
  _toggleAriaDescription(showing) {
    const $target = renderer_default(this.option("target"));
    const label = showing ? this._contentId : void 0;
    if (!isWindow($target.get(0))) {
      this.setAria("describedby", label, $target);
    }
  },
  _toggleAriaAttributes() {
    this._contentId = `dx-${new guid_default()}`;
    this.$overlayContent().attr({
      id: this._contentId
    });
    this._toggleAriaDescription(true);
  }
});
component_registrator_default("dxTooltip", Tooltip);
var m_tooltip_default = Tooltip;

// ../../../../../../node_modules/devextreme/esm/ui/tooltip.js
var tooltip_default = m_tooltip_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/tooltip/m_tooltip.js
var tooltip = null;
var removeTooltipElement = null;
var createTooltip = function(options2) {
  options2 = extend({
    position: "top"
  }, options2);
  const {
    content
  } = options2;
  delete options2.content;
  const $tooltip = renderer_default("<div>").html(content).appendTo(value());
  removeTooltipElement = function() {
    $tooltip.remove();
  };
  tooltip = new tooltip_default($tooltip, options2);
};
var removeTooltip = function() {
  if (!tooltip) {
    return;
  }
  removeTooltipElement();
  tooltip = null;
};
function show2(options2) {
  removeTooltip();
  createTooltip(options2);
  return tooltip.show();
}
function hide2() {
  if (!tooltip) {
    return Deferred().resolve();
  }
  return tooltip.hide().done(removeTooltip).promise();
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_appointment.js
var REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME = addNamespace2(pointer_default.enter, "dxSchedulerAppointment");
var REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME = addNamespace2(pointer_default.leave, "dxSchedulerAppointment");
var Appointment = class extends dom_component_default {
  get coloredElement() {
    return this.$element();
  }
  get rawAppointment() {
    return this.option("data");
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      data: {},
      groupIndex: -1,
      groups: [],
      geometry: {
        top: 0,
        left: 0,
        width: 0,
        height: 0
      },
      allowDrag: true,
      allowResize: true,
      reduced: null,
      isCompact: false,
      direction: "vertical",
      resizableConfig: {
        keepAspectRatio: false
      },
      cellHeight: 0,
      cellWidth: 0,
      isDragSource: false
    });
  }
  notifyObserver(subject, args) {
    const observer2 = this.option("observer");
    if (observer2) {
      observer2.fire(subject, args);
    }
  }
  invoke(funcName) {
    const observer2 = this.option("observer");
    if (observer2) {
      return observer2.fire.apply(observer2, arguments);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "data":
      case "groupIndex":
      case "geometry":
      case "allowDrag":
      case "allowResize":
      case "reduced":
      case "sortedIndex":
      case "isCompact":
      case "direction":
      case "resizableConfig":
      case "cellHeight":
      case "cellWidth":
        this._invalidate();
        break;
      case "isDragSource":
        this._renderDragSourceClass();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _getHorizontalResizingRule() {
    const reducedHandles = {
      head: this.option("rtlEnabled") ? "right" : "left",
      body: "",
      tail: this.option("rtlEnabled") ? "left" : "right"
    };
    const getResizableStep = this.option("getResizableStep");
    const step = getResizableStep ? getResizableStep() : 0;
    return {
      handles: this.option("reduced") ? reducedHandles[this.option("reduced")] : "left right",
      minHeight: 0,
      minWidth: this.invoke("getCellWidth"),
      step,
      roundStepValue: false
    };
  }
  _getVerticalResizingRule() {
    const height = Math.round(this.invoke("getCellHeight"));
    return {
      handles: "top bottom",
      minWidth: 0,
      minHeight: height,
      step: height,
      roundStepValue: true
    };
  }
  _render() {
    super._render();
    this._renderAppointmentGeometry();
    this._renderEmptyClass();
    this._renderReducedAppointment();
    this._renderAllDayClass();
    this._renderDragSourceClass();
    this._renderDirection();
    this.$element().data("dxAppointmentStartDate", this.option("startDate"));
    const text = ExpressionUtils.getField(this.option("dataAccessors"), "text", this.rawAppointment);
    this.$element().attr("title", text);
    this.$element().attr("role", "button");
    this._renderRecurrenceClass();
    this._renderResizable();
    this._setResourceColor();
  }
  _setResourceColor() {
    const appointmentConfig = {
      itemData: this.rawAppointment,
      groupIndex: this.option("groupIndex"),
      groups: this.option("groups")
    };
    const deferredColor = this.option("getAppointmentColor")(appointmentConfig);
    deferredColor.done((color) => {
      if (color) {
        this.coloredElement.css("backgroundColor", color);
        this.coloredElement.addClass(APPOINTMENT_HAS_RESOURCE_COLOR_CLASS);
      }
    });
  }
  _renderAppointmentGeometry() {
    const geometry = this.option("geometry");
    const $element = this.$element();
    move($element, {
      top: geometry.top,
      left: geometry.left
    });
    $element.css({
      width: geometry.width < 0 ? 0 : geometry.width,
      height: geometry.height < 0 ? 0 : geometry.height
    });
  }
  _renderEmptyClass() {
    const geometry = this.option("geometry");
    if (geometry.empty || this.option("isCompact")) {
      this.$element().addClass(EMPTY_APPOINTMENT_CLASS);
    }
  }
  _renderReducedAppointment() {
    const reducedPart = this.option("reduced");
    if (!reducedPart) {
      return;
    }
    this.$element().toggleClass(REDUCED_APPOINTMENT_CLASS, true).toggleClass(REDUCED_APPOINTMENT_PARTS_CLASSES[reducedPart], true);
    this._renderAppointmentReducedIcon();
  }
  _renderAppointmentReducedIcon() {
    const $icon = renderer_default("<div>").addClass(REDUCED_APPOINTMENT_ICON).appendTo(this.$element());
    const endDate = this._getEndDate();
    const tooltipLabel = message_default.format("dxScheduler-editorLabelEndDate");
    const tooltipText = [tooltipLabel, ": ", date_default3.format(endDate, "monthAndDay"), ", ", date_default3.format(endDate, "year")].join("");
    events_engine_default.off($icon, REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME);
    events_engine_default.on($icon, REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME, () => {
      show2({
        target: $icon,
        content: tooltipText
      });
    });
    events_engine_default.off($icon, REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME);
    events_engine_default.on($icon, REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME, () => {
      hide2();
    });
  }
  _getEndDate() {
    const result2 = ExpressionUtils.getField(this.option("dataAccessors"), "endDate", this.rawAppointment);
    if (result2) {
      return new Date(result2);
    }
    return result2;
  }
  _renderAllDayClass() {
    this.$element().toggleClass(ALL_DAY_APPOINTMENT_CLASS, !!this.option("allDay"));
  }
  _renderDragSourceClass() {
    this.$element().toggleClass(APPOINTMENT_DRAG_SOURCE_CLASS, !!this.option("isDragSource"));
  }
  _renderRecurrenceClass() {
    const rule = ExpressionUtils.getField(this.option("dataAccessors"), "recurrenceRule", this.rawAppointment);
    if (getRecurrenceProcessor().isValidRecurrenceRule(rule)) {
      this.$element().addClass(RECURRENCE_APPOINTMENT_CLASS);
    }
  }
  _renderDirection() {
    this.$element().addClass(DIRECTION_APPOINTMENT_CLASSES[this.option("direction")]);
  }
  _createResizingConfig() {
    const config3 = "vertical" === this.option("direction") ? this._getVerticalResizingRule() : this._getHorizontalResizingRule();
    if (!this.invoke("isGroupedByDate")) {
      config3.stepPrecision = "strict";
    }
    return config3;
  }
  _renderResizable() {
    if (this.option("allowResize")) {
      this._createComponent(this.$element(), resizable_default, extend(this._createResizingConfig(), this.option("resizableConfig")));
    }
  }
  _useTemplates() {
    return false;
  }
};
component_registrator_default("dxSchedulerAppointment", Appointment);
var AgendaAppointment = class extends Appointment {
  get coloredElement() {
    return this.$element().find(`.${APPOINTMENT_CONTENT_CLASSES.AGENDA_MARKER}`);
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      createPlainResourceListAsync: new Deferred()
    });
  }
  _renderResourceList(container, list) {
    list.forEach((item) => {
      const itemContainer = renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.AGENDA_RESOURCE_LIST_ITEM).appendTo(container);
      renderer_default("<div>").text(`${item.label}:`).appendTo(itemContainer);
      renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.AGENDA_RESOURCE_LIST_ITEM_VALUE).text(item.values.join(", ")).appendTo(itemContainer);
    });
  }
  _render() {
    super._render();
    const createPlainResourceListAsync = this.option("createPlainResourceListAsync");
    createPlainResourceListAsync(this.rawAppointment).done((list) => {
      const parent = this.$element().find(`.${APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_CONTENT_DETAILS}`);
      const container = renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.AGENDA_RESOURCE_LIST).appendTo(parent);
      this._renderResourceList(container, list);
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_appointment_layout.js
var allDayText = ` ${message_default.format("dxScheduler-allDay")}: `;
var createAppointmentLayout = (formatText, config3) => {
  const result2 = renderer_default(dom_adapter_default.createDocumentFragment());
  renderer_default("<div>").text(formatText.text).addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_TITLE).appendTo(result2);
  if (config3.html) {
    result2.html(config3.html);
  }
  const $contentDetails = renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_CONTENT_DETAILS).appendTo(result2);
  renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_DATE).text(formatText.formatDate).appendTo($contentDetails);
  config3.isRecurrence && renderer_default("<span>").addClass(`${APPOINTMENT_CONTENT_CLASSES.RECURRING_ICON} dx-icon-repeat`).appendTo(result2);
  config3.isAllDay && renderer_default("<div>").text(allDayText).addClass(APPOINTMENT_CONTENT_CLASSES.ALL_DAY_CONTENT).prependTo($contentDetails);
  return result2;
};
var createAgendaAppointmentLayout = (formatText, config3) => {
  const result2 = renderer_default(dom_adapter_default.createDocumentFragment());
  const leftLayoutContainer = renderer_default("<div>").addClass("dx-scheduler-agenda-appointment-left-layout").appendTo(result2);
  const rightLayoutContainer = renderer_default("<div>").addClass("dx-scheduler-agenda-appointment-right-layout").appendTo(result2);
  const marker = renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.AGENDA_MARKER).appendTo(leftLayoutContainer);
  config3.isRecurrence && renderer_default("<span>").addClass(`${APPOINTMENT_CONTENT_CLASSES.RECURRING_ICON} dx-icon-repeat`).appendTo(marker);
  renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_TITLE).text(formatText.text).appendTo(rightLayoutContainer);
  const additionalContainer = renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_CONTENT_DETAILS).appendTo(rightLayoutContainer);
  renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.APPOINTMENT_DATE).text(formatText.formatDate).appendTo(additionalContainer);
  if (config3.isAllDay) {
    renderer_default("<div>").text(allDayText).addClass(APPOINTMENT_CONTENT_CLASSES.ALL_DAY_CONTENT).prependTo(additionalContainer);
  }
  return result2;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/resizing/m_core.js
var getAppointmentLeftCell = (options2) => {
  const {
    cellHeight,
    cellWidth,
    viewDataProvider,
    relativeAppointmentRect,
    appointmentSettings,
    rtlEnabled
  } = options2;
  const cellRowIndex = Math.floor(relativeAppointmentRect.top / cellHeight);
  const cellColumnIndex = Math.round(relativeAppointmentRect.left / cellWidth);
  const leftCell = viewDataProvider.getCellData(cellRowIndex, cellColumnIndex, appointmentSettings.allDay, rtlEnabled);
  return leftCell;
};
var getDateRangeHorizontal = (options2) => {
  const {
    cellWidth,
    cellCountInRow,
    relativeAppointmentRect,
    viewDataProvider,
    appointmentSettings,
    handles
  } = options2;
  const appointmentFirstCell = getAppointmentLeftCell(options2);
  const appointmentCellsAmount = Math.round(relativeAppointmentRect.width / cellWidth);
  const appointmentLastCellIndex = appointmentFirstCell.index + (appointmentCellsAmount - 1);
  const {
    sourceAppointment
  } = appointmentSettings.info;
  const {
    allDay
  } = appointmentSettings.info.appointment;
  if (handles.left) {
    return {
      startDate: appointmentFirstCell.startDate,
      endDate: appointmentFirstCell.startDate > sourceAppointment.endDate ? appointmentFirstCell.startDate : sourceAppointment.endDate
    };
  }
  const appointmentRowIndex = Math.floor(appointmentLastCellIndex / cellCountInRow);
  const appointmentColumnIndex = appointmentLastCellIndex % cellCountInRow;
  const appointmentLastCell = viewDataProvider.getCellData(appointmentRowIndex, appointmentColumnIndex, allDay);
  const endDate = !options2.considerTime ? appointmentLastCell.endDate : appointmentLastCell.startDate;
  return {
    startDate: endDate < sourceAppointment.startDate ? endDate : sourceAppointment.startDate,
    endDate
  };
};
var getDateRangeHorizontalRTL = (options2) => {
  const {
    viewDataProvider,
    cellCountInRow,
    appointmentSettings,
    handles,
    cellWidth,
    relativeAppointmentRect
  } = options2;
  const appointmentLastCell = getAppointmentLeftCell(options2);
  const {
    sourceAppointment
  } = appointmentSettings.info;
  const {
    allDay
  } = appointmentSettings.info.appointment;
  if (handles.right) {
    const appointmentLastCellIndex = appointmentLastCell.index;
    const appointmentCellsAmount = Math.round(relativeAppointmentRect.width / cellWidth);
    const appointmentFirstCellIndex = appointmentLastCellIndex - appointmentCellsAmount + 1;
    const appointmentRowIndex = Math.floor(appointmentLastCellIndex / cellCountInRow);
    const appointmentFirstCell = viewDataProvider.getCellData(appointmentRowIndex, appointmentFirstCellIndex, allDay, true);
    return {
      startDate: appointmentFirstCell.startDate,
      endDate: appointmentFirstCell.startDate > sourceAppointment.endDate ? appointmentFirstCell.startDate : sourceAppointment.endDate
    };
  }
  const endDate = !options2.considerTime ? appointmentLastCell.endDate : appointmentLastCell.startDate;
  return {
    startDate: endDate < sourceAppointment.startDate ? endDate : sourceAppointment.startDate,
    endDate
  };
};
var getRelativeAppointmentRect = (appointmentRect, parentAppointmentRect) => {
  const left = appointmentRect.left - parentAppointmentRect.left;
  const top = appointmentRect.top - parentAppointmentRect.top;
  const width = left < 0 ? appointmentRect.width + left : appointmentRect.width;
  const height = top < 0 ? appointmentRect.height + top : appointmentRect.height;
  return {
    left: Math.max(0, left),
    top: Math.max(0, top),
    width,
    height
  };
};
var getAppointmentCellsInfo = (options2) => {
  const {
    appointmentSettings,
    isVerticalGroupedWorkSpace,
    DOMMetaData
  } = options2;
  const DOMMetaTable = appointmentSettings.allDay && !isVerticalGroupedWorkSpace ? [DOMMetaData.allDayPanelCellsMeta] : DOMMetaData.dateTableCellsMeta;
  const {
    positionByMap
  } = appointmentSettings;
  const {
    height: cellHeight,
    width: cellWidth
  } = DOMMetaTable[positionByMap.rowIndex][positionByMap.columnIndex];
  const cellCountInRow = DOMMetaTable[positionByMap.rowIndex].length;
  return {
    cellWidth,
    cellHeight,
    cellCountInRow
  };
};
var getAppointmentDateRange = (options2) => {
  const {
    appointmentSettings
  } = options2;
  const relativeAppointmentRect = getRelativeAppointmentRect(options2.appointmentRect, options2.parentAppointmentRect);
  const cellInfo = getAppointmentCellsInfo(options2);
  const considerTime = !options2.isDateAndTimeView || appointmentSettings.allDay;
  const extendedOptions = _extends({}, options2, cellInfo, {
    considerTime,
    relativeAppointmentRect
  });
  return !options2.rtlEnabled ? getDateRangeHorizontal(extendedOptions) : getDateRangeHorizontalRTL(extendedOptions);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_appointment_collection.js
var COMPONENT_CLASS = "dx-scheduler-scrollable-appointments";
var DBLCLICK_EVENT_NAME2 = addNamespace2(DBLCLICK_EVENT_NAME, "dxSchedulerAppointment");
var toMs9 = date_default.dateToMilliseconds;
var SchedulerAppointments = class extends ui_collection_widget_edit_default {
  get isAgendaView() {
    return this.invoke("isCurrentViewAgenda");
  }
  get isVirtualScrolling() {
    return this.invoke("isVirtualScrolling");
  }
  get appointmentDataProvider() {
    return this.option("getAppointmentDataProvider")();
  }
  constructor(element, options2) {
    super(element, options2);
    this._virtualAppointments = {};
  }
  option(optionName, value2) {
    return super.option(...arguments);
  }
  notifyObserver(subject, args) {
    const observer2 = this.option("observer");
    if (observer2) {
      observer2.fire(subject, args);
    }
  }
  invoke(funcName) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    const observer2 = this.option("observer");
    if (observer2) {
      return observer2.fire.apply(observer2, arguments);
    }
  }
  _dispose() {
    clearTimeout(this._appointmentClickTimeout);
    super._dispose();
  }
  _supportedKeys() {
    const parent = super._supportedKeys();
    const currentAppointment = this._$currentAppointment;
    return extend(parent, {
      escape: (function() {
        if (this.resizeOccur) {
          var _currentAppointment$d, _currentAppointment$d2, _currentAppointment$d3;
          this.moveAppointmentBack();
          this.resizeOccur = false;
          null === (_currentAppointment$d = currentAppointment.dxResizable("instance")) || void 0 === _currentAppointment$d || _currentAppointment$d._detachEventHandlers();
          null === (_currentAppointment$d2 = currentAppointment.dxResizable("instance")) || void 0 === _currentAppointment$d2 || _currentAppointment$d2._attachEventHandlers();
          null === (_currentAppointment$d3 = currentAppointment.dxResizable("instance")) || void 0 === _currentAppointment$d3 || _currentAppointment$d3._toggleResizingClass(false);
        }
      }).bind(this),
      del: (function(e) {
        if (this.option("allowDelete")) {
          e.preventDefault();
          const data2 = this._getItemData(e.target);
          this.notifyObserver("onDeleteButtonPress", {
            data: data2,
            target: e.target
          });
        }
      }).bind(this),
      tab: function(e) {
        const appointments = this._getAccessAppointments();
        const focusedAppointment = appointments.filter(".dx-state-focused");
        let index2 = focusedAppointment.data(APPOINTMENT_SETTINGS_KEY).sortedIndex;
        const lastIndex = appointments.length - 1;
        if (index2 > 0 && e.shiftKey || index2 < lastIndex && !e.shiftKey) {
          e.preventDefault();
          e.shiftKey ? index2-- : index2++;
          const $nextAppointment = this._getAppointmentByIndex(index2);
          this._resetTabIndex($nextAppointment);
          events_engine_default.trigger($nextAppointment, "focus");
        }
      }
    });
  }
  _getAppointmentByIndex(sortedIndex) {
    const appointments = this._getAccessAppointments();
    return appointments.filter((_, $item) => data($item, APPOINTMENT_SETTINGS_KEY).sortedIndex === sortedIndex).eq(0);
  }
  _getAccessAppointments() {
    return this._itemElements().filter(":visible").not(".dx-state-disabled");
  }
  _resetTabIndex($appointment) {
    this._focusTarget().attr("tabIndex", -1);
    $appointment.attr("tabIndex", this.option("tabIndex"));
  }
  _moveFocus() {
  }
  _focusTarget() {
    return this._itemElements();
  }
  _renderFocusTarget() {
    const $appointment = this._getAppointmentByIndex(0);
    this._resetTabIndex($appointment);
  }
  _focusInHandler(e) {
    super._focusInHandler(e);
    this._$currentAppointment = renderer_default(e.target);
    this.option("focusedElement", getPublicElement(renderer_default(e.target)));
  }
  _focusOutHandler(e) {
    const $appointment = this._getAppointmentByIndex(0);
    this.option("focusedElement", getPublicElement($appointment));
    super._focusOutHandler(e);
  }
  _eventBindingTarget() {
    return this._itemContainer();
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      noDataText: null,
      activeStateEnabled: true,
      hoverStateEnabled: true,
      tabIndex: 0,
      fixedContainer: null,
      allDayContainer: null,
      allowDrag: true,
      allowResize: true,
      allowAllDayResize: true,
      onAppointmentDblClick: null,
      _collectorOffset: 0,
      groups: [],
      resources: []
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case "items":
        this._cleanFocusState();
        this._clearDropDownItems();
        this._clearDropDownItemsElements();
        this._repaintAppointments(args.value);
        this._renderDropDownAppointments();
        this._attachAppointmentsEvents();
        break;
      case "fixedContainer":
      case "allDayContainer":
      case "onAppointmentDblClick":
      case "allowDelete":
        break;
      case "allowDrag":
      case "allowResize":
      case "allowAllDayResize":
        this._invalidate();
        break;
      case "focusedElement":
        this._resetTabIndex(renderer_default(args.value));
        super._optionChanged(args);
        break;
      case "focusStateEnabled":
        this._clearDropDownItemsElements();
        this._renderDropDownAppointments();
        super._optionChanged(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
  _isAllDayAppointment(appointment) {
    return appointment.settings.length && appointment.settings[0].allDay || false;
  }
  _isRepaintAppointment(appointment) {
    return !isDefined(appointment.needRepaint) || true === appointment.needRepaint;
  }
  _isRepaintAll(appointments) {
    if (this.isAgendaView) {
      return true;
    }
    for (let i = 0; i < appointments.length; i++) {
      if (!this._isRepaintAppointment(appointments[i])) {
        return false;
      }
    }
    return true;
  }
  _applyFragment(fragment, allDay) {
    if (fragment.children().length > 0) {
      this._getAppointmentContainer(allDay).append(fragment);
    }
  }
  _onEachAppointment(appointment, index2, container, isRepaintAll) {
    const repaintAppointment = () => {
      appointment.needRepaint = false;
      this._clearItem(appointment);
      this._renderItem(index2, appointment, container);
    };
    if (true === (null === appointment || void 0 === appointment ? void 0 : appointment.needRemove)) {
      this._clearItem(appointment);
    } else if (isRepaintAll || this._isRepaintAppointment(appointment)) {
      repaintAppointment();
    }
  }
  _repaintAppointments(appointments) {
    this._renderByFragments(($commonFragment, $allDayFragment) => {
      const isRepaintAll = this._isRepaintAll(appointments);
      if (isRepaintAll) {
        this._getAppointmentContainer(true).html("");
        this._getAppointmentContainer(false).html("");
      }
      !appointments.length && this._cleanItemContainer();
      appointments.forEach((appointment, index2) => {
        const container = this._isAllDayAppointment(appointment) ? $allDayFragment : $commonFragment;
        this._onEachAppointment(appointment, index2, container, isRepaintAll);
      });
    });
  }
  _renderByFragments(renderFunction) {
    if (this.isVirtualScrolling) {
      const $commonFragment = renderer_default(dom_adapter_default.createDocumentFragment());
      const $allDayFragment = renderer_default(dom_adapter_default.createDocumentFragment());
      renderFunction($commonFragment, $allDayFragment);
      this._applyFragment($commonFragment, false);
      this._applyFragment($allDayFragment, true);
    } else {
      renderFunction(this._getAppointmentContainer(false), this._getAppointmentContainer(true));
    }
  }
  _attachAppointmentsEvents() {
    this._attachClickEvent();
    this._attachHoldEvent();
    this._attachContextMenuEvent();
    this._attachAppointmentDblClick();
    this._renderFocusState();
    this._attachFeedbackEvents();
    this._attachHoverEvents();
  }
  _clearItem(item) {
    const $items = this._findItemElementByItem(item.itemData);
    if (!$items.length) {
      return;
    }
    each($items, (_, $item) => {
      $item.detach();
      $item.remove();
    });
  }
  _clearDropDownItems() {
    this._virtualAppointments = {};
  }
  _clearDropDownItemsElements() {
    this.invoke("clearCompactAppointments");
  }
  _findItemElementByItem(item) {
    const result2 = [];
    const that = this;
    this.itemElements().each(function() {
      const $item = renderer_default(this);
      if ($item.data(that._itemDataKey()) === item) {
        result2.push($item);
      }
    });
    return result2;
  }
  _itemClass() {
    return APPOINTMENT_ITEM_CLASS;
  }
  _itemContainer() {
    const $container = super._itemContainer();
    let $result = $container;
    const $allDayContainer = this.option("allDayContainer");
    if ($allDayContainer) {
      $result = $container.add($allDayContainer);
    }
    return $result;
  }
  _cleanItemContainer() {
    super._cleanItemContainer();
    const $allDayContainer = this.option("allDayContainer");
    if ($allDayContainer) {
      $allDayContainer.empty();
    }
    this._virtualAppointments = {};
  }
  _clean() {
    super._clean();
    delete this._$currentAppointment;
    delete this._initialSize;
    delete this._initialCoordinates;
  }
  _init() {
    super._init();
    this.$element().addClass(COMPONENT_CLASS);
    this._preventSingleAppointmentClick = false;
  }
  _renderAppointmentTemplate($container, appointment, model) {
    var _this$_currentAppoint;
    const config3 = {
      isAllDay: appointment.allDay,
      isRecurrence: appointment.recurrenceRule,
      html: isPlainObject(appointment) && appointment.html ? appointment.html : void 0
    };
    const formatText = this.invoke("getTextAndFormatDate", model.appointmentData, (null === (_this$_currentAppoint = this._currentAppointmentSettings) || void 0 === _this$_currentAppoint ? void 0 : _this$_currentAppoint.agendaSettings) || model.targetedAppointmentData, "TIME");
    $container.append(this.isAgendaView ? createAgendaAppointmentLayout(formatText, config3) : createAppointmentLayout(formatText, config3));
    if (!this.isAgendaView) {
      $container.parent().prepend(renderer_default("<div>").addClass(APPOINTMENT_CONTENT_CLASSES.STRIP));
    }
  }
  _executeItemRenderAction(index2, itemData, itemElement) {
    const action = this._getItemRenderAction();
    if (action) {
      action(this.invoke("mapAppointmentFields", {
        itemData,
        itemElement
      }));
    }
    delete this._currentAppointmentSettings;
  }
  _itemClickHandler(e) {
    super._itemClickHandler(e, {}, {
      afterExecute: (function(e2) {
        this._processItemClick(e2.args[0].event);
      }).bind(this)
    });
  }
  _processItemClick(e) {
    const $target = renderer_default(e.currentTarget);
    const data2 = this._getItemData($target);
    if ("keydown" === e.type || isFakeClickEvent(e)) {
      this.notifyObserver("showEditAppointmentPopup", {
        data: data2,
        target: $target
      });
      return;
    }
    this._appointmentClickTimeout = setTimeout(() => {
      if (!this._preventSingleAppointmentClick && isElementInDom($target)) {
        this.notifyObserver("showAppointmentTooltip", {
          data: data2,
          target: $target
        });
      }
      this._preventSingleAppointmentClick = false;
    }, 300);
  }
  _extendActionArgs($itemElement) {
    const args = super._extendActionArgs($itemElement);
    return this.invoke("mapAppointmentFields", args);
  }
  _render() {
    super._render();
    this._attachAppointmentDblClick();
  }
  _attachAppointmentDblClick() {
    const that = this;
    const itemSelector = that._itemSelector();
    const itemContainer = this._itemContainer();
    events_engine_default.off(itemContainer, DBLCLICK_EVENT_NAME2, itemSelector);
    events_engine_default.on(itemContainer, DBLCLICK_EVENT_NAME2, itemSelector, (e) => {
      that._itemDXEventHandler(e, "onAppointmentDblClick", {}, {
        afterExecute(e2) {
          that._dblClickHandler(e2.args[0].event);
        }
      });
    });
  }
  _dblClickHandler(e) {
    const $targetAppointment = renderer_default(e.currentTarget);
    const appointmentData = this._getItemData($targetAppointment);
    clearTimeout(this._appointmentClickTimeout);
    this._preventSingleAppointmentClick = true;
    this.notifyObserver("showEditAppointmentPopup", {
      data: appointmentData,
      target: $targetAppointment
    });
  }
  _renderItem(index2, item, container) {
    const {
      itemData
    } = item;
    const $items = [];
    for (let i = 0; i < item.settings.length; i++) {
      const setting = item.settings[i];
      this._currentAppointmentSettings = setting;
      const $item = super._renderItem(index2, itemData, container);
      $item.data(APPOINTMENT_SETTINGS_KEY, setting);
      $items.push($item);
    }
    return $items;
  }
  _getItemContent($itemFrame) {
    $itemFrame.data(APPOINTMENT_SETTINGS_KEY, this._currentAppointmentSettings);
    const $itemContent = super._getItemContent($itemFrame);
    return $itemContent;
  }
  _createItemByTemplate(itemTemplate, renderArgs) {
    const {
      itemData,
      container,
      index: index2
    } = renderArgs;
    return itemTemplate.render({
      model: {
        appointmentData: itemData,
        targetedAppointmentData: this.invoke("getTargetedAppointmentData", itemData, renderer_default(container).parent())
      },
      container,
      index: index2
    });
  }
  _getAppointmentContainer(allDay) {
    const $allDayContainer = this.option("allDayContainer");
    let $container = this.itemsContainer().not($allDayContainer);
    if (allDay && $allDayContainer) {
      $container = $allDayContainer;
    }
    return $container;
  }
  _postprocessRenderItem(args) {
    this._renderAppointment(args.itemElement, this._currentAppointmentSettings);
  }
  _renderAppointment(element, settings) {
    element.data(APPOINTMENT_SETTINGS_KEY, settings);
    this._applyResourceDataAttr(element);
    const rawAppointment = this._getItemData(element);
    const geometry = this.invoke("getAppointmentGeometry", settings);
    const allowResize = this.option("allowResize") && (!isDefined(settings.skipResizing) || isString(settings.skipResizing));
    const allowDrag = this.option("allowDrag");
    const {
      allDay
    } = settings;
    this.invoke("setCellDataCacheAlias", this._currentAppointmentSettings, geometry);
    if (settings.virtual) {
      const appointmentConfig = {
        itemData: rawAppointment,
        groupIndex: settings.groupIndex,
        groups: this.option("groups")
      };
      const deferredColor = this.option("getAppointmentColor")(appointmentConfig);
      this._processVirtualAppointment(settings, element, rawAppointment, deferredColor);
    } else {
      var _settings$info;
      const config3 = {
        data: rawAppointment,
        groupIndex: settings.groupIndex,
        observer: this.option("observer"),
        geometry,
        direction: settings.direction || "vertical",
        allowResize,
        allowDrag,
        allDay,
        reduced: settings.appointmentReduced,
        isCompact: settings.isCompact,
        startDate: new Date(null === (_settings$info = settings.info) || void 0 === _settings$info ? void 0 : _settings$info.appointment.startDate),
        cellWidth: this.invoke("getCellWidth"),
        cellHeight: this.invoke("getCellHeight"),
        resizableConfig: this._resizableConfig(rawAppointment, settings),
        groups: this.option("groups"),
        getAppointmentColor: this.option("getAppointmentColor"),
        getResourceDataAccessors: this.option("getResourceDataAccessors")
      };
      if (this.isAgendaView) {
        const agendaResourceProcessor = this.option("getAgendaResourceProcessor")();
        config3.createPlainResourceListAsync = (rawAppointment2) => agendaResourceProcessor.createListAsync(rawAppointment2);
      }
      this._createComponent(element, this.isAgendaView ? AgendaAppointment : Appointment, _extends({}, config3, {
        dataAccessors: this.option("dataAccessors"),
        getResizableStep: this.option("getResizableStep")
      }));
    }
  }
  _applyResourceDataAttr($appointment) {
    const dataAccessors = this.option("getResourceDataAccessors")();
    const rawAppointment = this._getItemData($appointment);
    each(dataAccessors.getter, (key) => {
      const value2 = dataAccessors.getter[key](rawAppointment);
      if (isDefined(value2)) {
        const prefix = `data-${normalizeKey(key.toLowerCase())}-`;
        wrapToArray(value2).forEach((value3) => $appointment.attr(prefix + normalizeKey(value3), true));
      }
    });
  }
  _resizableConfig(appointmentData, itemSetting) {
    return {
      area: this._calculateResizableArea(itemSetting, appointmentData),
      onResizeStart: (function(e) {
        this.resizeOccur = true;
        this._$currentAppointment = renderer_default(e.element);
        if (this.invoke("needRecalculateResizableArea")) {
          const updatedArea = this._calculateResizableArea(this._$currentAppointment.data(APPOINTMENT_SETTINGS_KEY), this._$currentAppointment.data("dxItemData"));
          e.component.option("area", updatedArea);
          e.component._renderDragOffsets(e.event);
        }
        this._initialSize = {
          width: e.width,
          height: e.height
        };
        this._initialCoordinates = locate(this._$currentAppointment);
      }).bind(this),
      onResizeEnd: (function(e) {
        this.resizeOccur = false;
        this._resizeEndHandler(e);
      }).bind(this)
    };
  }
  _calculateResizableArea(itemSetting, appointmentData) {
    const area = this.$element().closest(".dx-scrollable-content");
    return this.invoke("getResizableAppointmentArea", {
      coordinates: {
        left: itemSetting.left,
        top: 0,
        groupIndex: itemSetting.groupIndex
      },
      allDay: itemSetting.allDay
    }) || area;
  }
  _resizeEndHandler(e) {
    const $element = renderer_default(e.element);
    const {
      allDay,
      info
    } = $element.data("dxAppointmentSettings");
    const sourceAppointment = this._getItemData($element);
    const viewOffset = this.invoke("getViewOffsetMs");
    let dateRange;
    if (allDay) {
      dateRange = this.resizeAllDay(e);
    } else {
      const startDate = this._getEndResizeAppointmentStartDate(e, sourceAppointment, info.appointment);
      const {
        endDate
      } = info.appointment;
      const shiftedStartDate = dateUtilsTs.addOffsets(startDate, [-viewOffset]);
      const shiftedEndDate = dateUtilsTs.addOffsets(endDate, [-viewOffset]);
      dateRange = this._getDateRange(e, shiftedStartDate, shiftedEndDate);
      dateRange.startDate = dateUtilsTs.addOffsets(dateRange.startDate, [viewOffset]);
      dateRange.endDate = dateUtilsTs.addOffsets(dateRange.endDate, [viewOffset]);
    }
    this.updateResizedAppointment($element, dateRange, this.option("dataAccessors"), this.option("timeZoneCalculator"));
  }
  resizeAllDay(e) {
    const $element = renderer_default(e.element);
    const timeZoneCalculator = this.option("timeZoneCalculator");
    const dataAccessors = this.option("dataAccessors");
    return getAppointmentDateRange({
      handles: e.handles,
      appointmentSettings: $element.data("dxAppointmentSettings"),
      isVerticalViewDirection: this.option("isVerticalViewDirection")(),
      isVerticalGroupedWorkSpace: this.option("isVerticalGroupedWorkSpace")(),
      appointmentRect: getBoundingRect($element[0]),
      parentAppointmentRect: getBoundingRect($element.parent()[0]),
      viewDataProvider: this.option("getViewDataProvider")(),
      isDateAndTimeView: this.option("isDateAndTimeView")(),
      startDayHour: this.invoke("getStartDayHour"),
      endDayHour: this.invoke("getEndDayHour"),
      timeZoneCalculator,
      dataAccessors,
      rtlEnabled: this.option("rtlEnabled"),
      DOMMetaData: this.option("getDOMElementsMetaData")(),
      viewOffset: this.invoke("getViewOffsetMs")
    });
  }
  updateResizedAppointment($element, dateRange, dataAccessors, timeZoneCalculator) {
    const sourceAppointment = this._getItemData($element);
    const modifiedAppointmentAdapter = createAppointmentAdapter(sourceAppointment, dataAccessors, timeZoneCalculator).clone();
    modifiedAppointmentAdapter.startDate = new Date(dateRange.startDate);
    modifiedAppointmentAdapter.endDate = new Date(dateRange.endDate);
    this.notifyObserver("updateAppointmentAfterResize", {
      target: sourceAppointment,
      data: modifiedAppointmentAdapter.clone({
        pathTimeZone: "fromGrid"
      }).source(),
      $appointment: $element
    });
  }
  _getEndResizeAppointmentStartDate(e, rawAppointment, appointmentInfo) {
    const timeZoneCalculator = this.option("timeZoneCalculator");
    const appointmentAdapter = createAppointmentAdapter(rawAppointment, this.option("dataAccessors"), timeZoneCalculator);
    let {
      startDate
    } = appointmentInfo;
    const recurrenceProcessor = getRecurrenceProcessor();
    const {
      recurrenceRule,
      startDateTimeZone
    } = appointmentAdapter;
    const isAllDay = this.invoke("isAllDay", rawAppointment);
    const isRecurrent = recurrenceProcessor.isValidRecurrenceRule(recurrenceRule);
    if (!e.handles.top && !isRecurrent && !isAllDay) {
      startDate = timeZoneCalculator.createDate(appointmentAdapter.startDate, {
        appointmentTimeZone: startDateTimeZone,
        path: "toGrid"
      });
    }
    return startDate;
  }
  _getDateRange(e, startDate, endDate) {
    const itemData = this._getItemData(e.element);
    const deltaTime = this.invoke("getDeltaTime", e, this._initialSize, itemData);
    const renderingStrategyDirection = this.invoke("getRenderingStrategyDirection");
    let isStartDateChanged = false;
    const isAllDay = this.invoke("isAllDay", itemData);
    const needCorrectDates = this.invoke("needCorrectAppointmentDates") && !isAllDay;
    let startTime;
    let endTime;
    if ("vertical" !== renderingStrategyDirection || isAllDay) {
      isStartDateChanged = this.option("rtlEnabled") ? e.handles.right : e.handles.left;
    } else {
      isStartDateChanged = e.handles.top;
    }
    if (isStartDateChanged) {
      startTime = needCorrectDates ? this._correctStartDateByDelta(startDate, deltaTime) : startDate.getTime() - deltaTime;
      startTime += m_utils_time_zone_default.getTimezoneOffsetChangeInMs(startDate, endDate, startTime, endDate);
      endTime = endDate.getTime();
    } else {
      startTime = startDate.getTime();
      endTime = needCorrectDates ? this._correctEndDateByDelta(endDate, deltaTime) : endDate.getTime() + deltaTime;
      endTime -= m_utils_time_zone_default.getTimezoneOffsetChangeInMs(startDate, endDate, startDate, endTime);
    }
    return {
      startDate: new Date(startTime),
      endDate: new Date(endTime)
    };
  }
  _correctEndDateByDelta(endDate, deltaTime) {
    const endDayHour = this.invoke("getEndDayHour");
    const startDayHour = this.invoke("getStartDayHour");
    const maxDate = new Date(endDate);
    const minDate = new Date(endDate);
    const correctEndDate = new Date(endDate);
    minDate.setHours(startDayHour, 0, 0, 0);
    maxDate.setHours(endDayHour, 0, 0, 0);
    if (correctEndDate > maxDate) {
      correctEndDate.setHours(endDayHour, 0, 0, 0);
    }
    let result2 = correctEndDate.getTime() + deltaTime;
    const visibleDayDuration = (endDayHour - startDayHour) * toMs9("hour");
    const daysCount = deltaTime > 0 ? Math.ceil(deltaTime / visibleDayDuration) : Math.floor(deltaTime / visibleDayDuration);
    if (result2 > maxDate.getTime() || result2 <= minDate.getTime()) {
      const tailOfCurrentDay = maxDate.getTime() - correctEndDate.getTime();
      const tailOfPrevDays = deltaTime - tailOfCurrentDay;
      const correctedEndDate = new Date(correctEndDate).setDate(correctEndDate.getDate() + daysCount);
      const lastDay = new Date(correctedEndDate);
      lastDay.setHours(startDayHour, 0, 0, 0);
      result2 = lastDay.getTime() + tailOfPrevDays - visibleDayDuration * (daysCount - 1);
    }
    return result2;
  }
  _correctStartDateByDelta(startDate, deltaTime) {
    const endDayHour = this.invoke("getEndDayHour");
    const startDayHour = this.invoke("getStartDayHour");
    const maxDate = new Date(startDate);
    const minDate = new Date(startDate);
    const correctStartDate = new Date(startDate);
    minDate.setHours(startDayHour, 0, 0, 0);
    maxDate.setHours(endDayHour, 0, 0, 0);
    if (correctStartDate < minDate) {
      correctStartDate.setHours(startDayHour, 0, 0, 0);
    }
    let result2 = correctStartDate.getTime() - deltaTime;
    const visibleDayDuration = (endDayHour - startDayHour) * toMs9("hour");
    const daysCount = deltaTime > 0 ? Math.ceil(deltaTime / visibleDayDuration) : Math.floor(deltaTime / visibleDayDuration);
    if (result2 < minDate.getTime() || result2 >= maxDate.getTime()) {
      const tailOfCurrentDay = correctStartDate.getTime() - minDate.getTime();
      const tailOfPrevDays = deltaTime - tailOfCurrentDay;
      const firstDay = new Date(correctStartDate.setDate(correctStartDate.getDate() - daysCount));
      firstDay.setHours(endDayHour, 0, 0, 0);
      result2 = firstDay.getTime() - tailOfPrevDays + visibleDayDuration * (daysCount - 1);
    }
    return result2;
  }
  _processVirtualAppointment(appointmentSetting, $appointment, appointmentData, color) {
    const virtualAppointment = appointmentSetting.virtual;
    const virtualGroupIndex = virtualAppointment.index;
    if (!isDefined(this._virtualAppointments[virtualGroupIndex])) {
      this._virtualAppointments[virtualGroupIndex] = {
        coordinates: {
          top: virtualAppointment.top,
          left: virtualAppointment.left
        },
        items: {
          data: [],
          colors: [],
          settings: []
        },
        isAllDay: !!virtualAppointment.isAllDay,
        buttonColor: color
      };
    }
    appointmentSetting.targetedAppointmentData = this.invoke("getTargetedAppointmentData", appointmentData, $appointment);
    this._virtualAppointments[virtualGroupIndex].items.settings.push(appointmentSetting);
    this._virtualAppointments[virtualGroupIndex].items.data.push(appointmentData);
    this._virtualAppointments[virtualGroupIndex].items.colors.push(color);
    $appointment.remove();
  }
  _renderContentImpl() {
    super._renderContentImpl();
    this._renderDropDownAppointments();
  }
  _renderDropDownAppointments() {
    this._renderByFragments(($commonFragment, $allDayFragment) => {
      each(this._virtualAppointments, (groupIndex) => {
        const virtualGroup = this._virtualAppointments[groupIndex];
        const virtualItems = virtualGroup.items;
        const virtualCoordinates = virtualGroup.coordinates;
        const $fragment = virtualGroup.isAllDay ? $allDayFragment : $commonFragment;
        const {
          left
        } = virtualCoordinates;
        const buttonWidth = this.invoke("getDropDownAppointmentWidth", virtualGroup.isAllDay);
        const buttonHeight = this.invoke("getDropDownAppointmentHeight");
        const rtlOffset = this.option("rtlEnabled") ? buttonWidth : 0;
        this.notifyObserver("renderCompactAppointments", {
          $container: $fragment,
          coordinates: {
            top: virtualCoordinates.top,
            left: left + rtlOffset
          },
          items: virtualItems,
          buttonColor: virtualGroup.buttonColor,
          width: buttonWidth - this.option("_collectorOffset"),
          height: buttonHeight,
          onAppointmentClick: this.option("onItemClick"),
          allowDrag: this.option("allowDrag"),
          cellWidth: this.invoke("getCellWidth"),
          isCompact: this.invoke("isAdaptive") || this._isGroupCompact(virtualGroup)
        });
      });
    });
  }
  _isGroupCompact(virtualGroup) {
    return !virtualGroup.isAllDay && this.invoke("supportCompactDropDownAppointments");
  }
  _sortAppointmentsByStartDate(appointments) {
    return sortAppointmentsByStartDate(appointments, this.option("dataAccessors"));
  }
  _processRecurrenceAppointment(appointment, index2, skipLongAppointments) {
    const recurrenceRule = ExpressionUtils.getField(this.option("dataAccessors"), "recurrenceRule", appointment);
    const result2 = {
      parts: [],
      indexes: []
    };
    if (recurrenceRule) {
      const dates = appointment.settings || appointment;
      const startDate = new Date(ExpressionUtils.getField(this.option("dataAccessors"), "startDate", dates));
      const startDateTimeZone = ExpressionUtils.getField(this.option("dataAccessors"), "startDateTimeZone", appointment);
      const endDate = new Date(ExpressionUtils.getField(this.option("dataAccessors"), "endDate", dates));
      const appointmentDuration = endDate.getTime() - startDate.getTime();
      const recurrenceException = ExpressionUtils.getField(this.option("dataAccessors"), "recurrenceException", appointment);
      const startViewDate = this.invoke("getStartViewDate");
      const endViewDate = this.invoke("getEndViewDate");
      const timezoneCalculator = this.option("timeZoneCalculator");
      const recurrentDates = getRecurrenceProcessor().generateDates({
        rule: recurrenceRule,
        exception: recurrenceException,
        start: startDate,
        end: endDate,
        min: startViewDate,
        max: endViewDate,
        appointmentTimezoneOffset: timezoneCalculator.getOriginStartDateOffsetInMs(startDate, startDateTimeZone, false)
      });
      const recurrentDateCount = appointment.settings ? 1 : recurrentDates.length;
      for (let i = 0; i < recurrentDateCount; i++) {
        const appointmentPart = extend({}, appointment, true);
        if (recurrentDates[i]) {
          const appointmentSettings = this._applyStartDateToObj(recurrentDates[i], {});
          this._applyEndDateToObj(new Date(recurrentDates[i].getTime() + appointmentDuration), appointmentSettings);
          appointmentPart.settings = appointmentSettings;
        } else {
          appointmentPart.settings = dates;
        }
        result2.parts.push(appointmentPart);
        if (!skipLongAppointments) {
          this._processLongAppointment(appointmentPart, result2);
        }
      }
      result2.indexes.push(index2);
    }
    return result2;
  }
  _processLongAppointment(appointment, result2) {
    const parts = this.splitAppointmentByDay(appointment);
    const partCount = parts.length;
    const endViewDate = this.invoke("getEndViewDate").getTime();
    const startViewDate = this.invoke("getStartViewDate").getTime();
    const timeZoneCalculator = this.option("timeZoneCalculator");
    result2 = result2 || {
      parts: []
    };
    if (partCount > 1) {
      extend(appointment, parts[0]);
      for (let i = 1; i < partCount; i++) {
        let startDate = ExpressionUtils.getField(this.option("dataAccessors"), "startDate", parts[i].settings).getTime();
        startDate = timeZoneCalculator.createDate(startDate, {
          path: "toGrid"
        });
        if (startDate < endViewDate && startDate > startViewDate) {
          result2.parts.push(parts[i]);
        }
      }
    }
    return result2;
  }
  _reduceRecurrenceAppointments(recurrenceIndexes, appointments) {
    each(recurrenceIndexes, (i, index2) => {
      appointments.splice(index2 - i, 1);
    });
  }
  _combineAppointments(appointments, additionalAppointments) {
    if (additionalAppointments.length) {
      appointments.push(...additionalAppointments);
    }
    this._sortAppointmentsByStartDate(appointments);
  }
  _applyStartDateToObj(startDate, obj) {
    ExpressionUtils.setField(this.option("dataAccessors"), "startDate", obj, startDate);
    return obj;
  }
  _applyEndDateToObj(endDate, obj) {
    ExpressionUtils.setField(this.option("dataAccessors"), "endDate", obj, endDate);
    return obj;
  }
  moveAppointmentBack(dragEvent) {
    const $appointment = this._$currentAppointment;
    const size = this._initialSize;
    const coords = this._initialCoordinates;
    if (dragEvent) {
      this._removeDragSourceClassFromDraggedAppointment();
      if (isDeferred(dragEvent.cancel)) {
        dragEvent.cancel.resolve(true);
      } else {
        dragEvent.cancel = true;
      }
    }
    if ($appointment && !dragEvent) {
      if (coords) {
        move($appointment, coords);
        delete this._initialSize;
      }
      if (size) {
        setOuterWidth($appointment, size.width);
        setOuterHeight($appointment, size.height);
        delete this._initialCoordinates;
      }
    }
  }
  focus() {
    if (this._$currentAppointment) {
      const focusedElement = getPublicElement(this._$currentAppointment);
      this.option("focusedElement", focusedElement);
      events_engine_default.trigger(focusedElement, "focus");
    }
  }
  splitAppointmentByDay(appointment) {
    const dates = appointment.settings || appointment;
    const dataAccessors = this.option("dataAccessors");
    const originalStartDate = new Date(ExpressionUtils.getField(dataAccessors, "startDate", dates));
    let startDate = date_default.makeDate(originalStartDate);
    let endDate = date_default.makeDate(ExpressionUtils.getField(dataAccessors, "endDate", dates));
    const maxAllowedDate = this.invoke("getEndViewDate");
    const startDayHour = this.invoke("getStartDayHour");
    const endDayHour = this.invoke("getEndDayHour");
    const timeZoneCalculator = this.option("timeZoneCalculator");
    const adapter = createAppointmentAdapter(appointment, dataAccessors, timeZoneCalculator);
    const appointmentIsLong = getAppointmentTakesSeveralDays(adapter);
    const result2 = [];
    startDate = timeZoneCalculator.createDate(startDate, {
      path: "toGrid"
    });
    endDate = timeZoneCalculator.createDate(endDate, {
      path: "toGrid"
    });
    if (startDate.getHours() <= endDayHour && startDate.getHours() >= startDayHour && !appointmentIsLong) {
      result2.push(this._applyStartDateToObj(new Date(startDate), {
        appointmentData: appointment
      }));
      startDate.setDate(startDate.getDate() + 1);
    }
    while (appointmentIsLong && startDate.getTime() < endDate.getTime() && startDate < maxAllowedDate) {
      const currentStartDate = new Date(startDate);
      const currentEndDate = new Date(startDate);
      this._checkStartDate(currentStartDate, originalStartDate, startDayHour);
      this._checkEndDate(currentEndDate, endDate, endDayHour);
      const appointmentData = deepExtendArraySafe({}, appointment, true);
      const appointmentSettings = {};
      this._applyStartDateToObj(currentStartDate, appointmentSettings);
      this._applyEndDateToObj(currentEndDate, appointmentSettings);
      appointmentData.settings = appointmentSettings;
      result2.push(appointmentData);
      startDate = date_default.trimTime(startDate);
      startDate.setDate(startDate.getDate() + 1);
      startDate.setHours(startDayHour);
    }
    return result2;
  }
  _checkStartDate(currentDate, originalDate, startDayHour) {
    if (!date_default.sameDate(currentDate, originalDate) || currentDate.getHours() <= startDayHour) {
      currentDate.setHours(startDayHour, 0, 0, 0);
    } else {
      currentDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());
    }
  }
  _checkEndDate(currentDate, originalDate, endDayHour) {
    if (!date_default.sameDate(currentDate, originalDate) || currentDate.getHours() > endDayHour) {
      currentDate.setHours(endDayHour, 0, 0, 0);
    } else {
      currentDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());
    }
  }
  _removeDragSourceClassFromDraggedAppointment() {
    const $appointments = this._itemElements().filter(`.${APPOINTMENT_DRAG_SOURCE_CLASS}`);
    $appointments.each((_, element) => {
      const appointmentInstance = renderer_default(element).dxSchedulerAppointment("instance");
      appointmentInstance.option("isDragSource", false);
    });
  }
  _setDragSourceAppointment(appointment, settings) {
    const $appointments = this._findItemElementByItem(appointment);
    const {
      startDate,
      endDate
    } = settings.info.sourceAppointment;
    const {
      groupIndex
    } = settings;
    $appointments.forEach(($item) => {
      const {
        info: itemInfo,
        groupIndex: itemGroupIndex
      } = $item.data(APPOINTMENT_SETTINGS_KEY);
      const {
        startDate: itemStartDate,
        endDate: itemEndDate
      } = itemInfo.sourceAppointment;
      const appointmentInstance = $item.dxSchedulerAppointment("instance");
      const isDragSource = startDate.getTime() === itemStartDate.getTime() && endDate.getTime() === itemEndDate.getTime() && groupIndex === itemGroupIndex;
      appointmentInstance.option("isDragSource", isDragSource);
    });
  }
  updateResizableArea() {
    const $allResizableElements = this.$element().find(".dx-scheduler-appointment.dx-resizable");
    const horizontalResizables = grep($allResizableElements, (el) => {
      const $el = renderer_default(el);
      const resizableInst = $el.dxResizable("instance");
      const {
        area,
        handles
      } = resizableInst.option();
      return ("right left" === handles || "left right" === handles) && isPlainObject(area);
    });
    each(horizontalResizables, (_, el) => {
      const $el = renderer_default(el);
      const position3 = locate($el);
      const appointmentData = this._getItemData($el);
      const area = this._calculateResizableArea({
        left: position3.left
      }, appointmentData);
      $el.dxResizable("instance").option("area", area);
    });
  }
};
component_registrator_default("dxSchedulerAppointments", SchedulerAppointments);
var m_appointment_collection_default = SchedulerAppointments;

// ../../../../../../node_modules/devextreme/esm/__internal/data_controller.js
var DataController2 = class {
  constructor(dataSourceOptions, _ref) {
    let {
      key
    } = _ref;
    this._isSharedDataSource = false;
    this._keyExpr = key;
    this.updateDataSource(dataSourceOptions);
  }
  _updateDataSource(dataSourceOptions) {
    if (!dataSourceOptions) {
      return;
    }
    if (dataSourceOptions instanceof DataSource) {
      this._isSharedDataSource = true;
      this._dataSource = dataSourceOptions;
    } else {
      const normalizedDataSourceOptions = normalizeDataSourceOptions(dataSourceOptions);
      this._dataSource = new DataSource(extend(true, {}, {}, normalizedDataSourceOptions));
    }
  }
  _updateDataSourceByItems(items) {
    this._dataSource = new DataSource({
      store: new array_store_default({
        key: this.key(),
        data: items
      }),
      pageSize: 0
    });
  }
  _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        this._isSharedDataSource = false;
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
    }
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(propName, propValue) {
    if (!this._dataSource) {
      return new Deferred().reject();
    }
    let pName = propName;
    let pValue = propValue;
    if (arguments.length < 2) {
      pValue = propName;
      pName = this.key();
    }
    return this._dataSource.loadSingle(pName, pValue);
  }
  loadFromStore(loadOptions) {
    return this.store().load(loadOptions);
  }
  loadNextPage() {
    this.pageIndex(1 + this.pageIndex());
    return this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(operationId) {
    this._dataSource.cancel(operationId);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(filter) {
    return this._dataSource.filter(filter);
  }
  addSearchFilter(storeLoadOptions) {
    this._dataSource._addSearchFilter(storeLoadOptions);
  }
  group(group) {
    return this._dataSource.group(group);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(pageIndex) {
    if (void 0 === pageIndex) {
      return this._dataSource.pageIndex(void 0);
    }
    return this._dataSource.pageIndex(pageIndex);
  }
  resetDataSource() {
    this._disposeDataSource();
  }
  resetDataSourcePageIndex() {
    if (this.pageIndex()) {
      this.pageIndex(0);
      this.load();
    }
  }
  updateDataSource(items, key) {
    const dataSourceOptions = items ?? this.items();
    if (key) {
      this._keyExpr = key;
    }
    this._disposeDataSource();
    if (Array.isArray(dataSourceOptions)) {
      this._updateDataSourceByItems(dataSourceOptions);
    } else {
      this._updateDataSource(dataSourceOptions);
    }
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(value2) {
    return this._dataSource.searchValue(value2);
  }
  searchOperation(operation) {
    return this._dataSource.searchOperation(operation);
  }
  searchExpr(expr) {
    return this._dataSource.searchExpr(expr);
  }
  select() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this._dataSource.select(args);
  }
  key() {
    var _this$_dataSource;
    const storeKey = null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.key();
    return isDefined(storeKey) && "this" === this._keyExpr ? storeKey : this._keyExpr;
  }
  keyOf(item) {
    return this.store().keyOf(item);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    var _this$_dataSource2;
    return null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 ? void 0 : _this$_dataSource2.items();
  }
  applyMapFunction(data2) {
    return this._dataSource._applyMapFunction(data2);
  }
  getDataSource() {
    return this._dataSource ?? null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(event, handler) {
    this._dataSource.on(event, handler);
  }
  off(event, handler) {
    this._dataSource.off(event, handler);
  }
};
var data_controller_default = DataController2;

// ../../../../../../node_modules/devextreme/esm/data_controller.js
var data_controller_default2 = data_controller_default;

// ../../../../../../node_modules/devextreme/esm/__internal/ui/m_drop_down_button.js
var DROP_DOWN_BUTTON_CONTENT = "dx-dropdownbutton-content";
var DropDownButton2 = ui_widget_default.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      itemTemplate: "item",
      keyExpr: "this",
      displayExpr: void 0,
      selectedItem: null,
      selectedItemKey: null,
      stylingMode: "outlined",
      deferRendering: true,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      useSelectMode: false,
      splitButton: false,
      showArrowIcon: true,
      template: null,
      text: "",
      type: "normal",
      icon: void 0,
      onButtonClick: null,
      onSelectionChanged: null,
      onItemClick: null,
      opened: false,
      items: null,
      dataSource: null,
      focusStateEnabled: true,
      hoverStateEnabled: true,
      dropDownOptions: {},
      dropDownContentTemplate: "content",
      wrapItemText: false,
      useItemTextAsTitle: true,
      grouped: false,
      groupTemplate: "group",
      buttonGroupOptions: {}
    });
  },
  _setOptionsByReference() {
    this.callBase();
    extend(this._optionsByReference, {
      selectedItem: true
    });
  },
  _init() {
    this.callBase();
    this._createItemClickAction();
    this._createActionClickAction();
    this._createSelectionChangedAction();
    this._initDataController();
    this._compileKeyGetter();
    this._compileDisplayGetter();
    this._options.cache("buttonGroupOptions", this.option("buttonGroupOptions"));
    this._options.cache("dropDownOptions", this.option("dropDownOptions"));
  },
  _initDataController() {
    const dataSource = this.option("dataSource");
    this._dataController = new data_controller_default2(dataSource ?? this.option("items"), {
      key: this.option("keyExpr")
    });
  },
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new FunctionTemplate((options2) => {
        const $popupContent = renderer_default(options2.container);
        const $listContainer = renderer_default("<div>").appendTo($popupContent);
        this._list = this._createComponent($listContainer, list_light_default, this._listOptions());
        this._list.registerKeyHandler("escape", this._escHandler.bind(this));
        this._list.registerKeyHandler("tab", this._escHandler.bind(this));
        this._list.registerKeyHandler("leftArrow", this._escHandler.bind(this));
        this._list.registerKeyHandler("rightArrow", this._escHandler.bind(this));
      })
    });
    this.callBase();
  },
  _compileKeyGetter() {
    this._keyGetter = compileGetter(this._dataController.key());
  },
  _compileDisplayGetter() {
    this._displayGetter = compileGetter(this.option("displayExpr"));
  },
  _initMarkup() {
    this.callBase();
    this.$element().addClass("dx-dropdownbutton");
    this._renderButtonGroup();
    this._updateArrowClass();
    if (isDefined(this.option("selectedItemKey"))) {
      this._loadSelectedItem().done(this._updateActionButton.bind(this));
    }
  },
  _renderFocusTarget: noop2,
  _render() {
    if (!this.option("deferRendering") || this.option("opened")) {
      this._renderPopup();
    }
    this.callBase();
  },
  _renderContentImpl() {
    if (this._popup) {
      this._renderPopupContent();
    }
    return this.callBase();
  },
  _loadSelectedItem() {
    var _this$_loadSingleDefe;
    null === (_this$_loadSingleDefe = this._loadSingleDeferred) || void 0 === _this$_loadSingleDefe || _this$_loadSingleDefe.reject();
    const d = Deferred();
    if (this._list && void 0 !== this._lastSelectedItemData) {
      const cachedResult = this.option("useSelectMode") ? this._list.option("selectedItem") : this._lastSelectedItemData;
      return d.resolve(cachedResult);
    }
    this._lastSelectedItemData = void 0;
    const selectedItemKey = this.option("selectedItemKey");
    this._dataController.loadSingle(selectedItemKey).done(d.resolve).fail(() => {
      d.reject(null);
    });
    this._loadSingleDeferred = d;
    return d.promise();
  },
  _createActionClickAction() {
    this._actionClickAction = this._createActionByOption("onButtonClick");
  },
  _createSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged");
  },
  _createItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  },
  _fireSelectionChangedAction(_ref) {
    let {
      previousValue,
      value: value2
    } = _ref;
    this._selectionChangedAction({
      item: value2,
      previousItem: previousValue
    });
  },
  _fireItemClickAction(_ref2) {
    let {
      event,
      itemElement,
      itemData
    } = _ref2;
    return this._itemClickAction({
      event,
      itemElement,
      itemData: this._actionItem || itemData
    });
  },
  _getButtonTemplate() {
    const {
      template,
      splitButton,
      showArrowIcon
    } = this.option();
    if (template) {
      return template;
    }
    return splitButton || !showArrowIcon ? "content" : (_ref3, buttonContent) => {
      let {
        text,
        icon
      } = _ref3;
      const $firstIcon = getImageContainer(icon);
      const $textContainer = text ? renderer_default("<span>").text(text).addClass("dx-button-text") : void 0;
      const $secondIcon = getImageContainer("spindown").addClass("dx-icon-right");
      renderer_default(buttonContent).append($firstIcon, $textContainer, $secondIcon);
    };
  },
  _getActionButtonConfig() {
    const {
      icon,
      text,
      type: type2,
      splitButton
    } = this.option();
    const actionButtonConfig = {
      text,
      icon,
      type: type2,
      template: this._getButtonTemplate(),
      elementAttr: {
        class: "dx-dropdownbutton-action"
      }
    };
    if (splitButton) {
      actionButtonConfig.elementAttr.role = "menuitem";
    }
    return actionButtonConfig;
  },
  _getSpinButtonConfig() {
    const {
      type: type2
    } = this.option();
    const config3 = {
      type: type2,
      icon: "spindown",
      elementAttr: {
        class: "dx-dropdownbutton-toggle",
        role: "menuitem"
      }
    };
    return config3;
  },
  _getButtonGroupItems() {
    const {
      splitButton
    } = this.option();
    const items = [this._getActionButtonConfig()];
    if (splitButton) {
      items.push(this._getSpinButtonConfig());
    }
    return items;
  },
  _buttonGroupItemClick(_ref4) {
    let {
      event,
      itemData
    } = _ref4;
    const isActionButton = "dx-dropdownbutton-action" === itemData.elementAttr.class;
    const isToggleButton = "dx-dropdownbutton-toggle" === itemData.elementAttr.class;
    if (isToggleButton) {
      this.toggle();
    } else if (isActionButton) {
      this._actionClickAction({
        event,
        selectedItem: this.option("selectedItem")
      });
      if (!this.option("splitButton")) {
        this.toggle();
      }
    }
  },
  _getButtonGroupOptions() {
    const {
      accessKey,
      focusStateEnabled,
      hoverStateEnabled,
      splitButton,
      stylingMode,
      tabIndex
    } = this.option();
    const buttonGroupOptions = extend({
      items: this._getButtonGroupItems(),
      width: "100%",
      height: "100%",
      selectionMode: "none",
      focusStateEnabled,
      hoverStateEnabled,
      stylingMode,
      accessKey,
      tabIndex,
      elementAttr: {
        role: splitButton ? "menu" : "group"
      },
      onItemClick: this._buttonGroupItemClick.bind(this),
      onKeyboardHandled: (e) => this._keyboardHandler(e)
    }, this._options.cache("buttonGroupOptions"));
    return buttonGroupOptions;
  },
  _renderPopupContent() {
    const $content = this._popup.$content();
    const template = this._getTemplateByOption("dropDownContentTemplate");
    $content.empty();
    this._popupContentId = `dx-${new guid_default()}`;
    this.setAria("id", this._popupContentId, $content);
    return template.render({
      container: getPublicElement($content),
      model: this.option("items") || this._dataController.getDataSource()
    });
  },
  _popupOptions() {
    const horizontalAlignment = this.option("rtlEnabled") ? "right" : "left";
    return extend({
      dragEnabled: false,
      focusStateEnabled: false,
      deferRendering: this.option("deferRendering"),
      hideOnOutsideClick: (e) => {
        const $element = this.$element();
        const $buttonClicked = renderer_default(e.target).closest(".dx-dropdownbutton");
        return !$buttonClicked.is($element);
      },
      showTitle: false,
      animation: {
        show: {
          type: "fade",
          duration: 0,
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          duration: 400,
          from: 1,
          to: 0
        }
      },
      _ignoreFunctionValueDeprecation: true,
      width: () => getElementWidth(this.$element()),
      height: "auto",
      shading: false,
      position: {
        of: this.$element(),
        collision: "flipfit",
        my: `${horizontalAlignment} top`,
        at: `${horizontalAlignment} bottom`
      },
      _wrapperClassExternal: "dx-dropdowneditor-overlay"
    }, this._options.cache("dropDownOptions"), {
      visible: this.option("opened")
    });
  },
  _listOptions() {
    const selectedItemKey = this.option("selectedItemKey");
    const useSelectMode = this.option("useSelectMode");
    return {
      selectionMode: useSelectMode ? "single" : "none",
      wrapItemText: this.option("wrapItemText"),
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      useItemTextAsTitle: this.option("useItemTextAsTitle"),
      onContentReady: () => this._fireContentReadyAction(),
      selectedItemKeys: isDefined(selectedItemKey) && useSelectMode ? [selectedItemKey] : [],
      grouped: this.option("grouped"),
      groupTemplate: this.option("groupTemplate"),
      keyExpr: this._dataController.key(),
      noDataText: this.option("noDataText"),
      displayExpr: this.option("displayExpr"),
      itemTemplate: this.option("itemTemplate"),
      items: this.option("items"),
      dataSource: this._dataController.getDataSource(),
      onItemClick: (e) => {
        if (!this.option("useSelectMode")) {
          this._lastSelectedItemData = e.itemData;
        }
        this.option("selectedItemKey", this._keyGetter(e.itemData));
        const actionResult = this._fireItemClickAction(e);
        if (false !== actionResult) {
          this.toggle(false);
          this._buttonGroup.focus();
        }
      }
    };
  },
  _upDownKeyHandler() {
    if (this._popup && this._popup.option("visible") && this._list) {
      this._list.focus();
    } else {
      this.open();
    }
    return true;
  },
  _escHandler() {
    this.close();
    this._buttonGroup.focus();
    return true;
  },
  _tabHandler() {
    this.close();
    return true;
  },
  _renderPopup() {
    const $popup = renderer_default("<div>");
    this.$element().append($popup);
    this._popup = this._createComponent($popup, ui_popup_default, this._popupOptions());
    this._popup.$content().addClass(DROP_DOWN_BUTTON_CONTENT);
    this._popup.$wrapper().addClass("dx-dropdownbutton-popup-wrapper");
    this._popup.$overlayContent().attr("aria-label", "Dropdown");
    this._popup.on("hiding", this._popupHidingHandler.bind(this));
    this._popup.on("showing", this._popupShowingHandler.bind(this));
    this._bindInnerWidgetOptions(this._popup, "dropDownOptions");
  },
  _popupHidingHandler() {
    this.option("opened", false);
    this._updateAriaAttributes(false);
  },
  _popupOptionChanged(args) {
    const options2 = ui_widget_default.getOptionsFromContainer(args);
    this._setPopupOption(options2);
    const optionsKeys = Object.keys(options2);
    if (optionsKeys.includes("width") || optionsKeys.includes("height")) {
      this._dimensionChanged();
    }
  },
  _dimensionChanged() {
    const popupWidth = getSizeValue(this.option("dropDownOptions.width"));
    if (void 0 === popupWidth) {
      this._setPopupOption("width", () => getElementWidth(this.$element()));
    }
  },
  _setPopupOption(optionName, value2) {
    this._setWidgetOption("_popup", arguments);
  },
  _popupShowingHandler() {
    this.option("opened", true);
    this._updateAriaAttributes(true);
  },
  _setElementAria(value2) {
    const elementAria = {
      owns: value2 ? this._popupContentId : void 0
    };
    this.setAria(elementAria, this.$element());
  },
  _setButtonsAria(value2) {
    const commonButtonAria = {
      expanded: value2,
      haspopup: "listbox"
    };
    const firstButtonAria = {};
    if (!this.option("text")) {
      firstButtonAria.label = "dropdownbutton";
    }
    this._getButtons().each((index2, $button) => {
      if (0 === index2) {
        this.setAria(_extends({}, firstButtonAria, commonButtonAria), renderer_default($button));
      } else {
        this.setAria(commonButtonAria, renderer_default($button));
      }
    });
  },
  _updateAriaAttributes(value2) {
    this._setElementAria(value2);
    this._setButtonsAria(value2);
  },
  _getButtons() {
    return this._buttonGroup.$element().find(".dx-button");
  },
  _renderButtonGroup() {
    const $buttonGroup = this._buttonGroup && this._buttonGroup.$element() || renderer_default("<div>");
    if (!this._buttonGroup) {
      this.$element().append($buttonGroup);
    }
    this._buttonGroup = this._createComponent($buttonGroup, button_group_default, this._getButtonGroupOptions());
    this._buttonGroup.registerKeyHandler("downArrow", this._upDownKeyHandler.bind(this));
    this._buttonGroup.registerKeyHandler("tab", this._tabHandler.bind(this));
    this._buttonGroup.registerKeyHandler("upArrow", this._upDownKeyHandler.bind(this));
    this._buttonGroup.registerKeyHandler("escape", this._escHandler.bind(this));
    this._bindInnerWidgetOptions(this._buttonGroup, "buttonGroupOptions");
    this._updateAriaAttributes(this.option("opened"));
  },
  _updateArrowClass() {
    const hasArrow = this.option("splitButton") || this.option("showArrowIcon");
    this.$element().toggleClass("dx-dropdownbutton-has-arrow", hasArrow);
  },
  toggle(visible2) {
    if (!this._popup) {
      this._renderPopup();
      this._renderContent();
    }
    return this._popup.toggle(visible2);
  },
  open() {
    return this.toggle(true);
  },
  close() {
    return this.toggle(false);
  },
  _setListOption(name2, value2) {
    this._list && this._list.option(name2, value2);
  },
  _getDisplayValue(item) {
    const isPrimitiveItem = !isObject(item);
    const displayValue = isPrimitiveItem ? item : this._displayGetter(item);
    return !isObject(displayValue) ? String(ensureDefined(displayValue, "")) : "";
  },
  _updateActionButton(selectedItem) {
    if (this.option("useSelectMode")) {
      this.option({
        text: this._getDisplayValue(selectedItem),
        icon: isPlainObject(selectedItem) ? selectedItem.icon : void 0
      });
    }
    this._setOptionWithoutOptionChange("selectedItem", selectedItem);
    this._setOptionWithoutOptionChange("selectedItemKey", this._keyGetter(selectedItem));
  },
  _clean() {
    this._list && this._list.$element().remove();
    this._popup && this._popup.$element().remove();
  },
  _selectedItemKeyChanged(value2) {
    this._setListOption("selectedItemKeys", this.option("useSelectMode") && isDefined(value2) ? [value2] : []);
    const previousItem = this.option("selectedItem");
    this._loadSelectedItem().always((selectedItem) => {
      this._updateActionButton(selectedItem);
      if (this._displayGetter(previousItem) !== this._displayGetter(selectedItem)) {
        this._fireSelectionChangedAction({
          previousValue: previousItem,
          value: selectedItem
        });
      }
    });
  },
  _updateButtonGroup(name2, value2) {
    this._buttonGroup.option(name2, value2);
    this._updateAriaAttributes(this.option("opened"));
  },
  _actionButtonOptionChanged(_ref5) {
    let {
      name: name2,
      value: value2
    } = _ref5;
    const newConfig = {};
    newConfig[name2] = value2;
    this._updateButtonGroup("items[0]", extend({}, this._getActionButtonConfig(), newConfig));
    this._popup && this._popup.repaint();
  },
  _selectModeChanged(value2) {
    if (value2) {
      this._setListOption("selectionMode", "single");
      const selectedItemKey = this.option("selectedItemKey");
      this._setListOption("selectedItemKeys", isDefined(selectedItemKey) ? [selectedItemKey] : []);
      this._selectedItemKeyChanged(this.option("selectedItemKey"));
    } else {
      this._setListOption("selectionMode", "none");
      this.option({
        selectedItemKey: void 0,
        selectedItem: void 0
      });
      this._actionButtonOptionChanged({
        text: this.option("text")
      });
    }
  },
  _updateItemCollection(optionName) {
    const selectedItemKey = this.option("selectedItemKey");
    this._setListOption("selectedItem", null);
    this._setWidgetOption("_list", [optionName]);
    if (isDefined(selectedItemKey)) {
      this._loadSelectedItem().done((selectedItem) => {
        this._setListOption("selectedItemKeys", [selectedItemKey]);
        this._setListOption("selectedItem", selectedItem);
      }).fail((error) => {
        this._setListOption("selectedItemKeys", []);
      }).always(this._updateActionButton.bind(this));
    }
  },
  _updateDataController(items) {
    this._dataController.updateDataSource(items, this.option("keyExpr"));
    this._updateKeyExpr();
  },
  _updateKeyExpr() {
    this._compileKeyGetter();
    this._setListOption("keyExpr", this._dataController.key());
  },
  focus() {
    this._buttonGroup.focus();
  },
  _optionChanged(args) {
    var _this$_popup;
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "useSelectMode":
        this._selectModeChanged(value2);
        break;
      case "splitButton":
        this._updateArrowClass();
        this._renderButtonGroup();
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._setListOption(name2, value2);
        this._updateActionButton(this.option("selectedItem"));
        break;
      case "keyExpr":
        this._updateDataController();
        break;
      case "buttonGroupOptions":
        this._innerWidgetOptionChanged(this._buttonGroup, args);
        break;
      case "dropDownOptions":
        if ("dropDownOptions.visible" === args.fullName) {
          break;
        }
        if (void 0 !== args.value.visible) {
          delete args.value.visible;
        }
        this._popupOptionChanged(args);
        this._innerWidgetOptionChanged(this._popup, args);
        break;
      case "opened":
        this.toggle(value2);
        break;
      case "focusStateEnabled":
      case "hoverStateEnabled":
        this._setListOption(name2, value2);
        this._updateButtonGroup(name2, value2);
        this.callBase(args);
        break;
      case "items":
        this._updateDataController(this.option("items"));
        this._updateItemCollection(name2);
        break;
      case "dataSource":
        this._dataController.updateDataSource(value2);
        this._updateKeyExpr();
        this._updateItemCollection(name2);
        break;
      case "icon":
      case "text":
        this._actionButtonOptionChanged(args);
        break;
      case "showArrowIcon":
        this._updateArrowClass();
        this._renderButtonGroup();
        this._popup && this._popup.repaint();
        break;
      case "width":
      case "height":
        this.callBase(args);
        null === (_this$_popup = this._popup) || void 0 === _this$_popup || _this$_popup.repaint();
        break;
      case "stylingMode":
      case "tabIndex":
        this._updateButtonGroup(name2, value2);
        break;
      case "type":
        this._updateButtonGroup("items", this._getButtonGroupItems());
        break;
      case "itemTemplate":
      case "grouped":
      case "noDataText":
      case "groupTemplate":
      case "wrapItemText":
      case "useItemTextAsTitle":
        this._setListOption(name2, value2);
        break;
      case "dropDownContentTemplate":
        this._renderContent();
        break;
      case "selectedItemKey":
        this._selectedItemKeyChanged(value2);
        break;
      case "selectedItem":
        break;
      case "onItemClick":
        this._createItemClickAction();
        break;
      case "onButtonClick":
        this._createActionClickAction();
        break;
      case "onSelectionChanged":
        this._createSelectionChangedAction();
        break;
      case "deferRendering":
        this.toggle(this.option("opened"));
        break;
      case "template":
        this._renderButtonGroup();
        break;
      default:
        this.callBase(args);
    }
  },
  getDataSource() {
    return this._dataController.getDataSource();
  }
});
component_registrator_default("dxDropDownButton", DropDownButton2);

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.utils.js
var TOOLBAR_ITEMS = ["dxAutocomplete", "dxButton", "dxCheckBox", "dxDateBox", "dxMenu", "dxSelectBox", "dxTabs", "dxTextBox", "dxButtonGroup", "dxDropDownButton"];
var getItemInstance = function($element) {
  const itemData = $element.data && $element.data();
  const dxComponents = itemData && itemData.dxComponents;
  const widgetName = dxComponents && dxComponents[0];
  return widgetName && itemData[widgetName];
};
function toggleItemFocusableElementTabIndex(context2, item) {
  var _itemData$options;
  if (!context2) {
    return;
  }
  const $item = context2._findItemElementByItem(item);
  if (!$item.length) {
    return;
  }
  const itemData = context2._getItemData($item);
  const isItemNotFocusable = !!(null !== (_itemData$options = itemData.options) && void 0 !== _itemData$options && _itemData$options.disabled || itemData.disabled || context2.option("disabled"));
  const {
    widget
  } = itemData;
  if (widget && TOOLBAR_ITEMS.includes(widget)) {
    const $widget = $item.find(widget.toLowerCase().replace("dx", ".dx-"));
    if ($widget.length) {
      var _itemInstance$_focusT, _itemData$options2;
      const itemInstance = getItemInstance($widget);
      if (!itemInstance) {
        return;
      }
      let $focusTarget = null === (_itemInstance$_focusT = itemInstance._focusTarget) || void 0 === _itemInstance$_focusT ? void 0 : _itemInstance$_focusT.call(itemInstance);
      if ("dxDropDownButton" === widget) {
        $focusTarget = $focusTarget && $focusTarget.find(".dx-buttongroup");
      } else {
        $focusTarget = $focusTarget ?? renderer_default(itemInstance.element());
      }
      const tabIndex = null === (_itemData$options2 = itemData.options) || void 0 === _itemData$options2 ? void 0 : _itemData$options2.tabIndex;
      if (isItemNotFocusable) {
        $focusTarget.attr("tabIndex", -1);
      } else {
        $focusTarget.attr("tabIndex", tabIndex ?? 0);
      }
    }
  }
}

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/strategy/m_toolbar.multiline.js
var MultiLineStrategy = class {
  constructor(toolbar) {
    this._toolbar = toolbar;
  }
  _initMarkup() {
  }
  _updateMenuVisibility() {
  }
  _renderMenuItems() {
  }
  _renderItem() {
  }
  _getMenuItems() {
  }
  _getToolbarItems() {
    return this._toolbar.option("items") ?? [];
  }
  _getItemsWidth() {
    return this._toolbar._getSummaryItemsSize("width", this._toolbar._itemElements(), true);
  }
  _arrangeItems() {
    const $label = this._toolbar._$toolbarItemsContainer.find(".dx-toolbar-label").eq(0);
    if (!$label.length) {
      return;
    }
    const elementWidth = getWidth(this._toolbar.$element());
    const labelPaddings = getOuterWidth($label) - getWidth($label);
    $label.css("maxWidth", elementWidth - labelPaddings);
  }
  _hideOverflowItems() {
  }
  _dimensionChanged() {
  }
  _itemOptionChanged() {
  }
  _optionChanged() {
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/internal/m_toolbar.menu.list.js
var ToolbarMenuList = class extends ListBase {
  _init() {
    super._init();
    this._activeStateUnit = ".dx-toolbar-menu-action:not(.dx-toolbar-hidden-button-group)";
  }
  _initMarkup() {
    this._renderSections();
    super._initMarkup();
    this._setMenuRole();
  }
  _getSections() {
    return this._itemContainer().children();
  }
  _itemElements() {
    return this._getSections().children(this._itemSelector());
  }
  _renderSections() {
    const $container = this._itemContainer();
    each(["before", "center", "after", "menu"], (_, section) => {
      const sectionName = `_$${section}Section`;
      if (!this[sectionName]) {
        this[sectionName] = renderer_default("<div>").addClass("dx-toolbar-menu-section");
      }
      this[sectionName].appendTo($container);
    });
  }
  _renderItems() {
    super._renderItems.apply(this, arguments);
    this._updateSections();
  }
  _setMenuRole() {
    const $menuContainer = this.$element().find(".dx-scrollview-content");
    $menuContainer.attr("role", "menu");
  }
  _updateSections() {
    const $sections = this.$element().find(".dx-toolbar-menu-section");
    $sections.removeClass("dx-toolbar-menu-last-section");
    $sections.not(":empty").eq(-1).addClass("dx-toolbar-menu-last-section");
  }
  _renderItem(index2, item, itemContainer, $after) {
    const location = item.location ?? "menu";
    const $container = this[`_$${location}Section`];
    const itemElement = super._renderItem(index2, item, $container, $after);
    if (this._getItemTemplateName({
      itemData: item
    })) {
      itemElement.addClass("dx-toolbar-menu-custom");
    }
    if ("menu" === location || "dxButton" === item.widget || "dxButtonGroup" === item.widget || item.isAction) {
      itemElement.addClass("dx-toolbar-menu-action");
    }
    if ("dxButton" === item.widget) {
      itemElement.addClass("dx-toolbar-hidden-button");
    }
    if ("dxButtonGroup" === item.widget) {
      itemElement.addClass("dx-toolbar-hidden-button-group");
    }
    itemElement.addClass(item.cssClass);
    return itemElement;
  }
  _getItemTemplateName(args) {
    const template = super._getItemTemplateName(args);
    const data2 = args.itemData;
    const menuTemplate = data2 && data2.menuItemTemplate;
    return menuTemplate || template;
  }
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _itemClickHandler(e, args, config3) {
    if (renderer_default(e.target).closest(".dx-toolbar-menu-action").length) {
      super._itemClickHandler(e, args, config3);
    }
  }
  _clean() {
    this._getSections().empty();
    super._clean();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/internal/m_toolbar.menu.js
var DropDownMenu = class extends widget_default {
  _supportedKeys() {
    var _this$_list;
    let extension = {};
    if (!this.option("opened") || !(null !== (_this$_list = this._list) && void 0 !== _this$_list && _this$_list.option("focusedElement"))) {
      extension = this._button._supportedKeys();
    }
    return extend(super._supportedKeys(), extension, {
      tab() {
        this._popup && this._popup.hide();
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      items: [],
      onItemClick: null,
      dataSource: null,
      itemTemplate: "item",
      onButtonClick: null,
      activeStateEnabled: true,
      hoverStateEnabled: true,
      opened: false,
      onItemRendered: null,
      closeOnClick: true,
      useInkRipple: false,
      container: void 0,
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          to: 0
        }
      }
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useInkRipple: true,
        animation: {
          show: {
            type: "pop",
            duration: 200,
            from: {
              scale: 0
            },
            to: {
              scale: 1
            }
          },
          hide: {
            type: "pop",
            duration: 200,
            from: {
              scale: 1
            },
            to: {
              scale: 0
            }
          }
        }
      }
    }]);
  }
  _init() {
    super._init();
    this.$element().addClass("dx-dropdownmenu");
    this._initItemClickAction();
    this._initButtonClickAction();
  }
  _initItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  }
  _initButtonClickAction() {
    this._buttonClickAction = this._createActionByOption("onButtonClick");
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new ChildDefaultTemplate("content")
    });
    super._initTemplates();
  }
  _initMarkup() {
    this._renderButton();
    super._initMarkup();
  }
  _render() {
    super._render();
    this.setAria({
      haspopup: true,
      expanded: this.option("opened")
    });
  }
  _renderContentImpl() {
    if (this.option("opened")) {
      this._renderPopup();
    }
  }
  _clean() {
    this._cleanFocusState();
    this._list && this._list.$element().remove();
    this._popup && this._popup.$element().remove();
    delete this._list;
    delete this._popup;
  }
  _renderButton() {
    const $button = this.$element().addClass("dx-dropdownmenu-button");
    this._button = this._createComponent($button, button_default, {
      icon: "overflow",
      template: "content",
      stylingMode: isFluent() ? "text" : "contained",
      useInkRipple: this.option("useInkRipple"),
      hoverStateEnabled: false,
      focusStateEnabled: false,
      onClick: (e) => {
        this.option("opened", !this.option("opened"));
        this._buttonClickAction(e);
      }
    });
  }
  _toggleActiveState($element, value2, e) {
    this._button._toggleActiveState($element, value2, e);
  }
  _toggleMenuVisibility(opened) {
    var _this$_popup, _this$_popup2;
    const state = opened ?? !(null !== (_this$_popup = this._popup) && void 0 !== _this$_popup && _this$_popup.option("visible"));
    if (opened) {
      this._renderPopup();
    }
    null === (_this$_popup2 = this._popup) || void 0 === _this$_popup2 || _this$_popup2.toggle(state);
    this.setAria("expanded", state);
  }
  _renderPopup() {
    if (this._$popup) {
      return;
    }
    this._$popup = renderer_default("<div>").appendTo(this.$element());
    const {
      rtlEnabled,
      container,
      animation: animation3
    } = this.option();
    this._popup = this._createComponent(this._$popup, "dxPopup", {
      onInitialized(_ref) {
        let {
          component
        } = _ref;
        component.$wrapper().addClass("dx-dropdownmenu-popup-wrapper").addClass("dx-dropdownmenu-popup");
      },
      deferRendering: false,
      preventScrollEvents: false,
      contentTemplate: (contentElement) => this._renderList(contentElement),
      _ignoreFunctionValueDeprecation: true,
      maxHeight: () => this._getMaxHeight(),
      position: {
        my: "top " + (rtlEnabled ? "left" : "right"),
        at: "bottom " + (rtlEnabled ? "left" : "right"),
        collision: "fit flip",
        offset: {
          v: 3
        },
        of: this.$element()
      },
      animation: animation3,
      onOptionChanged: (_ref2) => {
        let {
          name: name2,
          value: value2
        } = _ref2;
        if ("visible" === name2) {
          this.option("opened", value2);
        }
      },
      container,
      autoResizeEnabled: false,
      height: "auto",
      width: "auto",
      hideOnOutsideClick: (e) => this._closeOutsideDropDownHandler(e),
      hideOnParentScroll: true,
      shading: false,
      dragEnabled: false,
      showTitle: false,
      fullScreen: false,
      _fixWrapperPosition: true
    });
  }
  _getMaxHeight() {
    const $element = this.$element();
    const offsetTop = $element.offset().top;
    const windowHeight = getOuterHeight(getWindow());
    const maxHeight = Math.max(offsetTop, windowHeight - offsetTop - getOuterHeight($element));
    return Math.min(windowHeight, maxHeight - 3 - 10);
  }
  _closeOutsideDropDownHandler(e) {
    const isOutsideClick = !renderer_default(e.target).closest(this.$element()).length;
    return isOutsideClick;
  }
  _renderList(contentElement) {
    const $content = renderer_default(contentElement);
    $content.addClass("dx-dropdownmenu-list");
    this._list = this._createComponent($content, ToolbarMenuList, {
      dataSource: this._getListDataSource(),
      pageLoadMode: "scrollBottom",
      indicateLoading: false,
      noDataText: "",
      itemTemplate: this.option("itemTemplate"),
      onItemClick: (e) => {
        if (this.option("closeOnClick")) {
          this.option("opened", false);
        }
        this._itemClickAction(e);
      },
      tabIndex: -1,
      focusStateEnabled: false,
      activeStateEnabled: true,
      onItemRendered: this.option("onItemRendered"),
      _itemAttributes: {
        role: "menuitem"
      }
    });
  }
  _itemOptionChanged(item, property, value2) {
    var _this$_list2;
    null === (_this$_list2 = this._list) || void 0 === _this$_list2 || _this$_list2._itemOptionChanged(item, property, value2);
    toggleItemFocusableElementTabIndex(this._list, item);
  }
  _getListDataSource() {
    return this.option("dataSource") ?? this.option("items");
  }
  _setListDataSource() {
    var _this$_list3;
    null === (_this$_list3 = this._list) || void 0 === _this$_list3 || _this$_list3.option("dataSource", this._getListDataSource());
    delete this._deferRendering;
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat([this._list]);
  }
  _toggleVisibility(visible2) {
    var _this$_button;
    super._toggleVisibility(visible2);
    null === (_this$_button = this._button) || void 0 === _this$_button || _this$_button.option("visible", visible2);
  }
  _optionChanged(args) {
    var _this$_list4, _this$_list5, _this$_list6;
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "items":
      case "dataSource":
        if (!this.option("opened")) {
          this._deferRendering = true;
        } else {
          this._setListDataSource();
        }
        break;
      case "itemTemplate":
        null === (_this$_list4 = this._list) || void 0 === _this$_list4 || _this$_list4.option(name2, this._getTemplate(value2));
        break;
      case "onItemClick":
        this._initItemClickAction();
        break;
      case "onButtonClick":
        this._buttonClickAction();
        break;
      case "useInkRipple":
        this._invalidate();
        break;
      case "focusStateEnabled":
        null === (_this$_list5 = this._list) || void 0 === _this$_list5 || _this$_list5.option(name2, value2);
        super._optionChanged(args);
        break;
      case "onItemRendered":
        null === (_this$_list6 = this._list) || void 0 === _this$_list6 || _this$_list6.option(name2, value2);
        break;
      case "opened":
        if (this._deferRendering) {
          this._setListDataSource();
        }
        this._toggleMenuVisibility(value2);
        this._updateFocusableItemsTabIndex();
        break;
      case "closeOnClick":
        break;
      case "container":
        this._popup && this._popup.option(name2, value2);
        break;
      case "disabled":
        if (this._list) {
          this._updateFocusableItemsTabIndex();
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
  _updateFocusableItemsTabIndex() {
    this.option("items").forEach((item) => toggleItemFocusableElementTabIndex(this._list, item));
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/strategy/m_toolbar.singleline.js
var TOOLBAR_HIDDEN_ITEM = "dx-toolbar-item-invisible";
var SingleLineStrategy = class {
  constructor(toolbar) {
    this._toolbar = toolbar;
  }
  _initMarkup() {
    deferRender(() => {
      this._renderOverflowMenu();
      this._renderMenuItems();
    });
  }
  _renderOverflowMenu() {
    if (!this._hasVisibleMenuItems()) {
      return;
    }
    this._renderMenuButtonContainer();
    const $menu = renderer_default("<div>").appendTo(this._overflowMenuContainer());
    const itemClickAction = this._toolbar._createActionByOption("onItemClick");
    const menuItemTemplate = this._toolbar._getTemplateByOption("menuItemTemplate");
    this._menu = this._toolbar._createComponent($menu, DropDownMenu, {
      disabled: this._toolbar.option("disabled"),
      itemTemplate: () => menuItemTemplate,
      onItemClick: (e) => {
        itemClickAction(e);
      },
      container: this._toolbar.option("menuContainer"),
      onOptionChanged: (_ref) => {
        let {
          name: name2,
          value: value2
        } = _ref;
        if ("opened" === name2) {
          this._toolbar.option("overflowMenuVisible", value2);
        }
        if ("items" === name2) {
          this._updateMenuVisibility(value2);
        }
      }
    });
  }
  renderMenuItems() {
    if (!this._menu) {
      this._renderOverflowMenu();
    }
    this._menu && this._menu.option("items", this._getMenuItems());
    if (this._menu && !this._menu.option("items").length) {
      this._menu.option("opened", false);
    }
  }
  _renderMenuButtonContainer() {
    this._$overflowMenuContainer = renderer_default("<div>").appendTo(this._toolbar._$afterSection).addClass("dx-toolbar-button").addClass("dx-toolbar-menu-container");
  }
  _overflowMenuContainer() {
    return this._$overflowMenuContainer;
  }
  _updateMenuVisibility(menuItems) {
    const items = menuItems ?? this._getMenuItems();
    const isMenuVisible = items.length && this._hasVisibleMenuItems(items);
    this._toggleMenuVisibility(isMenuVisible);
  }
  _toggleMenuVisibility(value2) {
    if (!this._overflowMenuContainer()) {
      return;
    }
    this._overflowMenuContainer().toggleClass("dx-state-invisible", !value2);
  }
  _renderMenuItems() {
    deferRender(() => {
      this.renderMenuItems();
    });
  }
  _dimensionChanged() {
    this.renderMenuItems();
  }
  _getToolbarItems() {
    return grep(this._toolbar.option("items") ?? [], (item) => !this._toolbar._isMenuItem(item));
  }
  _getHiddenItems() {
    return this._toolbar._itemContainer().children(`.dx-toolbar-item-auto-hide.${TOOLBAR_HIDDEN_ITEM}`).not(".dx-state-invisible");
  }
  _getMenuItems() {
    const menuItems = grep(this._toolbar.option("items") ?? [], (item) => this._toolbar._isMenuItem(item));
    const $hiddenItems = this._getHiddenItems();
    this._restoreItems = this._restoreItems ?? [];
    const overflowItems = [].slice.call($hiddenItems).map((hiddenItem) => {
      const itemData = this._toolbar._getItemData(hiddenItem);
      const $itemContainer = renderer_default(hiddenItem);
      const $itemMarkup = $itemContainer.children();
      return extend({
        menuItemTemplate: () => {
          this._restoreItems.push({
            container: $itemContainer,
            item: $itemMarkup
          });
          const $container = renderer_default("<div>").addClass("dx-toolbar-item-auto-hide");
          return $container.append($itemMarkup);
        }
      }, itemData);
    });
    return [...overflowItems, ...menuItems];
  }
  _hasVisibleMenuItems(items) {
    const menuItems = items ?? this._toolbar.option("items");
    let result2 = false;
    const optionGetter = compileGetter("visible");
    const overflowGetter = compileGetter("locateInMenu");
    each(menuItems, (index2, item) => {
      const itemVisible = optionGetter(item, {
        functionsAsIs: true
      });
      const itemOverflow = overflowGetter(item, {
        functionsAsIs: true
      });
      if (false !== itemVisible && ("auto" === itemOverflow || "always" === itemOverflow) || "menu" === item.location) {
        result2 = true;
      }
    });
    return result2;
  }
  _arrangeItems() {
    this._toolbar._$centerSection.css({
      margin: "0 auto",
      float: "none"
    });
    each(this._restoreItems ?? [], (_, obj) => {
      renderer_default(obj.container).append(obj.item);
    });
    this._restoreItems = [];
    const elementWidth = getWidth(this._toolbar.$element());
    this._hideOverflowItems(elementWidth);
    return elementWidth;
  }
  _hideOverflowItems(width) {
    const overflowItems = this._toolbar.$element().find(".dx-toolbar-item-auto-hide");
    if (!overflowItems.length) {
      return;
    }
    const elementWidth = width ?? getWidth(this._toolbar.$element());
    renderer_default(overflowItems).removeClass(TOOLBAR_HIDDEN_ITEM);
    let itemsWidth = this._getItemsWidth();
    while (overflowItems.length && elementWidth < itemsWidth) {
      const $item = overflowItems.eq(-1);
      $item.addClass(TOOLBAR_HIDDEN_ITEM);
      itemsWidth = this._getItemsWidth();
      overflowItems.splice(-1, 1);
    }
  }
  _getItemsWidth() {
    return this._toolbar._getSummaryItemsSize("width", [this._toolbar._$beforeSection, this._toolbar._$centerSection, this._toolbar._$afterSection]);
  }
  _itemOptionChanged(item, property, value2) {
    if ("disabled" === property || "options.disabled" === property) {
      if (this._toolbar._isMenuItem(item)) {
        var _this$_menu;
        null === (_this$_menu = this._menu) || void 0 === _this$_menu || _this$_menu._itemOptionChanged(item, property, value2);
        return;
      }
    }
    this.renderMenuItems();
  }
  _renderItem(item, itemElement) {
    if ("auto" === item.locateInMenu) {
      itemElement.addClass("dx-toolbar-item-auto-hide");
    }
  }
  _optionChanged(name2, value2) {
    var _this$_menu2, _this$_menu3, _this$_menu4, _this$_menu5, _this$_menu6;
    switch (name2) {
      case "disabled":
        null === (_this$_menu2 = this._menu) || void 0 === _this$_menu2 || _this$_menu2.option(name2, value2);
        break;
      case "overflowMenuVisible":
        null === (_this$_menu3 = this._menu) || void 0 === _this$_menu3 || _this$_menu3.option("opened", value2);
        break;
      case "onItemClick":
        null === (_this$_menu4 = this._menu) || void 0 === _this$_menu4 || _this$_menu4.option(name2, value2);
        break;
      case "menuContainer":
        null === (_this$_menu5 = this._menu) || void 0 === _this$_menu5 || _this$_menu5.option("container", value2);
        break;
      case "menuItemTemplate":
        null === (_this$_menu6 = this._menu) || void 0 === _this$_menu6 || _this$_menu6.option("itemTemplate", value2);
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.js
var Toolbar = class extends m_toolbar_base_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      menuItemTemplate: "menuItem",
      menuContainer: void 0,
      overflowMenuVisible: false,
      multiline: false
    });
  }
  _isMultiline() {
    return this.option("multiline");
  }
  _dimensionChanged(dimension) {
    if ("height" === dimension) {
      return;
    }
    super._dimensionChanged();
    this._layoutStrategy._dimensionChanged();
  }
  _initMarkup() {
    super._initMarkup();
    this._updateFocusableItemsTabIndex();
    this._layoutStrategy._initMarkup();
  }
  _renderToolbar() {
    super._renderToolbar();
    this._renderLayoutStrategy();
  }
  _itemContainer() {
    if (this._isMultiline()) {
      return this._$toolbarItemsContainer;
    }
    return super._itemContainer();
  }
  _renderLayoutStrategy() {
    this.$element().toggleClass("dx-toolbar-multiline", this._isMultiline());
    this._layoutStrategy = this._isMultiline() ? new MultiLineStrategy(this) : new SingleLineStrategy(this);
  }
  _renderSections() {
    if (this._isMultiline()) {
      return;
    }
    return super._renderSections();
  }
  _postProcessRenderItems() {
    this._layoutStrategy._hideOverflowItems();
    this._layoutStrategy._updateMenuVisibility();
    super._postProcessRenderItems();
    this._layoutStrategy._renderMenuItems();
  }
  _renderItem(index2, item, itemContainer, $after) {
    const itemElement = super._renderItem(index2, item, itemContainer, $after);
    this._layoutStrategy._renderItem(item, itemElement);
    const {
      widget,
      showText
    } = item;
    if ("dxButton" === widget && "inMenu" === showText) {
      itemElement.toggleClass("dx-toolbar-text-auto-hide");
    }
    return itemElement;
  }
  _getItemsWidth() {
    return this._layoutStrategy._getItemsWidth();
  }
  _getMenuItems() {
    return this._layoutStrategy._getMenuItems();
  }
  _getToolbarItems() {
    return this._layoutStrategy._getToolbarItems();
  }
  _arrangeItems() {
    if (this.$element().is(":hidden")) {
      return;
    }
    const elementWidth = this._layoutStrategy._arrangeItems();
    if (!this._isMultiline()) {
      super._arrangeItems(elementWidth);
    }
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    if (!this._isMenuItem(item)) {
      super._itemOptionChanged(item, property, value2, prevValue);
    }
    this._layoutStrategy._itemOptionChanged(item, property, value2);
    if ("disabled" === property || "options.disabled" === property) {
      toggleItemFocusableElementTabIndex(this, item);
    }
    if ("location" === property) {
      this.repaint();
    }
  }
  _updateFocusableItemsTabIndex() {
    this._getToolbarItems().forEach((item) => toggleItemFocusableElementTabIndex(this, item));
  }
  _isMenuItem(itemData) {
    return "menu" === itemData.location || "always" === itemData.locateInMenu;
  }
  _isToolbarItem(itemData) {
    return void 0 === itemData.location || "never" === itemData.locateInMenu;
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    this._layoutStrategy._optionChanged(name2, value2);
    switch (name2) {
      case "menuContainer":
      case "menuItemTemplate":
      case "overflowMenuVisible":
        break;
      case "multiline":
        this._invalidate();
        break;
      case "disabled":
        super._optionChanged(args);
        this._updateFocusableItemsTabIndex();
        break;
      default:
        super._optionChanged(args);
    }
  }
  updateDimensions() {
    this._dimensionChanged();
  }
};
component_registrator_default("dxToolbar", Toolbar);
var m_toolbar_default = Toolbar;

// ../../../../../../node_modules/devextreme/esm/ui/toolbar/ui.toolbar.js
var ui_toolbar_default = m_toolbar_default;

// ../../../../../../node_modules/devextreme/esm/ui/toolbar.js
var toolbar_default = ui_toolbar_default;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/header/m_calendar.js
var CALENDAR_CLASS = "dx-scheduler-navigator-calendar";
var CALENDAR_POPOVER_CLASS = "dx-scheduler-navigator-calendar-popover";
var SchedulerCalendar = class extends ui_widget_default {
  show(target) {
    if (!this._isMobileLayout()) {
      this._overlay.option("target", target);
    }
    this._overlay.show();
  }
  hide() {
    this._overlay.hide();
  }
  _keyboardHandler(opts) {
    var _this$_calendar;
    null === (_this$_calendar = this._calendar) || void 0 === _this$_calendar || _this$_calendar._keyboardHandler(opts);
  }
  _init() {
    super._init();
    this.$element();
  }
  _render() {
    super._render();
    this._renderOverlay();
  }
  _renderOverlay() {
    this.$element().addClass(CALENDAR_POPOVER_CLASS);
    const isMobileLayout = this._isMobileLayout();
    const overlayType = isMobileLayout ? ui_popup_default : ui_popover_default;
    this._overlay = this._createComponent(this.$element(), overlayType, {
      contentTemplate: () => this._createOverlayContent(),
      onShown: () => this._calendar.focus(),
      defaultOptionsRules: [{
        device: () => isMobileLayout,
        options: {
          fullScreen: true,
          showCloseButton: false,
          toolbarItems: [{
            shortcut: "cancel"
          }],
          _ignorePreventScrollEventsDeprecation: true,
          preventScrollEvents: false,
          enableBodyScroll: false
        }
      }]
    });
  }
  _createOverlayContent() {
    const result2 = renderer_default("<div>").addClass(CALENDAR_CLASS);
    this._calendar = this._createComponent(result2, calendar_default, this._getCalendarOptions());
    if (this._isMobileLayout()) {
      const scrollable = this._createScrollable(result2);
      return scrollable.$element();
    }
    return result2;
  }
  _createScrollable(content) {
    const result2 = this._createComponent("<div>", ui_scrollable_default, {
      height: "auto",
      direction: "both"
    });
    result2.$content().append(content);
    return result2;
  }
  _optionChanged(_ref) {
    var _this$_calendar2;
    let {
      name: name2,
      value: value2
    } = _ref;
    if ("value" === name2) {
      null === (_this$_calendar2 = this._calendar) || void 0 === _this$_calendar2 || _this$_calendar2.option("value", value2);
    }
  }
  _getCalendarOptions() {
    return {
      value: this.option("value"),
      min: this.option("min"),
      max: this.option("max"),
      firstDayOfWeek: this.option("firstDayOfWeek"),
      focusStateEnabled: this.option("focusStateEnabled"),
      onValueChanged: this.option("onValueChanged"),
      skipFocusCheck: true,
      tabIndex: this.option("tabIndex")
    };
  }
  _isMobileLayout() {
    return !devices_default.current().generic;
  }
};
component_registrator_default("dxSchedulerCalendarPopup", SchedulerCalendar);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/header/m_date_navigator.js
var {
  trimTime: trimTime2
} = date_default;
var DATE_NAVIGATOR_CLASS = "dx-scheduler-navigator";
var PREVIOUS_BUTTON_CLASS = "dx-scheduler-navigator-previous";
var CALENDAR_BUTTON_CLASS = "dx-scheduler-navigator-caption";
var NEXT_BUTTON_CLASS = "dx-scheduler-navigator-next";
var getDateNavigator = (header, item) => {
  const items = [getPreviousButtonOptions(header), getCalendarButtonOptions(header), getNextButtonOptions(header)];
  const stylingMode = isMaterialBased() ? "text" : "contained";
  return _extends({
    widget: "dxButtonGroup",
    cssClass: DATE_NAVIGATOR_CLASS,
    options: {
      items,
      stylingMode,
      selectionMode: "none",
      onItemClick: (e) => {
        e.itemData.clickHandler(e);
      }
    }
  }, item);
};
var getPreviousButtonOptions = (header) => ({
  key: "previous",
  icon: "chevronprev",
  elementAttr: {
    class: PREVIOUS_BUTTON_CLASS
  },
  clickHandler: () => header._updateDateByDirection(-1),
  onContentReady: (e) => {
    const previousButton = e.component;
    previousButton.option("disabled", isPreviousButtonDisabled(header));
    header._addEvent("min", () => {
      previousButton.option("disabled", isPreviousButtonDisabled(header));
    });
    header._addEvent("currentDate", () => {
      previousButton.option("disabled", isPreviousButtonDisabled(header));
    });
    header._addEvent("startViewDate", () => {
      previousButton.option("disabled", isPreviousButtonDisabled(header));
    });
  }
});
var getCalendarButtonOptions = (header) => ({
  key: "calendar",
  text: header.captionText,
  elementAttr: {
    class: CALENDAR_BUTTON_CLASS
  },
  clickHandler: (e) => header._showCalendar(e),
  onContentReady: (e) => {
    const calendarButton = e.component;
    header._addEvent("currentView", () => {
      calendarButton.option("text", header.captionText);
    });
    header._addEvent("currentDate", () => {
      calendarButton.option("text", header.captionText);
    });
    header._addEvent("startViewDate", () => {
      calendarButton.option("text", header.captionText);
    });
    header._addEvent("views", () => {
      calendarButton.option("text", header.captionText);
    });
    header._addEvent("firstDayOfWeek", () => {
      calendarButton.option("text", header.captionText);
    });
  }
});
var getNextButtonOptions = (header) => ({
  key: "next",
  icon: "chevronnext",
  elementAttr: {
    class: NEXT_BUTTON_CLASS
  },
  clickHandler: () => header._updateDateByDirection(1),
  onContentReady: (e) => {
    const nextButton = e.component;
    nextButton.option("disabled", isNextButtonDisabled(header));
    header._addEvent("min", () => {
      nextButton.option("disabled", isNextButtonDisabled(header));
    });
    header._addEvent("currentDate", () => {
      nextButton.option("disabled", isNextButtonDisabled(header));
    });
    header._addEvent("startViewDate", () => {
      nextButton.option("disabled", isNextButtonDisabled(header));
    });
  }
});
var isPreviousButtonDisabled = (header) => {
  let min = header.option("min");
  if (!min) {
    return false;
  }
  min = new Date(min);
  const caption = header._getCaption();
  min = trimTime2(min);
  const previousDate = header._getNextDate(-1, caption.endDate);
  return previousDate < min;
};
var isNextButtonDisabled = (header) => {
  let max = header.option("max");
  if (!max) {
    return false;
  }
  max = new Date(max);
  const caption = header._getCaption();
  max = max.setHours(23, 59, 59);
  const nextDate = header._getNextDate(1, caption.startDate);
  return nextDate > max;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/header/m_utils.js
var {
  correctDateWithUnitBeginning: getPeriodStart,
  getFirstWeekDate: getWeekStart,
  getLastMonthDay: getLastMonthDay2,
  addDateInterval: addDateInterval2
} = date_default;
var {
  format: formatDate
} = date_default3;
var MS_DURATION = {
  milliseconds: 1
};
var DAY_DURATION = {
  days: 1
};
var WEEK_DURATION = {
  days: 7
};
var subMS = (date) => addDateInterval2(date, MS_DURATION, -1);
var addMS = (date) => addDateInterval2(date, MS_DURATION, 1);
var nextDay = (date) => addDateInterval2(date, DAY_DURATION, 1);
var nextWeek = (date) => addDateInterval2(date, WEEK_DURATION, 1);
var nextMonth = (date) => {
  const days3 = getLastMonthDay2(date);
  return addDateInterval2(date, {
    days: days3
  }, 1);
};
var isWeekend = (date) => 6 === date.getDay() || 0 === date.getDay();
var getWorkWeekStart = (firstDayOfWeek) => {
  let date = new Date(firstDayOfWeek);
  while (isWeekend(date)) {
    date = nextDay(date);
  }
  return date;
};
var getDateAfterWorkWeek = (workWeekStart) => {
  let date = new Date(workWeekStart);
  let workDaysCount = 0;
  while (workDaysCount < 5) {
    if (!isWeekend(date)) {
      workDaysCount++;
    }
    date = nextDay(date);
  }
  return date;
};
var nextAgendaStart = (date, agendaDuration) => addDateInterval2(date, {
  days: agendaDuration
}, 1);
var getInterval = (options2) => {
  const startDate = getIntervalStartDate(options2);
  const endDate = getIntervalEndDate(startDate, options2);
  return {
    startDate,
    endDate
  };
};
var getIntervalStartDate = (options2) => {
  const {
    date,
    step,
    firstDayOfWeek
  } = options2;
  switch (step) {
    case "day":
    case "week":
    case "month":
      return getPeriodStart(date, step, false, firstDayOfWeek);
    case "workWeek":
      const firstWeekDay = getWeekStart(date, firstDayOfWeek);
      return getWorkWeekStart(firstWeekDay);
    case "agenda":
      return new Date(date);
  }
};
var getIntervalEndDate = (startDate, options2) => {
  const {
    intervalCount,
    step,
    agendaDuration
  } = options2;
  let periodStartDate;
  let periodEndDate;
  let nextPeriodStartDate = new Date(startDate);
  for (let i = 0; i < intervalCount; i++) {
    periodStartDate = nextPeriodStartDate;
    periodEndDate = getPeriodEndDate(periodStartDate, step, agendaDuration);
    nextPeriodStartDate = getNextPeriodStartDate(periodEndDate, step);
  }
  return periodEndDate;
};
var getPeriodEndDate = (currentPeriodStartDate, step, agendaDuration) => {
  let date;
  switch (step) {
    case "day":
      date = nextDay(currentPeriodStartDate);
      break;
    case "week":
      date = nextWeek(currentPeriodStartDate);
      break;
    case "month":
      date = nextMonth(currentPeriodStartDate);
      break;
    case "workWeek":
      date = getDateAfterWorkWeek(currentPeriodStartDate);
      break;
    case "agenda":
      date = nextAgendaStart(currentPeriodStartDate, agendaDuration);
  }
  return subMS(date);
};
var getNextPeriodStartDate = (currentPeriodEndDate, step) => {
  let date = addMS(currentPeriodEndDate);
  if ("workWeek" === step) {
    while (isWeekend(date)) {
      date = nextDay(date);
    }
  }
  return date;
};
var getNextIntervalDate = (options2, direction) => {
  const {
    date,
    step,
    intervalCount,
    agendaDuration
  } = options2;
  let dayDuration;
  switch (step) {
    case "day":
      dayDuration = 1 * intervalCount;
      break;
    case "week":
    case "workWeek":
      dayDuration = 7 * intervalCount;
      break;
    case "agenda":
      dayDuration = agendaDuration;
      break;
    case "month":
      return getNextMonthDate(date, intervalCount, direction);
  }
  return addDateInterval2(date, {
    days: dayDuration
  }, direction);
};
var getNextMonthDate = (date, intervalCount, direction) => {
  const currentDate = date.getDate();
  const currentMonthFirstDate = new Date(new Date(date.getTime()).setDate(1));
  const thatMonthFirstDate = new Date(currentMonthFirstDate.setMonth(currentMonthFirstDate.getMonth() + intervalCount * direction));
  const thatMonthDuration = getLastMonthDay2(thatMonthFirstDate);
  const minDate = currentDate < thatMonthDuration ? currentDate : thatMonthDuration;
  const currentMonthMinDate = new Date(new Date(date.getTime()).setDate(minDate));
  const thatMonthMinDate = new Date(currentMonthMinDate.setMonth(currentMonthMinDate.getMonth() + intervalCount * direction));
  return thatMonthMinDate;
};
var getDateMonthFormatter = (isShort) => {
  const monthType = isShort ? "abbreviated" : "wide";
  const months = date_default3.getMonthNames(monthType);
  return (date) => {
    const day = formatDate(date, "day");
    const month = months[date.getMonth()];
    return `${day} ${month}`;
  };
};
var formatMonthYear = (date) => {
  const months = date_default3.getMonthNames("abbreviated");
  const month = months[date.getMonth()];
  const year = formatDate(date, "year");
  return `${month} ${year}`;
};
var getDateMonthYearFormatter = (isShort) => (date) => {
  const dateMonthFormat = getDateMonthFormatter(isShort);
  const dateMonth = dateMonthFormat(date);
  const year = formatDate(date, "year");
  return `${dateMonth} ${year}`;
};
var getDifferentYearCaption = (startDate, endDate) => {
  const firstDateText = formatDate(startDate, getDateMonthYearFormatter(true));
  const lastDateDateText = formatDate(endDate, getDateMonthYearFormatter(true));
  return `${firstDateText}-${lastDateDateText}`;
};
var getSameYearCaption = (startDate, endDate, isShort) => {
  const isDifferentMonthDates = startDate.getMonth() !== endDate.getMonth();
  const useShortFormat = isDifferentMonthDates || isShort;
  const firstDateFormat = isDifferentMonthDates ? getDateMonthFormatter(useShortFormat) : "d";
  const firstDateText = formatDate(startDate, firstDateFormat);
  const lastDateText = formatDate(endDate, getDateMonthYearFormatter(useShortFormat));
  return `${firstDateText}-${lastDateText}`;
};
var getSameDateCaption = (date, step, isShort) => {
  const useShortFormat = "agenda" === step ? isShort : false;
  const dateMonthFormat = getDateMonthFormatter(useShortFormat);
  const dateMonth = dateMonthFormat(date);
  const year = formatDate(date, "year");
  return `${dateMonth} ${year}`;
};
var formatCaptionByMonths = (startDate, endDate, isShort) => {
  const isDifferentYears = startDate.getFullYear() !== endDate.getFullYear();
  if (isDifferentYears) {
    return getDifferentYearCaption(startDate, endDate);
  }
  return getSameYearCaption(startDate, endDate, isShort);
};
var formatMonthViewCaption = (startDate, endDate) => {
  if (date_default.sameMonth(startDate, endDate)) {
    return formatDate(startDate, "monthandyear");
  }
  const isSameYear = date_default.sameYear(startDate, endDate);
  const firstDateText = isSameYear ? date_default3.getMonthNames("abbreviated")[startDate.getMonth()] : formatMonthYear(startDate);
  const lastDateText = formatMonthYear(endDate);
  return `${firstDateText}-${lastDateText}`;
};
var getCaptionText = (startDate, endDate, isShort, step) => {
  if (date_default.sameDate(startDate, endDate)) {
    return getSameDateCaption(startDate, step, isShort);
  }
  if ("month" === step) {
    return formatMonthViewCaption(startDate, endDate);
  }
  return formatCaptionByMonths(startDate, endDate, isShort);
};
var getCaption = (options2, isShort, customizationFunction) => {
  const {
    startDate,
    endDate
  } = getInterval(options2);
  let text = getCaptionText(startDate, endDate, isShort, options2.step);
  if (isFunction(customizationFunction)) {
    text = customizationFunction({
      startDate,
      endDate,
      text
    });
  }
  return {
    startDate,
    endDate,
    text
  };
};
var STEP_MAP = {
  day: "day",
  week: "week",
  workWeek: "workWeek",
  month: "month",
  timelineDay: "day",
  timelineWeek: "week",
  timelineWorkWeek: "workWeek",
  timelineMonth: "month",
  agenda: "agenda"
};
var getStep = (view) => STEP_MAP[getViewType(view)];
var getViewType = (view) => {
  if (isObject(view) && view.type) {
    return view.type;
  }
  return view;
};
var getViewName = (view) => {
  if (isObject(view)) {
    return view.name ? view.name : view.type;
  }
  return view;
};
var getViewText = (view) => {
  if (view.name) {
    return view.name;
  }
  const viewName = camelize(view.type || view, true);
  return message_default.format(`dxScheduler-switcher${viewName}`);
};
var isValidView = (view) => Object.values(VIEWS).includes(view);
var validateViews = (views) => {
  views.forEach((view) => {
    const viewType = getViewType(view);
    if (!isValidView(viewType)) {
      errors_default.log("W0008", viewType);
    }
  });
};
var formatViews = (views) => {
  validateViews(views);
  return views.map((view) => {
    const text = getViewText(view);
    const type2 = getViewType(view);
    const name2 = getViewName(view);
    return {
      text,
      name: name2,
      view: {
        text,
        type: type2,
        name: name2
      }
    };
  });
};
var isOneView = (views, selectedView) => 1 === views.length && views[0].name === selectedView;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/header/m_view_switcher.js
var VIEW_SWITCHER_CLASS = "dx-scheduler-view-switcher";
var VIEW_SWITCHER_DROP_DOWN_BUTTON_CLASS = "dx-scheduler-view-switcher-dropdown-button";
var VIEW_SWITCHER_DROP_DOWN_BUTTON_CONTENT_CLASS = "dx-scheduler-view-switcher-dropdown-button-content";
var getViewsAndSelectedView = (header) => {
  const views = formatViews(header.views);
  let selectedView = getViewName(header.currentView);
  const isSelectedViewInViews = views.some((view) => view.name === selectedView);
  selectedView = isSelectedViewInViews ? selectedView : void 0;
  return {
    selectedView,
    views
  };
};
var getViewSwitcher = (header, item) => {
  const {
    selectedView,
    views
  } = getViewsAndSelectedView(header);
  const stylingMode = isFluent() ? "outlined" : "contained";
  return _extends({
    widget: "dxButtonGroup",
    locateInMenu: "auto",
    cssClass: VIEW_SWITCHER_CLASS,
    options: {
      items: views,
      keyExpr: "name",
      selectedItemKeys: [selectedView],
      stylingMode,
      onItemClick: (e) => {
        const {
          view
        } = e.itemData;
        header._updateCurrentView(view);
      },
      onContentReady: (e) => {
        const viewSwitcher = e.component;
        header._addEvent("currentView", (view) => {
          viewSwitcher.option("selectedItemKeys", [getViewName(view)]);
        });
      }
    }
  }, item);
};
var getDropDownViewSwitcher = (header, item) => {
  const {
    selectedView,
    views
  } = getViewsAndSelectedView(header);
  const oneView = isOneView(views, selectedView);
  return _extends({
    widget: "dxDropDownButton",
    locateInMenu: "never",
    cssClass: VIEW_SWITCHER_CLASS,
    options: {
      items: views,
      useSelectMode: true,
      keyExpr: "name",
      selectedItemKey: selectedView,
      displayExpr: "text",
      showArrowIcon: !oneView,
      elementAttr: {
        class: VIEW_SWITCHER_DROP_DOWN_BUTTON_CLASS
      },
      onItemClick: (e) => {
        const {
          view
        } = e.itemData;
        header._updateCurrentView(view);
      },
      onContentReady: (e) => {
        const viewSwitcher = e.component;
        header._addEvent("currentView", (view) => {
          const views2 = formatViews(header.views);
          if (isOneView(views2, view)) {
            header.repaint();
          }
          viewSwitcher.option("selectedItemKey", getViewName(view));
        });
      },
      dropDownOptions: {
        onShowing: (e) => {
          if (oneView) {
            e.cancel = true;
          }
        },
        width: "max-content",
        _wrapperClassExternal: VIEW_SWITCHER_DROP_DOWN_BUTTON_CONTENT_CLASS
      }
    }
  }, item);
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/header/m_header.js
var DEFAULT_ELEMENT = "defaultElement";
var VIEW_SWITCHER = "viewSwitcher";
var DATE_NAVIGATOR = "dateNavigator";
var COMPONENT_CLASS2 = "dx-scheduler-header";
var SchedulerHeader = class extends ui_widget_default {
  get views() {
    return this.option("views");
  }
  get captionText() {
    return this._getCaption().text;
  }
  get intervalOptions() {
    const step = getStep(this.currentView);
    const intervalCount = this.option("intervalCount");
    const firstDayOfWeek = this.option("firstDayOfWeek");
    const agendaDuration = this.option("agendaDuration");
    return {
      step,
      intervalCount,
      firstDayOfWeek,
      agendaDuration
    };
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      _useShortDateFormat: !devices_default.real().generic || devices_default.isSimulator()
    });
  }
  _createEventMap() {
    this.eventMap = /* @__PURE__ */ new Map([
      ["currentView", [(view) => {
        this.currentView = viewsUtils.getCurrentView(getViewName(view), this.option("views"));
      }]],
      ["items", [this.repaint.bind(this)]],
      ["views", [validateViews]],
      ["currentDate", [this._getCalendarOptionUpdater("value")]],
      ["min", [this._getCalendarOptionUpdater("min")]],
      ["max", [this._getCalendarOptionUpdater("max")]],
      ["tabIndex", [this.repaint.bind(this)]],
      ["focusStateEnabled", [this.repaint.bind(this)]],
      ["useDropDownViewSwitcher", [this.repaint.bind(this)]]
    ]);
  }
  _addEvent(name2, event) {
    if (!this.eventMap.has(name2)) {
      this.eventMap.set(name2, []);
    }
    const events = this.eventMap.get(name2);
    this.eventMap.set(name2, [...events, event]);
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    if (this.eventMap.has(name2)) {
      const events = this.eventMap.get(name2);
      events.forEach((event) => {
        event(value2);
      });
    }
  }
  _init() {
    super._init();
    this._createEventMap();
    this.$element().addClass(COMPONENT_CLASS2);
    this.currentView = viewsUtils.getCurrentView(getViewName(this.option("currentView")), this.option("views"));
  }
  _render() {
    super._render();
    this._createEventMap();
    this._renderToolbar();
  }
  _renderToolbar() {
    const config3 = this._createToolbarConfig();
    const toolbarElement = renderer_default("<div>");
    toolbarElement.appendTo(this.$element());
    this._toolbar = this._createComponent(toolbarElement, toolbar_default, config3);
  }
  _createToolbarConfig() {
    const items = this.option("items");
    const parsedItems = items.map((element) => this._parseItem(element));
    return {
      items: parsedItems
    };
  }
  _parseItem(item) {
    const isDefaultElement = this._isDefaultItem(item);
    if (isDefaultElement) {
      const defaultElementType = item[DEFAULT_ELEMENT];
      switch (defaultElementType) {
        case VIEW_SWITCHER:
          if (this.option("useDropDownViewSwitcher")) {
            return getDropDownViewSwitcher(this, item);
          }
          return getViewSwitcher(this, item);
        case DATE_NAVIGATOR:
          this._renderCalendar();
          return getDateNavigator(this, item);
        default:
          errors_default.log(`Unknown default element type: ${defaultElementType}`);
      }
    }
    return item;
  }
  _callEvent(event, arg) {
    if (this.eventMap.has(event)) {
      const events = this.eventMap.get(event);
      events.forEach((event2) => event2(arg));
    }
  }
  _updateCurrentView(view) {
    const onCurrentViewChange = this.option("onCurrentViewChange");
    onCurrentViewChange(view.name);
    this._callEvent("currentView", view);
  }
  _updateCalendarValueAndCurrentDate(date) {
    this._updateCurrentDate(date);
    this._calendar.option("value", date);
  }
  _updateCurrentDate(date) {
    const onCurrentDateChange = this.option("onCurrentDateChange");
    onCurrentDateChange(date);
    this._callEvent("currentDate", date);
  }
  _renderCalendar() {
    this._calendar = this._createComponent("<div>", SchedulerCalendar, {
      value: this.option("currentDate"),
      min: this.option("min"),
      max: this.option("max"),
      firstDayOfWeek: this.option("firstDayOfWeek"),
      focusStateEnabled: this.option("focusStateEnabled"),
      tabIndex: this.option("tabIndex"),
      onValueChanged: (e) => {
        this._updateCurrentDate(e.value);
        this._calendar.hide();
      }
    });
    this._calendar.$element().appendTo(this.$element());
  }
  _getCalendarOptionUpdater(name2) {
    return (value2) => {
      if (this._calendar) {
        this._calendar.option(name2, value2);
      }
    };
  }
  _getNextDate(direction) {
    let initialDate = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    const date = initialDate ?? this.option("currentDate");
    const options2 = _extends({}, this.intervalOptions, {
      date
    });
    return getNextIntervalDate(options2, direction);
  }
  _isMonth() {
    const {
      currentView
    } = this;
    return "month" === getViewType(currentView);
  }
  _getDisplayedDate() {
    const startViewDate = this.option("startViewDate");
    if (this._isMonth()) {
      return nextWeek(startViewDate);
    }
    return new Date(startViewDate);
  }
  _getCaption() {
    let date = this.option("currentDate");
    if (this.option("startViewDate")) {
      date = this._getDisplayedDate();
    }
    date = date_default.trimTime(date);
    const options2 = _extends({}, this.intervalOptions, {
      date
    });
    const customizationFunction = this.option("customizeDateNavigatorText");
    const useShortDateFormat = this.option("_useShortDateFormat");
    return getCaption(options2, useShortDateFormat, customizationFunction);
  }
  _updateDateByDirection(direction) {
    const date = this._getNextDate(direction);
    this._updateCalendarValueAndCurrentDate(date);
  }
  _showCalendar(e) {
    this._calendar.show(e.element);
  }
  _hideCalendar() {
    this._calendar.hide();
  }
  _isDefaultItem(item) {
    return Object.prototype.hasOwnProperty.call(item, DEFAULT_ELEMENT);
  }
};
component_registrator_default("dxSchedulerHeader", SchedulerHeader);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_cell_position_calculator.js
var BaseStrategy2 = class {
  constructor(options2) {
    this.isVirtualScrolling = false;
    this.options = options2;
  }
  get DOMMetaData() {
    return this.options.DOMMetaData;
  }
  get appointments() {
    return this.options.dateSettings;
  }
  get viewDataProvider() {
    return this.options.viewDataProvider;
  }
  get positionHelper() {
    return this.options.positionHelper;
  }
  get startViewDate() {
    return this.options.startViewDate;
  }
  get viewStartDayHour() {
    return this.options.viewStartDayHour;
  }
  get viewEndDayHour() {
    return this.options.viewEndDayHour;
  }
  get cellDuration() {
    return this.options.cellDuration;
  }
  get getPositionShift() {
    return this.options.getPositionShiftCallback;
  }
  get groupCount() {
    return this.options.groupCount;
  }
  get rtlEnabled() {
    return this.options.rtlEnabled;
  }
  get isVerticalGrouping() {
    return this.options.isVerticalGroupOrientation;
  }
  get showAllDayPanel() {
    return this.options.showAllDayPanel;
  }
  get supportAllDayRow() {
    return this.options.supportAllDayRow;
  }
  get isGroupedAllDayPanel() {
    return this.options.isGroupedAllDayPanel;
  }
  calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment) {
    const result2 = [];
    this.appointments.forEach((dateSetting, index2) => {
      const coordinates = this.getCoordinateInfos({
        appointment: dateSetting,
        groupIndices,
        isAllDayRowAppointment,
        isRecurrentAppointment
      });
      coordinates.forEach((item) => {
        !!item && result2.push(this._prepareObject(item, index2));
      });
    });
    return result2;
  }
  getCoordinateInfos(options2) {
    const {
      appointment,
      isAllDayRowAppointment,
      groupIndices,
      recurrent
    } = options2;
    const {
      startDate
    } = appointment;
    const groupIndex = !recurrent ? appointment.source.groupIndex : void 0;
    return this.getCoordinatesByDateInGroup(startDate, groupIndices, isAllDayRowAppointment, groupIndex);
  }
  _prepareObject(position3, dateSettingIndex) {
    position3.dateSettingIndex = dateSettingIndex;
    return {
      coordinates: position3,
      dateSettingIndex
    };
  }
  getCoordinatesByDate(date, groupIndex, inAllDayRow) {
    const validGroupIndex = groupIndex || 0;
    const cellInfo = {
      groupIndex: validGroupIndex,
      startDate: date,
      isAllDay: inAllDayRow
    };
    const positionByMap = this.viewDataProvider.findCellPositionInMap(cellInfo, true);
    if (!positionByMap) {
      return;
    }
    const position3 = this.getCellPosition(positionByMap, inAllDayRow && !this.isVerticalGrouping);
    const groupEdgeIndices = this.viewDataProvider.getGroupEdgeIndices(validGroupIndex);
    const {
      top: vMin
    } = this.getCellPosition({
      columnIndex: positionByMap.columnIndex,
      rowIndex: groupEdgeIndices.firstRowIndex
    }, inAllDayRow && !this.isVerticalGrouping);
    const timeShift = inAllDayRow ? 0 : this.getTimeShiftRatio(positionByMap, date);
    const shift = this.getPositionShift(timeShift, inAllDayRow);
    const horizontalHMax = this.positionHelper.getHorizontalMax(validGroupIndex, date);
    const verticalMax = this.positionHelper.getVerticalMax({
      groupIndex: validGroupIndex,
      isVirtualScrolling: this.isVirtualScrolling,
      showAllDayPanel: this.showAllDayPanel,
      supportAllDayRow: this.supportAllDayRow,
      isGroupedAllDayPanel: this.isGroupedAllDayPanel,
      isVerticalGrouping: this.isVerticalGrouping
    });
    return {
      positionByMap,
      cellPosition: position3.left + shift.cellPosition,
      top: position3.top + shift.top,
      left: position3.left + shift.left,
      rowIndex: position3.rowIndex,
      columnIndex: position3.columnIndex,
      hMax: horizontalHMax,
      vMax: verticalMax,
      vMin,
      groupIndex: validGroupIndex
    };
  }
  getCoordinatesByDateInGroup(startDate, groupIndices, inAllDayRow, groupIndex) {
    const result2 = [];
    if (this.viewDataProvider.isSkippedDate(startDate)) {
      return result2;
    }
    let validGroupIndices = [groupIndex];
    if (!isDefined(groupIndex)) {
      validGroupIndices = this.groupCount ? groupIndices : [0];
    }
    validGroupIndices.forEach((groupIndex2) => {
      const coordinates = this.getCoordinatesByDate(startDate, groupIndex2, inAllDayRow);
      if (coordinates) {
        result2.push(coordinates);
      }
    });
    return result2;
  }
  getCellPosition(cellCoordinates, isAllDayPanel) {
    const {
      dateTableCellsMeta,
      allDayPanelCellsMeta
    } = this.DOMMetaData;
    const {
      columnIndex,
      rowIndex
    } = cellCoordinates;
    const position3 = isAllDayPanel ? allDayPanelCellsMeta[columnIndex] : dateTableCellsMeta[rowIndex][columnIndex];
    const validPosition = _extends({}, position3);
    if (this.rtlEnabled) {
      validPosition.left += position3.width;
    }
    if (validPosition) {
      validPosition.rowIndex = cellCoordinates.rowIndex;
      validPosition.columnIndex = cellCoordinates.columnIndex;
    }
    return validPosition;
  }
  getTimeShiftRatio(positionByMap, appointmentDate) {
    const {
      cellDuration,
      viewOffset
    } = this.options;
    const {
      rowIndex,
      columnIndex
    } = positionByMap;
    const matchedCell = this.viewDataProvider.viewDataMap.dateTableMap[rowIndex][columnIndex];
    const matchedCellStartDate = dateUtilsTs.addOffsets(matchedCell.cellData.startDate, [-viewOffset]);
    const result2 = (appointmentDate.getTime() - matchedCellStartDate.getTime()) / cellDuration;
    return result2 % 1;
  }
};
var VirtualStrategy = class extends BaseStrategy2 {
  constructor() {
    super(...arguments);
    this.isVirtualScrolling = true;
  }
  calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment) {
    const appointments = isAllDayRowAppointment ? this.appointments : this.appointments.filter((_ref) => {
      let {
        source,
        startDate,
        endDate
      } = _ref;
      return this.viewDataProvider.isGroupIntersectDateInterval(source.groupIndex, startDate, endDate);
    });
    if (isRecurrentAppointment) {
      return this.createRecurrentAppointmentInfos(appointments, isAllDayRowAppointment);
    }
    return super.calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment);
  }
  createRecurrentAppointmentInfos(dateSettings, isAllDayRowAppointment) {
    const result2 = [];
    dateSettings.forEach((_ref2, index2) => {
      let {
        source,
        startDate
      } = _ref2;
      const coordinate = this.getCoordinatesByDate(startDate, source.groupIndex, isAllDayRowAppointment);
      if (coordinate) {
        result2.push(this._prepareObject(coordinate, index2));
      }
    });
    return result2;
  }
};
var CellPositionCalculator = class {
  constructor(options2) {
    this.options = options2;
  }
  calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment) {
    const strategy4 = this.options.isVirtualScrolling ? new VirtualStrategy(this.options) : new BaseStrategy2(this.options);
    return strategy4.calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_text_utils.js
var createFormattedDateText = (options2) => {
  const {
    startDate,
    endDate,
    allDay,
    format: format2
  } = options2;
  const formatType = format2 || getFormatType(startDate, endDate, allDay);
  return formatDates(startDate, endDate, formatType);
};
var getFormatType = (startDate, endDate, isAllDay, isDateAndTimeView2) => {
  if (isAllDay) {
    return "DATE";
  }
  if (isDateAndTimeView2 && date_default.sameDate(startDate, endDate)) {
    return "TIME";
  }
  return "DATETIME";
};
var formatDates = (startDate, endDate, formatType) => {
  const isSameDate = startDate.getDate() === endDate.getDate();
  switch (formatType) {
    case "DATETIME":
      return [date_default3.format(startDate, "monthandday"), " ", date_default3.format(startDate, "shorttime"), " - ", isSameDate ? "" : `${date_default3.format(endDate, "monthandday")} `, date_default3.format(endDate, "shorttime")].join("");
    case "TIME":
      return `${date_default3.format(startDate, "shorttime")} - ${date_default3.format(endDate, "shorttime")}`;
    case "DATE":
      return `${date_default3.format(startDate, "monthandday")}${isSameDate ? "" : ` - ${date_default3.format(endDate, "monthandday")}`}`;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_settings_generator.js
var toMs10 = date_default.dateToMilliseconds;
var DateGeneratorBaseStrategy = class {
  constructor(options2) {
    this.options = options2;
  }
  get rawAppointment() {
    return this.options.rawAppointment;
  }
  get timeZoneCalculator() {
    return this.options.timeZoneCalculator;
  }
  get viewDataProvider() {
    return this.options.viewDataProvider;
  }
  get appointmentTakesAllDay() {
    return this.options.appointmentTakesAllDay;
  }
  get supportAllDayRow() {
    return this.options.supportAllDayRow;
  }
  get isAllDayRowAppointment() {
    return this.options.isAllDayRowAppointment;
  }
  get timeZone() {
    return this.options.timeZone;
  }
  get dateRange() {
    return this.options.dateRange;
  }
  get firstDayOfWeek() {
    return this.options.firstDayOfWeek;
  }
  get viewStartDayHour() {
    return this.options.viewStartDayHour;
  }
  get viewEndDayHour() {
    return this.options.viewEndDayHour;
  }
  get endViewDate() {
    return this.options.endViewDate;
  }
  get viewType() {
    return this.options.viewType;
  }
  get isGroupedByDate() {
    return this.options.isGroupedByDate;
  }
  get isVerticalOrientation() {
    return this.options.isVerticalGroupOrientation;
  }
  get dataAccessors() {
    return this.options.dataAccessors;
  }
  get loadedResources() {
    return this.options.loadedResources;
  }
  get isDateAppointment() {
    return !isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;
  }
  getIntervalDuration() {
    return this.appointmentTakesAllDay ? this.options.allDayIntervalDuration : this.options.intervalDuration;
  }
  generate(appointmentAdapter) {
    const {
      isRecurrent
    } = appointmentAdapter;
    const itemGroupIndices = this._getGroupIndices(this.rawAppointment);
    let appointmentList = this._createAppointments(appointmentAdapter, itemGroupIndices);
    appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointmentAdapter);
    if (this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {
      appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointmentAdapter);
    }
    let dateSettings = this._createGridAppointmentList(appointmentList, appointmentAdapter);
    const firstViewDates = this._getAppointmentsFirstViewDate(dateSettings);
    dateSettings = this._fillNormalizedStartDate(dateSettings, firstViewDates);
    dateSettings = this._cropAppointmentsByStartDayHour(dateSettings, firstViewDates);
    dateSettings = this._fillNormalizedEndDate(dateSettings, this.rawAppointment);
    if (this._needSeparateLongParts()) {
      dateSettings = this._separateLongParts(dateSettings, appointmentAdapter);
    }
    dateSettings = this.shiftSourceAppointmentDates(dateSettings);
    return {
      dateSettings,
      itemGroupIndices,
      isRecurrent
    };
  }
  shiftSourceAppointmentDates(dateSettings) {
    const {
      viewOffset
    } = this.options;
    return dateSettings.map((item) => _extends({}, item, {
      source: _extends({}, item.source, {
        startDate: dateUtilsTs.addOffsets(item.source.startDate, [viewOffset]),
        endDate: dateUtilsTs.addOffsets(item.source.endDate, [viewOffset])
      })
    }));
  }
  _getProcessedByAppointmentTimeZone(appointmentList, appointment) {
    const hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);
    if (hasAppointmentTimeZone) {
      const appointmentOffsets = {
        startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),
        endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)
      };
      appointmentList.forEach((a) => {
        const sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone), sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);
        const startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;
        const endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;
        if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {
          a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs10("hour"));
        }
        if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {
          a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs10("hour"));
        }
      });
    }
    return appointmentList;
  }
  _createAppointments(appointment, groupIndices) {
    let appointments = this._createRecurrenceAppointments(appointment, groupIndices);
    if (!appointment.isRecurrent && 0 === appointments.length) {
      appointments.push({
        startDate: appointment.startDate,
        endDate: appointment.endDate
      });
    }
    appointments = appointments.map((item) => {
      var _item$endDate;
      const resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();
      if (item.startDate.getTime() === resultEndTime) {
        item.endDate.setTime(resultEndTime + toMs10("minute"));
      }
      return _extends({}, item, {
        exceptionDate: new Date(item.startDate)
      });
    });
    return appointments;
  }
  _canProcessNotNativeTimezoneDates(appointment) {
    const isTimeZoneSet = !isEmptyObject(this.timeZone);
    if (!isTimeZoneSet) {
      return false;
    }
    if (!appointment.isRecurrent) {
      return false;
    }
    return !m_utils_time_zone_default.isEqualLocalTimeZone(this.timeZone, appointment.startDate);
  }
  _getProcessedNotNativeDateIfCrossDST(date, offset2) {
    if (offset2 < 0) {
      const newDate = new Date(date);
      const newDateMinusOneHour = new Date(newDate);
      newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);
      const newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;
      const newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;
      if (newDateOffset !== newDateMinusOneHourOffset) {
        return 0;
      }
    }
    return offset2;
  }
  _getCommonOffset(date) {
    return this.timeZoneCalculator.getOffsets(date).common;
  }
  _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {
    return appointmentList.map((item) => {
      let diffStartDateOffset = this._getCommonOffset(appointment.startDate) - this._getCommonOffset(item.startDate);
      let diffEndDateOffset = this._getCommonOffset(appointment.endDate) - this._getCommonOffset(item.endDate);
      if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {
        return item;
      }
      diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);
      diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);
      const newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs10("hour"));
      let newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs10("hour"));
      const testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {
        path: "toGrid"
      });
      const testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {
        path: "toGrid"
      });
      if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {
        newEndDate = new Date(newStartDate.getTime() + appointment.duration);
      }
      return _extends({}, item, {
        startDate: newStartDate,
        endDate: newEndDate,
        exceptionDate: new Date(newStartDate)
      });
    });
  }
  _needSeparateLongParts() {
    return this.isVerticalOrientation ? this.isGroupedByDate : this.isGroupedByDate && this.appointmentTakesAllDay;
  }
  normalizeEndDateByViewEnd(rawAppointment, endDate) {
    let result2 = new Date(endDate.getTime());
    const isAllDay = isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;
    if (!isAllDay) {
      const roundedEndViewDate = date_default.roundToHour(this.endViewDate);
      if (result2 > roundedEndViewDate) {
        result2 = roundedEndViewDate;
      }
    }
    const endDayHour = this.viewEndDayHour;
    const allDay = ExpressionUtils.getField(this.dataAccessors, "allDay", rawAppointment);
    const currentViewEndTime = new Date(new Date(endDate.getTime()).setHours(endDayHour, 0, 0, 0));
    if (result2.getTime() > currentViewEndTime.getTime() || allDay && result2.getHours() < endDayHour) {
      result2 = currentViewEndTime;
    }
    return result2;
  }
  _fillNormalizedEndDate(dateSettings, rawAppointment) {
    return dateSettings.map((item) => _extends({}, item, {
      normalizedEndDate: this.normalizeEndDateByViewEnd(rawAppointment, item.endDate)
    }));
  }
  _separateLongParts(gridAppointmentList, appointmentAdapter) {
    let result2 = [];
    gridAppointmentList.forEach((gridAppointment) => {
      const maxDate = new Date(this.dateRange[1]);
      const {
        startDate,
        normalizedEndDate: endDateOfPart
      } = gridAppointment;
      const longStartDateParts = date_default.getDatesOfInterval(startDate, endDateOfPart, {
        milliseconds: this.getIntervalDuration()
      });
      const list = longStartDateParts.filter((startDatePart) => new Date(startDatePart) < maxDate).map((date) => {
        const endDate = new Date(new Date(date).setMilliseconds(appointmentAdapter.duration));
        const normalizedEndDate = this.normalizeEndDateByViewEnd(this.rawAppointment, endDate);
        return {
          startDate: date,
          endDate,
          normalizedEndDate,
          source: gridAppointment.source
        };
      });
      result2 = result2.concat(list);
    });
    return result2;
  }
  _createGridAppointmentList(appointmentList, appointmentAdapter) {
    return appointmentList.map((source) => {
      const offsetDifference = appointmentAdapter.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();
      if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {
        source.startDate = dateUtilsTs.addOffsets(source.startDate, [offsetDifference * toMs10("minute")]);
        source.endDate = dateUtilsTs.addOffsets(source.endDate, [offsetDifference * toMs10("minute")]);
        source.exceptionDate = new Date(source.startDate);
      }
      const duration = source.endDate.getTime() - source.startDate.getTime();
      const startDate = this.timeZoneCalculator.createDate(source.startDate, {
        path: "toGrid"
      });
      const endDate = dateUtilsTs.addOffsets(startDate, [duration]);
      return {
        startDate,
        endDate,
        allDay: appointmentAdapter.allDay || false,
        source
      };
    });
  }
  _createExtremeRecurrenceDates(groupIndex) {
    let startViewDate = this.appointmentTakesAllDay ? date_default.trimTime(this.dateRange[0]) : this.dateRange[0];
    let endViewDateByEndDayHour = this.dateRange[1];
    if (this.timeZone) {
      startViewDate = this.timeZoneCalculator.createDate(startViewDate, {
        path: "fromGrid"
      });
      endViewDateByEndDayHour = this.timeZoneCalculator.createDate(endViewDateByEndDayHour, {
        path: "fromGrid"
      });
      const daylightOffset = m_utils_time_zone_default.getDaylightOffsetInMs(startViewDate, endViewDateByEndDayHour);
      if (daylightOffset) {
        endViewDateByEndDayHour = new Date(endViewDateByEndDayHour.getTime() + daylightOffset);
      }
    }
    return [startViewDate, endViewDateByEndDayHour];
  }
  _createRecurrenceOptions(appointment, groupIndex) {
    const {
      viewOffset
    } = this.options;
    const originalAppointmentStartDate = dateUtilsTs.addOffsets(appointment.startDate, [viewOffset]);
    const originalAppointmentEndDate = dateUtilsTs.addOffsets(appointment.endDate, [viewOffset]);
    const [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(groupIndex);
    const shiftedMinRecurrenceDate = dateUtilsTs.addOffsets(minRecurrenceDate, [viewOffset]);
    const shiftedMaxRecurrenceDate = dateUtilsTs.addOffsets(maxRecurrenceDate, [viewOffset]);
    return {
      rule: appointment.recurrenceRule,
      exception: appointment.recurrenceException,
      min: shiftedMinRecurrenceDate,
      max: shiftedMaxRecurrenceDate,
      firstDayOfWeek: this.firstDayOfWeek,
      start: originalAppointmentStartDate,
      end: originalAppointmentEndDate,
      appointmentTimezoneOffset: this.timeZoneCalculator.getOriginStartDateOffsetInMs(originalAppointmentStartDate, appointment.rawAppointment.startDateTimeZone, true),
      getPostProcessedException: (date) => {
        if (isEmptyObject(this.timeZone) || m_utils_time_zone_default.isEqualLocalTimeZone(this.timeZone, date)) {
          return date;
        }
        const appointmentOffset = this.timeZoneCalculator.getOffsets(originalAppointmentStartDate).common;
        const exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;
        let diff = appointmentOffset - exceptionAppointmentOffset;
        diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);
        return new Date(date.getTime() - diff * date_default.dateToMilliseconds("hour"));
      }
    };
  }
  _createRecurrenceAppointments(appointment, groupIndices) {
    const {
      duration
    } = appointment;
    const {
      viewOffset
    } = this.options;
    const option = this._createRecurrenceOptions(appointment);
    const generatedStartDates = getRecurrenceProcessor().generateDates(option);
    return generatedStartDates.map((date) => {
      const utcDate = m_utils_time_zone_default.createUTCDateWithLocalOffset(date);
      utcDate.setTime(utcDate.getTime() + duration);
      const endDate = m_utils_time_zone_default.createDateFromUTCWithLocalOffset(utcDate);
      return {
        startDate: new Date(date),
        endDate
      };
    }).map((_ref) => {
      let {
        startDate,
        endDate
      } = _ref;
      return {
        startDate: dateUtilsTs.addOffsets(startDate, [-viewOffset]),
        endDate: dateUtilsTs.addOffsets(endDate, [-viewOffset])
      };
    });
  }
  _getAppointmentsFirstViewDate(appointments) {
    const {
      viewOffset
    } = this.options;
    return appointments.map((appointment) => {
      const tableFirstDate = this._getAppointmentFirstViewDate(_extends({}, appointment, {
        startDate: dateUtilsTs.addOffsets(appointment.startDate, [viewOffset]),
        endDate: dateUtilsTs.addOffsets(appointment.endDate, [viewOffset])
      }));
      if (!tableFirstDate) {
        return appointment.startDate;
      }
      const firstDate = dateUtilsTs.addOffsets(tableFirstDate, [-viewOffset]);
      return firstDate > appointment.startDate ? firstDate : appointment.startDate;
    });
  }
  _fillNormalizedStartDate(appointments, firstViewDates, rawAppointment) {
    return appointments.map((item, idx) => _extends({}, item, {
      startDate: this._getAppointmentResultDate({
        appointment: item,
        rawAppointment,
        startDate: new Date(item.startDate),
        startDayHour: this.viewStartDayHour,
        firstViewDate: firstViewDates[idx]
      })
    }));
  }
  _cropAppointmentsByStartDayHour(appointments, firstViewDates) {
    return appointments.filter((appointment, idx) => {
      if (!firstViewDates[idx]) {
        return false;
      }
      if (this.appointmentTakesAllDay) {
        return true;
      }
      return appointment.endDate > appointment.startDate;
    });
  }
  _getAppointmentResultDate(options2) {
    const {
      appointment,
      startDayHour,
      firstViewDate
    } = options2;
    let {
      startDate
    } = options2;
    let resultDate;
    if (this.appointmentTakesAllDay) {
      resultDate = date_default.normalizeDate(startDate, firstViewDate);
    } else {
      if (startDate < firstViewDate) {
        startDate = firstViewDate;
      }
      resultDate = date_default.normalizeDate(appointment.startDate, startDate);
    }
    return !this.isDateAppointment ? date_default.roundDateByStartDayHour(resultDate, startDayHour) : resultDate;
  }
  _getAppointmentFirstViewDate(appointment) {
    const groupIndex = appointment.source.groupIndex || 0;
    const {
      startDate,
      endDate
    } = appointment;
    if (this.isAllDayRowAppointment || appointment.allDay) {
      return this.viewDataProvider.findAllDayGroupCellStartDate(groupIndex);
    }
    return this.viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, this.isDateAppointment);
  }
  _getGroupIndices(rawAppointment) {
    let result2 = [];
    if (rawAppointment && this.loadedResources.length) {
      const tree = createResourcesTree(this.loadedResources);
      result2 = getResourceTreeLeaves((field, action) => getDataAccessors(this.options.dataAccessors.resources, field, action), tree, rawAppointment);
    }
    return result2;
  }
};
var DateGeneratorVirtualStrategy = class extends DateGeneratorBaseStrategy {
  get groupCount() {
    return getGroupCount(this.loadedResources);
  }
  _createRecurrenceAppointments(appointment, groupIndices) {
    const {
      duration
    } = appointment;
    const result2 = [];
    const validGroupIndices = this.groupCount ? groupIndices : [0];
    validGroupIndices.forEach((groupIndex) => {
      const option = this._createRecurrenceOptions(appointment, groupIndex);
      const generatedStartDates = getRecurrenceProcessor().generateDates(option);
      const recurrentInfo = generatedStartDates.map((date) => {
        const startDate = new Date(date);
        const utcDate = m_utils_time_zone_default.createUTCDateWithLocalOffset(date);
        utcDate.setTime(utcDate.getTime() + duration);
        const endDate = m_utils_time_zone_default.createDateFromUTCWithLocalOffset(utcDate);
        return {
          startDate,
          endDate,
          groupIndex
        };
      });
      result2.push(...recurrentInfo);
    });
    return result2;
  }
  _updateGroupIndices(appointments, groupIndices) {
    const result2 = [];
    groupIndices.forEach((groupIndex) => {
      const groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);
      if (groupStartDate) {
        appointments.forEach((appointment) => {
          const appointmentCopy = extend({}, appointment);
          appointmentCopy.groupIndex = groupIndex;
          result2.push(appointmentCopy);
        });
      }
    });
    return result2;
  }
  _getGroupIndices(resources) {
    var _groupIndices;
    let groupIndices = super._getGroupIndices(resources);
    const viewDataGroupIndices = this.viewDataProvider.getGroupIndices();
    if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {
      groupIndices = [0];
    }
    return groupIndices.filter((groupIndex) => -1 !== viewDataGroupIndices.indexOf(groupIndex));
  }
  _createAppointments(appointment, groupIndices) {
    const appointments = super._createAppointments(appointment, groupIndices);
    return !appointment.isRecurrent ? this._updateGroupIndices(appointments, groupIndices) : appointments;
  }
};
var AppointmentSettingsGenerator = class {
  constructor(options2) {
    this.options = options2;
    this.appointmentAdapter = createAppointmentAdapter(this.rawAppointment, this.dataAccessors, this.timeZoneCalculator);
  }
  get rawAppointment() {
    return this.options.rawAppointment;
  }
  get dataAccessors() {
    return this.options.dataAccessors;
  }
  get timeZoneCalculator() {
    return this.options.timeZoneCalculator;
  }
  get isAllDayRowAppointment() {
    return this.options.appointmentTakesAllDay && this.options.supportAllDayRow;
  }
  get groups() {
    return this.options.groups;
  }
  get dateSettingsStrategy() {
    const options2 = _extends({}, this.options, {
      isAllDayRowAppointment: this.isAllDayRowAppointment
    });
    return this.options.isVirtualScrolling ? new DateGeneratorVirtualStrategy(options2) : new DateGeneratorBaseStrategy(options2);
  }
  create() {
    const {
      dateSettings,
      itemGroupIndices,
      isRecurrent
    } = this._generateDateSettings();
    const cellPositions = this._calculateCellPositions(dateSettings, itemGroupIndices);
    const result2 = this._prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent);
    return result2;
  }
  _generateDateSettings() {
    return this.dateSettingsStrategy.generate(this.appointmentAdapter);
  }
  _calculateCellPositions(dateSettings, itemGroupIndices) {
    const cellPositionCalculator = new CellPositionCalculator(_extends({}, this.options, {
      dateSettings
    }));
    return cellPositionCalculator.calculateCellPositions(itemGroupIndices, this.isAllDayRowAppointment, this.appointmentAdapter.isRecurrent);
  }
  _prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent) {
    const infos = [];
    cellPositions.forEach((_ref2) => {
      let {
        coordinates,
        dateSettingIndex
      } = _ref2;
      const dateSetting = dateSettings[dateSettingIndex];
      const dateText = this._getAppointmentDateText(dateSetting);
      const info = {
        appointment: dateSetting,
        sourceAppointment: dateSetting.source,
        dateText,
        isRecurrent
      };
      infos.push(_extends({}, coordinates, {
        info
      }));
    });
    return infos;
  }
  _getAppointmentDateText(sourceAppointment) {
    const {
      startDate,
      endDate,
      allDay
    } = sourceAppointment;
    return createFormattedDateText({
      startDate,
      endDate,
      allDay,
      format: "TIME"
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_appointments_positioning_strategy_base.js
var AppointmentPositioningStrategy = class {
  constructor(renderingStrategy) {
    this._renderingStrategy = renderingStrategy;
  }
  getDropDownAppointmentWidth(intervalCount, isAllDay) {
    if (isAllDay || !isDefined(isAllDay)) {
      return 75 * this._renderingStrategy.cellWidth / 100;
    }
    return 24;
  }
  getCollectorTopOffset(allDay) {
    return 3;
  }
  getCollectorLeftOffset() {
    return 3;
  }
  getAppointmentDefaultOffset() {
    if (this._renderingStrategy._isCompactTheme()) {
      return 22;
    }
    return this._renderingStrategy.appointmentOffset;
  }
  getDynamicAppointmentCountPerCell() {
    const renderingStrategy = this._renderingStrategy;
    const {
      cellHeight
    } = renderingStrategy;
    const allDayCount = Math.floor((cellHeight - renderingStrategy._getAppointmentDefaultOffset()) / renderingStrategy._getAppointmentDefaultHeight()) || this._getAppointmentMinCount();
    if (renderingStrategy.allDaySupported()) {
      return {
        allDay: "vertical" === renderingStrategy.groupOrientation ? allDayCount : this._renderingStrategy.appointmentCountPerCell,
        simple: this._calculateDynamicAppointmentCountPerCell() || this._getAppointmentMinCount()
      };
    }
    return allDayCount;
  }
  getDropDownAppointmentHeight() {
    return;
  }
  _getAppointmentMinCount() {
    return 1;
  }
  _calculateDynamicAppointmentCountPerCell() {
    return Math.floor(this._renderingStrategy._getAppointmentMaxWidth() / 50);
  }
  _getAppointmentDefaultWidth() {
    return 40;
  }
};
var m_appointments_positioning_strategy_base_default = AppointmentPositioningStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_appointments_positioning_strategy_adaptive.js
var AdaptivePositioningStrategy = class extends m_appointments_positioning_strategy_base_default {
  getDropDownAppointmentWidth(intervalCount, isAllDay) {
    return this.getDropDownButtonAdaptiveSize();
  }
  getDropDownButtonAdaptiveSize() {
    return 28;
  }
  getCollectorTopOffset(allDay) {
    const renderingStrategy = this._renderingStrategy;
    if (renderingStrategy.allDaySupported() && allDay) {
      return (renderingStrategy.allDayHeight - renderingStrategy.getDropDownButtonAdaptiveSize()) / 2;
    }
    return this._renderingStrategy.cellHeight - 40;
  }
  getCollectorLeftOffset() {
    const collectorWidth = this._renderingStrategy.getDropDownAppointmentWidth();
    return (this._renderingStrategy.cellWidth - collectorWidth) / 2;
  }
  getAppointmentDefaultOffset() {
    return 35;
  }
  getDynamicAppointmentCountPerCell() {
    const renderingStrategy = this._renderingStrategy;
    if (renderingStrategy.allDaySupported()) {
      return {
        allDay: 0,
        simple: this._calculateDynamicAppointmentCountPerCell() || this._getAppointmentMinCount()
      };
    }
    return 0;
  }
  getDropDownAppointmentHeight() {
    return 28;
  }
  _getAppointmentMinCount() {
    return 0;
  }
  _getAppointmentDefaultWidth() {
    const renderingStrategy = this._renderingStrategy;
    if (renderingStrategy.allDaySupported()) {
      return 30;
    }
    return super._getAppointmentDefaultWidth();
  }
  _calculateDynamicAppointmentCountPerCell() {
    return Math.floor(this._renderingStrategy._getAppointmentMaxWidth() / this._renderingStrategy._getAppointmentDefaultWidth());
  }
};
var m_appointments_positioning_strategy_adaptive_default = AdaptivePositioningStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_base.js
var toMs11 = date_default.dateToMilliseconds;
var BaseRenderingStrategy = class {
  constructor(options2) {
    this.options = options2;
    this._initPositioningStrategy();
  }
  get isAdaptive() {
    return this.options.adaptivityEnabled;
  }
  get rtlEnabled() {
    return this.options.rtlEnabled;
  }
  get startDayHour() {
    return this.options.startDayHour;
  }
  get endDayHour() {
    return this.options.endDayHour;
  }
  get maxAppointmentsPerCell() {
    return this.options.maxAppointmentsPerCell;
  }
  get cellWidth() {
    return this.options.cellWidth;
  }
  get cellHeight() {
    return this.options.cellHeight;
  }
  get allDayHeight() {
    return this.options.allDayHeight;
  }
  get resizableStep() {
    return this.options.resizableStep;
  }
  get isGroupedByDate() {
    return this.options.isGroupedByDate;
  }
  get visibleDayDuration() {
    return this.options.visibleDayDuration;
  }
  get viewStartDayHour() {
    return this.options.viewStartDayHour;
  }
  get viewEndDayHour() {
    return this.options.viewEndDayHour;
  }
  get cellDuration() {
    return this.options.cellDuration;
  }
  get cellDurationInMinutes() {
    return this.options.cellDurationInMinutes;
  }
  get leftVirtualCellCount() {
    return this.options.leftVirtualCellCount;
  }
  get topVirtualCellCount() {
    return this.options.topVirtualCellCount;
  }
  get positionHelper() {
    return this.options.positionHelper;
  }
  get showAllDayPanel() {
    return this.options.showAllDayPanel;
  }
  get isGroupedAllDayPanel() {
    return this.options.isGroupedAllDayPanel;
  }
  get groupOrientation() {
    return this.options.groupOrientation;
  }
  get rowCount() {
    return this.options.rowCount;
  }
  get groupCount() {
    return this.options.groupCount;
  }
  get currentDate() {
    return this.options.currentDate;
  }
  get appointmentCountPerCell() {
    return this.options.appointmentCountPerCell;
  }
  get appointmentOffset() {
    return this.options.appointmentOffset;
  }
  get allowResizing() {
    return this.options.allowResizing;
  }
  get allowAllDayResizing() {
    return this.options.allowAllDayResizing;
  }
  get viewDataProvider() {
    return this.options.viewDataProvider;
  }
  get dataAccessors() {
    return this.options.dataAccessors;
  }
  get timeZoneCalculator() {
    return this.options.timeZoneCalculator;
  }
  get intervalCount() {
    return this.options.intervalCount;
  }
  get allDayPanelMode() {
    return this.options.allDayPanelMode;
  }
  get isVirtualScrolling() {
    return this.options.isVirtualScrolling;
  }
  _correctCollectorCoordinatesInAdaptive(coordinates, isAllDay) {
    coordinates.top += this.getCollectorTopOffset(isAllDay);
    coordinates.left += this.getCollectorLeftOffset();
  }
  _initPositioningStrategy() {
    this._positioningStrategy = this.isAdaptive ? new m_appointments_positioning_strategy_adaptive_default(this) : new m_appointments_positioning_strategy_base_default(this);
  }
  getPositioningStrategy() {
    return this._positioningStrategy;
  }
  getAppointmentMinSize() {
    return 2;
  }
  keepAppointmentSettings() {
    return false;
  }
  getDeltaTime(args, initialSize, appointment) {
  }
  getAppointmentGeometry(coordinates) {
    return coordinates;
  }
  needCorrectAppointmentDates() {
    return true;
  }
  getDirection() {
    return "horizontal";
  }
  createTaskPositionMap(items, skipSorting) {
    delete this._maxAppointmentCountPerCell;
    const length = null === items || void 0 === items ? void 0 : items.length;
    if (!length) {
      return;
    }
    const map2 = [];
    for (let i = 0; i < length; i++) {
      let coordinates = this._getItemPosition(items[i]);
      if (coordinates.length && this.rtlEnabled) {
        coordinates = this._correctRtlCoordinates(coordinates);
      }
      coordinates.forEach((item) => {
        item.leftVirtualCellCount = this.leftVirtualCellCount;
        item.topVirtualCellCount = this.topVirtualCellCount;
        item.leftVirtualWidth = this.leftVirtualCellCount * this.cellWidth;
        item.topVirtualHeight = this.topVirtualCellCount * this.cellHeight;
      });
      map2.push(coordinates);
    }
    const positionArray = this._getSortedPositions(map2);
    const resultPositions = this._getResultPositions(positionArray);
    return this._getExtendedPositionMap(map2, resultPositions);
  }
  _getDeltaWidth(args, initialSize) {
    const intervalWidth = this.resizableStep || this.getAppointmentMinSize();
    const initialWidth = initialSize.width;
    return Math.round((args.width - initialWidth) / intervalWidth);
  }
  _correctRtlCoordinates(coordinates) {
    const width = coordinates[0].width || this._getAppointmentMaxWidth();
    coordinates.forEach((coordinate) => {
      if (!coordinate.appointmentReduced) {
        coordinate.left -= width;
      }
    });
    return coordinates;
  }
  _getAppointmentMaxWidth() {
    return this.cellWidth;
  }
  _getItemPosition(initialAppointment) {
    const appointment = this.shiftAppointmentByViewOffset(initialAppointment);
    const position3 = this.generateAppointmentSettings(appointment);
    const allDay = this.isAllDay(appointment);
    let result2 = [];
    for (let j = 0; j < position3.length; j++) {
      const height = this.calculateAppointmentHeight(appointment, position3[j]);
      const width = this.calculateAppointmentWidth(appointment, position3[j]);
      let resultWidth = width;
      let appointmentReduced = null;
      let multiWeekAppointmentParts = [];
      let initialRowIndex = position3[j].rowIndex;
      let initialColumnIndex = position3[j].columnIndex;
      if (this._needVerifyItemSize() || allDay) {
        const currentMaxAllowedPosition = position3[j].hMax;
        if (this.isAppointmentGreaterThan(currentMaxAllowedPosition, {
          left: position3[j].left,
          width
        })) {
          appointmentReduced = "head";
          initialRowIndex = position3[j].rowIndex;
          initialColumnIndex = position3[j].columnIndex;
          resultWidth = this._reduceMultiWeekAppointment(width, {
            left: position3[j].left,
            right: currentMaxAllowedPosition
          });
          multiWeekAppointmentParts = this._getAppointmentParts({
            sourceAppointmentWidth: width,
            reducedWidth: resultWidth,
            height
          }, position3[j]);
          if (this.rtlEnabled) {
            position3[j].left = currentMaxAllowedPosition;
          }
        }
      }
      extend(position3[j], {
        height,
        width: resultWidth,
        allDay,
        rowIndex: initialRowIndex,
        columnIndex: initialColumnIndex,
        appointmentReduced
      });
      result2 = this._getAppointmentPartsPosition(multiWeekAppointmentParts, position3[j], result2);
    }
    return result2;
  }
  _getAppointmentPartsPosition(appointmentParts, position3, result2) {
    if (appointmentParts.length) {
      appointmentParts.unshift(position3);
      result2 = result2.concat(appointmentParts);
    } else {
      result2.push(position3);
    }
    return result2;
  }
  getAppointmentSettingsGenerator(rawAppointment) {
    return new AppointmentSettingsGenerator(_extends({
      rawAppointment,
      appointmentTakesAllDay: this.isAppointmentTakesAllDay(rawAppointment),
      getPositionShiftCallback: this.getPositionShift.bind(this)
    }, this.options));
  }
  generateAppointmentSettings(rawAppointment) {
    return this.getAppointmentSettingsGenerator(rawAppointment).create();
  }
  isAppointmentTakesAllDay(rawAppointment) {
    const adapter = createAppointmentAdapter(rawAppointment, this.dataAccessors, this.timeZoneCalculator);
    return getAppointmentTakesAllDay(adapter, this.allDayPanelMode);
  }
  _getAppointmentParts(geometry, settings) {
    return [];
  }
  _getCompactAppointmentParts(appointmentWidth) {
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    return Math.round(appointmentWidth / cellWidth);
  }
  _reduceMultiWeekAppointment(sourceAppointmentWidth, bound) {
    if (this.rtlEnabled) {
      sourceAppointmentWidth = Math.floor(bound.left - bound.right);
    } else {
      sourceAppointmentWidth = bound.right - Math.floor(bound.left);
    }
    return sourceAppointmentWidth;
  }
  calculateAppointmentHeight(appointment, position3) {
    return 0;
  }
  calculateAppointmentWidth(appointment, position3) {
    return 0;
  }
  isAppointmentGreaterThan(etalon, comparisonParameters) {
    let result2 = comparisonParameters.left + comparisonParameters.width - etalon;
    if (this.rtlEnabled) {
      result2 = etalon + comparisonParameters.width - comparisonParameters.left;
    }
    return result2 > this.cellWidth / 2;
  }
  isAllDay(appointment) {
    return false;
  }
  cropAppointmentWidth(width, cellWidth) {
    return this.isGroupedByDate ? cellWidth : width;
  }
  _getSortedPositions(positionList, skipSorting) {
    const result2 = [];
    const round = (value2) => Math.round(100 * value2) / 100;
    const createItem = (rowIndex, columnIndex, top, left, bottom, right, position3, allDay) => ({
      i: rowIndex,
      j: columnIndex,
      top: round(top),
      left: round(left),
      bottom: round(bottom),
      right: round(right),
      cellPosition: position3,
      allDay
    });
    for (let rowIndex = 0, rowCount = positionList.length; rowIndex < rowCount; rowIndex++) {
      for (let columnIndex = 0, cellCount = positionList[rowIndex].length; columnIndex < cellCount; columnIndex++) {
        const {
          top,
          left,
          height,
          width,
          cellPosition,
          allDay
        } = positionList[rowIndex][columnIndex];
        result2.push(createItem(rowIndex, columnIndex, top, left, top + height, left + width, cellPosition, allDay));
      }
    }
    return result2.sort((a, b) => this._sortCondition(a, b));
  }
  _sortCondition(a, b) {
  }
  _getConditions(a, b) {
    const isSomeEdge = this._isSomeEdge(a, b);
    return {
      columnCondition: isSomeEdge || this._normalizeCondition(a.left, b.left),
      rowCondition: isSomeEdge || this._normalizeCondition(a.top, b.top),
      cellPositionCondition: isSomeEdge || this._normalizeCondition(a.cellPosition, b.cellPosition)
    };
  }
  _rowCondition(a, b) {
    const conditions = this._getConditions(a, b);
    return conditions.columnCondition || conditions.rowCondition;
  }
  _columnCondition(a, b) {
    const conditions = this._getConditions(a, b);
    return conditions.rowCondition || conditions.columnCondition;
  }
  _isSomeEdge(a, b) {
    return a.i === b.i && a.j === b.j;
  }
  _normalizeCondition(first, second) {
    const result2 = first - second;
    return Math.abs(result2) > 1 ? result2 : 0;
  }
  _isItemsCross(firstItem, secondItem) {
    const areItemsInTheSameTable = !!firstItem.allDay === !!secondItem.allDay;
    const areItemsAllDay = firstItem.allDay && secondItem.allDay;
    if (areItemsInTheSameTable) {
      const orientation = this._getOrientation(areItemsAllDay);
      return this._checkItemsCrossing(firstItem, secondItem, orientation);
    }
    return false;
  }
  _checkItemsCrossing(firstItem, secondItem, orientation) {
    const firstItemSide1 = Math.floor(firstItem[orientation[0]]);
    const firstItemSide2 = Math.floor(firstItem[orientation[1]]);
    const secondItemSide1 = Math.ceil(secondItem[orientation[0]]);
    const secondItemSide2 = Math.ceil(secondItem[orientation[1]]);
    const isItemCross = Math.abs(firstItem[orientation[2]] - secondItem[orientation[2]]) <= 1;
    return isItemCross && (firstItemSide1 <= secondItemSide1 && firstItemSide2 > secondItemSide1 || firstItemSide1 < secondItemSide2 && firstItemSide2 >= secondItemSide2 || firstItemSide1 === secondItemSide1 && firstItemSide2 === secondItemSide2);
  }
  _getOrientation(isAllDay) {
    return isAllDay ? ["left", "right", "top"] : ["top", "bottom", "left"];
  }
  _getResultPositions(sortedArray) {
    const result2 = [];
    let i;
    let sortedIndex = 0;
    let currentItem;
    let indexes;
    let itemIndex;
    let maxIndexInStack = 0;
    let stack = {};
    const findFreeIndex = (indexes2, index2) => {
      const isFind = indexes2.some((item) => item === index2);
      if (isFind) {
        return findFreeIndex(indexes2, ++index2);
      }
      return index2;
    };
    const createItem = (currentItem2, index2) => {
      const currentIndex = index2 || 0;
      return {
        index: currentIndex,
        i: currentItem2.i,
        j: currentItem2.j,
        left: currentItem2.left,
        right: currentItem2.right,
        top: currentItem2.top,
        bottom: currentItem2.bottom,
        allDay: currentItem2.allDay,
        sortedIndex: this._skipSortedIndex(currentIndex) ? null : sortedIndex++
      };
    };
    const startNewStack = (currentItem2) => {
      stack.items = [createItem(currentItem2)];
      stack.left = currentItem2.left;
      stack.right = currentItem2.right;
      stack.top = currentItem2.top;
      stack.bottom = currentItem2.bottom;
      stack.allDay = currentItem2.allDay;
    };
    const pushItemsInResult = (items) => {
      items.forEach((item) => {
        result2.push({
          index: item.index,
          count: maxIndexInStack + 1,
          i: item.i,
          j: item.j,
          sortedIndex: item.sortedIndex
        });
      });
    };
    for (i = 0; i < sortedArray.length; i++) {
      currentItem = sortedArray[i];
      indexes = [];
      if (!stack.items) {
        startNewStack(currentItem);
      } else if (this._isItemsCross(stack, currentItem)) {
        stack.items.forEach((item) => {
          if (this._isItemsCross(item, currentItem)) {
            indexes.push(item.index);
          }
        });
        itemIndex = indexes.length ? findFreeIndex(indexes, 0) : 0;
        stack.items.push(createItem(currentItem, itemIndex));
        maxIndexInStack = Math.max(itemIndex, maxIndexInStack);
        stack.left = Math.min(stack.left, currentItem.left);
        stack.right = Math.max(stack.right, currentItem.right);
        stack.top = Math.min(stack.top, currentItem.top);
        stack.bottom = Math.max(stack.bottom, currentItem.bottom);
        stack.allDay = currentItem.allDay;
      } else {
        pushItemsInResult(stack.items);
        stack = {};
        startNewStack(currentItem);
        maxIndexInStack = 0;
      }
    }
    if (stack.items) {
      pushItemsInResult(stack.items);
    }
    return result2.sort((a, b) => {
      const columnCondition = a.j - b.j;
      const rowCondition = a.i - b.i;
      return rowCondition || columnCondition;
    });
  }
  _skipSortedIndex(index2) {
    return index2 > this._getMaxAppointmentCountPerCell() - 1;
  }
  _findIndexByKey(arr, iKey, jKey, iValue, jValue) {
    let result2 = 0;
    for (let i = 0, len = arr.length; i < len; i++) {
      if (arr[i][iKey] === iValue && arr[i][jKey] === jValue) {
        result2 = i;
        break;
      }
    }
    return result2;
  }
  _getExtendedPositionMap(map2, positions) {
    let positionCounter = 0;
    const result2 = [];
    for (let i = 0, mapLength = map2.length; i < mapLength; i++) {
      const resultString = [];
      for (let j = 0, itemLength = map2[i].length; j < itemLength; j++) {
        map2[i][j].index = positions[positionCounter].index;
        map2[i][j].sortedIndex = positions[positionCounter].sortedIndex;
        map2[i][j].count = positions[positionCounter++].count;
        resultString.push(map2[i][j]);
        this._checkLongCompactAppointment(map2[i][j], resultString);
      }
      result2.push(resultString);
    }
    return result2;
  }
  _checkLongCompactAppointment(item, result2) {
    this._splitLongCompactAppointment(item, result2);
    return result2;
  }
  _splitLongCompactAppointment(item, result2) {
    const appointmentCountPerCell = this._getMaxAppointmentCountPerCellByType(item.allDay);
    let compactCount = 0;
    if (void 0 !== appointmentCountPerCell && item.index > appointmentCountPerCell - 1) {
      item.isCompact = true;
      compactCount = this._getCompactAppointmentParts(item.width);
      for (let k = 1; k < compactCount; k++) {
        const compactPart = extend(true, {}, item);
        compactPart.left = this._getCompactLeftCoordinate(item.left, k);
        compactPart.columnIndex += k;
        compactPart.sortedIndex = null;
        result2.push(compactPart);
      }
    }
    return result2;
  }
  _adjustDurationByDaylightDiff(duration, startDate, endDate) {
    const {
      viewOffset
    } = this.options;
    const originalStartDate = dateUtilsTs.addOffsets(startDate, [viewOffset]);
    const originalEndDate = dateUtilsTs.addOffsets(endDate, [viewOffset]);
    const daylightDiff = m_utils_time_zone_default.getDaylightOffset(originalStartDate, originalEndDate);
    const correctedDuration = this._needAdjustDuration(daylightDiff) ? this._calculateDurationByDaylightDiff(duration, daylightDiff) : duration;
    return correctedDuration <= Math.abs(daylightDiff) ? duration : correctedDuration;
  }
  _needAdjustDuration(diff) {
    return 0 !== diff;
  }
  _calculateDurationByDaylightDiff(duration, diff) {
    return duration + diff * toMs11("minute");
  }
  _getCollectorLeftOffset(isAllDay) {
    if (isAllDay || !this.isApplyCompactAppointmentOffset()) {
      return 0;
    }
    const dropDownButtonWidth = this.getDropDownAppointmentWidth(this.intervalCount, isAllDay);
    const rightOffset = this._isCompactTheme() ? 1 : 5;
    return this.cellWidth - dropDownButtonWidth - rightOffset;
  }
  _markAppointmentAsVirtual(coordinates) {
    let isAllDay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const countFullWidthAppointmentInCell = this._getMaxAppointmentCountPerCellByType(isAllDay);
    if (coordinates.count - countFullWidthAppointmentInCell > 0) {
      const {
        top,
        left
      } = coordinates;
      const compactRender = this.isAdaptive || !isAllDay && this.supportCompactDropDownAppointments();
      coordinates.virtual = {
        left: left + this._getCollectorLeftOffset(isAllDay),
        top,
        width: this.getDropDownAppointmentWidth(this.intervalCount, isAllDay),
        height: this.getDropDownAppointmentHeight(),
        index: this._generateAppointmentCollectorIndex(coordinates, isAllDay),
        isAllDay,
        groupIndex: coordinates.groupIndex,
        isCompact: compactRender
      };
    }
  }
  isApplyCompactAppointmentOffset() {
    return this.supportCompactDropDownAppointments();
  }
  supportCompactDropDownAppointments() {
    return true;
  }
  _generateAppointmentCollectorIndex(_ref, isAllDay) {
    let {
      groupIndex,
      rowIndex,
      columnIndex
    } = _ref;
    return `${groupIndex}-${rowIndex}-${columnIndex}-${isAllDay}`;
  }
  _getMaxAppointmentCountPerCellByType(isAllDay) {
    const appointmentCountPerCell = this._getMaxAppointmentCountPerCell();
    if (isObject(appointmentCountPerCell)) {
      return isAllDay ? appointmentCountPerCell.allDay : appointmentCountPerCell.simple;
    }
    return appointmentCountPerCell;
  }
  getDropDownAppointmentWidth(intervalCount, isAllDay) {
    return this.getPositioningStrategy().getDropDownAppointmentWidth(intervalCount, isAllDay);
  }
  getDropDownAppointmentHeight() {
    return this.getPositioningStrategy().getDropDownAppointmentHeight();
  }
  getDropDownButtonAdaptiveSize() {
    return 28;
  }
  getCollectorTopOffset(allDay) {
    return this.getPositioningStrategy().getCollectorTopOffset(allDay);
  }
  getCollectorLeftOffset() {
    return this.getPositioningStrategy().getCollectorLeftOffset();
  }
  getAppointmentDataCalculator() {
  }
  getVerticalAppointmentHeight(cellHeight, currentAppointmentCountInCell, maxAppointmentsPerCell) {
    let resultMaxAppointmentsPerCell = maxAppointmentsPerCell;
    if (isNumeric(this.maxAppointmentsPerCell)) {
      const dynamicAppointmentCountPerCell = this._getDynamicAppointmentCountPerCell();
      const maxAppointmentCountDisplayedInCell = dynamicAppointmentCountPerCell.allDay || dynamicAppointmentCountPerCell;
      const maxAppointmentsCount = Math.max(currentAppointmentCountInCell, maxAppointmentCountDisplayedInCell);
      resultMaxAppointmentsPerCell = Math.min(maxAppointmentsCount, maxAppointmentsPerCell);
    }
    return cellHeight / resultMaxAppointmentsPerCell;
  }
  _customizeCoordinates(coordinates, cellHeight, appointmentCountPerCell, topOffset, isAllDay) {
    const {
      index: index2,
      count
    } = coordinates;
    const appointmentHeight = this.getVerticalAppointmentHeight(cellHeight, count, appointmentCountPerCell);
    const appointmentTop = coordinates.top + index2 * appointmentHeight;
    const top = appointmentTop + topOffset;
    const {
      width
    } = coordinates;
    const {
      left
    } = coordinates;
    if (coordinates.isCompact) {
      this.isAdaptive && this._correctCollectorCoordinatesInAdaptive(coordinates, isAllDay);
      this._markAppointmentAsVirtual(coordinates, isAllDay);
    }
    return {
      height: appointmentHeight,
      width,
      top,
      left,
      empty: this._isAppointmentEmpty(cellHeight, width)
    };
  }
  _isAppointmentEmpty(height, width) {
    return height < this._getAppointmentMinHeight() || width < this._getAppointmentMinWidth();
  }
  _calculateGeometryConfig(coordinates) {
    const overlappingMode = this.maxAppointmentsPerCell;
    const offsets = this._getOffsets();
    const appointmentDefaultOffset = this._getAppointmentDefaultOffset();
    let appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);
    let ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);
    let maxHeight = this._getMaxHeight();
    if (!isNumeric(appointmentCountPerCell)) {
      appointmentCountPerCell = coordinates.count;
      ratio = (maxHeight - offsets.unlimited) / maxHeight;
    }
    let topOffset = (1 - ratio) * maxHeight;
    if ("auto" === overlappingMode || isNumeric(overlappingMode)) {
      ratio = 1;
      maxHeight -= appointmentDefaultOffset;
      topOffset = appointmentDefaultOffset;
    }
    return {
      height: ratio * maxHeight,
      appointmentCountPerCell,
      offset: topOffset
    };
  }
  _getAppointmentCount(overlappingMode, coordinates) {
  }
  _getDefaultRatio(coordinates, appointmentCountPerCell) {
  }
  _getOffsets() {
  }
  _getMaxHeight() {
  }
  _needVerifyItemSize() {
    return false;
  }
  _getMaxAppointmentCountPerCell() {
    if (!this._maxAppointmentCountPerCell) {
      const overlappingMode = this.maxAppointmentsPerCell;
      let appointmentCountPerCell;
      if (isNumeric(overlappingMode)) {
        appointmentCountPerCell = overlappingMode;
      }
      if ("auto" === overlappingMode) {
        appointmentCountPerCell = this._getDynamicAppointmentCountPerCell();
      }
      if ("unlimited" === overlappingMode) {
        appointmentCountPerCell = void 0;
      }
      this._maxAppointmentCountPerCell = appointmentCountPerCell;
    }
    return this._maxAppointmentCountPerCell;
  }
  _getDynamicAppointmentCountPerCell() {
    return this.getPositioningStrategy().getDynamicAppointmentCountPerCell();
  }
  allDaySupported() {
    return false;
  }
  _isCompactTheme() {
    return "compact" === (current() || "").split(".").pop();
  }
  _getAppointmentDefaultOffset() {
    return this.getPositioningStrategy().getAppointmentDefaultOffset();
  }
  _getAppointmentDefaultHeight() {
    return this._getAppointmentHeightByTheme();
  }
  _getAppointmentMinHeight() {
    return this._getAppointmentDefaultHeight();
  }
  _getAppointmentHeightByTheme() {
    return this._isCompactTheme() ? 18 : 20;
  }
  _getAppointmentDefaultWidth() {
    return this.getPositioningStrategy()._getAppointmentDefaultWidth();
  }
  _getAppointmentMinWidth() {
    return this._getAppointmentDefaultWidth();
  }
  _needVerticalGroupBounds(allDay) {
    return false;
  }
  _needHorizontalGroupBounds() {
    return false;
  }
  getAppointmentDurationInMs(apptStartDate, apptEndDate, allDay) {
    if (allDay) {
      const appointmentDuration = apptEndDate.getTime() - apptStartDate.getTime();
      const ceilQuantityOfDays = Math.ceil(appointmentDuration / toMs11("day"));
      return ceilQuantityOfDays * this.visibleDayDuration;
    }
    const msInHour = toMs11("hour");
    const trimmedStartDate = date_default.trimTime(apptStartDate);
    const trimmedEndDate = date_default.trimTime(apptEndDate);
    const deltaDate = trimmedEndDate - trimmedStartDate;
    const quantityOfDays = deltaDate / toMs11("day") + 1;
    const dayVisibleHours = this.endDayHour - this.startDayHour;
    const appointmentDayHours = dayVisibleHours * quantityOfDays;
    const startHours = (apptStartDate - trimmedStartDate) / msInHour;
    const apptStartDelta = Math.max(0, startHours - this.startDayHour);
    const endHours = Math.max(0, (apptEndDate - trimmedEndDate) / msInHour - this.startDayHour);
    const apptEndDelta = Math.max(0, dayVisibleHours - endHours);
    const result2 = (appointmentDayHours - (apptStartDelta + apptEndDelta)) * msInHour;
    return result2;
  }
  getPositionShift(timeShift, isAllDay) {
    return {
      top: timeShift * this.cellHeight,
      left: 0,
      cellPosition: 0
    };
  }
  shiftAppointmentByViewOffset(appointment) {
    const {
      viewOffset
    } = this.options;
    const startDateField = this.dataAccessors.expr.startDateExpr;
    const endDateField = this.dataAccessors.expr.endDateExpr;
    let startDate = new Date(ExpressionUtils.getField(this.dataAccessors, "startDate", appointment));
    startDate = dateUtilsTs.addOffsets(startDate, [-viewOffset]);
    let endDate = new Date(ExpressionUtils.getField(this.dataAccessors, "endDate", appointment));
    endDate = dateUtilsTs.addOffsets(endDate, [-viewOffset]);
    return _extends({}, appointment, {
      [startDateField]: startDate,
      [endDateField]: endDate
    });
  }
};
var m_strategy_base_default = BaseRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_agenda.js
var AgendaRenderingStrategy = class extends m_strategy_base_default {
  get instance() {
    return this.options.instance;
  }
  get agendaDuration() {
    return this.options.agendaDuration;
  }
  getAppointmentMinSize() {
  }
  getDeltaTime() {
  }
  keepAppointmentSettings() {
    return true;
  }
  getAppointmentGeometry(geometry) {
    return geometry;
  }
  groupAppointmentByResources(appointments) {
    const groups = this.instance._getCurrentViewOption("groups");
    const config3 = {
      loadedResources: this.options.loadedResources,
      resources: this.options.resources,
      dataAccessors: this.dataAccessors.resources
    };
    return groupAppointmentsByResources(config3, appointments, groups);
  }
  createTaskPositionMap(appointments) {
    let height;
    let appointmentsByResources;
    this.calculateRows(appointments, this.agendaDuration, this.currentDate);
    if (appointments.length) {
      height = this.instance.fire("getAgendaVerticalStepHeight");
      appointmentsByResources = this.groupAppointmentByResources(appointments);
      let groupedAppts = [];
      each(appointmentsByResources, (i, appts) => {
        let additionalAppointments = [];
        let recurrentIndexes = [];
        each(appts, (index2, appointment) => {
          const recurrenceBatch = this.instance.getAppointmentsInstance()._processRecurrenceAppointment(appointment, index2);
          let appointmentBatch = null;
          if (!recurrenceBatch.indexes.length) {
            appointmentBatch = this.instance.getAppointmentsInstance()._processLongAppointment(appointment);
            additionalAppointments = additionalAppointments.concat(appointmentBatch.parts);
          }
          additionalAppointments = additionalAppointments.concat(recurrenceBatch.parts);
          recurrentIndexes = recurrentIndexes.concat(recurrenceBatch.indexes);
        });
        this.instance.getAppointmentsInstance()._reduceRecurrenceAppointments(recurrentIndexes, appts);
        this.instance.getAppointmentsInstance()._combineAppointments(appts, additionalAppointments);
        groupedAppts = groupedAppts.concat(appts);
      });
      Array.prototype.splice.apply(appointments, [0, appointments.length].concat(groupedAppts));
    }
    const result2 = [];
    let sortedIndex = 0;
    appointments.forEach((appt, index2) => {
      result2.push([{
        height,
        width: "100%",
        sortedIndex: sortedIndex++,
        groupIndex: this._calculateGroupIndex(index2, appointmentsByResources),
        agendaSettings: appt.settings
      }]);
      delete appt.settings;
    });
    return result2;
  }
  _calculateGroupIndex(apptIndex, appointmentsByResources) {
    let resultInd;
    let counter = 0;
    for (const i in appointmentsByResources) {
      const countApptInGroup = appointmentsByResources[i].length;
      if (apptIndex >= counter && apptIndex < counter + countApptInGroup) {
        resultInd = Number(i);
        break;
      }
      counter += countApptInGroup;
    }
    return resultInd;
  }
  _getDeltaWidth(args, initialSize) {
  }
  _getAppointmentMaxWidth() {
    return this.cellWidth;
  }
  _needVerifyItemSize() {
    return false;
  }
  _getAppointmentParts(geometry, settings) {
  }
  _reduceMultiWeekAppointment() {
  }
  calculateAppointmentHeight() {
    return 0;
  }
  calculateAppointmentWidth() {
    return 0;
  }
  isAppointmentGreaterThan(etalon, comparisonParameters) {
  }
  isAllDay() {
    return false;
  }
  _sortCondition() {
  }
  _rowCondition(a, b) {
  }
  _columnCondition(a, b) {
  }
  _findIndexByKey(arr, iKey, jKey, iValue, jValue) {
  }
  _markAppointmentAsVirtual() {
  }
  getDropDownAppointmentWidth() {
  }
  getCollectorLeftOffset() {
  }
  getCollectorTopOffset() {
  }
  replaceWrongAppointmentEndDate(rawAppointment, startDate, endDate) {
    const adapter = createAppointmentAdapter(rawAppointment, this.dataAccessors, this.timeZoneCalculator);
    replaceWrongEndDate(adapter, startDate, endDate, this.cellDuration, this.dataAccessors);
  }
  calculateRows(appointments, agendaDuration, currentDate, needClearSettings) {
    this._rows = [];
    currentDate = date_default.trimTime(new Date(currentDate));
    const groupedAppointments = this.groupAppointmentByResources(appointments);
    each(groupedAppointments, (_, currentAppointments) => {
      const groupResult = [];
      const appts = {
        indexes: [],
        parts: []
      };
      if (!currentAppointments.length) {
        this._rows.push([]);
        return true;
      }
      each(currentAppointments, (index2, appointment) => {
        const startDate = ExpressionUtils.getField(this.dataAccessors, "startDate", appointment);
        const endDate = ExpressionUtils.getField(this.dataAccessors, "endDate", appointment);
        this.replaceWrongAppointmentEndDate(appointment, startDate, endDate);
        needClearSettings && delete appointment.settings;
        const result2 = this.instance.getAppointmentsInstance()._processRecurrenceAppointment(appointment, index2, false);
        appts.parts = appts.parts.concat(result2.parts);
        appts.indexes = appts.indexes.concat(result2.indexes);
      });
      this.instance.getAppointmentsInstance()._reduceRecurrenceAppointments(appts.indexes, currentAppointments);
      currentAppointments.push(...appts.parts);
      const appointmentCount = currentAppointments.length;
      for (let i = 0; i < agendaDuration; i++) {
        const day = new Date(currentDate);
        day.setMilliseconds(day.getMilliseconds() + 864e5 * i);
        if (void 0 === groupResult[i]) {
          groupResult[i] = 0;
        }
        for (let j = 0; j < appointmentCount; j++) {
          const appointmentData = currentAppointments[j].settings || currentAppointments[j];
          const adapter = createAppointmentAdapter(currentAppointments[j], this.dataAccessors, this.timeZoneCalculator);
          const appointmentIsLong = getAppointmentTakesSeveralDays(adapter);
          const appointmentIsRecurrence = ExpressionUtils.getField(this.dataAccessors, "recurrenceRule", currentAppointments[j]);
          if (this.instance.fire("dayHasAppointment", day, appointmentData, true) || !appointmentIsRecurrence && appointmentIsLong && this.instance.fire("dayHasAppointment", day, currentAppointments[j], true)) {
            groupResult[i] += 1;
          }
        }
      }
      this._rows.push(groupResult);
    });
    return this._rows;
  }
  _iterateRow(row, obj, index2) {
    for (let i = 0; i < row.length; i++) {
      obj.counter += row[i];
      if (obj.counter >= index2) {
        obj.indexInRow = i;
        break;
      }
    }
  }
  getDateByIndex(index2, rows, startViewDate) {
    const obj = {
      counter: 0,
      indexInRow: 0
    };
    index2++;
    for (let i = 0; i < rows.length; i++) {
      this._iterateRow(rows[i], obj, index2);
      if (obj.indexInRow) {
        break;
      }
    }
    return new Date(new Date(startViewDate).setDate(startViewDate.getDate() + obj.indexInRow));
  }
  getAppointmentDataCalculator() {
    return ($appointment, originalStartDate) => {
      const apptIndex = $appointment.index();
      const startViewDate = this.instance.getStartViewDate();
      const calculatedStartDate = this.getDateByIndex(apptIndex, this._rows, startViewDate);
      const wrappedOriginalStartDate = new Date(originalStartDate);
      return {
        startDate: new Date(calculatedStartDate.setHours(wrappedOriginalStartDate.getHours(), wrappedOriginalStartDate.getMinutes(), wrappedOriginalStartDate.getSeconds(), wrappedOriginalStartDate.getMilliseconds()))
      };
    };
  }
};
var m_strategy_agenda_default = AgendaRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_horizontal.js
var toMs12 = date_default.dateToMilliseconds;
var HorizontalRenderingStrategy = class extends m_strategy_base_default {
  _needVerifyItemSize() {
    return true;
  }
  calculateAppointmentWidth(appointment, position3) {
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    const allDay = ExpressionUtils.getField(this.dataAccessors, "allDay", appointment);
    const {
      startDate,
      endDate,
      normalizedEndDate
    } = position3.info.appointment;
    let duration = this.getAppointmentDurationInMs(startDate, normalizedEndDate, allDay);
    duration = this._adjustDurationByDaylightDiff(duration, startDate, normalizedEndDate);
    const cellDuration = this.cellDurationInMinutes * toMs12("minute");
    const skippedHours = getSkippedHoursInRange(startDate, endDate, appointment.allDay, this.viewDataProvider);
    const durationInCells = (duration - skippedHours * toMs12("hour")) / cellDuration;
    const width = this.cropAppointmentWidth(durationInCells * cellWidth, cellWidth);
    return width;
  }
  _needAdjustDuration(diff) {
    return diff < 0;
  }
  getAppointmentGeometry(coordinates) {
    const result2 = this._customizeAppointmentGeometry(coordinates);
    return super.getAppointmentGeometry(result2);
  }
  _customizeAppointmentGeometry(coordinates) {
    const config3 = this._calculateGeometryConfig(coordinates);
    return this._customizeCoordinates(coordinates, config3.height, config3.appointmentCountPerCell, config3.offset);
  }
  _getOffsets() {
    return {
      unlimited: 0,
      auto: 0
    };
  }
  _getCompactLeftCoordinate(itemLeft, index2) {
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    return itemLeft + cellWidth * index2;
  }
  _getMaxHeight() {
    return this.cellHeight || this.getAppointmentMinSize();
  }
  _getAppointmentCount(overlappingMode, coordinates) {
    return this._getMaxAppointmentCountPerCellByType(false);
  }
  _getAppointmentDefaultHeight() {
    return 60;
  }
  _getAppointmentMinHeight() {
    return 35;
  }
  _sortCondition(a, b) {
    return this._columnCondition(a, b);
  }
  _getOrientation() {
    return ["left", "right", "top"];
  }
  getDropDownAppointmentWidth(intervalCount, isAllDay) {
    return this.cellWidth - 4;
  }
  getDeltaTime(args, initialSize) {
    let deltaTime = 0;
    const deltaWidth = args.width - initialSize.width;
    deltaTime = toMs12("minute") * Math.round(deltaWidth / this.cellWidth * this.cellDurationInMinutes);
    return deltaTime;
  }
  isAllDay(appointmentData) {
    return ExpressionUtils.getField(this.dataAccessors, "allDay", appointmentData);
  }
  _isItemsCross(firstItem, secondItem) {
    const orientation = this._getOrientation();
    return this._checkItemsCrossing(firstItem, secondItem, orientation);
  }
  getPositionShift(timeShift) {
    const positionShift = super.getPositionShift(timeShift);
    let left = this.cellWidth * timeShift;
    if (this.rtlEnabled) {
      left *= -1;
    }
    left += positionShift.left;
    return {
      top: 0,
      left,
      cellPosition: left
    };
  }
  supportCompactDropDownAppointments() {
    return false;
  }
};
var m_strategy_horizontal_default = HorizontalRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/helpers/m_position_helper.js
var getCellSize = (DOMMetaData) => {
  const {
    dateTableCellsMeta
  } = DOMMetaData;
  const length = null === dateTableCellsMeta || void 0 === dateTableCellsMeta ? void 0 : dateTableCellsMeta.length;
  if (!length) {
    return {
      width: 0,
      height: 0
    };
  }
  const cellIndex = length > 1 ? 1 : 0;
  const cellSize = dateTableCellsMeta[cellIndex][0];
  return {
    width: cellSize.width,
    height: cellSize.height
  };
};
var getMaxAllowedHorizontalPosition = (groupIndex, viewDataProvider, rtlEnabled, DOMMetaData) => {
  const {
    dateTableCellsMeta
  } = DOMMetaData;
  const firstRow = dateTableCellsMeta[0];
  if (!firstRow) {
    return 0;
  }
  const {
    columnIndex
  } = viewDataProvider.getLastGroupCellPosition(groupIndex);
  const cellPosition = firstRow[columnIndex];
  if (!cellPosition) {
    return 0;
  }
  return !rtlEnabled ? cellPosition.left + cellPosition.width : cellPosition.left;
};
var getCellHeight = (DOMMetaData) => getCellSize(DOMMetaData).height;
var getCellWidth = (DOMMetaData) => getCellSize(DOMMetaData).width;
var getAllDayHeight = (showAllDayPanel, isVerticalGrouping, DOMMetaData) => {
  if (!showAllDayPanel) {
    return 0;
  }
  if (isVerticalGrouping) {
    const {
      dateTableCellsMeta
    } = DOMMetaData;
    const length = null === dateTableCellsMeta || void 0 === dateTableCellsMeta ? void 0 : dateTableCellsMeta.length;
    return length ? dateTableCellsMeta[0][0].height : 0;
  }
  const {
    allDayPanelCellsMeta
  } = DOMMetaData;
  return null !== allDayPanelCellsMeta && void 0 !== allDayPanelCellsMeta && allDayPanelCellsMeta.length ? allDayPanelCellsMeta[0].height : 0;
};
var getMaxAllowedPosition = (groupIndex, viewDataProvider, rtlEnabled, DOMMetaData) => {
  const validGroupIndex = groupIndex || 0;
  return getMaxAllowedHorizontalPosition(validGroupIndex, viewDataProvider, rtlEnabled, DOMMetaData);
};
var getGroupWidth = (groupIndex, viewDataProvider, options2) => {
  const {
    isVirtualScrolling,
    rtlEnabled,
    DOMMetaData
  } = options2;
  const cellWidth = getCellWidth(DOMMetaData);
  let result2 = viewDataProvider.getCellCount(options2) * cellWidth;
  if (isVirtualScrolling) {
    const groupedData = viewDataProvider.groupedDataMap.dateTableGroupedMap;
    const groupLength = groupedData[groupIndex][0].length;
    result2 = groupLength * cellWidth;
  }
  const position3 = getMaxAllowedPosition(groupIndex, viewDataProvider, rtlEnabled, DOMMetaData);
  const currentPosition = position3[groupIndex];
  if (currentPosition) {
    if (rtlEnabled) {
      result2 = currentPosition - position3[groupIndex + 1];
    } else if (0 === groupIndex) {
      result2 = currentPosition;
    } else {
      result2 = currentPosition - position3[groupIndex - 1];
    }
  }
  return result2;
};
var PositionHelper = class {
  get viewDataProvider() {
    return this.options.viewDataProvider;
  }
  get rtlEnabled() {
    return this.options.rtlEnabled;
  }
  get isGroupedByDate() {
    return this.options.isGroupedByDate;
  }
  get groupCount() {
    return this.options.groupCount;
  }
  get DOMMetaData() {
    return this.options.getDOMMetaDataCallback();
  }
  constructor(options2) {
    this.options = options2;
    this.groupStrategy = this.options.isVerticalGrouping ? new GroupStrategyBase(this.options) : new GroupStrategyHorizontal(this.options);
  }
  getHorizontalMax(groupIndex) {
    const getMaxPosition = (groupIndex2) => getMaxAllowedPosition(groupIndex2, this.viewDataProvider, this.rtlEnabled, this.DOMMetaData);
    if (this.isGroupedByDate) {
      const viewPortGroupCount = this.viewDataProvider.getViewPortGroupCount();
      return Math.max(getMaxPosition(groupIndex), getMaxPosition(viewPortGroupCount - 1));
    }
    return getMaxPosition(groupIndex);
  }
  getResizableStep() {
    const cellWidth = getCellWidth(this.DOMMetaData);
    if (this.isGroupedByDate) {
      return this.groupCount * cellWidth;
    }
    return cellWidth;
  }
  getVerticalMax(options2) {
    return this.groupStrategy.getVerticalMax(options2);
  }
  getOffsetByAllDayPanel(options2) {
    return this.groupStrategy.getOffsetByAllDayPanel(options2);
  }
  getGroupTop(options2) {
    return this.groupStrategy.getGroupTop(options2);
  }
};
var GroupStrategyBase = class {
  constructor(options2) {
    this.options = options2;
  }
  get viewDataProvider() {
    return this.options.viewDataProvider;
  }
  get isGroupedByDate() {
    return this.options.isGroupedByDate;
  }
  get rtlEnabled() {
    return this.options.rtlEnabled;
  }
  get groupCount() {
    return this.options.groupCount;
  }
  get DOMMetaData() {
    return this.options.getDOMMetaDataCallback();
  }
  getOffsetByAllDayPanel(_ref) {
    let {
      groupIndex,
      supportAllDayRow,
      showAllDayPanel
    } = _ref;
    let result2 = 0;
    if (supportAllDayRow && showAllDayPanel) {
      const allDayPanelHeight = getAllDayHeight(showAllDayPanel, true, this.DOMMetaData);
      result2 = allDayPanelHeight * (groupIndex + 1);
    }
    return result2;
  }
  getVerticalMax(options2) {
    let maxAllowedPosition = this._getMaxAllowedVerticalPosition(_extends({}, options2, {
      viewDataProvider: this.viewDataProvider,
      rtlEnabled: this.rtlEnabled,
      DOMMetaData: this.DOMMetaData
    }));
    maxAllowedPosition += this.getOffsetByAllDayPanel(options2);
    return maxAllowedPosition;
  }
  getGroupTop(_ref2) {
    let {
      groupIndex,
      showAllDayPanel,
      isGroupedAllDayPanel
    } = _ref2;
    const rowCount = this.viewDataProvider.getRowCountInGroup(groupIndex);
    const maxVerticalPosition = this._getMaxAllowedVerticalPosition({
      groupIndex,
      viewDataProvider: this.viewDataProvider,
      showAllDayPanel,
      isGroupedAllDayPanel,
      isVerticalGrouping: true,
      DOMMetaData: this.DOMMetaData
    });
    return maxVerticalPosition - getCellHeight(this.DOMMetaData) * rowCount;
  }
  _getAllDayHeight(showAllDayPanel) {
    return getAllDayHeight(showAllDayPanel, true, this.DOMMetaData);
  }
  _getMaxAllowedVerticalPosition(_ref3) {
    let {
      groupIndex,
      showAllDayPanel,
      isGroupedAllDayPanel
    } = _ref3;
    const {
      rowIndex
    } = this.viewDataProvider.getLastGroupCellPosition(groupIndex);
    const {
      dateTableCellsMeta
    } = this.DOMMetaData;
    const lastGroupRow = dateTableCellsMeta[rowIndex];
    if (!lastGroupRow) {
      return 0;
    }
    let result2 = lastGroupRow[0].top + lastGroupRow[0].height;
    if (isGroupedAllDayPanel) {
      result2 -= (groupIndex + 1) * this._getAllDayHeight(showAllDayPanel);
    }
    return result2;
  }
};
var GroupStrategyHorizontal = class extends GroupStrategyBase {
  getOffsetByAllDayPanel() {
    return 0;
  }
  getVerticalMax(options2) {
    const {
      isVirtualScrolling,
      groupIndex
    } = options2;
    const correctedGroupIndex = isVirtualScrolling ? groupIndex : 0;
    return this._getMaxAllowedVerticalPosition(_extends({}, options2, {
      groupIndex: correctedGroupIndex
    }));
  }
  getGroupTop() {
    return 0;
  }
  _getAllDayHeight(showAllDayPanel) {
    return getAllDayHeight(showAllDayPanel, false, this.DOMMetaData);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_horizontal_month_line.js
var HorizontalMonthLineRenderingStrategy = class extends m_strategy_horizontal_default {
  calculateAppointmentWidth(_, position3) {
    const {
      startDate: startDateWithTime,
      normalizedEndDate
    } = position3.info.appointment;
    const startDate = date_default.trimTime(startDateWithTime);
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    const duration = Math.ceil(this._getDurationInDays(startDate, normalizedEndDate));
    let width = this.cropAppointmentWidth(duration * cellWidth, cellWidth);
    if (this.isVirtualScrolling) {
      const skippedDays = this.viewDataProvider.getSkippedDaysCount(position3.groupIndex, startDate, normalizedEndDate, duration);
      width -= skippedDays * cellWidth;
    }
    return width;
  }
  _columnCondition(a, b) {
    const conditions = this._getConditions(a, b);
    return conditions.rowCondition || conditions.columnCondition || conditions.cellPositionCondition;
  }
  _getDurationInDays(startDate, endDate) {
    const adjustedDuration = this._adjustDurationByDaylightDiff(endDate.getTime() - startDate.getTime(), startDate, endDate);
    return adjustedDuration / date_default.dateToMilliseconds("day") || 1;
  }
  getDeltaTime(args, initialSize) {
    return 864e5 * this._getDeltaWidth(args, initialSize);
  }
  isAllDay() {
    return false;
  }
  createTaskPositionMap(items, skipSorting) {
    if (!skipSorting) {
      sortAppointmentsByStartDate(items, this.dataAccessors);
    }
    return super.createTaskPositionMap(items);
  }
  _getSortedPositions(map2, skipSorting) {
    let result2 = super._getSortedPositions(map2);
    if (!skipSorting) {
      result2 = query_default(result2).sortBy("top").thenBy("left").thenBy("cellPosition").thenBy("i").toArray();
    }
    return result2;
  }
  needCorrectAppointmentDates() {
    return false;
  }
  getPositionShift(timeShift) {
    return {
      top: 0,
      left: 0,
      cellPosition: timeShift * this.cellWidth
    };
  }
};
var m_strategy_horizontal_month_line_default = HorizontalMonthLineRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_horizontal_month.js
var toMs13 = date_default.dateToMilliseconds;
var HorizontalMonthRenderingStrategy = class extends m_strategy_horizontal_month_line_default {
  get endViewDate() {
    return this.options.endViewDate;
  }
  get adaptivityEnabled() {
    return this.options.adaptivityEnabled;
  }
  get DOMMetaData() {
    return this.options.DOMMetaData;
  }
  _getLeftPosition(settings) {
    const fullWeekAppointmentWidth = this.getGroupWidth(settings.groupIndex);
    return this._calculateMultiWeekAppointmentLeftOffset(settings.hMax, fullWeekAppointmentWidth);
  }
  _getChunkCount(fullChunksWidth, firstChunkWidth, weekWidth, settings) {
    const {
      groupIndex,
      info: {
        appointment: {
          startDate
        }
      }
    } = settings;
    const rawFullChunksWidth = fullChunksWidth - firstChunkWidth + weekWidth;
    const allChunksCount = Math.ceil(rawFullChunksWidth / weekWidth);
    const viewRowIndex = this._tryGetRowIndexInView(startDate);
    if (void 0 !== viewRowIndex) {
      const viewChunksCount = this.viewDataProvider.getRowCountInGroup(groupIndex);
      const allowedChunksCount = viewChunksCount - viewRowIndex;
      return allChunksCount <= allowedChunksCount ? allChunksCount : allowedChunksCount;
    }
    return allChunksCount;
  }
  _tryGetRowIndexInView(positionStartDate) {
    var _this$options$dataRan;
    const columnsCount = this.viewDataProvider.getColumnsCount();
    if ((null === (_this$options$dataRan = this.options.dataRange) || void 0 === _this$options$dataRan ? void 0 : _this$options$dataRan.length) < 1 || !columnsCount) {
      return;
    }
    const [startViewDate] = this.options.dateRange;
    const dayDurationMs = toMs13("day");
    const timeFromStart = positionStartDate.getTime() - startViewDate.getTime();
    return Math.floor(timeFromStart / dayDurationMs / columnsCount);
  }
  _getChunkWidths(geometry, settings, weekWidth) {
    const firstChunkWidth = geometry.reducedWidth;
    const fullChunksWidth = Math.floor(geometry.sourceAppointmentWidth);
    const widthWithoutFirstChunk = fullChunksWidth - firstChunkWidth;
    return [firstChunkWidth, fullChunksWidth, widthWithoutFirstChunk];
  }
  _getTailChunkSettings(withoutFirstChunkWidth, weekWidth, leftPosition) {
    const tailChunkWidth = withoutFirstChunkWidth % weekWidth || weekWidth;
    const rtlPosition = leftPosition + (weekWidth - tailChunkWidth);
    const tailChunkLeftPosition = this.rtlEnabled ? rtlPosition : leftPosition;
    return [tailChunkWidth, tailChunkLeftPosition];
  }
  _getAppointmentParts(geometry, settings) {
    const result2 = [];
    const weekWidth = Math.round(this.getGroupWidth(settings.groupIndex));
    const [firstChunkWidth, fullChunksWidth, withoutFirstChunkWidth] = this._getChunkWidths(geometry, settings, weekWidth);
    const leftPosition = this._getLeftPosition(settings);
    const {
      endDate
    } = settings.info.appointment;
    const hasTailChunk = this.endViewDate > endDate;
    const chunkCount = this._getChunkCount(fullChunksWidth, firstChunkWidth, weekWidth, settings);
    const [tailChunkWidth, tailChunkLeftPosition] = this._getTailChunkSettings(withoutFirstChunkWidth, weekWidth, leftPosition);
    for (let chunkIndex = 1; chunkIndex < chunkCount; chunkIndex++) {
      const topPosition = settings.top + this.cellHeight * chunkIndex;
      const isTailChunk = hasTailChunk && chunkIndex === chunkCount - 1;
      result2.push(_extends({}, settings, {
        top: topPosition,
        left: isTailChunk ? tailChunkLeftPosition : leftPosition,
        height: geometry.height,
        width: isTailChunk ? tailChunkWidth : weekWidth,
        appointmentReduced: isTailChunk ? "tail" : "body",
        rowIndex: ++settings.rowIndex,
        columnIndex: 0
      }));
    }
    return result2;
  }
  _calculateMultiWeekAppointmentLeftOffset(max, width) {
    return this.rtlEnabled ? max : max - width;
  }
  getGroupWidth(groupIndex) {
    return getGroupWidth(groupIndex, this.viewDataProvider, {
      intervalCount: this.options.intervalCount,
      currentDate: this.options.currentDate,
      viewType: this.options.viewType,
      hoursInterval: this.options.hoursInterval,
      startDayHour: this.options.startDayHour,
      endDayHour: this.options.endDayHour,
      isVirtualScrolling: this.isVirtualScrolling,
      rtlEnabled: this.rtlEnabled,
      DOMMetaData: this.DOMMetaData
    });
  }
  _getAppointmentDefaultHeight() {
    return this._getAppointmentHeightByTheme();
  }
  _getAppointmentMinHeight() {
    return this._getAppointmentDefaultHeight();
  }
  createTaskPositionMap(items) {
    return super.createTaskPositionMap(items, true);
  }
  _getSortedPositions(map2) {
    return super._getSortedPositions(map2, true);
  }
  _getDefaultRatio() {
    return 0.6;
  }
  _getOffsets() {
    return {
      unlimited: 26,
      auto: 30
    };
  }
  getDropDownAppointmentWidth(intervalCount, isAllDay) {
    if (this.adaptivityEnabled) {
      return this.getDropDownButtonAdaptiveSize();
    }
    const offset2 = intervalCount > 1 ? 60 : 36;
    return this.cellWidth - offset2;
  }
  needCorrectAppointmentDates() {
    return false;
  }
  _needVerticalGroupBounds() {
    return false;
  }
  _needHorizontalGroupBounds() {
    return true;
  }
};
var m_strategy_horizontal_month_default = HorizontalMonthRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_vertical.js
var toMs14 = date_default.dateToMilliseconds;
var VerticalRenderingStrategy = class extends m_strategy_base_default {
  getDeltaTime(args, initialSize, appointment) {
    let deltaTime = 0;
    if (this.isAllDay(appointment)) {
      deltaTime = this._getDeltaWidth(args, initialSize) * toMs14("day");
    } else {
      const deltaHeight = args.height - initialSize.height;
      deltaTime = toMs14("minute") * Math.round(deltaHeight / this.cellHeight * this.cellDurationInMinutes);
    }
    return deltaTime;
  }
  _correctCollectorCoordinatesInAdaptive(coordinates, isAllDay) {
    if (isAllDay) {
      super._correctCollectorCoordinatesInAdaptive(coordinates, isAllDay);
    } else if (0 === this._getMaxAppointmentCountPerCellByType()) {
      const {
        cellHeight
      } = this;
      const {
        cellWidth
      } = this;
      coordinates.top += (cellHeight - this.getDropDownButtonAdaptiveSize()) / 2;
      coordinates.left += (cellWidth - this.getDropDownButtonAdaptiveSize()) / 2;
    }
  }
  getAppointmentGeometry(coordinates) {
    let geometry = null;
    if (coordinates.allDay) {
      geometry = this._getAllDayAppointmentGeometry(coordinates);
    } else {
      geometry = this.isAdaptive && coordinates.isCompact ? this._getAdaptiveGeometry(coordinates) : this._getVerticalAppointmentGeometry(coordinates);
    }
    return super.getAppointmentGeometry(geometry);
  }
  _getAdaptiveGeometry(coordinates) {
    const config3 = this._calculateGeometryConfig(coordinates);
    return this._customizeCoordinates(coordinates, config3.height, config3.appointmentCountPerCell, config3.offset);
  }
  _getItemPosition(initialAppointment) {
    const allDay = this.isAllDay(initialAppointment);
    if (allDay) {
      return super._getItemPosition(initialAppointment);
    }
    const appointment = super.shiftAppointmentByViewOffset(initialAppointment);
    const adapter = createAppointmentAdapter(appointment, this.dataAccessors, this.timeZoneCalculator);
    const isRecurring = !!adapter.recurrenceRule;
    const appointmentStartDate = adapter.calculateStartDate("toGrid");
    const appointmentEndDate = adapter.calculateEndDate("toGrid");
    const appointmentDuration = appointmentEndDate - appointmentStartDate;
    const appointmentBeginInCurrentView = this.options.startViewDate < appointmentStartDate;
    const isAppointmentTakesSeveralDays = !m_utils_time_zone_default.isSameAppointmentDates(appointmentStartDate, appointmentEndDate);
    const settings = this.generateAppointmentSettings(appointment);
    let result2 = [];
    for (let j = 0; j < settings.length; j++) {
      const currentSetting = settings[j];
      const height = this.calculateAppointmentHeight(appointment, currentSetting);
      const width = this.calculateAppointmentWidth(appointment, currentSetting);
      let resultHeight = height;
      let appointmentReduced = null;
      let multiDaysAppointmentParts = [];
      const currentMaxAllowedPosition = currentSetting.vMax;
      if (this._isMultiViewAppointment(currentSetting, height) || isAppointmentTakesSeveralDays && !isRecurring) {
        const trimmedStartDate = date_default.trimTime(appointmentStartDate);
        const trimmedSettingStartDate = date_default.trimTime(currentSetting.info.appointment.startDate);
        const reduceHead = trimmedStartDate <= trimmedSettingStartDate || isRecurring;
        if (reduceHead) {
          resultHeight = this._reduceMultiDayAppointment(height, {
            top: currentSetting.top,
            bottom: currentMaxAllowedPosition
          });
          multiDaysAppointmentParts = this._getAppointmentParts({
            sourceAppointmentHeight: height,
            reducedHeight: resultHeight,
            width
          }, currentSetting);
        }
        const {
          startDate: currentSettingStartDate,
          normalizedEndDate: currentSettingNormalizedEndDate
        } = currentSetting.info.appointment;
        const currentSettingDuration = currentSettingNormalizedEndDate - currentSettingStartDate;
        const hasNextParts = currentSettingDuration < appointmentDuration;
        appointmentReduced = hasNextParts ? appointmentBeginInCurrentView ? "head" : "body" : appointmentBeginInCurrentView ? "head" : "tail";
      }
      extend(currentSetting, {
        height: resultHeight,
        width,
        allDay,
        appointmentReduced
      });
      result2 = this._getAppointmentPartsPosition(multiDaysAppointmentParts, currentSetting, result2);
    }
    return result2;
  }
  _isMultiViewAppointment(_ref, height) {
    let {
      vMax,
      top
    } = _ref;
    const fullAppointmentHeight = roundFloatPart(height, 2);
    const remainingHeight = roundFloatPart(vMax - top, 2);
    return fullAppointmentHeight > remainingHeight;
  }
  _reduceMultiDayAppointment(sourceAppointmentHeight, bound) {
    return Math.min(sourceAppointmentHeight, bound.bottom - Math.floor(bound.top));
  }
  _getGroupHeight() {
    return this.cellHeight * this.rowCount;
  }
  _getGroupTopOffset(appointmentSettings) {
    const {
      groupIndex
    } = appointmentSettings;
    const groupTop = Math.max(0, this.positionHelper.getGroupTop({
      groupIndex,
      showAllDayPanel: this.showAllDayPanel,
      isGroupedAllDayPanel: this.isGroupedAllDayPanel
    }));
    const allDayPanelOffset = this.positionHelper.getOffsetByAllDayPanel({
      groupIndex,
      supportAllDayRow: this.allDaySupported(),
      showAllDayPanel: this.showAllDayPanel
    });
    const appointmentGroupTopOffset = appointmentSettings.top - groupTop - allDayPanelOffset;
    return appointmentGroupTopOffset;
  }
  _getTailHeight(appointmentGeometry, appointmentSettings) {
    if (!this.isVirtualScrolling) {
      return appointmentGeometry.sourceAppointmentHeight - appointmentGeometry.reducedHeight;
    }
    const appointmentGroupTopOffset = this._getGroupTopOffset(appointmentSettings);
    const {
      sourceAppointmentHeight
    } = appointmentGeometry;
    const groupHeight = this._getGroupHeight();
    const tailHeight = appointmentGroupTopOffset + sourceAppointmentHeight - groupHeight;
    return tailHeight;
  }
  _getAppointmentParts(appointmentGeometry, appointmentSettings) {
    const {
      width
    } = appointmentGeometry;
    const result2 = [];
    let currentPartTop = Math.max(0, this.positionHelper.getGroupTop({
      groupIndex: appointmentSettings.groupIndex,
      showAllDayPanel: this.showAllDayPanel,
      isGroupedAllDayPanel: this.isGroupedAllDayPanel
    }));
    const cellsDiff = this.isGroupedByDate ? this.groupCount : 1;
    const offset2 = this.cellWidth * cellsDiff;
    const allDayPanelOffset = this.positionHelper.getOffsetByAllDayPanel({
      groupIndex: appointmentSettings.groupIndex,
      supportAllDayRow: this.allDaySupported(),
      showAllDayPanel: this.showAllDayPanel
    });
    currentPartTop += allDayPanelOffset;
    const minHeight = this.getAppointmentMinSize();
    const {
      hMax,
      vMax,
      vMin
    } = appointmentSettings;
    const maxHeight = this.isVirtualScrolling ? vMax : vMax - vMin;
    const hasTailPart = this.options.endViewDate > appointmentSettings.info.appointment.endDate;
    let left = Math.round(appointmentSettings.left + offset2);
    let tailHeight = this._getTailHeight(appointmentGeometry, appointmentSettings);
    let {
      columnIndex
    } = appointmentSettings;
    while (tailHeight > 0 && left < hMax) {
      tailHeight = Math.max(minHeight, tailHeight);
      columnIndex += cellsDiff;
      const height = Math.min(tailHeight, maxHeight);
      result2.push(_extends({}, appointmentSettings, {
        top: currentPartTop,
        left,
        height,
        width,
        appointmentReduced: "body",
        rowIndex: 0,
        columnIndex
      }));
      left += offset2;
      tailHeight -= maxHeight;
    }
    if (hasTailPart && result2.length > 0) {
      result2[result2.length - 1].appointmentReduced = "tail";
    }
    return result2;
  }
  _getMinuteHeight() {
    return this.cellHeight / this.cellDurationInMinutes;
  }
  _getCompactLeftCoordinate(itemLeft, index2) {
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    return itemLeft + (1 + cellWidth) * index2;
  }
  _getVerticalAppointmentGeometry(coordinates) {
    const config3 = this._calculateVerticalGeometryConfig(coordinates);
    return this._customizeVerticalCoordinates(coordinates, config3.width, config3.appointmentCountPerCell, config3.offset);
  }
  _customizeVerticalCoordinates(coordinates, width, appointmentCountPerCell, topOffset, isAllDay) {
    const appointmentWidth = Math.max(width / appointmentCountPerCell, width / coordinates.count);
    const {
      height
    } = coordinates;
    const appointmentLeft = coordinates.left + coordinates.index * appointmentWidth;
    const {
      top
    } = coordinates;
    if (coordinates.isCompact) {
      this._markAppointmentAsVirtual(coordinates, isAllDay);
    }
    return {
      height,
      width: appointmentWidth,
      top,
      left: appointmentLeft,
      empty: this._isAppointmentEmpty(height, width)
    };
  }
  _calculateVerticalGeometryConfig(coordinates) {
    const overlappingMode = this.maxAppointmentsPerCell;
    const offsets = this._getOffsets();
    const appointmentDefaultOffset = this._getAppointmentDefaultOffset();
    let appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);
    let ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);
    let maxWidth = this._getMaxWidth();
    if (!appointmentCountPerCell) {
      appointmentCountPerCell = coordinates.count;
      ratio = (maxWidth - offsets.unlimited) / maxWidth;
    }
    let topOffset = (1 - ratio) * maxWidth;
    if ("auto" === overlappingMode || isNumeric(overlappingMode)) {
      ratio = 1;
      maxWidth -= appointmentDefaultOffset;
      topOffset = 0;
    }
    return {
      width: ratio * maxWidth,
      appointmentCountPerCell,
      offset: topOffset
    };
  }
  _getMaxWidth() {
    return this.cellWidth;
  }
  isAllDay(appointmentData) {
    return getAppointmentTakesAllDay(createAppointmentAdapter(appointmentData, this.dataAccessors, this.timeZoneCalculator), this.allDayPanelMode);
  }
  _getAppointmentMaxWidth() {
    return this.cellWidth - this._getAppointmentDefaultOffset();
  }
  calculateAppointmentWidth(appointment, position3) {
    if (!this.isAllDay(appointment)) {
      return 0;
    }
    const {
      startDate: startDateWithTime,
      endDate,
      normalizedEndDate
    } = position3.info.appointment;
    const startDate = date_default.trimTime(startDateWithTime);
    const cellWidth = this.cellWidth || this.getAppointmentMinSize();
    const durationInHours = (normalizedEndDate.getTime() - startDate.getTime()) / toMs14("hour");
    const skippedHours = getSkippedHoursInRange(startDate, endDate, appointment.allDay, this.viewDataProvider);
    let width = Math.ceil((durationInHours - skippedHours) / 24) * cellWidth;
    width = this.cropAppointmentWidth(width, cellWidth);
    return width;
  }
  calculateAppointmentHeight(appointment, position3) {
    if (this.isAllDay(appointment)) {
      return 0;
    }
    const {
      startDate,
      normalizedEndDate
    } = position3.info.appointment;
    const allDay = ExpressionUtils.getField(this.dataAccessors, "allDay", appointment);
    const duration = this.getAppointmentDurationInMs(startDate, normalizedEndDate, allDay);
    const skippedMinutes = 60 * getSkippedHoursInRange(startDate, normalizedEndDate, appointment.allDay, this.viewDataProvider);
    const durationInMinutes = this._adjustDurationByDaylightDiff(duration, startDate, normalizedEndDate) / toMs14("minute") - skippedMinutes;
    const height = durationInMinutes * this._getMinuteHeight();
    return height;
  }
  getDirection() {
    return "vertical";
  }
  _sortCondition(a, b) {
    if (!!a.allDay !== !!b.allDay) {
      return a.allDay ? 1 : -1;
    }
    const isAllDay = a.allDay && b.allDay;
    return "vertical" === this.groupOrientation && isAllDay ? this._columnCondition(a, b) : this._rowCondition(a, b);
  }
  allDaySupported() {
    return true;
  }
  _getAllDayAppointmentGeometry(coordinates) {
    const config3 = this._calculateGeometryConfig(coordinates);
    return this._customizeCoordinates(coordinates, config3.height, config3.appointmentCountPerCell, config3.offset, true);
  }
  _calculateGeometryConfig(coordinates) {
    if (!this.allowResizing || !this.allowAllDayResizing) {
      coordinates.skipResizing = true;
    }
    const config3 = super._calculateGeometryConfig(coordinates);
    const minAppointmentCountPerCell = Math.min(config3.appointmentCountPerCell, this._getDynamicAppointmentCountPerCell().allDay);
    if (coordinates.allDay && coordinates.count <= minAppointmentCountPerCell) {
      config3.offset = 0;
    }
    return config3;
  }
  _getAppointmentCount(overlappingMode, coordinates) {
    return "auto" !== overlappingMode && 1 === coordinates.count && !isNumeric(overlappingMode) ? coordinates.count : this._getMaxAppointmentCountPerCellByType(coordinates.allDay);
  }
  _getDefaultRatio(coordinates, appointmentCountPerCell) {
    return coordinates.count > this.appointmentCountPerCell ? 0.65 : 1;
  }
  _getOffsets() {
    return {
      unlimited: 5,
      auto: 20
    };
  }
  _getMaxHeight() {
    return this.allDayHeight || this.getAppointmentMinSize();
  }
  _needVerticalGroupBounds(allDay) {
    return !allDay;
  }
  _needHorizontalGroupBounds() {
    return false;
  }
  getPositionShift(timeShift, isAllDay) {
    if (!isAllDay && this.isAdaptive && 0 === this._getMaxAppointmentCountPerCellByType(isAllDay)) {
      return {
        top: 0,
        left: 0,
        cellPosition: 0
      };
    }
    return super.getPositionShift(timeShift, isAllDay);
  }
};
var m_strategy_vertical_default = VerticalRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/rendering_strategies/m_strategy_week.js
var WeekAppointmentRenderingStrategy = class extends m_strategy_vertical_default {
  isApplyCompactAppointmentOffset() {
    if (this.isAdaptive && 0 === this._getMaxAppointmentCountPerCellByType()) {
      return false;
    }
    return this.supportCompactDropDownAppointments();
  }
};
var m_strategy_week_default = WeekAppointmentRenderingStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/appointments/m_view_model_generator.js
var RENDERING_STRATEGIES = {
  horizontal: m_strategy_horizontal_default,
  horizontalMonth: m_strategy_horizontal_month_default,
  horizontalMonthLine: m_strategy_horizontal_month_line_default,
  vertical: m_strategy_vertical_default,
  week: m_strategy_week_default,
  agenda: m_strategy_agenda_default
};
var AppointmentViewModelGenerator = class {
  initRenderingStrategy(options2) {
    const RenderingStrategy = RENDERING_STRATEGIES[options2.appointmentRenderingStrategyName];
    this.renderingStrategy = new RenderingStrategy(options2);
  }
  generate(filteredItems, options2) {
    const {
      viewOffset
    } = options2;
    const appointments = filteredItems ? filteredItems.slice() : [];
    this.initRenderingStrategy(options2);
    const renderingStrategy = this.getRenderingStrategy();
    const positionMap = renderingStrategy.createTaskPositionMap(appointments);
    const shiftedViewModel = this.postProcess(appointments, positionMap);
    const viewModel = this.unshiftViewModelAppointmentsByViewOffset(shiftedViewModel, viewOffset);
    return {
      positionMap,
      viewModel
    };
  }
  postProcess(filteredItems, positionMap) {
    const renderingStrategy = this.getRenderingStrategy();
    return filteredItems.map((data2, index2) => {
      if (!renderingStrategy.keepAppointmentSettings()) {
        delete data2.settings;
      }
      const appointmentSettings = positionMap[index2];
      appointmentSettings.forEach((item2) => {
        item2.direction = "vertical" === renderingStrategy.getDirection() && !item2.allDay ? "vertical" : "horizontal";
      });
      const item = {
        itemData: data2,
        settings: appointmentSettings
      };
      item.needRepaint = true;
      item.needRemove = false;
      return item;
    });
  }
  makeRenovatedViewModels(viewModel, supportAllDayRow, isVerticalGrouping) {
    const strategy4 = this.getRenderingStrategy();
    const regularViewModels = [];
    const allDayViewModels = [];
    const compactOptions = [];
    const isAllDayPanel = supportAllDayRow && !isVerticalGrouping;
    viewModel.forEach((_ref) => {
      let {
        itemData,
        settings
      } = _ref;
      settings.forEach((options2) => {
        const item = this.prepareViewModel(options2, strategy4, itemData);
        if (options2.isCompact) {
          compactOptions.push({
            compactViewModel: options2.virtual,
            appointmentViewModel: item
          });
        } else if (options2.allDay && isAllDayPanel) {
          allDayViewModels.push(item);
        } else {
          regularViewModels.push(item);
        }
      });
    });
    const compactViewModels = this.prepareCompactViewModels(compactOptions, supportAllDayRow);
    const result2 = _extends({
      allDay: allDayViewModels,
      regular: regularViewModels
    }, compactViewModels);
    return result2;
  }
  prepareViewModel(options2, strategy4, itemData) {
    const geometry = strategy4.getAppointmentGeometry(options2);
    const viewModel = {
      key: getAppointmentKey(geometry),
      appointment: itemData,
      geometry: _extends({}, geometry, {
        leftVirtualWidth: options2.leftVirtualWidth,
        topVirtualHeight: options2.topVirtualHeight
      }),
      info: _extends({}, options2.info, {
        allDay: options2.allDay,
        direction: options2.direction,
        appointmentReduced: options2.appointmentReduced,
        groupIndex: options2.groupIndex
      })
    };
    return viewModel;
  }
  getCompactViewModelFrame(compactViewModel) {
    return {
      isAllDay: !!compactViewModel.isAllDay,
      isCompact: compactViewModel.isCompact,
      groupIndex: compactViewModel.groupIndex,
      geometry: {
        left: compactViewModel.left,
        top: compactViewModel.top,
        width: compactViewModel.width,
        height: compactViewModel.height
      },
      items: {
        colors: [],
        data: [],
        settings: []
      }
    };
  }
  prepareCompactViewModels(compactOptions, supportAllDayRow) {
    const regularCompact = {};
    const allDayCompact = {};
    compactOptions.forEach((_ref2) => {
      let {
        compactViewModel,
        appointmentViewModel
      } = _ref2;
      const {
        index: index2,
        isAllDay
      } = compactViewModel;
      const viewModel = isAllDay && supportAllDayRow ? allDayCompact : regularCompact;
      if (!viewModel[index2]) {
        viewModel[index2] = this.getCompactViewModelFrame(compactViewModel);
      }
      const {
        settings,
        data: data2,
        colors
      } = viewModel[index2].items;
      settings.push(appointmentViewModel);
      data2.push(appointmentViewModel.appointment);
      colors.push(appointmentViewModel.info.resourceColor);
    });
    const toArray2 = (items) => Object.keys(items).map((key) => _extends({
      key
    }, items[key]));
    const allDayViewModels = toArray2(allDayCompact);
    const regularViewModels = toArray2(regularCompact);
    return {
      allDayCompact: allDayViewModels,
      regularCompact: regularViewModels
    };
  }
  getRenderingStrategy() {
    return this.renderingStrategy;
  }
  unshiftViewModelAppointmentsByViewOffset(viewModel, viewOffset) {
    const processedAppointments = /* @__PURE__ */ new Set();
    for (const model of viewModel) {
      for (const setting of model.settings ?? []) {
        var _setting$info;
        const appointment = null === setting || void 0 === setting || null === (_setting$info = setting.info) || void 0 === _setting$info ? void 0 : _setting$info.appointment;
        if (appointment && !processedAppointments.has(appointment)) {
          appointment.startDate = dateUtilsTs.addOffsets(appointment.startDate, [viewOffset]);
          appointment.endDate = dateUtilsTs.addOffsets(appointment.endDate, [viewOffset]);
          appointment.normalizedEndDate = dateUtilsTs.addOffsets(appointment.normalizedEndDate, [viewOffset]);
          processedAppointments.add(appointment);
        }
      }
    }
    return viewModel;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_appointments_layout_manager.js
var toMs15 = date_default.dateToMilliseconds;
var AppointmentLayoutManager = class {
  constructor(instance) {
    this.instance = instance;
    this.appointmentViewModel = new AppointmentViewModelGenerator();
  }
  get appointmentRenderingStrategyName() {
    return getAppointmentRenderingStrategyName(this.instance.currentViewType);
  }
  getCellDimensions(options2) {
    if (this.instance._workSpace) {
      return {
        width: this.instance._workSpace.getCellWidth(),
        height: this.instance._workSpace.getCellHeight(),
        allDayHeight: this.instance._workSpace.getAllDayHeight()
      };
    }
    return;
  }
  _getRenderingStrategyOptions() {
    const workspace = this.instance.getWorkSpace();
    const {
      virtualScrollingDispatcher
    } = this.instance.getWorkSpace();
    const {
      cellCountInsideLeftVirtualCell,
      cellCountInsideTopVirtualRow
    } = virtualScrollingDispatcher;
    const groupCount = getGroupCount(this.instance.option("loadedResources"));
    const DOMMetaData = workspace.getDOMElementsMetaData();
    const allDayHeight = getAllDayHeight(workspace.option("showAllDayPanel"), workspace._isVerticalGroupedWorkSpace(), DOMMetaData);
    const rowCount = workspace._getRowCount();
    const {
      positionHelper,
      viewDataProvider
    } = workspace;
    const visibleDayDuration = viewDataProvider.getVisibleDayDuration(workspace.option("startDayHour"), workspace.option("endDayHour"), workspace.option("hoursInterval"));
    const cellDuration = getCellDuration(workspace.type, workspace.option("startDayHour"), workspace.option("endDayHour"), workspace.option("hoursInterval"));
    return {
      resources: this.instance.option("resources"),
      loadedResources: this.instance.option("loadedResources"),
      getAppointmentColor: this.instance.createGetAppointmentColor(),
      dataAccessors: this.instance._dataAccessors,
      appointmentRenderingStrategyName: this.appointmentRenderingStrategyName,
      adaptivityEnabled: this.instance.option("adaptivityEnabled"),
      rtlEnabled: this.instance.option("rtlEnabled"),
      startDayHour: this.instance._getCurrentViewOption("startDayHour"),
      endDayHour: this.instance._getCurrentViewOption("endDayHour"),
      viewOffset: this.instance._getCurrentViewOption("offset") * toMs15("minute"),
      maxAppointmentsPerCell: this.instance._getCurrentViewOption("maxAppointmentsPerCell"),
      currentDate: this.instance.option("currentDate"),
      isVirtualScrolling: this.instance.isVirtualScrolling(),
      leftVirtualCellCount: cellCountInsideLeftVirtualCell,
      topVirtualCellCount: cellCountInsideTopVirtualRow,
      intervalCount: workspace.option("intervalCount"),
      hoursInterval: workspace.option("hoursInterval"),
      showAllDayPanel: workspace.option("showAllDayPanel"),
      isGroupedAllDayPanel: workspace.isGroupedAllDayPanel(),
      groups: this.instance._getCurrentViewOption("groups"),
      groupCount,
      rowCount,
      appointmentCountPerCell: this.instance.option("_appointmentCountPerCell"),
      appointmentOffset: this.instance.option("_appointmentOffset"),
      allowResizing: this.instance._allowResizing(),
      allowAllDayResizing: this.instance._allowAllDayResizing(),
      startViewDate: workspace.getStartViewDate(),
      groupOrientation: workspace._getRealGroupOrientation(),
      cellWidth: getCellWidth(DOMMetaData),
      cellHeight: getCellHeight(DOMMetaData),
      allDayHeight,
      resizableStep: positionHelper.getResizableStep(),
      visibleDayDuration,
      allDayPanelMode: this.instance._getCurrentViewOption("allDayPanelMode"),
      timeZoneCalculator: this.instance.timeZoneCalculator,
      timeZone: this.instance.option("timeZone"),
      firstDayOfWeek: this.instance.getFirstDayOfWeek(),
      viewStartDayHour: this.instance._getCurrentViewOption("startDayHour"),
      viewEndDayHour: this.instance._getCurrentViewOption("endDayHour"),
      viewType: workspace.type,
      endViewDate: workspace.getEndViewDate(),
      positionHelper,
      isGroupedByDate: workspace.isGroupedByDate(),
      cellDuration,
      cellDurationInMinutes: workspace.option("cellDuration"),
      viewDataProvider: workspace.viewDataProvider,
      supportAllDayRow: workspace.supportAllDayRow(),
      dateRange: workspace.getDateRange(),
      intervalDuration: workspace.getIntervalDuration(),
      allDayIntervalDuration: workspace.getIntervalDuration(true),
      isVerticalGroupOrientation: workspace.isVerticalOrientation(),
      DOMMetaData,
      instance: this.instance,
      agendaDuration: workspace.option("agendaDuration")
    };
  }
  createAppointmentsMap(items) {
    const renderingStrategyOptions = this._getRenderingStrategyOptions();
    const {
      viewModel,
      positionMap
    } = this.appointmentViewModel.generate(items, renderingStrategyOptions);
    this._positionMap = positionMap;
    return viewModel;
  }
  _isDataChanged(data2) {
    const {
      appointmentDataProvider
    } = this.instance;
    const updatedData = appointmentDataProvider.getUpdatedAppointment();
    return updatedData === data2 || appointmentDataProvider.getUpdatedAppointmentKeys().some((item) => data2[item.key] === item.value);
  }
  _isAppointmentShouldAppear(currentAppointment, sourceAppointment) {
    return currentAppointment.needRepaint && sourceAppointment.needRemove;
  }
  _isSettingChanged(settings, sourceSetting) {
    if (settings.length !== sourceSetting.length) {
      return true;
    }
    const createSettingsToCompare = (settings2, index2) => {
      const currentSetting = settings2[index2];
      const leftVirtualCellCount = currentSetting.leftVirtualCellCount || 0;
      const topVirtualCellCount = currentSetting.topVirtualCellCount || 0;
      const columnIndex = currentSetting.columnIndex + leftVirtualCellCount;
      const rowIndex = currentSetting.rowIndex + topVirtualCellCount;
      const hMax = currentSetting.reduced ? currentSetting.hMax : void 0;
      const vMax = currentSetting.reduced ? currentSetting.vMax : void 0;
      return _extends({}, currentSetting, {
        columnIndex,
        rowIndex,
        positionByMap: void 0,
        topVirtualCellCount: void 0,
        leftVirtualCellCount: void 0,
        leftVirtualWidth: void 0,
        topVirtualHeight: void 0,
        hMax,
        vMax,
        info: {}
      });
    };
    for (let i = 0; i < settings.length; i++) {
      const newSettings = createSettingsToCompare(settings, i);
      const oldSettings = createSettingsToCompare(sourceSetting, i);
      if (oldSettings) {
        oldSettings.sortedIndex = newSettings.sortedIndex;
      }
      if (!equalByValue(newSettings, oldSettings)) {
        return true;
      }
    }
    return false;
  }
  _getAssociatedSourceAppointment(currentAppointment, sourceAppointments) {
    for (let i = 0; i < sourceAppointments.length; i++) {
      const item = sourceAppointments[i];
      if (item.itemData === currentAppointment.itemData) {
        return item;
      }
    }
    return null;
  }
  _getDeletedAppointments(currentAppointments, sourceAppointments) {
    const result2 = [];
    for (let i = 0; i < sourceAppointments.length; i++) {
      const sourceAppointment = sourceAppointments[i];
      const currentAppointment = this._getAssociatedSourceAppointment(sourceAppointment, currentAppointments);
      if (!currentAppointment) {
        sourceAppointment.needRemove = true;
        result2.push(sourceAppointment);
      }
    }
    return result2;
  }
  getRepaintedAppointments(currentAppointments, sourceAppointments) {
    if (0 === sourceAppointments.length || "agenda" === this.appointmentRenderingStrategyName) {
      return currentAppointments;
    }
    currentAppointments.forEach((appointment) => {
      const sourceAppointment = this._getAssociatedSourceAppointment(appointment, sourceAppointments);
      if (sourceAppointment) {
        const isDataChanged = this._isDataChanged(appointment.itemData);
        const isSettingChanged = this._isSettingChanged(appointment.settings, sourceAppointment.settings);
        const isAppointmentShouldAppear = this._isAppointmentShouldAppear(appointment, sourceAppointment);
        appointment.needRepaint = isDataChanged || isSettingChanged || isAppointmentShouldAppear;
      }
    });
    return currentAppointments.concat(this._getDeletedAppointments(currentAppointments, sourceAppointments));
  }
  getRenderingStrategyInstance() {
    const renderingStrategy = this.appointmentViewModel.getRenderingStrategy();
    if (!renderingStrategy) {
      const options2 = this._getRenderingStrategyOptions();
      this.appointmentViewModel.initRenderingStrategy(options2);
    }
    return this.appointmentViewModel.getRenderingStrategy();
  }
};
var m_appointments_layout_manager_default = AppointmentLayoutManager;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_data_structures.js
var AppointmentTooltipInfo = class {
  constructor(appointment) {
    let targetedAppointment = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
    let color = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
    let settings = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [];
    this.appointment = appointment;
    this.targetedAppointment = targetedAppointment;
    this.color = color;
    this.settings = settings;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_compact_appointments_helper.js
var APPOINTMENT_COLLECTOR_CLASS = "dx-scheduler-appointment-collector";
var COMPACT_APPOINTMENT_COLLECTOR_CLASS = `${APPOINTMENT_COLLECTOR_CLASS}-compact`;
var APPOINTMENT_COLLECTOR_CONTENT_CLASS = `${APPOINTMENT_COLLECTOR_CLASS}-content`;
var CompactAppointmentsHelper = class {
  constructor(instance) {
    this.instance = instance;
    this.elements = [];
  }
  render(options2) {
    const {
      isCompact: isCompact2,
      items,
      buttonColor
    } = options2;
    const template = this._createTemplate(items.data.length, isCompact2);
    const button = this._createCompactButton(template, options2);
    const $button = button.$element();
    this._makeBackgroundColor($button, items.colors, buttonColor);
    this._makeBackgroundDarker($button);
    this.elements.push($button);
    $button.data("items", this._createTooltipInfos(items));
    return $button;
  }
  clear() {
    this.elements.forEach((button) => {
      button.detach();
      button.remove();
    });
    this.elements = [];
  }
  _createTooltipInfos(items) {
    return items.data.map((appointment, index2) => {
      var _items$settings;
      const targetedAdapter = createAppointmentAdapter(appointment, this.instance._dataAccessors, this.instance.timeZoneCalculator).clone();
      if ((null === (_items$settings = items.settings) || void 0 === _items$settings ? void 0 : _items$settings.length) > 0) {
        const {
          info
        } = items.settings[index2];
        targetedAdapter.startDate = info.sourceAppointment.startDate;
        targetedAdapter.endDate = info.sourceAppointment.endDate;
      }
      return new AppointmentTooltipInfo(appointment, targetedAdapter.source(), items.colors[index2], items.settings[index2]);
    });
  }
  _onButtonClick(e, options2) {
    const $button = renderer_default(e.element);
    this.instance.showAppointmentTooltipCore($button, $button.data("items"), this._getExtraOptionsForTooltip(options2, $button));
  }
  _getExtraOptionsForTooltip(options2, $appointmentCollector) {
    return {
      clickEvent: this._clickEvent(options2.onAppointmentClick).bind(this),
      dragBehavior: options2.allowDrag && this._createTooltipDragBehavior($appointmentCollector).bind(this),
      dropDownAppointmentTemplate: this.instance.option().dropDownAppointmentTemplate,
      isButtonClick: true
    };
  }
  _clickEvent(onAppointmentClick) {
    return (e) => {
      const clickEventArgs = this.instance._createEventArgs(e);
      onAppointmentClick(clickEventArgs);
    };
  }
  _createTooltipDragBehavior($appointmentCollector) {
    return (e) => {
      const $element = renderer_default(e.element);
      const $schedulerElement = renderer_default(this.instance.element());
      const workSpace = this.instance.getWorkSpace();
      const initialPosition = locate($appointmentCollector);
      const options2 = {
        filter: `.${LIST_ITEM_CLASS}`,
        isSetCursorOffset: true,
        initialPosition,
        getItemData: (itemElement) => {
          var _$$data;
          return null === (_$$data = renderer_default(itemElement).data(LIST_ITEM_DATA_KEY)) || void 0 === _$$data ? void 0 : _$$data.appointment;
        },
        getItemSettings: (_, event) => event.itemSettings
      };
      workSpace._createDragBehaviorBase($element, $schedulerElement, options2);
    };
  }
  _getCollectorOffset(width, cellWidth) {
    return cellWidth - width - this._getCollectorRightOffset();
  }
  _getCollectorRightOffset() {
    return this.instance.getRenderingStrategyInstance()._isCompactTheme() ? 1 : 5;
  }
  _makeBackgroundDarker(button) {
    button.css("boxShadow", `inset ${getBoundingRect(button.get(0)).width}px 0 0 0 rgba(0, 0, 0, 0.3)`);
  }
  _makeBackgroundColor($button, colors, color) {
    when.apply(null, colors).done((function() {
      this._makeBackgroundColorCore($button, color, [...arguments]);
    }).bind(this));
  }
  _makeBackgroundColorCore($button, color, itemColors) {
    color && color.done((color2) => {
      const backgroundColor = getOverflowIndicatorColor(color2, itemColors);
      if (backgroundColor) {
        $button.css("backgroundColor", backgroundColor);
      }
    });
  }
  _setPosition(element, position3) {
    move(element, {
      top: position3.top,
      left: position3.left
    });
  }
  _createCompactButton(template, options2) {
    const $button = this._createCompactButtonElement(options2);
    return this.instance._createComponent($button, button_default, {
      type: "default",
      width: options2.width,
      height: options2.height,
      onClick: (e) => this._onButtonClick(e, options2),
      template: this._renderTemplate(template, options2.items, options2.isCompact)
    });
  }
  _createCompactButtonElement(_ref) {
    let {
      isCompact: isCompact2,
      $container,
      coordinates
    } = _ref;
    const result2 = renderer_default("<div>").addClass(APPOINTMENT_COLLECTOR_CLASS).toggleClass(COMPACT_APPOINTMENT_COLLECTOR_CLASS, isCompact2).appendTo($container);
    this._setPosition(result2, coordinates);
    return result2;
  }
  _renderTemplate(template, items, isCompact2) {
    return new FunctionTemplate((options2) => template.render({
      model: {
        appointmentCount: items.data.length,
        isCompact: isCompact2
      },
      container: options2.container
    }));
  }
  _createTemplate(count, isCompact2) {
    this._initButtonTemplate(count, isCompact2);
    return this.instance._getAppointmentTemplate("appointmentCollectorTemplate");
  }
  _initButtonTemplate(count, isCompact2) {
    this.instance._templateManager.addDefaultTemplates({
      appointmentCollector: new FunctionTemplate((options2) => this._createButtonTemplate(count, renderer_default(options2.container), isCompact2))
    });
  }
  _createButtonTemplate(appointmentCount, element, isCompact2) {
    const text = isCompact2 ? appointmentCount : message_default.getFormatter("dxScheduler-moreAppointments")(appointmentCount);
    return element.append(renderer_default("<span>").text(text)).addClass(APPOINTMENT_COLLECTOR_CONTENT_CLASS);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_utils.js
var utils2 = {
  dataAccessors: {
    getAppointmentSettings: (element) => renderer_default(element).data(APPOINTMENT_SETTINGS_KEY),
    getAppointmentInfo: (element) => {
      const settings = utils2.dataAccessors.getAppointmentSettings(element);
      return null === settings || void 0 === settings ? void 0 : settings.info;
    },
    create: (fields, currentDataAccessors, forceIsoDateParsing, dateSerializationFormat) => {
      const dataAccessors = currentDataAccessors ? _extends({}, currentDataAccessors) : {
        getter: {},
        setter: {},
        expr: {}
      };
      each(fields, (name2, expr) => {
        if (expr) {
          const getter = compileGetter(expr);
          const setter = compileSetter(expr);
          let dateGetter;
          let dateSetter;
          let serializationFormat;
          if (field = name2, "startDate" === field || "endDate" === field) {
            dateGetter = (object) => {
              let value2 = getter(object);
              if (forceIsoDateParsing) {
                value2 = date_serialization_default.deserializeDate(value2);
              }
              return value2;
            };
            dateSetter = (object, value2) => {
              if (dateSerializationFormat) {
                serializationFormat = dateSerializationFormat;
              } else if (forceIsoDateParsing && !serializationFormat) {
                const oldValue = getter(object);
                serializationFormat = date_serialization_default.getDateSerializationFormat(oldValue);
              }
              const newValue = date_serialization_default.serializeDate(value2, serializationFormat);
              setter(object, newValue);
            };
          }
          dataAccessors.getter[name2] = dateGetter || getter;
          dataAccessors.setter[name2] = dateSetter || setter;
          dataAccessors.expr[`${name2}Expr`] = expr;
        } else {
          delete dataAccessors.getter[name2];
          delete dataAccessors.setter[name2];
          delete dataAccessors.expr[`${name2}Expr`];
        }
        var field;
      });
      return dataAccessors;
    }
  },
  DOM: {
    getHeaderHeight: (header) => header ? header._$element && parseInt(getOuterHeight(header._$element), 10) : 0
  },
  renovation: {
    renderComponent: (widget, parentElement, componentClass, componentName, viewModel) => {
      let component = widget[componentName];
      if (!component) {
        const container = getPublicElement(parentElement);
        component = widget._createComponent(container, componentClass, viewModel);
        widget[componentName] = component;
      } else {
        const $element = component.$element();
        const elementStyle = $element.get(0).style;
        const {
          height
        } = elementStyle;
        const {
          width
        } = elementStyle;
        component.option(viewModel);
        if (height) {
          setHeight($element, height);
        }
        if (width) {
          setWidth($element, width);
        }
      }
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_subscribes.js
var toMs16 = date_default.dateToMilliseconds;
var subscribes = {
  isCurrentViewAgenda() {
    return "agenda" === this.currentViewType;
  },
  currentViewUpdated(currentView) {
    this.option("currentView", currentView);
  },
  currentDateUpdated(date) {
    this.option("currentDate", date);
  },
  getOption(name2) {
    return this.option(name2);
  },
  getWorkspaceOption(name2) {
    return this.getWorkSpace().option(name2);
  },
  isVirtualScrolling() {
    return this.isVirtualScrolling();
  },
  setCellDataCacheAlias(appointment, geometry) {
    this._workSpace.setCellDataCacheAlias(appointment, geometry);
  },
  isGroupedByDate() {
    return this.getWorkSpace().isGroupedByDate();
  },
  showAppointmentTooltip(options2) {
    const targetedAppointment = this.getTargetedAppointment(options2.data, options2.target);
    this.showAppointmentTooltip(options2.data, options2.target, targetedAppointment);
  },
  hideAppointmentTooltip() {
    this.hideAppointmentTooltip();
  },
  showEditAppointmentPopup(options2) {
    const targetedData = this.getTargetedAppointment(options2.data, options2.target);
    this.showAppointmentPopup(options2.data, false, targetedData);
  },
  updateAppointmentAfterResize(options2) {
    const info = utils2.dataAccessors.getAppointmentInfo(options2.$appointment);
    const {
      exceptionDate
    } = info.sourceAppointment;
    this._checkRecurringAppointment(options2.target, options2.data, exceptionDate, () => {
      this._updateAppointment(options2.target, options2.data, function() {
        this._appointments.moveAppointmentBack();
      });
    });
  },
  getUpdatedData(rawAppointment) {
    return this._getUpdatedData(rawAppointment);
  },
  updateAppointmentAfterDrag(_ref) {
    let {
      event,
      element,
      rawAppointment,
      newCellIndex,
      oldCellIndex
    } = _ref;
    const info = utils2.dataAccessors.getAppointmentInfo(element);
    const appointment = createAppointmentAdapter(rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    const targetedAppointment = createAppointmentAdapter(extend({}, rawAppointment, this._getUpdatedData(rawAppointment)), this._dataAccessors, this.timeZoneCalculator);
    const targetedRawAppointment = targetedAppointment.source();
    const becomeAllDay = targetedAppointment.allDay;
    const wasAllDay = appointment.allDay;
    const movedBetweenAllDayAndSimple = this._workSpace.supportAllDayRow() && (wasAllDay && !becomeAllDay || !wasAllDay && becomeAllDay);
    const isDragAndDropBetweenComponents = event.fromComponent !== event.toComponent;
    if (-1 === newCellIndex) {
      if (!isDragAndDropBetweenComponents) {
        this._appointments.moveAppointmentBack(event);
      }
      return;
    }
    if (newCellIndex !== oldCellIndex || isDragAndDropBetweenComponents || movedBetweenAllDayAndSimple) {
      this._checkRecurringAppointment(rawAppointment, targetedRawAppointment, info.sourceAppointment.exceptionDate, () => {
        this._updateAppointment(rawAppointment, targetedRawAppointment, function() {
          this._appointments.moveAppointmentBack(event);
        }, event);
      }, void 0, void 0, event);
    } else {
      this._appointments.moveAppointmentBack(event);
    }
  },
  onDeleteButtonPress(options2) {
    const targetedData = this.getTargetedAppointment(options2.data, renderer_default(options2.target));
    this.checkAndDeleteAppointment(options2.data, targetedData);
    this.hideAppointmentTooltip();
  },
  getTextAndFormatDate(appointmentRaw, targetedAppointmentRaw, format2) {
    const appointmentAdapter = createAppointmentAdapter(appointmentRaw, this._dataAccessors, this.timeZoneCalculator);
    const targetedAdapter = createAppointmentAdapter(targetedAppointmentRaw || appointmentRaw, this._dataAccessors, this.timeZoneCalculator);
    const startDate = this.timeZoneCalculator.createDate(targetedAdapter.startDate, {
      path: "toGrid"
    });
    const endDate = this.timeZoneCalculator.createDate(targetedAdapter.endDate, {
      path: "toGrid"
    });
    const formatType = format2 || getFormatType(startDate, endDate, targetedAdapter.allDay, "month" !== this.currentViewType);
    return {
      text: targetedAdapter.text || appointmentAdapter.text,
      formatDate: formatDates(startDate, endDate, formatType)
    };
  },
  _createAppointmentTitle(data2) {
    if (isPlainObject(data2)) {
      return data2.text;
    }
    return String(data2);
  },
  getResizableAppointmentArea(options2) {
    const {
      allDay
    } = options2;
    const groups = this._getCurrentViewOption("groups");
    if (groups && groups.length) {
      if (allDay || this.getLayoutManager().getRenderingStrategyInstance()._needHorizontalGroupBounds()) {
        const horizontalGroupBounds = this._workSpace.getGroupBounds(options2.coordinates);
        return {
          left: horizontalGroupBounds.left,
          right: horizontalGroupBounds.right,
          top: 0,
          bottom: 0
        };
      }
      if (this.getLayoutManager().getRenderingStrategyInstance()._needVerticalGroupBounds(allDay) && this._workSpace._isVerticalGroupedWorkSpace()) {
        const verticalGroupBounds = this._workSpace.getGroupBounds(options2.coordinates);
        return {
          left: 0,
          right: 0,
          top: verticalGroupBounds.top,
          bottom: verticalGroupBounds.bottom
        };
      }
    }
    return;
  },
  needRecalculateResizableArea() {
    return this.getWorkSpace().needRecalculateResizableArea();
  },
  getAppointmentGeometry(settings) {
    return this.getLayoutManager().getRenderingStrategyInstance().getAppointmentGeometry(settings);
  },
  isAllDay(appointmentData) {
    return this.getLayoutManager().getRenderingStrategyInstance().isAllDay(appointmentData);
  },
  getDeltaTime(e, initialSize, itemData) {
    return this.getLayoutManager().getRenderingStrategyInstance().getDeltaTime(e, initialSize, itemData);
  },
  getDropDownAppointmentWidth(isAllDay) {
    return this.getLayoutManager().getRenderingStrategyInstance().getDropDownAppointmentWidth(this._getViewCountConfig().intervalCount, isAllDay);
  },
  getDropDownAppointmentHeight() {
    return this.getLayoutManager().getRenderingStrategyInstance().getDropDownAppointmentHeight();
  },
  getCellWidth() {
    return this.getWorkSpace().getCellWidth();
  },
  getCellHeight() {
    return this.getWorkSpace().getCellHeight();
  },
  getMaxAppointmentCountPerCellByType(isAllDay) {
    return this.getRenderingStrategyInstance()._getMaxAppointmentCountPerCellByType(isAllDay);
  },
  needCorrectAppointmentDates() {
    return this.getRenderingStrategyInstance().needCorrectAppointmentDates();
  },
  getRenderingStrategyDirection() {
    return this.getRenderingStrategyInstance().getDirection();
  },
  updateAppointmentEndDate(options2) {
    const {
      endDate
    } = options2;
    const endDayHour = this._getCurrentViewOption("endDayHour");
    const startDayHour = this._getCurrentViewOption("startDayHour");
    let updatedEndDate = endDate;
    if (endDate.getHours() >= endDayHour) {
      updatedEndDate.setHours(endDayHour, 0, 0, 0);
    } else if (!options2.isSameDate && startDayHour > 0 && 60 * endDate.getHours() + endDate.getMinutes() < 60 * startDayHour) {
      updatedEndDate = new Date(updatedEndDate.getTime() - toMs16("day"));
      updatedEndDate.setHours(endDayHour, 0, 0, 0);
    }
    return updatedEndDate;
  },
  renderCompactAppointments(options2) {
    this._compactAppointmentsHelper.render(options2);
  },
  clearCompactAppointments() {
    this._compactAppointmentsHelper.clear();
  },
  supportCompactDropDownAppointments() {
    return this.getLayoutManager().getRenderingStrategyInstance().supportCompactDropDownAppointments();
  },
  getGroupCount() {
    return this._workSpace._getGroupCount();
  },
  mapAppointmentFields(config3) {
    const {
      itemData,
      itemElement,
      targetedAppointment
    } = config3;
    const targetedData = targetedAppointment || this.getTargetedAppointment(itemData, itemElement);
    return {
      appointmentData: config3.itemData,
      appointmentElement: config3.itemElement,
      targetedAppointmentData: targetedData
    };
  },
  dayHasAppointment(day, appointment, trimTime3) {
    return this.dayHasAppointment(day, appointment, trimTime3);
  },
  getLayoutManager() {
    return this._layoutManager;
  },
  getAgendaVerticalStepHeight() {
    return this.getWorkSpace().getAgendaVerticalStepHeight();
  },
  getAgendaDuration() {
    return this._getCurrentViewOption("agendaDuration");
  },
  getStartViewDate() {
    return this.getStartViewDate();
  },
  getEndViewDate() {
    return this.getEndViewDate();
  },
  forceMaxAppointmentPerCell() {
    return this.forceMaxAppointmentPerCell();
  },
  onAgendaReady(rows) {
    const $appts = this.getAppointmentsInstance()._itemElements();
    let total = 0;
    const applyClass = function(_, count) {
      const index2 = count + total - 1;
      $appts.eq(index2).addClass(AGENDA_LAST_IN_DATE_APPOINTMENT_CLASS);
      total += count;
    };
    for (let i = 0; i < rows.length; i++) {
      each(rows[i], applyClass);
    }
  },
  getTimezone() {
    return this._getTimezoneOffsetByOption();
  },
  getTargetedAppointmentData(appointment, element) {
    return this.getTargetedAppointment(appointment, element);
  },
  getEndDayHour() {
    return this._workSpace.option("endDayHour") || this.option("endDayHour");
  },
  getStartDayHour() {
    return this._workSpace.option("startDayHour") || this.option("startDayHour");
  },
  getViewOffsetMs() {
    return this.getViewOffsetMs();
  },
  isAdaptive() {
    return this.option("adaptivityEnabled");
  },
  removeDroppableCellClass() {
    this._workSpace.removeDroppableCellClass();
  }
};
var m_subscribes_default = subscribes;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/common/validation_functions.js
var isInteger = (value2) => Number.isInteger(value2);
var greaterThan = function(value2, minimalValue) {
  let strict = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;
  return strict ? value2 > minimalValue : value2 >= minimalValue;
};
var lessThan = function(value2, maximalValue) {
  let strict = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;
  return strict ? value2 < maximalValue : value2 <= maximalValue;
};
var inRange2 = (value2, _ref) => {
  let [from, to] = _ref;
  return value2 >= from && value2 <= to;
};
var divisibleBy = (value2, divider) => value2 % divider === 0;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/core/options_validator.js
var OptionsValidator = class {
  constructor(validators) {
    this.validators = validators;
  }
  validate(options2) {
    const errors2 = Object.entries(this.validators).reduce((result2, _ref) => {
      let [validatorName, validator] = _ref;
      const validatorResult = validator.validate(options2);
      if (true !== validatorResult) {
        result2[validatorName] = validatorResult;
      }
      return result2;
    }, {});
    return Object.keys(errors2).length > 0 ? errors2 : true;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/core/options_validator_error_handler.js
var OptionsValidatorErrorHandler = class {
  constructor(validatorNameToErrorCodeMap, globalErrorHandler) {
    this.validatorNameToErrorCodeMap = validatorNameToErrorCodeMap;
    this.globalErrorHandler = globalErrorHandler;
  }
  handleValidationResult(optionsValidatorResult) {
    if (true === optionsValidatorResult) {
      return;
    }
    const uniqErrorCodes = Object.keys(optionsValidatorResult).reduce((set, validatorName) => {
      const errorCode = this.validatorNameToErrorCodeMap[validatorName];
      if (errorCode) {
        set.add(errorCode);
      }
      return set;
    }, /* @__PURE__ */ new Set());
    const errorCodeArray = [...uniqErrorCodes];
    errorCodeArray.forEach((errorCode, idx) => {
      const isLastErrorCode = idx === errorCodeArray.length - 1;
      if (!isLastErrorCode) {
        this.globalErrorHandler.logError(errorCode);
      } else {
        this.globalErrorHandler.throwError(errorCode);
      }
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/core/validator.js
var Validator2 = class {
  constructor(valueSelector, rules) {
    this.valueSelector = valueSelector;
    this.rules = rules;
  }
  validate(options2) {
    const value2 = this.valueSelector(options2);
    const errors2 = this.rules.reduce((result2, rule) => {
      const validationResult = rule(value2);
      if (true !== validationResult) {
        result2[rule.name] = validationResult;
      }
      return result2;
    }, {});
    return Object.keys(errors2).length ? errors2 : true;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/core/validator_rules.js
var createValidatorRule = (name2, ruleFunc) => {
  Object.defineProperty(ruleFunc, "name", {
    value: name2,
    writable: false
  });
  return ruleFunc;
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/common/validator_rules.js
var mustBeInteger = createValidatorRule("mustBeInteger", (value2) => isInteger(value2) || `${value2} must be an integer.`);
var mustBeGreaterThan = function(minimalValue) {
  let strict = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
  return createValidatorRule("mustBeGreaterThan", (value2) => greaterThan(value2, minimalValue, strict) || `${value2} must be ${strict ? ">" : ">="} than ${minimalValue}.`);
};
var mustBeInRange = (range2) => createValidatorRule("mustBeInRange", (value2) => inRange2(value2, range2) || `${value2} must be in range [${range2[0]}, ${range2[1]}].`);
var mustBeDivisibleBy = (divider) => createValidatorRule("mustBeDivisibleBy", (value2) => divisibleBy(value2, divider) || `${value2} must be divisible by ${divider}.`);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/validator_rules.js
var endDayHourMustBeGreaterThanStartDayHour = createValidatorRule("endDayHourGreaterThanStartDayHour", (_ref) => {
  let {
    startDayHour,
    endDayHour
  } = _ref;
  return greaterThan(endDayHour, startDayHour) || `endDayHour: ${endDayHour} must be greater that startDayHour: ${startDayHour}.`;
});
var visibleIntervalMustBeDivisibleByCellDuration = createValidatorRule("visibleIntervalMustBeDivisibleByCellDuration", (_ref2) => {
  let {
    cellDuration,
    startDayHour,
    endDayHour
  } = _ref2;
  const visibleInterval = 60 * (endDayHour - startDayHour);
  return divisibleBy(visibleInterval, cellDuration) || `endDayHour - startDayHour: ${visibleInterval} (minutes), must be divisible by cellDuration: ${cellDuration} (minutes).`;
});
var cellDurationMustBeLessThanVisibleInterval = createValidatorRule("cellDurationMustBeLessThanVisibleInterval", (_ref3) => {
  let {
    cellDuration,
    startDayHour,
    endDayHour
  } = _ref3;
  const visibleInterval = 60 * (endDayHour - startDayHour);
  return lessThan(cellDuration, visibleInterval, false) || `endDayHour - startDayHour: ${visibleInterval} (minutes), must be greater or equal the cellDuration: ${cellDuration} (minutes).`;
});

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/options_validator.js
var SchedulerOptionsValidator = class extends OptionsValidator {
  constructor() {
    super({
      startDayHour: new Validator2((_ref) => {
        let {
          startDayHour
        } = _ref;
        return startDayHour;
      }, [mustBeInteger, mustBeInRange([0, 24])]),
      endDayHour: new Validator2((_ref2) => {
        let {
          endDayHour
        } = _ref2;
        return endDayHour;
      }, [mustBeInteger, mustBeInRange([0, 24])]),
      offset: new Validator2((_ref3) => {
        let {
          offset: offset2
        } = _ref3;
        return offset2;
      }, [mustBeInteger, mustBeInRange([-1440, 1440]), mustBeDivisibleBy(5)]),
      cellDuration: new Validator2((_ref4) => {
        let {
          cellDuration
        } = _ref4;
        return cellDuration;
      }, [mustBeInteger, mustBeGreaterThan(0)]),
      startDayHourAndEndDayHour: new Validator2((options2) => options2, [endDayHourMustBeGreaterThanStartDayHour]),
      cellDurationAndVisibleInterval: new Validator2((options2) => options2, [visibleIntervalMustBeDivisibleByCellDuration, cellDurationMustBeLessThanVisibleInterval])
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/options_validator/options_validator_errors_handler.js
var GLOBAL_ERROR_HANDLER = {
  logError: (errorCode) => {
    ui_errors_default.log(errorCode);
  },
  throwError: (errorCode) => {
    throw ui_errors_default.Error(errorCode);
  }
};
var SchedulerOptionsValidatorErrorsHandler = class extends OptionsValidatorErrorHandler {
  constructor() {
    super({
      startDayHour: "E1058",
      endDayHour: "E1058",
      startDayHourAndEndDayHour: "E1058",
      offset: "E1061",
      cellDuration: "E1062",
      cellDurationAndVisibleInterval: "E1062"
    }, GLOBAL_ERROR_HANDLER);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/resources/m_agenda_resource_processor.js
var PromiseItem = class {
  constructor(rawAppointment, promise) {
    this.rawAppointment = rawAppointment;
    this.promise = promise;
  }
};
var AgendaResourceProcessor = class {
  get resourceDeclarations() {
    return this._resourceDeclarations;
  }
  set resourceDeclarations(value2) {
    this._resourceDeclarations = value2;
    this.isLoaded = false;
    this.isLoading = false;
    this.resourceMap.clear();
    this.appointmentPromiseQueue = [];
  }
  constructor() {
    let resourceDeclarations = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    this._resourceDeclarations = resourceDeclarations;
    this.isLoaded = false;
    this.isLoading = false;
    this.resourceMap = /* @__PURE__ */ new Map();
    this.appointmentPromiseQueue = [];
  }
  _pushAllResources() {
    this.appointmentPromiseQueue.forEach((_ref) => {
      let {
        promise,
        rawAppointment
      } = _ref;
      const result2 = [];
      this.resourceMap.forEach((resource, fieldName) => {
        const item = {
          label: resource.label,
          values: []
        };
        if (fieldName in rawAppointment) {
          wrapToArray(rawAppointment[fieldName]).forEach((value2) => item.values.push(resource.map.get(value2)));
        }
        if (item.values.length) {
          result2.push(item);
        }
      });
      promise.resolve(result2);
    });
    this.appointmentPromiseQueue = [];
  }
  _onPullResource(fieldName, valueName, displayName, label, items) {
    const map2 = /* @__PURE__ */ new Map();
    items.forEach((item) => map2.set(item[valueName], item[displayName]));
    this.resourceMap.set(fieldName, {
      label,
      map: map2
    });
  }
  _hasResourceDeclarations(resources) {
    if (0 === resources.length) {
      this.appointmentPromiseQueue.forEach((_ref2) => {
        let {
          promise
        } = _ref2;
        return promise.resolve([]);
      });
      this.appointmentPromiseQueue = [];
      return false;
    }
    return true;
  }
  _tryPullResources(resources, resultAsync) {
    if (!this.isLoading) {
      this.isLoading = true;
      const promises = [];
      resources.forEach((resource) => {
        const promise = new Deferred().done((items) => this._onPullResource(getFieldExpr(resource), getValueExpr(resource), getDisplayExpr(resource), resource.label, items));
        promises.push(promise);
        const dataSource = getWrappedDataSource(resource.dataSource);
        if (dataSource.isLoaded()) {
          promise.resolve(dataSource.items());
        } else {
          dataSource.load().done((list) => promise.resolve(list)).fail(() => promise.reject());
        }
      });
      when.apply(null, promises).done(() => {
        this.isLoaded = true;
        this.isLoading = false;
        this._pushAllResources();
      }).fail(() => resultAsync.reject());
    }
  }
  initializeState() {
    let resourceDeclarations = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    this.resourceDeclarations = resourceDeclarations;
  }
  createListAsync(rawAppointment) {
    const resultAsync = new Deferred();
    this.appointmentPromiseQueue.push(new PromiseItem(rawAppointment, resultAsync));
    if (this._hasResourceDeclarations(this.resourceDeclarations)) {
      if (this.isLoaded) {
        this._pushAllResources();
      } else {
        this._tryPullResources(this.resourceDeclarations, resultAsync);
      }
    }
    return resultAsync.promise();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/utils/promise.js
function createPromise() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    resolve,
    reject
  };
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/tooltip_strategies/m_tooltip_strategy_base.js
var TOOLTIP_APPOINTMENT_ITEM = "dx-tooltip-appointment-item";
var TOOLTIP_APPOINTMENT_ITEM_CONTENT = `${TOOLTIP_APPOINTMENT_ITEM}-content`;
var TOOLTIP_APPOINTMENT_ITEM_CONTENT_SUBJECT = `${TOOLTIP_APPOINTMENT_ITEM}-content-subject`;
var TOOLTIP_APPOINTMENT_ITEM_CONTENT_DATE = `${TOOLTIP_APPOINTMENT_ITEM}-content-date`;
var TOOLTIP_APPOINTMENT_ITEM_MARKER = `${TOOLTIP_APPOINTMENT_ITEM}-marker`;
var TOOLTIP_APPOINTMENT_ITEM_MARKER_BODY = `${TOOLTIP_APPOINTMENT_ITEM}-marker-body`;
var TOOLTIP_APPOINTMENT_ITEM_DELETE_BUTTON_CONTAINER = `${TOOLTIP_APPOINTMENT_ITEM}-delete-button-container`;
var TOOLTIP_APPOINTMENT_ITEM_DELETE_BUTTON = `${TOOLTIP_APPOINTMENT_ITEM}-delete-button`;
var TooltipStrategyBase = class {
  constructor(options2) {
    this.asyncTemplatePromises = /* @__PURE__ */ new Set();
    this._tooltip = null;
    this._options = options2;
    this._extraOptions = null;
  }
  show(target, dataList, extraOptions) {
    if (this._canShowTooltip(dataList)) {
      this.hide();
      this._extraOptions = extraOptions;
      this._showCore(target, dataList);
    }
  }
  _showCore(target, dataList) {
    if (!this._tooltip) {
      this._tooltip = this._createTooltip(target, dataList);
    } else {
      this._shouldUseTarget() && this._tooltip.option("target", target);
      this._list.option("dataSource", dataList);
    }
    this._prepareBeforeVisibleChanged(dataList);
    this._tooltip.option("visible", true);
  }
  _prepareBeforeVisibleChanged(dataList) {
  }
  _getContentTemplate(dataList) {
    return (container) => {
      const listElement = renderer_default("<div>");
      renderer_default(container).append(listElement);
      this._list = this._createList(listElement, dataList);
    };
  }
  isAlreadyShown(target) {
    if (this._tooltip && this._tooltip.option("visible")) {
      return this._tooltip.option("target")[0] === target[0];
    }
    return;
  }
  _onShown() {
    this._list.option("focusStateEnabled", this._extraOptions.focusStateEnabled);
  }
  dispose() {
  }
  hide() {
    if (this._tooltip) {
      this._tooltip.option("visible", false);
    }
  }
  _shouldUseTarget() {
    return true;
  }
  _createTooltip(target, dataList) {
  }
  _canShowTooltip(dataList) {
    if (!dataList.length) {
      return false;
    }
    return true;
  }
  _createListOption(dataList) {
    return {
      dataSource: dataList,
      onContentReady: this._onListRender.bind(this),
      onItemClick: (e) => this._onListItemClick(e),
      onItemContextMenu: this._onListItemContextMenu.bind(this),
      itemTemplate: (item, index2) => this._renderTemplate(item.appointment, item.targetedAppointment, index2, item.color),
      _swipeEnabled: false,
      pageLoadMode: "scrollBottom"
    };
  }
  _onListRender(e) {
  }
  _createTooltipElement(wrapperClass) {
    return renderer_default("<div>").appendTo(this._options.container).addClass(wrapperClass);
  }
  _createList(listElement, dataList) {
    return this._options.createComponent(listElement, m_list_edit_default, this._createListOption(dataList));
  }
  _renderTemplate(appointment, targetedAppointment, index2, color) {
    const itemListContent = this._createItemListContent(appointment, targetedAppointment, color);
    this._options.addDefaultTemplates({
      [this._getItemListTemplateName()]: new FunctionTemplate((options2) => {
        const $container = renderer_default(options2.container);
        $container.append(itemListContent);
        return $container;
      })
    });
    const template = this._options.getAppointmentTemplate(`${this._getItemListTemplateName()}Template`);
    return this._createFunctionTemplate(template, appointment, targetedAppointment, index2);
  }
  _createFunctionTemplate(template, appointmentData, targetedAppointmentData, index2) {
    const isButtonClicked = !!this._extraOptions.isButtonClick;
    const isEmptyDropDownAppointmentTemplate = this._isEmptyDropDownAppointmentTemplate();
    return new FunctionTemplate((options2) => {
      const {
        promise,
        resolve
      } = createPromise();
      this.asyncTemplatePromises.add(promise);
      return template.render({
        model: isEmptyDropDownAppointmentTemplate ? {
          appointmentData,
          targetedAppointmentData,
          isButtonClicked
        } : appointmentData,
        container: options2.container,
        index: index2,
        onRendered: () => {
          this.asyncTemplatePromises.delete(promise);
          resolve();
        }
      });
    });
  }
  _getItemListTemplateName() {
    return this._isEmptyDropDownAppointmentTemplate() ? "appointmentTooltip" : "dropDownAppointment";
  }
  _isEmptyDropDownAppointmentTemplate() {
    return !this._extraOptions.dropDownAppointmentTemplate || "dropDownAppointment" === this._extraOptions.dropDownAppointmentTemplate;
  }
  _onListItemClick(e) {
    this.hide();
    this._extraOptions.clickEvent && this._extraOptions.clickEvent(e);
    this._options.showAppointmentPopup(e.itemData.appointment, false, e.itemData.targetedAppointment);
  }
  _onListItemContextMenu(e) {
  }
  _createItemListContent(appointment, targetedAppointment, color) {
    const {
      editing
    } = this._extraOptions;
    const $itemElement = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM);
    $itemElement.append(this._createItemListMarker(color));
    $itemElement.append(this._createItemListInfo(this._options.createFormattedDateText(appointment, targetedAppointment)));
    const disabled = this._options.getAppointmentDisabled(appointment);
    if (!disabled && (editing && true === editing.allowDeleting || true === editing)) {
      $itemElement.append(this._createDeleteButton(appointment, targetedAppointment));
    }
    return $itemElement;
  }
  _createItemListMarker(color) {
    const $marker = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_MARKER);
    const $markerBody = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_MARKER_BODY);
    $marker.append($markerBody);
    color && color.done((value2) => $markerBody.css("background", value2));
    return $marker;
  }
  _createItemListInfo(object) {
    const result2 = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_CONTENT);
    const $title = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_CONTENT_SUBJECT).text(object.text);
    const $date = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_CONTENT_DATE).text(object.formatDate);
    return result2.append($title).append($date);
  }
  _createDeleteButton(appointment, targetedAppointment) {
    const $container = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_DELETE_BUTTON_CONTAINER);
    const $deleteButton = renderer_default("<div>").addClass(TOOLTIP_APPOINTMENT_ITEM_DELETE_BUTTON);
    $container.append($deleteButton);
    this._options.createComponent($deleteButton, button_default, {
      icon: "trash",
      stylingMode: "text",
      onClick: (e) => {
        this.hide();
        e.event.stopPropagation();
        this._options.checkAndDeleteAppointment(appointment, targetedAppointment);
      }
    });
    return $container;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/tooltip_strategies/m_desktop_tooltip_strategy.js
var APPOINTMENT_TOOLTIP_WRAPPER_CLASS = "dx-scheduler-appointment-tooltip-wrapper";
var DesktopTooltipStrategy = class extends TooltipStrategyBase {
  _prepareBeforeVisibleChanged(dataList) {
    this._tooltip.option("position", {
      my: "bottom",
      at: "top",
      boundary: this._getBoundary(dataList),
      offset: this._extraOptions.offset,
      collision: "fit flipfit"
    });
  }
  _getBoundary(dataList) {
    return this._options.isAppointmentInAllDayPanel(dataList[0].appointment) ? this._options.container : this._options.getScrollableContainer();
  }
  _onShown() {
    super._onShown();
    if (this._extraOptions.isButtonClick) {
      this._list.focus();
      this._list.option("focusedElement", null);
    }
  }
  _createListOption(target, dataList) {
    const result2 = super._createListOption(target, dataList);
    result2.showScrollbar = touch ? "always" : "onHover";
    return result2;
  }
  _createTooltip(target, dataList) {
    const tooltip2 = this._createTooltipElement(APPOINTMENT_TOOLTIP_WRAPPER_CLASS);
    return this._options.createComponent(tooltip2, m_tooltip_default, {
      target,
      maxHeight: 200,
      rtlEnabled: this._extraOptions.rtlEnabled,
      onShown: this._onShown.bind(this),
      contentTemplate: this._getContentTemplate(dataList),
      wrapperAttr: {
        class: APPOINTMENT_TOOLTIP_WRAPPER_CLASS
      }
    });
  }
  _onListRender(e) {
    return this._extraOptions.dragBehavior && this._extraOptions.dragBehavior(e);
  }
  _onListItemContextMenu(e) {
    const contextMenuEventArgs = this._options.createEventArgs(e);
    this._options.onItemContextMenu(contextMenuEventArgs);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/tooltip_strategies/m_mobile_tooltip_strategy.js
var CLASS = {
  slidePanel: "dx-scheduler-overlay-panel",
  scrollableContent: ".dx-scrollable-content"
};
var MAX_HEIGHT = {
  PHONE: 250,
  TABLET: "90%",
  DEFAULT: "auto"
};
var MAX_WIDTH = {
  PHONE: "100%",
  TABLET: "80%"
};
var animationConfig = {
  show: {
    type: "slide",
    duration: 300,
    from: {
      position: {
        my: "top",
        at: "bottom",
        of: getWindow()
      }
    },
    to: {
      position: {
        my: "center",
        at: "center",
        of: getWindow()
      }
    }
  },
  hide: {
    type: "slide",
    duration: 300,
    to: {
      position: {
        my: "top",
        at: "bottom",
        of: getWindow()
      }
    },
    from: {
      position: {
        my: "center",
        at: "center",
        of: getWindow()
      }
    }
  }
};
var createPhoneDeviceConfig = (listHeight) => ({
  shading: false,
  width: MAX_WIDTH.PHONE,
  height: listHeight > MAX_HEIGHT.PHONE ? MAX_HEIGHT.PHONE : MAX_HEIGHT.DEFAULT,
  position: {
    my: "bottom",
    at: "bottom",
    of: getWindow()
  }
});
var createTabletDeviceConfig = (listHeight) => {
  const currentMaxHeight = 0.9 * getHeight(getWindow());
  return {
    shading: true,
    width: MAX_WIDTH.TABLET,
    height: listHeight > currentMaxHeight ? MAX_HEIGHT.TABLET : MAX_HEIGHT.DEFAULT,
    position: {
      my: "center",
      at: "center",
      of: getWindow()
    }
  };
};
var MobileTooltipStrategy = class extends TooltipStrategyBase {
  _shouldUseTarget() {
    return false;
  }
  setTooltipConfig() {
    const isTabletWidth = getWidth(getWindow()) > 700;
    const listHeight = getOuterHeight(this._list.$element().find(CLASS.scrollableContent));
    this._tooltip.option(isTabletWidth ? createTabletDeviceConfig(listHeight) : createPhoneDeviceConfig(listHeight));
  }
  async _onShowing() {
    this._tooltip.option("height", MAX_HEIGHT.DEFAULT);
    this.setTooltipConfig();
    await Promise.all([...this.asyncTemplatePromises]);
    this.setTooltipConfig();
  }
  _createTooltip(target, dataList) {
    const element = this._createTooltipElement(CLASS.slidePanel);
    return this._options.createComponent(element, ui_overlay_default, {
      target: getWindow(),
      hideOnOutsideClick: true,
      animation: animationConfig,
      onShowing: () => this._onShowing(),
      onShown: this._onShown.bind(this),
      contentTemplate: this._getContentTemplate(dataList),
      wrapperAttr: {
        class: CLASS.slidePanel
      }
    });
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_table_creator.js
var SchedulerTableCreator = class {
  constructor() {
    this.VERTICAL = "vertical";
    this.HORIZONTAL = "horizontal";
  }
  insertAllDayRow(allDayElements, tableBody, index2) {
    if (allDayElements[index2]) {
      let row = allDayElements[index2].find("tr");
      if (!row.length) {
        row = renderer_default(dom_adapter_default.createElement("tr"));
        row.append(allDayElements[index2].get(0));
      }
      tableBody.appendChild(row.get ? row.get(0) : row);
    }
  }
  makeTable(options2) {
    const tableBody = dom_adapter_default.createElement("tbody");
    const templateCallbacks = [];
    let row;
    const rowCountInGroup = options2.groupCount ? options2.rowCount / options2.groupCount : options2.rowCount;
    let allDayElementIndex = 0;
    const {
      allDayElements
    } = options2;
    const {
      groupIndex
    } = options2;
    const {
      rowCount
    } = options2;
    renderer_default(options2.container).append(tableBody);
    if (allDayElements) {
      this.insertAllDayRow(allDayElements, tableBody, 0);
      allDayElementIndex++;
    }
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
      row = dom_adapter_default.createElement("tr");
      tableBody.appendChild(row);
      const isLastRowInGroup = (rowIndex + 1) % rowCountInGroup === 0;
      if (options2.rowClass) {
        row.className = options2.rowClass;
      }
      for (let columnIndex = 0; columnIndex < options2.cellCount; columnIndex++) {
        var _options$setAdditiona;
        const td = dom_adapter_default.createElement("td");
        row.appendChild(td);
        if (options2.cellClass) {
          if (isFunction(options2.cellClass)) {
            td.className = options2.cellClass(rowIndex, columnIndex);
          } else {
            td.className = options2.cellClass;
          }
        }
        let cellDataObject;
        let dataKey;
        let dataValue;
        if (options2.getCellData) {
          cellDataObject = options2.getCellData(td, rowIndex, columnIndex, groupIndex);
          dataKey = cellDataObject.key;
          dataValue = cellDataObject.value;
          dataKey && data(td, dataKey, dataValue);
        }
        null === (_options$setAdditiona = options2.setAdditionalClasses) || void 0 === _options$setAdditiona || _options$setAdditiona.call(options2, renderer_default(td), dataValue);
        if (options2.cellTemplate && options2.cellTemplate.render) {
          const additionalTemplateData = options2.getTemplateData ? options2.getTemplateData(rowIndex) : {};
          const templateOptions = {
            model: _extends({
              text: options2.getCellText ? options2.getCellText(rowIndex, columnIndex) : "",
              date: options2.getCellDate ? options2.getCellDate(rowIndex) : void 0
            }, additionalTemplateData),
            container: getPublicElement(renderer_default(td)),
            index: rowIndex * options2.cellCount + columnIndex
          };
          if (dataValue) {
            if (dataValue.startDate) {
              templateOptions.model.startDate = dataValue.startDate;
            }
            if (dataValue.endDate) {
              templateOptions.model.endDate = dataValue.endDate;
            }
            if (dataValue.groups) {
              templateOptions.model.groups = dataValue.groups;
            }
            if (dataValue.allDay) {
              templateOptions.model.allDay = dataValue.allDay;
            }
          }
          templateCallbacks.push(options2.cellTemplate.render.bind(options2.cellTemplate, templateOptions));
        } else if (options2.getCellText) {
          renderer_default("<div>").text(options2.getCellText(rowIndex, columnIndex)).addClass(options2.getCellTextClass).appendTo(renderer_default(td));
        }
      }
      if (allDayElements && isLastRowInGroup) {
        this.insertAllDayRow(allDayElements, tableBody, allDayElementIndex);
        allDayElementIndex++;
      }
    }
    return templateCallbacks;
  }
  makeGroupedTable(type2, groups, cssClasses, cellCount, cellTemplate, rowCount, groupByDate) {
    let rows = [];
    if (type2 === this.VERTICAL) {
      rows = this._makeVerticalGroupedRows(groups, cssClasses, cellTemplate, rowCount);
    } else {
      rows = this._makeHorizontalGroupedRows(groups, cssClasses, cellCount, cellTemplate, groupByDate);
    }
    return rows;
  }
  makeGroupedTableFromJSON(type2, data2, config3) {
    let table;
    const cellStorage = [];
    let rowIndex = 0;
    config3 = config3 || {};
    const cellTag = config3.cellTag || "td";
    const childrenField = config3.childrenField || "children";
    const titleField = config3.titleField || "title";
    const {
      groupTableClass
    } = config3;
    const {
      groupRowClass
    } = config3;
    const {
      groupCellClass
    } = config3;
    const {
      groupCellCustomContent
    } = config3;
    function getChildCount(item) {
      if (item[childrenField]) {
        return item[childrenField].length;
      }
      return 0;
    }
    function createCell(text, childCount, index2, data3) {
      const cell = {
        element: dom_adapter_default.createElement(cellTag),
        childCount
      };
      if (groupCellClass) {
        cell.element.className = groupCellClass;
      }
      const cellText = dom_adapter_default.createTextNode(text);
      if ("function" === typeof groupCellCustomContent) {
        groupCellCustomContent(cell.element, cellText, index2, data3);
      } else {
        cell.element.appendChild(cellText);
      }
      return cell;
    }
    !function() {
      table = dom_adapter_default.createElement("table");
      if (groupTableClass) {
        table.className = groupTableClass;
      }
    }();
    !function generateCells(data3) {
      for (let i = 0; i < data3.length; i++) {
        const childCount = getChildCount(data3[i]);
        const cell = createCell(data3[i][titleField], childCount, i, data3[i]);
        if (!cellStorage[rowIndex]) {
          cellStorage[rowIndex] = [];
        }
        cellStorage[rowIndex].push(cell);
        if (childCount) {
          generateCells(data3[i][childrenField]);
        } else {
          rowIndex++;
        }
      }
    }(data2);
    void cellStorage.forEach((cells) => {
      const row = dom_adapter_default.createElement("tr");
      if (groupRowClass) {
        row.className = groupRowClass;
      }
      const rowspans = [];
      for (let i = cells.length - 1; i >= 0; i--) {
        const prev = cells[i + 1];
        let rowspan = cells[i].childCount;
        if (prev && prev.childCount) {
          rowspan *= prev.childCount;
        }
        rowspans.push(rowspan);
      }
      rowspans.reverse();
      cells.forEach((cell, index2) => {
        if (rowspans[index2]) {
          cell.element.setAttribute("rowSpan", rowspans[index2]);
        }
        row.appendChild(cell.element);
      });
      table.appendChild(row);
    });
    return table;
  }
  _makeFlexGroupedRowCells(group, repeatCount, cssClasses, cellTemplate) {
    let repeatByDate = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1;
    const cells = [];
    const {
      items
    } = group;
    const itemCount = items.length;
    for (let i = 0; i < repeatCount * repeatByDate; i++) {
      for (let j = 0; j < itemCount; j++) {
        let $container = renderer_default("<div>");
        const cell = {};
        if (cellTemplate && cellTemplate.render) {
          const templateOptions = {
            model: items[j],
            container: getPublicElement($container),
            index: i * itemCount + j
          };
          if (group.data) {
            templateOptions.model.data = group.data[j];
          }
          cell.template = cellTemplate.render.bind(cellTemplate, templateOptions);
        } else {
          $container.text(items[j].text).attr("title", items[j].text).addClass("dx-scheduler-group-header-content");
          $container = renderer_default("<div>").append($container);
        }
        const cssClass = isFunction(cssClasses.groupHeaderClass) ? cssClasses.groupHeaderClass(j) : cssClasses.groupHeaderClass;
        cell.element = $container.addClass(cssClass);
        cells.push(cell);
      }
    }
    return cells;
  }
  _makeVerticalGroupedRows(groups, cssClasses, cellTemplate, rowCount) {
    const cellTemplates = [];
    let repeatCount = 1;
    const cellsArray = [];
    const cellIterator = function(cell) {
      if (cell.template) {
        cellTemplates.push(cell.template);
      }
    };
    for (let i = 0; i < groups.length; i++) {
      if (i > 0) {
        repeatCount = groups[i - 1].items.length * repeatCount;
      }
      const cells = this._makeFlexGroupedRowCells(groups[i], repeatCount, cssClasses, cellTemplate);
      cells.forEach(cellIterator);
      cellsArray.push(cells);
    }
    const rows = [];
    const groupCount = cellsArray.length;
    for (let i = 0; i < groupCount; i++) {
      rows.push(renderer_default("<div>").addClass(cssClasses.groupHeaderRowClass));
    }
    for (let i = groupCount - 1; i >= 0; i--) {
      const currentColumnLength = cellsArray[i].length;
      for (let j = 0; j < currentColumnLength; j++) {
        rows[i].append(cellsArray[i][j].element);
      }
    }
    return {
      elements: renderer_default("<div>").addClass("dx-scheduler-group-flex-container").append(rows),
      cellTemplates
    };
  }
  _makeHorizontalGroupedRows(groups, cssClasses, cellCount, cellTemplate, groupByDate) {
    let repeatCount = 1;
    const groupCount = groups.length;
    const rows = [];
    const cellTemplates = [];
    const repeatByDate = groupByDate ? cellCount : 1;
    const cellIterator = function(cell) {
      if (cell.template) {
        cellTemplates.push(cell.template);
      }
      return cell.element;
    };
    for (let i = 0; i < groupCount; i++) {
      if (i > 0) {
        repeatCount = groups[i - 1].items.length * repeatCount;
      }
      const cells = this._makeGroupedRowCells(groups[i], repeatCount, cssClasses, cellTemplate, repeatByDate);
      rows.push(renderer_default("<tr>").addClass(cssClasses.groupRowClass).append(cells.map(cellIterator)));
    }
    const maxCellCount = rows[groupCount - 1].find("th").length;
    for (let j = 0; j < groupCount; j++) {
      const $cell = rows[j].find("th");
      let colspan = maxCellCount / $cell.length;
      if (!groupByDate) {
        colspan *= cellCount;
      }
      if (colspan > 1 && 1 === repeatByDate || groupByDate && groupCount > 1) {
        $cell.attr("colSpan", colspan);
      }
    }
    return {
      elements: rows,
      cellTemplates
    };
  }
  _makeGroupedRowCells(group, repeatCount, cssClasses, cellTemplate, repeatByDate) {
    repeatByDate = repeatByDate || 1;
    repeatCount *= repeatByDate;
    const cells = [];
    const {
      items
    } = group;
    const itemCount = items.length;
    for (let i = 0; i < repeatCount; i++) {
      for (let j = 0; j < itemCount; j++) {
        let $container = renderer_default("<div>");
        const cell = {};
        if (cellTemplate && cellTemplate.render) {
          const templateOptions = {
            model: items[j],
            container: getPublicElement($container),
            index: i * itemCount + j
          };
          if (group.data) {
            templateOptions.model.data = group.data[j];
          }
          cell.template = cellTemplate.render.bind(cellTemplate, templateOptions);
        } else {
          $container.text(items[j].text);
          $container = renderer_default("<div>").append($container);
        }
        $container.addClass(cssClasses.groupHeaderContentClass);
        let cssClass;
        if (isFunction(cssClasses.groupHeaderClass)) {
          cssClass = cssClasses.groupHeaderClass(j);
        } else {
          cssClass = cssClasses.groupHeaderClass;
        }
        cell.element = renderer_default("<th>").addClass(cssClass).append($container);
        cells.push(cell);
      }
    }
    return cells;
  }
};
var m_table_creator_default = {
  tableCreator: new SchedulerTableCreator()
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/utils/scroll.js
function getMemoizeScrollTo(getScrollableInstance) {
  const instance = getScrollableInstance();
  let lastParams = {};
  return function(params) {
    let force = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const normalizedParams = {
      top: void 0 !== params.top ? Math.ceil(params.top) : void 0,
      left: void 0 !== params.left ? Math.ceil(params.left) : void 0
    };
    const isSameParams = normalizedParams.top === lastParams.top && normalizedParams.left === lastParams.left;
    if (!force && isSameParams) {
      return;
    }
    lastParams = normalizedParams;
    instance.scrollTo(params);
  };
}

// ../../../../../../node_modules/devextreme/esm/__internal/core/r1/utils/shallow_equals.js
var shallowEquals2 = (firstObject, secondObject) => {
  if (Object.keys(firstObject).length !== Object.keys(secondObject).length) {
    return false;
  }
  return Object.keys(firstObject).every((key) => firstObject[key] === secondObject[key]);
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/r1/template_wrapper.js
var _excluded16 = ["isEqual"];
var isDxElementWrapper2 = (element) => !!element.toArray;
var buildTemplateArgs2 = (model, template) => {
  const args = {
    template,
    model: _extends({}, model)
  };
  const _ref = model.data ?? {}, {
    isEqual: isEqual2
  } = _ref, data2 = _objectWithoutPropertiesLoose(_ref, _excluded16);
  if (isEqual2) {
    args.model.data = data2;
    args.isEqual = isEqual2;
  }
  return args;
};
var renderTemplateContent2 = (props, container) => {
  const {
    data: data2,
    index: index2
  } = props.model ?? {
    data: {}
  };
  if (data2) {
    Object.keys(data2).forEach((name2) => {
      if (data2[name2] && dom_adapter_default.isNode(data2[name2])) {
        data2[name2] = getPublicElement(renderer_default(data2[name2]));
      }
    });
  }
  const rendered = props.template.render(_extends({
    container,
    transclude: props.transclude
  }, {
    renovated: props.renovated
  }, !props.transclude ? {
    model: data2
  } : {}, !props.transclude && Number.isFinite(index2) ? {
    index: index2
  } : {}));
  if (void 0 === rendered) {
    return [];
  }
  return isDxElementWrapper2(rendered) ? rendered.toArray() : [renderer_default(rendered).get(0)];
};
var removeDifferentElements2 = (oldChildren, newChildren) => {
  newChildren.forEach((newElement) => {
    const hasOldChild = !!oldChildren.find((oldElement) => newElement === oldElement);
    if (!hasOldChild && newElement.parentNode) {
      renderer_default(newElement).remove();
    }
  });
};
var TemplateWrapper2 = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.renderTemplate = this.renderTemplate.bind(this);
  }
  renderTemplate() {
    const node = findDOMfromVNode(this.$LI, true);
    if (!(null !== node && void 0 !== node && node.parentNode)) {
      return () => {
      };
    }
    const container = node.parentNode;
    const $container = renderer_default(container);
    const $oldContainerContent = $container.contents().toArray();
    const content = renderTemplateContent2(this.props, getPublicElement($container));
    replaceWith(renderer_default(node), renderer_default(content));
    return () => {
      const $actualContainerContent = renderer_default(container).contents().toArray();
      removeDifferentElements2($oldContainerContent, $actualContainerContent);
      container.appendChild(node);
    };
  }
  shouldComponentUpdate(nextProps) {
    const {
      template,
      model
    } = this.props;
    const {
      template: nextTemplate,
      model: nextModel,
      isEqual: isEqual2
    } = nextProps;
    const equalityComparer = isEqual2 ?? shallowEquals2;
    if (template !== nextTemplate) {
      return true;
    }
    if (!isDefined(model) || !isDefined(nextModel)) {
      return model !== nextModel;
    }
    const {
      data: data2,
      index: index2
    } = model;
    const {
      data: nextData,
      index: nextIndex
    } = nextModel;
    if (index2 !== nextIndex) {
      return true;
    }
    return !equalityComparer(data2, nextData);
  }
  createEffects() {
    return [new InfernoEffect(this.renderTemplate, [this.props.template, this.props.model])];
  }
  updateEffects() {
    this._effects[0].update([this.props.template, this.props.model]);
  }
  componentWillUnmount() {
  }
  render() {
    return null;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/r1/utils/get_template.js
var getTemplate3 = (TemplateProp) => TemplateProp && (TemplateProp.defaultProps ? (props) => normalizeProps(createComponentVNode(2, TemplateProp, _extends({}, props))) : TemplateProp);

// ../../../../../../node_modules/devextreme/esm/__internal/core/r1/utils/update_props_immutable.js
var cloneObjectValue2 = (value2) => Array.isArray(value2) ? [...value2] : _extends({}, value2);
var cloneObjectProp2 = (value2, prevValue, fullNameParts) => {
  const result2 = fullNameParts.length > 0 && prevValue && value2 !== prevValue ? cloneObjectValue2(prevValue) : cloneObjectValue2(value2);
  const name2 = fullNameParts[0];
  if (fullNameParts.length > 1) {
    result2[name2] = cloneObjectProp2(value2[name2], null === prevValue || void 0 === prevValue ? void 0 : prevValue[name2], fullNameParts.slice(1));
  } else if (name2) {
    if (isPlainObject(value2[name2])) {
      result2[name2] = cloneObjectValue2(value2[name2]);
    } else {
      result2[name2] = value2[name2];
    }
  }
  return result2;
};
var updatePropsImmutable2 = (props, option, name2, fullName) => {
  const currentPropsValue = option[name2];
  const prevPropsValue = props[name2];
  const result2 = props;
  if (isPlainObject(currentPropsValue) || name2 !== fullName && Array.isArray(currentPropsValue)) {
    result2[name2] = cloneObjectProp2(currentPropsValue, prevPropsValue, getPathParts(fullName).slice(1));
  } else {
    result2[name2] = currentPropsValue;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/r1/component_wrapper.js
var setDefaultOptionValue2 = (options2, defaultValueGetter) => (name2) => {
  if (Object.prototype.hasOwnProperty.call(options2, name2) && void 0 === options2[name2]) {
    options2[name2] = defaultValueGetter(name2);
  }
};
var ComponentWrapper2 = class extends dom_component_default {
  get _propsInfo() {
    return {
      allowNull: [],
      twoWay: [],
      elements: [],
      templates: [],
      props: []
    };
  }
  constructor(element, options2) {
    super(element, options2);
    this._shouldRaiseContentReady = false;
    this.validateKeyDownHandler();
  }
  validateKeyDownHandler() {
    const supportedKeyNames = this.getSupportedKeyNames();
    const hasComponentDefaultKeyHandlers = supportedKeyNames.length > 0;
    const hasComponentKeyDownMethod = "function" === typeof this._viewComponent.prototype.keyDown;
    if (hasComponentDefaultKeyHandlers && !hasComponentKeyDownMethod) {
      throw Error("Component's declaration must have 'keyDown' method.");
    }
  }
  get viewRef() {
    var _this$_viewRef;
    return null === (_this$_viewRef = this._viewRef) || void 0 === _this$_viewRef ? void 0 : _this$_viewRef.current;
  }
  _checkContentReadyOption(fullName) {
    const contentReadyOptions = this._getContentReadyOptions().reduce((options2, name2) => {
      options2[name2] = true;
      return options2;
    }, {});
    this._checkContentReadyOption = (optionName) => !!contentReadyOptions[optionName];
    return this._checkContentReadyOption(fullName);
  }
  _getContentReadyOptions() {
    return ["rtlEnabled"];
  }
  _fireContentReady() {
    this._actionsMap.onContentReady({});
  }
  _getDefaultOptions() {
    const viewDefaultProps = this._getViewComponentDefaultProps();
    return extend(true, super._getDefaultOptions(), viewDefaultProps, this._propsInfo.twoWay.reduce((options2, _ref) => {
      let [name2, defaultName, eventName] = _ref;
      return _extends({}, options2, {
        [name2]: viewDefaultProps[defaultName],
        [eventName]: (value2) => this.option(name2, value2)
      });
    }, {}), this._propsInfo.templates.reduce((options2, name2) => _extends({}, options2, {
      [name2]: null
    }), {}));
  }
  _getUnwrappedOption() {
    const unwrappedProps = {};
    Object.keys(this.option()).forEach((key) => {
      unwrappedProps[key] = this.option(key);
    });
    return unwrappedProps;
  }
  _initializeComponent() {
    var _this$_templateManage;
    super._initializeComponent();
    null === (_this$_templateManage = this._templateManager) || void 0 === _this$_templateManage || _this$_templateManage.addDefaultTemplates(this.getDefaultTemplates());
    const optionProxy = this._getUnwrappedOption();
    this._props = this._optionsWithDefaultTemplates(optionProxy);
    this._propsInfo.templates.forEach((template) => {
      this._componentTemplates[template] = this._createTemplateComponent(this._props[template]);
    });
    Object.keys(this._getActionConfigsFull()).forEach((name2) => this._addAction(name2));
    this._viewRef = createRef();
    this.defaultKeyHandlers = this._createDefaultKeyHandlers();
  }
  _initMarkup() {
    const props = this.getProps();
    this._renderWrapper(props);
  }
  _renderWrapper(props) {
    const containerNode = this.$element()[0];
    if (!this._isNodeReplaced) {
      inferno_renderer_default.onPreRender();
    }
    inferno_renderer_default.render(this._viewComponent, props, containerNode, this._isNodeReplaced);
    if (!this._isNodeReplaced) {
      this._isNodeReplaced = true;
      inferno_renderer_default.onAfterRender();
      this._shouldRaiseContentReady = true;
    }
    if (this._shouldRaiseContentReady) {
      this._fireContentReady();
      this._shouldRaiseContentReady = false;
    }
  }
  _silent(name2, value2) {
    this._options.silent(name2, value2);
  }
  _render() {
  }
  _removeWidget() {
    inferno_renderer_default.remove(this.$element()[0]);
  }
  _dispose() {
    this._removeWidget();
    super._dispose();
  }
  get elementAttr() {
    const element = this.$element()[0];
    if (!this._elementAttr) {
      const {
        attributes
      } = element;
      const attrs = Array.from(attributes).filter((attr) => {
        var _attributes$attr$name;
        return !this._propsInfo.templates.includes(attr.name) && (null === (_attributes$attr$name = attributes[attr.name]) || void 0 === _attributes$attr$name ? void 0 : _attributes$attr$name.specified);
      }).reduce((result2, _ref2) => {
        let {
          name: name2,
          value: value2
        } = _ref2;
        const updatedAttributes = result2;
        const isDomAttr = name2 in element;
        updatedAttributes[name2] = "" === value2 && isDomAttr ? element[name2] : value2;
        return updatedAttributes;
      }, {});
      this._elementAttr = attrs;
      this._storedClasses = element.getAttribute("class") || "";
    }
    const elemStyle = element.style;
    const style = {};
    for (let i = 0; i < elemStyle.length; i += 1) {
      style[elemStyle[i]] = elemStyle.getPropertyValue(elemStyle[i]);
    }
    this._elementAttr.style = style;
    this._elementAttr.class = this._storedClasses;
    return this._elementAttr;
  }
  _getAdditionalActionConfigs() {
    return {
      onContentReady: {
        excludeValidators: ["disabled", "readOnly"]
      }
    };
  }
  _getAdditionalProps() {
    return [];
  }
  _patchOptionValues(options2) {
    const {
      allowNull,
      twoWay,
      elements,
      props
    } = this._propsInfo;
    const viewDefaultProps = this._getViewComponentDefaultProps();
    const defaultWidgetPropsKeys = Object.keys(viewDefaultProps);
    const defaultOptions3 = this._getDefaultOptions();
    const {
      ref,
      children,
      onKeyboardHandled
    } = options2;
    const onKeyDown = onKeyboardHandled ? (_, event_options) => {
      onKeyboardHandled(event_options);
    } : void 0;
    const widgetProps = {
      ref,
      children,
      onKeyDown
    };
    [...props, ...this._getAdditionalProps()].forEach((propName) => {
      if (Object.prototype.hasOwnProperty.call(options2, propName)) {
        widgetProps[propName] = options2[propName];
      }
    });
    allowNull.forEach(setDefaultOptionValue2(widgetProps, () => null));
    defaultWidgetPropsKeys.forEach(setDefaultOptionValue2(widgetProps, (name2) => defaultOptions3[name2]));
    twoWay.forEach((_ref3) => {
      let [name2, defaultName] = _ref3;
      setDefaultOptionValue2(widgetProps, () => defaultOptions3[defaultName])(name2);
    });
    elements.forEach((name2) => {
      if (name2 in widgetProps) {
        const value2 = widgetProps[name2];
        if (isRenderer(value2)) {
          widgetProps[name2] = this._patchElementParam(value2);
        }
      }
    });
    return widgetProps;
  }
  getSupportedKeyNames() {
    return [];
  }
  prepareStyleProp(props) {
    if ("string" === typeof props.style) {
      return _extends({}, props, {
        style: {},
        cssText: props.style
      });
    }
    return props;
  }
  getProps() {
    const {
      elementAttr
    } = this.option();
    const options2 = this._patchOptionValues(_extends({}, this._props, {
      ref: this._viewRef,
      children: this._extractDefaultSlot(),
      aria: this._aria
    }));
    this._propsInfo.templates.forEach((template) => {
      options2[template] = this._componentTemplates[template];
    });
    return this.prepareStyleProp(_extends({}, options2, this.elementAttr, elementAttr, {
      className: [...(this.elementAttr.class ?? "").split(" "), ...((null === elementAttr || void 0 === elementAttr ? void 0 : elementAttr.class) ?? "").split(" ")].filter((c, i, a) => c && a.indexOf(c) === i).join(" ").trim(),
      class: ""
    }, this._actionsMap));
  }
  _getActionConfigs() {
    return {};
  }
  _getActionConfigsFull() {
    return _extends({}, this._getActionConfigs(), this._getAdditionalActionConfigs());
  }
  getDefaultTemplates() {
    const defaultTemplates = Object.values(this._templatesInfo);
    const result2 = {};
    defaultTemplates.forEach((template) => {
      result2[template] = "dx-renovation-template-mock";
    });
    return result2;
  }
  get _templatesInfo() {
    return {};
  }
  _optionsWithDefaultTemplates(options2) {
    const templateOptions = Object.entries(this._templatesInfo).reduce((result2, _ref4) => {
      let [templateName, templateValue] = _ref4;
      return _extends({}, result2, {
        [templateName]: options2[templateName] ?? templateValue
      });
    }, {});
    return _extends({}, options2, templateOptions);
  }
  _init() {
    super._init();
    this.customKeyHandlers = {};
    this._actionsMap = {};
    this._aria = {};
    this._componentTemplates = {};
  }
  _createDefaultKeyHandlers() {
    const result2 = {};
    const keys = this.getSupportedKeyNames();
    keys.forEach((key) => {
      result2[key] = (e) => this.viewRef.keyDown(keyboard_processor_default.createKeyDownOptions(e));
    });
    return result2;
  }
  _addAction(event, actionToAdd) {
    let action = actionToAdd;
    if (!action) {
      const actionByOption = this._createActionByOption(event, this._getActionConfigsFull()[event]);
      action = (actArgs) => {
        Object.keys(actArgs).forEach((name2) => {
          if (isDefined(actArgs[name2]) && dom_adapter_default.isNode(actArgs[name2])) {
            actArgs[name2] = getPublicElement(renderer_default(actArgs[name2]));
          }
        });
        return actionByOption(actArgs);
      };
    }
    this._actionsMap[event] = action;
  }
  _optionChanged(option) {
    const {
      name: name2,
      fullName,
      value: value2,
      previousValue
    } = option;
    updatePropsImmutable2(this._props, this.option(), name2, fullName);
    if (this._propsInfo.templates.includes(name2) && value2 !== previousValue) {
      this._componentTemplates[name2] = this._createTemplateComponent(value2);
    }
    if (name2 && this._getActionConfigsFull()[name2]) {
      this._addAction(name2);
    }
    this._shouldRaiseContentReady = this._shouldRaiseContentReady || this._checkContentReadyOption(fullName);
    super._optionChanged(option);
    this._invalidate();
  }
  _extractDefaultSlot() {
    if (this.option("_hasAnonymousTemplateContent")) {
      return inferno_renderer_default.createElement(TemplateWrapper2, {
        template: this._getTemplate(this._templateManager.anonymousTemplateName),
        transclude: true,
        renovated: true
      });
    }
    return null;
  }
  _createTemplateComponent(templateOption) {
    if (!templateOption) {
      return;
    }
    const template = this._getTemplate(templateOption);
    if (isString(template) && "dx-renovation-template-mock" === template) {
      return;
    }
    return (model) => inferno_renderer_default.createElement(TemplateWrapper2, buildTemplateArgs2(model, template));
  }
  _wrapKeyDownHandler(initialHandler) {
    return (options2) => {
      const {
        originalEvent,
        keyName,
        which
      } = options2;
      const keys = this.customKeyHandlers;
      const func = keys[keyName] || keys[which];
      if (void 0 !== func) {
        const handler = func.bind(this);
        const result2 = handler(originalEvent, options2);
        if (!result2) {
          originalEvent.cancel = true;
          return originalEvent;
        }
      }
      return null === initialHandler || void 0 === initialHandler ? void 0 : initialHandler(originalEvent, options2);
    };
  }
  _toPublicElement(element) {
    return getPublicElement(renderer_default(element));
  }
  _patchElementParam(value2) {
    try {
      const result2 = renderer_default(value2);
      const element = null === result2 || void 0 === result2 ? void 0 : result2.get(0);
      return null !== element && void 0 !== element && element.nodeType ? element : value2;
    } catch (error) {
      return value2;
    }
  }
  repaint() {
    this._isNodeReplaced = false;
    this._shouldRaiseContentReady = true;
    this._removeWidget();
    this._refresh();
  }
  _supportedKeys() {
    return _extends({}, this.defaultKeyHandlers, this.customKeyHandlers);
  }
  registerKeyHandler(key, handler) {
    this.customKeyHandlers[key] = handler;
  }
  setAria(name2, value2) {
    this._aria[name2] = value2;
    this._initMarkup();
  }
  _getViewComponentDefaultProps() {
    return this._viewComponent.defaultProps || {};
  }
};
ComponentWrapper2.IS_RENOVATED_WIDGET = false;
ComponentWrapper2.IS_RENOVATED_WIDGET = true;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/all_day_panel_title.js
var AllDayPanelTitle = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const text = message_default.format("dxScheduler-allDay");
    return createVNode(1, "div", "dx-scheduler-all-day-title", text, 0);
  }
};
AllDayPanelTitle.defaultProps = {};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/all_day_panel_title.js
var AllDayPanelTitleComponent = class extends ComponentWrapper2 {
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: [],
      props: []
    };
  }
  get _viewComponent() {
    return AllDayPanelTitle;
  }
};
component_registrator_default("dxAllDayPanelTitle", AllDayPanelTitleComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/const.js
var DefaultSizes = {
  allDayPanelHeight: 25
};
var DATE_TABLE_CELL_CLASS = "dx-scheduler-date-table-cell";
var DATE_TABLE_ROW_CLASS2 = "dx-scheduler-date-table-row";
var ALL_DAY_PANEL_CELL_CLASS = "dx-scheduler-all-day-table-cell";

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/cell.js
var CellBaseDefaultProps = {
  className: "",
  isFirstGroupCell: false,
  isLastGroupCell: false,
  startDate: /* @__PURE__ */ new Date(),
  endDate: /* @__PURE__ */ new Date(),
  allDay: false,
  text: "",
  index: 0,
  contentTemplateProps: {
    data: {},
    index: 0
  }
};
var CellBase = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      isFirstGroupCell,
      isLastGroupCell,
      children,
      ariaLabel
    } = this.props;
    const classes = renderUtils.getGroupCellClasses(isFirstGroupCell, isLastGroupCell, className);
    return createVNode(1, "td", classes, children, 0, {
      "aria-label": ariaLabel
    });
  }
};
CellBase.defaultProps = CellBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_table_cell_base.js
var DateTableCallBaseDefaultProps = _extends({}, CellBaseDefaultProps, {
  otherMonth: false,
  today: false,
  firstDayOfMonth: false,
  isSelected: false,
  isFocused: false
});
var DateTableCellBase = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.dataCellTemplateProps = null;
  }
  getDataCellTemplateProps() {
    if (null !== this.dataCellTemplateProps) {
      return this.dataCellTemplateProps;
    }
    const {
      allDay,
      contentTemplateProps,
      endDate,
      groupIndex,
      groups,
      index: index2,
      startDate
    } = this.props;
    this.dataCellTemplateProps = {
      data: _extends({
        startDate,
        endDate,
        groups,
        groupIndex: groups ? groupIndex : void 0,
        text: "",
        allDay: !!allDay || void 0
      }, null === contentTemplateProps || void 0 === contentTemplateProps ? void 0 : contentTemplateProps.data),
      index: index2
    };
    return this.dataCellTemplateProps;
  }
  componentWillUpdate(nextProps) {
    if (this.props.allDay !== nextProps.allDay || this.props.contentTemplateProps !== nextProps.contentTemplateProps || this.props.endDate !== nextProps.endDate || this.props.groupIndex !== nextProps.groupIndex || this.props.groups !== nextProps.groups || this.props.index !== nextProps.index || this.props.startDate !== nextProps.startDate) {
      this.dataCellTemplateProps = null;
    }
  }
  render() {
    const {
      viewContext,
      allDay,
      className,
      isFocused,
      isSelected,
      isFirstGroupCell,
      isLastGroupCell,
      dataCellTemplate,
      children
    } = this.props;
    const {
      view: {
        type: viewType
      },
      crossScrollingEnabled
    } = viewContext;
    const cellSizeHorizontalClass = renderUtils.getCellSizeHorizontalClass(viewType, crossScrollingEnabled);
    const cellSizeVerticalClass = renderUtils.getCellSizeVerticalClass(!!allDay);
    const classes = renderUtils.combineClasses({
      [cellSizeHorizontalClass]: true,
      [cellSizeVerticalClass]: true,
      [DATE_TABLE_CELL_CLASS]: !allDay,
      "dx-state-focused": isSelected,
      "dx-scheduler-focused-cell": isFocused,
      [className ?? ""]: true
    });
    const ariaLabel = isSelected ? "Add appointment" : void 0;
    const dataCellTemplateProps = this.getDataCellTemplateProps();
    const DataCellTemplateComponent = getTemplate3(dataCellTemplate);
    return createComponentVNode(2, CellBase, {
      className: classes,
      viewContext,
      isFirstGroupCell,
      isLastGroupCell,
      ariaLabel,
      startDate: CellBaseDefaultProps.startDate,
      endDate: CellBaseDefaultProps.endDate,
      index: CellBaseDefaultProps.index,
      children: createFragment([!DataCellTemplateComponent && children, !!DataCellTemplateComponent && DataCellTemplateComponent({
        index: dataCellTemplateProps.index,
        data: dataCellTemplateProps.data
      })], 0)
    });
  }
};
DateTableCellBase.defaultProps = DateTableCallBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/all_day_panel_cell.js
var AllDayPanelCell = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      viewContext,
      dataCellTemplate,
      endDate,
      groupIndex,
      groups,
      index: index2,
      isFirstGroupCell,
      isFocused,
      isLastGroupCell,
      isSelected,
      startDate
    } = this.props;
    const DataCellTemplateComponent = getTemplate3(dataCellTemplate);
    return createComponentVNode(2, DateTableCellBase, {
      className: `${ALL_DAY_PANEL_CELL_CLASS} ${className}`,
      viewContext,
      startDate,
      endDate,
      groups,
      groupIndex,
      allDay: true,
      isFirstGroupCell,
      isLastGroupCell,
      index: index2,
      dataCellTemplate: DataCellTemplateComponent,
      isSelected,
      isFocused
    });
  }
};
AllDayPanelCell.defaultProps = DateTableCallBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/ordinary_cell.js
var OrdinaryCellDefaultProps = {};
var OrdinaryCell = class extends BaseInfernoComponent {
  render() {
    const {
      children,
      className,
      colSpan,
      styles
    } = this.props;
    return createVNode(1, "td", className, children, 0, {
      style: normalizeStyles(styles),
      colSpan
    });
  }
};
OrdinaryCell.defaultProps = OrdinaryCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/header_cell.js
var HeaderCell = class extends BaseInfernoComponent {
  render() {
    const {
      children,
      className,
      colSpan,
      styles
    } = this.props;
    return createVNode(1, "th", className, children, 0, {
      style: normalizeStyles(styles),
      colSpan
    });
  }
};
HeaderCell.defaultProps = OrdinaryCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/virtual_cell.js
var VirtualCellDefaultProps = {
  width: 0,
  isHeaderCell: false
};
var VirtualCell = class extends BaseInfernoComponent {
  render() {
    const {
      colSpan,
      isHeaderCell,
      width,
      styles
    } = this.props;
    const modifiedStyles = renderUtils.addWidthToStyle(width, styles);
    const Cell = isHeaderCell ? HeaderCell : OrdinaryCell;
    return createComponentVNode(2, Cell, {
      className: "dx-scheduler-virtual-cell",
      styles: modifiedStyles,
      colSpan
    });
  }
};
VirtualCell.defaultProps = VirtualCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/row.js
var RowDefaultProps = {
  className: "",
  leftVirtualCellWidth: 0,
  rightVirtualCellWidth: 0,
  isHeaderRow: false
};
var Row = class extends BaseInfernoComponent {
  render() {
    const {
      children,
      className,
      isHeaderRow,
      leftVirtualCellCount,
      leftVirtualCellWidth,
      rightVirtualCellCount,
      rightVirtualCellWidth,
      styles
    } = this.props;
    const hasLeftVirtualCell = !!leftVirtualCellCount;
    const hasRightVirtualCell = !!rightVirtualCellCount;
    return createVNode(1, "tr", className, [hasLeftVirtualCell && null != leftVirtualCellCount && splitNumber(leftVirtualCellCount, 1e3).map((colSpan, index2) => createComponentVNode(2, VirtualCell, {
      className: `left-virtual-cell-${index2}`,
      width: leftVirtualCellWidth * (colSpan / leftVirtualCellCount),
      colSpan,
      isHeaderCell: isHeaderRow ?? VirtualCellDefaultProps.isHeaderCell
    })), children, hasRightVirtualCell && null != rightVirtualCellCount && splitNumber(rightVirtualCellCount, 1e3).map((colSpan, index2) => createComponentVNode(2, VirtualCell, {
      className: `right-virtual-cell-${index2}`,
      width: rightVirtualCellWidth * (colSpan / rightVirtualCellCount),
      colSpan,
      isHeaderCell: isHeaderRow ?? VirtualCellDefaultProps.isHeaderCell
    }))], 0, {
      style: normalizeStyles(styles)
    });
  }
};
Row.defaultProps = RowDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/all_day_panel_table_body.js
var AllDayPanelTableBodyDefaultProps = {
  viewData: [],
  isVerticalGroupOrientation: false,
  className: "",
  leftVirtualCellWidth: 0,
  rightVirtualCellWidth: 0
};
var AllDayPanelTableBody = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      viewData,
      viewContext,
      leftVirtualCellWidth,
      rightVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellCount,
      isVerticalGroupOrientation,
      dataCellTemplate
    } = this.props;
    const classes = renderUtils.combineClasses({
      "dx-scheduler-all-day-table-row": true,
      [className ?? ""]: !!className
    });
    const DataCellTemplateComponent = getTemplate3(dataCellTemplate);
    return createComponentVNode(2, Row, {
      leftVirtualCellWidth,
      rightVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellCount,
      className: classes,
      children: viewData.map((_ref) => {
        let {
          endDate,
          groupIndex: cellGroupIndex,
          groups,
          index: cellIndex,
          isFirstGroupCell,
          isFocused,
          isLastGroupCell,
          isSelected,
          key,
          startDate
        } = _ref;
        return createComponentVNode(2, AllDayPanelCell, {
          viewContext,
          isFirstGroupCell: !isVerticalGroupOrientation && isFirstGroupCell,
          isLastGroupCell: !isVerticalGroupOrientation && isLastGroupCell,
          startDate,
          endDate,
          groups,
          groupIndex: cellGroupIndex,
          index: cellIndex,
          dataCellTemplate: DataCellTemplateComponent,
          isSelected: isSelected ?? false,
          isFocused: isFocused ?? false
        }, key);
      })
    });
  }
};
AllDayPanelTableBody.defaultProps = AllDayPanelTableBodyDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/layout_props.js
var LayoutDefaultProps = {
  viewData: {
    groupedData: [],
    leftVirtualCellCount: 0,
    rightVirtualCellCount: 0,
    topVirtualRowCount: 0,
    bottomVirtualRowCount: 0
  },
  leftVirtualCellWidth: 0,
  rightVirtualCellWidth: 0,
  topVirtualRowHeight: 0,
  bottomVirtualRowHeight: 0,
  addDateTableClass: true,
  addVerticalSizesClassToRows: true
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/virtual_row.js
var VirtualRowDefaultProps = _extends({}, RowDefaultProps, {
  leftVirtualCellWidth: 0,
  rightVirtualCellWidth: 0,
  cellsCount: 1
});
var VirtualRow = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.virtualCells = null;
  }
  getVirtualCells() {
    if (null !== this.virtualCells) {
      return this.virtualCells;
    }
    const {
      cellsCount
    } = this.props;
    this.virtualCells = [...Array(cellsCount)];
    return this.virtualCells;
  }
  componentWillUpdate(nextProps) {
    if (this.props.cellsCount !== nextProps.cellsCount) {
      this.virtualCells = null;
    }
  }
  render() {
    const {
      className,
      leftVirtualCellCount,
      leftVirtualCellWidth,
      rightVirtualCellCount,
      rightVirtualCellWidth,
      styles,
      height
    } = this.props;
    const classes = `dx-scheduler-virtual-row ${className}`;
    const modifiedStyles = renderUtils.addHeightToStyle(height, styles);
    const virtualCells = this.getVirtualCells();
    return createComponentVNode(2, Row, {
      className: classes,
      styles: modifiedStyles,
      leftVirtualCellWidth,
      rightVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellCount,
      children: virtualCells.map((_, index2) => createComponentVNode(2, VirtualCell, {
        width: VirtualCellDefaultProps.width,
        isHeaderCell: VirtualCellDefaultProps.isHeaderCell
      }, index2.toString()))
    });
  }
};
VirtualRow.defaultProps = VirtualRowDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/table.js
var TableDefaultProps = {
  topVirtualRowHeight: 0,
  bottomVirtualRowHeight: 0,
  leftVirtualCellWidth: 0,
  rightVirtualCellWidth: 0,
  virtualCellsCount: 0
};
var Table = class extends BaseInfernoComponent {
  getResultStyles() {
    const {
      height,
      width,
      styles
    } = this.props;
    const heightAdded = renderUtils.addHeightToStyle(height, styles);
    return renderUtils.addWidthToStyle(width, heightAdded);
  }
  render() {
    const {
      className,
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      children,
      leftVirtualCellCount,
      leftVirtualCellWidth,
      rightVirtualCellCount,
      rightVirtualCellWidth,
      tableRef,
      virtualCellsCount
    } = this.props;
    const hasTopVirtualRow = !!topVirtualRowHeight;
    const hasBottomVirtualRow = !!bottomVirtualRowHeight;
    const resultStyles = this.getResultStyles();
    return createVNode(1, "table", className, createVNode(1, "tbody", null, [hasTopVirtualRow && createComponentVNode(2, VirtualRow, {
      height: topVirtualRowHeight,
      cellsCount: virtualCellsCount ?? VirtualRowDefaultProps.cellsCount,
      leftVirtualCellWidth: leftVirtualCellWidth ?? VirtualRowDefaultProps.leftVirtualCellWidth,
      rightVirtualCellWidth: rightVirtualCellWidth ?? VirtualRowDefaultProps.rightVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellCount
    }), children, hasBottomVirtualRow && createComponentVNode(2, VirtualRow, {
      height: bottomVirtualRowHeight,
      cellsCount: virtualCellsCount ?? VirtualRowDefaultProps.cellsCount,
      leftVirtualCellWidth: leftVirtualCellWidth ?? VirtualRowDefaultProps.leftVirtualCellWidth,
      rightVirtualCellWidth: rightVirtualCellWidth ?? VirtualRowDefaultProps.rightVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellCount
    })], 0), 2, {
      style: normalizeStyles(resultStyles)
    }, null, tableRef);
  }
};
Table.defaultProps = TableDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/all_day_panel_table.js
var AllDayTable = class extends InfernoWrapperComponent {
  constructor() {
    super(...arguments);
    this.allDayPanelData = null;
  }
  createEffects() {
    return [createReRenderEffect()];
  }
  getAllDayPanelData() {
    if (null !== this.allDayPanelData) {
      return this.allDayPanelData;
    }
    this.allDayPanelData = this.props.viewData.groupedData[0].allDayPanel;
    return this.allDayPanelData;
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.viewData !== nextProps.viewData) {
      this.allDayPanelData = null;
    }
  }
  render() {
    const {
      viewData,
      viewContext,
      width,
      tableRef,
      dataCellTemplate
    } = this.props;
    const allDayPanelData = this.getAllDayPanelData();
    const DataCellTemplateComponent = getTemplate3(dataCellTemplate);
    return createComponentVNode(2, Table, {
      className: "dx-scheduler-all-day-table",
      height: allDayPanelData ? void 0 : DefaultSizes.allDayPanelHeight,
      width,
      tableRef,
      children: createComponentVNode(2, AllDayPanelTableBody, {
        viewData: allDayPanelData ?? AllDayPanelTableBodyDefaultProps.viewData,
        viewContext,
        leftVirtualCellWidth: viewData.leftVirtualCellWidth ?? AllDayPanelTableBodyDefaultProps.leftVirtualCellWidth,
        rightVirtualCellWidth: viewData.rightVirtualCellWidth ?? AllDayPanelTableBodyDefaultProps.rightVirtualCellWidth,
        leftVirtualCellCount: viewData.leftVirtualCellCount,
        rightVirtualCellCount: viewData.rightVirtualCellCount,
        dataCellTemplate: DataCellTemplateComponent
      })
    });
  }
};
AllDayTable.defaultProps = LayoutDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_table_body.js
var DateTableBodyDefaultProps = _extends({}, LayoutDefaultProps, {
  cellTemplate: DateTableCellBase
});
var DateTableBody = class extends BaseInfernoComponent {
  render() {
    const {
      viewData,
      viewContext,
      addVerticalSizesClassToRows,
      cellTemplate,
      dataCellTemplate
    } = this.props;
    const rowClasses = renderUtils.combineClasses({
      [DATE_TABLE_ROW_CLASS2]: true,
      "dx-scheduler-cell-sizes-vertical": addVerticalSizesClassToRows
    });
    const CellTemplateComponent = getTemplate3(cellTemplate);
    const DataCellTemplateComponent = getTemplate3(dataCellTemplate);
    return createFragment(viewData.groupedData.map((_ref) => {
      let {
        allDayPanel,
        dateTable,
        isGroupedAllDayPanel,
        key: fragmentKey
      } = _ref;
      return createFragment([isGroupedAllDayPanel && createComponentVNode(2, AllDayPanelTableBody, {
        viewData: allDayPanel ?? AllDayPanelTableBodyDefaultProps.viewData,
        viewContext,
        dataCellTemplate: DataCellTemplateComponent,
        isVerticalGroupOrientation: true,
        leftVirtualCellWidth: viewData.leftVirtualCellWidth ?? AllDayPanelTableBodyDefaultProps.leftVirtualCellWidth,
        rightVirtualCellWidth: viewData.rightVirtualCellWidth ?? AllDayPanelTableBodyDefaultProps.rightVirtualCellWidth,
        leftVirtualCellCount: viewData.leftVirtualCellCount,
        rightVirtualCellCount: viewData.rightVirtualCellCount
      }), dateTable.map((_ref2) => {
        let {
          cells,
          key: rowKey
        } = _ref2;
        return createComponentVNode(2, Row, {
          className: rowClasses,
          leftVirtualCellWidth: viewData.leftVirtualCellWidth ?? RowDefaultProps.leftVirtualCellWidth,
          rightVirtualCellWidth: viewData.rightVirtualCellWidth ?? RowDefaultProps.rightVirtualCellWidth,
          leftVirtualCellCount: viewData.leftVirtualCellCount,
          rightVirtualCellCount: viewData.rightVirtualCellCount,
          children: cells.map((_ref3) => {
            let {
              key: cellKey,
              endDate,
              firstDayOfMonth,
              groupIndex: cellGroupIndex,
              groups,
              index: cellIndex,
              isFirstGroupCell,
              isFocused,
              isLastGroupCell,
              isSelected,
              otherMonth,
              startDate,
              text,
              today
            } = _ref3;
            return CellTemplateComponent({
              key: cellKey,
              viewContext,
              isFirstGroupCell,
              isLastGroupCell,
              startDate,
              endDate,
              groups,
              groupIndex: cellGroupIndex,
              index: cellIndex,
              dataCellTemplate: DataCellTemplateComponent,
              text,
              today,
              otherMonth,
              firstDayOfMonth,
              isSelected,
              isFocused
            });
          })
        }, rowKey);
      })], 0, fragmentKey);
    }), 0);
  }
};
DateTableBody.defaultProps = DateTableBodyDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_table.js
var _excluded17 = ["viewData", "viewContext", "tableRef", "addDateTableClass", "width", "cellTemplate", "dataCellTemplate", "groupOrientation", "addVerticalSizesClassToRows"];
var DateTableDefaultProps = _extends({}, LayoutDefaultProps, {
  cellTemplate: DateTableCellBase
});
var DateTable = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const _this$props = this.props, {
      viewData,
      viewContext,
      tableRef,
      addDateTableClass,
      width,
      cellTemplate,
      dataCellTemplate,
      groupOrientation,
      addVerticalSizesClassToRows
    } = _this$props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded17);
    const classes = addDateTableClass ? "dx-scheduler-date-table" : void 0;
    const topVirtualRowHeight = viewData.topVirtualRowHeight ?? 0;
    const bottomVirtualRowHeight = viewData.bottomVirtualRowHeight ?? 0;
    const leftVirtualCellWidth = viewData.leftVirtualCellWidth ?? 0;
    const rightVirtualCellWidth = viewData.rightVirtualCellWidth ?? 0;
    const virtualCellsCount = viewData.groupedData[0].dateTable[0].cells.length;
    const CellTemplateComponent = getTemplate3(cellTemplate);
    const DataCellTemplateComponent = getTemplate3(dataCellTemplate);
    return normalizeProps(createComponentVNode(2, Table, _extends({}, restProps, {
      tableRef,
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      leftVirtualCellWidth,
      rightVirtualCellWidth,
      leftVirtualCellCount: viewData.leftVirtualCellCount,
      rightVirtualCellCount: viewData.rightVirtualCellCount,
      virtualCellsCount,
      className: classes,
      width,
      children: createComponentVNode(2, DateTableBody, {
        viewData,
        viewContext,
        cellTemplate: CellTemplateComponent,
        dataCellTemplate: DataCellTemplateComponent,
        leftVirtualCellWidth,
        rightVirtualCellWidth,
        groupOrientation,
        addVerticalSizesClassToRows,
        topVirtualRowHeight: DateTableBodyDefaultProps.topVirtualRowHeight,
        bottomVirtualRowHeight: DateTableBodyDefaultProps.bottomVirtualRowHeight,
        addDateTableClass: DateTableBodyDefaultProps.addDateTableClass
      })
    })));
  }
};
DateTable.defaultProps = DateTableDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/date_table.js
var DateTableComponent = class extends ComponentWrapper2 {
  _setOptionsByReference() {
    super._setOptionsByReference();
    this._optionsByReference = _extends({}, this._optionsByReference, {
      dataCellTemplate: true
    });
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["cellTemplate", "dataCellTemplate"],
      props: ["viewData", "viewContext", "cellTemplate", "groupOrientation", "leftVirtualCellWidth", "rightVirtualCellWidth", "topVirtualRowHeight", "bottomVirtualRowHeight", "addDateTableClass", "addVerticalSizesClassToRows", "width", "dataCellTemplate"]
    };
  }
  get _viewComponent() {
    return DateTable;
  }
};
component_registrator_default("dxDateTableLayoutBase", DateTableComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/all_day_table.js
var AllDayTableComponent = class extends DateTableComponent {
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["dataCellTemplate"],
      props: ["viewData", "viewContext", "groupOrientation", "leftVirtualCellWidth", "rightVirtualCellWidth", "topVirtualRowHeight", "bottomVirtualRowHeight", "addDateTableClass", "addVerticalSizesClassToRows", "width", "dataCellTemplate"]
    };
  }
  get _viewComponent() {
    return AllDayTable;
  }
};
component_registrator_default("dxAllDayTable", AllDayTableComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/month/date_table_month_cell.js
var DateTableMonthCell = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.contentTemplateProps = null;
  }
  getContentTemplateProps() {
    if (null !== this.contentTemplateProps) {
      return this.contentTemplateProps;
    }
    const {
      index: index2,
      text
    } = this.props;
    this.contentTemplateProps = {
      data: {
        text
      },
      index: index2
    };
    return this.contentTemplateProps;
  }
  componentWillUpdate(nextProps) {
    if (this.props.index !== nextProps.index || this.props.text !== nextProps.text) {
      this.contentTemplateProps = null;
    }
  }
  render() {
    const {
      viewContext,
      dataCellTemplate,
      endDate,
      groupIndex,
      groups,
      index: index2,
      isFirstGroupCell,
      isFocused,
      isLastGroupCell,
      isSelected,
      startDate,
      text,
      className,
      firstDayOfMonth,
      otherMonth,
      today
    } = this.props;
    const classes = renderUtils.combineClasses({
      "dx-scheduler-date-table-other-month": !!otherMonth,
      "dx-scheduler-date-table-current-date": !!today,
      "dx-scheduler-date-table-first-of-month": !!firstDayOfMonth,
      [className ?? ""]: !!className
    });
    const contentTemplateProps = this.getContentTemplateProps();
    const DataCellTemplateComponent = getTemplate3(dataCellTemplate);
    return createComponentVNode(2, DateTableCellBase, {
      className: classes,
      viewContext,
      dataCellTemplate: DataCellTemplateComponent,
      startDate,
      endDate,
      text,
      groups,
      groupIndex,
      index: index2,
      isFirstGroupCell,
      isLastGroupCell,
      isSelected,
      isFocused,
      contentTemplateProps,
      children: createVNode(1, "div", "dx-scheduler-date-table-cell-text", text, 0)
    });
  }
};
DateTableMonthCell.defaultProps = DateTableCallBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/month/date_table_month.js
var _excluded18 = ["viewData", "viewContext", "addDateTableClass", "addVerticalSizesClassToRows", "dataCellTemplate", "groupOrientation", "tableRef", "width"];
var DateTableMonth = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const _this$props = this.props, {
      viewData,
      viewContext,
      addDateTableClass,
      addVerticalSizesClassToRows,
      dataCellTemplate,
      groupOrientation,
      tableRef,
      width
    } = _this$props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded18);
    const DataCellTemplateComponent = getTemplate3(dataCellTemplate);
    return normalizeProps(createComponentVNode(2, DateTable, _extends({}, restProps, {
      viewData,
      viewContext,
      groupOrientation,
      addDateTableClass,
      dataCellTemplate: DataCellTemplateComponent,
      cellTemplate: DateTableMonthCell,
      tableRef,
      addVerticalSizesClassToRows,
      width
    })));
  }
};
DateTableMonth.defaultProps = DateTableDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/date_table_month.js
var DateTableMonthComponent = class extends DateTableComponent {
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["cellTemplate", "dataCellTemplate"],
      props: ["viewData", "viewContext", "cellTemplate", "groupOrientation", "leftVirtualCellWidth", "rightVirtualCellWidth", "topVirtualRowHeight", "bottomVirtualRowHeight", "addDateTableClass", "addVerticalSizesClassToRows", "width", "dataCellTemplate"]
    };
  }
  get _viewComponent() {
    return DateTableMonth;
  }
};
component_registrator_default("dxMonthDateTableLayout", DateTableMonthComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_props.js
var GroupPanelBaseDefaultProps = {
  groupPanelData: {
    groupPanelItems: [],
    baseColSpan: 1
  },
  groupByDate: false,
  styles: {}
};
var GroupPanelCellDefaultProps = {
  id: 0,
  text: "",
  data: {
    id: 0
  },
  className: ""
};
var GroupPanelRowDefaultProps = {
  groupItems: [],
  className: ""
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_horizontal_cell.js
var GroupPanelHorizontalCellDefaultProps = _extends({}, GroupPanelCellDefaultProps, {
  isFirstGroupCell: false,
  isLastGroupCell: false,
  colSpan: 1
});
var GroupPanelHorizontalCell = class extends BaseInfernoComponent {
  render() {
    const {
      cellTemplate,
      colSpan,
      color,
      data: data2,
      id,
      index: index2,
      text,
      className,
      isFirstGroupCell,
      isLastGroupCell
    } = this.props;
    const classes = renderUtils.combineClasses({
      "dx-scheduler-group-header": true,
      "dx-scheduler-first-group-cell": isFirstGroupCell,
      "dx-scheduler-last-group-cell": isLastGroupCell,
      [className ?? ""]: !!className
    });
    const CellTemplateComponent = getTemplate3(cellTemplate);
    return createVNode(1, "th", classes, createVNode(1, "div", "dx-scheduler-group-header-content", CellTemplateComponent ? CellTemplateComponent({
      data: {
        data: data2,
        id,
        color,
        text
      },
      index: index2
    }) : createVNode(1, "div", null, text, 0), 0), 2, {
      colSpan
    });
  }
};
GroupPanelHorizontalCell.defaultProps = GroupPanelHorizontalCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_horizontal_row.js
var GroupPanelHorizontalRow = class extends BaseInfernoComponent {
  render() {
    const {
      cellTemplate,
      className,
      groupItems
    } = this.props;
    const CellTemplateComponent = getTemplate3(cellTemplate);
    return createVNode(1, "tr", `dx-scheduler-group-row ${className}`, groupItems.map((_ref, index2) => {
      let {
        colSpan,
        color,
        data: data2,
        id,
        isFirstGroupCell,
        isLastGroupCell,
        key,
        text
      } = _ref;
      return createComponentVNode(2, GroupPanelHorizontalCell, {
        text,
        id,
        data: data2,
        index: index2,
        color,
        colSpan: colSpan ?? GroupPanelHorizontalCellDefaultProps.colSpan,
        isFirstGroupCell: !!isFirstGroupCell,
        isLastGroupCell: !!isLastGroupCell,
        cellTemplate: CellTemplateComponent
      }, key);
    }), 0);
  }
};
GroupPanelHorizontalRow.defaultProps = GroupPanelRowDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_horizontal.js
var GroupPanelHorizontal = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this._groupPanelItems = null;
  }
  getGroupPanelItems() {
    if (null !== this._groupPanelItems) {
      return this._groupPanelItems;
    }
    const {
      groupPanelData: {
        baseColSpan,
        groupPanelItems
      }
    } = this.props;
    const colSpans = groupPanelItems.reduceRight((currentColSpans, groupsRow, idx) => {
      const nextColSpans = currentColSpans;
      const currentLevelGroupCount = groupsRow.length;
      const previousColSpan = idx === groupPanelItems.length - 1 ? baseColSpan : currentColSpans[idx + 1];
      const previousLevelGroupCount = idx === groupPanelItems.length - 1 ? currentLevelGroupCount : groupPanelItems[idx + 1].length;
      const groupCountDiff = previousLevelGroupCount / currentLevelGroupCount;
      nextColSpans[idx] = groupCountDiff * previousColSpan;
      return nextColSpans;
    }, [...new Array(groupPanelItems.length)]);
    this._groupPanelItems = groupPanelItems.map((groupsRenderRow, index2) => {
      const colSpan = colSpans[index2];
      return groupsRenderRow.map((groupItem) => _extends({}, groupItem, {
        colSpan
      }));
    });
    return this._groupPanelItems;
  }
  componentWillUpdate(nextProps) {
    if (this.props.groupPanelData !== nextProps.groupPanelData) {
      this._groupPanelItems = null;
    }
  }
  render() {
    const {
      resourceCellTemplate
    } = this.props;
    const groupPanelItems = this.getGroupPanelItems();
    const ResourceCellTemplateComponent = getTemplate3(resourceCellTemplate);
    return createFragment(groupPanelItems.map((group) => createComponentVNode(2, GroupPanelHorizontalRow, {
      groupItems: group,
      cellTemplate: ResourceCellTemplateComponent
    }, group[0].key)), 0);
  }
};
GroupPanelHorizontal.defaultProps = GroupPanelBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_vertical_cell.js
var GroupPanelVerticalCell = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      data: data2,
      id,
      color,
      text,
      index: index2,
      cellTemplate
    } = this.props;
    const CellTemplateComponent = getTemplate3(cellTemplate);
    return createVNode(1, "div", `dx-scheduler-group-header ${className}`, CellTemplateComponent ? CellTemplateComponent({
      data: {
        data: data2,
        id,
        color,
        text
      },
      index: index2
    }) : createVNode(1, "div", "dx-scheduler-group-header-content", text, 0), 0);
  }
};
GroupPanelVerticalCell.defaultProps = GroupPanelCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_vertical_row.js
var GroupPanelVerticalRow = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      groupItems,
      cellTemplate
    } = this.props;
    const CellTemplateComponent = getTemplate3(cellTemplate);
    return createVNode(1, "div", `dx-scheduler-group-row ${className}`, groupItems.map((_ref, index2) => {
      let {
        color,
        data: data2,
        id,
        key,
        text
      } = _ref;
      return createComponentVNode(2, GroupPanelVerticalCell, {
        text,
        id,
        data: data2,
        index: index2,
        color,
        cellTemplate: CellTemplateComponent
      }, key);
    }), 0);
  }
};
GroupPanelVerticalRow.defaultProps = GroupPanelRowDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel_vertical.js
var GroupPanelVertical = class extends BaseInfernoComponent {
  render() {
    const {
      className,
      elementRef,
      groupPanelData,
      resourceCellTemplate,
      height,
      styles
    } = this.props;
    const style = normalizeStyles(renderUtils.addHeightToStyle(height, styles));
    const ResourceCellTemplateComponent = getTemplate3(resourceCellTemplate);
    return createVNode(1, "div", className, createVNode(1, "div", "dx-scheduler-group-flex-container", groupPanelData.groupPanelItems.map((group) => createComponentVNode(2, GroupPanelVerticalRow, {
      groupItems: group,
      cellTemplate: ResourceCellTemplateComponent
    }, group[0].key)), 0), 2, {
      style
    }, null, elementRef);
  }
};
GroupPanelVertical.defaultProps = GroupPanelBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/group_panel.js
var GroupPanelDefaultProps = _extends({}, GroupPanelBaseDefaultProps, {
  groups: [],
  groupOrientation: VERTICAL_GROUP_ORIENTATION
});
var GroupPanel = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const {
      className,
      viewContext,
      elementRef,
      groupPanelData,
      height,
      resourceCellTemplate,
      groupOrientation,
      groups,
      styles
    } = this.props;
    const ResourceCellTemplateComponent = getTemplate3(resourceCellTemplate);
    const isVerticalLayout = isVerticalGroupingApplied(groups, groupOrientation);
    const Layout = isVerticalLayout ? GroupPanelVertical : GroupPanelHorizontal;
    return createComponentVNode(2, Layout, {
      viewContext,
      height,
      resourceCellTemplate: ResourceCellTemplateComponent,
      className,
      groupPanelData,
      elementRef,
      styles,
      groups: GroupPanelDefaultProps.groups,
      groupOrientation: GroupPanelDefaultProps.groupOrientation,
      groupByDate: GroupPanelDefaultProps.groupByDate
    });
  }
};
GroupPanel.defaultProps = GroupPanelDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/group_panel.js
var GroupPanelComponent = class extends ComponentWrapper2 {
  _setOptionsByReference() {
    super._setOptionsByReference();
    this._optionsByReference = _extends({}, this._optionsByReference, {
      resourceCellTemplate: true
    });
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["resourceCellTemplate"],
      props: ["viewContext", "groups", "groupOrientation", "groupPanelData", "groupByDate", "height", "className", "resourceCellTemplate"]
    };
  }
  get _viewComponent() {
    return GroupPanel;
  }
};
component_registrator_default("dxGroupPanel", GroupPanelComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_header_text.js
var DateHeaderTextDefaultProps = {
  text: "",
  splitText: false
};
var DateHeaderText = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this._textCache = null;
  }
  getTextParts() {
    if (null !== this._textCache) {
      return this._textCache;
    }
    const {
      text
    } = this.props;
    this._textCache = text ? text.split(" ") : [""];
    return this._textCache;
  }
  componentWillUpdate(nextProps) {
    if (this.props.text !== nextProps.text) {
      this._textCache = null;
    }
  }
  render() {
    const {
      splitText,
      text
    } = this.props;
    const textParts = this.getTextParts();
    return createFragment(splitText ? textParts.map((part) => createVNode(1, "div", "dx-scheduler-header-panel-cell-date", createVNode(1, "span", null, part, 0), 2)) : text, 0);
  }
};
DateHeaderText.defaultProps = DateHeaderTextDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_header_cell.js
var DateHeaderCellDefaultProps = _extends({}, CellBaseDefaultProps, {
  today: false,
  colSpan: 1,
  isWeekDayCell: false,
  splitText: false,
  isTimeCellTemplate: false
});
var DateHeaderCell = class extends BaseInfernoComponent {
  render() {
    const {
      viewContext: {
        view: {
          type: viewType
        },
        crossScrollingEnabled
      },
      colSpan,
      dateCellTemplate,
      groupIndex,
      groups,
      index: index2,
      isTimeCellTemplate,
      splitText,
      startDate,
      text,
      timeCellTemplate,
      className,
      isFirstGroupCell,
      isLastGroupCell,
      isWeekDayCell,
      today
    } = this.props;
    const cellSizeHorizontalClass = renderUtils.getCellSizeHorizontalClass(viewType, crossScrollingEnabled);
    const cellClasses = renderUtils.combineClasses({
      "dx-scheduler-header-panel-cell": true,
      [cellSizeHorizontalClass]: true,
      "dx-scheduler-header-panel-current-time-cell": today,
      "dx-scheduler-header-panel-week-cell": isWeekDayCell,
      [className ?? ""]: !!className
    });
    const classes = renderUtils.getGroupCellClasses(isFirstGroupCell, isLastGroupCell, cellClasses);
    const useTemplate = !isTimeCellTemplate && !!dateCellTemplate || isTimeCellTemplate && !!timeCellTemplate;
    const TimeCellTemplateComponent = getTemplate3(timeCellTemplate);
    const DateCellTemplateComponent = getTemplate3(dateCellTemplate);
    const children = useTemplate ? createFragment([isTimeCellTemplate && TimeCellTemplateComponent && TimeCellTemplateComponent({
      data: {
        date: startDate,
        text,
        groups,
        groupIndex
      },
      index: index2
    }), !isTimeCellTemplate && DateCellTemplateComponent && DateCellTemplateComponent({
      data: {
        date: startDate,
        text,
        groups,
        groupIndex
      },
      index: index2
    })], 0) : createComponentVNode(2, DateHeaderText, {
      splitText,
      text
    });
    return createVNode(1, "th", classes, children, 0, {
      colSpan,
      title: text
    });
  }
};
DateHeaderCell.defaultProps = DateHeaderCellDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/date_header.js
var {
  isMaterialBased: isMaterialBased2
} = themeUtils.getThemeType();
var DateHeaderDefaultProps = {
  groupOrientation: "horizontal",
  groupByDate: false,
  groups: []
};
var DateHeader = class extends BaseInfernoComponent {
  render() {
    const {
      viewContext,
      dateCellTemplate,
      dateHeaderData: {
        dataMap: dataMap2,
        leftVirtualCellCount,
        leftVirtualCellWidth,
        rightVirtualCellCount,
        rightVirtualCellWidth
      },
      groupByDate,
      groupOrientation,
      groups
    } = this.props;
    const isHorizontalGrouping = isHorizontalGroupingApplied(groups, groupOrientation) && !groupByDate;
    const DateCellTemplateComponent = getTemplate3(dateCellTemplate);
    return createFragment(dataMap2.map((dateHeaderRow, rowIndex) => createComponentVNode(2, Row, {
      className: "dx-scheduler-header-row",
      leftVirtualCellWidth,
      leftVirtualCellCount,
      rightVirtualCellWidth,
      rightVirtualCellCount,
      isHeaderRow: true,
      children: dateHeaderRow.map((_ref) => {
        let {
          colSpan,
          endDate,
          groupIndex,
          groups: cellGroups,
          index: index2,
          isFirstGroupCell,
          isLastGroupCell,
          key,
          startDate,
          text,
          today
        } = _ref;
        return createComponentVNode(2, DateHeaderCell, {
          viewContext,
          startDate,
          endDate,
          groups: isHorizontalGrouping ? cellGroups : void 0,
          groupIndex: isHorizontalGrouping ? groupIndex : void 0,
          today: today ?? false,
          isWeekDayCell: false,
          isTimeCellTemplate: false,
          index: index2,
          text,
          isFirstGroupCell,
          isLastGroupCell,
          dateCellTemplate: DateCellTemplateComponent,
          colSpan,
          splitText: isMaterialBased2
        }, key);
      })
    }, rowIndex.toString())), 0);
  }
};
DateHeader.defaultProps = DateHeaderDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/header_panel.js
var HeaderPanelDefaultProps = _extends({}, GroupPanelDefaultProps, {
  isRenderDateHeader: true,
  dateHeaderTemplate: DateHeader
});
var HeaderPanel = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const {
      viewContext,
      dateHeaderData,
      groupByDate,
      groupOrientation,
      groupPanelData,
      groups,
      isRenderDateHeader,
      dateCellTemplate,
      dateHeaderTemplate,
      resourceCellTemplate,
      timeCellTemplate
    } = this.props;
    const isHorizontalGrouping = isHorizontalGroupingApplied(groups, groupOrientation);
    const DateCellTemplateComponent = getTemplate3(dateCellTemplate);
    const DateHeaderTemplateComponent = getTemplate3(dateHeaderTemplate);
    const ResourceCellTemplateComponent = getTemplate3(resourceCellTemplate);
    const TimeCellTemplateComponent = getTemplate3(timeCellTemplate);
    return createVNode(1, "thead", null, [isHorizontalGrouping && !groupByDate && createComponentVNode(2, GroupPanel, {
      viewContext,
      groupPanelData,
      groups,
      groupByDate,
      groupOrientation,
      resourceCellTemplate: ResourceCellTemplateComponent
    }), isRenderDateHeader && DateHeaderTemplateComponent({
      viewContext,
      groupByDate,
      dateHeaderData,
      groupOrientation,
      groups,
      dateCellTemplate: DateCellTemplateComponent,
      timeCellTemplate: TimeCellTemplateComponent
    }), groupByDate && createComponentVNode(2, GroupPanel, {
      viewContext,
      groupPanelData,
      groups,
      groupByDate,
      groupOrientation,
      resourceCellTemplate: ResourceCellTemplateComponent
    })], 0);
  }
};
HeaderPanel.defaultProps = HeaderPanelDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/header_panel.js
var HeaderPanelComponent = class extends ComponentWrapper2 {
  _setOptionsByReference() {
    super._setOptionsByReference();
    this._optionsByReference = _extends({}, this._optionsByReference, {
      dateHeaderData: true,
      resourceCellTemplate: true,
      dateCellTemplate: true,
      timeCellTemplate: true
    });
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["dateCellTemplate", "timeCellTemplate", "dateHeaderTemplate", "resourceCellTemplate"],
      props: ["viewContext", "dateHeaderData", "isRenderDateHeader", "dateCellTemplate", "timeCellTemplate", "dateHeaderTemplate", "groups", "groupOrientation", "groupPanelData", "groupByDate", "height", "className", "resourceCellTemplate"]
    };
  }
  get _viewComponent() {
    return HeaderPanel;
  }
};
component_registrator_default("dxHeaderPanelLayout", HeaderPanelComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/timeline/date_header_timeline.js
var {
  isMaterialBased: isMaterialBased3
} = getThemeType();
var TimelineDateHeaderLayout = class extends BaseInfernoComponent {
  render() {
    const {
      viewContext,
      groupByDate,
      groupOrientation,
      groups,
      dateHeaderData,
      dateCellTemplate,
      timeCellTemplate
    } = this.props;
    const {
      dataMap: dataMap2,
      isMonthDateHeader,
      leftVirtualCellCount,
      leftVirtualCellWidth,
      rightVirtualCellCount,
      rightVirtualCellWidth,
      weekDayLeftVirtualCellCount,
      weekDayLeftVirtualCellWidth,
      weekDayRightVirtualCellCount,
      weekDayRightVirtualCellWidth
    } = dateHeaderData;
    const isHorizontalGrouping = isHorizontalGroupingApplied(groups, groupOrientation) && !groupByDate;
    const DateCellTemplateComponent = getTemplate3(dateCellTemplate);
    const TimeCellTemplateComponent = getTemplate3(timeCellTemplate);
    return createFragment(dataMap2.map((dateHeaderRow, rowIndex) => {
      const rowsCount = dataMap2.length;
      const isTimeCellTemplate = rowsCount - 1 === rowIndex;
      const isWeekDayRow = rowsCount > 1 && 0 === rowIndex;
      const splitText = isMaterialBased3 && (isMonthDateHeader || isWeekDayRow);
      let validLeftVirtualCellCount = leftVirtualCellCount;
      let validRightVirtualCellCount = rightVirtualCellCount;
      let validRightVirtualCellWidth = rightVirtualCellWidth;
      let validLeftVirtualCellWidth = leftVirtualCellWidth;
      if (isWeekDayRow) {
        validLeftVirtualCellCount = weekDayLeftVirtualCellCount;
        validRightVirtualCellCount = weekDayRightVirtualCellCount;
        validRightVirtualCellWidth = weekDayRightVirtualCellWidth;
        validLeftVirtualCellWidth = weekDayLeftVirtualCellWidth;
      }
      return createComponentVNode(2, Row, {
        className: "dx-scheduler-header-row",
        leftVirtualCellWidth: validLeftVirtualCellWidth ?? RowDefaultProps.leftVirtualCellWidth,
        leftVirtualCellCount: validLeftVirtualCellCount,
        rightVirtualCellWidth: validRightVirtualCellWidth ?? RowDefaultProps.rightVirtualCellWidth,
        rightVirtualCellCount: validRightVirtualCellCount,
        children: dateHeaderRow.map((_ref) => {
          let {
            colSpan,
            endDate,
            groupIndex,
            groups: cellGroups,
            index: index2,
            isFirstGroupCell,
            isLastGroupCell,
            key,
            startDate,
            text,
            today
          } = _ref;
          return createComponentVNode(2, DateHeaderCell, {
            viewContext,
            startDate,
            endDate,
            groups: isHorizontalGrouping ? cellGroups : void 0,
            groupIndex: isHorizontalGrouping ? groupIndex : void 0,
            today: today ?? DateHeaderCellDefaultProps.today,
            index: index2,
            text,
            isFirstGroupCell,
            isLastGroupCell,
            isWeekDayCell: isWeekDayRow,
            colSpan,
            splitText,
            dateCellTemplate: DateCellTemplateComponent,
            timeCellTemplate: TimeCellTemplateComponent,
            isTimeCellTemplate
          }, key);
        })
      }, rowIndex.toString());
    }), 0);
  }
};
TimelineDateHeaderLayout.defaultProps = DateHeaderDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/timeline/header_panel_timeline.js
var HeaderPanelTimeline = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const {
      viewContext,
      dateCellTemplate,
      dateHeaderData,
      groupByDate,
      groupOrientation,
      groupPanelData,
      groups,
      isRenderDateHeader,
      resourceCellTemplate,
      timeCellTemplate
    } = this.props;
    const DateCellTemplateComponent = getTemplate3(dateCellTemplate);
    const ResourceCellTemplateComponent = getTemplate3(resourceCellTemplate);
    const TimeCellTemplateComponent = getTemplate3(timeCellTemplate);
    return createComponentVNode(2, HeaderPanel, {
      viewContext,
      dateHeaderData,
      groupPanelData,
      groupByDate,
      groups,
      groupOrientation,
      isRenderDateHeader,
      dateHeaderTemplate: TimelineDateHeaderLayout,
      resourceCellTemplate: ResourceCellTemplateComponent,
      dateCellTemplate: DateCellTemplateComponent,
      timeCellTemplate: TimeCellTemplateComponent
    });
  }
};
HeaderPanelTimeline.defaultProps = HeaderPanelDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/header_panel_timeline.js
var HeaderPanelTimelineComponent = class extends HeaderPanelComponent {
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["dateCellTemplate", "timeCellTemplate", "dateHeaderTemplate", "resourceCellTemplate"],
      props: ["viewContext", "dateHeaderData", "isRenderDateHeader", "dateCellTemplate", "timeCellTemplate", "dateHeaderTemplate", "groups", "groupOrientation", "groupPanelData", "groupByDate", "height", "className", "resourceCellTemplate"]
    };
  }
  get _viewComponent() {
    return HeaderPanelTimeline;
  }
};
component_registrator_default("dxTimelineHeaderPanelLayout", HeaderPanelTimelineComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/time_panel_cell.js
var TimePanelCell = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.timeCellTemplateProps = null;
  }
  getTimeCellTemplateProps() {
    if (null !== this.timeCellTemplateProps) {
      return this.timeCellTemplateProps;
    }
    const {
      groupIndex,
      groups,
      index: index2,
      startDate,
      text
    } = this.props;
    this.timeCellTemplateProps = {
      data: {
        date: startDate,
        groups,
        groupIndex,
        text
      },
      index: index2
    };
    return this.timeCellTemplateProps;
  }
  componentWillUpdate(nextProps) {
    if (this.props.groupIndex !== nextProps.groupIndex || this.props.groups !== nextProps.groups || this.props.index !== nextProps.index || this.props.startDate !== nextProps.startDate || this.props.text !== nextProps.text) {
      this.timeCellTemplateProps = null;
    }
  }
  render() {
    const {
      className,
      viewContext,
      highlighted,
      isFirstGroupCell,
      isLastGroupCell,
      text,
      timeCellTemplate
    } = this.props;
    const cellSizeVerticalClass = renderUtils.getCellSizeVerticalClass(false);
    const classes = renderUtils.combineClasses({
      "dx-scheduler-time-panel-cell": true,
      [cellSizeVerticalClass]: true,
      "dx-scheduler-time-panel-current-time-cell": !!highlighted,
      [className ?? ""]: true
    });
    const timeCellTemplateProps = this.getTimeCellTemplateProps();
    const TimeCellTemplateComponent = getTemplate3(timeCellTemplate);
    return createComponentVNode(2, CellBase, {
      className: classes,
      viewContext,
      isFirstGroupCell,
      isLastGroupCell,
      startDate: CellBaseDefaultProps.startDate,
      endDate: CellBaseDefaultProps.endDate,
      index: CellBaseDefaultProps.index,
      children: TimeCellTemplateComponent ? TimeCellTemplateComponent({
        index: timeCellTemplateProps.index,
        data: timeCellTemplateProps.data
      }) : createVNode(1, "div", null, text, 0)
    });
  }
};
TimePanelCell.defaultProps = CellBaseDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/base/time_panel_table.js
var _excluded19 = ["timePanelData", "viewContext", "tableRef", "timeCellTemplate"];
var TimePanelTableDefaultProps = {
  timePanelData: {
    groupedData: [],
    leftVirtualCellCount: 0,
    rightVirtualCellCount: 0,
    topVirtualRowCount: 0,
    bottomVirtualRowCount: 0
  }
};
var TimePanelTable = class extends InfernoWrapperComponent {
  createEffects() {
    return [createReRenderEffect()];
  }
  render() {
    const _this$props = this.props, {
      timePanelData,
      viewContext,
      tableRef,
      timeCellTemplate
    } = _this$props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded19);
    const {
      topVirtualRowHeight,
      bottomVirtualRowHeight
    } = timePanelData;
    const TimeCellTemplateComponent = getTemplate3(timeCellTemplate);
    return normalizeProps(createComponentVNode(2, Table, _extends({}, restProps, {
      className: "dx-scheduler-time-panel",
      topVirtualRowHeight: topVirtualRowHeight ?? 0,
      bottomVirtualRowHeight: bottomVirtualRowHeight ?? 0,
      virtualCellsCount: 1,
      tableRef,
      children: timePanelData.groupedData.map((_ref) => {
        let {
          dateTable,
          groupIndex,
          isGroupedAllDayPanel,
          key: fragmentKey
        } = _ref;
        return createFragment([isGroupedAllDayPanel && createComponentVNode(2, Row, {
          leftVirtualCellWidth: RowDefaultProps.leftVirtualCellWidth,
          rightVirtualCellWidth: RowDefaultProps.rightVirtualCellWidth,
          children: createComponentVNode(2, CellBase, {
            className: "dx-scheduler-time-panel-title-cell",
            viewContext,
            startDate: CellBaseDefaultProps.startDate,
            endDate: CellBaseDefaultProps.endDate,
            index: CellBaseDefaultProps.index,
            children: createComponentVNode(2, AllDayPanelTitle)
          })
        }), dateTable.map((_ref2) => {
          let {
            groups,
            highlighted,
            index: cellIndex,
            isFirstGroupCell,
            isLastGroupCell,
            key,
            startDate,
            text
          } = _ref2;
          return createComponentVNode(2, Row, {
            className: "dx-scheduler-time-panel-row",
            leftVirtualCellWidth: RowDefaultProps.leftVirtualCellWidth,
            rightVirtualCellWidth: RowDefaultProps.rightVirtualCellWidth,
            children: createComponentVNode(2, TimePanelCell, {
              viewContext,
              startDate,
              endDate: CellBaseDefaultProps.endDate,
              text,
              groups,
              groupIndex,
              isFirstGroupCell,
              isLastGroupCell,
              index: cellIndex,
              timeCellTemplate: TimeCellTemplateComponent,
              highlighted
            })
          }, key);
        })], 0, fragmentKey);
      })
    })));
  }
};
TimePanelTable.defaultProps = TimePanelTableDefaultProps;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/r1/components/wrappers/time_panel.js
var TimePanelComponent = class extends ComponentWrapper2 {
  _setOptionsByReference() {
    super._setOptionsByReference();
    this._optionsByReference = _extends({}, this._optionsByReference, {
      timeCellTemplate: true
    });
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: [],
      templates: ["timeCellTemplate"],
      props: ["viewContext", "groupOrientation", "timePanelData", "timeCellTemplate"]
    };
  }
  get _viewComponent() {
    return TimePanelTable;
  }
};
component_registrator_default("dxTimePanelTableLayout", TimePanelComponent);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/base/m_widget_observer.js
var WidgetObserver = class extends ui_widget_default {
  notifyObserver(subject, args) {
    const observer2 = this.option("observer");
    if (observer2) {
      observer2.fire(subject, args);
    }
  }
  invoke() {
    const observer2 = this.option("observer");
    if (observer2) {
      return observer2.fire.apply(observer2, arguments);
    }
  }
};
var m_widget_observer_default = WidgetObserver;

// ../../../../../../node_modules/devextreme/esm/__internal/m_draggable.js
var window27 = getWindow();
var DRAGGABLE = "dxDraggable";
var DRAGSTART_EVENT_NAME2 = addNamespace2(DRAG_START_EVENT, DRAGGABLE);
var DRAG_EVENT_NAME = addNamespace2(DRAG_EVENT, DRAGGABLE);
var DRAGEND_EVENT_NAME = addNamespace2(DRAG_END_EVENT, DRAGGABLE);
var DRAG_ENTER_EVENT_NAME = addNamespace2(DRAG_ENTER_EVENT, DRAGGABLE);
var DRAGEND_LEAVE_EVENT_NAME = addNamespace2(DRAG_LEAVE_EVENT, DRAGGABLE);
var POINTERDOWN_EVENT_NAME = addNamespace2(pointer_default.down, DRAGGABLE);
var KEYDOWN_EVENT_NAME = addNamespace2("keydown", DRAGGABLE);
var targetDraggable;
var sourceDraggable;
var getMousePosition = (event) => ({
  x: event.pageX - renderer_default(window27).scrollLeft(),
  y: event.pageY - renderer_default(window27).scrollTop()
});
var ScrollHelper = class {
  constructor(orientation, component) {
    this._$scrollableAtPointer = null;
    this._preventScroll = true;
    this._component = component;
    if ("vertical" === orientation) {
      this._scrollValue = "scrollTop";
      this._overFlowAttr = "overflowY";
      this._sizeAttr = "height";
      this._scrollSizeProp = "scrollHeight";
      this._clientSizeProp = "clientHeight";
      this._limitProps = {
        start: "top",
        end: "bottom"
      };
    } else {
      this._scrollValue = "scrollLeft";
      this._overFlowAttr = "overflowX";
      this._sizeAttr = "width";
      this._scrollSizeProp = "scrollWidth";
      this._clientSizeProp = "clientWidth";
      this._limitProps = {
        start: "left",
        end: "right"
      };
    }
  }
  updateScrollable(elements, mousePosition) {
    let isScrollableFound = false;
    elements.some((element) => {
      const $element = renderer_default(element);
      const isTargetOverOverlayWrapper = $element.hasClass("dx-overlay-wrapper");
      const isTargetOverOverlayContent = $element.hasClass("dx-overlay-content");
      if (isTargetOverOverlayWrapper || isTargetOverOverlayContent) {
        return true;
      }
      isScrollableFound = this._trySetScrollable(element, mousePosition);
      return isScrollableFound;
    });
    if (!isScrollableFound) {
      this._$scrollableAtPointer = null;
      this._scrollSpeed = 0;
    }
  }
  isScrolling() {
    return !!this._scrollSpeed;
  }
  isScrollable($element) {
    return ("auto" === $element.css(this._overFlowAttr) || $element.hasClass("dx-scrollable-container")) && $element.prop(this._scrollSizeProp) > Math.ceil("width" === this._sizeAttr ? getWidth($element) : getHeight($element));
  }
  _trySetScrollable(element, mousePosition) {
    const that = this;
    const $element = renderer_default(element);
    let distanceToBorders;
    const sensitivity = that._component.option("scrollSensitivity");
    let isScrollable = that.isScrollable($element);
    if (isScrollable) {
      distanceToBorders = that._calculateDistanceToBorders($element, mousePosition);
      if (sensitivity > distanceToBorders[that._limitProps.start]) {
        if (!that._preventScroll) {
          that._scrollSpeed = -that._calculateScrollSpeed(distanceToBorders[that._limitProps.start]);
          that._$scrollableAtPointer = $element;
        }
      } else if (sensitivity > distanceToBorders[that._limitProps.end]) {
        if (!that._preventScroll) {
          that._scrollSpeed = that._calculateScrollSpeed(distanceToBorders[that._limitProps.end]);
          that._$scrollableAtPointer = $element;
        }
      } else {
        isScrollable = false;
        that._preventScroll = false;
      }
    }
    return isScrollable;
  }
  _calculateDistanceToBorders($area, mousePosition) {
    const area = $area.get(0);
    let areaBoundingRect;
    if (area) {
      areaBoundingRect = getBoundingRect(area);
      return {
        left: mousePosition.x - areaBoundingRect.left,
        top: mousePosition.y - areaBoundingRect.top,
        right: areaBoundingRect.right - mousePosition.x,
        bottom: areaBoundingRect.bottom - mousePosition.y
      };
    }
    return {};
  }
  _calculateScrollSpeed(distance) {
    const component = this._component;
    const sensitivity = component.option("scrollSensitivity");
    const maxSpeed = component.option("scrollSpeed");
    return Math.ceil(((sensitivity - distance) / sensitivity) ** 2 * maxSpeed);
  }
  scrollByStep() {
    const that = this;
    if (that._$scrollableAtPointer && that._scrollSpeed) {
      if (that._$scrollableAtPointer.hasClass("dx-scrollable-container")) {
        const $scrollable = that._$scrollableAtPointer.closest(".dx-scrollable");
        const scrollableInstance = $scrollable.data("dxScrollable") || $scrollable.data("dxScrollView");
        if (scrollableInstance) {
          const nextScrollPosition = scrollableInstance.scrollOffset()[that._limitProps.start] + that._scrollSpeed;
          scrollableInstance.scrollTo({
            [that._limitProps.start]: nextScrollPosition
          });
        }
      } else {
        const nextScrollPosition = that._$scrollableAtPointer[that._scrollValue]() + that._scrollSpeed;
        that._$scrollableAtPointer[that._scrollValue](nextScrollPosition);
      }
      const dragMoveArgs = that._component._dragMoveArgs;
      if (dragMoveArgs) {
        that._component._dragMoveHandler(dragMoveArgs);
      }
    }
  }
  reset() {
    this._$scrollableAtPointer = null;
    this._scrollSpeed = 0;
    this._preventScroll = true;
  }
  isOutsideScrollable($scrollable, event) {
    if (!$scrollable) {
      return false;
    }
    const scrollableSize = getBoundingRect($scrollable.get(0));
    const start = scrollableSize[this._limitProps.start];
    const size = scrollableSize[this._sizeAttr];
    const mousePosition = getMousePosition(event);
    const location = "width" === this._sizeAttr ? mousePosition.x : mousePosition.y;
    return location < start || location > start + size;
  }
};
var ScrollAnimator = m_animator_default.inherit({
  ctor(strategy4) {
    this.callBase();
    this._strategy = strategy4;
  },
  _step() {
    const horizontalScrollHelper = this._strategy._horizontalScrollHelper;
    const verticalScrollHelper = this._strategy._verticalScrollHelper;
    horizontalScrollHelper && horizontalScrollHelper.scrollByStep();
    verticalScrollHelper && verticalScrollHelper.scrollByStep();
  }
});
var Draggable = dom_component_default.inherit({
  reset: noop2,
  dragMove: noop2,
  dragEnter: noop2,
  dragLeave: noop2,
  dragEnd(sourceEvent) {
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2._fireRemoveEvent(sourceEvent);
    return Deferred().resolve();
  },
  _fireRemoveEvent: noop2,
  _getDefaultOptions() {
    return extend(this.callBase(), {
      onDragStart: null,
      onDragMove: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragLeave: null,
      onDragCancel: null,
      onCancelByEsc: false,
      onDrop: null,
      immediate: true,
      dragDirection: "both",
      boundary: void 0,
      boundOffset: 0,
      allowMoveByClick: false,
      itemData: null,
      container: void 0,
      dragTemplate: void 0,
      contentTemplate: "content",
      handle: "",
      filter: "",
      clone: false,
      autoScroll: true,
      scrollSpeed: 30,
      scrollSensitivity: 60,
      group: void 0,
      data: void 0
    });
  },
  _setOptionsByReference() {
    this.callBase.apply(this, arguments);
    extend(this._optionsByReference, {
      component: true,
      group: true,
      itemData: true,
      data: true
    });
  },
  _init() {
    this.callBase();
    this._attachEventHandlers();
    this._scrollAnimator = new ScrollAnimator(this);
    this._horizontalScrollHelper = new ScrollHelper("horizontal", this);
    this._verticalScrollHelper = new ScrollHelper("vertical", this);
    this._initScrollTop = 0;
    this._initScrollLeft = 0;
  },
  _normalizeCursorOffset(offset2) {
    if (isObject(offset2)) {
      offset2 = {
        h: offset2.x,
        v: offset2.y
      };
    }
    offset2 = splitPair(offset2).map((value2) => parseFloat(value2));
    return {
      left: offset2[0],
      top: 1 === offset2.length ? offset2[0] : offset2[1]
    };
  },
  _getNormalizedCursorOffset(offset2, options2) {
    if (isFunction(offset2)) {
      offset2 = offset2.call(this, options2);
    }
    return this._normalizeCursorOffset(offset2);
  },
  _calculateElementOffset(options2) {
    let elementOffset;
    let dragElementOffset;
    const {
      event
    } = options2;
    const $element = renderer_default(options2.itemElement);
    const $dragElement = renderer_default(options2.dragElement);
    const isCloned = this._dragElementIsCloned();
    const cursorOffset = this.option("cursorOffset");
    let normalizedCursorOffset = {
      left: 0,
      top: 0
    };
    const currentLocate = this._initialLocate = locate($dragElement);
    if (isCloned || options2.initialOffset || cursorOffset) {
      elementOffset = options2.initialOffset || $element.offset();
      if (cursorOffset) {
        normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options2);
        if (isFinite(normalizedCursorOffset.left)) {
          elementOffset.left = event.pageX;
        }
        if (isFinite(normalizedCursorOffset.top)) {
          elementOffset.top = event.pageY;
        }
      }
      dragElementOffset = $dragElement.offset();
      elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;
      elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left;
    }
    return elementOffset;
  },
  _initPosition(options2) {
    const $dragElement = renderer_default(options2.dragElement);
    const elementOffset = this._calculateElementOffset(options2);
    if (elementOffset) {
      this._move(elementOffset, $dragElement);
    }
    this._startPosition = locate($dragElement);
  },
  _startAnimator() {
    if (!this._scrollAnimator.inProgress()) {
      this._scrollAnimator.start();
    }
  },
  _stopAnimator() {
    this._scrollAnimator.stop();
  },
  _addWidgetPrefix(className) {
    const componentName = this.NAME;
    return dasherize(componentName) + (className ? `-${className}` : "");
  },
  _getItemsSelector() {
    return this.option("filter") || "";
  },
  _$content() {
    const $element = this.$element();
    const $wrapper = $element.children(".dx-template-wrapper");
    return $wrapper.length ? $wrapper : $element;
  },
  _attachEventHandlers() {
    if (this.option("disabled")) {
      return;
    }
    let $element = this._$content();
    let itemsSelector = this._getItemsSelector();
    const allowMoveByClick = this.option("allowMoveByClick");
    const data2 = {
      direction: this.option("dragDirection"),
      immediate: this.option("immediate"),
      checkDropTarget: ($target, event) => {
        const targetGroup = this.option("group");
        const sourceGroup = this._getSourceDraggable().option("group");
        const $scrollable = this._getScrollable($target);
        if (this._verticalScrollHelper.isOutsideScrollable($scrollable, event) || this._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {
          return false;
        }
        return sourceGroup && sourceGroup === targetGroup;
      }
    };
    if (allowMoveByClick) {
      $element = this._getArea();
      events_engine_default.on($element, POINTERDOWN_EVENT_NAME, data2, this._pointerDownHandler.bind(this));
    }
    if (">" === itemsSelector[0]) {
      itemsSelector = itemsSelector.slice(1);
    }
    events_engine_default.on($element, DRAGSTART_EVENT_NAME2, itemsSelector, data2, this._dragStartHandler.bind(this));
    events_engine_default.on($element, DRAG_EVENT_NAME, data2, this._dragMoveHandler.bind(this));
    events_engine_default.on($element, DRAGEND_EVENT_NAME, data2, this._dragEndHandler.bind(this));
    events_engine_default.on($element, DRAG_ENTER_EVENT_NAME, data2, this._dragEnterHandler.bind(this));
    events_engine_default.on($element, DRAGEND_LEAVE_EVENT_NAME, data2, this._dragLeaveHandler.bind(this));
    if (this.option("onCancelByEsc")) {
      events_engine_default.on($element, KEYDOWN_EVENT_NAME, this._keydownHandler.bind(this));
    }
  },
  _dragElementIsCloned() {
    return this._$dragElement && this._$dragElement.hasClass(this._addWidgetPrefix("clone"));
  },
  _getDragTemplateArgs($element, $container) {
    return {
      container: getPublicElement($container),
      model: {
        itemData: this.option("itemData"),
        itemElement: getPublicElement($element)
      }
    };
  },
  _createDragElement($element) {
    let result2 = $element;
    const clone3 = this.option("clone");
    const $container = this._getContainer();
    let template = this.option("dragTemplate");
    if (template) {
      template = this._getTemplate(template);
      result2 = renderer_default("<div>").appendTo($container);
      template.render(this._getDragTemplateArgs($element, result2));
    } else if (clone3) {
      result2 = renderer_default("<div>").appendTo($container);
      $element.clone().css({
        width: $element.css("width"),
        height: $element.css("height")
      }).appendTo(result2);
    }
    return result2.toggleClass(this._addWidgetPrefix("clone"), result2.get(0) !== $element.get(0)).toggleClass("dx-rtl", this.option("rtlEnabled"));
  },
  _resetDragElement() {
    if (this._dragElementIsCloned()) {
      this._$dragElement.remove();
    } else {
      this._toggleDraggingClass(false);
    }
    this._$dragElement = null;
  },
  _resetSourceElement() {
    this._toggleDragSourceClass(false);
    this._$sourceElement = null;
  },
  _detachEventHandlers() {
    events_engine_default.off(this._$content(), `.${DRAGGABLE}`);
    events_engine_default.off(this._getArea(), `.${DRAGGABLE}`);
  },
  _move(position3, $element) {
    move($element || this._$dragElement, position3);
  },
  _getDraggableElement(e) {
    const $sourceElement = this._getSourceElement();
    if ($sourceElement) {
      return $sourceElement;
    }
    const allowMoveByClick = this.option("allowMoveByClick");
    if (allowMoveByClick) {
      return this.$element();
    }
    let $target = renderer_default(e && e.target);
    const itemsSelector = this._getItemsSelector();
    if (">" === itemsSelector[0]) {
      const $items = this._$content().find(itemsSelector);
      if (!$items.is($target)) {
        $target = $target.closest($items);
      }
    }
    return $target;
  },
  _getSourceElement() {
    const draggable = this._getSourceDraggable();
    return draggable._$sourceElement;
  },
  _pointerDownHandler(e) {
    if (needSkipEvent(e)) {
      return;
    }
    const position3 = {};
    const $element = this.$element();
    const dragDirection = this.option("dragDirection");
    if ("horizontal" === dragDirection || "both" === dragDirection) {
      position3.left = e.pageX - $element.offset().left + locate($element).left - getWidth($element) / 2;
    }
    if ("vertical" === dragDirection || "both" === dragDirection) {
      position3.top = e.pageY - $element.offset().top + locate($element).top - getHeight($element) / 2;
    }
    this._move(position3, $element);
    this._getAction("onDragMove")(this._getEventArgs(e));
  },
  _isValidElement(event, $element) {
    const handle = this.option("handle");
    const $target = renderer_default(event.originalEvent && event.originalEvent.target);
    if (handle && !$target.closest(handle).length) {
      return false;
    }
    if (!$element.length) {
      return false;
    }
    return !$element.is(".dx-state-disabled, .dx-state-disabled *");
  },
  _dragStartHandler(e) {
    const $element = this._getDraggableElement(e);
    this.dragInProgress = true;
    if (!this._isValidElement(e, $element)) {
      e.cancel = true;
      return;
    }
    if (this._$sourceElement) {
      return;
    }
    const dragStartArgs = this._getDragStartArgs(e, $element);
    this._getAction("onDragStart")(dragStartArgs);
    if (dragStartArgs.cancel) {
      e.cancel = true;
      return;
    }
    this.option("itemData", dragStartArgs.itemData);
    this._setSourceDraggable();
    this._$sourceElement = $element;
    let initialOffset = $element.offset();
    if (!this._hasClonedDraggable() && this.option("autoScroll")) {
      this._initScrollTop = this._getScrollableScrollTop();
      this._initScrollLeft = this._getScrollableScrollLeft();
      initialOffset = this._getDraggableElementOffset(initialOffset.left, initialOffset.top);
    }
    const $dragElement = this._$dragElement = this._createDragElement($element);
    this._toggleDraggingClass(true);
    this._toggleDragSourceClass(true);
    this._setGestureCoverCursor($dragElement.children());
    const isFixedPosition = "fixed" === $dragElement.css("position");
    this._initPosition(extend({}, dragStartArgs, {
      dragElement: $dragElement.get(0),
      initialOffset: isFixedPosition && initialOffset
    }));
    this._getAction("onDraggableElementShown")(_extends({}, dragStartArgs, {
      dragElement: $dragElement
    }));
    const $area = this._getArea();
    const areaOffset = this._getAreaOffset($area);
    const boundOffset = this._getBoundOffset();
    const areaWidth = getOuterWidth($area);
    const areaHeight = getOuterHeight($area);
    const elementWidth = getWidth($dragElement);
    const elementHeight = getHeight($dragElement);
    const startOffset_left = $dragElement.offset().left - areaOffset.left, startOffset_top = $dragElement.offset().top - areaOffset.top;
    if ($area.length) {
      e.maxLeftOffset = startOffset_left - boundOffset.left;
      e.maxRightOffset = areaWidth - startOffset_left - elementWidth - boundOffset.right;
      e.maxTopOffset = startOffset_top - boundOffset.top;
      e.maxBottomOffset = areaHeight - startOffset_top - elementHeight - boundOffset.bottom;
    }
    if (this.option("autoScroll")) {
      this._startAnimator();
    }
  },
  _getAreaOffset($area) {
    const offset2 = $area && position_default.offset($area);
    return offset2 || {
      left: 0,
      top: 0
    };
  },
  _toggleDraggingClass(value2) {
    this._$dragElement && this._$dragElement.toggleClass(this._addWidgetPrefix("dragging"), value2);
  },
  _toggleDragSourceClass(value2, $element) {
    const $sourceElement = $element || this._$sourceElement;
    $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix("source"), value2);
  },
  _setGestureCoverCursor($element) {
    renderer_default(".dx-gesture-cover").css("cursor", $element.css("cursor"));
  },
  _getBoundOffset() {
    let boundOffset = this.option("boundOffset");
    if (isFunction(boundOffset)) {
      boundOffset = boundOffset.call(this);
    }
    return quadToObject(boundOffset);
  },
  _getArea() {
    let area = this.option("boundary");
    if (isFunction(area)) {
      area = area.call(this);
    }
    return renderer_default(area);
  },
  _getContainer() {
    let container = this.option("container");
    if (void 0 === container) {
      container = value();
    }
    return renderer_default(container);
  },
  _getDraggableElementOffset(initialOffsetX, initialOffsetY) {
    var _this$_startPosition, _this$_startPosition2;
    const initScrollTop = this._initScrollTop;
    const initScrollLeft = this._initScrollLeft;
    const scrollTop = this._getScrollableScrollTop();
    const scrollLeft = this._getScrollableScrollLeft();
    const elementPosition = renderer_default(this.element()).css("position");
    const isFixedPosition = "fixed" === elementPosition;
    const result2 = {
      left: ((null === (_this$_startPosition = this._startPosition) || void 0 === _this$_startPosition ? void 0 : _this$_startPosition.left) ?? 0) + initialOffsetX,
      top: ((null === (_this$_startPosition2 = this._startPosition) || void 0 === _this$_startPosition2 ? void 0 : _this$_startPosition2.top) ?? 0) + initialOffsetY
    };
    if (isFixedPosition || this._hasClonedDraggable()) {
      return result2;
    }
    return {
      left: isNumeric(scrollLeft) ? result2.left + scrollLeft - initScrollLeft : result2.left,
      top: isNumeric(scrollTop) ? result2.top + scrollTop - initScrollTop : result2.top
    };
  },
  _hasClonedDraggable() {
    return this.option("clone") || this.option("dragTemplate");
  },
  _dragMoveHandler(e) {
    this._dragMoveArgs = e;
    if (!this._$dragElement) {
      e.cancel = true;
      return;
    }
    const offset2 = this._getDraggableElementOffset(e.offset.x, e.offset.y);
    this._move(offset2);
    this._updateScrollable(e);
    const eventArgs = this._getEventArgs(e);
    this._getAction("onDragMove")(eventArgs);
    if (true === eventArgs.cancel) {
      return;
    }
    const targetDraggable2 = this._getTargetDraggable();
    targetDraggable2.dragMove(e, scrollBy);
  },
  _updateScrollable(e) {
    const that = this;
    if (that.option("autoScroll")) {
      const mousePosition = getMousePosition(e);
      const allObjects = dom_adapter_default.elementsFromPoint(mousePosition.x, mousePosition.y, this.$element().get(0));
      that._verticalScrollHelper.updateScrollable(allObjects, mousePosition);
      that._horizontalScrollHelper.updateScrollable(allObjects, mousePosition);
    }
  },
  _getScrollable($element) {
    let $scrollable;
    $element.parents().toArray().some((parent) => {
      const $parent = renderer_default(parent);
      if (this._horizontalScrollHelper.isScrollable($parent) || this._verticalScrollHelper.isScrollable($parent)) {
        $scrollable = $parent;
        return true;
      }
      return false;
    });
    return $scrollable;
  },
  _getScrollableScrollTop() {
    var _this$_getScrollable;
    return (null === (_this$_getScrollable = this._getScrollable(renderer_default(this.element()))) || void 0 === _this$_getScrollable ? void 0 : _this$_getScrollable.scrollTop()) ?? 0;
  },
  _getScrollableScrollLeft() {
    var _this$_getScrollable2;
    return (null === (_this$_getScrollable2 = this._getScrollable(renderer_default(this.element()))) || void 0 === _this$_getScrollable2 ? void 0 : _this$_getScrollable2.scrollLeft()) ?? 0;
  },
  _defaultActionArgs() {
    const args = this.callBase.apply(this, arguments);
    const component = this.option("component");
    if (component) {
      args.component = component;
      args.element = component.element();
    }
    return args;
  },
  _getEventArgs(e) {
    const sourceDraggable2 = this._getSourceDraggable();
    const targetDraggable2 = this._getTargetDraggable();
    return {
      event: e,
      itemData: sourceDraggable2.option("itemData"),
      itemElement: getPublicElement(sourceDraggable2._$sourceElement),
      fromComponent: sourceDraggable2.option("component") || sourceDraggable2,
      toComponent: targetDraggable2.option("component") || targetDraggable2,
      fromData: sourceDraggable2.option("data"),
      toData: targetDraggable2.option("data")
    };
  },
  _getDragStartArgs(e, $itemElement) {
    const args = this._getEventArgs(e);
    return {
      event: args.event,
      itemData: args.itemData,
      itemElement: $itemElement,
      fromData: args.fromData
    };
  },
  _revertItemToInitialPosition() {
    !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);
  },
  _dragEndHandler(e) {
    const d = Deferred();
    const dragEndEventArgs = this._getEventArgs(e);
    const dropEventArgs = this._getEventArgs(e);
    const targetDraggable2 = this._getTargetDraggable();
    let needRevertPosition = true;
    this.dragInProgress = false;
    try {
      this._getAction("onDragEnd")(dragEndEventArgs);
    } finally {
      when(fromPromise(dragEndEventArgs.cancel)).done((cancel2) => {
        if (!cancel2) {
          if (targetDraggable2 !== this) {
            targetDraggable2._getAction("onDrop")(dropEventArgs);
          }
          if (!dropEventArgs.cancel) {
            needRevertPosition = false;
            when(fromPromise(targetDraggable2.dragEnd(dragEndEventArgs))).always(d.resolve);
            return;
          }
        }
        d.resolve();
      }).fail(d.resolve);
      d.done(() => {
        if (needRevertPosition) {
          this._revertItemToInitialPosition();
        }
        this._resetDragOptions(targetDraggable2);
      });
    }
  },
  _isTargetOverAnotherDraggable(e) {
    const sourceDraggable2 = this._getSourceDraggable();
    if (this === sourceDraggable2) {
      return false;
    }
    const $dragElement = sourceDraggable2._$dragElement;
    const $sourceDraggableElement = sourceDraggable2.$element();
    const $targetDraggableElement = this.$element();
    const mousePosition = getMousePosition(e);
    const elements = dom_adapter_default.elementsFromPoint(mousePosition.x, mousePosition.y, this.element());
    const firstWidgetElement = elements.filter((element) => {
      const $element = renderer_default(element);
      if ($element.hasClass(this._addWidgetPrefix())) {
        return !$element.closest($dragElement).length;
      }
      return false;
    })[0];
    const $sourceElement = this._getSourceElement();
    const isTargetOverItself = firstWidgetElement === $sourceDraggableElement.get(0);
    const isTargetOverNestedDraggable = renderer_default(firstWidgetElement).closest($sourceElement).length;
    return !firstWidgetElement || firstWidgetElement === $targetDraggableElement.get(0) && !isTargetOverItself && !isTargetOverNestedDraggable;
  },
  _dragEnterHandler(e) {
    this._fireDragEnterEvent(e);
    if (this._isTargetOverAnotherDraggable(e)) {
      this._setTargetDraggable();
    }
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2.dragEnter(e);
  },
  _dragLeaveHandler(e) {
    this._fireDragLeaveEvent(e);
    this._resetTargetDraggable();
    if (this !== this._getSourceDraggable()) {
      this.reset();
    }
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2.dragLeave(e);
  },
  _keydownHandler(e) {
    if (this.dragInProgress && "Escape" === e.key) {
      this._keydownEscapeHandler(e);
    }
  },
  _keydownEscapeHandler(e) {
    var _sourceDraggable;
    const $sourceElement = this._getSourceElement();
    if (!$sourceElement) {
      return;
    }
    const dragCancelEventArgs = this._getEventArgs(e);
    this._getAction("onDragCancel")(dragCancelEventArgs);
    if (dragCancelEventArgs.cancel) {
      return;
    }
    this.dragInProgress = false;
    null === (_sourceDraggable = sourceDraggable) || void 0 === _sourceDraggable || _sourceDraggable._toggleDraggingClass(false);
    this._detachEventHandlers();
    this._revertItemToInitialPosition();
    const targetDraggable2 = this._getTargetDraggable();
    this._resetDragOptions(targetDraggable2);
    this._attachEventHandlers();
  },
  _getAction(name2) {
    return this[`_${name2}Action`] || this._createActionByOption(name2);
  },
  _getAnonymousTemplateName: () => "content",
  _initTemplates() {
    if (!this.option("contentTemplate")) {
      return;
    }
    this._templateManager.addDefaultTemplates({
      content: new EmptyTemplate()
    });
    this.callBase.apply(this, arguments);
  },
  _render() {
    this.callBase();
    this.$element().addClass(this._addWidgetPrefix());
    const transclude = this._templateManager.anonymousTemplateName === this.option("contentTemplate");
    const template = this._getTemplateByOption("contentTemplate");
    if (template) {
      renderer_default(template.render({
        container: this.element(),
        transclude
      }));
    }
  },
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "onDragStart":
      case "onDragMove":
      case "onDragEnd":
      case "onDrop":
      case "onDragEnter":
      case "onDragLeave":
      case "onDragCancel":
      case "onDraggableElementShown":
        this[`_${name2}Action`] = this._createActionByOption(name2);
        break;
      case "dragTemplate":
      case "contentTemplate":
      case "container":
      case "clone":
      case "scrollSensitivity":
      case "scrollSpeed":
      case "boundOffset":
      case "handle":
      case "group":
      case "data":
      case "itemData":
        break;
      case "allowMoveByClick":
      case "dragDirection":
      case "disabled":
      case "boundary":
      case "filter":
      case "immediate":
        this._resetDragElement();
        this._detachEventHandlers();
        this._attachEventHandlers();
        break;
      case "onCancelByEsc":
        this._keydownHandler();
        break;
      case "autoScroll":
        this._verticalScrollHelper.reset();
        this._horizontalScrollHelper.reset();
        break;
      default:
        this.callBase(args);
    }
  },
  _getTargetDraggable() {
    return targetDraggable || this;
  },
  _getSourceDraggable() {
    return sourceDraggable || this;
  },
  _setTargetDraggable() {
    const currentGroup = this.option("group");
    const sourceDraggable2 = this._getSourceDraggable();
    if (currentGroup && currentGroup === sourceDraggable2.option("group")) {
      targetDraggable = this;
    }
  },
  _setSourceDraggable() {
    sourceDraggable = this;
  },
  _resetSourceDraggable() {
    sourceDraggable = null;
  },
  _resetTargetDraggable() {
    targetDraggable = null;
  },
  _resetDragOptions(targetDraggable2) {
    this.reset();
    targetDraggable2.reset();
    this._stopAnimator();
    this._horizontalScrollHelper.reset();
    this._verticalScrollHelper.reset();
    this._resetDragElement();
    this._resetSourceElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
  },
  _dispose() {
    this.callBase();
    this._detachEventHandlers();
    this._resetDragElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
    this._$sourceElement = null;
    this._stopAnimator();
  },
  _fireDragEnterEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onDragEnter")(args);
  },
  _fireDragLeaveEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onDragLeave")(args);
  }
});
component_registrator_default(DRAGGABLE, Draggable);
var m_draggable_default = Draggable;

// ../../../../../../node_modules/devextreme/esm/ui/draggable.js
var draggable_default = m_draggable_default;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/utils/is_scheduler_component.js
function isSchedulerComponent(component) {
  return "dxScheduler" === component.NAME;
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_appointment_drag_behavior.js
var APPOINTMENT_ITEM_CLASS2 = "dx-scheduler-appointment";
var AppointmentDragBehavior = class {
  constructor(scheduler) {
    this.scheduler = scheduler;
    this.workspace = this.scheduler._workSpace;
    this.appointments = this.scheduler._appointments;
    this.initialPosition = {
      left: 0,
      top: 0
    };
    this.appointmentInfo = null;
    this.dragBetweenComponentsPromise = null;
  }
  isAllDay(appointment) {
    return appointment.data("dxAppointmentSettings").allDay;
  }
  onDragStart(e) {
    const {
      itemSettings,
      itemData,
      initialPosition
    } = e;
    this.initialPosition = initialPosition;
    this.appointmentInfo = {
      appointment: itemData,
      settings: itemSettings
    };
    this.appointments.notifyObserver("hideAppointmentTooltip");
  }
  onDragMove(e) {
    if (e.fromComponent !== e.toComponent) {
      this.appointments.notifyObserver("removeDroppableCellClass");
    }
  }
  getAppointmentElement(e) {
    const itemElement = e.event.data && e.event.data.itemElement || e.itemElement;
    return renderer_default(itemElement);
  }
  onDragEnd(event) {
    const element = this.getAppointmentElement(event);
    const rawAppointment = this.appointments._getItemData(element);
    const container = this.appointments._getAppointmentContainer(this.isAllDay(element));
    container.append(element);
    const newCellIndex = this.workspace.getDroppableCellIndex();
    const oldCellIndex = this.workspace.getCellIndexByCoordinates(this.initialPosition);
    this.appointments.notifyObserver("updateAppointmentAfterDrag", {
      event,
      element,
      rawAppointment,
      newCellIndex,
      oldCellIndex
    });
  }
  onDragCancel() {
    this.removeDroppableClasses();
  }
  getItemData(appointmentElement) {
    const dataFromTooltip = renderer_default(appointmentElement).data(LIST_ITEM_DATA_KEY);
    const itemDataFromTooltip = null === dataFromTooltip || void 0 === dataFromTooltip ? void 0 : dataFromTooltip.appointment;
    const itemDataFromGrid = this.appointments._getItemData(appointmentElement);
    return itemDataFromTooltip || itemDataFromGrid;
  }
  getItemSettings(appointment) {
    const itemData = renderer_default(appointment).data(LIST_ITEM_DATA_KEY);
    return itemData && itemData.settings || [];
  }
  createDragStartHandler(options2, appointmentDragging) {
    return (e) => {
      e.itemData = this.getItemData(e.itemElement);
      e.itemSettings = this.getItemSettings(e.itemElement);
      appointmentDragging.onDragStart && appointmentDragging.onDragStart(e);
      if (!e.cancel) {
        options2.onDragStart(e);
      }
    };
  }
  createDragMoveHandler(options2, appointmentDragging) {
    return (e) => {
      appointmentDragging.onDragMove && appointmentDragging.onDragMove(e);
      if (!e.cancel) {
        options2.onDragMove(e);
      }
    };
  }
  createDragEndHandler(options2, appointmentDragging) {
    return (e) => {
      const updatedData = this.appointments.invoke("getUpdatedData", e.itemData);
      this.appointmentInfo = null;
      e.toItemData = extend({}, e.itemData, updatedData);
      appointmentDragging.onDragEnd && appointmentDragging.onDragEnd(e);
      if (!e.cancel) {
        options2.onDragEnd(e);
        if (e.fromComponent !== e.toComponent) {
          appointmentDragging.onRemove && appointmentDragging.onRemove(e);
        }
      }
      if (true === e.cancel) {
        this.removeDroppableClasses();
      }
      if (true !== e.cancel && isSchedulerComponent(e.toComponent)) {
        const targetDragBehavior = e.toComponent._getDragBehavior();
        targetDragBehavior.dragBetweenComponentsPromise = new Deferred();
      }
    };
  }
  createDropHandler(appointmentDragging) {
    return (e) => {
      const updatedData = this.appointments.invoke("getUpdatedData", e.itemData);
      e.itemData = extend({}, e.itemData, updatedData);
      if (e.fromComponent !== e.toComponent) {
        appointmentDragging.onAdd && appointmentDragging.onAdd(e);
      }
      if (this.dragBetweenComponentsPromise) {
        this.dragBetweenComponentsPromise.resolve();
      }
    };
  }
  addTo(container, config3) {
    const appointmentDragging = this.scheduler.option("appointmentDragging") || {};
    const options2 = extend({
      component: this.scheduler,
      contentTemplate: null,
      filter: `.${APPOINTMENT_ITEM_CLASS2}`,
      immediate: false,
      onDragStart: this.onDragStart.bind(this),
      onDragMove: this.onDragMove.bind(this),
      onDragEnd: this.onDragEnd.bind(this),
      onDragCancel: this.onDragCancel.bind(this)
    }, config3);
    this.appointments._createComponent(container, draggable_default, extend({}, options2, appointmentDragging, {
      onDragStart: this.createDragStartHandler(options2, appointmentDragging),
      onDragMove: this.createDragMoveHandler(options2, appointmentDragging),
      onDragEnd: this.createDragEndHandler(options2, appointmentDragging),
      onDrop: this.createDropHandler(appointmentDragging),
      onCancelByEsc: true
    }));
  }
  updateDragSource(appointment, settings) {
    const {
      appointmentInfo
    } = this;
    if (appointmentInfo || appointment) {
      const currentAppointment = appointment || appointmentInfo.appointment;
      const currentSettings = settings || appointmentInfo.settings;
      this.appointments._setDragSourceAppointment(currentAppointment, currentSettings);
    }
  }
  removeDroppableClasses() {
    this.appointments._removeDragSourceClassFromDraggedAppointment();
    this.workspace.removeDroppableCellClass();
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/shaders/m_current_time_shader.js
var DATE_TIME_SHADER_CLASS = "dx-scheduler-date-time-shader";
var CurrentTimeShader = class {
  constructor(_workSpace) {
    this._workSpace = _workSpace;
    this._$container = this._workSpace._dateTableScrollable.$content();
  }
  render() {
    this.initShaderElements();
    this.renderShader();
    this._shader.forEach((shader) => {
      this._$container.append(shader);
    });
  }
  initShaderElements() {
    this._$shader = this.createShader();
    this._shader = [];
    this._shader.push(this._$shader);
  }
  renderShader() {
  }
  createShader() {
    return renderer_default("<div>").addClass(DATE_TIME_SHADER_CLASS);
  }
  clean() {
    this._$container && this._$container.find(`.${DATE_TIME_SHADER_CLASS}`).remove();
  }
};
var m_current_time_shader_default = CurrentTimeShader;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/shaders/m_current_time_shader_vertical.js
var DATE_TIME_SHADER_ALL_DAY_CLASS = "dx-scheduler-date-time-shader-all-day";
var DATE_TIME_SHADER_TOP_CLASS = "dx-scheduler-date-time-shader-top";
var DATE_TIME_SHADER_BOTTOM_CLASS = "dx-scheduler-date-time-shader-bottom";
var VerticalCurrentTimeShader = class extends m_current_time_shader_default {
  renderShader() {
    let shaderHeight = this._getShaderHeight();
    const maxHeight = this._getShaderMaxHeight();
    const isSolidShader = shaderHeight > maxHeight;
    if (shaderHeight > maxHeight) {
      shaderHeight = maxHeight;
    }
    setHeight(this._$shader, shaderHeight);
    const groupCount = this._workSpace._getGroupCount() || 1;
    if (this._workSpace.isGroupedByDate()) {
      this._renderGroupedByDateShaderParts(groupCount, shaderHeight, maxHeight, isSolidShader);
    } else {
      this._renderShaderParts(groupCount, shaderHeight, maxHeight, isSolidShader);
    }
  }
  _renderShaderParts(groupCount, shaderHeight, maxHeight, isSolidShader) {
    for (let i = 0; i < groupCount; i++) {
      const shaderWidth = this._getShaderWidth(i);
      this._renderTopShader(this._$shader, shaderHeight, shaderWidth, i);
      !isSolidShader && this._renderBottomShader(this._$shader, maxHeight, shaderHeight, shaderWidth, i);
      this._renderAllDayShader(shaderWidth, i);
    }
  }
  _renderGroupedByDateShaderParts(groupCount, shaderHeight, maxHeight, isSolidShader) {
    const shaderWidth = this._getShaderWidth(0);
    let bottomShaderWidth = shaderWidth - this._workSpace.getCellWidth();
    if (shaderHeight < 0) {
      shaderHeight = 0;
      bottomShaderWidth = shaderWidth;
    }
    this._renderTopShader(this._$shader, shaderHeight, shaderWidth * groupCount, 0);
    !isSolidShader && this._renderBottomShader(this._$shader, maxHeight, shaderHeight, bottomShaderWidth * groupCount + this._workSpace.getCellWidth(), 0);
    this._renderAllDayShader(shaderWidth * groupCount, 0);
  }
  _renderTopShader($shader, height, width, i) {
    this._$topShader = renderer_default("<div>").addClass(DATE_TIME_SHADER_TOP_CLASS);
    if (width) {
      setWidth(this._$topShader, width);
    }
    if (height) {
      setHeight(this._$topShader, height);
    }
    this._$topShader.css("marginTop", this._getShaderTopOffset(i));
    this._$topShader.css("left", this._getShaderOffset(i, width));
    $shader.append(this._$topShader);
  }
  _renderBottomShader($shader, maxHeight, height, width, i) {
    this._$bottomShader = renderer_default("<div>").addClass(DATE_TIME_SHADER_BOTTOM_CLASS);
    const shaderWidth = height < 0 ? width : width - this._workSpace.getCellWidth();
    const shaderHeight = height < 0 ? maxHeight : maxHeight - height;
    setWidth(this._$bottomShader, shaderWidth);
    setHeight(this._$bottomShader, shaderHeight);
    this._$bottomShader.css("left", this._getShaderOffset(i, width - this._workSpace.getCellWidth()));
    $shader.append(this._$bottomShader);
  }
  _renderAllDayShader(shaderWidth, i) {
    if (this._workSpace.option("showAllDayPanel")) {
      this._$allDayIndicator = renderer_default("<div>").addClass(DATE_TIME_SHADER_ALL_DAY_CLASS);
      setHeight(this._$allDayIndicator, this._workSpace.getAllDayHeight());
      setWidth(this._$allDayIndicator, shaderWidth);
      this._$allDayIndicator.css("left", this._getShaderOffset(i, shaderWidth));
      this._workSpace._$allDayPanel.prepend(this._$allDayIndicator);
    }
  }
  _getShaderOffset(i, width) {
    return this._workSpace.getGroupedStrategy().getShaderOffset(i, width);
  }
  _getShaderTopOffset(i) {
    return this._workSpace.getGroupedStrategy().getShaderTopOffset(i);
  }
  _getShaderHeight() {
    return this._workSpace.getGroupedStrategy().getShaderHeight();
  }
  _getShaderMaxHeight() {
    return this._workSpace.getGroupedStrategy().getShaderMaxHeight();
  }
  _getShaderWidth(i) {
    return this._workSpace.getGroupedStrategy().getShaderWidth(i);
  }
  clean() {
    super.clean();
    this._workSpace && this._workSpace._$allDayPanel && this._workSpace._$allDayPanel.find(`.${DATE_TIME_SHADER_ALL_DAY_CLASS}`).remove();
  }
};
var m_current_time_shader_vertical_default = VerticalCurrentTimeShader;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_cache.js
var Cache2 = class {
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._cache.size;
  }
  clear() {
    this._cache.clear();
  }
  get(name2, callback) {
    if (!this._cache.has(name2) && callback) {
      this.set(name2, callback());
    }
    return this._cache.get(name2);
  }
  set(name2, value2) {
    isDefined(value2) && this._cache.set(name2, value2);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_cells_selection_controller.js
var CellsSelectionController = class {
  handleArrowClick(options2) {
    const {
      key,
      focusedCellPosition,
      edgeIndices,
      getCellDataByPosition,
      isAllDayPanelCell
    } = options2;
    let nextCellIndices;
    switch (key) {
      case "down":
        nextCellIndices = this.getCellFromNextRowPosition(focusedCellPosition, "next", edgeIndices);
        break;
      case "up":
        nextCellIndices = this.getCellFromNextRowPosition(focusedCellPosition, "prev", edgeIndices);
        break;
      case "left":
        nextCellIndices = this.getCellFromNextColumnPosition(_extends({}, options2, {
          direction: "prev"
        }));
        break;
      case "right":
        nextCellIndices = this.getCellFromNextColumnPosition(_extends({}, options2, {
          direction: "next"
        }));
    }
    const currentCellData = getCellDataByPosition(nextCellIndices.rowIndex, nextCellIndices.columnIndex, isAllDayPanelCell);
    return this.moveToCell(_extends({}, options2, {
      currentCellData
    }));
  }
  getCellFromNextRowPosition(focusedCellPosition, direction, edgeIndices) {
    const {
      columnIndex,
      rowIndex
    } = focusedCellPosition;
    const deltaPosition = "next" === direction ? 1 : -1;
    const nextRowIndex = rowIndex + deltaPosition;
    const validRowIndex = nextRowIndex >= 0 && nextRowIndex <= edgeIndices.lastRowIndex ? nextRowIndex : rowIndex;
    return {
      columnIndex,
      rowIndex: validRowIndex
    };
  }
  getCellFromNextColumnPosition(options2) {
    const {
      focusedCellPosition,
      direction,
      edgeIndices,
      isRTL,
      isGroupedByDate,
      groupCount,
      isMultiSelection,
      viewType
    } = options2;
    const {
      columnIndex,
      rowIndex
    } = focusedCellPosition;
    const {
      firstColumnIndex,
      lastColumnIndex,
      firstRowIndex,
      lastRowIndex
    } = edgeIndices;
    const step = isGroupedByDate && isMultiSelection ? groupCount : 1;
    const sign2 = isRTL ? -1 : 1;
    const deltaColumnIndex = "next" === direction ? sign2 * step : -1 * sign2 * step;
    const nextColumnIndex = columnIndex + deltaColumnIndex;
    const isValidColumnIndex = nextColumnIndex >= firstColumnIndex && nextColumnIndex <= lastColumnIndex;
    if (isValidColumnIndex) {
      return {
        columnIndex: nextColumnIndex,
        rowIndex
      };
    }
    return isDateAndTimeView(viewType) ? focusedCellPosition : this._processEdgeCell({
      nextColumnIndex,
      rowIndex,
      columnIndex,
      firstColumnIndex,
      lastColumnIndex,
      firstRowIndex,
      lastRowIndex,
      step
    });
  }
  _processEdgeCell(options2) {
    const {
      nextColumnIndex,
      rowIndex,
      columnIndex,
      firstColumnIndex,
      lastColumnIndex,
      firstRowIndex,
      lastRowIndex,
      step
    } = options2;
    let validColumnIndex = nextColumnIndex;
    let validRowIndex = rowIndex;
    const isLeftEdgeCell = nextColumnIndex < firstColumnIndex;
    const isRightEdgeCell = nextColumnIndex > lastColumnIndex;
    if (isLeftEdgeCell) {
      const columnIndexInNextRow = lastColumnIndex - (step - columnIndex % step - 1);
      const nextRowIndex = rowIndex - 1;
      const isValidRowIndex = nextRowIndex >= firstRowIndex;
      validRowIndex = isValidRowIndex ? nextRowIndex : rowIndex;
      validColumnIndex = isValidRowIndex ? columnIndexInNextRow : columnIndex;
    }
    if (isRightEdgeCell) {
      const columnIndexInNextRow = firstColumnIndex + columnIndex % step;
      const nextRowIndex = rowIndex + 1;
      const isValidRowIndex = nextRowIndex <= lastRowIndex;
      validRowIndex = isValidRowIndex ? nextRowIndex : rowIndex;
      validColumnIndex = isValidRowIndex ? columnIndexInNextRow : columnIndex;
    }
    return {
      columnIndex: validColumnIndex,
      rowIndex: validRowIndex
    };
  }
  moveToCell(options2) {
    const {
      isMultiSelection,
      isMultiSelectionAllowed,
      focusedCellData,
      currentCellData
    } = options2;
    const isValidMultiSelection = isMultiSelection && isMultiSelectionAllowed;
    const nextFocusedCellData = isValidMultiSelection ? this._getNextCellData(currentCellData, focusedCellData) : currentCellData;
    return nextFocusedCellData;
  }
  _getNextCellData(nextFocusedCellData, focusedCellData, isVirtualCell) {
    if (isVirtualCell) {
      return focusedCellData;
    }
    const isValidNextFocusedCell = this._isValidNextFocusedCell(nextFocusedCellData, focusedCellData);
    return isValidNextFocusedCell ? nextFocusedCellData : focusedCellData;
  }
  _isValidNextFocusedCell(nextFocusedCellData, focusedCellData) {
    if (!focusedCellData) {
      return true;
    }
    const {
      groupIndex,
      allDay
    } = focusedCellData;
    const {
      groupIndex: nextGroupIndex,
      allDay: nextAllDay
    } = nextFocusedCellData;
    return groupIndex === nextGroupIndex && allDay === nextAllDay;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_cells_selection_state.js
var CellsSelectionState = class {
  constructor(_viewDataProvider) {
    this._viewDataProvider = _viewDataProvider;
    this._focusedCell = null;
    this._selectedCells = null;
    this._firstSelectedCell = null;
    this._prevFocusedCell = null;
    this._prevSelectedCells = null;
  }
  get viewDataProvider() {
    return this._viewDataProvider;
  }
  get focusedCell() {
    const focusedCell = this._focusedCell;
    if (!focusedCell) {
      return;
    }
    const {
      groupIndex,
      startDate,
      allDay
    } = focusedCell;
    const cellInfo = {
      groupIndex,
      startDate,
      isAllDay: allDay,
      index: focusedCell.index
    };
    const cellPosition = this.viewDataProvider.findCellPositionInMap(cellInfo);
    return {
      coordinates: cellPosition,
      cellData: focusedCell
    };
  }
  setFocusedCell(rowIndex, columnIndex, isAllDay) {
    if (rowIndex >= 0) {
      const cell = this._viewDataProvider.getCellData(rowIndex, columnIndex, isAllDay);
      this._focusedCell = cell;
    }
  }
  setSelectedCells(lastCellCoordinates) {
    let firstCellCoordinates = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
    const viewDataProvider = this._viewDataProvider;
    const {
      rowIndex: lastRowIndex,
      columnIndex: lastColumnIndex,
      allDay: isLastCellAllDay
    } = lastCellCoordinates;
    if (lastRowIndex < 0) {
      return;
    }
    const firstCell = firstCellCoordinates ? viewDataProvider.getCellData(firstCellCoordinates.rowIndex, firstCellCoordinates.columnIndex, firstCellCoordinates.allDay) : this._firstSelectedCell;
    const lastCell = viewDataProvider.getCellData(lastRowIndex, lastColumnIndex, isLastCellAllDay);
    this._firstSelectedCell = firstCell;
    this._selectedCells = this._viewDataProvider.getCellsBetween(firstCell, lastCell);
  }
  setSelectedCellsByData(selectedCellsData) {
    this._selectedCells = selectedCellsData;
  }
  getSelectedCells() {
    return this._selectedCells;
  }
  releaseSelectedAndFocusedCells() {
    this.releaseSelectedCells();
    this.releaseFocusedCell();
  }
  releaseSelectedCells() {
    this._prevSelectedCells = this._selectedCells;
    this._prevFirstSelectedCell = this._firstSelectedCell;
    this._selectedCells = null;
    this._firstSelectedCell = null;
  }
  releaseFocusedCell() {
    this._prevFocusedCell = this._focusedCell;
    this._focusedCell = null;
  }
  restoreSelectedAndFocusedCells() {
    this._selectedCells = this._selectedCells || this._prevSelectedCells;
    this._focusedCell = this._focusedCell || this._prevFocusedCell;
    this._firstSelectedCell = this._firstSelectedCell || this._prevFirstSelectedCell;
    this._prevSelectedCells = null;
    this._prevFirstSelectedCell = null;
    this._prevFocusedCell = null;
  }
  clearSelectedAndFocusedCells() {
    this._prevSelectedCells = null;
    this._selectedCells = null;
    this._prevFocusedCell = null;
    this._focusedCell = null;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_virtual_scrolling.js
var DOCUMENT_SCROLL_EVENT_NAMESPACE = addNamespace2("scroll", "dxSchedulerVirtualScrolling");
var scrollingOrientations = {
  vertical: "vertical",
  horizontal: "horizontal",
  both: "both",
  none: "none"
};
var DefaultScrollingOrientation = scrollingOrientations.both;
var VirtualScrollingDispatcher = class {
  constructor(options2) {
    this.options = options2;
    if (options2) {
      this._rowHeight = this.getCellHeight();
      this._cellWidth = this.getCellWidth();
      this._createVirtualScrollingBase();
    }
  }
  get isRTL() {
    return this.options.isRTL();
  }
  get verticalVirtualScrolling() {
    return this._verticalVirtualScrolling;
  }
  set verticalVirtualScrolling(value2) {
    this._verticalVirtualScrolling = value2;
  }
  get horizontalVirtualScrolling() {
    return this._horizontalVirtualScrolling;
  }
  set horizontalVirtualScrolling(value2) {
    this._horizontalVirtualScrolling = value2;
  }
  get document() {
    return dom_adapter_default.getDocument();
  }
  get height() {
    return this.options.getSchedulerHeight();
  }
  get width() {
    return this.options.getSchedulerWidth();
  }
  get rowHeight() {
    return this._rowHeight;
  }
  set rowHeight(value2) {
    this._rowHeight = value2;
  }
  get outlineCount() {
    return this.options.getScrolling().outlineCount;
  }
  get cellWidth() {
    return this._cellWidth;
  }
  set cellWidth(value2) {
    this._cellWidth = value2;
  }
  get viewportWidth() {
    const width = this.width && this.options.getViewWidth();
    return width > 0 ? width : this.options.getWindowWidth();
  }
  get viewportHeight() {
    const height = this.height && this.options.getViewHeight();
    return height > 0 ? height : this.options.getWindowHeight();
  }
  get cellCountInsideTopVirtualRow() {
    var _this$verticalScrolli;
    return (null === (_this$verticalScrolli = this.verticalScrollingState) || void 0 === _this$verticalScrolli ? void 0 : _this$verticalScrolli.virtualItemCountBefore) || 0;
  }
  get cellCountInsideLeftVirtualCell() {
    var _this$horizontalScrol;
    return (null === (_this$horizontalScrol = this.horizontalScrollingState) || void 0 === _this$horizontalScrol ? void 0 : _this$horizontalScrol.virtualItemCountBefore) || 0;
  }
  get cellCountInsideRightVirtualCell() {
    var _this$horizontalScrol2;
    return (null === (_this$horizontalScrol2 = this.horizontalScrollingState) || void 0 === _this$horizontalScrol2 ? void 0 : _this$horizontalScrol2.virtualItemCountAfter) || 0;
  }
  get topVirtualRowsCount() {
    return this.cellCountInsideTopVirtualRow > 0 ? 1 : 0;
  }
  get leftVirtualCellsCount() {
    const virtualItemsCount = !this.isRTL ? this.cellCountInsideLeftVirtualCell : this.cellCountInsideRightVirtualCell;
    return Math.ceil(virtualItemsCount / 1e3);
  }
  get virtualRowOffset() {
    var _this$verticalScrolli2;
    return (null === (_this$verticalScrolli2 = this.verticalScrollingState) || void 0 === _this$verticalScrolli2 ? void 0 : _this$verticalScrolli2.virtualItemSizeBefore) || 0;
  }
  get virtualCellOffset() {
    var _this$horizontalScrol3;
    return (null === (_this$horizontalScrol3 = this.horizontalScrollingState) || void 0 === _this$horizontalScrol3 ? void 0 : _this$horizontalScrol3.virtualItemSizeBefore) || 0;
  }
  get scrollingState() {
    var _this$verticalVirtual, _this$horizontalVirtu;
    return {
      vertical: null === (_this$verticalVirtual = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual ? void 0 : _this$verticalVirtual.state,
      horizontal: null === (_this$horizontalVirtu = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu ? void 0 : _this$horizontalVirtu.state
    };
  }
  get verticalScrollingState() {
    return this.scrollingState.vertical;
  }
  get horizontalScrollingState() {
    return this.scrollingState.horizontal;
  }
  get scrollingOrientation() {
    const scrolling = this.options.getScrolling();
    if ("standard" === scrolling.mode) {
      return scrollingOrientations.none;
    }
    return scrolling.orientation || DefaultScrollingOrientation;
  }
  get verticalScrollingAllowed() {
    return this.scrollingOrientation === scrollingOrientations.vertical || this.scrollingOrientation === scrollingOrientations.both;
  }
  get horizontalScrollingAllowed() {
    return this.scrollingOrientation === scrollingOrientations.horizontal || this.scrollingOrientation === scrollingOrientations.both;
  }
  setViewOptions(options2) {
    this.options = options2;
    if (this.verticalVirtualScrolling) {
      this.verticalVirtualScrolling.options = options2;
      this.verticalVirtualScrolling.itemSize = this.rowHeight;
      this.verticalVirtualScrolling.viewportSize = this.viewportHeight;
    }
    if (this.horizontalVirtualScrolling) {
      this.horizontalVirtualScrolling.options = options2;
      this.verticalVirtualScrolling.itemSize = this.cellWidth;
      this.verticalVirtualScrolling.viewportSize = this.viewportWidth;
    }
  }
  getRenderState() {
    var _this$verticalVirtual2, _this$horizontalVirtu2;
    const verticalRenderState = (null === (_this$verticalVirtual2 = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual2 ? void 0 : _this$verticalVirtual2.getRenderState()) || {};
    const horizontalRenderState = (null === (_this$horizontalVirtu2 = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu2 ? void 0 : _this$horizontalVirtu2.getRenderState()) || {};
    return _extends({}, verticalRenderState, horizontalRenderState);
  }
  getCellHeight() {
    const cellHeight = this.options.getCellHeight();
    const result2 = cellHeight > 0 ? cellHeight : 50;
    return Math.floor(result2);
  }
  getCellWidth() {
    let cellWidth = this.options.getCellWidth();
    const minCellWidth = this.options.getCellMinWidth();
    if (!cellWidth || cellWidth < minCellWidth) {
      cellWidth = minCellWidth;
    }
    const result2 = cellWidth > 0 ? cellWidth : 1;
    return Math.floor(result2);
  }
  calculateCoordinatesByDataAndPosition(cellData, position3, date, isCalculateTime, isVerticalDirectionView) {
    const {
      rowIndex,
      columnIndex
    } = position3;
    const {
      startDate,
      endDate,
      allDay
    } = cellData;
    const timeToScroll = date.getTime();
    const cellStartTime = startDate.getTime();
    const cellEndTime = endDate.getTime();
    const scrollInCell = allDay || !isCalculateTime ? 0 : (timeToScroll - cellStartTime) / (cellEndTime - cellStartTime);
    const cellWidth = this.getCellWidth();
    const rowHeight = this.getCellHeight();
    const top = isVerticalDirectionView ? (rowIndex + scrollInCell) * rowHeight : rowIndex * rowHeight;
    let left = isVerticalDirectionView ? columnIndex * cellWidth : (columnIndex + scrollInCell) * cellWidth;
    if (this.isRTL) {
      left = this.options.getScrollableOuterWidth() - left;
    }
    return {
      top,
      left
    };
  }
  dispose() {
    if (this._onScrollHandler) {
      events_engine_default.off(this.document, DOCUMENT_SCROLL_EVENT_NAMESPACE, this._onScrollHandler);
    }
  }
  createVirtualScrolling() {
    const isVerticalVirtualScrollingCreated = !!this.verticalVirtualScrolling;
    const isHorizontalVirtualScrollingCreated = !!this.horizontalVirtualScrolling;
    if (this.verticalScrollingAllowed !== isVerticalVirtualScrollingCreated || this.horizontalScrollingAllowed !== isHorizontalVirtualScrollingCreated) {
      this._rowHeight = this.getCellHeight();
      this._cellWidth = this.getCellWidth();
      this._createVirtualScrollingBase();
    }
  }
  _createVirtualScrollingBase() {
    if (this.verticalScrollingAllowed) {
      this.verticalVirtualScrolling = new VerticalVirtualScrolling(_extends({}, this.options, {
        viewportHeight: this.viewportHeight,
        rowHeight: this.rowHeight,
        outlineCount: this.outlineCount
      }));
    }
    if (this.horizontalScrollingAllowed) {
      this.horizontalVirtualScrolling = new HorizontalVirtualScrolling(_extends({}, this.options, {
        viewportWidth: this.viewportWidth,
        cellWidth: this.cellWidth,
        outlineCount: this.outlineCount
      }));
    }
  }
  isAttachWindowScrollEvent() {
    return (this.horizontalScrollingAllowed || this.verticalScrollingAllowed) && !this.height;
  }
  attachScrollableEvents() {
    if (this.isAttachWindowScrollEvent()) {
      this._attachWindowScroll();
    }
  }
  _attachWindowScroll() {
    const window28 = getWindow();
    this._onScrollHandler = this.options.createAction(() => {
      const {
        scrollX,
        scrollY
      } = window28;
      if (scrollX >= 10 || scrollY >= 10) {
        this.handleOnScrollEvent({
          left: scrollX,
          top: scrollY
        });
      }
    });
    events_engine_default.on(this.document, DOCUMENT_SCROLL_EVENT_NAMESPACE, this._onScrollHandler);
  }
  handleOnScrollEvent(scrollPosition) {
    if (scrollPosition) {
      var _this$verticalVirtual3, _this$horizontalVirtu3;
      const {
        left,
        top
      } = scrollPosition;
      const verticalStateChanged = isDefined(top) && (null === (_this$verticalVirtual3 = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual3 ? void 0 : _this$verticalVirtual3.updateState(top));
      const horizontalStateChanged = isDefined(left) && (null === (_this$horizontalVirtu3 = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu3 ? void 0 : _this$horizontalVirtu3.updateState(left));
      if (verticalStateChanged || horizontalStateChanged) {
        var _this$options$updateR, _this$options;
        null === (_this$options$updateR = (_this$options = this.options).updateRender) || void 0 === _this$options$updateR || _this$options$updateR.call(_this$options);
      }
    }
  }
  updateDimensions(isForce) {
    const cellHeight = this.getCellHeight();
    const needUpdateVertical = this.verticalScrollingAllowed && cellHeight !== this.rowHeight;
    if ((needUpdateVertical || isForce) && this.verticalVirtualScrolling) {
      this.rowHeight = cellHeight;
      this.verticalVirtualScrolling.viewportSize = this.viewportHeight;
      this.verticalVirtualScrolling.reinitState(cellHeight, isForce);
    }
    const cellWidth = this.getCellWidth();
    const needUpdateHorizontal = this.horizontalScrollingAllowed && cellWidth !== this.cellWidth;
    if ((needUpdateHorizontal || isForce) && this.horizontalVirtualScrolling) {
      this.cellWidth = cellWidth;
      this.horizontalVirtualScrolling.viewportSize = this.viewportWidth;
      this.horizontalVirtualScrolling.reinitState(cellWidth, isForce);
    }
    if (needUpdateVertical || needUpdateHorizontal) {
      var _this$options$updateG, _this$options2;
      null === (_this$options$updateG = (_this$options2 = this.options).updateGrid) || void 0 === _this$options$updateG || _this$options$updateG.call(_this$options2);
    }
  }
};
var VirtualScrollingBase = class {
  constructor(options2) {
    this.options = options2;
    this._state = this.defaultState;
    this.viewportSize = this.options.viewportSize;
    this._itemSize = this.options.itemSize;
    this._position = -1;
    this._itemSizeChanged = false;
    this.updateState(0);
  }
  get itemSize() {
    return this._itemSize;
  }
  set itemSize(value2) {
    this._itemSizeChanged = this._itemSize !== value2;
    this._itemSize = value2;
  }
  get state() {
    return this._state;
  }
  set state(value2) {
    this._state = value2;
  }
  get startIndex() {
    return this.state.startIndex;
  }
  get pageSize() {
    return Math.ceil(this.viewportSize / this.itemSize);
  }
  get outlineCount() {
    return isDefined(this.options.outlineCount) ? this.options.outlineCount : Math.floor(this.pageSize / 2);
  }
  get groupCount() {
    return this.options.getGroupCount();
  }
  get isVerticalGrouping() {
    return this.options.isVerticalGrouping();
  }
  get defaultState() {
    return {
      prevPosition: 0,
      startIndex: -1,
      itemCount: 0,
      virtualItemCountBefore: 0,
      virtualItemCountAfter: 0,
      outlineCountBefore: 0,
      outlineCountAfter: 0,
      virtualItemSizeBefore: 0,
      virtualItemSizeAfter: 0,
      outlineSizeBefore: 0,
      outlineSizeAfter: 0
    };
  }
  get maxScrollPosition() {
    return this.getTotalItemCount() * this.itemSize - this.viewportSize;
  }
  get position() {
    return this._position;
  }
  set position(value2) {
    this._position = value2;
  }
  needUpdateState(position3) {
    const {
      prevPosition,
      startIndex
    } = this.state;
    const isFirstInitialization = startIndex < 0;
    if (isFirstInitialization) {
      return true;
    }
    let isStartIndexChanged = false;
    if (this._validateAndSavePosition(position3)) {
      if (0 === position3 || position3 === this.maxScrollPosition) {
        return true;
      }
      const currentPosition = prevPosition;
      const currentItemsCount = Math.floor(currentPosition / this.itemSize);
      const itemsCount = Math.floor(position3 / this.itemSize);
      isStartIndexChanged = Math.abs(currentItemsCount - itemsCount) >= this.outlineCount;
    }
    return isStartIndexChanged;
  }
  _validateAndSavePosition(position3) {
    if (!isDefined(position3)) {
      return false;
    }
    const result2 = this.position !== position3;
    this.position = position3;
    return result2;
  }
  _correctPosition(position3) {
    return position3 >= 0 ? Math.min(position3, this.maxScrollPosition) : -1;
  }
  updateState(position3, isForce) {
    position3 = this._correctPosition(position3);
    if (!this.needUpdateState(position3) && !isForce) {
      return false;
    }
    const itemsInfoBefore = this._calcItemInfoBefore(position3);
    const itemsDeltaBefore = this._calcItemDeltaBefore(itemsInfoBefore);
    const {
      outlineCountAfter,
      virtualItemCountAfter,
      itemCountWithAfter
    } = this._calcItemInfoAfter(itemsDeltaBefore);
    const {
      virtualItemCountBefore,
      outlineCountBefore
    } = itemsInfoBefore;
    const itemCount = outlineCountBefore + itemCountWithAfter + outlineCountAfter;
    const itemCountBefore = Math.floor(position3 / this.itemSize);
    this.state.prevPosition = itemCountBefore * this.itemSize;
    this.state.startIndex = itemCountBefore - outlineCountBefore;
    this.state.virtualItemCountBefore = virtualItemCountBefore;
    this.state.outlineCountBefore = outlineCountBefore;
    this.state.itemCount = itemCount;
    this.state.outlineCountAfter = outlineCountAfter;
    this.state.virtualItemCountAfter = virtualItemCountAfter;
    this._updateStateCore();
    return true;
  }
  reinitState(itemSize, isForceUpdate) {
    const {
      position: position3
    } = this;
    this.itemSize = itemSize;
    this.updateState(0, isForceUpdate);
    if (position3 > 0) {
      this.updateState(position3, isForceUpdate);
    }
  }
  _calcItemInfoBefore(position3) {
    let virtualItemCountBefore = Math.floor(position3 / this.itemSize);
    const outlineCountBefore = Math.min(virtualItemCountBefore, this.outlineCount);
    virtualItemCountBefore -= outlineCountBefore;
    return {
      virtualItemCountBefore,
      outlineCountBefore
    };
  }
  _calcItemDeltaBefore(itemInfoBefore) {
    const {
      virtualItemCountBefore,
      outlineCountBefore
    } = itemInfoBefore;
    const totalItemCount = this.getTotalItemCount();
    return totalItemCount - virtualItemCountBefore - outlineCountBefore;
  }
  getTotalItemCount() {
    throw "getTotalItemCount method should be implemented";
  }
  getRenderState() {
    throw "getRenderState method should be implemented";
  }
  _calcItemInfoAfter(itemsDeltaBefore) {
    const itemCountWithAfter = itemsDeltaBefore >= this.pageSize ? this.pageSize : itemsDeltaBefore;
    let virtualItemCountAfter = itemsDeltaBefore - itemCountWithAfter;
    const outlineCountAfter = virtualItemCountAfter > 0 ? Math.min(virtualItemCountAfter, this.outlineCount) : 0;
    if (virtualItemCountAfter > 0) {
      virtualItemCountAfter -= outlineCountAfter;
    }
    return {
      virtualItemCountAfter,
      outlineCountAfter,
      itemCountWithAfter
    };
  }
  _updateStateCore() {
    const {
      state
    } = this;
    const {
      virtualItemCountBefore
    } = state;
    const {
      virtualItemCountAfter
    } = state;
    const {
      outlineCountBefore
    } = state;
    const {
      outlineCountAfter
    } = state;
    const prevVirtualItemSizeBefore = state.virtualItemSizeBefore;
    const prevVirtualItemSizeAfter = state.virtualItemSizeAfter;
    const prevOutlineSizeBefore = state.outlineSizeBefore;
    const prevOutlineSizeAfter = state.outlineSizeAfter;
    const virtualItemSizeBefore = this.itemSize * virtualItemCountBefore;
    const virtualItemSizeAfter = this.itemSize * virtualItemCountAfter;
    const outlineSizeBefore = this.itemSize * outlineCountBefore;
    const outlineSizeAfter = this.itemSize * outlineCountAfter;
    const prevVirtualSizeBefore = prevVirtualItemSizeBefore + prevOutlineSizeBefore;
    const virtualSizeBefore = virtualItemSizeBefore + outlineSizeBefore;
    const prevVirtualSizeAfter = prevVirtualItemSizeAfter + prevOutlineSizeAfter;
    const virtualSizeAfter = virtualItemSizeAfter + outlineSizeAfter;
    const isAppend = prevVirtualSizeBefore < virtualSizeBefore;
    const isPrepend = prevVirtualSizeAfter < virtualSizeAfter;
    const needAddItems = this._itemSizeChanged || isAppend || isPrepend;
    if (needAddItems) {
      this._updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter);
    }
  }
  _updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter) {
    const {
      state
    } = this;
    state.virtualItemSizeBefore = virtualItemSizeBefore;
    state.virtualItemSizeAfter = virtualItemSizeAfter;
  }
};
var VerticalVirtualScrolling = class extends VirtualScrollingBase {
  constructor(options2) {
    super(_extends({}, options2, {
      itemSize: options2.rowHeight,
      viewportSize: options2.viewportHeight
    }));
  }
  get prevTopPosition() {
    return this.state.prevPosition;
  }
  get rowCount() {
    return this.state.itemCount;
  }
  get topVirtualRowCount() {
    return this.state.virtualItemCountBefore;
  }
  get bottomVirtualRowCount() {
    return this.state.virtualItemCountAfter;
  }
  getTotalItemCount() {
    return this.options.getTotalRowCount(this.groupCount, this.isVerticalGrouping);
  }
  getRenderState() {
    return {
      topVirtualRowHeight: this.state.virtualItemSizeBefore,
      bottomVirtualRowHeight: this.state.virtualItemSizeAfter,
      startRowIndex: this.state.startIndex,
      rowCount: this.state.itemCount,
      startIndex: this.state.startIndex
    };
  }
};
var HorizontalVirtualScrolling = class extends VirtualScrollingBase {
  constructor(options2) {
    super(_extends({}, options2, {
      itemSize: options2.cellWidth,
      viewportSize: options2.viewportWidth
    }));
  }
  get isRTL() {
    return this.options.isRTL();
  }
  getTotalItemCount() {
    return this.options.getTotalCellCount(this.groupCount, this.isVerticalGrouping);
  }
  getRenderState() {
    return {
      leftVirtualCellWidth: this.state.virtualItemSizeBefore,
      rightVirtualCellWidth: this.state.virtualItemSizeAfter,
      startCellIndex: this.state.startIndex,
      cellCount: this.state.itemCount,
      cellWidth: this.itemSize
    };
  }
  _updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter) {
    if (!this.isRTL) {
      super._updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter);
    } else {
      const {
        state
      } = this;
      state.virtualItemSizeAfter = virtualItemSizeBefore;
      state.virtualItemSizeBefore = virtualItemSizeAfter;
      state.startIndex = this.getTotalItemCount() - this.startIndex - this.state.itemCount;
    }
  }
};
var VirtualScrollingRenderer = class {
  constructor(_workspace) {
    this._workspace = _workspace;
    this._renderAppointmentTimeoutID = null;
  }
  getRenderTimeout() {
    return 15;
  }
  get workspace() {
    return this._workspace;
  }
  updateRender() {
    this._renderGrid();
    this._renderAppointments();
  }
  _renderGrid() {
    this.workspace.renderWorkSpace(false);
  }
  _renderAppointments() {
    const renderTimeout = this.getRenderTimeout();
    if (renderTimeout >= 0) {
      clearTimeout(this._renderAppointmentTimeoutID);
      this._renderAppointmentTimeoutID = setTimeout(() => this.workspace.updateAppointments(), renderTimeout);
    } else {
      this.workspace.updateAppointments();
    }
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/const.js
var WORK_SPACE_BORDER_PX = 1;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_grouped_strategy_horizontal.js
var HorizontalGroupedStrategy = class {
  constructor(_workSpace) {
    this._workSpace = _workSpace;
  }
  prepareCellIndexes(cellCoordinates, groupIndex, inAllDay) {
    const groupByDay = this._workSpace.isGroupedByDate();
    if (!groupByDay) {
      return {
        rowIndex: cellCoordinates.rowIndex,
        columnIndex: cellCoordinates.columnIndex + groupIndex * this._workSpace._getCellCount()
      };
    }
    return {
      rowIndex: cellCoordinates.rowIndex,
      columnIndex: cellCoordinates.columnIndex * this._workSpace._getGroupCount() + groupIndex
    };
  }
  getGroupIndex(rowIndex, columnIndex) {
    const groupByDay = this._workSpace.isGroupedByDate();
    const groupCount = this._workSpace._getGroupCount();
    if (groupByDay) {
      return columnIndex % groupCount;
    }
    return Math.floor(columnIndex / this._workSpace._getCellCount());
  }
  calculateHeaderCellRepeatCount() {
    return this._workSpace._getGroupCount() || 1;
  }
  insertAllDayRowsIntoDateTable() {
    return false;
  }
  getTotalCellCount(groupCount) {
    groupCount = groupCount || 1;
    return this._workSpace._getCellCount() * groupCount;
  }
  getTotalRowCount() {
    return this._workSpace._getRowCount();
  }
  calculateTimeCellRepeatCount() {
    return 1;
  }
  getWorkSpaceMinWidth() {
    const workSpaceElementWidth = getBoundingRect(this._workSpace.$element().get(0)).width;
    return workSpaceElementWidth - this._workSpace.getTimePanelWidth() - 2 * WORK_SPACE_BORDER_PX;
  }
  getAllDayOffset() {
    return this._workSpace.getAllDayHeight();
  }
  getGroupCountClass(groups) {
    return;
  }
  getLeftOffset() {
    return this._workSpace.getTimePanelWidth();
  }
  _createGroupBoundOffset(startCell, endCell, cellWidth) {
    const extraOffset = cellWidth / 2;
    const startOffset = startCell ? startCell.offset().left - extraOffset : 0;
    const endOffset = endCell ? endCell.offset().left + cellWidth + extraOffset : 0;
    return {
      left: startOffset,
      right: endOffset,
      top: 0,
      bottom: 0
    };
  }
  _getGroupedByDateBoundOffset($cells, cellWidth) {
    const lastCellIndex = $cells.length - 1;
    const startCell = $cells.eq(0);
    const endCell = $cells.eq(lastCellIndex);
    return this._createGroupBoundOffset(startCell, endCell, cellWidth);
  }
  getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap) {
    if (this._workSpace.isGroupedByDate()) {
      return this._getGroupedByDateBoundOffset($cells, cellWidth);
    }
    let startCell;
    let endCell;
    const cellIndex = this._workSpace.getCellIndexByCoordinates(coordinates);
    const groupIndex = coordinates.groupIndex || Math.floor(cellIndex / cellCount);
    const currentCellGroup = groupedDataMap.dateTableGroupedMap[groupIndex];
    if (currentCellGroup) {
      const groupRowLength = currentCellGroup[0].length;
      const groupStartPosition = currentCellGroup[0][0].position;
      const groupEndPosition = currentCellGroup[0][groupRowLength - 1].position;
      startCell = $cells.eq(groupStartPosition.columnIndex);
      endCell = $cells.eq(groupEndPosition.columnIndex);
    }
    return this._createGroupBoundOffset(startCell, endCell, cellWidth);
  }
  shiftIndicator($indicator, height, rtlOffset, groupIndex) {
    const offset2 = this._getIndicatorOffset(groupIndex);
    const horizontalOffset = rtlOffset ? rtlOffset - offset2 : offset2;
    $indicator.css("left", horizontalOffset);
    $indicator.css("top", height);
  }
  _getIndicatorOffset(groupIndex) {
    const groupByDay = this._workSpace.isGroupedByDate();
    return groupByDay ? this._calculateGroupByDateOffset(groupIndex) : this._calculateOffset(groupIndex);
  }
  _calculateOffset(groupIndex) {
    const indicatorStartPosition = this._workSpace.getIndicatorOffset(groupIndex);
    const offset2 = this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex;
    return indicatorStartPosition + offset2;
  }
  _calculateGroupByDateOffset(groupIndex) {
    return this._workSpace.getIndicatorOffset(0) * this._workSpace._getGroupCount() + this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex;
  }
  getShaderOffset(i, width) {
    const offset2 = this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(i - 1) * i;
    return this._workSpace.option("rtlEnabled") ? getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).width - offset2 - this._workSpace.getTimePanelWidth() - width : offset2;
  }
  getShaderTopOffset(i) {
    return -this.getShaderMaxHeight() * (i > 0 ? 1 : 0);
  }
  getShaderHeight() {
    const height = this._workSpace.getIndicationHeight();
    return height;
  }
  getShaderMaxHeight() {
    return getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).height;
  }
  getShaderWidth(i) {
    return this._workSpace.getIndicationWidth(i);
  }
  getScrollableScrollTop(allDay) {
    return !allDay ? this._workSpace.getScrollable().scrollTop() : 0;
  }
  addAdditionalGroupCellClasses(cellClass, index2, i, j) {
    let applyUnconditionally = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    cellClass = this._addLastGroupCellClass(cellClass, index2, applyUnconditionally);
    return this._addFirstGroupCellClass(cellClass, index2, applyUnconditionally);
  }
  _addLastGroupCellClass(cellClass, index2, applyUnconditionally) {
    if (applyUnconditionally) {
      return `${cellClass} ${LAST_GROUP_CELL_CLASS}`;
    }
    const groupByDate = this._workSpace.isGroupedByDate();
    if (groupByDate) {
      if (index2 % this._workSpace._getGroupCount() === 0) {
        return `${cellClass} ${LAST_GROUP_CELL_CLASS}`;
      }
    } else if (index2 % this._workSpace._getCellCount() === 0) {
      return `${cellClass} ${LAST_GROUP_CELL_CLASS}`;
    }
    return cellClass;
  }
  _addFirstGroupCellClass(cellClass, index2, applyUnconditionally) {
    if (applyUnconditionally) {
      return `${cellClass} ${FIRST_GROUP_CELL_CLASS}`;
    }
    const groupByDate = this._workSpace.isGroupedByDate();
    if (groupByDate) {
      if ((index2 - 1) % this._workSpace._getGroupCount() === 0) {
        return `${cellClass} ${FIRST_GROUP_CELL_CLASS}`;
      }
    } else if ((index2 - 1) % this._workSpace._getCellCount() === 0) {
      return `${cellClass} ${FIRST_GROUP_CELL_CLASS}`;
    }
    return cellClass;
  }
};
var m_work_space_grouped_strategy_horizontal_default = HorizontalGroupedStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_grouped_strategy_vertical.js
var VerticalGroupedStrategy = class {
  constructor(_workSpace) {
    this._workSpace = _workSpace;
    this.cache = new Cache2();
  }
  prepareCellIndexes(cellCoordinates, groupIndex, inAllDayRow) {
    let rowIndex = cellCoordinates.rowIndex + groupIndex * this._workSpace._getRowCount();
    if (this._workSpace.supportAllDayRow() && this._workSpace.option("showAllDayPanel")) {
      rowIndex += groupIndex;
      if (!inAllDayRow) {
        rowIndex += 1;
      }
    }
    return {
      rowIndex,
      columnIndex: cellCoordinates.columnIndex
    };
  }
  getGroupIndex(rowIndex) {
    return Math.floor(rowIndex / this._workSpace._getRowCount());
  }
  calculateHeaderCellRepeatCount() {
    return 1;
  }
  insertAllDayRowsIntoDateTable() {
    return this._workSpace.option("showAllDayPanel");
  }
  getTotalCellCount() {
    return this._workSpace._getCellCount();
  }
  getTotalRowCount() {
    return this._workSpace._getRowCount() * this._workSpace._getGroupCount();
  }
  calculateTimeCellRepeatCount() {
    return this._workSpace._getGroupCount() || 1;
  }
  getWorkSpaceMinWidth() {
    let minWidth = this._workSpace._getWorkSpaceWidth();
    const workSpaceElementWidth = getBoundingRect(this._workSpace.$element().get(0)).width;
    const workspaceContainerWidth = workSpaceElementWidth - this._workSpace.getTimePanelWidth() - this._workSpace.getGroupTableWidth() - 2 * WORK_SPACE_BORDER_PX;
    if (minWidth < workspaceContainerWidth) {
      minWidth = workspaceContainerWidth;
    }
    return minWidth;
  }
  getAllDayOffset() {
    return 0;
  }
  getGroupCountClass(groups) {
    return getVerticalGroupCountClass(groups);
  }
  getLeftOffset() {
    return this._workSpace.getTimePanelWidth() + this._workSpace.getGroupTableWidth();
  }
  getGroupBoundsOffset(groupIndex, _ref) {
    let [$firstCell, $lastCell] = _ref;
    return this.cache.get(`groupBoundsOffset${groupIndex}`, () => {
      const startDayHour = this._workSpace.option("startDayHour");
      const endDayHour = this._workSpace.option("endDayHour");
      const hoursInterval = this._workSpace.option("hoursInterval");
      const dayHeight = calculateDayDuration(startDayHour, endDayHour) / hoursInterval * this._workSpace.getCellHeight();
      const scrollTop = this.getScrollableScrollTop();
      const headerRowHeight = getBoundingRect(this._workSpace._$headerPanelContainer.get(0)).height;
      let topOffset = groupIndex * dayHeight + headerRowHeight + this._workSpace.option("getHeaderHeight")() - scrollTop;
      if (this._workSpace.option("showAllDayPanel") && this._workSpace.supportAllDayRow()) {
        topOffset += this._workSpace.getCellHeight() * (groupIndex + 1);
      }
      const bottomOffset = topOffset + dayHeight;
      const {
        left
      } = $firstCell.getBoundingClientRect();
      const {
        right
      } = $lastCell.getBoundingClientRect();
      this._groupBoundsOffset = {
        left,
        right,
        top: topOffset,
        bottom: bottomOffset
      };
      return this._groupBoundsOffset;
    });
  }
  shiftIndicator($indicator, height, rtlOffset, i) {
    const offset2 = this._workSpace.getIndicatorOffset(0);
    const tableOffset = this._workSpace.option("crossScrollingEnabled") ? 0 : this._workSpace.getGroupTableWidth();
    const horizontalOffset = rtlOffset ? rtlOffset - offset2 : offset2;
    let verticalOffset = this._workSpace._getRowCount() * this._workSpace.getCellHeight() * i;
    if (this._workSpace.supportAllDayRow() && this._workSpace.option("showAllDayPanel")) {
      verticalOffset += this._workSpace.getAllDayHeight() * (i + 1);
    }
    $indicator.css("left", horizontalOffset + tableOffset);
    $indicator.css("top", height + verticalOffset);
  }
  getShaderOffset(i, width) {
    const offset2 = this._workSpace.option("crossScrollingEnabled") ? 0 : this._workSpace.getGroupTableWidth();
    return this._workSpace.option("rtlEnabled") ? getBoundingRect(this._$container.get(0)).width - offset2 - this._workSpace.getWorkSpaceLeftOffset() - width : offset2;
  }
  getShaderTopOffset(i) {
    return 0;
  }
  getShaderHeight() {
    let height = this._workSpace.getIndicationHeight();
    if (this._workSpace.supportAllDayRow() && this._workSpace.option("showAllDayPanel")) {
      height += this._workSpace.getCellHeight();
    }
    return height;
  }
  getShaderMaxHeight() {
    let height = this._workSpace._getRowCount() * this._workSpace.getCellHeight();
    if (this._workSpace.supportAllDayRow() && this._workSpace.option("showAllDayPanel")) {
      height += this._workSpace.getCellHeight();
    }
    return height;
  }
  getShaderWidth() {
    return this._workSpace.getIndicationWidth(0);
  }
  getScrollableScrollTop() {
    return this._workSpace.getScrollable().scrollTop();
  }
  addAdditionalGroupCellClasses(cellClass, index2, i, j) {
    cellClass = this._addLastGroupCellClass(cellClass, i + 1);
    return this._addFirstGroupCellClass(cellClass, i + 1);
  }
  _addLastGroupCellClass(cellClass, index2) {
    if (index2 % this._workSpace._getRowCount() === 0) {
      return `${cellClass} ${LAST_GROUP_CELL_CLASS}`;
    }
    return cellClass;
  }
  _addFirstGroupCellClass(cellClass, index2) {
    if ((index2 - 1) % this._workSpace._getRowCount() === 0) {
      return `${cellClass} ${FIRST_GROUP_CELL_CLASS}`;
    }
    return cellClass;
  }
};
var m_work_space_grouped_strategy_vertical_default = VerticalGroupedStrategy;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_date_header_data_generator.js
var _excluded20 = ["startDate", "endDate", "isFirstGroupCell", "isLastGroupCell"];
var DateHeaderDataGenerator = class {
  constructor(_viewDataGenerator) {
    this._viewDataGenerator = _viewDataGenerator;
  }
  getCompleteDateHeaderMap(options2, completeViewDataMap) {
    const {
      isGenerateWeekDaysHeaderData
    } = options2;
    const result2 = [];
    if (isGenerateWeekDaysHeaderData) {
      const weekDaysRow = this._generateWeekDaysHeaderRowMap(options2, completeViewDataMap);
      result2.push(weekDaysRow);
    }
    const dateRow = this._generateHeaderDateRow(options2, completeViewDataMap);
    result2.push(dateRow);
    return result2;
  }
  _generateWeekDaysHeaderRowMap(options2, completeViewDataMap) {
    const {
      isGroupedByDate,
      groups,
      groupOrientation,
      startDayHour,
      endDayHour,
      hoursInterval,
      isHorizontalGrouping,
      intervalCount,
      viewOffset
    } = options2;
    const cellCountInDay = this._viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
    const horizontalGroupCount = getHorizontalGroupCount(groups, groupOrientation);
    const index2 = completeViewDataMap[0][0].allDay ? 1 : 0;
    const colSpan = isGroupedByDate ? horizontalGroupCount * cellCountInDay : cellCountInDay;
    const groupCount = getGroupCount(groups);
    const datesRepeatCount = isHorizontalGrouping && !isGroupedByDate ? groupCount : 1;
    const daysInGroup = this._viewDataGenerator.daysInInterval * intervalCount;
    const daysInView = daysInGroup * datesRepeatCount;
    const weekDaysRow = [];
    for (let dayIndex = 0; dayIndex < daysInView; dayIndex += 1) {
      const cell = completeViewDataMap[index2][dayIndex * colSpan];
      const shiftedStartDate = m_utils_time_zone_default.addOffsetsWithoutDST(cell.startDate, -viewOffset);
      weekDaysRow.push(_extends({}, cell, {
        colSpan,
        text: formatWeekdayAndDay(shiftedStartDate),
        isFirstGroupCell: false,
        isLastGroupCell: false
      }));
    }
    return weekDaysRow;
  }
  _generateHeaderDateRow(options2, completeViewDataMap) {
    const {
      today,
      isGroupedByDate,
      groupOrientation,
      groups,
      headerCellTextFormat,
      getDateForHeaderText: getDateForHeaderText2,
      interval,
      startViewDate,
      startDayHour,
      endDayHour,
      hoursInterval,
      intervalCount,
      currentDate,
      viewType,
      viewOffset
    } = options2;
    const horizontalGroupCount = getHorizontalGroupCount(groups, groupOrientation);
    const index2 = completeViewDataMap[0][0].allDay ? 1 : 0;
    const colSpan = isGroupedByDate ? horizontalGroupCount : 1;
    const isVerticalGrouping = "vertical" === groupOrientation;
    const cellCountInGroupRow = this._viewDataGenerator.getCellCount({
      intervalCount,
      currentDate,
      viewType,
      hoursInterval,
      startDayHour,
      endDayHour
    });
    const cellCountInDay = this._viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
    const slicedByColumnsData = isGroupedByDate ? completeViewDataMap[index2].filter((_, columnIndex) => columnIndex % horizontalGroupCount === 0) : completeViewDataMap[index2];
    const shouldShiftDatesForHeaderText = !isTimelineView(viewType) || viewType === VIEWS.TIMELINE_MONTH;
    return slicedByColumnsData.map((_ref, idx) => {
      let {
        startDate,
        isFirstGroupCell,
        isLastGroupCell
      } = _ref, restProps = _objectWithoutPropertiesLoose(_ref, _excluded20);
      const shiftedStartDate = m_utils_time_zone_default.addOffsetsWithoutDST(startDate, -viewOffset);
      const shiftedStartDateForHeaderText = shouldShiftDatesForHeaderText ? shiftedStartDate : startDate;
      const text = getHeaderCellText(idx % cellCountInGroupRow, shiftedStartDateForHeaderText, headerCellTextFormat, getDateForHeaderText2, {
        interval,
        startViewDate,
        startDayHour,
        cellCountInDay,
        viewOffset
      });
      return _extends({}, restProps, {
        startDate,
        text,
        today: date_default.sameDate(shiftedStartDate, today),
        colSpan,
        isFirstGroupCell: isGroupedByDate || isFirstGroupCell && !isVerticalGrouping,
        isLastGroupCell: isGroupedByDate || isLastGroupCell && !isVerticalGrouping
      });
    });
  }
  generateDateHeaderData(completeDateHeaderMap, completeViewDataMap, options2) {
    const {
      isGenerateWeekDaysHeaderData,
      cellWidth,
      isProvideVirtualCellsWidth,
      startDayHour,
      endDayHour,
      hoursInterval,
      isMonthDateHeader
    } = options2;
    const dataMap2 = [];
    let weekDayRowConfig = {};
    const validCellWidth = cellWidth || 0;
    if (isGenerateWeekDaysHeaderData) {
      weekDayRowConfig = this._generateDateHeaderDataRow(options2, completeDateHeaderMap, completeViewDataMap, this._viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval), 0, validCellWidth);
      dataMap2.push(weekDayRowConfig.dateRow);
    }
    const datesRowConfig = this._generateDateHeaderDataRow(options2, completeDateHeaderMap, completeViewDataMap, 1, isGenerateWeekDaysHeaderData ? 1 : 0, validCellWidth);
    dataMap2.push(datesRowConfig.dateRow);
    return {
      dataMap: dataMap2,
      leftVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.leftVirtualCellWidth : void 0,
      rightVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.rightVirtualCellWidth : void 0,
      leftVirtualCellCount: datesRowConfig.leftVirtualCellCount,
      rightVirtualCellCount: datesRowConfig.rightVirtualCellCount,
      weekDayLeftVirtualCellWidth: weekDayRowConfig.leftVirtualCellWidth,
      weekDayRightVirtualCellWidth: weekDayRowConfig.rightVirtualCellWidth,
      weekDayLeftVirtualCellCount: weekDayRowConfig.leftVirtualCellCount,
      weekDayRightVirtualCellCount: weekDayRowConfig.rightVirtualCellCount,
      isMonthDateHeader
    };
  }
  _generateDateHeaderDataRow(options2, completeDateHeaderMap, completeViewDataMap, baseColSpan, rowIndex, cellWidth) {
    const {
      startCellIndex,
      cellCount,
      isProvideVirtualCellsWidth,
      groups,
      groupOrientation,
      isGroupedByDate
    } = options2;
    const horizontalGroupCount = getHorizontalGroupCount(groups, groupOrientation);
    const colSpan = isGroupedByDate ? horizontalGroupCount * baseColSpan : baseColSpan;
    const leftVirtualCellCount = Math.floor(startCellIndex / colSpan);
    const displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);
    const actualCellCount = Math.ceil((startCellIndex + displayedCellCount) / colSpan);
    const totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);
    const dateRow = completeDateHeaderMap[rowIndex].slice(leftVirtualCellCount, actualCellCount);
    const finalLeftVirtualCellCount = leftVirtualCellCount * colSpan;
    const finalLeftVirtualCellWidth = finalLeftVirtualCellCount * cellWidth;
    const finalRightVirtualCellCount = totalCellCount - actualCellCount * colSpan;
    const finalRightVirtualCellWidth = finalRightVirtualCellCount * cellWidth;
    return {
      dateRow,
      leftVirtualCellCount: finalLeftVirtualCellCount,
      leftVirtualCellWidth: isProvideVirtualCellsWidth ? finalLeftVirtualCellWidth : void 0,
      rightVirtualCellCount: finalRightVirtualCellCount,
      rightVirtualCellWidth: isProvideVirtualCellsWidth ? finalRightVirtualCellWidth : void 0
    };
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_grouped_data_map_provider.js
var toMs17 = date_default.dateToMilliseconds;
var GroupedDataMapProvider = class {
  constructor(viewDataGenerator, viewDataMap, completeViewDataMap, viewOptions) {
    this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);
    this.completeViewDataMap = completeViewDataMap;
    this._viewOptions = viewOptions;
  }
  getGroupStartDate(groupIndex) {
    var _firstRow$;
    const firstRow = this.getFirstGroupRow(groupIndex);
    return (null === firstRow || void 0 === firstRow || null === (_firstRow$ = firstRow[0]) || void 0 === _firstRow$ || null === (_firstRow$ = _firstRow$.cellData) || void 0 === _firstRow$ ? void 0 : _firstRow$.startDate) ?? null;
  }
  getGroupEndDate(groupIndex) {
    const lastRow = this.getLastGroupRow(groupIndex);
    if (lastRow) {
      const lastColumnIndex = lastRow.length - 1;
      const {
        cellData
      } = lastRow[lastColumnIndex];
      const {
        endDate
      } = cellData;
      return endDate;
    }
  }
  findGroupCellStartDate(groupIndex, startDate, endDate, isFindByDate) {
    const groupData = this.getGroupFromDateTableGroupMap(groupIndex);
    const checkCellStartDate = (rowIndex, columnIndex) => {
      const {
        cellData
      } = groupData[rowIndex][columnIndex];
      let {
        startDate: secondMin,
        endDate: secondMax
      } = cellData;
      if (isFindByDate) {
        secondMin = date_default.trimTime(secondMin);
        secondMax = date_default.setToDayEnd(secondMin);
      }
      if (date_default.intervalsOverlap({
        firstMin: startDate,
        firstMax: endDate,
        secondMin,
        secondMax
      })) {
        return secondMin;
      }
    };
    const startDateVerticalSearch = (() => {
      const cellCount = groupData[0].length;
      for (let columnIndex = 0; columnIndex < cellCount; ++columnIndex) {
        for (let rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {
          const result2 = checkCellStartDate(rowIndex, columnIndex);
          if (result2) {
            return result2;
          }
        }
      }
    })();
    const startDateHorizontalSearch = (() => {
      for (let rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {
        const row = groupData[rowIndex];
        for (let columnIndex = 0; columnIndex < row.length; ++columnIndex) {
          const result2 = checkCellStartDate(rowIndex, columnIndex);
          if (result2) {
            return result2;
          }
        }
      }
    })();
    return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch;
  }
  findAllDayGroupCellStartDate(groupIndex) {
    var _groupedData$;
    const groupedData = this.getGroupFromDateTableGroupMap(groupIndex);
    const cellData = null === groupedData || void 0 === groupedData || null === (_groupedData$ = groupedData[0]) || void 0 === _groupedData$ || null === (_groupedData$ = _groupedData$[0]) || void 0 === _groupedData$ ? void 0 : _groupedData$.cellData;
    return (null === cellData || void 0 === cellData ? void 0 : cellData.startDate) ?? null;
  }
  findCellPositionInMap(cellInfo, isAppointmentRender) {
    const {
      groupIndex,
      startDate,
      isAllDay,
      index: index2
    } = cellInfo;
    const {
      allDayPanelGroupedMap,
      dateTableGroupedMap
    } = this.groupedDataMap;
    const {
      viewOffset
    } = this._viewOptions;
    const rows = isAllDay && !this._viewOptions.isVerticalGrouping ? allDayPanelGroupedMap[groupIndex] ? [allDayPanelGroupedMap[groupIndex]] : [] : dateTableGroupedMap[groupIndex] || [];
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex += 1) {
      const row = rows[rowIndex];
      for (let columnIndex = 0; columnIndex < row.length; columnIndex += 1) {
        const cell = row[columnIndex];
        const originCellData = cell.cellData;
        const cellData = isAppointmentRender ? _extends({}, originCellData, {
          startDate: dateUtilsTs.addOffsets(cell.cellData.startDate, [-viewOffset]),
          endDate: dateUtilsTs.addOffsets(cell.cellData.endDate, [-viewOffset])
        }) : originCellData;
        if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index2)) {
          if (this.isStartDateInCell(startDate, isAllDay, cellData, originCellData)) {
            return cell.position;
          }
        }
      }
    }
    return;
  }
  isStartDateInCell(startDate, inAllDayRow, _ref, _ref2) {
    let {
      startDate: cellStartDate,
      endDate: cellEndDate,
      allDay: cellAllDay
    } = _ref;
    let {
      startDate: originCellStartDate,
      endDate: originCellEndDate
    } = _ref2;
    const {
      viewType
    } = this._viewOptions;
    const cellSecondIntervalOffset = this.getCellSecondIntervalOffset(originCellStartDate, originCellEndDate);
    const isCellCoversTwoIntervals = 0 !== cellSecondIntervalOffset;
    switch (true) {
      case !isDateAndTimeView(viewType):
      case (inAllDayRow && cellAllDay):
        return date_default.sameDate(startDate, cellStartDate);
      case (!inAllDayRow && !isCellCoversTwoIntervals):
        return startDate >= cellStartDate && startDate < cellEndDate;
      case (!inAllDayRow && isCellCoversTwoIntervals):
        return this.isStartDateInTwoIntervalsCell(startDate, cellSecondIntervalOffset, cellStartDate, cellEndDate);
      default:
        return false;
    }
  }
  getCellSecondIntervalOffset(cellStartDate, cellEndDate) {
    const nextHourCellStartDate = dateUtilsTs.addOffsets(cellStartDate, [toMs17("hour")]);
    const cellTimezoneDiff = m_utils_time_zone_default.getDaylightOffset(cellStartDate, cellEndDate);
    const cellNextHourTimezoneDiff = m_utils_time_zone_default.getDaylightOffset(cellStartDate, nextHourCellStartDate);
    const isDSTInsideCell = 0 !== cellTimezoneDiff;
    const isWinterTimezoneNextHour = cellNextHourTimezoneDiff < 0;
    return !isDSTInsideCell && isWinterTimezoneNextHour ? Math.abs(cellNextHourTimezoneDiff * toMs17("minute")) : 0;
  }
  isStartDateInTwoIntervalsCell(startDate, secondIntervalOffset, cellStartDate, cellEndDate) {
    const nextIntervalCellStartDate = dateUtilsTs.addOffsets(cellStartDate, [secondIntervalOffset]);
    const nextIntervalCellEndDate = dateUtilsTs.addOffsets(cellEndDate, [secondIntervalOffset]);
    const isInOriginInterval = startDate >= cellStartDate && startDate < cellEndDate;
    const isInSecondInterval = startDate >= nextIntervalCellStartDate && startDate < nextIntervalCellEndDate;
    return isInOriginInterval || isInSecondInterval;
  }
  _isSameGroupIndexAndIndex(cellData, groupIndex, index2) {
    return cellData.groupIndex === groupIndex && (void 0 === index2 || cellData.index === index2);
  }
  getCellsGroup(groupIndex) {
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    const groupData = dateTableGroupedMap[groupIndex];
    if (groupData) {
      const {
        cellData
      } = groupData[0][0];
      return cellData.groups;
    }
  }
  getCompletedGroupsInfo() {
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    return dateTableGroupedMap.map((groupData) => {
      const firstCell = groupData[0][0];
      const {
        allDay,
        groupIndex
      } = firstCell.cellData;
      return {
        allDay,
        groupIndex,
        startDate: this.getGroupStartDate(groupIndex),
        endDate: this.getGroupEndDate(groupIndex)
      };
    }).filter((_ref3) => {
      let {
        startDate
      } = _ref3;
      return !!startDate;
    });
  }
  getGroupIndices() {
    return this.getCompletedGroupsInfo().map((_ref4) => {
      let {
        groupIndex
      } = _ref4;
      return groupIndex;
    });
  }
  getGroupFromDateTableGroupMap(groupIndex) {
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    return dateTableGroupedMap[groupIndex];
  }
  getFirstGroupRow(groupIndex) {
    const groupedData = this.getGroupFromDateTableGroupMap(groupIndex);
    if (groupedData) {
      const {
        cellData
      } = groupedData[0][0];
      return !cellData.allDay ? groupedData[0] : groupedData[1];
    }
  }
  getLastGroupRow(groupIndex) {
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    const groupedData = dateTableGroupedMap[groupIndex];
    if (groupedData) {
      const lastRowIndex = groupedData.length - 1;
      return groupedData[lastRowIndex];
    }
  }
  getLastGroupCellPosition(groupIndex) {
    const groupRow = this.getLastGroupRow(groupIndex);
    return null === groupRow || void 0 === groupRow ? void 0 : groupRow[(null === groupRow || void 0 === groupRow ? void 0 : groupRow.length) - 1].position;
  }
  getRowCountInGroup(groupIndex) {
    const groupRow = this.getLastGroupRow(groupIndex);
    const cellAmount = groupRow.length;
    const lastCellData = groupRow[cellAmount - 1].cellData;
    const lastCellIndex = lastCellData.index;
    return (lastCellIndex + 1) / groupRow.length;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/core/utils/math.js
var shiftIntegerByModule = (integerValue, moduleValue) => {
  if (!Number.isInteger(integerValue)) {
    throw Error(`Passed integer value ${integerValue} is not an integer.`);
  }
  if (!Number.isInteger(moduleValue)) {
    throw Error(`Passed module value ${moduleValue} is not an integer.`);
  }
  if (moduleValue <= 0) {
    throw Error(`Passed module value ${moduleValue} must be > 0.`);
  }
  const normalizedInteger = integerValue % moduleValue;
  switch (true) {
    case 0 === normalizedInteger:
      return 0;
    case normalizedInteger > 0:
      return normalizedInteger;
    case normalizedInteger < 0:
      return moduleValue + normalizedInteger;
    default:
      throw Error(`Unexpected division (${integerValue} % ${moduleValue}) occurred.`);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_time_panel_data_generator.js
var _excluded21 = ["allDay", "startDate", "endDate", "groups", "groupIndex", "isFirstGroupCell", "isLastGroupCell", "index"];
var toMs18 = date_default.dateToMilliseconds;
var TimePanelDataGenerator = class {
  constructor(_viewDataGenerator) {
    this._viewDataGenerator = _viewDataGenerator;
  }
  getCompleteTimePanelMap(options2, completeViewDataMap) {
    const {
      startViewDate,
      cellDuration,
      startDayHour,
      isVerticalGrouping,
      intervalCount,
      currentDate,
      viewType,
      hoursInterval,
      endDayHour,
      viewOffset,
      today,
      showCurrentTimeIndicator
    } = options2;
    const rowsCount = completeViewDataMap.length - 1;
    const realEndViewDate = completeViewDataMap[rowsCount][completeViewDataMap[rowsCount].length - 1].endDate;
    const rowCountInGroup = this._viewDataGenerator.getRowCount({
      intervalCount,
      currentDate,
      viewType,
      hoursInterval,
      startDayHour,
      endDayHour
    });
    const cellCountInGroupRow = this._viewDataGenerator.getCellCount({
      intervalCount,
      currentDate,
      viewType,
      hoursInterval,
      startDayHour,
      endDayHour
    });
    let allDayRowsCount = 0;
    let usualCellIndex = 0;
    return completeViewDataMap.map((row, index2) => {
      const _row$ = row[0], {
        allDay,
        startDate,
        groups,
        groupIndex,
        isFirstGroupCell,
        isLastGroupCell,
        index: cellIndex
      } = _row$, restCellProps = _objectWithoutPropertiesLoose(_row$, _excluded21);
      const highlighted = allDay ? false : this.isTimeCellShouldBeHighlighted(today, viewOffset, {
        startViewDate,
        realEndViewDate,
        showCurrentTimeIndicator
      }, {
        date: startDate,
        index: usualCellIndex,
        duration: Math.round(cellDuration),
        isFirst: 0 === usualCellIndex,
        isLast: this.isLastCellInGroup(completeViewDataMap, index2)
      });
      if (allDay) {
        allDayRowsCount += 1;
        usualCellIndex = 0;
      } else {
        usualCellIndex += 1;
      }
      const timeIndex = (index2 - allDayRowsCount) % rowCountInGroup;
      return _extends({}, restCellProps, {
        startDate,
        allDay,
        highlighted,
        text: weekUtils.getTimePanelCellText(timeIndex, startDate, startViewDate, cellDuration, startDayHour, viewOffset),
        groups: isVerticalGrouping ? groups : void 0,
        groupIndex: isVerticalGrouping ? groupIndex : void 0,
        isFirstGroupCell: isVerticalGrouping && isFirstGroupCell,
        isLastGroupCell: isVerticalGrouping && isLastGroupCell,
        index: Math.floor(cellIndex / cellCountInGroupRow)
      });
    });
  }
  generateTimePanelData(completeTimePanelMap, options2) {
    const {
      startRowIndex,
      rowCount,
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      isGroupedAllDayPanel,
      isVerticalGrouping,
      isAllDayPanelVisible
    } = options2;
    const indexDifference = isVerticalGrouping || !isAllDayPanelVisible ? 0 : 1;
    const correctedStartRowIndex = startRowIndex + indexDifference;
    const displayedRowCount = getDisplayedRowCount(rowCount, completeTimePanelMap);
    const timePanelMap = completeTimePanelMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount);
    const timePanelData = {
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      isGroupedAllDayPanel
    };
    const {
      previousGroupedData: groupedData
    } = this._generateTimePanelDataFromMap(timePanelMap, isVerticalGrouping);
    timePanelData.groupedData = groupedData;
    return timePanelData;
  }
  _generateTimePanelDataFromMap(timePanelMap, isVerticalGrouping) {
    return timePanelMap.reduce((_ref, cellData) => {
      let {
        previousGroupIndex,
        previousGroupedData
      } = _ref;
      const currentGroupIndex = cellData.groupIndex;
      if (currentGroupIndex !== previousGroupIndex) {
        previousGroupedData.push({
          dateTable: [],
          isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!cellData.allDay, isVerticalGrouping),
          groupIndex: currentGroupIndex,
          key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)
        });
      }
      if (cellData.allDay) {
        previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellData;
      } else {
        previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellData);
      }
      return {
        previousGroupIndex: currentGroupIndex,
        previousGroupedData
      };
    }, {
      previousGroupIndex: -1,
      previousGroupedData: []
    });
  }
  isTimeCellShouldBeHighlighted(today, viewOffset, _ref2, cellData) {
    let {
      startViewDate,
      realEndViewDate,
      showCurrentTimeIndicator
    } = _ref2;
    const realToday = dateUtilsTs.addOffsets(today, [viewOffset]);
    const realStartViewDate = dateUtilsTs.addOffsets(startViewDate, [viewOffset]);
    if (!showCurrentTimeIndicator || realToday < realStartViewDate || realToday >= realEndViewDate) {
      return false;
    }
    const realTodayTimeMs = this.getLocalDateTimeInMs(realToday);
    const [startMs, endMs] = this.getHighlightedInterval(cellData);
    return startMs < endMs ? realTodayTimeMs >= startMs && realTodayTimeMs < endMs : realTodayTimeMs >= startMs && realTodayTimeMs < toMs18("day") || realTodayTimeMs >= 0 && realTodayTimeMs < endMs;
  }
  getHighlightedInterval(_ref3) {
    let {
      date,
      index: index2,
      duration,
      isFirst,
      isLast
    } = _ref3;
    const cellTimeMs = this.getLocalDateTimeInMs(date);
    const isEvenCell = index2 % 2 === 0;
    switch (true) {
      case (isFirst || isLast && !isEvenCell):
        return [cellTimeMs, shiftIntegerByModule(cellTimeMs + duration, toMs18("day"))];
      case isEvenCell:
        return [shiftIntegerByModule(cellTimeMs - duration, toMs18("day")), shiftIntegerByModule(cellTimeMs + duration, toMs18("day"))];
      default:
        return [cellTimeMs, shiftIntegerByModule(cellTimeMs + 2 * duration, toMs18("day"))];
    }
  }
  getLocalDateTimeInMs(date) {
    const dateUtcMs = date.getTime() - date.getTimezoneOffset() * toMs18("minute");
    return shiftIntegerByModule(dateUtcMs, toMs18("day"));
  }
  isLastCellInGroup(completeViewDataMap, index2) {
    if (index2 === completeViewDataMap.length - 1) {
      return true;
    }
    const {
      groupIndex: currentGroupIndex
    } = completeViewDataMap[index2][0];
    const {
      groupIndex: nextGroupIndex,
      allDay: nextAllDay
    } = completeViewDataMap[index2 + 1][0];
    return nextAllDay || nextGroupIndex !== currentGroupIndex;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator.js
var toMs19 = date_default.dateToMilliseconds;
var ViewDataGenerator = class {
  constructor() {
    this.daysInInterval = 1;
    this.isWorkView = false;
    this.tableAllDay = false;
  }
  isSkippedDate(date) {
    return false;
  }
  _calculateStartViewDate(options2) {
  }
  getStartViewDate(options2) {
    return this._calculateStartViewDate(options2);
  }
  getCompleteViewDataMap(options2) {
    const {
      groups,
      isGroupedByDate,
      isHorizontalGrouping,
      isVerticalGrouping,
      intervalCount,
      currentDate,
      viewType,
      startDayHour,
      endDayHour,
      hoursInterval
    } = options2;
    this._setVisibilityDates(options2);
    this.setHiddenInterval(startDayHour, endDayHour, hoursInterval);
    const groupsList = getAllGroups(groups);
    const cellCountInGroupRow = this.getCellCount({
      intervalCount,
      currentDate,
      viewType,
      startDayHour,
      endDayHour,
      hoursInterval
    });
    const rowCountInGroup = this.getRowCount({
      intervalCount,
      currentDate,
      viewType,
      hoursInterval,
      startDayHour,
      endDayHour
    });
    let viewDataMap = [];
    const allDayPanelData = this._generateAllDayPanelData(options2, rowCountInGroup, cellCountInGroupRow);
    const viewCellsData = this._generateViewCellsData(options2, rowCountInGroup, cellCountInGroupRow);
    if (allDayPanelData) {
      viewDataMap.push(allDayPanelData);
    }
    viewDataMap.push(...viewCellsData);
    if (isHorizontalGrouping && !isGroupedByDate) {
      viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList);
    }
    if (isVerticalGrouping) {
      viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList);
    }
    if (isGroupedByDate) {
      viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList);
    }
    return this._addKeysToCells(viewDataMap);
  }
  _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {
    const result2 = viewDataMap.map((row) => row.slice());
    groupsList.slice(1).forEach((groups, index2) => {
      const groupIndex = index2 + 1;
      viewDataMap.forEach((row, rowIndex) => {
        const nextGroupRow = row.map((cellData) => _extends({}, cellData, {
          groups,
          groupIndex
        }));
        result2[rowIndex].push(...nextGroupRow);
      });
    });
    return result2;
  }
  _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {
    const result2 = viewDataMap.map((row) => row.slice());
    groupsList.slice(1).forEach((groups, index2) => {
      const groupIndex = index2 + 1;
      const nextGroupMap = viewDataMap.map((cellsRow) => {
        const nextRow = cellsRow.map((cellData) => _extends({}, cellData, {
          groupIndex,
          groups
        }));
        return nextRow;
      });
      result2.push(...nextGroupMap);
    });
    return result2;
  }
  _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {
    const correctedGroupList = groupsList.slice(1);
    const correctedGroupCount = correctedGroupList.length;
    const result2 = viewDataMap.map((cellsRow) => {
      const groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {
        const rowWithCurrentCell = [...currentRow, _extends({}, cell, {
          isFirstGroupCell: true,
          isLastGroupCell: 0 === correctedGroupCount
        }), ...correctedGroupList.map((groups, index2) => _extends({}, cell, {
          groups,
          groupIndex: index2 + 1,
          isFirstGroupCell: false,
          isLastGroupCell: index2 === correctedGroupCount - 1
        }))];
        return rowWithCurrentCell;
      }, []);
      return groupedByDateCellsRow;
    });
    return result2;
  }
  _addKeysToCells(viewDataMap) {
    const totalColumnCount = viewDataMap[0].length;
    const {
      currentViewDataMap: result2
    } = viewDataMap.reduce((_ref, row, rowIndex) => {
      let {
        allDayPanelsCount,
        currentViewDataMap
      } = _ref;
      const isAllDay = row[0].allDay;
      const keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;
      const currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;
      currentViewDataMap[rowIndex].forEach((cell, columnIndex) => {
        cell.key = keyBase + columnIndex;
      });
      return {
        allDayPanelsCount: currentAllDayPanelsCount,
        currentViewDataMap
      };
    }, {
      allDayPanelsCount: 0,
      currentViewDataMap: viewDataMap
    });
    return result2;
  }
  generateViewDataMap(completeViewDataMap, options2) {
    const {
      rowCount,
      startCellIndex,
      startRowIndex,
      cellCount,
      isVerticalGrouping,
      isAllDayPanelVisible
    } = options2;
    const sliceCells = (row, rowIndex, startIndex, count) => {
      const sliceToIndex = void 0 !== count ? startIndex + count : void 0;
      return row.slice(startIndex, sliceToIndex).map((cellData, columnIndex) => ({
        cellData,
        position: {
          rowIndex,
          columnIndex
        }
      }));
    };
    let correctedStartRowIndex = startRowIndex;
    let allDayPanelMap = [];
    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {
      correctedStartRowIndex++;
      allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount);
    }
    const displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);
    const dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));
    return {
      allDayPanelMap,
      dateTableMap
    };
  }
  _isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible) {
    return !isVerticalGrouping && isAllDayPanelVisible;
  }
  getViewDataFromMap(completeViewDataMap, viewDataMap, options2) {
    const {
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      leftVirtualCellWidth,
      rightVirtualCellWidth,
      cellCount,
      rowCount,
      startRowIndex,
      startCellIndex,
      isProvideVirtualCellsWidth,
      isGroupedAllDayPanel,
      isVerticalGrouping,
      isAllDayPanelVisible
    } = options2;
    const {
      allDayPanelMap,
      dateTableMap
    } = viewDataMap;
    const {
      groupedData
    } = dateTableMap.reduce((_ref2, cellsRow) => {
      let {
        previousGroupIndex,
        groupedData: groupedData2
      } = _ref2;
      const cellDataRow = cellsRow.map((_ref3) => {
        let {
          cellData
        } = _ref3;
        return cellData;
      });
      const firstCell = cellDataRow[0];
      const isAllDayRow = firstCell.allDay;
      const currentGroupIndex = firstCell.groupIndex;
      if (currentGroupIndex !== previousGroupIndex) {
        groupedData2.push({
          dateTable: [],
          isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!isAllDayRow, isVerticalGrouping),
          groupIndex: currentGroupIndex,
          key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)
        });
      }
      if (isAllDayRow) {
        groupedData2[groupedData2.length - 1].allDayPanel = cellDataRow;
      } else {
        groupedData2[groupedData2.length - 1].dateTable.push({
          cells: cellDataRow,
          key: cellDataRow[0].key - startCellIndex
        });
      }
      return {
        groupedData: groupedData2,
        previousGroupIndex: currentGroupIndex
      };
    }, {
      previousGroupIndex: -1,
      groupedData: []
    });
    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {
      groupedData[0].allDayPanel = allDayPanelMap.map((_ref4) => {
        let {
          cellData
        } = _ref4;
        return cellData;
      });
    }
    const totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);
    const totalRowCount = getTotalRowCountByCompleteData(completeViewDataMap);
    const displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);
    const displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);
    return {
      groupedData,
      topVirtualRowHeight,
      bottomVirtualRowHeight,
      leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,
      rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,
      isGroupedAllDayPanel,
      leftVirtualCellCount: startCellIndex,
      rightVirtualCellCount: void 0 === cellCount ? 0 : totalCellCount - startCellIndex - displayedCellCount,
      topVirtualRowCount: startRowIndex,
      bottomVirtualRowCount: totalRowCount - startRowIndex - displayedRowCount
    };
  }
  _generateViewCellsData(options2, rowCount, cellCountInGroupRow) {
    const viewCellsData = [];
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
      viewCellsData.push(this._generateCellsRow(options2, false, rowIndex, rowCount, cellCountInGroupRow));
    }
    return viewCellsData;
  }
  _generateAllDayPanelData(options2, rowCount, columnCount) {
    if (!options2.isAllDayPanelVisible) {
      return null;
    }
    return this._generateCellsRow(options2, true, 0, rowCount, columnCount);
  }
  _generateCellsRow(options2, allDay, rowIndex, rowCount, columnCount) {
    const cellsRow = [];
    for (let columnIndex = 0; columnIndex < columnCount; ++columnIndex) {
      const cellDataValue = this.getCellData(rowIndex, columnIndex, options2, allDay);
      cellDataValue.index = rowIndex * columnCount + columnIndex;
      cellDataValue.isFirstGroupCell = this._isFirstGroupCell(rowIndex, columnIndex, options2, rowCount, columnCount);
      cellDataValue.isLastGroupCell = this._isLastGroupCell(rowIndex, columnIndex, options2, rowCount, columnCount);
      cellsRow.push(cellDataValue);
    }
    return cellsRow;
  }
  getCellData(rowIndex, columnIndex, options2, allDay) {
    return allDay ? this.prepareAllDayCellData(options2, rowIndex, columnIndex) : this.prepareCellData(options2, rowIndex, columnIndex);
  }
  prepareCellData(options2, rowIndex, columnIndex) {
    const {
      groups,
      startDayHour,
      endDayHour,
      hoursInterval
    } = options2;
    const groupsList = getAllGroups(groups);
    const startDate = this.getDateByCellIndices(options2, rowIndex, columnIndex, this.getCellCountInDay(startDayHour, endDayHour, hoursInterval));
    const endDate = this.getCellEndDate(startDate, options2);
    const data2 = {
      startDate,
      endDate,
      allDay: this.tableAllDay,
      groupIndex: 0
    };
    if (groupsList.length > 0) {
      data2.groups = groupsList[0];
    }
    return data2;
  }
  prepareAllDayCellData(options2, rowIndex, columnIndex) {
    const data2 = this.prepareCellData(_extends({}, options2, {
      viewOffset: 0
    }), rowIndex, columnIndex);
    const {
      viewOffset
    } = options2;
    const startDate = date_default.trimTime(data2.startDate);
    const shiftedStartDate = dateUtilsTs.addOffsets(startDate, [viewOffset]);
    return _extends({}, data2, {
      startDate: shiftedStartDate,
      endDate: shiftedStartDate,
      allDay: true
    });
  }
  getDateByCellIndices(options2, rowIndex, columnIndex, cellCountInDay) {
    let {
      startViewDate
    } = options2;
    const {
      startDayHour,
      interval,
      firstDayOfWeek,
      intervalCount,
      viewOffset
    } = options2;
    const isStartViewDateDuringDST = startViewDate.getHours() !== Math.floor(startDayHour);
    if (isStartViewDateDuringDST) {
      const dateWithCorrectHours = getStartViewDateWithoutDST(startViewDate, startDayHour);
      startViewDate = new Date(dateWithCorrectHours.getTime() - toMs19("day"));
    }
    const columnCountBase = this.getCellCount(options2);
    const rowCountBase = this.getRowCount(options2);
    const cellIndex = this._calculateCellIndex(rowIndex, columnIndex, rowCountBase, columnCountBase);
    const millisecondsOffset = this.getMillisecondsOffset(cellIndex, interval, cellCountInDay);
    const offsetByCount = this.isWorkView ? this.getTimeOffsetByColumnIndex(columnIndex, this.getFirstDayOfWeek(firstDayOfWeek), columnCountBase, intervalCount) : 0;
    const startViewDateTime = startViewDate.getTime();
    const currentDate = new Date(startViewDateTime + millisecondsOffset + offsetByCount + viewOffset);
    const timeZoneDifference = isStartViewDateDuringDST ? 0 : date_default.getTimezonesDifference(startViewDate, currentDate);
    currentDate.setTime(currentDate.getTime() + timeZoneDifference);
    return currentDate;
  }
  getMillisecondsOffset(cellIndex, interval, cellCountInDay) {
    const dayIndex = Math.floor(cellIndex / cellCountInDay);
    const realHiddenInterval = dayIndex * this.hiddenInterval;
    return interval * cellIndex + realHiddenInterval;
  }
  getTimeOffsetByColumnIndex(columnIndex, firstDayOfWeek, columnCount, intervalCount) {
    const firstDayOfWeekDiff = Math.max(0, firstDayOfWeek - 1);
    const columnsInWeek = columnCount / intervalCount;
    const weekendCount = Math.floor((columnIndex + firstDayOfWeekDiff) / columnsInWeek);
    return 2 * weekendCount * toMs19("day");
  }
  calculateEndDate(startDate, interval, endDayHour) {
    return this.getCellEndDate(startDate, {
      interval
    });
  }
  _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCountBase) {
    return calculateCellIndex(rowIndex, columnIndex, rowCount);
  }
  generateGroupedDataMap(viewDataMap) {
    const {
      allDayPanelMap,
      dateTableMap
    } = viewDataMap;
    const {
      previousGroupedDataMap: dateTableGroupedMap
    } = dateTableMap.reduce((previousOptions, cellsRow) => {
      const {
        previousGroupedDataMap,
        previousRowIndex,
        previousGroupIndex
      } = previousOptions;
      const {
        groupIndex: currentGroupIndex
      } = cellsRow[0].cellData;
      const currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;
      cellsRow.forEach((cell) => {
        const {
          groupIndex
        } = cell.cellData;
        if (!previousGroupedDataMap[groupIndex]) {
          previousGroupedDataMap[groupIndex] = [];
        }
        if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {
          previousGroupedDataMap[groupIndex][currentRowIndex] = [];
        }
        previousGroupedDataMap[groupIndex][currentRowIndex].push(cell);
      });
      return {
        previousGroupedDataMap,
        previousRowIndex: currentRowIndex,
        previousGroupIndex: currentGroupIndex
      };
    }, {
      previousGroupedDataMap: [],
      previousRowIndex: -1,
      previousGroupIndex: -1
    });
    const allDayPanelGroupedMap = [];
    null === allDayPanelMap || void 0 === allDayPanelMap || allDayPanelMap.forEach((cell) => {
      const {
        groupIndex
      } = cell.cellData;
      if (!allDayPanelGroupedMap[groupIndex]) {
        allDayPanelGroupedMap[groupIndex] = [];
      }
      allDayPanelGroupedMap[groupIndex].push(cell);
    });
    return {
      allDayPanelGroupedMap,
      dateTableGroupedMap
    };
  }
  _isFirstGroupCell(rowIndex, columnIndex, options2, rowCount, columnCount) {
    const {
      groupOrientation,
      groups,
      isGroupedByDate
    } = options2;
    const groupCount = getGroupCount(groups);
    if (isGroupedByDate) {
      return columnIndex % groupCount === 0;
    }
    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {
      return columnIndex % columnCount === 0;
    }
    return rowIndex % rowCount === 0;
  }
  _isLastGroupCell(rowIndex, columnIndex, options2, rowCount, columnCount) {
    const {
      groupOrientation,
      groups,
      isGroupedByDate
    } = options2;
    const groupCount = getGroupCount(groups);
    if (isGroupedByDate) {
      return (columnIndex + 1) % groupCount === 0;
    }
    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {
      return (columnIndex + 1) % columnCount === 0;
    }
    return (rowIndex + 1) % rowCount === 0;
  }
  markSelectedAndFocusedCells(viewDataMap, renderOptions) {
    const {
      selectedCells,
      focusedCell
    } = renderOptions;
    if (!selectedCells && !focusedCell) {
      return viewDataMap;
    }
    const {
      allDayPanelMap,
      dateTableMap
    } = viewDataMap;
    const nextDateTableMap = dateTableMap.map((row) => this._markSelectedAndFocusedCellsInRow(row, selectedCells, focusedCell));
    const nextAllDayMap = this._markSelectedAndFocusedCellsInRow(allDayPanelMap, selectedCells, focusedCell);
    return {
      allDayPanelMap: nextAllDayMap,
      dateTableMap: nextDateTableMap
    };
  }
  _markSelectedAndFocusedCellsInRow(dataRow, selectedCells, focusedCell) {
    return dataRow.map((cell) => {
      const {
        index: index2,
        groupIndex,
        allDay,
        startDate
      } = cell.cellData;
      const indexInSelectedCells = selectedCells.findIndex((_ref5) => {
        let {
          index: selectedCellIndex,
          groupIndex: selectedCellGroupIndex,
          allDay: selectedCellAllDay,
          startDate: selectedCellStartDate
        } = _ref5;
        return groupIndex === selectedCellGroupIndex && (index2 === selectedCellIndex || void 0 === selectedCellIndex && startDate.getTime() === selectedCellStartDate.getTime()) && !!allDay === !!selectedCellAllDay;
      });
      const isFocused = !!focusedCell && index2 === focusedCell.cellData.index && groupIndex === focusedCell.cellData.groupIndex && allDay === focusedCell.cellData.allDay;
      if (!isFocused && -1 === indexInSelectedCells) {
        return cell;
      }
      return _extends({}, cell, {
        cellData: _extends({}, cell.cellData, {
          isSelected: indexInSelectedCells > -1,
          isFocused
        })
      });
    });
  }
  getInterval(hoursInterval) {
    return hoursInterval * toMs19("hour");
  }
  _getIntervalDuration(intervalCount) {
    return toMs19("day") * intervalCount;
  }
  _setVisibilityDates(options2) {
  }
  getCellCountInDay(startDayHour, endDayHour, hoursInterval) {
    const result2 = calculateDayDuration(startDayHour, endDayHour) / hoursInterval;
    return Math.ceil(result2);
  }
  getCellCount(options2) {
    const {
      intervalCount,
      viewType,
      startDayHour,
      endDayHour,
      hoursInterval
    } = options2;
    const cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
    const columnCountInDay = isHorizontalView(viewType) ? cellCountInDay : 1;
    return this.daysInInterval * intervalCount * columnCountInDay;
  }
  getRowCount(options2) {
    const {
      viewType,
      startDayHour,
      endDayHour,
      hoursInterval
    } = options2;
    const cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
    const rowCountInDay = !isHorizontalView(viewType) ? cellCountInDay : 1;
    return rowCountInDay;
  }
  setHiddenInterval(startDayHour, endDayHour, hoursInterval) {
    this.hiddenInterval = toMs19("day") - this.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);
  }
  getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {
    const cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
    return hoursInterval * cellCountInDay * toMs19("hour");
  }
  getFirstDayOfWeek(firstDayOfWeekOption) {
    return firstDayOfWeekOption;
  }
  getCellEndDate(cellStartDate, options2) {
    const durationMs = Math.round(options2.interval);
    return m_utils_time_zone_default.addOffsetsWithoutDST(cellStartDate, durationMs);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator_day.js
var ViewDataGeneratorDay = class extends ViewDataGenerator {
  _calculateStartViewDate(options2) {
    return dayUtils.calculateStartViewDate(options2.currentDate, options2.startDayHour, options2.startDate, this._getIntervalDuration(options2.intervalCount));
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator_month.js
var toMs20 = date_default.dateToMilliseconds;
var ViewDataGeneratorMonth = class extends ViewDataGenerator {
  constructor() {
    super(...arguments);
    this.tableAllDay = void 0;
  }
  getCellData(rowIndex, columnIndex, options2, allDay) {
    const {
      indicatorTime,
      timeZoneCalculator,
      intervalCount,
      viewOffset
    } = options2;
    const data2 = super.getCellData(rowIndex, columnIndex, options2, false);
    const startDate = m_utils_time_zone_default.addOffsetsWithoutDST(data2.startDate, -viewOffset);
    data2.today = this.isCurrentDate(startDate, indicatorTime, timeZoneCalculator);
    data2.otherMonth = this.isOtherMonth(startDate, this._minVisibleDate, this._maxVisibleDate);
    data2.firstDayOfMonth = isFirstCellInMonthWithIntervalCount(startDate, intervalCount);
    data2.text = monthUtils.getCellText(startDate, intervalCount);
    return data2;
  }
  isCurrentDate(date, indicatorTime, timeZoneCalculator) {
    return date_default.sameDate(date, getToday(indicatorTime, timeZoneCalculator));
  }
  isOtherMonth(cellDate, minDate, maxDate) {
    return !date_default.dateInRange(cellDate, minDate, maxDate, "date");
  }
  _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {
    return monthUtils.calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount);
  }
  calculateEndDate(startDate, interval, endDayHour) {
    return setOptionHour(startDate, endDayHour);
  }
  getInterval() {
    return toMs20("day");
  }
  _calculateStartViewDate(options2) {
    return monthUtils.calculateStartViewDate(options2.currentDate, options2.startDayHour, options2.startDate, options2.intervalCount, this.getFirstDayOfWeek(options2.firstDayOfWeek));
  }
  _setVisibilityDates(options2) {
    const {
      intervalCount,
      startDate,
      currentDate
    } = options2;
    const firstMonthDate = date_default.getFirstMonthDate(startDate);
    const viewStart = monthUtils.getViewStartByOptions(startDate, currentDate, intervalCount, firstMonthDate);
    this._minVisibleDate = new Date(viewStart.setDate(1));
    const nextMonthDate = new Date(viewStart.setMonth(viewStart.getMonth() + intervalCount));
    this._maxVisibleDate = new Date(nextMonthDate.setDate(0));
  }
  getCellCount() {
    return 7;
  }
  getRowCount(options2) {
    const startDate = new Date(options2.currentDate);
    startDate.setDate(1);
    const endDate = new Date(startDate);
    endDate.setMonth(endDate.getMonth() + options2.intervalCount);
    endDate.setDate(0);
    return calculateAlignedWeeksBetweenDates(startDate, endDate, options2.firstDayOfWeek ?? date_default3.firstDayOfWeekIndex());
  }
  getCellCountInDay() {
    return 1;
  }
  setHiddenInterval() {
    this.hiddenInterval = 0;
  }
  getCellEndDate(cellStartDate, options2) {
    const {
      startDayHour,
      endDayHour
    } = options2;
    const durationMs = (endDayHour - startDayHour) * toMs20("hour");
    return m_utils_time_zone_default.addOffsetsWithoutDST(cellStartDate, durationMs);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator_timeline_month.js
var toMs21 = date_default.dateToMilliseconds;
var ViewDataGeneratorTimelineMonth = class extends ViewDataGenerator {
  _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {
    return monthUtils.calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount);
  }
  calculateEndDate(startDate, interval, endDayHour) {
    return setOptionHour(startDate, endDayHour);
  }
  getInterval() {
    return toMs21("day");
  }
  _calculateStartViewDate(options2) {
    return timelineMonthUtils.calculateStartViewDate(options2.currentDate, options2.startDayHour, options2.startDate, options2.intervalCount);
  }
  getCellCount(options2) {
    const {
      intervalCount
    } = options2;
    const currentDate = new Date(options2.currentDate);
    let cellCount = 0;
    for (let i = 1; i <= intervalCount; i++) {
      cellCount += new Date(currentDate.getFullYear(), currentDate.getMonth() + i, 0).getDate();
    }
    return cellCount;
  }
  setHiddenInterval() {
    this.hiddenInterval = 0;
  }
  getCellEndDate(cellStartDate, options2) {
    const {
      startDayHour,
      endDayHour
    } = options2;
    const durationMs = (endDayHour - startDayHour) * toMs21("hour");
    return m_utils_time_zone_default.addOffsetsWithoutDST(cellStartDate, durationMs);
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator_week.js
var ViewDataGeneratorWeek = class extends ViewDataGenerator {
  constructor() {
    super(...arguments);
    this.daysInInterval = 7;
  }
  _getIntervalDuration(intervalCount) {
    return weekUtils.getIntervalDuration(intervalCount);
  }
  _calculateStartViewDate(options2) {
    return weekUtils.calculateStartViewDate(options2.currentDate, options2.startDayHour, options2.startDate, this._getIntervalDuration(options2.intervalCount), this.getFirstDayOfWeek(options2.firstDayOfWeek));
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_generator_work_week.js
var ViewDataGeneratorWorkWeek = class extends ViewDataGeneratorWeek {
  constructor() {
    super(...arguments);
    this.daysInInterval = 5;
    this.isWorkView = true;
  }
  isSkippedDate(date) {
    return isDataOnWeekend(date);
  }
  _calculateStartViewDate(options2) {
    return workWeekUtils.calculateStartViewDate(options2.currentDate, options2.startDayHour, options2.startDate, this._getIntervalDuration(options2.intervalCount), this.getFirstDayOfWeek(options2.firstDayOfWeek));
  }
  getFirstDayOfWeek(firstDayOfWeekOption) {
    return firstDayOfWeekOption || 0;
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_utils.js
var DAYS_IN_WEEK2 = 7;
var MS_IN_DAY = 864e5;
var getViewDataGeneratorByViewType = (viewType) => {
  switch (viewType) {
    case VIEWS.MONTH:
      return new ViewDataGeneratorMonth();
    case VIEWS.TIMELINE_MONTH:
      return new ViewDataGeneratorTimelineMonth();
    case VIEWS.DAY:
    case VIEWS.TIMELINE_DAY:
      return new ViewDataGeneratorDay();
    case VIEWS.WEEK:
    case VIEWS.TIMELINE_WEEK:
      return new ViewDataGeneratorWeek();
    case VIEWS.WORK_WEEK:
    case VIEWS.TIMELINE_WORK_WEEK:
      return new ViewDataGeneratorWorkWeek();
    default:
      return new ViewDataGenerator();
  }
};
function alignToFirstDayOfWeek(date, firstDayOfWeek) {
  const newDate = new Date(date);
  let dayDiff = newDate.getDay() - firstDayOfWeek;
  if (dayDiff < 0) {
    dayDiff += DAYS_IN_WEEK2;
  }
  newDate.setDate(newDate.getDate() - dayDiff);
  return newDate;
}
function alignToLastDayOfWeek(date, firstDayOfWeek) {
  const newDate = alignToFirstDayOfWeek(date, firstDayOfWeek);
  newDate.setDate(newDate.getDate() + DAYS_IN_WEEK2 - 1);
  return newDate;
}
function calculateDaysBetweenDates(fromDate, toDate) {
  const msDiff = date_default.trimTime(toDate).getTime() - date_default.trimTime(fromDate).getTime();
  return Math.round(msDiff / MS_IN_DAY) + 1;
}
function calculateAlignedWeeksBetweenDates(fromDate, toDate, firstDayOfWeek) {
  const alignedFromDate = alignToFirstDayOfWeek(fromDate, firstDayOfWeek);
  const alignedToDate = alignToLastDayOfWeek(toDate, firstDayOfWeek);
  const weekCount = calculateDaysBetweenDates(alignedFromDate, alignedToDate) / DAYS_IN_WEEK2;
  return Math.max(weekCount, 6);
}

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/view_model/m_view_data_provider.js
var _excluded23 = ["groups", "groupOrientation", "groupByDate", "isAllDayPanelVisible", "viewOffset"];
var ViewDataProvider = class {
  constructor(viewType) {
    this.viewType = viewType;
    this.viewDataGenerator = getViewDataGeneratorByViewType(viewType);
    this.viewData = {};
    this.completeViewDataMap = [];
    this.completeDateHeaderMap = [];
    this.viewDataMap = {};
    this._groupedDataMapProvider = null;
  }
  get groupedDataMap() {
    return this._groupedDataMapProvider.groupedDataMap;
  }
  get hiddenInterval() {
    return this.viewDataGenerator.hiddenInterval;
  }
  isSkippedDate(date) {
    return this.viewDataGenerator.isSkippedDate(date);
  }
  update(options2, isGenerateNewViewData) {
    this.viewDataGenerator = getViewDataGeneratorByViewType(options2.viewType);
    const {
      viewDataGenerator
    } = this;
    const dateHeaderDataGenerator = new DateHeaderDataGenerator(viewDataGenerator);
    const timePanelDataGenerator = new TimePanelDataGenerator(viewDataGenerator);
    const renderOptions = this._transformRenderOptions(options2);
    renderOptions.interval = this.viewDataGenerator.getInterval(renderOptions.hoursInterval);
    this._options = renderOptions;
    if (isGenerateNewViewData) {
      this.completeViewDataMap = viewDataGenerator.getCompleteViewDataMap(renderOptions);
      this.completeDateHeaderMap = dateHeaderDataGenerator.getCompleteDateHeaderMap(renderOptions, this.completeViewDataMap);
      if (renderOptions.isGenerateTimePanelData) {
        this.completeTimePanelMap = timePanelDataGenerator.getCompleteTimePanelMap(renderOptions, this.completeViewDataMap);
      }
    }
    this.viewDataMap = viewDataGenerator.generateViewDataMap(this.completeViewDataMap, renderOptions);
    this.updateViewData(renderOptions);
    this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, {
      isVerticalGrouping: renderOptions.isVerticalGrouping,
      viewType: renderOptions.viewType,
      viewOffset: options2.viewOffset
    });
    this.dateHeaderData = dateHeaderDataGenerator.generateDateHeaderData(this.completeDateHeaderMap, this.completeViewDataMap, renderOptions);
    if (renderOptions.isGenerateTimePanelData) {
      this.timePanelData = timePanelDataGenerator.generateTimePanelData(this.completeTimePanelMap, renderOptions);
    }
  }
  createGroupedDataMapProvider() {
    this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, {
      isVerticalGrouping: this._options.isVerticalGrouping,
      viewType: this._options.viewType
    });
  }
  updateViewData(options2) {
    const renderOptions = this._transformRenderOptions(options2);
    this.viewDataMapWithSelection = this.viewDataGenerator.markSelectedAndFocusedCells(this.viewDataMap, renderOptions);
    this.viewData = this.viewDataGenerator.getViewDataFromMap(this.completeViewDataMap, this.viewDataMapWithSelection, renderOptions);
  }
  _transformRenderOptions(renderOptions) {
    const {
      groups,
      groupOrientation,
      groupByDate,
      isAllDayPanelVisible,
      viewOffset
    } = renderOptions, restOptions = _objectWithoutPropertiesLoose(renderOptions, _excluded23);
    return _extends({}, restOptions, {
      startViewDate: this.viewDataGenerator._calculateStartViewDate(renderOptions),
      isVerticalGrouping: isVerticalGroupingApplied(groups, groupOrientation),
      isHorizontalGrouping: isHorizontalGroupingApplied(groups, groupOrientation),
      isGroupedByDate: isGroupingByDate(groups, groupOrientation, groupByDate),
      isGroupedAllDayPanel: calculateIsGroupedAllDayPanel(groups, groupOrientation, isAllDayPanelVisible),
      groups,
      groupOrientation,
      isAllDayPanelVisible,
      viewOffset
    });
  }
  getGroupPanelData(options2) {
    const renderOptions = this._transformRenderOptions(options2);
    if (renderOptions.groups.length > 0) {
      const cellCount = this.getCellCount(renderOptions);
      return getGroupPanelData(renderOptions.groups, cellCount, renderOptions.isGroupedByDate, renderOptions.isGroupedByDate ? 1 : cellCount);
    }
    return;
  }
  getGroupStartDate(groupIndex) {
    return this._groupedDataMapProvider.getGroupStartDate(groupIndex);
  }
  getGroupEndDate(groupIndex) {
    return this._groupedDataMapProvider.getGroupEndDate(groupIndex);
  }
  findGroupCellStartDate(groupIndex, startDate, endDate) {
    let isFindByDate = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    return this._groupedDataMapProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isFindByDate);
  }
  findAllDayGroupCellStartDate(groupIndex) {
    return this._groupedDataMapProvider.findAllDayGroupCellStartDate(groupIndex);
  }
  findCellPositionInMap(cellInfo) {
    let isAppointmentRender = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    return this._groupedDataMapProvider.findCellPositionInMap(cellInfo, isAppointmentRender);
  }
  hasAllDayPanel() {
    const {
      viewData
    } = this.viewDataMap;
    const {
      allDayPanel
    } = viewData.groupedData[0];
    return !viewData.isGroupedAllDayPanel && (null === allDayPanel || void 0 === allDayPanel ? void 0 : allDayPanel.length) > 0;
  }
  getCellsGroup(groupIndex) {
    return this._groupedDataMapProvider.getCellsGroup(groupIndex);
  }
  getCompletedGroupsInfo() {
    return this._groupedDataMapProvider.getCompletedGroupsInfo();
  }
  getGroupIndices() {
    return this._groupedDataMapProvider.getGroupIndices();
  }
  getLastGroupCellPosition(groupIndex) {
    return this._groupedDataMapProvider.getLastGroupCellPosition(groupIndex);
  }
  getRowCountInGroup(groupIndex) {
    return this._groupedDataMapProvider.getRowCountInGroup(groupIndex);
  }
  getCellData(rowIndex, columnIndex, isAllDay, rtlEnabled) {
    const row = isAllDay && !this._options.isVerticalGrouping ? this.viewDataMap.allDayPanelMap : this.viewDataMap.dateTableMap[rowIndex];
    const actualColumnIndex = !rtlEnabled ? columnIndex : row.length - 1 - columnIndex;
    const {
      cellData
    } = row[actualColumnIndex];
    return cellData;
  }
  getCellsByGroupIndexAndAllDay(groupIndex, allDay) {
    const rowsPerGroup = this._getRowCountWithAllDayRows();
    const isShowAllDayPanel = this._options.isAllDayPanelVisible;
    const firstRowInGroup = this._options.isVerticalGrouping ? groupIndex * rowsPerGroup : 0;
    const lastRowInGroup = this._options.isVerticalGrouping ? (groupIndex + 1) * rowsPerGroup - 1 : rowsPerGroup;
    const correctedFirstRow = isShowAllDayPanel && !allDay ? firstRowInGroup + 1 : firstRowInGroup;
    const correctedLastRow = allDay ? correctedFirstRow : lastRowInGroup;
    return this.completeViewDataMap.slice(correctedFirstRow, correctedLastRow + 1).map((row) => row.filter((_ref) => {
      let {
        groupIndex: currentGroupIndex
      } = _ref;
      return groupIndex === currentGroupIndex;
    }));
  }
  getCellCountWithGroup(groupIndex) {
    let rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    return dateTableGroupedMap.filter((_, index2) => index2 <= groupIndex).reduce((previous, row) => previous + row[rowIndex].length, 0);
  }
  hasGroupAllDayPanel(groupIndex) {
    var _this$groupedDataMap$2;
    if (this._options.isVerticalGrouping) {
      var _this$groupedDataMap$;
      return !!(null !== (_this$groupedDataMap$ = this.groupedDataMap.dateTableGroupedMap[groupIndex]) && void 0 !== _this$groupedDataMap$ && _this$groupedDataMap$[0][0].cellData.allDay);
    }
    return (null === (_this$groupedDataMap$2 = this.groupedDataMap.allDayPanelGroupedMap[groupIndex]) || void 0 === _this$groupedDataMap$2 ? void 0 : _this$groupedDataMap$2.length) > 0;
  }
  isGroupIntersectDateInterval(groupIndex, startDate, endDate) {
    const groupStartDate = this.getGroupStartDate(groupIndex);
    const groupEndDate = this.getGroupEndDate(groupIndex);
    return startDate < groupEndDate && endDate > groupStartDate;
  }
  findGlobalCellPosition(date) {
    let groupIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    let allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    const {
      completeViewDataMap
    } = this;
    const showAllDayPanel = this._options.isAllDayPanelVisible;
    for (let rowIndex = 0; rowIndex < completeViewDataMap.length; rowIndex += 1) {
      const currentRow = completeViewDataMap[rowIndex];
      for (let columnIndex = 0; columnIndex < currentRow.length; columnIndex += 1) {
        const cellData = currentRow[columnIndex];
        const {
          startDate: currentStartDate,
          endDate: currentEndDate,
          groupIndex: currentGroupIndex,
          allDay: currentAllDay
        } = cellData;
        if (groupIndex === currentGroupIndex && allDay === !!currentAllDay && this._compareDatesAndAllDay(date, currentStartDate, currentEndDate, allDay)) {
          return {
            position: {
              columnIndex,
              rowIndex: showAllDayPanel && !this._options.isVerticalGrouping ? rowIndex - 1 : rowIndex
            },
            cellData
          };
        }
      }
    }
    return;
  }
  _compareDatesAndAllDay(date, cellStartDate, cellEndDate, allDay) {
    return allDay ? date_default.sameDate(date, cellStartDate) : date >= cellStartDate && date < cellEndDate;
  }
  getSkippedDaysCount(groupIndex, startDate, endDate, daysCount) {
    const {
      dateTableGroupedMap
    } = this._groupedDataMapProvider.groupedDataMap;
    const groupedData = dateTableGroupedMap[groupIndex];
    let includedDays = 0;
    for (let rowIndex = 0; rowIndex < groupedData.length; rowIndex += 1) {
      for (let columnIndex = 0; columnIndex < groupedData[rowIndex].length; columnIndex += 1) {
        const cell = groupedData[rowIndex][columnIndex].cellData;
        if (startDate.getTime() < cell.endDate.getTime() && endDate.getTime() > cell.startDate.getTime()) {
          includedDays += 1;
        }
      }
    }
    const lastCell = groupedData[groupedData.length - 1][groupedData[0].length - 1].cellData;
    const lastCellStart = date_default.trimTime(lastCell.startDate);
    const daysAfterView = Math.floor((endDate.getTime() - lastCellStart.getTime()) / date_default.dateToMilliseconds("day"));
    const deltaDays = daysAfterView > 0 ? daysAfterView : 0;
    return daysCount - includedDays - deltaDays;
  }
  getColumnsCount() {
    const {
      dateTableMap
    } = this.viewDataMap;
    return dateTableMap ? dateTableMap[0].length : 0;
  }
  getViewEdgeIndices(isAllDayPanel) {
    if (isAllDayPanel) {
      return {
        firstColumnIndex: 0,
        lastColumnIndex: this.viewDataMap.allDayPanelMap.length - 1,
        firstRowIndex: 0,
        lastRowIndex: 0
      };
    }
    return {
      firstColumnIndex: 0,
      lastColumnIndex: this.viewDataMap.dateTableMap[0].length - 1,
      firstRowIndex: 0,
      lastRowIndex: this.viewDataMap.dateTableMap.length - 1
    };
  }
  getGroupEdgeIndices(groupIndex, isAllDay) {
    const groupedDataMap = this.groupedDataMap.dateTableGroupedMap[groupIndex];
    const cellsCount = groupedDataMap[0].length;
    const rowsCount = groupedDataMap.length;
    const firstColumnIndex = groupedDataMap[0][0].position.columnIndex;
    const lastColumnIndex = groupedDataMap[0][cellsCount - 1].position.columnIndex;
    if (isAllDay) {
      return {
        firstColumnIndex,
        lastColumnIndex,
        firstRowIndex: 0,
        lastRowIndex: 0
      };
    }
    return {
      firstColumnIndex,
      lastColumnIndex,
      firstRowIndex: groupedDataMap[0][0].position.rowIndex,
      lastRowIndex: groupedDataMap[rowsCount - 1][0].position.rowIndex
    };
  }
  isSameCell(firstCellData, secondCellData) {
    const {
      startDate: firstStartDate,
      groupIndex: firstGroupIndex,
      allDay: firstAllDay,
      index: firstIndex
    } = firstCellData;
    const {
      startDate: secondStartDate,
      groupIndex: secondGroupIndex,
      allDay: secondAllDay,
      index: secondIndex
    } = secondCellData;
    return firstStartDate.getTime() === secondStartDate.getTime() && firstGroupIndex === secondGroupIndex && firstAllDay === secondAllDay && firstIndex === secondIndex;
  }
  getLastViewDate() {
    const {
      completeViewDataMap
    } = this;
    const rowsCount = completeViewDataMap.length - 1;
    return completeViewDataMap[rowsCount][completeViewDataMap[rowsCount].length - 1].endDate;
  }
  getStartViewDate() {
    return this._options.startViewDate;
  }
  getIntervalDuration(intervalCount) {
    return this.viewDataGenerator._getIntervalDuration(intervalCount);
  }
  getLastCellEndDate() {
    const lastEndDate = new Date(this.getLastViewDate().getTime() - date_default.dateToMilliseconds("minute"));
    return dateUtilsTs.addOffsets(lastEndDate, [-this._options.viewOffset]);
  }
  getLastViewDateByEndDayHour(endDayHour) {
    const lastCellEndDate = this.getLastCellEndDate();
    const endTime = date_default.dateTimeFromDecimal(endDayHour);
    const endDateOfLastViewCell = new Date(lastCellEndDate.setHours(endTime.hours, endTime.minutes));
    return this._adjustEndDateByDaylightDiff(lastCellEndDate, endDateOfLastViewCell);
  }
  _adjustEndDateByDaylightDiff(startDate, endDate) {
    const daylightDiff = m_utils_time_zone_default.getDaylightOffsetInMs(startDate, endDate);
    const endDateOfLastViewCell = new Date(endDate.getTime() - daylightDiff);
    return new Date(endDateOfLastViewCell.getTime() - date_default.dateToMilliseconds("minute"));
  }
  getCellCountInDay(startDayHour, endDayHour, hoursInterval) {
    return this.viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
  }
  getCellCount(options2) {
    return this.viewDataGenerator.getCellCount(options2);
  }
  getRowCount(options2) {
    return this.viewDataGenerator.getRowCount(options2);
  }
  getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {
    return this.viewDataGenerator.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);
  }
  _getRowCountWithAllDayRows() {
    const allDayRowCount = this._options.isAllDayPanelVisible ? 1 : 0;
    return this.getRowCount(this._options) + allDayRowCount;
  }
  getFirstDayOfWeek(firstDayOfWeekOption) {
    return this.viewDataGenerator.getFirstDayOfWeek(firstDayOfWeekOption);
  }
  setViewOptions(options2) {
    this._options = this._transformRenderOptions(options2);
  }
  getViewOptions() {
    return this._options;
  }
  getViewPortGroupCount() {
    const {
      dateTableGroupedMap
    } = this.groupedDataMap;
    return (null === dateTableGroupedMap || void 0 === dateTableGroupedMap ? void 0 : dateTableGroupedMap.length) || 0;
  }
  getCellsBetween(first, last) {
    const [firstCell, lastCell] = this.normalizeCellsOrder(first, last);
    const {
      index: firstIdx
    } = firstCell;
    const {
      index: lastIdx
    } = lastCell;
    const cellMatrix = this.getCellsByGroupIndexAndAllDay(firstCell.groupIndex ?? 0, lastCell.allDay ?? false);
    return isHorizontalView(this.viewType) ? this.getCellsBetweenHorizontalView(cellMatrix, firstIdx, lastIdx) : this.getCellsBetweenVerticalView(cellMatrix, firstIdx, lastIdx);
  }
  getCellsBetweenHorizontalView(cellMatrix, firstIdx, lastIdx) {
    return cellMatrix.reduce((result2, row) => result2.concat(row.filter((_ref2) => {
      let {
        index: index2
      } = _ref2;
      return firstIdx <= index2 && index2 <= lastIdx;
    })), []);
  }
  getCellsBetweenVerticalView(cellMatrix, firstIdx, lastIdx) {
    var _cellMatrix$;
    const result2 = [];
    const matrixHeight = cellMatrix.length;
    const matrixWidth = (null === (_cellMatrix$ = cellMatrix[0]) || void 0 === _cellMatrix$ ? void 0 : _cellMatrix$.length) ?? 0;
    let inSegment = false;
    for (let columnIdx = 0; columnIdx < matrixWidth; columnIdx += 1) {
      for (let rowIdx = 0; rowIdx < matrixHeight; rowIdx += 1) {
        const cell = cellMatrix[rowIdx][columnIdx];
        const {
          index: cellIdx
        } = cell;
        if (cellIdx === firstIdx) {
          inSegment = true;
        }
        if (inSegment) {
          result2.push(cell);
        }
        if (cellIdx === lastIdx) {
          return result2;
        }
      }
    }
    return result2;
  }
  normalizeCellsOrder(firstSelectedCell, lastSelectedCell) {
    return firstSelectedCell.startDate > lastSelectedCell.startDate ? [lastSelectedCell, firstSelectedCell] : [firstSelectedCell, lastSelectedCell];
  }
};

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space.js
var {
  tableCreator
} = m_table_creator_default;
var {
  abstract: abstract9
} = m_widget_observer_default;
var toMs22 = date_default.dateToMilliseconds;
var COMPONENT_CLASS3 = "dx-scheduler-work-space";
var GROUPED_WORKSPACE_CLASS = "dx-scheduler-work-space-grouped";
var VERTICAL_GROUPED_WORKSPACE_CLASS = "dx-scheduler-work-space-vertical-grouped";
var WORKSPACE_VERTICAL_GROUP_TABLE_CLASS = "dx-scheduler-work-space-vertical-group-table";
var WORKSPACE_WITH_BOTH_SCROLLS_CLASS = "dx-scheduler-work-space-both-scrollbar";
var WORKSPACE_WITH_COUNT_CLASS = "dx-scheduler-work-space-count";
var WORKSPACE_WITH_GROUP_BY_DATE_CLASS = "dx-scheduler-work-space-group-by-date";
var WORKSPACE_WITH_ODD_CELLS_CLASS = "dx-scheduler-work-space-odd-cells";
var TIME_PANEL_CELL_CLASS = "dx-scheduler-time-panel-cell";
var TIME_PANEL_ROW_CLASS = "dx-scheduler-time-panel-row";
var ALL_DAY_PANEL_CLASS = "dx-scheduler-all-day-panel";
var ALL_DAY_TABLE_CLASS = "dx-scheduler-all-day-table";
var ALL_DAY_CONTAINER_CLASS = "dx-scheduler-all-day-appointments";
var ALL_DAY_TITLE_CLASS = "dx-scheduler-all-day-title";
var ALL_DAY_TABLE_CELL_CLASS = "dx-scheduler-all-day-table-cell";
var ALL_DAY_TABLE_ROW_CLASS = "dx-scheduler-all-day-table-row";
var WORKSPACE_WITH_ALL_DAY_CLASS = "dx-scheduler-work-space-all-day";
var WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS = "dx-scheduler-work-space-all-day-collapsed";
var WORKSPACE_WITH_MOUSE_SELECTION_CLASS = "dx-scheduler-work-space-mouse-selection";
var HORIZONTAL_SIZES_CLASS = "dx-scheduler-cell-sizes-horizontal";
var VERTICAL_SIZES_CLASS = "dx-scheduler-cell-sizes-vertical";
var HEADER_PANEL_CLASS = "dx-scheduler-header-panel";
var HEADER_PANEL_CELL_CLASS = "dx-scheduler-header-panel-cell";
var HEADER_ROW_CLASS = "dx-scheduler-header-row";
var GROUP_HEADER_CLASS = "dx-scheduler-group-header";
var DATE_TABLE_CELL_CLASS2 = "dx-scheduler-date-table-cell";
var VIRTUAL_ROW_CLASS = "dx-scheduler-virtual-row";
var DATE_TABLE_DROPPABLE_CELL_CLASS = "dx-scheduler-date-table-droppable-cell";
var SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME = addNamespace2(pointer_default.down, "dxSchedulerWorkSpace");
var DragEventNames = {
  ENTER: addNamespace2(DRAG_ENTER_EVENT, "dxSchedulerDateTable"),
  DROP: addNamespace2(DROP_EVENT, "dxSchedulerDateTable"),
  LEAVE: addNamespace2(DRAG_LEAVE_EVENT, "dxSchedulerDateTable")
};
var SCHEDULER_CELL_DXCLICK_EVENT_NAME = addNamespace2(CLICK_EVENT_NAME, "dxSchedulerDateTable");
var SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME = addNamespace2(pointer_default.down, "dxSchedulerDateTable");
var SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME = addNamespace2(pointer_default.up, "dxSchedulerDateTable");
var SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME = addNamespace2(pointer_default.move, "dxSchedulerDateTable");
var CELL_DATA = "dxCellData";
var DAY_MS = toMs22("day");
var HOUR_MS = toMs22("hour");
var DRAG_AND_DROP_SELECTOR = `.${DATE_TABLE_CLASS} td, .${ALL_DAY_TABLE_CLASS} td`;
var CELL_SELECTOR = `.${DATE_TABLE_CELL_CLASS2}, .${ALL_DAY_TABLE_CELL_CLASS}`;
var DEFAULT_WORKSPACE_RENDER_OPTIONS = {
  renderComponents: {
    header: true,
    timePanel: true,
    dateTable: true,
    allDayPanel: true
  },
  generateNewData: true
};
var SchedulerWorkSpace = class extends m_widget_observer_default {
  constructor() {
    super(...arguments);
    this.viewDirection = "vertical";
  }
  get type() {
    return "";
  }
  get viewDataProvider() {
    if (!this._viewDataProvider) {
      this._viewDataProvider = new ViewDataProvider(this.type);
    }
    return this._viewDataProvider;
  }
  get cache() {
    if (!this._cache) {
      this._cache = new Cache2();
    }
    return this._cache;
  }
  get cellsSelectionState() {
    if (!this._cellsSelectionState) {
      this._cellsSelectionState = new CellsSelectionState(this.viewDataProvider);
      const selectedCellsOption = this.option("selectedCellData");
      if ((null === selectedCellsOption || void 0 === selectedCellsOption ? void 0 : selectedCellsOption.length) > 0) {
        const validSelectedCells = selectedCellsOption.map((selectedCell) => {
          const {
            groups
          } = selectedCell;
          if (!groups || 0 === this._getGroupCount()) {
            return _extends({}, selectedCell, {
              groupIndex: 0
            });
          }
          const groupIndex = this._getGroupIndexByResourceId(groups);
          return _extends({}, selectedCell, {
            groupIndex
          });
        });
        this._cellsSelectionState.setSelectedCellsByData(validSelectedCells);
      }
    }
    return this._cellsSelectionState;
  }
  get cellsSelectionController() {
    if (!this._cellsSelectionController) {
      this._cellsSelectionController = new CellsSelectionController();
    }
    return this._cellsSelectionController;
  }
  get isAllDayPanelVisible() {
    return this._isShowAllDayPanel() && this.supportAllDayRow();
  }
  get verticalGroupTableClass() {
    return WORKSPACE_VERTICAL_GROUP_TABLE_CLASS;
  }
  get renovatedHeaderPanelComponent() {
    return HeaderPanelComponent;
  }
  get timeZoneCalculator() {
    return this.option("timeZoneCalculator");
  }
  get isDefaultDraggingMode() {
    return "default" === this.option("draggingMode");
  }
  _supportedKeys() {
    const clickHandler2 = function(e) {
      e.preventDefault();
      e.stopPropagation();
      const selectedCells = this.cellsSelectionState.getSelectedCells();
      if (null !== selectedCells && void 0 !== selectedCells && selectedCells.length) {
        const selectedCellsElement = selectedCells.map((cellData) => this._getCellByData(cellData)).filter((cell) => !!cell);
        e.target = selectedCellsElement;
        this._showPopup = true;
        this._cellClickAction({
          event: e,
          cellElement: renderer_default(selectedCellsElement),
          cellData: selectedCells[0]
        });
      }
    };
    const onArrowPressed = (e, key) => {
      var _this$cellsSelectionS;
      e.preventDefault();
      e.stopPropagation();
      const focusedCellData = null === (_this$cellsSelectionS = this.cellsSelectionState.focusedCell) || void 0 === _this$cellsSelectionS ? void 0 : _this$cellsSelectionS.cellData;
      if (focusedCellData) {
        const isAllDayPanelCell = focusedCellData.allDay && !this._isVerticalGroupedWorkSpace();
        const isMultiSelection = e.shiftKey;
        const isMultiSelectionAllowed = this.option("allowMultipleCellSelection");
        const isRTL = this._isRTL();
        const groupCount = this._getGroupCount();
        const isGroupedByDate = this.isGroupedByDate();
        const isHorizontalGrouping = this._isHorizontalGroupedWorkSpace();
        const focusedCellPosition = this.viewDataProvider.findCellPositionInMap(_extends({}, focusedCellData, {
          isAllDay: focusedCellData.allDay
        }));
        const edgeIndices = isHorizontalGrouping && isMultiSelection && !isGroupedByDate ? this.viewDataProvider.getGroupEdgeIndices(focusedCellData.groupIndex, isAllDayPanelCell) : this.viewDataProvider.getViewEdgeIndices(isAllDayPanelCell);
        const nextCellData = this.cellsSelectionController.handleArrowClick({
          focusedCellPosition,
          edgeIndices,
          isRTL,
          isGroupedByDate,
          groupCount,
          isMultiSelection,
          isMultiSelectionAllowed,
          viewType: this.type,
          key,
          getCellDataByPosition: this.viewDataProvider.getCellData.bind(this.viewDataProvider),
          isAllDayPanelCell,
          focusedCellData
        });
        this._processNextSelectedCell(nextCellData, focusedCellData, isMultiSelection && isMultiSelectionAllowed);
      }
    };
    return extend(super._supportedKeys(), {
      enter: clickHandler2,
      space: clickHandler2,
      downArrow: (e) => {
        onArrowPressed(e, "down");
      },
      upArrow: (e) => {
        onArrowPressed(e, "up");
      },
      rightArrow: (e) => {
        onArrowPressed(e, "right");
      },
      leftArrow: (e) => {
        onArrowPressed(e, "left");
      }
    });
  }
  _isRTL() {
    return this.option("rtlEnabled");
  }
  _moveToCell($cell, isMultiSelection) {
    if (!isDefined($cell) || !$cell.length) {
      return;
    }
    const isMultiSelectionAllowed = this.option("allowMultipleCellSelection");
    const currentCellData = this._getFullCellData($cell);
    const focusedCellData = this.cellsSelectionState.focusedCell.cellData;
    const nextFocusedCellData = this.cellsSelectionController.moveToCell({
      isMultiSelection,
      isMultiSelectionAllowed,
      currentCellData,
      focusedCellData,
      isVirtualCell: $cell.hasClass(VIRTUAL_CELL_CLASS)
    });
    this._processNextSelectedCell(nextFocusedCellData, focusedCellData, isMultiSelectionAllowed && isMultiSelection);
  }
  _processNextSelectedCell(nextCellData, focusedCellData, isMultiSelection) {
    const nextCellPosition = this.viewDataProvider.findCellPositionInMap({
      startDate: nextCellData.startDate,
      groupIndex: nextCellData.groupIndex,
      isAllDay: nextCellData.allDay,
      index: nextCellData.index
    });
    if (!this.viewDataProvider.isSameCell(focusedCellData, nextCellData)) {
      const $cell = nextCellData.allDay && !this._isVerticalGroupedWorkSpace() ? this._dom_getAllDayPanelCell(nextCellPosition.columnIndex) : this._dom_getDateCell(nextCellPosition);
      const isNextCellAllDay = nextCellData.allDay;
      this._setSelectedCellsStateAndUpdateSelection(isNextCellAllDay, nextCellPosition, isMultiSelection, $cell);
      this._dateTableScrollable.scrollToElement($cell);
    }
  }
  _setSelectedCellsStateAndUpdateSelection(isAllDay, cellPosition, isMultiSelection, $nextFocusedCell) {
    const nextCellCoordinates = {
      rowIndex: cellPosition.rowIndex,
      columnIndex: cellPosition.columnIndex,
      allDay: isAllDay
    };
    this.cellsSelectionState.setFocusedCell(nextCellCoordinates.rowIndex, nextCellCoordinates.columnIndex, isAllDay);
    if (isMultiSelection) {
      this.cellsSelectionState.setSelectedCells(nextCellCoordinates);
    } else {
      this.cellsSelectionState.setSelectedCells(nextCellCoordinates, nextCellCoordinates);
    }
    this.updateCellsSelection();
    this._updateSelectedCellDataOption(this.cellsSelectionState.getSelectedCells(), $nextFocusedCell);
  }
  _hasAllDayClass($cell) {
    return $cell.hasClass(ALL_DAY_TABLE_CELL_CLASS);
  }
  _focusInHandler(e) {
    if (renderer_default(e.target).is(this._focusTarget()) && false !== this._isCellClick) {
      delete this._isCellClick;
      delete this._contextMenuHandled;
      super._focusInHandler.apply(this, arguments);
      this.cellsSelectionState.restoreSelectedAndFocusedCells();
      if (!this.cellsSelectionState.focusedCell) {
        const cellCoordinates = {
          columnIndex: 0,
          rowIndex: 0,
          allDay: this._isVerticalGroupedWorkSpace() && this.isAllDayPanelVisible
        };
        this.cellsSelectionState.setFocusedCell(cellCoordinates.rowIndex, cellCoordinates.columnIndex, cellCoordinates.allDay);
        this.cellsSelectionState.setSelectedCells(cellCoordinates, cellCoordinates);
      }
      this.updateCellsSelection();
      this._updateSelectedCellDataOption(this.cellsSelectionState.getSelectedCells());
    }
  }
  _focusOutHandler() {
    super._focusOutHandler.apply(this, arguments);
    if (!this._contextMenuHandled && !this._disposed) {
      this.cellsSelectionState.releaseSelectedAndFocusedCells();
      this.viewDataProvider.updateViewData(this.generateRenderOptions());
      this.updateCellsSelection();
    }
  }
  _focusTarget() {
    return this.$element();
  }
  _isVerticalGroupedWorkSpace() {
    var _this$option;
    return !!(null !== (_this$option = this.option("groups")) && void 0 !== _this$option && _this$option.length) && "vertical" === this.option("groupOrientation");
  }
  _isHorizontalGroupedWorkSpace() {
    var _this$option2;
    return !!(null !== (_this$option2 = this.option("groups")) && void 0 !== _this$option2 && _this$option2.length) && "horizontal" === this.option("groupOrientation");
  }
  _isWorkSpaceWithCount() {
    return this.option("intervalCount") > 1;
  }
  _isWorkspaceWithOddCells() {
    return 0.5 === this.option("hoursInterval") && !this.isVirtualScrolling();
  }
  _getRealGroupOrientation() {
    return this._isVerticalGroupedWorkSpace() ? "vertical" : "horizontal";
  }
  createRAllDayPanelElements() {
    this._$allDayPanel = renderer_default("<div>").addClass(ALL_DAY_PANEL_CLASS);
    this._$allDayTitle = renderer_default("<div>").appendTo(this._$headerPanelEmptyCell);
  }
  _dateTableScrollableConfig() {
    let config3 = {
      useKeyboard: false,
      bounceEnabled: false,
      updateManually: true,
      onScroll: () => {
        var _this$_groupedStrateg;
        null === (_this$_groupedStrateg = this._groupedStrategy.cache) || void 0 === _this$_groupedStrateg || _this$_groupedStrateg.clear();
      }
    };
    if (this._needCreateCrossScrolling()) {
      config3 = extend(config3, this._createCrossScrollingConfig(config3));
    }
    if (this.isVirtualScrolling() && (this.virtualScrollingDispatcher.horizontalScrollingAllowed || this.virtualScrollingDispatcher.height)) {
      const currentOnScroll = config3.onScroll;
      config3 = _extends({}, config3, {
        onScroll: (e) => {
          null === currentOnScroll || void 0 === currentOnScroll || currentOnScroll(e);
          this.virtualScrollingDispatcher.handleOnScrollEvent(null === e || void 0 === e ? void 0 : e.scrollOffset);
        }
      });
    }
    return config3;
  }
  _createCrossScrollingConfig(_ref) {
    let {
      onScroll
    } = _ref;
    return {
      direction: "both",
      onScroll: (event) => {
        null === onScroll || void 0 === onScroll || onScroll();
        this._scrollSync.sidebar({
          top: event.scrollOffset.top
        });
        this._scrollSync.header({
          left: event.scrollOffset.left
        });
      },
      onEnd: () => {
        this.option("onScrollEnd")();
      }
    };
  }
  _headerScrollableConfig() {
    return {
      useKeyboard: false,
      showScrollbar: "never",
      direction: "horizontal",
      useNative: false,
      updateManually: true,
      bounceEnabled: false,
      onScroll: (event) => {
        this._scrollSync.dateTable({
          left: event.scrollOffset.left
        });
      }
    };
  }
  _visibilityChanged(visible2) {
    this.cache.clear();
    if (visible2) {
      this._updateGroupTableHeight();
    }
    if (visible2 && this._needCreateCrossScrolling()) {
      this._setTableSizes();
    }
  }
  _setTableSizes() {
    this.cache.clear();
    this._attachTableClasses();
    let cellWidth = this.getCellWidth();
    if (cellWidth < this.getCellMinWidth()) {
      cellWidth = this.getCellMinWidth();
    }
    const minWidth = this.getWorkSpaceMinWidth();
    const groupCount = this._getGroupCount();
    const totalCellCount = this._getTotalCellCount(groupCount);
    let width = cellWidth * totalCellCount;
    if (width < minWidth) {
      width = minWidth;
    }
    setWidth(this._$headerPanel, width);
    setWidth(this._$dateTable, width);
    if (this._$allDayTable) {
      setWidth(this._$allDayTable, width);
    }
    this._attachHeaderTableClasses();
    this._updateGroupTableHeight();
    this._updateScrollable();
  }
  getWorkSpaceMinWidth() {
    return this._groupedStrategy.getWorkSpaceMinWidth();
  }
  _dimensionChanged() {
    if (!this._isVisible()) {
      return;
    }
    if (this.option("crossScrollingEnabled")) {
      this._setTableSizes();
    }
    this.updateHeaderEmptyCellWidth();
    this._updateScrollable();
    this.cache.clear();
  }
  _needCreateCrossScrolling() {
    return this.option("crossScrollingEnabled");
  }
  _getElementClass() {
    return noop2();
  }
  _getRowCount() {
    return this.viewDataProvider.getRowCount({
      intervalCount: this.option("intervalCount"),
      currentDate: this.option("currentDate"),
      viewType: this.type,
      hoursInterval: this.option("hoursInterval"),
      startDayHour: this.option("startDayHour"),
      endDayHour: this.option("endDayHour")
    });
  }
  _getCellCount() {
    return this.viewDataProvider.getCellCount({
      intervalCount: this.option("intervalCount"),
      currentDate: this.option("currentDate"),
      viewType: this.type,
      hoursInterval: this.option("hoursInterval"),
      startDayHour: this.option("startDayHour"),
      endDayHour: this.option("endDayHour")
    });
  }
  isRenovatedRender() {
    return this.renovatedRenderSupported() && this.option("renovateRender");
  }
  _isVirtualModeOn() {
    return "virtual" === this.option("scrolling.mode");
  }
  isVirtualScrolling() {
    return this.isRenovatedRender() && this._isVirtualModeOn();
  }
  _initVirtualScrolling() {
    if (this.virtualScrollingDispatcher) {
      this.virtualScrollingDispatcher.dispose();
      this.virtualScrollingDispatcher = null;
    }
    this.virtualScrollingDispatcher = new VirtualScrollingDispatcher(this._getVirtualScrollingDispatcherOptions());
    this.virtualScrollingDispatcher.attachScrollableEvents();
    this.renderer = new VirtualScrollingRenderer(this);
  }
  onDataSourceChanged(argument) {
  }
  isGroupedAllDayPanel() {
    return calculateIsGroupedAllDayPanel(this.option("groups"), this.option("groupOrientation"), this.isAllDayPanelVisible);
  }
  generateRenderOptions(isProvideVirtualCellsWidth) {
    var _this$_getToday;
    const groupCount = this._getGroupCount();
    const groupOrientation = groupCount > 0 ? this.option("groupOrientation") : this._getDefaultGroupStrategy();
    const options2 = _extends({
      groupByDate: this.option("groupByDate"),
      startRowIndex: 0,
      startCellIndex: 0,
      groupOrientation,
      today: null === (_this$_getToday = this._getToday) || void 0 === _this$_getToday ? void 0 : _this$_getToday.call(this),
      groups: this.option("groups"),
      isProvideVirtualCellsWidth,
      isAllDayPanelVisible: this.isAllDayPanelVisible,
      selectedCells: this.cellsSelectionState.getSelectedCells(),
      focusedCell: this.cellsSelectionState.focusedCell,
      headerCellTextFormat: this._getFormat(),
      getDateForHeaderText: (_, date) => date,
      viewOffset: this.option("viewOffset"),
      startDayHour: this.option("startDayHour"),
      endDayHour: this.option("endDayHour"),
      cellDuration: this.getCellDuration(),
      viewType: this.type,
      intervalCount: this.option("intervalCount"),
      hoursInterval: this.option("hoursInterval"),
      currentDate: this.option("currentDate"),
      startDate: this.option("startDate"),
      firstDayOfWeek: this.option("firstDayOfWeek"),
      showCurrentTimeIndicator: this.option("showCurrentTimeIndicator")
    }, this.virtualScrollingDispatcher.getRenderState());
    return options2;
  }
  renovatedRenderSupported() {
    return true;
  }
  _updateGroupTableHeight() {
    if (this._isVerticalGroupedWorkSpace() && hasWindow()) {
      this._setHorizontalGroupHeaderCellsHeight();
    }
  }
  updateHeaderEmptyCellWidth() {
    if (hasWindow() && this._isRenderHeaderPanelEmptyCell()) {
      const timePanelWidth = this.getTimePanelWidth();
      const groupPanelWidth = this.getGroupTableWidth();
      this._$headerPanelEmptyCell.css("width", timePanelWidth + groupPanelWidth);
    }
  }
  _isGroupsSpecified(resources) {
    var _this$option3;
    return (null === (_this$option3 = this.option("groups")) || void 0 === _this$option3 ? void 0 : _this$option3.length) && resources;
  }
  _getGroupIndexByResourceId(id) {
    const groups = this.option("groups");
    const resourceTree = createResourcesTree(groups);
    if (!resourceTree.length) {
      return 0;
    }
    return this._getGroupIndexRecursively(resourceTree, id);
  }
  _getGroupIndexRecursively(resourceTree, id) {
    const currentKey = resourceTree[0].name;
    const currentValue = id[currentKey];
    return resourceTree.reduce((prevIndex, _ref2) => {
      let {
        leafIndex,
        value: value2,
        children
      } = _ref2;
      const areValuesEqual = currentValue === value2;
      if (areValuesEqual && void 0 !== leafIndex) {
        return leafIndex;
      }
      if (areValuesEqual) {
        return this._getGroupIndexRecursively(children, id);
      }
      return prevIndex;
    }, 0);
  }
  _getViewStartByOptions() {
    return getViewStartByOptions(this.option("startDate"), this.option("currentDate"), this._getIntervalDuration(), this.option("startDate") ? this._calculateViewStartDate() : void 0);
  }
  _getIntervalDuration() {
    return this.viewDataProvider.getIntervalDuration(this.option("intervalCount"));
  }
  _getHeaderDate() {
    return this.getStartViewDate();
  }
  _calculateViewStartDate() {
    return calculateViewStartDate(this.option("startDate"));
  }
  _firstDayOfWeek() {
    return this.viewDataProvider.getFirstDayOfWeek(this.option("firstDayOfWeek"));
  }
  _attachEvents() {
    this._createSelectionChangedAction();
    this._attachClickEvent();
    this._attachContextMenuEvent();
  }
  _attachClickEvent() {
    const that = this;
    const pointerDownAction = this._createAction((e) => {
      that._pointerDownHandler(e.event);
    });
    this._createCellClickAction();
    const cellSelector = `.${DATE_TABLE_CELL_CLASS2},.${ALL_DAY_TABLE_CELL_CLASS}`;
    const $element = this.$element();
    events_engine_default.off($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME);
    events_engine_default.off($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME);
    events_engine_default.on($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME, (e) => {
      if (isMouseEvent(e) && e.which > 1) {
        e.preventDefault();
        return;
      }
      pointerDownAction({
        event: e
      });
    });
    events_engine_default.on($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME, cellSelector, (e) => {
      const $cell = renderer_default(e.target);
      that._cellClickAction({
        event: e,
        cellElement: getPublicElement($cell),
        cellData: that.getCellData($cell)
      });
    });
  }
  _createCellClickAction() {
    this._cellClickAction = this._createActionByOption("onCellClick", {
      afterExecute: (e) => this._cellClickHandler(e.args[0].event)
    });
  }
  _createSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged");
  }
  _cellClickHandler(argument) {
    if (this._showPopup) {
      delete this._showPopup;
      this._handleSelectedCellsClick();
    }
  }
  _pointerDownHandler(e) {
    const $target = renderer_default(e.target);
    if (!$target.hasClass(DATE_TABLE_CELL_CLASS2) && !$target.hasClass(ALL_DAY_TABLE_CELL_CLASS)) {
      this._isCellClick = false;
      return;
    }
    this._isCellClick = true;
    if ($target.hasClass("dx-scheduler-focused-cell")) {
      this._showPopup = true;
    } else {
      const cellCoordinates = this._getCoordinatesByCell($target);
      const isAllDayCell = this._hasAllDayClass($target);
      this._setSelectedCellsStateAndUpdateSelection(isAllDayCell, cellCoordinates, false, $target);
    }
  }
  _handleSelectedCellsClick() {
    const selectedCells = this.cellsSelectionState.getSelectedCells();
    const firstCellData = selectedCells[0];
    const lastCellData = selectedCells[selectedCells.length - 1];
    const result2 = {
      startDate: firstCellData.startDate,
      endDate: lastCellData.endDate
    };
    if (void 0 !== lastCellData.allDay) {
      result2.allDay = lastCellData.allDay;
    }
    this.option("onSelectedCellsClick")(result2, lastCellData.groups);
  }
  _attachContextMenuEvent() {
    this._createContextMenuAction();
    const cellSelector = `.${DATE_TABLE_CELL_CLASS2},.${ALL_DAY_TABLE_CELL_CLASS}`;
    const $element = this.$element();
    const eventName = addNamespace2(name, this.NAME);
    events_engine_default.off($element, eventName, cellSelector);
    events_engine_default.on($element, eventName, cellSelector, this._contextMenuHandler.bind(this));
  }
  _contextMenuHandler(e) {
    const $cell = renderer_default(e.target);
    this._contextMenuAction({
      event: e,
      cellElement: getPublicElement($cell),
      cellData: this.getCellData($cell)
    });
    this._contextMenuHandled = true;
  }
  _createContextMenuAction() {
    this._contextMenuAction = this._createActionByOption("onCellContextMenu");
  }
  _getGroupHeaderContainer() {
    if (this._isVerticalGroupedWorkSpace()) {
      return this._$groupTable;
    }
    return this._$thead;
  }
  _getDateHeaderContainer() {
    return this._$thead;
  }
  _getCalculateHeaderCellRepeatCount() {
    return this._groupedStrategy.calculateHeaderCellRepeatCount();
  }
  _updateScrollable() {
    var _this$_headerScrollab, _this$_sidebarScrolla;
    this._dateTableScrollable.update();
    null === (_this$_headerScrollab = this._headerScrollable) || void 0 === _this$_headerScrollab || _this$_headerScrollab.update();
    null === (_this$_sidebarScrolla = this._sidebarScrollable) || void 0 === _this$_sidebarScrolla || _this$_sidebarScrolla.update();
  }
  _getTimePanelRowCount() {
    return this._getCellCountInDay();
  }
  _getCellCountInDay() {
    const hoursInterval = this.option("hoursInterval");
    const startDayHour = this.option("startDayHour");
    const endDayHour = this.option("endDayHour");
    return this.viewDataProvider.getCellCountInDay(startDayHour, endDayHour, hoursInterval);
  }
  _getTotalCellCount(groupCount) {
    return this._groupedStrategy.getTotalCellCount(groupCount);
  }
  _getTotalRowCount(groupCount, includeAllDayPanelRows) {
    let result2 = this._groupedStrategy.getTotalRowCount(groupCount);
    if (includeAllDayPanelRows && this.isAllDayPanelVisible) {
      result2 += groupCount;
    }
    return result2;
  }
  _getGroupIndex(rowIndex, columnIndex) {
    return this._groupedStrategy.getGroupIndex(rowIndex, columnIndex);
  }
  calculateEndDate(startDate) {
    const {
      viewDataGenerator
    } = this.viewDataProvider;
    return viewDataGenerator.calculateEndDate(startDate, viewDataGenerator.getInterval(this.option("hoursInterval")), this.option("endDayHour"));
  }
  _getGroupCount() {
    return getGroupCount(this.option("groups"));
  }
  _attachTablesEvents() {
    const element = this.$element();
    this._attachDragEvents(element);
    this._attachPointerEvents(element);
  }
  _detachDragEvents(element) {
    events_engine_default.off(element, DragEventNames.ENTER);
    events_engine_default.off(element, DragEventNames.LEAVE);
    events_engine_default.off(element, DragEventNames.DROP);
  }
  _attachDragEvents(element) {
    this._detachDragEvents(element);
    events_engine_default.on(element, DragEventNames.ENTER, DRAG_AND_DROP_SELECTOR, {
      checkDropTarget: (target, event) => !this._isOutsideScrollable(target, event)
    }, (e) => {
      if (!this.preventDefaultDragging) {
        this.removeDroppableCellClass();
        renderer_default(e.target).addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
      }
    });
    events_engine_default.on(element, DragEventNames.LEAVE, () => {
      if (!this.preventDefaultDragging) {
        this.removeDroppableCellClass();
      }
    });
    events_engine_default.on(element, DragEventNames.DROP, DRAG_AND_DROP_SELECTOR, () => {
      var _this$dragBehavior, _this$dragBehavior$dr;
      if (!this.dragBehavior) {
        return;
      }
      if (!(null !== (_this$dragBehavior = this.dragBehavior) && void 0 !== _this$dragBehavior && _this$dragBehavior.dragBetweenComponentsPromise)) {
        this.dragBehavior.removeDroppableClasses();
        return;
      }
      null === (_this$dragBehavior$dr = this.dragBehavior.dragBetweenComponentsPromise) || void 0 === _this$dragBehavior$dr || _this$dragBehavior$dr.then(() => {
        this.dragBehavior.removeDroppableClasses();
      });
    });
  }
  _attachPointerEvents(element) {
    let isPointerDown = false;
    events_engine_default.off(element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME);
    events_engine_default.off(element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME);
    events_engine_default.on(element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME, DRAG_AND_DROP_SELECTOR, (e) => {
      if (isMouseEvent(e) && 1 === e.which) {
        isPointerDown = true;
        this.$element().addClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);
        events_engine_default.off(dom_adapter_default.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);
        events_engine_default.on(dom_adapter_default.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME, () => {
          isPointerDown = false;
          this.$element().removeClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);
        });
      }
    });
    events_engine_default.on(element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME, DRAG_AND_DROP_SELECTOR, (e) => {
      if (isPointerDown && this._dateTableScrollable && !this._dateTableScrollable.option("scrollByContent")) {
        e.preventDefault();
        e.stopPropagation();
        this._moveToCell(renderer_default(e.target), true);
      }
    });
  }
  _getFormat() {
    return abstract9();
  }
  getWorkArea() {
    return this._$dateTableContainer;
  }
  getScrollable() {
    return this._dateTableScrollable;
  }
  getScrollableScrollTop() {
    return this._dateTableScrollable.scrollTop();
  }
  getGroupedScrollableScrollTop(allDay) {
    return this._groupedStrategy.getScrollableScrollTop(allDay);
  }
  getScrollableScrollLeft() {
    return this._dateTableScrollable.scrollLeft();
  }
  getScrollableOuterWidth() {
    return this._dateTableScrollable.scrollWidth();
  }
  getScrollableContainer() {
    return renderer_default(this._dateTableScrollable.container());
  }
  getHeaderPanelHeight() {
    return this._$headerPanel && getOuterHeight(this._$headerPanel, true);
  }
  getTimePanelWidth() {
    return this._$timePanel && getBoundingRect(this._$timePanel.get(0)).width;
  }
  getGroupTableWidth() {
    return this._$groupTable ? getOuterWidth(this._$groupTable) : 0;
  }
  getWorkSpaceLeftOffset() {
    return this._groupedStrategy.getLeftOffset();
  }
  _getCellCoordinatesByIndex(index2) {
    const columnIndex = Math.floor(index2 / this._getRowCount());
    const rowIndex = index2 - this._getRowCount() * columnIndex;
    return {
      columnIndex,
      rowIndex
    };
  }
  _getDateGenerationOptions() {
    var _this$viewDataProvide;
    return {
      startDayHour: this.option("startDayHour"),
      endDayHour: this.option("endDayHour"),
      isWorkView: this.viewDataProvider.viewDataGenerator.isWorkView,
      interval: null === (_this$viewDataProvide = this.viewDataProvider.viewDataGenerator) || void 0 === _this$viewDataProvide ? void 0 : _this$viewDataProvide.getInterval(this.option("hoursInterval")),
      startViewDate: this.getStartViewDate(),
      firstDayOfWeek: this._firstDayOfWeek()
    };
  }
  _getIntervalBetween(currentDate, allDay) {
    const firstViewDate = this.getStartViewDate();
    const startDayTime = this.option("startDayHour") * HOUR_MS;
    const timeZoneOffset = date_default.getTimezonesDifference(firstViewDate, currentDate);
    const fullInterval = currentDate.getTime() - firstViewDate.getTime() - timeZoneOffset;
    const days3 = this._getDaysOfInterval(fullInterval, startDayTime);
    const weekendsCount = this._getWeekendsCount(days3);
    let result2 = (days3 - weekendsCount) * DAY_MS;
    if (!allDay) {
      const {
        hiddenInterval
      } = this.viewDataProvider;
      const visibleDayDuration = this.getVisibleDayDuration();
      result2 = fullInterval - days3 * hiddenInterval - weekendsCount * visibleDayDuration;
    }
    return result2;
  }
  _getWeekendsCount(argument) {
    return 0;
  }
  _getDaysOfInterval(fullInterval, startDayTime) {
    return Math.floor((fullInterval + startDayTime) / DAY_MS);
  }
  _updateIndex(index2) {
    return index2 * this._getRowCount();
  }
  _getDroppableCell() {
    return this._getDateTables().find(`.${DATE_TABLE_DROPPABLE_CELL_CLASS}`);
  }
  _getWorkSpaceWidth() {
    return this.cache.get("workspaceWidth", () => {
      if (this._needCreateCrossScrolling()) {
        return getBoundingRect(this._$dateTable.get(0)).width;
      }
      const totalWidth = getBoundingRect(this.$element().get(0)).width;
      const timePanelWidth = this.getTimePanelWidth();
      const groupTableWidth = this.getGroupTableWidth();
      return totalWidth - timePanelWidth - groupTableWidth;
    });
  }
  _getCellByCoordinates(cellCoordinates, groupIndex, inAllDayRow) {
    const indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex, inAllDayRow);
    return this._dom_getDateCell(indexes);
  }
  _dom_getDateCell(position3) {
    return this._$dateTable.find(`tr:not(.${VIRTUAL_ROW_CLASS})`).eq(position3.rowIndex).find(`td:not(.${VIRTUAL_CELL_CLASS})`).eq(position3.columnIndex);
  }
  _dom_getAllDayPanelCell(columnIndex) {
    return this._$allDayPanel.find("tr").eq(0).find("td").eq(columnIndex);
  }
  _getCells(allDay, direction) {
    const cellClass = allDay ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS2;
    if ("vertical" === direction) {
      let result2 = [];
      for (let i = 1; ; i++) {
        const cells = this.$element().find(`tr .${cellClass}:nth-child(${i})`);
        if (!cells.length) {
          break;
        }
        result2 = result2.concat(cells.toArray());
      }
      return renderer_default(result2);
    }
    return this.$element().find(`.${cellClass}`);
  }
  _getFirstAndLastDataTableCell() {
    const selector = this.isVirtualScrolling() ? `.${DATE_TABLE_CELL_CLASS2}, .${VIRTUAL_CELL_CLASS}` : `.${DATE_TABLE_CELL_CLASS2}`;
    const $cells = this.$element().find(selector);
    return [$cells[0], $cells[$cells.length - 1]];
  }
  _getAllCells(allDay) {
    if (this._isVerticalGroupedWorkSpace()) {
      return this._$dateTable.find(`td:not(.${VIRTUAL_CELL_CLASS})`);
    }
    const cellClass = allDay && this.supportAllDayRow() ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS2;
    return this.$element().find(`.${cellClass}`);
  }
  _setHorizontalGroupHeaderCellsHeight() {
    const {
      height
    } = getBoundingRect(this._$dateTable.get(0));
    setOuterHeight(this._$groupTable, height);
  }
  _getGroupHeaderCells() {
    return this.$element().find(`.${GROUP_HEADER_CLASS}`);
  }
  _getScrollCoordinates(hours, minutes, date, groupIndex, allDay) {
    const currentDate = date || new Date(this.option("currentDate"));
    const startDayHour = this.option("startDayHour");
    const endDayHour = this.option("endDayHour");
    if (hours < startDayHour) {
      hours = startDayHour;
    }
    if (hours >= endDayHour) {
      hours = endDayHour - 1;
    }
    currentDate.setHours(hours, minutes, 0, 0);
    const cell = this.viewDataProvider.findGlobalCellPosition(currentDate, groupIndex, allDay);
    const {
      position: position3,
      cellData
    } = cell;
    return this.virtualScrollingDispatcher.calculateCoordinatesByDataAndPosition(cellData, position3, currentDate, isDateAndTimeView(this.type), "vertical" === this.viewDirection);
  }
  _isOutsideScrollable(target, event) {
    const $dateTableScrollableElement = this._dateTableScrollable.$element();
    const scrollableSize = getBoundingRect($dateTableScrollableElement.get(0));
    const window28 = getWindow();
    const isTargetInAllDayPanel = !renderer_default(target).closest($dateTableScrollableElement).length;
    const isOutsideHorizontalScrollable = event.pageX < scrollableSize.left || event.pageX > scrollableSize.left + scrollableSize.width + (window28.scrollX || 0);
    const isOutsideVerticalScrollable = event.pageY < scrollableSize.top || event.pageY > scrollableSize.top + scrollableSize.height + (window28.scrollY || 0);
    if (isTargetInAllDayPanel && !isOutsideHorizontalScrollable) {
      return false;
    }
    return isOutsideVerticalScrollable || isOutsideHorizontalScrollable;
  }
  setCellDataCache(cellCoordinates, groupIndex, $cell) {
    const key = JSON.stringify({
      rowIndex: cellCoordinates.rowIndex,
      columnIndex: cellCoordinates.columnIndex,
      groupIndex
    });
    this.cache.set(key, this.getCellData($cell));
  }
  setCellDataCacheAlias(appointment, geometry) {
    const key = JSON.stringify({
      rowIndex: appointment.rowIndex,
      columnIndex: appointment.columnIndex,
      groupIndex: appointment.groupIndex
    });
    const aliasKey = JSON.stringify({
      top: geometry.top,
      left: geometry.left
    });
    this.cache.set(aliasKey, this.cache.get(key));
  }
  supportAllDayRow() {
    return true;
  }
  keepOriginalHours() {
    return false;
  }
  _filterCellDataFields(cellData) {
    return extend(true, {}, {
      startDate: cellData.startDate,
      endDate: cellData.endDate,
      groups: cellData.groups,
      groupIndex: cellData.groupIndex,
      allDay: cellData.allDay
    });
  }
  getCellData($cell) {
    const cellData = this._getFullCellData($cell) || {};
    return this._filterCellDataFields(cellData);
  }
  _getFullCellData($cell) {
    const currentCell = $cell[0];
    if (currentCell) {
      return this._getDataByCell($cell);
    }
    return;
  }
  _getVirtualRowOffset() {
    return this.virtualScrollingDispatcher.virtualRowOffset;
  }
  _getVirtualCellOffset() {
    return this.virtualScrollingDispatcher.virtualCellOffset;
  }
  _getDataByCell($cell) {
    const rowIndex = $cell.parent().index() - this.virtualScrollingDispatcher.topVirtualRowsCount;
    const columnIndex = $cell.index() - this.virtualScrollingDispatcher.leftVirtualCellsCount;
    const {
      viewDataProvider
    } = this;
    const isAllDayCell = this._hasAllDayClass($cell);
    const cellData = viewDataProvider.getCellData(rowIndex, columnIndex, isAllDayCell);
    return cellData || void 0;
  }
  isGroupedByDate() {
    return this.option("groupByDate") && this._isHorizontalGroupedWorkSpace() && this._getGroupCount() > 0;
  }
  getCellIndexByDate(date, inAllDayRow) {
    const {
      viewDataGenerator
    } = this.viewDataProvider;
    const timeInterval = inAllDayRow ? 864e5 : viewDataGenerator.getInterval(this.option("hoursInterval"));
    const startViewDateOffset = getStartViewDateTimeOffset(this.getStartViewDate(), this.option("startDayHour"));
    const dateTimeStamp = this._getIntervalBetween(date, inAllDayRow) + startViewDateOffset;
    let index2 = Math.floor(dateTimeStamp / timeInterval);
    if (inAllDayRow) {
      index2 = this._updateIndex(index2);
    }
    if (index2 < 0) {
      index2 = 0;
    }
    return index2;
  }
  getDroppableCellIndex() {
    const $droppableCell = this._getDroppableCell();
    const $row = $droppableCell.parent();
    const rowIndex = $row.index();
    return rowIndex * $row.find("td").length + $droppableCell.index();
  }
  getDataByDroppableCell() {
    const cellData = this.getCellData(renderer_default(this._getDroppableCell()));
    const {
      allDay
    } = cellData;
    const {
      startDate
    } = cellData;
    const {
      endDate
    } = cellData;
    return {
      startDate,
      endDate,
      allDay,
      groups: cellData.groups
    };
  }
  getDateRange() {
    return [this.getStartViewDate(), this.getEndViewDateByEndDayHour()];
  }
  getCellMinWidth() {
    return 75;
  }
  getRoundedCellWidth(groupIndex, startIndex, cellCount) {
    if (groupIndex < 0 || !hasWindow()) {
      return 0;
    }
    const $row = this.$element().find(`.${DATE_TABLE_ROW_CLASS}`).eq(0);
    let width = 0;
    const $cells = $row.find(`.${DATE_TABLE_CELL_CLASS2}`);
    const totalCellCount = this._getCellCount() * groupIndex;
    cellCount = cellCount || this._getCellCount();
    if (!isDefined(startIndex)) {
      startIndex = totalCellCount;
    }
    for (let i = startIndex; i < totalCellCount + cellCount; i++) {
      const element = renderer_default($cells).eq(i).get(0);
      const elementWidth = element ? getBoundingRect(element).width : 0;
      width += elementWidth;
    }
    return width / (totalCellCount + cellCount - startIndex);
  }
  getCellWidth() {
    return getCellWidth(this.getDOMElementsMetaData());
  }
  getCellHeight() {
    return getCellHeight(this.getDOMElementsMetaData());
  }
  getAllDayHeight() {
    return getAllDayHeight(this.option("showAllDayPanel"), this._isVerticalGroupedWorkSpace(), this.getDOMElementsMetaData());
  }
  getMaxAllowedPosition(groupIndex) {
    return getMaxAllowedPosition(groupIndex, this.viewDataProvider, this.option("rtlEnabled"), this.getDOMElementsMetaData());
  }
  getAllDayOffset() {
    return this._groupedStrategy.getAllDayOffset();
  }
  getCellIndexByCoordinates(coordinates, allDay) {
    const {
      horizontalScrollingState,
      verticalScrollingState
    } = this.virtualScrollingDispatcher;
    const cellCount = (null === horizontalScrollingState || void 0 === horizontalScrollingState ? void 0 : horizontalScrollingState.itemCount) ?? this._getTotalCellCount(this._getGroupCount());
    const cellWidth = this.getCellWidth();
    const cellHeight = allDay ? this.getAllDayHeight() : this.getCellHeight();
    const leftCoordinateOffset = (null === horizontalScrollingState || void 0 === horizontalScrollingState ? void 0 : horizontalScrollingState.virtualItemSizeBefore) ?? 0;
    const topCoordinateOffset = (null === verticalScrollingState || void 0 === verticalScrollingState ? void 0 : verticalScrollingState.virtualItemSizeBefore) ?? 0;
    const topIndex = Math.floor(Math.floor(coordinates.top - topCoordinateOffset) / Math.floor(cellHeight));
    let leftIndex = (coordinates.left - leftCoordinateOffset) / cellWidth;
    leftIndex = Math.floor(leftIndex + 0.05);
    if (this._isRTL()) {
      leftIndex = cellCount - leftIndex - 1;
    }
    return cellCount * topIndex + leftIndex;
  }
  getStartViewDate() {
    return this.viewDataProvider.getStartViewDate();
  }
  getEndViewDate() {
    return this.viewDataProvider.getLastCellEndDate();
  }
  getEndViewDateByEndDayHour() {
    return this.viewDataProvider.getLastViewDateByEndDayHour(this.option("endDayHour"));
  }
  getCellDuration() {
    return getCellDuration(this.type, this.option("startDayHour"), this.option("endDayHour"), this.option("hoursInterval"));
  }
  getIntervalDuration(allDay) {
    return allDay ? toMs22("day") : this.getCellDuration();
  }
  getVisibleDayDuration() {
    const startDayHour = this.option("startDayHour");
    const endDayHour = this.option("endDayHour");
    const hoursInterval = this.option("hoursInterval");
    return this.viewDataProvider.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);
  }
  getGroupBounds(coordinates) {
    const groupBounds = this._groupedStrategy instanceof m_work_space_grouped_strategy_vertical_default ? this.getGroupBoundsVertical(coordinates.groupIndex) : this.getGroupBoundsHorizontal(coordinates);
    return this._isRTL() ? this.getGroupBoundsRtlCorrection(groupBounds) : groupBounds;
  }
  getGroupBoundsVertical(groupIndex) {
    const $firstAndLastCells = this._getFirstAndLastDataTableCell();
    return this._groupedStrategy.getGroupBoundsOffset(groupIndex, $firstAndLastCells);
  }
  getGroupBoundsHorizontal(coordinates) {
    const cellCount = this._getCellCount();
    const $cells = this._getCells();
    const cellWidth = this.getCellWidth();
    const {
      groupedDataMap
    } = this.viewDataProvider;
    return this._groupedStrategy.getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap);
  }
  getGroupBoundsRtlCorrection(groupBounds) {
    const cellWidth = this.getCellWidth();
    return _extends({}, groupBounds, {
      left: groupBounds.right - 2 * cellWidth,
      right: groupBounds.left + 2 * cellWidth
    });
  }
  needRecalculateResizableArea() {
    return this._isVerticalGroupedWorkSpace() && 0 !== this.getScrollable().scrollTop();
  }
  getCellDataByCoordinates(coordinates, allDay) {
    const key = JSON.stringify({
      top: coordinates.top,
      left: coordinates.left
    });
    return this.cache.get(key, () => {
      const $cells = this._getCells(allDay);
      const cellIndex = this.getCellIndexByCoordinates(coordinates, allDay);
      const $cell = $cells.eq(cellIndex);
      return this.getCellData($cell);
    });
  }
  getVisibleBounds() {
    const result2 = {};
    const $scrollable = this.getScrollable().$element();
    const cellHeight = this.getCellHeight();
    const scrolledCellCount = this.getScrollableScrollTop() / cellHeight;
    const totalCellCount = scrolledCellCount + getHeight($scrollable) / cellHeight;
    result2.top = {
      hours: Math.floor(scrolledCellCount * this.option("hoursInterval")) + this.option("startDayHour"),
      minutes: scrolledCellCount % 2 ? 30 : 0
    };
    result2.bottom = {
      hours: Math.floor(totalCellCount * this.option("hoursInterval")) + this.option("startDayHour"),
      minutes: Math.floor(totalCellCount) % 2 ? 30 : 0
    };
    return result2;
  }
  updateScrollPosition(date, groups) {
    let allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    const newDate = this.timeZoneCalculator.createDate(date, {
      path: "toGrid"
    });
    const inAllDayRow = allDay && this.isAllDayPanelVisible;
    if (this.needUpdateScrollPosition(newDate, groups, inAllDayRow)) {
      this.scrollTo(newDate, groups, inAllDayRow, false);
    }
  }
  needUpdateScrollPosition(date, groups, inAllDayRow) {
    const cells = this._getCellsInViewport(inAllDayRow);
    const groupIndex = this._isGroupsSpecified(groups) ? this._getGroupIndexByResourceId(groups) : 0;
    const time = date.getTime();
    const trimmedTime = date_default.trimTime(date).getTime();
    return cells.reduce((currentResult, cell) => {
      const {
        startDate: cellStartDate,
        endDate: cellEndDate,
        groupIndex: cellGroupIndex
      } = this.getCellData(cell);
      const cellStartTime = cellStartDate.getTime();
      const cellEndTime = cellEndDate.getTime();
      if ((!inAllDayRow && cellStartTime <= time && time < cellEndTime || inAllDayRow && trimmedTime === cellStartTime) && groupIndex === cellGroupIndex) {
        return false;
      }
      return currentResult;
    }, true);
  }
  _getCellsInViewport(inAllDayRow) {
    const $scrollable = this.getScrollable().$element();
    const cellHeight = this.getCellHeight();
    const cellWidth = this.getCellWidth();
    const totalColumnCount = this._getTotalCellCount(this._getGroupCount());
    const scrollableScrollTop = this.getScrollableScrollTop();
    const scrollableScrollLeft = this.getScrollableScrollLeft();
    const fullScrolledRowCount = scrollableScrollTop / cellHeight - this.virtualScrollingDispatcher.topVirtualRowsCount;
    let scrolledRowCount = Math.floor(fullScrolledRowCount);
    if (scrollableScrollTop % cellHeight !== 0) {
      scrolledRowCount += 1;
    }
    const fullScrolledColumnCount = scrollableScrollLeft / cellWidth;
    let scrolledColumnCount = Math.floor(fullScrolledColumnCount);
    if (scrollableScrollLeft % cellWidth !== 0) {
      scrolledColumnCount += 1;
    }
    const rowCount = Math.floor(fullScrolledRowCount + getHeight($scrollable) / cellHeight);
    const columnCount = Math.floor(fullScrolledColumnCount + getWidth($scrollable) / cellWidth);
    const $cells = this._getAllCells(inAllDayRow);
    const result2 = [];
    $cells.each(function(index2) {
      const $cell = renderer_default(this);
      const columnIndex = index2 % totalColumnCount;
      const rowIndex = index2 / totalColumnCount;
      if (scrolledColumnCount <= columnIndex && columnIndex < columnCount && scrolledRowCount <= rowIndex && rowIndex < rowCount) {
        result2.push($cell);
      }
    });
    return result2;
  }
  scrollToTime(hours, minutes, date) {
    if (!this._isValidScrollDate(date)) {
      return;
    }
    const coordinates = this._getScrollCoordinates(hours, minutes, date);
    const scrollable = this.getScrollable();
    scrollable.scrollBy({
      top: coordinates.top - scrollable.scrollTop(),
      left: 0
    });
  }
  scrollTo(date, groups) {
    let allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    let throwWarning = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : true;
    if (!this._isValidScrollDate(date, throwWarning)) {
      return;
    }
    const groupIndex = this._getGroupCount() && groups ? this._getGroupIndexByResourceId(groups) : 0;
    const isScrollToAllDay = allDay && this.isAllDayPanelVisible;
    const coordinates = this._getScrollCoordinates(date.getHours(), date.getMinutes(), date, groupIndex, isScrollToAllDay);
    const scrollable = this.getScrollable();
    const $scrollable = scrollable.$element();
    const cellWidth = this.getCellWidth();
    const offset2 = this.option("rtlEnabled") ? cellWidth : 0;
    const scrollableHeight = getHeight($scrollable);
    const scrollableWidth = getWidth($scrollable);
    const cellHeight = this.getCellHeight();
    const xShift = (scrollableWidth - cellWidth) / 2;
    const yShift = (scrollableHeight - cellHeight) / 2;
    const left = coordinates.left - scrollable.scrollLeft() - xShift - offset2;
    let top = coordinates.top - scrollable.scrollTop() - yShift;
    if (isScrollToAllDay && !this._isVerticalGroupedWorkSpace()) {
      top = 0;
    }
    if (this.option("templatesRenderAsynchronously")) {
      setTimeout(() => {
        scrollable.scrollBy({
          left,
          top
        });
      });
    } else {
      scrollable.scrollBy({
        left,
        top
      });
    }
  }
  _isValidScrollDate(date) {
    let throwWarning = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
    const min = this.getStartViewDate();
    const max = this.getEndViewDate();
    if (date < min || date > max) {
      throwWarning && ui_errors_default.log("W1008", date);
      return false;
    }
    return true;
  }
  needApplyCollectorOffset() {
    return false;
  }
  removeDroppableCellClass($cellElement) {
    const $cell = $cellElement || this._getDroppableCell();
    null === $cell || void 0 === $cell || $cell.removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
  }
  _getCoordinatesByCell($cell) {
    const columnIndex = $cell.index() - this.virtualScrollingDispatcher.leftVirtualCellsCount;
    let rowIndex = $cell.parent().index();
    const isAllDayCell = this._hasAllDayClass($cell);
    const isVerticalGrouping = this._isVerticalGroupedWorkSpace();
    if (!(isAllDayCell && !isVerticalGrouping)) {
      rowIndex -= this.virtualScrollingDispatcher.topVirtualRowsCount;
    }
    return {
      rowIndex,
      columnIndex
    };
  }
  _isShowAllDayPanel() {
    return this.option("showAllDayPanel");
  }
  _getTimePanelCells() {
    return this.$element().find(`.${TIME_PANEL_CELL_CLASS}`);
  }
  _getRDateTableProps() {
    return {
      viewData: this.viewDataProvider.viewData,
      viewContext: this.getR1ComponentsViewContext(),
      dataCellTemplate: this.option("dataCellTemplate"),
      addDateTableClass: !this.option("crossScrollingEnabled") || this.isVirtualScrolling(),
      groupOrientation: this.option("groupOrientation"),
      addVerticalSizesClassToRows: false
    };
  }
  getR1ComponentsViewContext() {
    return {
      view: {
        type: this.type
      },
      crossScrollingEnabled: !!this.option("crossScrollingEnabled")
    };
  }
  _updateSelectedCellDataOption(selectedCellData, $nextFocusedCell) {
    const correctedSelectedCellData = selectedCellData.map((_ref3) => {
      let {
        startDate,
        endDate,
        allDay,
        groupIndex,
        groups
      } = _ref3;
      return {
        startDate,
        endDate,
        allDay,
        groupIndex,
        groups
      };
    });
    this.option("selectedCellData", correctedSelectedCellData);
    this._selectionChangedAction({
      selectedCellData: correctedSelectedCellData
    });
  }
  _getCellByData(cellData) {
    const {
      startDate,
      groupIndex,
      allDay,
      index: index2
    } = cellData;
    const position3 = this.viewDataProvider.findCellPositionInMap({
      startDate,
      groupIndex,
      isAllDay: allDay,
      index: index2
    });
    if (!position3) {
      return;
    }
    return allDay && !this._isVerticalGroupedWorkSpace() ? this._dom_getAllDayPanelCell(position3.columnIndex) : this._dom_getDateCell(position3);
  }
  getDOMElementsMetaData() {
    return this.cache.get("cellElementsMeta", () => ({
      dateTableCellsMeta: this._getDateTableDOMElementsInfo(),
      allDayPanelCellsMeta: this._getAllDayPanelDOMElementsInfo()
    }));
  }
  _getDateTableDOMElementsInfo() {
    const dateTableCells = this._getAllCells(false);
    if (!dateTableCells.length || !hasWindow()) {
      return [
        [{}]
      ];
    }
    const dateTable = this._getDateTable();
    const dateTableRect = getBoundingRect(dateTable.get(0));
    const columnsCount = this.viewDataProvider.getColumnsCount();
    const result2 = [];
    dateTableCells.each((index2, cell) => {
      const rowIndex = Math.floor(index2 / columnsCount);
      if (result2.length === rowIndex) {
        result2.push([]);
      }
      this._addCellMetaData(result2[rowIndex], cell, dateTableRect);
    });
    return result2;
  }
  _getAllDayPanelDOMElementsInfo() {
    const result2 = [];
    if (this.isAllDayPanelVisible && !this._isVerticalGroupedWorkSpace() && hasWindow()) {
      const allDayCells = this._getAllCells(true);
      if (!allDayCells.length) {
        return [{}];
      }
      const allDayAppointmentContainer = this._$allDayPanel;
      const allDayPanelRect = getBoundingRect(allDayAppointmentContainer.get(0));
      allDayCells.each((_, cell) => {
        this._addCellMetaData(result2, cell, allDayPanelRect);
      });
    }
    return result2;
  }
  _addCellMetaData(cellMetaDataArray, cell, parentRect) {
    const cellRect = getBoundingRect(cell);
    cellMetaDataArray.push({
      left: cellRect.left - parentRect.left,
      top: cellRect.top - parentRect.top,
      width: cellRect.width,
      height: cellRect.height
    });
  }
  _oldRender_getAllDayCellData(groupIndex) {
    return (cell, rowIndex, columnIndex) => {
      const validColumnIndex = columnIndex % this._getCellCount();
      const options2 = this._getDateGenerationOptions(true);
      let startDate = this.viewDataProvider.viewDataGenerator.getDateByCellIndices(options2, rowIndex, validColumnIndex, this._getCellCountInDay());
      startDate = date_default.trimTime(startDate);
      let validGroupIndex = groupIndex || 0;
      if (this.isGroupedByDate()) {
        validGroupIndex = Math.floor(columnIndex % this._getGroupCount());
      } else if (this._isHorizontalGroupedWorkSpace()) {
        validGroupIndex = Math.floor(columnIndex / this._getCellCount());
      }
      const data2 = {
        startDate,
        endDate: startDate,
        allDay: true,
        groupIndex: validGroupIndex
      };
      const groupsArray = getCellGroups(validGroupIndex, this.option("groups"));
      if (groupsArray.length) {
        data2.groups = getGroupsObjectFromGroupsArray(groupsArray);
      }
      return {
        key: CELL_DATA,
        value: data2
      };
    };
  }
  renderRWorkSpace() {
    let {
      header,
      timePanel,
      dateTable,
      allDayPanel
    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : DEFAULT_WORKSPACE_RENDER_OPTIONS.renderComponents;
    if (header) {
      this.renderRHeaderPanel();
    }
    if (timePanel) {
      this.renderRTimeTable();
    }
    if (dateTable) {
      this.renderRDateTable();
    }
    if (allDayPanel) {
      this.renderRAllDayPanel();
    }
  }
  renderRDateTable() {
    utils2.renovation.renderComponent(this, this._$dateTable, DateTableComponent, "renovatedDateTable", this._getRDateTableProps());
  }
  renderRGroupPanel() {
    var _this$option4;
    const options2 = {
      viewContext: this.getR1ComponentsViewContext(),
      groups: this.option("groups"),
      groupOrientation: this.option("groupOrientation"),
      groupByDate: this.isGroupedByDate(),
      resourceCellTemplate: this.option("resourceCellTemplate"),
      className: this.verticalGroupTableClass,
      groupPanelData: this.viewDataProvider.getGroupPanelData(this.generateRenderOptions())
    };
    if (null !== (_this$option4 = this.option("groups")) && void 0 !== _this$option4 && _this$option4.length) {
      this._attachGroupCountClass();
      utils2.renovation.renderComponent(this, this._getGroupHeaderContainer(), GroupPanelComponent, "renovatedGroupPanel", options2);
    } else {
      this._detachGroupCountClass();
    }
  }
  renderRAllDayPanel() {
    const visible2 = this.isAllDayPanelVisible && !this.isGroupedAllDayPanel();
    if (visible2) {
      var _this$virtualScrollin;
      this._toggleAllDayVisibility(false);
      const options2 = _extends({
        viewData: this.viewDataProvider.viewData,
        viewContext: this.getR1ComponentsViewContext(),
        dataCellTemplate: this.option("dataCellTemplate"),
        startCellIndex: 0
      }, (null === (_this$virtualScrollin = this.virtualScrollingDispatcher.horizontalVirtualScrolling) || void 0 === _this$virtualScrollin ? void 0 : _this$virtualScrollin.getRenderState()) || {});
      utils2.renovation.renderComponent(this, this._$allDayTable, AllDayTableComponent, "renovatedAllDayPanel", options2);
      utils2.renovation.renderComponent(this, this._$allDayTitle, AllDayPanelTitleComponent, "renovatedAllDayPanelTitle", {});
    }
    this._toggleAllDayVisibility(true);
  }
  renderRTimeTable() {
    utils2.renovation.renderComponent(this, this._$timePanel, TimePanelComponent, "renovatedTimePanel", {
      viewContext: this.getR1ComponentsViewContext(),
      timePanelData: this.viewDataProvider.timePanelData,
      timeCellTemplate: this.option("timeCellTemplate"),
      groupOrientation: this.option("groupOrientation")
    });
  }
  renderRHeaderPanel() {
    var _this$option5;
    let isRenderDateHeader = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;
    if (null !== (_this$option5 = this.option("groups")) && void 0 !== _this$option5 && _this$option5.length) {
      this._attachGroupCountClass();
    } else {
      this._detachGroupCountClass();
    }
    utils2.renovation.renderComponent(this, this._$thead, this.renovatedHeaderPanelComponent, "renovatedHeaderPanel", {
      viewContext: this.getR1ComponentsViewContext(),
      dateHeaderData: this.viewDataProvider.dateHeaderData,
      groupPanelData: this.viewDataProvider.getGroupPanelData(this.generateRenderOptions()),
      dateCellTemplate: this.option("dateCellTemplate"),
      timeCellTemplate: this.option("timeCellTemplate"),
      groups: this.option("groups"),
      groupByDate: this.isGroupedByDate(),
      groupOrientation: this.option("groupOrientation"),
      resourceCellTemplate: this.option("resourceCellTemplate"),
      isRenderDateHeader
    });
  }
  initDragBehavior(scheduler) {
    if (!this.dragBehavior && scheduler) {
      this.dragBehavior = new AppointmentDragBehavior(scheduler);
      const $rootElement = renderer_default(scheduler.element());
      this._createDragBehavior(this.getWorkArea(), $rootElement);
      if (!this._isVerticalGroupedWorkSpace()) {
        this._createDragBehavior(this._$allDayPanel, $rootElement);
      }
    }
  }
  _createDragBehavior($targetElement, $rootElement) {
    const options2 = {
      getItemData: (itemElement, appointments) => appointments._getItemData(itemElement),
      getItemSettings: ($itemElement) => $itemElement.data(APPOINTMENT_SETTINGS_KEY)
    };
    this._createDragBehaviorBase($targetElement, $rootElement, options2);
  }
  _createDragBehaviorBase(targetElement, rootElement, options2) {
    const container = this.$element().find(`.${FIXED_CONTAINER_CLASS}`);
    this.dragBehavior.addTo(targetElement, createDragBehaviorConfig(container, rootElement, this.isDefaultDraggingMode, this.dragBehavior, () => {
      if (!this.isDefaultDraggingMode) {
        this.preventDefaultDragging = false;
      }
    }, () => {
      if (!this.isDefaultDraggingMode) {
        this.preventDefaultDragging = true;
      }
    }, () => this._getDroppableCell(), () => this._getDateTables(), () => this.removeDroppableCellClass(), () => this.getCellWidth(), options2));
  }
  _isRenderHeaderPanelEmptyCell() {
    return this._isVerticalGroupedWorkSpace();
  }
  _dispose() {
    super._dispose();
    this.virtualScrollingDispatcher.dispose();
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      currentDate: /* @__PURE__ */ new Date(),
      intervalCount: 1,
      startDate: null,
      firstDayOfWeek: void 0,
      startDayHour: 0,
      endDayHour: 24,
      viewOffset: 0,
      hoursInterval: 0.5,
      activeStateEnabled: true,
      hoverStateEnabled: true,
      groups: [],
      showAllDayPanel: true,
      allDayExpanded: false,
      onCellClick: null,
      crossScrollingEnabled: false,
      dataCellTemplate: null,
      timeCellTemplate: null,
      resourceCellTemplate: null,
      dateCellTemplate: null,
      allowMultipleCellSelection: true,
      indicatorTime: /* @__PURE__ */ new Date(),
      indicatorUpdateInterval: 5 * toMs22("minute"),
      shadeUntilCurrentTime: true,
      groupOrientation: "horizontal",
      selectedCellData: [],
      groupByDate: false,
      scrolling: {
        mode: "standard"
      },
      allDayPanelMode: "all",
      renovateRender: true,
      height: void 0,
      draggingMode: "outlook",
      onScrollEnd: () => {
      },
      getHeaderHeight: void 0,
      onRenderAppointments: () => {
      },
      onShowAllDayPanel: () => {
      },
      onSelectedCellsClick: () => {
      },
      timeZoneCalculator: void 0,
      schedulerHeight: void 0,
      schedulerWidth: void 0
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case "startDayHour":
      case "endDayHour":
      case "viewOffset":
      case "dateCellTemplate":
      case "resourceCellTemplate":
      case "dataCellTemplate":
      case "timeCellTemplate":
      case "hoursInterval":
      case "firstDayOfWeek":
      case "currentDate":
      case "startDate":
        this._cleanWorkSpace();
        break;
      case "groups":
        this._cleanView();
        this._removeAllDayElements();
        this._initGrouping();
        this.repaint();
        break;
      case "groupOrientation":
        this._initGroupedStrategy();
        this._createAllDayPanelElements();
        this._removeAllDayElements();
        this._cleanWorkSpace();
        this._toggleGroupByDateClass();
        break;
      case "showAllDayPanel":
        if (this._isVerticalGroupedWorkSpace()) {
          this._cleanView();
          this._removeAllDayElements();
          this._initGrouping();
          this.repaint();
        } else if (!this.isRenovatedRender()) {
          this._toggleAllDayVisibility(true);
        } else {
          this.renderWorkSpace();
        }
        break;
      case "allDayExpanded":
        this._changeAllDayVisibility();
        this._attachTablesEvents();
        this._updateScrollable();
        break;
      case "onSelectionChanged":
        this._createSelectionChangedAction();
        break;
      case "onCellClick":
        this._createCellClickAction();
        break;
      case "onCellContextMenu":
        this._attachContextMenuEvent();
        break;
      case "intervalCount":
        this._cleanWorkSpace();
        this._toggleWorkSpaceCountClass();
        break;
      case "groupByDate":
        this._cleanWorkSpace();
        this._toggleGroupByDateClass();
        break;
      case "crossScrollingEnabled":
        this._toggleHorizontalScrollClass();
        this._dateTableScrollable.option(this._dateTableScrollableConfig());
        break;
      case "allDayPanelMode":
        this.updateShowAllDayPanel();
        this.updateAppointments();
        break;
      case "width":
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "timeZoneCalculator":
      case "allowMultipleCellSelection":
      case "selectedCellData":
        break;
      case "renovateRender":
      case "scrolling":
        this.repaint();
        break;
      case "schedulerHeight":
      case "schedulerWidth":
        this.virtualScrollingDispatcher.updateDimensions(true);
        break;
      default:
        super._optionChanged(args);
    }
  }
  updateShowAllDayPanel() {
    const isHiddenAllDayPanel = "hidden" === this.option("allDayPanelMode");
    this.option("onShowAllDayPanel")(!isHiddenAllDayPanel);
  }
  _getVirtualScrollingDispatcherOptions() {
    return {
      getCellHeight: this.getCellHeight.bind(this),
      getCellWidth: this.getCellWidth.bind(this),
      getCellMinWidth: this.getCellMinWidth.bind(this),
      isRTL: this._isRTL.bind(this),
      getSchedulerHeight: () => this.option("schedulerHeight"),
      getSchedulerWidth: () => this.option("schedulerWidth"),
      getViewHeight: () => this.$element().height ? this.$element().height() : getHeight(this.$element()),
      getViewWidth: () => this.$element().width ? this.$element().width() : getWidth(this.$element()),
      getWindowHeight: () => getWindow().innerHeight,
      getWindowWidth: () => getWindow().innerWidth,
      getScrolling: () => this.option("scrolling"),
      getScrollableOuterWidth: this.getScrollableOuterWidth.bind(this),
      getScrollable: this.getScrollable.bind(this),
      createAction: this._createAction.bind(this),
      updateRender: this.updateRender.bind(this),
      updateGrid: this.updateGrid.bind(this),
      getGroupCount: this._getGroupCount.bind(this),
      isVerticalGrouping: this._isVerticalGroupedWorkSpace.bind(this),
      getTotalRowCount: this._getTotalRowCount.bind(this),
      getTotalCellCount: this._getTotalCellCount.bind(this)
    };
  }
  _cleanWorkSpace() {
    this._cleanView();
    this._toggleGroupedClass();
    this._toggleWorkSpaceWithOddCells();
    this.virtualScrollingDispatcher.updateDimensions(true);
    this._renderView();
    this.option("crossScrollingEnabled") && this._setTableSizes();
    this.cache.clear();
  }
  _init() {
    this._scrollSync = {};
    this._viewDataProvider = null;
    this._cellsSelectionState = null;
    this._activeStateUnit = CELL_SELECTOR;
    super._init();
    this._initGrouping();
    this._toggleHorizontalScrollClass();
    this._toggleWorkSpaceCountClass();
    this._toggleGroupByDateClass();
    this._toggleWorkSpaceWithOddCells();
    this.$element().addClass(COMPONENT_CLASS3).addClass(this._getElementClass());
  }
  _initPositionHelper() {
    this.positionHelper = new PositionHelper({
      key: this.option("key"),
      viewDataProvider: this.viewDataProvider,
      viewStartDayHour: this.option("startDayHour"),
      viewEndDayHour: this.option("endDayHour"),
      cellDuration: this.getCellDuration(),
      groupedStrategy: this._groupedStrategy,
      isGroupedByDate: this.isGroupedByDate(),
      rtlEnabled: this.option("rtlEnabled"),
      startViewDate: this.getStartViewDate(),
      isVerticalGrouping: this._isVerticalGroupedWorkSpace(),
      groupCount: this._getGroupCount(),
      isVirtualScrolling: this.isVirtualScrolling(),
      getDOMMetaDataCallback: this.getDOMElementsMetaData.bind(this)
    });
  }
  _initGrouping() {
    this._initGroupedStrategy();
    this._toggleGroupingDirectionClass();
    this._toggleGroupByDateClass();
  }
  isVerticalOrientation() {
    var _this$option6;
    const orientation = null !== (_this$option6 = this.option("groups")) && void 0 !== _this$option6 && _this$option6.length ? this.option("groupOrientation") : this._getDefaultGroupStrategy();
    return "vertical" === orientation;
  }
  _initGroupedStrategy() {
    const Strategy = this.isVerticalOrientation() ? m_work_space_grouped_strategy_vertical_default : m_work_space_grouped_strategy_horizontal_default;
    this._groupedStrategy = new Strategy(this);
  }
  _getDefaultGroupStrategy() {
    return "horizontal";
  }
  _toggleHorizontalScrollClass() {
    this.$element().toggleClass(WORKSPACE_WITH_BOTH_SCROLLS_CLASS, this.option("crossScrollingEnabled"));
  }
  _toggleGroupByDateClass() {
    this.$element().toggleClass(WORKSPACE_WITH_GROUP_BY_DATE_CLASS, this.isGroupedByDate());
  }
  _toggleWorkSpaceCountClass() {
    this.$element().toggleClass(WORKSPACE_WITH_COUNT_CLASS, this._isWorkSpaceWithCount());
  }
  _toggleWorkSpaceWithOddCells() {
    this.$element().toggleClass(WORKSPACE_WITH_ODD_CELLS_CLASS, this._isWorkspaceWithOddCells());
  }
  _toggleGroupingDirectionClass() {
    this.$element().toggleClass(VERTICAL_GROUPED_WORKSPACE_CLASS, this._isVerticalGroupedWorkSpace());
  }
  _getDateTableCellClass(rowIndex, columnIndex) {
    const cellClass = `${DATE_TABLE_CELL_CLASS2} ${HORIZONTAL_SIZES_CLASS} ${VERTICAL_SIZES_CLASS}`;
    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, columnIndex + 1, rowIndex, columnIndex);
  }
  _getGroupHeaderClass(i) {
    const cellClass = GROUP_HEADER_CLASS;
    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1);
  }
  _initWorkSpaceUnits() {
    this._$headerPanelContainer = renderer_default("<div>").addClass("dx-scheduler-header-panel-container");
    this._$headerTablesContainer = renderer_default("<div>").addClass("dx-scheduler-header-tables-container");
    this._$headerPanel = renderer_default("<table>");
    this._$thead = renderer_default("<thead>").appendTo(this._$headerPanel);
    this._$headerPanelEmptyCell = renderer_default("<div>").addClass("dx-scheduler-header-panel-empty-cell");
    this._$allDayTable = renderer_default("<table>");
    this._$fixedContainer = renderer_default("<div>").addClass(FIXED_CONTAINER_CLASS);
    this._$allDayContainer = renderer_default("<div>").addClass(ALL_DAY_CONTAINER_CLASS);
    this._$dateTableScrollableContent = renderer_default("<div>").addClass("dx-scheduler-date-table-scrollable-content");
    this._$sidebarScrollableContent = renderer_default("<div>").addClass("dx-scheduler-side-bar-scrollable-content");
    this._initAllDayPanelElements();
    if (this.isRenovatedRender()) {
      this.createRAllDayPanelElements();
    } else {
      this._createAllDayPanelElements();
    }
    this._$timePanel = renderer_default("<table>").addClass(TIME_PANEL_CLASS);
    this._$dateTable = renderer_default("<table>");
    this._$dateTableContainer = renderer_default("<div>").addClass("dx-scheduler-date-table-container");
    this._$groupTable = renderer_default("<div>").addClass(WORKSPACE_VERTICAL_GROUP_TABLE_CLASS);
  }
  _initAllDayPanelElements() {
    this._allDayTitles = [];
    this._allDayTables = [];
    this._allDayPanels = [];
  }
  _initDateTableScrollable() {
    const $dateTableScrollable = renderer_default("<div>").addClass("dx-scheduler-date-table-scrollable");
    this._dateTableScrollable = this._createComponent($dateTableScrollable, ui_scrollable_default, this._dateTableScrollableConfig());
    this._scrollSync.dateTable = getMemoizeScrollTo(() => this._dateTableScrollable);
  }
  _createWorkSpaceElements() {
    if (this.option("crossScrollingEnabled")) {
      this._createWorkSpaceScrollableElements();
    } else {
      this._createWorkSpaceStaticElements();
    }
  }
  _createWorkSpaceStaticElements() {
    this._$dateTableContainer.append(this._$dateTable);
    if (this._isVerticalGroupedWorkSpace()) {
      this._$dateTableContainer.append(this._$allDayContainer);
      this._$dateTableScrollableContent.append(this._$groupTable, this._$timePanel, this._$dateTableContainer);
      this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);
      this._$headerTablesContainer.append(this._$headerPanel);
    } else {
      var _this$_$allDayPanel;
      this._$dateTableScrollableContent.append(this._$timePanel, this._$dateTableContainer);
      this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);
      this._$headerTablesContainer.append(this._$headerPanel, this._$allDayPanel);
      null === (_this$_$allDayPanel = this._$allDayPanel) || void 0 === _this$_$allDayPanel || _this$_$allDayPanel.append(this._$allDayContainer, this._$allDayTable);
    }
    this._appendHeaderPanelEmptyCellIfNecessary();
    this._$headerPanelContainer.append(this._$headerTablesContainer);
    this.$element().append(this._$fixedContainer, this._$headerPanelContainer, this._dateTableScrollable.$element());
  }
  _createWorkSpaceScrollableElements() {
    this.$element().append(this._$fixedContainer);
    this._$flexContainer = renderer_default("<div>").addClass("dx-scheduler-work-space-flex-container");
    this._createHeaderScrollable();
    this._headerScrollable.$content().append(this._$headerPanel);
    this._appendHeaderPanelEmptyCellIfNecessary();
    this._$headerPanelContainer.append(this._$headerTablesContainer);
    this.$element().append(this._$headerPanelContainer);
    this.$element().append(this._$flexContainer);
    this._createSidebarScrollable();
    this._$flexContainer.append(this._dateTableScrollable.$element());
    this._$dateTableContainer.append(this._$dateTable);
    this._$dateTableScrollableContent.append(this._$dateTableContainer);
    this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);
    if (this._isVerticalGroupedWorkSpace()) {
      this._$dateTableContainer.append(this._$allDayContainer);
      this._$sidebarScrollableContent.append(this._$groupTable, this._$timePanel);
    } else {
      var _this$_$allDayPanel2;
      this._headerScrollable.$content().append(this._$allDayPanel);
      null === (_this$_$allDayPanel2 = this._$allDayPanel) || void 0 === _this$_$allDayPanel2 || _this$_$allDayPanel2.append(this._$allDayContainer, this._$allDayTable);
      this._$sidebarScrollableContent.append(this._$timePanel);
    }
    this._sidebarScrollable.$content().append(this._$sidebarScrollableContent);
  }
  _appendHeaderPanelEmptyCellIfNecessary() {
    this._isRenderHeaderPanelEmptyCell() && this._$headerPanelContainer.append(this._$headerPanelEmptyCell);
  }
  _createHeaderScrollable() {
    const $headerScrollable = renderer_default("<div>").addClass("dx-scheduler-header-scrollable").appendTo(this._$headerTablesContainer);
    this._headerScrollable = this._createComponent($headerScrollable, ui_scrollable_default, this._headerScrollableConfig());
    this._scrollSync.header = getMemoizeScrollTo(() => this._headerScrollable);
  }
  _createSidebarScrollable() {
    const $timePanelScrollable = renderer_default("<div>").addClass("dx-scheduler-sidebar-scrollable").appendTo(this._$flexContainer);
    this._sidebarScrollable = this._createComponent($timePanelScrollable, ui_scrollable_default, {
      useKeyboard: false,
      showScrollbar: "never",
      direction: "vertical",
      useNative: false,
      updateManually: true,
      bounceEnabled: false,
      onScroll: (event) => {
        this._scrollSync.dateTable({
          top: event.scrollOffset.top
        });
      }
    });
    this._scrollSync.sidebar = getMemoizeScrollTo(() => this._sidebarScrollable);
  }
  _attachTableClasses() {
    this._addTableClass(this._$dateTable, DATE_TABLE_CLASS);
    if (this._isVerticalGroupedWorkSpace()) {
      const groupCount = this._getGroupCount();
      for (let i = 0; i < groupCount; i++) {
        this._addTableClass(this._allDayTables[i], ALL_DAY_TABLE_CLASS);
      }
    } else if (!this.isRenovatedRender()) {
      this._addTableClass(this._$allDayTable, ALL_DAY_TABLE_CLASS);
    }
  }
  _attachHeaderTableClasses() {
    this._addTableClass(this._$headerPanel, HEADER_PANEL_CLASS);
  }
  _addTableClass($el, className) {
    $el && !$el.hasClass(className) && $el.addClass(className);
  }
  _initMarkup() {
    this.cache.clear();
    this._initWorkSpaceUnits();
    this._initVirtualScrolling();
    this._initDateTableScrollable();
    this._createWorkSpaceElements();
    super._initMarkup();
    if (!this.option("crossScrollingEnabled")) {
      this._attachTableClasses();
      this._attachHeaderTableClasses();
    }
    this._toggleGroupedClass();
    this._renderView();
    this._attachEvents();
  }
  _render() {
    super._render();
    this._renderDateTimeIndication();
    this._setIndicationUpdateInterval();
  }
  _toggleGroupedClass() {
    this.$element().toggleClass(GROUPED_WORKSPACE_CLASS, this._getGroupCount() > 0);
  }
  _renderView() {
    if (this.isRenovatedRender()) {
      if (this._isVerticalGroupedWorkSpace()) {
        this.renderRGroupPanel();
      }
    } else {
      this._applyCellTemplates(this._renderGroupHeader());
    }
    this.renderWorkSpace();
    if (this.isRenovatedRender()) {
      this.virtualScrollingDispatcher.updateDimensions();
    }
    this._updateGroupTableHeight();
    this.updateHeaderEmptyCellWidth();
    this._shader = new m_current_time_shader_vertical_default(this);
  }
  updateCellsSelection() {
    const renderOptions = this.generateRenderOptions();
    this.viewDataProvider.updateViewData(renderOptions);
    this.renderRWorkSpace({
      timePanel: true,
      dateTable: true,
      allDayPanel: true
    });
  }
  _renderDateTimeIndication() {
    return noop2();
  }
  renderCurrentDateTimeLineAndShader() {
    return noop2();
  }
  renderCurrentDateTimeIndication() {
    return noop2();
  }
  _setIndicationUpdateInterval() {
    return noop2();
  }
  _detachGroupCountClass() {
    [...VERTICAL_GROUP_COUNT_CLASSES].forEach((className) => {
      this.$element().removeClass(className);
    });
  }
  _attachGroupCountClass() {
    const className = this._groupedStrategy.getGroupCountClass(this.option("groups"));
    this.$element().addClass(className);
  }
  _getDateHeaderTemplate() {
    return this.option("dateCellTemplate");
  }
  _toggleAllDayVisibility(isUpdateScrollable) {
    const showAllDayPanel = this._isShowAllDayPanel();
    this.$element().toggleClass(WORKSPACE_WITH_ALL_DAY_CLASS, showAllDayPanel);
    this._changeAllDayVisibility();
    isUpdateScrollable && this._updateScrollable();
  }
  _changeAllDayVisibility() {
    this.cache.clear();
    this.$element().toggleClass(WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS, !this.option("allDayExpanded") && this._isShowAllDayPanel());
  }
  _getDateTables() {
    return this._$dateTable.add(this._$allDayTable);
  }
  _getDateTable() {
    return this._$dateTable;
  }
  _removeAllDayElements() {
    this._$allDayTable && this._$allDayTable.remove();
    this._$allDayTitle && this._$allDayTitle.remove();
  }
  _cleanView() {
    var _this$_shader;
    this.cache.clear();
    this._cleanTableWidths();
    this.cellsSelectionState.clearSelectedAndFocusedCells();
    if (!this.isRenovatedRender()) {
      var _this$_$allDayTable, _this$_$sidebarTable;
      this._$thead.empty();
      this._$dateTable.empty();
      this._$timePanel.empty();
      this._$groupTable.empty();
      null === (_this$_$allDayTable = this._$allDayTable) || void 0 === _this$_$allDayTable || _this$_$allDayTable.empty();
      null === (_this$_$sidebarTable = this._$sidebarTable) || void 0 === _this$_$sidebarTable || _this$_$sidebarTable.empty();
    }
    null === (_this$_shader = this._shader) || void 0 === _this$_shader || _this$_shader.clean();
    delete this._interval;
  }
  _clean() {
    events_engine_default.off(dom_adapter_default.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);
    this._disposeRenovatedComponents();
    super._clean();
  }
  _cleanTableWidths() {
    this._$headerPanel.css("width", "");
    this._$dateTable.css("width", "");
    this._$allDayTable && this._$allDayTable.css("width", "");
  }
  _disposeRenovatedComponents() {
    var _this$renovatedAllDay, _this$renovatedDateTa, _this$renovatedTimePa, _this$renovatedGroupP, _this$renovatedHeader;
    null === (_this$renovatedAllDay = this.renovatedAllDayPanel) || void 0 === _this$renovatedAllDay || _this$renovatedAllDay.dispose();
    this.renovatedAllDayPanel = void 0;
    null === (_this$renovatedDateTa = this.renovatedDateTable) || void 0 === _this$renovatedDateTa || _this$renovatedDateTa.dispose();
    this.renovatedDateTable = void 0;
    null === (_this$renovatedTimePa = this.renovatedTimePanel) || void 0 === _this$renovatedTimePa || _this$renovatedTimePa.dispose();
    this.renovatedTimePanel = void 0;
    null === (_this$renovatedGroupP = this.renovatedGroupPanel) || void 0 === _this$renovatedGroupP || _this$renovatedGroupP.dispose();
    this.renovatedGroupPanel = void 0;
    null === (_this$renovatedHeader = this.renovatedHeaderPanel) || void 0 === _this$renovatedHeader || _this$renovatedHeader.dispose();
    this.renovatedHeaderPanel = void 0;
  }
  getGroupedStrategy() {
    return this._groupedStrategy;
  }
  getFixedContainer() {
    return this._$fixedContainer;
  }
  getAllDayContainer() {
    return this._$allDayContainer;
  }
  updateRender() {
    this.renderer.updateRender();
  }
  updateGrid() {
    this.renderer._renderGrid();
  }
  updateAppointments() {
    var _this$dragBehavior2;
    this.option("onRenderAppointments")();
    null === (_this$dragBehavior2 = this.dragBehavior) || void 0 === _this$dragBehavior2 || _this$dragBehavior2.updateDragSource();
  }
  _createAllDayPanelElements() {
    const groupCount = this._getGroupCount();
    if (this._isVerticalGroupedWorkSpace() && 0 !== groupCount) {
      for (let i = 0; i < groupCount; i++) {
        const $allDayTitle = renderer_default("<div>").addClass(ALL_DAY_TITLE_CLASS).text(message_default.format("dxScheduler-allDay"));
        this._allDayTitles.push($allDayTitle);
        this._$allDayTable = renderer_default("<table>");
        this._allDayTables.push(this._$allDayTable);
        this._$allDayPanel = renderer_default("<div>").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);
        this._allDayPanels.push(this._$allDayPanel);
      }
    } else {
      this._$allDayTitle = renderer_default("<div>").addClass(ALL_DAY_TITLE_CLASS).text(message_default.format("dxScheduler-allDay")).appendTo(this.$element());
      this._$allDayTable = renderer_default("<table>");
      this._$allDayPanel = renderer_default("<div>").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);
    }
  }
  renderWorkSpace() {
    let {
      generateNewData,
      renderComponents
    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : DEFAULT_WORKSPACE_RENDER_OPTIONS;
    this.cache.clear();
    this.viewDataProvider.update(this.generateRenderOptions(), generateNewData);
    if (this.isRenovatedRender()) {
      this.renderRWorkSpace(renderComponents);
    } else {
      this._renderDateHeader();
      this._renderTimePanel();
      this._renderGroupAllDayPanel();
      this._renderDateTable();
      this._renderAllDayPanel();
    }
    this._initPositionHelper();
  }
  _renderGroupHeader() {
    const $container = this._getGroupHeaderContainer();
    const groupCount = this._getGroupCount();
    let cellTemplates = [];
    if (groupCount) {
      const groupRows = this._makeGroupRows(this.option("groups"), this.option("groupByDate"));
      this._attachGroupCountClass();
      $container.append(groupRows.elements);
      cellTemplates = groupRows.cellTemplates;
    } else {
      this._detachGroupCountClass();
    }
    return cellTemplates;
  }
  _applyCellTemplates(templates) {
    null === templates || void 0 === templates || templates.forEach((template) => {
      template();
    });
  }
  _makeGroupRows(groups, groupByDate) {
    const tableCreatorStrategy = this._isVerticalGroupedWorkSpace() ? tableCreator.VERTICAL : tableCreator.HORIZONTAL;
    return tableCreator.makeGroupedTable(tableCreatorStrategy, groups, {
      groupHeaderRowClass: GROUP_ROW_CLASS,
      groupRowClass: GROUP_ROW_CLASS,
      groupHeaderClass: this._getGroupHeaderClass.bind(this),
      groupHeaderContentClass: GROUP_HEADER_CONTENT_CLASS
    }, this._getCellCount() || 1, this.option("resourceCellTemplate"), this._getGroupCount(), groupByDate);
  }
  _renderDateHeader() {
    const container = this._getDateHeaderContainer();
    const $headerRow = renderer_default("<tr>").addClass(HEADER_ROW_CLASS);
    const count = this._getCellCount();
    const cellTemplate = this._getDateHeaderTemplate();
    const repeatCount = this._getCalculateHeaderCellRepeatCount();
    const templateCallbacks = [];
    const groupByDate = this.isGroupedByDate();
    if (!groupByDate) {
      for (let rowIndex = 0; rowIndex < repeatCount; rowIndex++) {
        for (let columnIndex = 0; columnIndex < count; columnIndex++) {
          const templateIndex = rowIndex * count + columnIndex;
          this._renderDateHeaderTemplate($headerRow, columnIndex, templateIndex, cellTemplate, templateCallbacks);
        }
      }
      container.append($headerRow);
    } else {
      const colSpan = groupByDate ? this._getGroupCount() : 1;
      for (let columnIndex = 0; columnIndex < count; columnIndex++) {
        const templateIndex = columnIndex * repeatCount;
        const cellElement = this._renderDateHeaderTemplate($headerRow, columnIndex, templateIndex, cellTemplate, templateCallbacks);
        cellElement.attr("colSpan", colSpan);
      }
      container.prepend($headerRow);
    }
    this._applyCellTemplates(templateCallbacks);
    return $headerRow;
  }
  _renderDateHeaderTemplate(container, panelCellIndex, templateIndex, cellTemplate, templateCallbacks) {
    const validTemplateIndex = this.isGroupedByDate() ? Math.floor(templateIndex / this._getGroupCount()) : templateIndex;
    const {
      completeDateHeaderMap
    } = this.viewDataProvider;
    const {
      text,
      startDate: date
    } = completeDateHeaderMap[completeDateHeaderMap.length - 1][validTemplateIndex];
    const $cell = renderer_default("<th>").addClass(this._getHeaderPanelCellClass(panelCellIndex)).attr("title", text);
    if (null !== cellTemplate && void 0 !== cellTemplate && cellTemplate.render) {
      templateCallbacks.push(cellTemplate.render.bind(cellTemplate, {
        model: _extends({
          text,
          date
        }, this._getGroupsForDateHeaderTemplate(templateIndex)),
        index: templateIndex,
        container: getPublicElement($cell)
      }));
    } else {
      $cell.text(text);
    }
    container.append($cell);
    return $cell;
  }
  _getGroupsForDateHeaderTemplate(templateIndex) {
    let indexMultiplier = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    let groupIndex;
    let groups;
    if (this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate()) {
      groupIndex = this._getGroupIndex(0, templateIndex * indexMultiplier);
      const groupsArray = getCellGroups(groupIndex, this.option("groups"));
      groups = getGroupsObjectFromGroupsArray(groupsArray);
    }
    return {
      groups,
      groupIndex
    };
  }
  _getHeaderPanelCellClass(i) {
    const cellClass = `${HEADER_PANEL_CELL_CLASS} ${HORIZONTAL_SIZES_CLASS}`;
    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1, void 0, void 0, this.isGroupedByDate());
  }
  _renderAllDayPanel(index2) {
    let cellCount = this._getCellCount();
    if (!this._isVerticalGroupedWorkSpace()) {
      cellCount *= this._getGroupCount() || 1;
    }
    const cellTemplates = this._renderTableBody({
      container: this._allDayPanels.length ? getPublicElement(this._allDayTables[index2]) : getPublicElement(this._$allDayTable),
      rowCount: 1,
      cellCount,
      cellClass: this._getAllDayPanelCellClass.bind(this),
      rowClass: ALL_DAY_TABLE_ROW_CLASS,
      cellTemplate: this.option("dataCellTemplate"),
      getCellData: this._oldRender_getAllDayCellData(index2),
      groupIndex: index2
    }, true);
    this._toggleAllDayVisibility(true);
    this._applyCellTemplates(cellTemplates);
  }
  _renderGroupAllDayPanel() {
    if (this._isVerticalGroupedWorkSpace()) {
      const groupCount = this._getGroupCount();
      for (let i = 0; i < groupCount; i++) {
        this._renderAllDayPanel(i);
      }
    }
  }
  _getAllDayPanelCellClass(i, j) {
    const cellClass = `${ALL_DAY_TABLE_CELL_CLASS} ${HORIZONTAL_SIZES_CLASS}`;
    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, j + 1);
  }
  _renderTimePanel() {
    const repeatCount = this._groupedStrategy.calculateTimeCellRepeatCount();
    const getData = (rowIndex, field) => {
      let allDayPanelsCount = 0;
      if (this.isAllDayPanelVisible) {
        allDayPanelsCount = 1;
      }
      if (this.isGroupedAllDayPanel()) {
        allDayPanelsCount = Math.ceil((rowIndex + 1) / this._getRowCount());
      }
      const validRowIndex = rowIndex + allDayPanelsCount;
      return this.viewDataProvider.completeTimePanelMap[validRowIndex][field];
    };
    this._renderTableBody({
      container: getPublicElement(this._$timePanel),
      rowCount: this._getTimePanelRowCount() * repeatCount,
      cellCount: 1,
      cellClass: this._getTimeCellClass.bind(this),
      rowClass: TIME_PANEL_ROW_CLASS,
      cellTemplate: this.option("timeCellTemplate"),
      getCellText: (rowIndex) => getData(rowIndex, "text"),
      getCellDate: (rowIndex) => getData(rowIndex, "startDate"),
      groupCount: this._getGroupCount(),
      allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayTitles : void 0,
      getTemplateData: ((rowIndex) => {
        if (!this._isVerticalGroupedWorkSpace()) {
          return {};
        }
        const groupIndex = this._getGroupIndex(rowIndex, 0);
        const groupsArray = getCellGroups(groupIndex, this.option("groups"));
        const groups = getGroupsObjectFromGroupsArray(groupsArray);
        return {
          groupIndex,
          groups
        };
      }).bind(this)
    });
  }
  _getTimeCellClass(i) {
    const cellClass = `${TIME_PANEL_CELL_CLASS} ${VERTICAL_SIZES_CLASS}`;
    return this._isVerticalGroupedWorkSpace() ? this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i, i) : cellClass;
  }
  _renderDateTable() {
    const groupCount = this._getGroupCount();
    this._renderTableBody({
      container: getPublicElement(this._$dateTable),
      rowCount: this._getTotalRowCount(groupCount),
      cellCount: this._getTotalCellCount(groupCount),
      cellClass: this._getDateTableCellClass.bind(this),
      rowClass: DATE_TABLE_ROW_CLASS,
      cellTemplate: this.option("dataCellTemplate"),
      getCellData: (_, rowIndex, columnIndex) => {
        const isGroupedAllDayPanel = this.isGroupedAllDayPanel();
        let validRowIndex = rowIndex;
        if (isGroupedAllDayPanel) {
          const rowCount = this._getRowCount();
          const allDayPanelsCount = Math.ceil(rowIndex / rowCount);
          validRowIndex += allDayPanelsCount;
        }
        const {
          cellData
        } = this.viewDataProvider.viewDataMap.dateTableMap[validRowIndex][columnIndex];
        return {
          value: this._filterCellDataFields(cellData),
          fullValue: cellData,
          key: CELL_DATA
        };
      },
      allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayPanels : void 0,
      groupCount,
      groupByDate: this.option("groupByDate")
    });
  }
  _insertAllDayRowsIntoDateTable() {
    return this._groupedStrategy.insertAllDayRowsIntoDateTable();
  }
  _renderTableBody(options2, delayCellTemplateRendering) {
    let result2 = [];
    if (!delayCellTemplateRendering) {
      this._applyCellTemplates(tableCreator.makeTable(options2));
    } else {
      result2 = tableCreator.makeTable(options2);
    }
    return result2;
  }
};
var createDragBehaviorConfig = (container, rootElement, isDefaultDraggingMode, dragBehavior, enableDefaultDragging, disableDefaultDragging, getDroppableCell, getDateTables, removeDroppableCellClass, getCellWidth2, options2) => {
  const state = {
    dragElement: void 0,
    itemData: void 0
  };
  const isItemDisabled = () => {
    const {
      itemData
    } = state;
    if (itemData) {
      const getter = compileGetter("disabled");
      return getter(itemData);
    }
    return true;
  };
  const cursorOffset = options2.isSetCursorOffset ? () => {
    const $dragElement = renderer_default(state.dragElement);
    return {
      x: getWidth($dragElement) / 2,
      y: getHeight($dragElement) / 2
    };
  } : void 0;
  return {
    container,
    dragTemplate: () => state.dragElement,
    onDragStart: (e) => {
      if (!isDefaultDraggingMode) {
        disableDefaultDragging();
      }
      const canceled = e.cancel;
      const {
        event
      } = e;
      const $itemElement = renderer_default(e.itemElement);
      const appointments = e.component._appointments;
      state.itemData = options2.getItemData(e.itemElement, appointments);
      const settings = options2.getItemSettings($itemElement, e);
      const {
        initialPosition
      } = options2;
      if (!isItemDisabled()) {
        event.data = event.data || {};
        if (!canceled) {
          if (!settings.isCompact) {
            dragBehavior.updateDragSource(state.itemData, settings);
          }
          state.dragElement = ((itemData, settings2, appointments2) => {
            const appointmentIndex = appointments2.option("items").length;
            settings2.isCompact = false;
            settings2.virtual = false;
            const items = appointments2._renderItem(appointmentIndex, {
              itemData,
              settings: [settings2]
            });
            return items[0];
          })(state.itemData, settings, appointments);
          event.data.itemElement = state.dragElement;
          event.data.initialPosition = initialPosition ?? locate(renderer_default(state.dragElement));
          event.data.itemData = state.itemData;
          event.data.itemSettings = settings;
          dragBehavior.onDragStart(event.data);
          resetPosition(renderer_default(state.dragElement));
        }
      }
    },
    onDragMove: () => {
      if (isDefaultDraggingMode) {
        return;
      }
      const elements = (() => {
        const appointmentWidth = getWidth(state.dragElement);
        const cellWidth = getCellWidth2();
        const isWideAppointment = appointmentWidth > cellWidth;
        const isNarrowAppointment = appointmentWidth <= 10;
        const dragElementContainer = renderer_default(state.dragElement).parent().get(0);
        const boundingRect = getBoundingRect(dragElementContainer);
        const newX = boundingRect.left;
        const newY = boundingRect.top;
        if (isWideAppointment) {
          return dom_adapter_default.elementsFromPoint(newX + 10, newY + 10, dragElementContainer);
        }
        if (isNarrowAppointment) {
          return dom_adapter_default.elementsFromPoint(newX, newY, dragElementContainer);
        }
        return dom_adapter_default.elementsFromPoint(newX + appointmentWidth / 2, newY + 10, dragElementContainer);
      })();
      const isMoveUnderControl = !!elements.find((el) => el === rootElement.get(0));
      const dateTables = getDateTables();
      const droppableCell = elements.find((el) => {
        const {
          classList
        } = el;
        const isCurrentSchedulerElement = 1 === dateTables.find(el).length;
        return isCurrentSchedulerElement && (classList.contains(DATE_TABLE_CELL_CLASS2) || classList.contains(ALL_DAY_TABLE_CELL_CLASS));
      });
      if (droppableCell) {
        if (!getDroppableCell().is(droppableCell)) {
          removeDroppableCellClass();
        }
        renderer_default(droppableCell).addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
      } else if (!isMoveUnderControl) {
        removeDroppableCellClass();
      }
    },
    onDragEnd: (e) => {
      var _state$dragElement;
      if (!isDefaultDraggingMode) {
        enableDefaultDragging();
      }
      if (!isItemDisabled()) {
        dragBehavior.onDragEnd(e);
      }
      null === (_state$dragElement = state.dragElement) || void 0 === _state$dragElement || _state$dragElement.remove();
      removeDroppableCellClass();
    },
    cursorOffset,
    filter: options2.filter
  };
};
var m_work_space_default = SchedulerWorkSpace;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_agenda.js
var {
  tableCreator: tableCreator2
} = m_table_creator_default;
var AGENDA_CLASS = "dx-scheduler-agenda";
var AGENDA_DATE_CLASS = "dx-scheduler-agenda-date";
var GROUP_TABLE_CLASS = "dx-scheduler-group-table";
var TIME_PANEL_ROW_CLASS2 = "dx-scheduler-time-panel-row";
var TIME_PANEL_CELL_CLASS2 = "dx-scheduler-time-panel-cell";
var NODATA_CONTAINER_CLASS = "dx-scheduler-agenda-nodata";
var LAST_ROW_CLASS = "dx-scheduler-date-table-last-row";
var SchedulerAgenda = class extends m_work_space_default {
  get type() {
    return VIEWS.AGENDA;
  }
  get renderingStrategy() {
    return this.invoke("getLayoutManager").getRenderingStrategyInstance();
  }
  get appointmentDataProvider() {
    return this.option("getAppointmentDataProvider")();
  }
  getStartViewDate() {
    return this._startViewDate;
  }
  _init() {
    super._init();
    this._activeStateUnit = void 0;
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      agendaDuration: 7,
      rowHeight: 60,
      noDataText: ""
    });
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    const {
      value: value2
    } = args;
    switch (name2) {
      case "agendaDuration":
        break;
      case "noDataText":
      case "rowHeight":
        this._recalculateAgenda(this._rows);
        break;
      case "groups":
        if (!value2 || !value2.length) {
          if (this._$groupTable) {
            this._$groupTable.remove();
            this._$groupTable = null;
            this._detachGroupCountClass();
          }
        } else if (!this._$groupTable) {
          this._initGroupTable();
          this._dateTableScrollable.$content().prepend(this._$groupTable);
        }
        super._optionChanged(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
  _renderFocusState() {
    return noop2();
  }
  _renderFocusTarget() {
    return noop2();
  }
  _cleanFocusState() {
    return noop2();
  }
  supportAllDayRow() {
    return false;
  }
  _isVerticalGroupedWorkSpace() {
    return false;
  }
  _getElementClass() {
    return AGENDA_CLASS;
  }
  _calculateStartViewDate() {
    return agendaUtils.calculateStartViewDate(this.option("currentDate"), this.option("startDayHour"));
  }
  _getRowCount() {
    return this.option("agendaDuration");
  }
  _getCellCount() {
    return 1;
  }
  _getTimePanelRowCount() {
    return this.option("agendaDuration");
  }
  _renderAllDayPanel() {
    return noop2();
  }
  _toggleAllDayVisibility() {
    return noop2();
  }
  _initWorkSpaceUnits() {
    this._initGroupTable();
    this._$timePanel = renderer_default("<table>").addClass(TIME_PANEL_CLASS);
    this._$dateTable = renderer_default("<table>").addClass(DATE_TABLE_CLASS);
    this._$dateTableScrollableContent = renderer_default("<div>").addClass("dx-scheduler-date-table-scrollable-content");
    this._$dateTableContainer = renderer_default("<div>").addClass("dx-scheduler-date-table-container");
  }
  _initGroupTable() {
    const groups = this.option("groups");
    if (groups && groups.length) {
      this._$groupTable = renderer_default("<table>").addClass(GROUP_TABLE_CLASS);
    }
  }
  _renderView() {
    this._startViewDate = this._calculateStartViewDate();
    this._rows = [];
    this._initPositionHelper();
  }
  _recalculateAgenda(rows) {
    let cellTemplates = [];
    this._cleanView();
    if (this._rowsIsEmpty(rows)) {
      this._renderNoData();
      return;
    }
    this._rows = rows;
    if (this._$groupTable) {
      cellTemplates = this._renderGroupHeader();
      this._setGroupHeaderCellsHeight();
    }
    this._renderTimePanel();
    this._renderDateTable();
    this.invoke("onAgendaReady", rows);
    this._applyCellTemplates(cellTemplates);
    this._dateTableScrollable.update();
  }
  _renderNoData() {
    this._$noDataContainer = renderer_default("<div>").addClass(NODATA_CONTAINER_CLASS).html(this.option("noDataText"));
    this._dateTableScrollable.$content().append(this._$noDataContainer);
  }
  _setTableSizes() {
    return noop2();
  }
  _toggleHorizontalScrollClass() {
    return noop2();
  }
  _createCrossScrollingConfig(argument) {
    return noop2();
  }
  _setGroupHeaderCellsHeight() {
    const $cells = this._getGroupHeaderCells().filter((_, element) => !element.getAttribute("rowSpan"));
    const rows = this._removeEmptyRows(this._rows);
    if (!rows.length) {
      return;
    }
    for (let i = 0; i < $cells.length; i++) {
      const $cellContent = $cells.eq(i).find(".dx-scheduler-group-header-content");
      setOuterHeight($cellContent, this._getGroupRowHeight(rows[i]));
    }
  }
  _rowsIsEmpty(rows) {
    let result2 = true;
    for (let i = 0; i < rows.length; i++) {
      const groupRow = rows[i];
      for (let j = 0; j < groupRow.length; j++) {
        if (groupRow[j]) {
          result2 = false;
          break;
        }
      }
    }
    return result2;
  }
  _attachGroupCountClass() {
    const className = getVerticalGroupCountClass(this.option("groups"));
    this.$element().addClass(className);
  }
  _removeEmptyRows(rows) {
    const result2 = [];
    for (let i = 0; i < rows.length; i++) {
      if (rows[i].length && !(data2 = rows[i], !data2.some((value2) => value2 > 0))) {
        result2.push(rows[i]);
      }
    }
    var data2;
    return result2;
  }
  _getGroupHeaderContainer() {
    return this._$groupTable;
  }
  _makeGroupRows() {
    const tree = createReducedResourcesTree(this.option("loadedResources"), (field, action) => getDataAccessors(this.option("getResourceDataAccessors")(), field, action), this.option("getFilteredItems")());
    const cellTemplate = this.option("resourceCellTemplate");
    const getGroupHeaderContentClass = GROUP_HEADER_CONTENT_CLASS;
    const cellTemplates = [];
    const table = tableCreator2.makeGroupedTableFromJSON(tableCreator2.VERTICAL, tree, {
      cellTag: "th",
      groupTableClass: GROUP_TABLE_CLASS,
      groupRowClass: GROUP_ROW_CLASS,
      groupCellClass: this._getGroupHeaderClass(),
      groupCellCustomContent(cell, cellTextElement, index2, data2) {
        const container = dom_adapter_default.createElement("div");
        container.className = getGroupHeaderContentClass;
        if (cellTemplate && cellTemplate.render) {
          cellTemplates.push(cellTemplate.render.bind(cellTemplate, {
            model: {
              data: data2.data,
              id: data2.value,
              color: data2.color,
              text: cellTextElement.textContent
            },
            container: getPublicElement(renderer_default(container)),
            index: index2
          }));
        } else {
          const contentWrapper = dom_adapter_default.createElement("div");
          contentWrapper.appendChild(cellTextElement);
          container.appendChild(contentWrapper);
        }
        cell.appendChild(container);
      },
      cellTemplate
    });
    return {
      elements: renderer_default(table).find(`.${GROUP_ROW_CLASS}`),
      cellTemplates
    };
  }
  _cleanView() {
    this._$dateTable.empty();
    this._$timePanel.empty();
    if (this._$groupTable) {
      this._$groupTable.empty();
    }
    if (this._$noDataContainer) {
      this._$noDataContainer.empty();
      this._$noDataContainer.remove();
      delete this._$noDataContainer;
    }
  }
  _createWorkSpaceElements() {
    this._createWorkSpaceStaticElements();
  }
  _createWorkSpaceStaticElements() {
    this._$dateTableContainer.append(this._$dateTable);
    this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);
    if (this._$groupTable) {
      this._$dateTableScrollableContent.prepend(this._$groupTable);
    }
    this._$dateTableScrollableContent.append(this._$timePanel, this._$dateTableContainer);
    this.$element().append(this._dateTableScrollable.$element());
  }
  _renderDateTable() {
    this._renderTableBody({
      container: getPublicElement(this._$dateTable),
      rowClass: DATE_TABLE_ROW_CLASS,
      cellClass: this._getDateTableCellClass()
    });
  }
  _attachTablesEvents() {
    return noop2();
  }
  _attachEvents() {
    return noop2();
  }
  _cleanCellDataCache() {
    return noop2();
  }
  isIndicationAvailable() {
    return false;
  }
  _prepareCellTemplateOptions(text, date, rowIndex, $cell) {
    const groupsOpt = this.option("groups");
    const groups = {};
    const isGroupedView = !!groupsOpt.length;
    const path = isGroupedView && getPathToLeaf(rowIndex, groupsOpt) || [];
    path.forEach((resourceValue, resourceIndex) => {
      const resourceName = groupsOpt[resourceIndex].name;
      groups[resourceName] = resourceValue;
    });
    const groupIndex = isGroupedView ? this._getGroupIndexByResourceId(groups) : void 0;
    return {
      model: {
        text,
        date,
        groups,
        groupIndex
      },
      container: getPublicElement($cell),
      index: rowIndex
    };
  }
  _renderTableBody(options2, delayCellTemplateRendering) {
    const cellTemplates = [];
    const cellTemplateOpt = options2.cellTemplate;
    this._$rows = [];
    let i;
    const fillTableBody = (function(rowIndex, rowSize) {
      if (rowSize) {
        let date;
        let cellDateNumber;
        let cellDayName;
        const $row = renderer_default("<tr>");
        const $td = renderer_default("<td>");
        setHeight($td, this._getRowHeight(rowSize));
        if (options2.getStartDate) {
          date = options2.getStartDate && options2.getStartDate(rowIndex);
          cellDateNumber = date_default3.format(date, "d");
          cellDayName = date_default3.format(date, formatWeekday);
        }
        if (cellTemplateOpt && cellTemplateOpt.render) {
          const templateOptions = this._prepareCellTemplateOptions(`${cellDateNumber} ${cellDayName}`, date, i, $td);
          cellTemplates.push(cellTemplateOpt.render.bind(cellTemplateOpt, templateOptions));
        } else if (cellDateNumber && cellDayName) {
          $td.addClass(AGENDA_DATE_CLASS).text(`${cellDateNumber} ${cellDayName}`);
        }
        if (options2.rowClass) {
          $row.addClass(options2.rowClass);
        }
        if (options2.cellClass) {
          $td.addClass(options2.cellClass);
        }
        $row.append($td);
        this._$rows.push($row);
      }
    }).bind(this);
    for (i = 0; i < this._rows.length; i++) {
      each(this._rows[i], fillTableBody);
      this._setLastRowClass();
    }
    renderer_default(options2.container).append(renderer_default("<tbody>").append(this._$rows));
    this._applyCellTemplates(cellTemplates);
  }
  _setLastRowClass() {
    if (this._rows.length > 1 && this._$rows.length) {
      const $lastRow = this._$rows[this._$rows.length - 1];
      $lastRow.addClass(LAST_ROW_CLASS);
    }
  }
  _renderTimePanel() {
    this._renderTableBody({
      container: getPublicElement(this._$timePanel),
      rowCount: this._getTimePanelRowCount(),
      cellCount: 1,
      rowClass: TIME_PANEL_ROW_CLASS2,
      cellClass: TIME_PANEL_CELL_CLASS2,
      cellTemplate: this.option("dateCellTemplate"),
      getStartDate: this._getTimePanelStartDate.bind(this)
    });
  }
  _getTimePanelStartDate(rowIndex) {
    const current2 = new Date(this.option("currentDate"));
    const cellDate = new Date(current2.setDate(current2.getDate() + rowIndex));
    return cellDate;
  }
  _getRowHeight(rowSize) {
    const baseHeight = this.option("rowHeight");
    const innerOffset = 5 * (rowSize - 1);
    return rowSize ? baseHeight * rowSize + innerOffset + 20 : 0;
  }
  _getGroupRowHeight(groupRows) {
    if (!groupRows) {
      return;
    }
    let result2 = 0;
    for (let i = 0; i < groupRows.length; i++) {
      result2 += this._getRowHeight(groupRows[i]);
    }
    return result2;
  }
  _calculateRows(appointments) {
    return this.renderingStrategy.calculateRows(appointments, this.option("agendaDuration"), this.option("currentDate"));
  }
  onDataSourceChanged(appointments) {
    super.onDataSourceChanged();
    this._renderView();
    const rows = this._calculateRows(appointments);
    this._recalculateAgenda(rows);
  }
  getAgendaVerticalStepHeight() {
    return this.option("rowHeight");
  }
  getEndViewDate() {
    const currentDate = new Date(this.option("currentDate"));
    const agendaDuration = this.option("agendaDuration");
    currentDate.setHours(this.option("endDayHour"));
    const result2 = currentDate.setDate(currentDate.getDate() + agendaDuration - 1) - 6e4;
    return new Date(result2);
  }
  getEndViewDateByEndDayHour() {
    return this.getEndViewDate();
  }
  getCellDataByCoordinates() {
    return {
      startDate: null,
      endDate: null
    };
  }
  updateScrollPosition(date) {
    const newDate = this.timeZoneCalculator.createDate(date, {
      path: "toGrid"
    });
    const bounds = this.getVisibleBounds();
    const startDateHour = newDate.getHours();
    const startDateMinutes = newDate.getMinutes();
    if (this.needUpdateScrollPosition(startDateHour, startDateMinutes, bounds, newDate)) {
      this.scrollToTime(startDateHour, startDateMinutes, newDate);
    }
  }
  needUpdateScrollPosition(hours, minutes, bounds, newData) {
    let isUpdateNeeded = false;
    if (hours < bounds.top.hours || hours > bounds.bottom.hours) {
      isUpdateNeeded = true;
    }
    if (hours === bounds.top.hours && minutes < bounds.top.minutes) {
      isUpdateNeeded = true;
    }
    if (hours === bounds.bottom.hours && minutes > bounds.top.minutes) {
      isUpdateNeeded = true;
    }
    return isUpdateNeeded;
  }
  renovatedRenderSupported() {
    return false;
  }
  _setSelectedCellsByCellData() {
  }
  _getIntervalDuration() {
    return date_default.dateToMilliseconds("day") * this.option("intervalCount");
  }
  getDOMElementsMetaData() {
    return {
      dateTableCellsMeta: [
        [{}]
      ],
      allDayPanelCellsMeta: [{}]
    };
  }
};
component_registrator_default("dxSchedulerAgenda", SchedulerAgenda);
var m_agenda_default = SchedulerAgenda;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/shaders/m_current_time_shader_horizontal.js
var HorizontalCurrentTimeShader = class extends m_current_time_shader_default {
  renderShader() {
    const groupCount = this._workSpace._isHorizontalGroupedWorkSpace() ? this._workSpace._getGroupCount() : 1;
    for (let i = 0; i < groupCount; i += 1) {
      const isFirstShader = 0 === i;
      const $shader = isFirstShader ? this._$shader : this.createShader();
      if (this._workSpace.isGroupedByDate()) {
        this._customizeGroupedByDateShader($shader, i);
      } else {
        this._customizeShader($shader, i);
      }
      !isFirstShader && this._shader.push($shader);
    }
  }
  _customizeShader($shader, groupIndex) {
    const shaderWidth = this._workSpace.getIndicationWidth();
    this._applyShaderWidth($shader, shaderWidth);
    if (groupIndex >= 1) {
      const workSpace = this._workSpace;
      const indicationWidth = workSpace._getCellCount() * workSpace.getCellWidth();
      $shader.css("left", indicationWidth);
    } else {
      $shader.css("left", 0);
    }
  }
  _applyShaderWidth($shader, width) {
    const maxWidth = getBoundingRect(this._$container.get(0)).width;
    if (width > maxWidth) {
      width = maxWidth;
    }
    if (width > 0) {
      setWidth($shader, width);
    }
  }
  _customizeGroupedByDateShader($shader, groupIndex) {
    const cellCount = this._workSpace.getIndicationCellCount();
    const integerPart = Math.floor(cellCount);
    const fractionPart = cellCount - integerPart;
    const isFirstShaderPart = 0 === groupIndex;
    const workSpace = this._workSpace;
    const shaderWidth = isFirstShaderPart ? workSpace.getIndicationWidth() : fractionPart * workSpace.getCellWidth();
    let shaderLeft;
    this._applyShaderWidth($shader, shaderWidth);
    if (isFirstShaderPart) {
      shaderLeft = workSpace._getCellCount() * workSpace.getCellWidth() * groupIndex;
    } else {
      shaderLeft = workSpace.getCellWidth() * integerPart * workSpace._getGroupCount() + groupIndex * workSpace.getCellWidth();
    }
    $shader.css("left", shaderLeft);
  }
};
var m_current_time_shader_horizontal_default = HorizontalCurrentTimeShader;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_indicator.js
var toMs23 = date_default.dateToMilliseconds;
var TIME_PANEL_CURRENT_TIME_CELL_CLASS = "dx-scheduler-time-panel-current-time-cell";
var SchedulerWorkSpaceIndicator = class extends m_work_space_default {
  _getToday() {
    const viewOffset = this.option("viewOffset");
    const today = getToday(this.option("indicatorTime"), this.timeZoneCalculator);
    return dateUtilsTs.addOffsets(today, [-viewOffset]);
  }
  isIndicationOnView() {
    if (this.option("showCurrentTimeIndicator")) {
      const today = this._getToday();
      const endViewDate = date_default.trimTime(this.getEndViewDate());
      return date_default.dateInRange(today, this.getStartViewDate(), new Date(endViewDate.getTime() + toMs23("day")));
    }
    return false;
  }
  isIndicationAvailable() {
    if (!hasWindow()) {
      return false;
    }
    const today = this._getToday();
    return today >= date_default.trimTime(new Date(this.getStartViewDate()));
  }
  isIndicatorVisible() {
    const today = this._getToday();
    const endViewDate = new Date(this.getEndViewDate().getTime() + toMs23("minute") - 1);
    const firstViewDate = new Date(this.getStartViewDate());
    firstViewDate.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
    endViewDate.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
    return date_default.dateInRange(today, firstViewDate, endViewDate);
  }
  _renderIndicator(height, rtlOffset, $container, groupCount) {
    const groupedByDate = this.isGroupedByDate();
    const repeatCount = groupedByDate ? 1 : groupCount;
    for (let i = 0; i < repeatCount; i++) {
      const $indicator = this._createIndicator($container);
      setWidth($indicator, groupedByDate ? this.getCellWidth() * groupCount : this.getCellWidth());
      this._groupedStrategy.shiftIndicator($indicator, height, rtlOffset, i);
    }
  }
  _createIndicator($container) {
    const $indicator = renderer_default("<div>").addClass("dx-scheduler-date-time-indicator");
    $container.append($indicator);
    return $indicator;
  }
  _getRtlOffset(width) {
    return this.option("rtlEnabled") ? getBoundingRect(this._dateTableScrollable.$content().get(0)).width - this.getTimePanelWidth() - width : 0;
  }
  _setIndicationUpdateInterval() {
    if (!this.option("showCurrentTimeIndicator") || 0 === this.option("indicatorUpdateInterval")) {
      return;
    }
    this._clearIndicatorUpdateInterval();
    this._indicatorInterval = setInterval(() => {
      this.renderCurrentDateTimeIndication();
    }, this.option("indicatorUpdateInterval"));
  }
  _clearIndicatorUpdateInterval() {
    if (this._indicatorInterval) {
      clearInterval(this._indicatorInterval);
      delete this._indicatorInterval;
    }
  }
  _isVerticalShader() {
    return true;
  }
  getIndicationWidth(groupIndex) {
    const maxWidth = this.getCellWidth() * this._getCellCount();
    let difference = this._getIndicatorDuration();
    if (difference > this._getCellCount()) {
      difference = this._getCellCount();
    }
    const width = difference * this.getRoundedCellWidth(groupIndex, groupIndex * this._getCellCount(), difference);
    return maxWidth < width ? maxWidth : width;
  }
  getIndicatorOffset(groupIndex) {
    const difference = this._getIndicatorDuration() - 1;
    const offset2 = difference * this.getRoundedCellWidth(groupIndex, groupIndex * this._getCellCount(), difference);
    return offset2;
  }
  _getIndicatorDuration() {
    const today = this._getToday();
    const firstViewDate = new Date(this.getStartViewDate());
    let timeDiff = today.getTime() - firstViewDate.getTime();
    if ("workWeek" === this.option("type")) {
      timeDiff -= this._getWeekendsCount(Math.round(timeDiff / toMs23("day"))) * toMs23("day");
    }
    return Math.ceil((timeDiff + 1) / toMs23("day"));
  }
  getIndicationHeight() {
    const today = m_utils_time_zone_default.getDateWithoutTimezoneChange(this._getToday());
    const cellHeight = this.getCellHeight();
    const date = new Date(this.getStartViewDate());
    if (this.isIndicationOnView()) {
      date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
    }
    const duration = today.getTime() - date.getTime();
    const cellCount = duration / this.getCellDuration();
    return cellCount * cellHeight;
  }
  _dispose() {
    this._clearIndicatorUpdateInterval();
    super._dispose.apply(this, arguments);
  }
  renderCurrentDateTimeIndication() {
    this.renderCurrentDateTimeLineAndShader();
    if (this.isRenovatedRender()) {
      this.renderWorkSpace({
        generateNewData: true,
        renderComponents: {
          header: true,
          timePanel: true
        }
      });
    }
  }
  renderCurrentDateTimeLineAndShader() {
    var _this$_shader;
    this._cleanDateTimeIndicator();
    null === (_this$_shader = this._shader) || void 0 === _this$_shader || _this$_shader.clean();
    this._renderDateTimeIndication();
  }
  _isCurrentTimeHeaderCell(headerIndex) {
    if (this.isIndicationOnView()) {
      const {
        completeDateHeaderMap
      } = this.viewDataProvider;
      const date = completeDateHeaderMap[completeDateHeaderMap.length - 1][headerIndex].startDate;
      return date_default.sameDate(date, this._getToday());
    }
    return false;
  }
  _getHeaderPanelCellClass(i) {
    const cellClass = super._getHeaderPanelCellClass(i);
    if (this._isCurrentTimeHeaderCell(i)) {
      return `${cellClass} ${HEADER_CURRENT_TIME_CELL_CLASS}`;
    }
    return cellClass;
  }
  _cleanView() {
    super._cleanView();
    this._cleanDateTimeIndicator();
  }
  _dimensionChanged() {
    super._dimensionChanged();
    this.renderCurrentDateTimeLineAndShader();
  }
  _cleanDateTimeIndicator() {
    this.$element().find(".dx-scheduler-date-time-indicator").remove();
  }
  _cleanWorkSpace() {
    super._cleanWorkSpace();
    this._renderDateTimeIndication();
    this._setIndicationUpdateInterval();
  }
  _optionChanged(args) {
    switch (args.name) {
      case "showCurrentTimeIndicator":
      case "indicatorTime":
        this._cleanWorkSpace();
        break;
      case "indicatorUpdateInterval":
        this._setIndicationUpdateInterval();
        break;
      case "showAllDayPanel":
      case "allDayExpanded":
      case "crossScrollingEnabled":
        super._optionChanged(args);
        this.renderCurrentDateTimeIndication();
        break;
      case "shadeUntilCurrentTime":
        this.renderCurrentDateTimeIndication();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      showCurrentTimeIndicator: true,
      indicatorTime: /* @__PURE__ */ new Date(),
      indicatorUpdateInterval: 5 * toMs23("minute"),
      shadeUntilCurrentTime: true
    });
  }
  _getCurrentTimePanelCellIndices() {
    const rowCountPerGroup = this._getTimePanelRowCount();
    const today = this._getToday();
    const index2 = this.getCellIndexByDate(today);
    const {
      rowIndex: currentTimeRowIndex
    } = this._getCellCoordinatesByIndex(index2);
    if (void 0 === currentTimeRowIndex) {
      return [];
    }
    let cellIndices;
    if (0 === currentTimeRowIndex) {
      cellIndices = [currentTimeRowIndex];
    } else {
      cellIndices = currentTimeRowIndex % 2 === 0 ? [currentTimeRowIndex - 1, currentTimeRowIndex] : [currentTimeRowIndex, currentTimeRowIndex + 1];
    }
    const verticalGroupCount = this._isVerticalGroupedWorkSpace() ? this._getGroupCount() : 1;
    return [...new Array(verticalGroupCount)].reduce((currentIndices, _, groupIndex) => [...currentIndices, ...cellIndices.map((cellIndex) => rowCountPerGroup * groupIndex + cellIndex)], []);
  }
  _renderDateTimeIndication() {
    if (!this.isIndicationAvailable()) {
      return;
    }
    if (this.option("shadeUntilCurrentTime")) {
      this._shader.render();
    }
    if (!this.isIndicationOnView() || !this.isIndicatorVisible()) {
      return;
    }
    const groupCount = this._getGroupCount() || 1;
    const $container = this._dateTableScrollable.$content();
    const height = this.getIndicationHeight();
    const rtlOffset = this._getRtlOffset(this.getCellWidth());
    this._renderIndicator(height, rtlOffset, $container, groupCount);
    if (!this.isRenovatedRender()) {
      this._setCurrentTimeCells();
    }
  }
  _setCurrentTimeCells() {
    const timePanelCells = this._getTimePanelCells();
    const currentTimeCellIndices = this._getCurrentTimePanelCellIndices();
    currentTimeCellIndices.forEach((timePanelCellIndex) => {
      timePanelCells.eq(timePanelCellIndex).addClass(TIME_PANEL_CURRENT_TIME_CELL_CLASS);
    });
  }
  _cleanCurrentTimeCells() {
    this.$element().find(`.${TIME_PANEL_CURRENT_TIME_CELL_CLASS}`).removeClass(TIME_PANEL_CURRENT_TIME_CELL_CLASS);
  }
};
component_registrator_default("dxSchedulerWorkSpace", SchedulerWorkSpaceIndicator);
var m_work_space_indicator_default = SchedulerWorkSpaceIndicator;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_timeline.js
var {
  tableCreator: tableCreator3
} = m_table_creator_default;
var TIMELINE_CLASS = "dx-scheduler-timeline";
var GROUP_TABLE_CLASS2 = "dx-scheduler-group-table";
var HORIZONTAL_GROUPED_WORKSPACE_CLASS = "dx-scheduler-work-space-horizontal-grouped";
var HEADER_PANEL_CELL_CLASS2 = "dx-scheduler-header-panel-cell";
var HEADER_PANEL_WEEK_CELL_CLASS = "dx-scheduler-header-panel-week-cell";
var HEADER_ROW_CLASS2 = "dx-scheduler-header-row";
var HORIZONTAL5 = "horizontal";
var toMs24 = date_default.dateToMilliseconds;
var SchedulerTimeline = class extends m_work_space_indicator_default {
  constructor() {
    super(...arguments);
    this.viewDirection = "horizontal";
  }
  get verticalGroupTableClass() {
    return GROUP_TABLE_CLASS2;
  }
  get renovatedHeaderPanelComponent() {
    return HeaderPanelTimelineComponent;
  }
  getGroupTableWidth() {
    return this._$sidebarTable ? getOuterWidth(this._$sidebarTable) : 0;
  }
  _getTotalRowCount(groupCount) {
    if (this._isHorizontalGroupedWorkSpace()) {
      return this._getRowCount();
    }
    groupCount = groupCount || 1;
    return this._getRowCount() * groupCount;
  }
  _getFormat() {
    return "shorttime";
  }
  _getWorkSpaceHeight() {
    if (this.option("crossScrollingEnabled") && hasWindow()) {
      return getBoundingRect(this._$dateTable.get(0)).height;
    }
    return getBoundingRect(this.$element().get(0)).height;
  }
  _dateTableScrollableConfig() {
    const config3 = super._dateTableScrollableConfig();
    const timelineConfig = {
      direction: HORIZONTAL5
    };
    return this.option("crossScrollingEnabled") ? config3 : extend(config3, timelineConfig);
  }
  _needCreateCrossScrolling() {
    return true;
  }
  _headerScrollableConfig() {
    const config3 = super._headerScrollableConfig();
    return extend(config3, {
      scrollByContent: true
    });
  }
  supportAllDayRow() {
    return false;
  }
  _getGroupHeaderContainer() {
    if (this._isHorizontalGroupedWorkSpace()) {
      return this._$thead;
    }
    return this._$sidebarTable;
  }
  _insertAllDayRowsIntoDateTable() {
    return false;
  }
  _needRenderWeekHeader() {
    return false;
  }
  _incrementDate(date) {
    date.setDate(date.getDate() + 1);
  }
  getIndicationCellCount() {
    const timeDiff = this._getTimeDiff();
    return this._calculateDurationInCells(timeDiff);
  }
  _getTimeDiff() {
    let today = this._getToday();
    const date = this._getIndicationFirstViewDate();
    const startViewDate = this.getStartViewDate();
    const dayLightOffset = m_utils_time_zone_default.getDaylightOffsetInMs(startViewDate, today);
    if (dayLightOffset) {
      today = new Date(today.getTime() + dayLightOffset);
    }
    return today.getTime() - date.getTime();
  }
  _calculateDurationInCells(timeDiff) {
    const today = this._getToday();
    const differenceInDays = Math.floor(timeDiff / toMs24("day"));
    let duration = (timeDiff - differenceInDays * toMs24("day") - this.option("startDayHour") * toMs24("hour")) / this.getCellDuration();
    if (today.getHours() > this.option("endDayHour")) {
      duration = this._getCellCountInDay();
    }
    if (duration < 0) {
      duration = 0;
    }
    return differenceInDays * this._getCellCountInDay() + duration;
  }
  getIndicationWidth() {
    if (this.isGroupedByDate()) {
      const cellCount = this.getIndicationCellCount();
      const integerPart = Math.floor(cellCount);
      const fractionPart = cellCount - integerPart;
      return this.getCellWidth() * (integerPart * this._getGroupCount() + fractionPart);
    }
    return this.getIndicationCellCount() * this.getCellWidth();
  }
  _isVerticalShader() {
    return false;
  }
  _isCurrentTimeHeaderCell() {
    return false;
  }
  _setTableSizes() {
    super._setTableSizes();
    const minHeight = this._getWorkSpaceMinHeight();
    setHeight(this._$sidebarTable, minHeight);
    setHeight(this._$dateTable, minHeight);
    this.virtualScrollingDispatcher.updateDimensions();
  }
  _getWorkSpaceMinHeight() {
    let minHeight = this._getWorkSpaceHeight();
    const workspaceContainerHeight = getOuterHeight(this._$flexContainer, true);
    if (minHeight < workspaceContainerHeight) {
      minHeight = workspaceContainerHeight;
    }
    return minHeight;
  }
  _getCellCoordinatesByIndex(index2) {
    return {
      columnIndex: index2 % this._getCellCount(),
      rowIndex: 0
    };
  }
  _getCellByCoordinates(cellCoordinates, groupIndex) {
    const indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex);
    return this._$dateTable.find("tr").eq(indexes.rowIndex).find("td").eq(indexes.columnIndex);
  }
  _getWorkSpaceWidth() {
    return getOuterWidth(this._$dateTable, true);
  }
  _getIndicationFirstViewDate() {
    return date_default.trimTime(new Date(this.getStartViewDate()));
  }
  _getIntervalBetween(currentDate, allDay) {
    const startDayHour = this.option("startDayHour");
    const endDayHour = this.option("endDayHour");
    const firstViewDate = this.getStartViewDate();
    const firstViewDateTime = firstViewDate.getTime();
    const hiddenInterval = (24 - endDayHour + startDayHour) * toMs24("hour");
    const timeZoneOffset = date_default.getTimezonesDifference(firstViewDate, currentDate);
    const apptStart = currentDate.getTime();
    const fullInterval = apptStart - firstViewDateTime - timeZoneOffset;
    const fullDays = Math.floor(fullInterval / toMs24("day"));
    const tailDuration = fullInterval - fullDays * toMs24("day");
    let tailDelta = 0;
    const cellCount = this._getCellCountInDay() * (fullDays - this._getWeekendsCount(fullDays));
    const gapBeforeAppt = apptStart - date_default.trimTime(new Date(currentDate)).getTime();
    let result2 = cellCount * this.option("hoursInterval") * toMs24("hour");
    if (!allDay) {
      if (currentDate.getHours() < startDayHour) {
        tailDelta = tailDuration - hiddenInterval + gapBeforeAppt;
      } else if (currentDate.getHours() >= startDayHour && currentDate.getHours() < endDayHour) {
        tailDelta = tailDuration;
      } else if (currentDate.getHours() >= startDayHour && currentDate.getHours() >= endDayHour) {
        tailDelta = tailDuration - (gapBeforeAppt - endDayHour * toMs24("hour"));
      } else if (!fullDays) {
        result2 = fullInterval;
      }
      result2 += tailDelta;
    }
    return result2;
  }
  _getWeekendsCount(argument) {
    return 0;
  }
  getAllDayContainer() {
    return null;
  }
  getTimePanelWidth() {
    return 0;
  }
  getIntervalDuration(allDay) {
    return this.getCellDuration();
  }
  getCellMinWidth() {
    return 0;
  }
  getWorkSpaceLeftOffset() {
    return 0;
  }
  scrollToTime(hours, minutes, date) {
    const coordinates = this._getScrollCoordinates(hours, minutes, date);
    const scrollable = this.getScrollable();
    const offset2 = this.option("rtlEnabled") ? getBoundingRect(this.getScrollableContainer().get(0)).width : 0;
    if (this.option("templatesRenderAsynchronously")) {
      setTimeout(() => {
        scrollable.scrollBy({
          left: coordinates.left - scrollable.scrollLeft() - offset2,
          top: 0
        });
      });
    } else {
      scrollable.scrollBy({
        left: coordinates.left - scrollable.scrollLeft() - offset2,
        top: 0
      });
    }
  }
  renderRAllDayPanel() {
  }
  renderRTimeTable() {
  }
  _renderGroupAllDayPanel() {
  }
  generateRenderOptions(argument) {
    const options2 = super.generateRenderOptions(true);
    return _extends({}, options2, {
      isGenerateWeekDaysHeaderData: this._needRenderWeekHeader(),
      getDateForHeaderText: timelineWeekUtils.getDateForHeaderText
    });
  }
  _init() {
    super._init();
    this.$element().addClass(TIMELINE_CLASS);
    this._$sidebarTable = renderer_default("<div>").addClass(GROUP_TABLE_CLASS2);
  }
  _getDefaultGroupStrategy() {
    return "vertical";
  }
  _toggleGroupingDirectionClass() {
    this.$element().toggleClass(HORIZONTAL_GROUPED_WORKSPACE_CLASS, this._isHorizontalGroupedWorkSpace());
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      groupOrientation: "vertical"
    });
  }
  _createWorkSpaceElements() {
    this._createWorkSpaceScrollableElements();
  }
  _toggleAllDayVisibility() {
    return noop2();
  }
  _changeAllDayVisibility() {
    return noop2();
  }
  _getDateHeaderTemplate() {
    return this.option("timeCellTemplate");
  }
  _renderView() {
    let groupCellTemplates;
    if (!this.isRenovatedRender()) {
      groupCellTemplates = this._renderGroupHeader();
    }
    this.renderWorkSpace();
    if (this.isRenovatedRender()) {
      this.virtualScrollingDispatcher.updateDimensions();
    }
    this._shader = new m_current_time_shader_horizontal_default(this);
    this._$sidebarTable.appendTo(this._sidebarScrollable.$content());
    if (this.isRenovatedRender() && this._isVerticalGroupedWorkSpace()) {
      this.renderRGroupPanel();
    }
    this.updateHeaderEmptyCellWidth();
    this._applyCellTemplates(groupCellTemplates);
  }
  _setHorizontalGroupHeaderCellsHeight() {
    return noop2();
  }
  _getTimePanelCells() {
    return this.$element().find(`.${HEADER_PANEL_CELL_CLASS2}:not(.${HEADER_PANEL_WEEK_CELL_CLASS})`);
  }
  _getCurrentTimePanelCellIndices() {
    const columnCountPerGroup = this._getCellCount();
    const today = this._getToday();
    const index2 = this.getCellIndexByDate(today);
    const {
      columnIndex: currentTimeColumnIndex
    } = this._getCellCoordinatesByIndex(index2);
    if (void 0 === currentTimeColumnIndex) {
      return [];
    }
    const horizontalGroupCount = this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate() ? this._getGroupCount() : 1;
    return [...new Array(horizontalGroupCount)].map((_, groupIndex) => columnCountPerGroup * groupIndex + currentTimeColumnIndex);
  }
  _renderTimePanel() {
    return noop2();
  }
  _renderAllDayPanel() {
    return noop2();
  }
  _createAllDayPanelElements() {
    return noop2();
  }
  _renderDateHeader() {
    const $headerRow = super._renderDateHeader();
    if (this._needRenderWeekHeader()) {
      const firstViewDate = new Date(this.getStartViewDate());
      let currentDate = new Date(firstViewDate);
      const $cells = [];
      const groupCount = this._getGroupCount();
      const cellCountInDay = this._getCellCountInDay();
      const colSpan = this.isGroupedByDate() ? cellCountInDay * groupCount : cellCountInDay;
      const cellTemplate = this.option("dateCellTemplate");
      const horizontalGroupCount = this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate() ? groupCount : 1;
      const cellsInGroup = this.viewDataProvider.viewDataGenerator.daysInInterval * this.option("intervalCount");
      const cellsCount = cellsInGroup * horizontalGroupCount;
      for (let templateIndex = 0; templateIndex < cellsCount; templateIndex++) {
        const $th = renderer_default("<th>");
        const text = formatWeekdayAndDay(currentDate);
        if (cellTemplate) {
          const templateOptions = {
            model: _extends({
              text,
              date: new Date(currentDate)
            }, this._getGroupsForDateHeaderTemplate(templateIndex, colSpan)),
            container: $th,
            index: templateIndex
          };
          cellTemplate.render(templateOptions);
        } else {
          $th.text(text);
        }
        $th.addClass(HEADER_PANEL_CELL_CLASS2).addClass(HEADER_PANEL_WEEK_CELL_CLASS).attr("colSpan", colSpan);
        $cells.push($th);
        if (templateIndex % cellsInGroup === cellsInGroup - 1) {
          currentDate = new Date(firstViewDate);
        } else {
          this._incrementDate(currentDate);
        }
      }
      const $row = renderer_default("<tr>").addClass(HEADER_ROW_CLASS2).append($cells);
      $headerRow.before($row);
    }
  }
  _renderIndicator(height, rtlOffset, $container, groupCount) {
    let $indicator;
    const width = this.getIndicationWidth();
    if ("vertical" === this.option("groupOrientation")) {
      $indicator = this._createIndicator($container);
      setHeight($indicator, getBoundingRect($container.get(0)).height);
      $indicator.css("left", rtlOffset ? rtlOffset - width : width);
    } else {
      for (let i = 0; i < groupCount; i++) {
        const offset2 = this.isGroupedByDate() ? i * this.getCellWidth() : this._getCellCount() * this.getCellWidth() * i;
        $indicator = this._createIndicator($container);
        setHeight($indicator, getBoundingRect($container.get(0)).height);
        $indicator.css("left", rtlOffset ? rtlOffset - width - offset2 : width + offset2);
      }
    }
  }
  _makeGroupRows(groups, groupByDate) {
    const tableCreatorStrategy = "vertical" === this.option("groupOrientation") ? tableCreator3.VERTICAL : tableCreator3.HORIZONTAL;
    return tableCreator3.makeGroupedTable(tableCreatorStrategy, groups, {
      groupRowClass: GROUP_ROW_CLASS,
      groupHeaderRowClass: GROUP_ROW_CLASS,
      groupHeaderClass: this._getGroupHeaderClass.bind(this),
      groupHeaderContentClass: GROUP_HEADER_CONTENT_CLASS
    }, this._getCellCount() || 1, this.option("resourceCellTemplate"), this._getTotalRowCount(this._getGroupCount()), groupByDate);
  }
  _setCurrentTimeCells() {
    const timePanelCells = this._getTimePanelCells();
    const currentTimeCellIndices = this._getCurrentTimePanelCellIndices();
    currentTimeCellIndices.forEach((timePanelCellIndex) => {
      timePanelCells.eq(timePanelCellIndex).addClass(HEADER_CURRENT_TIME_CELL_CLASS);
    });
  }
  _cleanCurrentTimeCells() {
    this.$element().find(`.${HEADER_CURRENT_TIME_CELL_CLASS}`).removeClass(HEADER_CURRENT_TIME_CELL_CLASS);
  }
};
component_registrator_default("dxSchedulerTimeline", SchedulerTimeline);
var m_timeline_default = SchedulerTimeline;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_timeline_day.js
var TIMELINE_CLASS2 = "dx-scheduler-timeline-day";
var SchedulerTimelineDay = class extends m_timeline_default {
  get type() {
    return VIEWS.TIMELINE_DAY;
  }
  _getElementClass() {
    return TIMELINE_CLASS2;
  }
  _needRenderWeekHeader() {
    return this._isWorkSpaceWithCount();
  }
};
component_registrator_default("dxSchedulerTimelineDay", SchedulerTimelineDay);
var m_timeline_day_default = SchedulerTimelineDay;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_timeline_month.js
var TIMELINE_CLASS3 = "dx-scheduler-timeline-month";
var SchedulerTimelineMonth = class extends m_timeline_default {
  constructor() {
    super(...arguments);
    this.viewDirection = "horizontal";
  }
  get type() {
    return VIEWS.TIMELINE_MONTH;
  }
  get renovatedHeaderPanelComponent() {
    return HeaderPanelComponent;
  }
  _renderView() {
    super._renderView();
    this._updateScrollable();
  }
  _getElementClass() {
    return TIMELINE_CLASS3;
  }
  _getDateHeaderTemplate() {
    return this.option("dateCellTemplate");
  }
  _calculateDurationInCells(timeDiff) {
    return timeDiff / this.getCellDuration();
  }
  isIndicatorVisible() {
    return true;
  }
  _getFormat() {
    return formatWeekdayAndDay;
  }
  _getIntervalBetween(currentDate) {
    const firstViewDate = this.getStartViewDate();
    const timeZoneOffset = date_default.getTimezonesDifference(firstViewDate, currentDate);
    return currentDate.getTime() - (firstViewDate.getTime() - 36e5 * this.option("startDayHour")) - timeZoneOffset;
  }
  _getViewStartByOptions() {
    return monthUtils.getViewStartByOptions(this.option("startDate"), this.option("currentDate"), this.option("intervalCount"), date_default.getFirstMonthDate(this.option("startDate")));
  }
  generateRenderOptions() {
    const options2 = super.generateRenderOptions(true);
    return _extends({}, options2, {
      getDateForHeaderText: (_, date) => date
    });
  }
  keepOriginalHours() {
    return true;
  }
};
component_registrator_default("dxSchedulerTimelineMonth", SchedulerTimelineMonth);
var m_timeline_month_default = SchedulerTimelineMonth;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_timeline_week.js
var TIMELINE_CLASS4 = "dx-scheduler-timeline-week";
var SchedulerTimelineWeek = class extends m_timeline_default {
  get type() {
    return VIEWS.TIMELINE_WEEK;
  }
  _getElementClass() {
    return TIMELINE_CLASS4;
  }
  _getHeaderPanelCellWidth($headerRow) {
    return getBoundingRect($headerRow.children().first().get(0)).width;
  }
  _needRenderWeekHeader() {
    return true;
  }
  _incrementDate(date) {
    date.setDate(date.getDate() + 1);
  }
};
component_registrator_default("dxSchedulerTimelineWeek", SchedulerTimelineWeek);

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_timeline_work_week.js
var TIMELINE_CLASS5 = "dx-scheduler-timeline-work-week";
var SchedulerTimelineWorkWeek = class extends SchedulerTimelineWeek {
  get type() {
    return VIEWS.TIMELINE_WORK_WEEK;
  }
  constructor() {
    super(...arguments);
    this._getWeekendsCount = getWeekendsCount;
  }
  _getElementClass() {
    return TIMELINE_CLASS5;
  }
  _incrementDate(date) {
    const day = date.getDay();
    if (5 === day) {
      date.setDate(date.getDate() + 2);
    }
    super._incrementDate(date);
  }
};
component_registrator_default("dxSchedulerTimelineWorkWeek", SchedulerTimelineWorkWeek);
var m_timeline_work_week_default = SchedulerTimelineWorkWeek;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_vertical.js
var SchedulerWorkspaceVertical = class extends m_work_space_indicator_default {
  _getFormat() {
    return formatWeekdayAndDay;
  }
  generateRenderOptions() {
    const options2 = super.generateRenderOptions();
    return _extends({}, options2, {
      isGenerateTimePanelData: true
    });
  }
  _isRenderHeaderPanelEmptyCell() {
    return true;
  }
};
var m_work_space_vertical_default = SchedulerWorkspaceVertical;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_day.js
var DAY_CLASS = "dx-scheduler-work-space-day";
var SchedulerWorkSpaceDay = class extends m_work_space_vertical_default {
  get type() {
    return VIEWS.DAY;
  }
  _getElementClass() {
    return DAY_CLASS;
  }
  _renderDateHeader() {
    return 1 === this.option("intervalCount") ? null : super._renderDateHeader();
  }
  renderRHeaderPanel() {
    if (1 === this.option("intervalCount")) {
      super.renderRHeaderPanel(false);
    } else {
      super.renderRHeaderPanel(true);
    }
  }
};
component_registrator_default("dxSchedulerWorkSpaceDay", SchedulerWorkSpaceDay);
var m_work_space_day_default = SchedulerWorkSpaceDay;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_month.js
var MONTH_CLASS = "dx-scheduler-work-space-month";
var DATE_TABLE_CURRENT_DATE_CLASS = "dx-scheduler-date-table-current-date";
var DATE_TABLE_CELL_TEXT_CLASS = "dx-scheduler-date-table-cell-text";
var DATE_TABLE_FIRST_OF_MONTH_CLASS = "dx-scheduler-date-table-first-of-month";
var DATE_TABLE_OTHER_MONTH_DATE_CLASS = "dx-scheduler-date-table-other-month";
var toMs25 = date_default.dateToMilliseconds;
var SchedulerWorkSpaceMonth = class extends m_work_space_indicator_default {
  get type() {
    return VIEWS.MONTH;
  }
  _getElementClass() {
    return MONTH_CLASS;
  }
  _getFormat() {
    return formatWeekday;
  }
  _getIntervalBetween(currentDate) {
    const firstViewDate = this.getStartViewDate();
    const timeZoneOffset = date_default.getTimezonesDifference(firstViewDate, currentDate);
    return currentDate.getTime() - (firstViewDate.getTime() - 36e5 * this.option("startDayHour")) - timeZoneOffset;
  }
  _getDateGenerationOptions() {
    return _extends({}, super._getDateGenerationOptions(), {
      cellCountInDay: 1
    });
  }
  getCellWidth() {
    return this.cache.get("cellWidth", () => {
      let averageWidth = 0;
      const cells = this._getCells().slice(0, 7);
      cells.each((index2, element) => {
        averageWidth += hasWindow() ? getBoundingRect(element).width : 0;
      });
      return 0 === cells.length ? void 0 : averageWidth / 7;
    });
  }
  _insertAllDayRowsIntoDateTable() {
    return false;
  }
  _getCellCoordinatesByIndex(index2) {
    const rowIndex = Math.floor(index2 / this._getCellCount());
    const columnIndex = index2 - this._getCellCount() * rowIndex;
    return {
      rowIndex,
      columnIndex
    };
  }
  _needCreateCrossScrolling() {
    return this.option("crossScrollingEnabled") || this._isVerticalGroupedWorkSpace();
  }
  _getViewStartByOptions() {
    return monthUtils.getViewStartByOptions(this.option("startDate"), this.option("currentDate"), this.option("intervalCount"), date_default.getFirstMonthDate(this.option("startDate")));
  }
  _updateIndex(index2) {
    return index2;
  }
  isIndicationAvailable() {
    return false;
  }
  getIntervalDuration() {
    return toMs25("day");
  }
  getTimePanelWidth() {
    return 0;
  }
  supportAllDayRow() {
    return false;
  }
  keepOriginalHours() {
    return true;
  }
  getWorkSpaceLeftOffset() {
    return 0;
  }
  needApplyCollectorOffset() {
    return true;
  }
  _getHeaderDate() {
    return this._getViewStartByOptions();
  }
  scrollToTime() {
    return noop2();
  }
  renderRAllDayPanel() {
  }
  renderRTimeTable() {
  }
  renderRDateTable() {
    utils2.renovation.renderComponent(this, this._$dateTable, DateTableMonthComponent, "renovatedDateTable", this._getRDateTableProps());
  }
  _createWorkSpaceElements() {
    if (this._isVerticalGroupedWorkSpace()) {
      this._createWorkSpaceScrollableElements();
    } else {
      super._createWorkSpaceElements();
    }
  }
  _toggleAllDayVisibility() {
    return noop2();
  }
  _changeAllDayVisibility() {
    return noop2();
  }
  _renderTimePanel() {
    return noop2();
  }
  _renderAllDayPanel() {
    return noop2();
  }
  _setMonthClassesToCell($cell, data2) {
    $cell.toggleClass(DATE_TABLE_CURRENT_DATE_CLASS, data2.isCurrentDate).toggleClass(DATE_TABLE_FIRST_OF_MONTH_CLASS, data2.firstDayOfMonth).toggleClass(DATE_TABLE_OTHER_MONTH_DATE_CLASS, data2.otherMonth);
  }
  _createAllDayPanelElements() {
  }
  _renderTableBody(options2) {
    options2.getCellText = (rowIndex, columnIndex) => {
      const date = this.viewDataProvider.completeViewDataMap[rowIndex][columnIndex].startDate;
      return monthUtils.getCellText(date, this.option("intervalCount"));
    };
    options2.getCellTextClass = DATE_TABLE_CELL_TEXT_CLASS;
    options2.setAdditionalClasses = this._setMonthClassesToCell.bind(this);
    super._renderTableBody(options2);
  }
};
component_registrator_default("dxSchedulerWorkSpaceMonth", SchedulerWorkSpaceMonth);
var m_work_space_month_default = SchedulerWorkSpaceMonth;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_week.js
var WEEK_CLASS = "dx-scheduler-work-space-week";
var SchedulerWorkSpaceWeek = class extends m_work_space_vertical_default {
  get type() {
    return VIEWS.WEEK;
  }
  _getElementClass() {
    return WEEK_CLASS;
  }
  _calculateViewStartDate() {
    return weekUtils.calculateViewStartDate(this.option("startDate"), this._firstDayOfWeek());
  }
};
component_registrator_default("dxSchedulerWorkSpaceWeek", SchedulerWorkSpaceWeek);
var m_work_space_week_default = SchedulerWorkSpaceWeek;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/workspaces/m_work_space_work_week.js
var WORK_WEEK_CLASS = "dx-scheduler-work-space-work-week";
var SchedulerWorkSpaceWorkWeek = class extends m_work_space_week_default {
  get type() {
    return VIEWS.WORK_WEEK;
  }
  constructor() {
    super(...arguments);
    this._getWeekendsCount = getWeekendsCount;
  }
  _getElementClass() {
    return WORK_WEEK_CLASS;
  }
};
component_registrator_default("dxSchedulerWorkSpaceWorkWeek", SchedulerWorkSpaceWorkWeek);
var m_work_space_work_week_default = SchedulerWorkSpaceWorkWeek;

// ../../../../../../node_modules/devextreme/esm/__internal/scheduler/m_scheduler.js
var toMs26 = date_default.dateToMilliseconds;
var WIDGET_CLASS2 = "dx-scheduler";
var WIDGET_SMALL_CLASS = `${WIDGET_CLASS2}-small`;
var WIDGET_ADAPTIVE_CLASS = `${WIDGET_CLASS2}-adaptive`;
var WIDGET_READONLY_CLASS = `${WIDGET_CLASS2}-readonly`;
var FULL_DATE_FORMAT3 = "yyyyMMddTHHmmss";
var UTC_FULL_DATE_FORMAT2 = `${FULL_DATE_FORMAT3}Z`;
var VIEWS_CONFIG = {
  day: {
    workSpace: m_work_space_day_default,
    renderingStrategy: "vertical"
  },
  week: {
    workSpace: m_work_space_week_default,
    renderingStrategy: "vertical"
  },
  workWeek: {
    workSpace: m_work_space_work_week_default,
    renderingStrategy: "vertical"
  },
  month: {
    workSpace: m_work_space_month_default,
    renderingStrategy: "horizontalMonth"
  },
  timelineDay: {
    workSpace: m_timeline_day_default,
    renderingStrategy: "horizontal"
  },
  timelineWeek: {
    workSpace: SchedulerTimelineWeek,
    renderingStrategy: "horizontal"
  },
  timelineWorkWeek: {
    workSpace: m_timeline_work_week_default,
    renderingStrategy: "horizontal"
  },
  timelineMonth: {
    workSpace: m_timeline_month_default,
    renderingStrategy: "horizontalMonthLine"
  },
  agenda: {
    workSpace: m_agenda_default,
    renderingStrategy: "agenda"
  }
};
var StoreEventNames = {
  ADDING: "onAppointmentAdding",
  ADDED: "onAppointmentAdded",
  DELETING: "onAppointmentDeleting",
  DELETED: "onAppointmentDeleted",
  UPDATING: "onAppointmentUpdating",
  UPDATED: "onAppointmentUpdated"
};
var RECURRENCE_EDITING_MODE = {
  SERIES: "editSeries",
  OCCURENCE: "editOccurence",
  CANCEL: "cancel"
};
var Scheduler = class extends ui_widget_default {
  _getDefaultOptions() {
    const defaultOptions3 = extend(super._getDefaultOptions(), {
      views: ["day", "week"],
      currentView: "day",
      currentDate: date_default.trimTime(/* @__PURE__ */ new Date()),
      min: void 0,
      max: void 0,
      dateSerializationFormat: void 0,
      firstDayOfWeek: void 0,
      groups: [],
      resources: [],
      loadedResources: [],
      resourceLoaderMap: /* @__PURE__ */ new Map(),
      dataSource: null,
      customizeDateNavigatorText: void 0,
      appointmentTemplate: "item",
      dropDownAppointmentTemplate: "dropDownAppointment",
      appointmentCollectorTemplate: "appointmentCollector",
      dataCellTemplate: null,
      timeCellTemplate: null,
      resourceCellTemplate: null,
      dateCellTemplate: null,
      startDayHour: 0,
      endDayHour: 24,
      offset: 0,
      editing: {
        allowAdding: true,
        allowDeleting: true,
        allowDragging: true,
        allowResizing: true,
        allowUpdating: true,
        allowTimeZoneEditing: false
      },
      showAllDayPanel: true,
      showCurrentTimeIndicator: true,
      shadeUntilCurrentTime: false,
      indicatorUpdateInterval: 3e5,
      indicatorTime: void 0,
      recurrenceEditMode: "dialog",
      cellDuration: 30,
      maxAppointmentsPerCell: "auto",
      selectedCellData: [],
      groupByDate: false,
      onAppointmentRendered: null,
      onAppointmentClick: null,
      onAppointmentDblClick: null,
      onAppointmentContextMenu: null,
      onCellClick: null,
      onCellContextMenu: null,
      onAppointmentAdding: null,
      onAppointmentAdded: null,
      onAppointmentUpdating: null,
      onAppointmentUpdated: null,
      onAppointmentDeleting: null,
      onAppointmentDeleted: null,
      onAppointmentFormOpening: null,
      onAppointmentTooltipShowing: null,
      appointmentTooltipTemplate: "appointmentTooltip",
      appointmentPopupTemplate: "appointmentPopup",
      crossScrollingEnabled: false,
      useDropDownViewSwitcher: false,
      startDateExpr: "startDate",
      endDateExpr: "endDate",
      textExpr: "text",
      descriptionExpr: "description",
      allDayExpr: "allDay",
      recurrenceRuleExpr: "recurrenceRule",
      recurrenceExceptionExpr: "recurrenceException",
      disabledExpr: "disabled",
      remoteFiltering: false,
      timeZone: "",
      startDateTimeZoneExpr: "startDateTimeZone",
      endDateTimeZoneExpr: "endDateTimeZone",
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      adaptivityEnabled: false,
      allowMultipleCellSelection: true,
      scrolling: {
        mode: "standard"
      },
      allDayPanelMode: "all",
      renovateRender: true,
      _draggingMode: "outlook",
      _appointmentTooltipOffset: {
        x: 0,
        y: 0
      },
      _appointmentTooltipButtonsPosition: "bottom",
      _appointmentTooltipOpenButtonText: message_default.format("dxScheduler-openAppointment"),
      _appointmentCountPerCell: 2,
      _collectorOffset: 0,
      _appointmentOffset: 26,
      toolbar: [{
        location: "before",
        defaultElement: "dateNavigator"
      }, {
        location: "after",
        defaultElement: "viewSwitcher"
      }]
    });
    return extend(true, defaultOptions3, {
      integrationOptions: {
        useDeferUpdateForTemplates: false
      }
    });
  }
  get filteredItems() {
    if (!this._filteredItems) {
      this._filteredItems = [];
    }
    return this._filteredItems;
  }
  set filteredItems(value2) {
    this._filteredItems = value2;
  }
  get preparedItems() {
    if (!this._preparedItems) {
      this._preparedItems = [];
    }
    return this._preparedItems;
  }
  set preparedItems(value2) {
    this._preparedItems = value2;
  }
  get currentView() {
    return viewsUtils.getCurrentView(this.option("currentView"), this.option("views"));
  }
  get currentViewType() {
    return isObject(this.currentView) ? this.currentView.type : this.currentView;
  }
  get timeZoneCalculator() {
    if (!this._timeZoneCalculator) {
      this._timeZoneCalculator = createTimeZoneCalculator(this.option("timeZone"));
    }
    return this._timeZoneCalculator;
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions();
    extend(this._deprecatedOptions, {
      dropDownAppointmentTemplate: {
        since: "19.2",
        message: "appointmentTooltipTemplate"
      }
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => !devices_default.current().generic,
      options: {
        useDropDownViewSwitcher: true,
        editing: {
          allowDragging: false,
          allowResizing: false
        }
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useDropDownViewSwitcher: true,
        dateCellTemplate(data2, index2, element) {
          const {
            text
          } = data2;
          text.split(" ").forEach((text2, index3) => {
            const span = renderer_default("<span>").text(text2).addClass("dx-scheduler-header-panel-cell-date");
            renderer_default(element).append(span);
            if (!index3) {
              renderer_default(element).append(" ");
            }
          });
        },
        _appointmentTooltipButtonsPosition: "top",
        _appointmentTooltipOpenButtonText: null,
        _appointmentCountPerCell: 1,
        _collectorOffset: 20,
        _appointmentOffset: 30
      }
    }, {
      device: () => isMaterial(),
      options: {
        _appointmentTooltipOffset: {
          x: 0,
          y: 11
        }
      }
    }]);
  }
  _postponeDataSourceLoading(promise) {
    this.postponedOperations.add("_reloadDataSource", this._reloadDataSource.bind(this), promise);
  }
  _postponeResourceLoading() {
    const whenLoaded = this.postponedOperations.add("loadResources", () => {
      const groups = this._getCurrentViewOption("groups");
      return loadResources(groups, this.option("resources"), this.option("resourceLoaderMap"));
    });
    const resolveCallbacks = new Deferred();
    whenLoaded.done((resources) => {
      this.option("loadedResources", resources);
      resolveCallbacks.resolve(resources);
    });
    this._postponeDataSourceLoading(whenLoaded);
    return resolveCallbacks.promise();
  }
  _optionChanged(args) {
    var _this$_header, _this$_header2, _this$_header4;
    this.validateOptions();
    let {
      value: value2
    } = args;
    const {
      name: name2
    } = args;
    switch (args.name) {
      case "customizeDateNavigatorText":
        this._updateOption("header", name2, value2);
        break;
      case "firstDayOfWeek":
        this._updateOption("workSpace", name2, value2);
        this._updateOption("header", name2, value2);
        break;
      case "currentDate":
        value2 = this._dateOption(name2);
        value2 = date_default.trimTime(new Date(value2));
        this.option("selectedCellData", []);
        this._workSpace.option(name2, new Date(value2));
        null === (_this$_header = this._header) || void 0 === _this$_header || _this$_header.option(name2, new Date(value2));
        null === (_this$_header2 = this._header) || void 0 === _this$_header2 || _this$_header2.option("startViewDate", this.getStartViewDate());
        this._appointments.option("items", []);
        this._filterAppointmentsByDate();
        this._postponeDataSourceLoading();
        break;
      case "dataSource":
        this._initDataSource();
        this.appointmentDataProvider.setDataSource(this._dataSource);
        this._postponeResourceLoading().done(() => {
          this._filterAppointmentsByDate();
          this._updateOption("workSpace", "showAllDayPanel", this.option("showAllDayPanel"));
        });
        break;
      case "min":
      case "max":
        value2 = this._dateOption(name2);
        this._updateOption("header", name2, new Date(value2));
        this._updateOption("workSpace", name2, new Date(value2));
        break;
      case "views":
        if (this._getCurrentViewOptions()) {
          this.repaint();
        } else {
          var _this$_header3;
          null === (_this$_header3 = this._header) || void 0 === _this$_header3 || _this$_header3.option(name2, value2);
        }
        break;
      case "useDropDownViewSwitcher":
        null === (_this$_header4 = this._header) || void 0 === _this$_header4 || _this$_header4.option(name2, value2);
        break;
      case "currentView":
        this._appointments.option({
          items: [],
          allowDrag: this._allowDragging(),
          allowResize: this._allowResizing(),
          itemTemplate: this._getAppointmentTemplate("appointmentTemplate")
        });
        this._postponeResourceLoading().done((resources) => {
          var _this$_header5;
          this._refreshWorkSpace(resources);
          null === (_this$_header5 = this._header) || void 0 === _this$_header5 || _this$_header5.option(this._headerConfig());
          this._filterAppointmentsByDate();
          this._appointments.option("allowAllDayResize", "day" !== value2);
        });
        this.postponedOperations.callPostponedOperations();
        break;
      case "appointmentTemplate":
        this._appointments.option("itemTemplate", value2);
        break;
      case "dateCellTemplate":
      case "resourceCellTemplate":
      case "dataCellTemplate":
      case "timeCellTemplate":
        this.repaint();
        break;
      case "groups":
        this._postponeResourceLoading().done((resources) => {
          this._refreshWorkSpace(resources);
          this._filterAppointmentsByDate();
        });
        break;
      case "resources":
        this._dataAccessors.resources = createExpressions(this.option("resources"));
        this.agendaResourceProcessor.initializeState(this.option("resources"));
        this.updateInstances();
        this.option("resourceLoaderMap").clear();
        this._postponeResourceLoading().done((resources) => {
          this._appointments.option("items", []);
          this._refreshWorkSpace(resources);
          this._filterAppointmentsByDate();
          this._createAppointmentPopupForm();
        });
        break;
      case "startDayHour":
      case "endDayHour":
        this.updateInstances();
        this._appointments.option("items", []);
        this._updateOption("workSpace", name2, value2);
        this._appointments.repaint();
        this._filterAppointmentsByDate();
        this._postponeDataSourceLoading();
        break;
      case "offset":
        this.updateInstances();
        this._appointments.option("items", []);
        this._updateOption("workSpace", "viewOffset", this.normalizeViewOffsetValue(value2));
        this._appointments.repaint();
        this._filterAppointmentsByDate();
        this._postponeDataSourceLoading();
        break;
      case StoreEventNames.ADDING:
      case StoreEventNames.ADDED:
      case StoreEventNames.UPDATING:
      case StoreEventNames.UPDATED:
      case StoreEventNames.DELETING:
      case StoreEventNames.DELETED:
      case "onAppointmentFormOpening":
      case "onAppointmentTooltipShowing":
        this._actions[name2] = this._createActionByOption(name2);
        break;
      case "onAppointmentRendered":
        this._appointments.option("onItemRendered", this._getAppointmentRenderedAction());
        break;
      case "onAppointmentClick":
        this._appointments.option("onItemClick", this._createActionByOption(name2));
        break;
      case "onAppointmentDblClick":
        this._appointments.option(name2, this._createActionByOption(name2));
        break;
      case "onAppointmentContextMenu":
        this._appointments.option("onItemContextMenu", this._createActionByOption(name2));
        this._appointmentTooltip._options.onItemContextMenu = this._createActionByOption(name2);
        break;
      case "noDataText":
      case "allowMultipleCellSelection":
      case "selectedCellData":
      case "accessKey":
      case "onCellClick":
      case "onCellContextMenu":
        this._workSpace.option(name2, value2);
        break;
      case "crossScrollingEnabled":
        this._postponeResourceLoading().done((resources) => {
          this._appointments.option("items", []);
          this._refreshWorkSpace(resources);
          if (this._readyToRenderAppointments) {
            this._appointments.option("items", this._getAppointmentsToRepaint());
          }
        });
        break;
      case "cellDuration":
        this._updateOption("workSpace", name2, value2);
        this._appointments.option("items", []);
        if (this._readyToRenderAppointments) {
          this._updateOption("workSpace", "hoursInterval", value2 / 60);
          this._appointments.option("items", this._getAppointmentsToRepaint());
        }
        break;
      case "tabIndex":
      case "focusStateEnabled":
        this._updateOption("header", name2, value2);
        this._updateOption("workSpace", name2, value2);
        this._appointments.option(name2, value2);
        super._optionChanged(args);
        break;
      case "width":
        this._updateOption("header", name2, value2);
        if (this.option("crossScrollingEnabled")) {
          this._updateOption("workSpace", "width", value2);
        }
        this._updateOption("workSpace", "schedulerWidth", value2);
        super._optionChanged(args);
        this._dimensionChanged(null, true);
        break;
      case "height":
        super._optionChanged(args);
        this._dimensionChanged(null, true);
        this._updateOption("workSpace", "schedulerHeight", value2);
        break;
      case "editing": {
        this._initEditing();
        const editing = this._editing;
        this._bringEditingModeToAppointments(editing);
        this.hideAppointmentTooltip();
        this._cleanPopup();
        break;
      }
      case "showAllDayPanel":
        this.updateInstances();
        this.repaint();
        break;
      case "showCurrentTimeIndicator":
      case "indicatorTime":
      case "indicatorUpdateInterval":
      case "shadeUntilCurrentTime":
      case "groupByDate":
        this._updateOption("workSpace", name2, value2);
        this.repaint();
        break;
      case "appointmentDragging":
      case "appointmentTooltipTemplate":
      case "appointmentPopupTemplate":
      case "recurrenceEditMode":
      case "remoteFiltering":
      case "timeZone":
        this.updateInstances();
        this.repaint();
        break;
      case "dropDownAppointmentTemplate":
      case "appointmentCollectorTemplate":
      case "_appointmentTooltipOffset":
      case "_appointmentTooltipButtonsPosition":
      case "_appointmentTooltipOpenButtonText":
      case "_appointmentCountPerCell":
      case "_collectorOffset":
      case "_appointmentOffset":
        this.repaint();
        break;
      case "dateSerializationFormat":
      case "maxAppointmentsPerCell":
        break;
      case "startDateExpr":
      case "endDateExpr":
      case "startDateTimeZoneExpr":
      case "endDateTimeZoneExpr":
      case "textExpr":
      case "descriptionExpr":
      case "allDayExpr":
      case "recurrenceRuleExpr":
      case "recurrenceExceptionExpr":
      case "disabledExpr":
        this._updateExpression(name2, value2);
        this.appointmentDataProvider.updateDataAccessors(this._dataAccessors);
        this._initAppointmentTemplate();
        this.repaint();
        break;
      case "adaptivityEnabled":
        this._toggleAdaptiveClass();
        this.repaint();
        break;
      case "scrolling":
        this.option("crossScrollingEnabled", this._isHorizontalVirtualScrolling() || this.option("crossScrollingEnabled"));
        this._updateOption("workSpace", args.fullName, value2);
        break;
      case "allDayPanelMode":
        this.updateInstances();
        this._updateOption("workSpace", args.fullName, value2);
        break;
      case "renovateRender":
        this._updateOption("workSpace", name2, value2);
        break;
      case "_draggingMode":
        this._workSpace.option("draggingMode", value2);
        break;
      case "toolbar":
        this._header ? this._header.option("items", value2) : this.repaint();
        break;
      case "loadedResources":
      case "resourceLoaderMap":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dateOption(optionName) {
    const optionValue = this._getCurrentViewOption(optionName);
    return date_serialization_default.deserializeDate(optionValue);
  }
  _getSerializationFormat(optionName) {
    const value2 = this._getCurrentViewOption(optionName);
    if ("number" === typeof value2) {
      return "number";
    }
    if (!isString(value2)) {
      return;
    }
    return date_serialization_default.getDateSerializationFormat(value2);
  }
  _bringEditingModeToAppointments(editing) {
    const editingConfig = {
      allowDelete: editing.allowUpdating && editing.allowDeleting
    };
    if (!this._isAgenda()) {
      editingConfig.allowDrag = editing.allowDragging;
      editingConfig.allowResize = editing.allowResizing;
      editingConfig.allowAllDayResize = editing.allowResizing && this._supportAllDayResizing();
    }
    this._appointments.option(editingConfig);
    this.repaint();
  }
  _isAgenda() {
    return "agenda" === this.getLayoutManager().appointmentRenderingStrategyName;
  }
  _allowDragging() {
    return this._editing.allowDragging && !this._isAgenda();
  }
  _allowResizing() {
    return this._editing.allowResizing && !this._isAgenda();
  }
  _allowAllDayResizing() {
    return this._editing.allowResizing && this._supportAllDayResizing();
  }
  _supportAllDayResizing() {
    return "day" !== this.currentViewType || this.currentView.intervalCount > 1;
  }
  _isAllDayExpanded() {
    return this.option("showAllDayPanel") && this.appointmentDataProvider.hasAllDayAppointments(this.filteredItems, this.preparedItems);
  }
  _getTimezoneOffsetByOption(date) {
    return m_utils_time_zone_default.calculateTimezoneByValue(this.option("timeZone"), date);
  }
  _filterAppointmentsByDate() {
    const dateRange = this._workSpace.getDateRange();
    const startDate = this.timeZoneCalculator.createDate(dateRange[0], {
      path: "fromGrid"
    });
    const endDate = this.timeZoneCalculator.createDate(dateRange[1], {
      path: "fromGrid"
    });
    this.appointmentDataProvider.filterByDate(startDate, endDate, this.option("remoteFiltering"), this.option("dateSerializationFormat"));
  }
  _reloadDataSource() {
    const result2 = new Deferred();
    if (this._dataSource) {
      this._dataSource.load().done(() => {
        hide();
        this._fireContentReadyAction(result2);
      }).fail(() => {
        hide();
        result2.reject();
      });
      this._dataSource.isLoading() && show({
        container: this.$element(),
        position: {
          of: this.$element()
        }
      });
    } else {
      this._fireContentReadyAction(result2);
    }
    return result2.promise();
  }
  _fireContentReadyAction(result2) {
    const contentReadyBase = super._fireContentReadyAction.bind(this);
    const fireContentReady = () => {
      contentReadyBase();
      null === result2 || void 0 === result2 || result2.resolve();
    };
    if (this._workSpaceRecalculation) {
      var _this$_workSpaceRecal;
      null === (_this$_workSpaceRecal = this._workSpaceRecalculation) || void 0 === _this$_workSpaceRecal || _this$_workSpaceRecal.done(() => {
        fireContentReady();
      });
    } else {
      fireContentReady();
    }
  }
  _dimensionChanged(value2) {
    let isForce = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const isFixedHeight = "number" === typeof this.option("height");
    const isFixedWidth = "number" === typeof this.option("width");
    if (!this._isVisible()) {
      return;
    }
    this._toggleSmallClass();
    const workspace = this.getWorkSpace();
    if (!this._isAgenda() && this.filteredItems && workspace) {
      if (isForce || !isFixedHeight || !isFixedWidth) {
        workspace.option("allDayExpanded", this._isAllDayExpanded());
        workspace._dimensionChanged();
        const appointments = this.getLayoutManager().createAppointmentsMap(this.filteredItems);
        this._appointments.option("items", appointments);
      }
    }
    this.hideAppointmentTooltip();
    this._appointmentPopup.triggerResize();
    this._appointmentPopup.updatePopupFullScreenMode();
  }
  _clean() {
    this._cleanPopup();
    super._clean();
  }
  _toggleSmallClass() {
    const {
      width
    } = getBoundingRect(this.$element().get(0));
    this.$element().toggleClass(WIDGET_SMALL_CLASS, width < 400);
  }
  _toggleAdaptiveClass() {
    this.$element().toggleClass(WIDGET_ADAPTIVE_CLASS, this.option("adaptivityEnabled"));
  }
  _visibilityChanged(visible2) {
    visible2 && this._dimensionChanged(null, true);
  }
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _initAllDayPanel() {
    if ("hidden" === this.option("allDayPanelMode")) {
      this.option("showAllDayPanel", false);
    }
  }
  _init() {
    this._initExpressions({
      startDate: this.option("startDateExpr"),
      endDate: this.option("endDateExpr"),
      startDateTimeZone: this.option("startDateTimeZoneExpr"),
      endDateTimeZone: this.option("endDateTimeZoneExpr"),
      allDay: this.option("allDayExpr"),
      text: this.option("textExpr"),
      description: this.option("descriptionExpr"),
      recurrenceRule: this.option("recurrenceRuleExpr"),
      recurrenceException: this.option("recurrenceExceptionExpr"),
      disabled: this.option("disabledExpr")
    });
    super._init();
    this._initAllDayPanel();
    this._initDataSource();
    this._customizeDataSourceLoadOptions();
    this.$element().addClass(WIDGET_CLASS2);
    this._initEditing();
    this.updateInstances();
    this._initActions();
    this._compactAppointmentsHelper = new CompactAppointmentsHelper(this);
    this._asyncTemplatesTimers = [];
    this._dataSourceLoadedCallback = callbacks_default();
    this._subscribes = m_subscribes_default;
    this.agendaResourceProcessor = new AgendaResourceProcessor(this.option("resources"));
    this._optionsValidator = new SchedulerOptionsValidator();
    this._optionsValidatorErrorHandler = new SchedulerOptionsValidatorErrorsHandler();
  }
  createAppointmentDataProvider() {
    var _this$appointmentData;
    null === (_this$appointmentData = this.appointmentDataProvider) || void 0 === _this$appointmentData || _this$appointmentData.destroy();
    this.appointmentDataProvider = new AppointmentDataProvider({
      dataSource: this._dataSource,
      dataAccessors: this._dataAccessors,
      timeZoneCalculator: this.timeZoneCalculator,
      dateSerializationFormat: this.option("dateSerializationFormat"),
      resources: this.option("resources"),
      startDayHour: this._getCurrentViewOption("startDayHour"),
      endDayHour: this._getCurrentViewOption("endDayHour"),
      viewOffset: this.getViewOffsetMs(),
      appointmentDuration: this._getCurrentViewOption("cellDuration"),
      allDayPanelMode: this._getCurrentViewOption("allDayPanelMode"),
      showAllDayPanel: this.option("showAllDayPanel"),
      getLoadedResources: () => this.option("loadedResources"),
      getIsVirtualScrolling: () => this.isVirtualScrolling(),
      getSupportAllDayRow: () => this._workSpace.supportAllDayRow(),
      getViewType: () => this._workSpace.type,
      getViewDirection: () => this._workSpace.viewDirection,
      getDateRange: () => this._workSpace.getDateRange(),
      getGroupCount: () => this._workSpace._getGroupCount(),
      getViewDataProvider: () => this._workSpace.viewDataProvider
    });
  }
  updateInstances() {
    this._timeZoneCalculator = null;
    if (this.getWorkSpace()) {
      this.createAppointmentDataProvider();
    }
  }
  _customizeDataSourceLoadOptions() {
    var _this$_dataSource;
    null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource || _this$_dataSource.on("customizeStoreLoadOptions", (_ref) => {
      let {
        storeLoadOptions
      } = _ref;
      storeLoadOptions.startDate = this.getStartViewDate();
      storeLoadOptions.endDate = this.getEndViewDate();
    });
  }
  _initTemplates() {
    this._initAppointmentTemplate();
    this._templateManager.addDefaultTemplates({
      appointmentTooltip: new EmptyTemplate(),
      dropDownAppointment: new EmptyTemplate()
    });
    super._initTemplates();
  }
  _initAppointmentTemplate() {
    const {
      expr
    } = this._dataAccessors;
    const createGetter = (property) => compileGetter(`appointmentData.${property}`);
    const getDate = (getter) => (data2) => {
      const value2 = getter(data2);
      if (value2 instanceof Date) {
        return value2.valueOf();
      }
      return value2;
    };
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data2, model) => this.getAppointmentsInstance()._renderAppointmentTemplate($container, data2, model), ["html", "text", "startDate", "endDate", "allDay", "description", "recurrenceRule", "recurrenceException", "startDateTimeZone", "endDateTimeZone"], this.option("integrationOptions.watchMethod"), {
        text: createGetter(expr.textExpr),
        startDate: getDate(createGetter(expr.startDateExpr)),
        endDate: getDate(createGetter(expr.endDateExpr)),
        startDateTimeZone: createGetter(expr.startDateTimeZoneExpr),
        endDateTimeZone: createGetter(expr.endDateTimeZoneExpr),
        allDay: createGetter(expr.allDayExpr),
        recurrenceRule: createGetter(expr.recurrenceRuleExpr)
      })
    });
  }
  _renderContent() {
    this._renderContentImpl();
  }
  _updatePreparedItems(items) {
    this.preparedItems = getPreparedDataItems(items, this._dataAccessors, this._getCurrentViewOption("cellDuration"), this.timeZoneCalculator);
  }
  _dataSourceChangedHandler(result2) {
    if (this._readyToRenderAppointments) {
      this._workSpaceRecalculation.done(() => {
        this._updatePreparedItems(result2);
        this._renderAppointments();
        this.getWorkSpace().onDataSourceChanged(this.filteredItems);
      });
    }
  }
  isVirtualScrolling() {
    var _currentViewOptions$s;
    const workspace = this.getWorkSpace();
    if (workspace) {
      return workspace.isVirtualScrolling();
    }
    const currentViewOptions = this._getCurrentViewOptions();
    const scrolling = this.option("scrolling");
    return "virtual" === (null === scrolling || void 0 === scrolling ? void 0 : scrolling.mode) || "virtual" === (null === currentViewOptions || void 0 === currentViewOptions || null === (_currentViewOptions$s = currentViewOptions.scrolling) || void 0 === _currentViewOptions$s ? void 0 : _currentViewOptions$s.mode);
  }
  _filterAppointments() {
    this.filteredItems = this.appointmentDataProvider.filter(this.preparedItems);
  }
  _renderAppointments() {
    const workspace = this.getWorkSpace();
    this._filterAppointments();
    workspace.option("allDayExpanded", this._isAllDayExpanded());
    let viewModel = [];
    if (this._isVisible()) {
      viewModel = this._getAppointmentsToRepaint();
    }
    this._appointments.option("items", viewModel);
    this.appointmentDataProvider.cleanState();
  }
  _getAppointmentsToRepaint() {
    const layoutManager = this.getLayoutManager();
    const appointmentsMap = layoutManager.createAppointmentsMap(this.filteredItems);
    return layoutManager.getRepaintedAppointments(appointmentsMap, this.getAppointmentsInstance().option("items"));
  }
  _initExpressions(fields) {
    this._dataAccessors = utils2.dataAccessors.create(fields, this._dataAccessors, config_default().forceIsoDateParsing, this.option("dateSerializationFormat"));
    this._dataAccessors.resources = createExpressions(this.option("resources"));
  }
  _updateExpression(name2, value2) {
    const exprObj = {};
    exprObj[name2.replace("Expr", "")] = value2;
    this._initExpressions(exprObj);
  }
  getResourceDataAccessors() {
    return this._dataAccessors.resources;
  }
  _initEditing() {
    const editing = this.option("editing");
    this._editing = {
      allowAdding: !!editing,
      allowUpdating: !!editing,
      allowDeleting: !!editing,
      allowResizing: !!editing,
      allowDragging: !!editing
    };
    if (isObject(editing)) {
      this._editing = extend(this._editing, editing);
    }
    this._editing.allowDragging = this._editing.allowDragging && this._editing.allowUpdating;
    this._editing.allowResizing = this._editing.allowResizing && this._editing.allowUpdating;
    this.$element().toggleClass(WIDGET_READONLY_CLASS, this._isReadOnly());
  }
  _isReadOnly() {
    let result2 = true;
    const editing = this._editing;
    for (const prop in editing) {
      if (Object.prototype.hasOwnProperty.call(editing, prop)) {
        result2 = result2 && !editing[prop];
      }
    }
    return result2;
  }
  _dispose() {
    var _this$_recurrenceDial;
    this._appointmentTooltip && this._appointmentTooltip.dispose();
    null === (_this$_recurrenceDial = this._recurrenceDialog) || void 0 === _this$_recurrenceDial || _this$_recurrenceDial.hide(RECURRENCE_EDITING_MODE.CANCEL);
    this.hideAppointmentPopup();
    this.hideAppointmentTooltip();
    this._asyncTemplatesTimers.forEach(clearTimeout);
    this._asyncTemplatesTimers = [];
    super._dispose();
  }
  _initActions() {
    this._actions = {
      onAppointmentAdding: this._createActionByOption(StoreEventNames.ADDING),
      onAppointmentAdded: this._createActionByOption(StoreEventNames.ADDED),
      onAppointmentUpdating: this._createActionByOption(StoreEventNames.UPDATING),
      onAppointmentUpdated: this._createActionByOption(StoreEventNames.UPDATED),
      onAppointmentDeleting: this._createActionByOption(StoreEventNames.DELETING),
      onAppointmentDeleted: this._createActionByOption(StoreEventNames.DELETED),
      onAppointmentFormOpening: this._createActionByOption("onAppointmentFormOpening"),
      onAppointmentTooltipShowing: this._createActionByOption("onAppointmentTooltipShowing")
    };
  }
  _getAppointmentRenderedAction() {
    return this._createActionByOption("onAppointmentRendered", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _renderFocusTarget() {
    return noop2();
  }
  _initMarkup() {
    super._initMarkup();
    this._renderMainContainer();
    this._renderHeader();
    this._layoutManager = new m_appointments_layout_manager_default(this);
    this._appointments = this._createComponent("<div>", m_appointment_collection_default, this._appointmentsConfig());
    this._appointments.option("itemTemplate", this._getAppointmentTemplate("appointmentTemplate"));
    this._appointmentTooltip = new (this.option("adaptivityEnabled") ? MobileTooltipStrategy : DesktopTooltipStrategy)(this._getAppointmentTooltipOptions());
    this._createAppointmentPopupForm();
    if (this._isDataSourceLoaded() || this._isDataSourceLoading()) {
      this._initMarkupCore(this.option("loadedResources"));
      this._dataSourceChangedHandler(this._dataSource.items());
      this._fireContentReadyAction();
    } else {
      const groups = this._getCurrentViewOption("groups");
      loadResources(groups, this.option("resources"), this.option("resourceLoaderMap")).done((resources) => {
        this.option("loadedResources", resources);
        this._initMarkupCore(resources);
        this._reloadDataSource();
      });
    }
  }
  _createAppointmentPopupForm() {
    var _this$_appointmentPop;
    if (this._appointmentForm) {
      var _this$_appointmentFor;
      null === (_this$_appointmentFor = this._appointmentForm.form) || void 0 === _this$_appointmentFor || _this$_appointmentFor.dispose();
    }
    this._appointmentForm = this.createAppointmentForm();
    null === (_this$_appointmentPop = this._appointmentPopup) || void 0 === _this$_appointmentPop || _this$_appointmentPop.dispose();
    this._appointmentPopup = this.createAppointmentPopup(this._appointmentForm);
  }
  _renderMainContainer() {
    this._mainContainer = renderer_default("<div>").addClass("dx-scheduler-container");
    this.$element().append(this._mainContainer);
  }
  createAppointmentForm() {
    const scheduler = {
      createResourceEditorModel: () => createResourceEditorModel(this.option("resources"), this.option("loadedResources")),
      getDataAccessors: () => this._dataAccessors,
      createComponent: (element, component, options2) => this._createComponent(element, component, options2),
      getEditingConfig: () => this._editing,
      getFirstDayOfWeek: () => this.option("firstDayOfWeek"),
      getStartDayHour: () => this.option("startDayHour"),
      getCalculatedEndDate: (startDateWithStartHour) => this._workSpace.calculateEndDate(startDateWithStartHour),
      getTimeZoneCalculator: () => this.timeZoneCalculator
    };
    return new AppointmentForm(scheduler);
  }
  createAppointmentPopup(form) {
    const scheduler = {
      getElement: () => this.$element(),
      createComponent: (element, component, options2) => this._createComponent(element, component, options2),
      focus: () => this.focus(),
      getResources: () => this.option("resources"),
      getEditingConfig: () => this._editing,
      getTimeZoneCalculator: () => this.timeZoneCalculator,
      getDataAccessors: () => this._dataAccessors,
      getAppointmentFormOpening: () => this._actions.onAppointmentFormOpening,
      processActionResult: (arg, canceled) => this._processActionResult(arg, canceled),
      addAppointment: (appointment) => this.addAppointment(appointment),
      updateAppointment: (sourceAppointment, updatedAppointment) => this.updateAppointment(sourceAppointment, updatedAppointment),
      updateScrollPosition: (startDate, resourceItem, inAllDayRow) => {
        this._workSpace.updateScrollPosition(startDate, resourceItem, inAllDayRow);
      }
    };
    return new AppointmentPopup(scheduler, form);
  }
  _getAppointmentTooltipOptions() {
    return {
      createComponent: this._createComponent.bind(this),
      container: this.$element(),
      getScrollableContainer: this.getWorkSpaceScrollableContainer.bind(this),
      addDefaultTemplates: this._templateManager.addDefaultTemplates.bind(this._templateManager),
      getAppointmentTemplate: this._getAppointmentTemplate.bind(this),
      showAppointmentPopup: this.showAppointmentPopup.bind(this),
      checkAndDeleteAppointment: this.checkAndDeleteAppointment.bind(this),
      isAppointmentInAllDayPanel: this.isAppointmentInAllDayPanel.bind(this),
      createFormattedDateText: (appointment, targetedAppointment, format2) => this.fire("getTextAndFormatDate", appointment, targetedAppointment, format2),
      getAppointmentDisabled: (appointment) => createAppointmentAdapter(appointment, this._dataAccessors, this.timeZoneCalculator).disabled,
      onItemContextMenu: this._createActionByOption("onAppointmentContextMenu"),
      createEventArgs: this._createEventArgs.bind(this)
    };
  }
  _createEventArgs(e) {
    const config3 = {
      itemData: e.itemData.appointment,
      itemElement: e.itemElement,
      targetedAppointment: e.itemData.targetedAppointment
    };
    return extend({}, this.fire("mapAppointmentFields", config3), {
      component: e.component,
      element: e.element,
      event: e.event,
      model: e.model
    });
  }
  checkAndDeleteAppointment(appointment, targetedAppointment) {
    const targetedAdapter = createAppointmentAdapter(targetedAppointment, this._dataAccessors, this.timeZoneCalculator);
    const deletingOptions = this.fireOnAppointmentDeleting(appointment, targetedAdapter);
    this._checkRecurringAppointment(appointment, targetedAppointment, targetedAdapter.startDate, () => {
      this.processDeleteAppointment(appointment, deletingOptions);
    }, true);
  }
  _getExtraAppointmentTooltipOptions() {
    return {
      rtlEnabled: this.option("rtlEnabled"),
      focusStateEnabled: this.option("focusStateEnabled"),
      editing: this.option("editing"),
      offset: this.option("_appointmentTooltipOffset")
    };
  }
  isAppointmentInAllDayPanel(appointmentData) {
    const workSpace = this._workSpace;
    const itTakesAllDay = this.appointmentTakesAllDay(appointmentData);
    return itTakesAllDay && workSpace.supportAllDayRow() && workSpace.option("showAllDayPanel");
  }
  _initMarkupCore(resources) {
    this._readyToRenderAppointments = hasWindow();
    this._workSpace && this._cleanWorkspace();
    this._renderWorkSpace(resources);
    this._appointments.option({
      fixedContainer: this._workSpace.getFixedContainer(),
      allDayContainer: this._workSpace.getAllDayContainer()
    });
    this._waitAsyncTemplate(() => {
      var _this$_workSpaceRecal2;
      return null === (_this$_workSpaceRecal2 = this._workSpaceRecalculation) || void 0 === _this$_workSpaceRecal2 ? void 0 : _this$_workSpaceRecal2.resolve();
    });
    this.createAppointmentDataProvider();
    this._filterAppointmentsByDate();
    this._validateKeyFieldIfAgendaExist();
  }
  _isDataSourceLoaded() {
    return this._dataSource && this._dataSource.isLoaded();
  }
  _render() {
    var _this$getWorkSpace;
    this._toggleSmallClass();
    this._toggleAdaptiveClass();
    null === (_this$getWorkSpace = this.getWorkSpace()) || void 0 === _this$getWorkSpace || _this$getWorkSpace.updateHeaderEmptyCellWidth();
    super._render();
  }
  _renderHeader() {
    if (0 !== this.option("toolbar").length) {
      const $header = renderer_default("<div>").appendTo(this._mainContainer);
      this._header = this._createComponent($header, SchedulerHeader, this._headerConfig());
    }
  }
  _headerConfig() {
    const currentViewOptions = this._getCurrentViewOptions();
    const countConfig = this._getViewCountConfig();
    const result2 = extend({
      firstDayOfWeek: this.getFirstDayOfWeek(),
      currentView: this.option("currentView"),
      isAdaptive: this.option("adaptivityEnabled"),
      tabIndex: this.option("tabIndex"),
      focusStateEnabled: this.option("focusStateEnabled"),
      rtlEnabled: this.option("rtlEnabled"),
      useDropDownViewSwitcher: this.option("useDropDownViewSwitcher"),
      customizeDateNavigatorText: this.option("customizeDateNavigatorText"),
      agendaDuration: currentViewOptions.agendaDuration || 7
    }, currentViewOptions);
    result2.intervalCount = countConfig.intervalCount;
    result2.views = this.option("views");
    result2.min = new Date(this._dateOption("min"));
    result2.max = new Date(this._dateOption("max"));
    result2.currentDate = date_default.trimTime(new Date(this._dateOption("currentDate")));
    result2.onCurrentViewChange = (name2) => {
      this.option("currentView", name2);
    };
    result2.onCurrentDateChange = (date) => {
      this.option("currentDate", date);
    };
    result2.items = this.option("toolbar");
    result2.startViewDate = this.getStartViewDate();
    result2.todayDate = () => {
      const result3 = this.timeZoneCalculator.createDate(/* @__PURE__ */ new Date(), {
        path: "toGrid"
      });
      return result3;
    };
    return result2;
  }
  _appointmentsConfig() {
    const config3 = {
      getResources: () => this.option("resources"),
      getResourceDataAccessors: this.getResourceDataAccessors.bind(this),
      getAgendaResourceProcessor: () => this.agendaResourceProcessor,
      getAppointmentColor: this.createGetAppointmentColor(),
      getAppointmentDataProvider: () => this.appointmentDataProvider,
      dataAccessors: this._dataAccessors,
      observer: this,
      onItemRendered: this._getAppointmentRenderedAction(),
      onItemClick: this._createActionByOption("onAppointmentClick"),
      onItemContextMenu: this._createActionByOption("onAppointmentContextMenu"),
      onAppointmentDblClick: this._createActionByOption("onAppointmentDblClick"),
      tabIndex: this.option("tabIndex"),
      focusStateEnabled: this.option("focusStateEnabled"),
      allowDrag: this._allowDragging(),
      allowDelete: this._editing.allowUpdating && this._editing.allowDeleting,
      allowResize: this._allowResizing(),
      allowAllDayResize: this._allowAllDayResizing(),
      rtlEnabled: this.option("rtlEnabled"),
      currentView: this.currentView,
      groups: this._getCurrentViewOption("groups"),
      timeZoneCalculator: this.timeZoneCalculator,
      getResizableStep: () => this._workSpace ? this._workSpace.positionHelper.getResizableStep() : 0,
      getDOMElementsMetaData: () => {
        var _this$_workSpace;
        return null === (_this$_workSpace = this._workSpace) || void 0 === _this$_workSpace ? void 0 : _this$_workSpace.getDOMElementsMetaData();
      },
      getViewDataProvider: () => {
        var _this$_workSpace2;
        return null === (_this$_workSpace2 = this._workSpace) || void 0 === _this$_workSpace2 ? void 0 : _this$_workSpace2.viewDataProvider;
      },
      isVerticalViewDirection: () => "vertical" === this.getRenderingStrategyInstance().getDirection(),
      isVerticalGroupedWorkSpace: () => this._workSpace._isVerticalGroupedWorkSpace(),
      isDateAndTimeView: () => isDateAndTimeView(this._workSpace.type),
      onContentReady: () => {
        var _this$_workSpace3;
        null === (_this$_workSpace3 = this._workSpace) || void 0 === _this$_workSpace3 || _this$_workSpace3.option("allDayExpanded", this._isAllDayExpanded());
      }
    };
    return config3;
  }
  getCollectorOffset() {
    if (this._workSpace.needApplyCollectorOffset() && !this.option("adaptivityEnabled")) {
      return this.option("_collectorOffset");
    }
    return 0;
  }
  getAppointmentDurationInMinutes() {
    return this._getCurrentViewOption("cellDuration");
  }
  _getCurrentViewType() {
    return this.currentViewType;
  }
  _renderWorkSpace(groups) {
    var _this$_header6;
    this._readyToRenderAppointments && this._toggleSmallClass();
    const $workSpace = renderer_default("<div>").appendTo(this._mainContainer);
    const countConfig = this._getViewCountConfig();
    const workSpaceComponent = VIEWS_CONFIG[this._getCurrentViewType()].workSpace;
    const workSpaceConfig = this._workSpaceConfig(groups, countConfig);
    this._workSpace = this._createComponent($workSpace, workSpaceComponent, workSpaceConfig);
    this._allowDragging() && this._workSpace.initDragBehavior(this, this._all);
    this._workSpace._attachTablesEvents();
    this._workSpace.getWorkArea().append(this._appointments.$element());
    this._recalculateWorkspace();
    countConfig.startDate && (null === (_this$_header6 = this._header) || void 0 === _this$_header6 ? void 0 : _this$_header6.option("currentDate", this._workSpace._getHeaderDate()));
    this._appointments.option("_collectorOffset", this.getCollectorOffset());
  }
  _getViewCountConfig() {
    const currentView = this.option("currentView");
    const view = this._getViewByName(currentView);
    const viewCount = view && view.intervalCount || 1;
    const startDate = view && view.startDate || null;
    return {
      intervalCount: viewCount,
      startDate
    };
  }
  _getViewByName(name2) {
    const views = this.option("views");
    for (let i = 0; i < views.length; i++) {
      if (views[i].name === name2 || views[i].type === name2 || views[i] === name2) {
        return views[i];
      }
    }
  }
  _recalculateWorkspace() {
    this._workSpaceRecalculation = new Deferred();
    this._waitAsyncTemplate(() => {
      triggerResizeEvent(this._workSpace.$element());
      this._workSpace.renderCurrentDateTimeLineAndShader();
    });
  }
  _workSpaceConfig(groups, countConfig) {
    var _currentViewOptions$s2;
    const currentViewOptions = this._getCurrentViewOptions();
    const scrolling = this.option("scrolling");
    const isVirtualScrolling = "virtual" === scrolling.mode || "virtual" === (null === (_currentViewOptions$s2 = currentViewOptions.scrolling) || void 0 === _currentViewOptions$s2 ? void 0 : _currentViewOptions$s2.mode);
    const horizontalVirtualScrollingAllowed = isVirtualScrolling && (!isDefined(scrolling.orientation) || ["horizontal", "both"].filter((item) => {
      var _currentViewOptions$s3;
      return scrolling.orientation === item || (null === (_currentViewOptions$s3 = currentViewOptions.scrolling) || void 0 === _currentViewOptions$s3 ? void 0 : _currentViewOptions$s3.orientation) === item;
    }).length > 0);
    const crossScrollingEnabled = this.option("crossScrollingEnabled") || horizontalVirtualScrollingAllowed || isTimelineView(this.currentViewType);
    const result2 = extend({
      resources: this.option("resources"),
      loadedResources: this.option("loadedResources"),
      getFilteredItems: () => this.filteredItems,
      getResourceDataAccessors: this.getResourceDataAccessors.bind(this),
      noDataText: this.option("noDataText"),
      firstDayOfWeek: this.option("firstDayOfWeek"),
      startDayHour: this.option("startDayHour"),
      endDayHour: this.option("endDayHour"),
      viewOffset: this.getViewOffsetMs(),
      tabIndex: this.option("tabIndex"),
      accessKey: this.option("accessKey"),
      focusStateEnabled: this.option("focusStateEnabled"),
      cellDuration: this.option("cellDuration"),
      showAllDayPanel: this.option("showAllDayPanel"),
      showCurrentTimeIndicator: this.option("showCurrentTimeIndicator"),
      indicatorTime: this.option("indicatorTime"),
      indicatorUpdateInterval: this.option("indicatorUpdateInterval"),
      shadeUntilCurrentTime: this.option("shadeUntilCurrentTime"),
      allDayExpanded: this._appointments.option("items"),
      crossScrollingEnabled,
      dataCellTemplate: this.option("dataCellTemplate"),
      timeCellTemplate: this.option("timeCellTemplate"),
      resourceCellTemplate: this.option("resourceCellTemplate"),
      dateCellTemplate: this.option("dateCellTemplate"),
      allowMultipleCellSelection: this.option("allowMultipleCellSelection"),
      selectedCellData: this.option("selectedCellData"),
      onSelectionChanged: (args) => {
        this.option("selectedCellData", args.selectedCellData);
      },
      groupByDate: this._getCurrentViewOption("groupByDate"),
      scrolling,
      draggingMode: this.option("_draggingMode"),
      timeZoneCalculator: this.timeZoneCalculator,
      schedulerHeight: this.option("height"),
      schedulerWidth: this.option("width"),
      allDayPanelMode: this.option("allDayPanelMode"),
      onSelectedCellsClick: this.showAddAppointmentPopup.bind(this),
      onRenderAppointments: this._renderAppointments.bind(this),
      onShowAllDayPanel: (value2) => this.option("showAllDayPanel", value2),
      getHeaderHeight: () => utils2.DOM.getHeaderHeight(this._header),
      onScrollEnd: () => this._appointments.updateResizableArea(),
      renovateRender: this._isRenovatedRender(isVirtualScrolling)
    }, currentViewOptions);
    result2.observer = this;
    result2.intervalCount = countConfig.intervalCount;
    result2.startDate = countConfig.startDate;
    result2.groups = groups;
    result2.onCellClick = this._createActionByOption("onCellClick");
    result2.onCellContextMenu = this._createActionByOption("onCellContextMenu");
    result2.currentDate = date_default.trimTime(new Date(this._dateOption("currentDate")));
    result2.hoursInterval = result2.cellDuration / 60;
    result2.allDayExpanded = false;
    result2.dataCellTemplate = result2.dataCellTemplate ? this._getTemplate(result2.dataCellTemplate) : null;
    result2.timeCellTemplate = result2.timeCellTemplate ? this._getTemplate(result2.timeCellTemplate) : null;
    result2.resourceCellTemplate = result2.resourceCellTemplate ? this._getTemplate(result2.resourceCellTemplate) : null;
    result2.dateCellTemplate = result2.dateCellTemplate ? this._getTemplate(result2.dateCellTemplate) : null;
    result2.getAppointmentDataProvider = () => this.appointmentDataProvider;
    return result2;
  }
  _isRenovatedRender(isVirtualScrolling) {
    return this.option("renovateRender") && hasWindow() || isVirtualScrolling;
  }
  _waitAsyncTemplate(callback) {
    if (this._options.silent("templatesRenderAsynchronously")) {
      const timer = setTimeout(() => {
        callback();
        clearTimeout(timer);
      });
      this._asyncTemplatesTimers.push(timer);
    } else {
      callback();
    }
  }
  _getCurrentViewOptions() {
    return this.currentView;
  }
  _getCurrentViewOption(optionName) {
    if (this.currentView && void 0 !== this.currentView[optionName]) {
      return this.currentView[optionName];
    }
    return this.option(optionName);
  }
  _getAppointmentTemplate(optionName) {
    const currentViewOptions = this._getCurrentViewOptions();
    if (currentViewOptions && currentViewOptions[optionName]) {
      return this._getTemplate(currentViewOptions[optionName]);
    }
    return this._getTemplateByOption(optionName);
  }
  _updateOption(viewName, optionName, value2) {
    const currentViewOptions = this._getCurrentViewOptions();
    if (!currentViewOptions || !isDefined(currentViewOptions[optionName])) {
      this[`_${viewName}`].option(optionName, value2);
    }
  }
  _refreshWorkSpace(groups) {
    this._cleanWorkspace();
    delete this._workSpace;
    this._renderWorkSpace(groups);
    if (this._readyToRenderAppointments) {
      this._appointments.option({
        fixedContainer: this._workSpace.getFixedContainer(),
        allDayContainer: this._workSpace.getAllDayContainer()
      });
      this._waitAsyncTemplate(() => this._workSpaceRecalculation.resolve());
    }
  }
  _cleanWorkspace() {
    this._appointments.$element().detach();
    this._workSpace._dispose();
    this._workSpace.$element().remove();
    this.option("selectedCellData", []);
  }
  getWorkSpaceScrollable() {
    return this._workSpace.getScrollable();
  }
  getWorkSpaceScrollableContainer() {
    return this._workSpace.getScrollableContainer();
  }
  getWorkSpace() {
    return this._workSpace;
  }
  getHeader() {
    return this._header;
  }
  _cleanPopup() {
    var _this$_appointmentPop2;
    null === (_this$_appointmentPop2 = this._appointmentPopup) || void 0 === _this$_appointmentPop2 || _this$_appointmentPop2.dispose();
  }
  _checkRecurringAppointment(rawAppointment, singleAppointment, exceptionDate, callback, isDeleted, isPopupEditing, dragEvent, recurrenceEditMode) {
    const recurrenceRule = ExpressionUtils.getField(this._dataAccessors, "recurrenceRule", rawAppointment);
    if (!getRecurrenceProcessor().evalRecurrenceRule(recurrenceRule).isValid || !this._editing.allowUpdating) {
      callback();
      return;
    }
    const editMode = recurrenceEditMode || this.option("recurrenceEditMode");
    switch (editMode) {
      case "series":
        callback();
        break;
      case "occurrence":
        this._excludeAppointmentFromSeries(rawAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing, dragEvent);
        break;
      default:
        if (dragEvent) {
          dragEvent.cancel = new Deferred();
        }
        this._showRecurrenceChangeConfirm(isDeleted).done((editingMode) => {
          editingMode === RECURRENCE_EDITING_MODE.SERIES && callback();
          editingMode === RECURRENCE_EDITING_MODE.OCCURENCE && this._excludeAppointmentFromSeries(rawAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing, dragEvent);
        }).fail(() => this._appointments.moveAppointmentBack(dragEvent));
    }
  }
  _excludeAppointmentFromSeries(rawAppointment, newRawAppointment, exceptionDate, isDeleted, isPopupEditing, dragEvent) {
    const appointment = excludeFromRecurrence(rawAppointment, exceptionDate, this._dataAccessors, this._timeZoneCalculator);
    const singleRawAppointment = _extends({}, newRawAppointment);
    delete singleRawAppointment[this._dataAccessors.expr.recurrenceExceptionExpr];
    delete singleRawAppointment[this._dataAccessors.expr.recurrenceRuleExpr];
    const keyPropertyName = this.appointmentDataProvider.keyName;
    delete singleRawAppointment[keyPropertyName];
    const canCreateNewAppointment = !isDeleted && !isPopupEditing;
    if (canCreateNewAppointment) {
      this.addAppointment(singleRawAppointment);
    }
    if (isPopupEditing) {
      this._appointmentPopup.show(singleRawAppointment, {
        isToolbarVisible: true,
        action: ACTION_TO_APPOINTMENT.EXCLUDE_FROM_SERIES,
        excludeInfo: {
          sourceAppointment: rawAppointment,
          updatedAppointment: appointment.source()
        }
      });
      this._editAppointmentData = rawAppointment;
    } else {
      this._updateAppointment(rawAppointment, appointment.source(), () => {
        this._appointments.moveAppointmentBack(dragEvent);
      }, dragEvent);
    }
  }
  _createRecurrenceException(appointment, exceptionDate) {
    const result2 = [];
    if (appointment.recurrenceException) {
      result2.push(appointment.recurrenceException);
    }
    result2.push(this._getSerializedDate(exceptionDate, appointment.startDate, appointment.allDay));
    return result2.join();
  }
  _getSerializedDate(date, startDate, isAllDay) {
    isAllDay && date.setHours(startDate.getHours(), startDate.getMinutes(), startDate.getSeconds(), startDate.getMilliseconds());
    return date_serialization_default.serializeDate(date, UTC_FULL_DATE_FORMAT2);
  }
  _showRecurrenceChangeConfirm(isDeleted) {
    const title = message_default.format(isDeleted ? "dxScheduler-confirmRecurrenceDeleteTitle" : "dxScheduler-confirmRecurrenceEditTitle");
    const message = message_default.format(isDeleted ? "dxScheduler-confirmRecurrenceDeleteMessage" : "dxScheduler-confirmRecurrenceEditMessage");
    const seriesText = message_default.format(isDeleted ? "dxScheduler-confirmRecurrenceDeleteSeries" : "dxScheduler-confirmRecurrenceEditSeries");
    const occurrenceText = message_default.format(isDeleted ? "dxScheduler-confirmRecurrenceDeleteOccurrence" : "dxScheduler-confirmRecurrenceEditOccurrence");
    this._recurrenceDialog = custom({
      title,
      messageHtml: message,
      showCloseButton: true,
      showTitle: true,
      buttons: [{
        text: seriesText,
        onClick: () => RECURRENCE_EDITING_MODE.SERIES
      }, {
        text: occurrenceText,
        onClick: () => RECURRENCE_EDITING_MODE.OCCURENCE
      }],
      popupOptions: {
        wrapperAttr: {
          class: "dx-dialog"
        }
      }
    });
    return this._recurrenceDialog.show();
  }
  _getUpdatedData(rawAppointment) {
    const viewOffset = this.getViewOffsetMs();
    const getConvertedFromGrid = (date) => {
      if (!date) {
        return;
      }
      const result3 = this.timeZoneCalculator.createDate(date, {
        path: "fromGrid"
      });
      return dateUtilsTs.addOffsets(result3, [-viewOffset]);
    };
    const isValidDate3 = (date) => !isNaN(new Date(date).getTime());
    const targetCell = this.getTargetCellData();
    const appointment = createAppointmentAdapter(rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    const cellStartDate = getConvertedFromGrid(targetCell.startDate);
    const cellEndDate = getConvertedFromGrid(targetCell.endDate);
    let appointmentStartDate = new Date(appointment.startDate);
    appointmentStartDate = dateUtilsTs.addOffsets(appointmentStartDate, [-viewOffset]);
    let appointmentEndDate = new Date(appointment.endDate);
    appointmentEndDate = dateUtilsTs.addOffsets(appointmentEndDate, [-viewOffset]);
    let resultedStartDate = cellStartDate ?? appointmentStartDate;
    if (!isValidDate3(appointmentStartDate)) {
      appointmentStartDate = resultedStartDate;
    }
    if (!isValidDate3(appointmentEndDate)) {
      appointmentEndDate = cellEndDate;
    }
    const duration = appointmentEndDate.getTime() - appointmentStartDate.getTime();
    const isKeepAppointmentHours = this._workSpace.keepOriginalHours() && isValidDate3(appointment.startDate) && isValidDate3(cellStartDate);
    if (isKeepAppointmentHours) {
      const startDate = this.timeZoneCalculator.createDate(appointmentStartDate, {
        path: "toGrid"
      });
      const timeInMs = startDate.getTime() - date_default.trimTime(startDate).getTime();
      const targetCellStartDate = dateUtilsTs.addOffsets(targetCell.startDate, [-viewOffset]);
      resultedStartDate = new Date(date_default.trimTime(targetCellStartDate).getTime() + timeInMs);
      resultedStartDate = this.timeZoneCalculator.createDate(resultedStartDate, {
        path: "fromGrid"
      });
    }
    const result2 = createAppointmentAdapter({}, this._dataAccessors, this.timeZoneCalculator);
    if (void 0 !== targetCell.allDay) {
      result2.allDay = targetCell.allDay;
    }
    result2.startDate = resultedStartDate;
    let resultedEndDate = new Date(resultedStartDate.getTime() + duration);
    if (this.appointmentTakesAllDay(rawAppointment) && !result2.allDay && this._workSpace.supportAllDayRow()) {
      resultedEndDate = this._workSpace.calculateEndDate(resultedStartDate);
    }
    if (appointment.allDay && !this._workSpace.supportAllDayRow() && !this._workSpace.keepOriginalHours()) {
      const dateCopy = new Date(resultedStartDate);
      dateCopy.setHours(0);
      resultedEndDate = new Date(dateCopy.getTime() + duration);
      if (0 !== resultedEndDate.getHours()) {
        resultedEndDate.setHours(this._getCurrentViewOption("endDayHour"));
      }
    }
    result2.startDate = dateUtilsTs.addOffsets(result2.startDate, [viewOffset]);
    result2.endDate = dateUtilsTs.addOffsets(resultedEndDate, [viewOffset]);
    const rawResult = result2.source();
    setResourceToAppointment(this.option("resources"), this.getResourceDataAccessors(), rawResult, targetCell.groups);
    return rawResult;
  }
  getTargetedAppointment(appointment, element) {
    const settings = utils2.dataAccessors.getAppointmentSettings(element);
    const info = utils2.dataAccessors.getAppointmentInfo(element);
    const appointmentIndex = renderer_default(element).data(this._appointments._itemIndexKey());
    const adapter = createAppointmentAdapter(appointment, this._dataAccessors, this.timeZoneCalculator);
    const targetedAdapter = adapter.clone();
    if (this._isAgenda() && adapter.isRecurrent) {
      const {
        agendaSettings
      } = settings;
      targetedAdapter.startDate = ExpressionUtils.getField(this._dataAccessors, "startDate", agendaSettings);
      targetedAdapter.endDate = ExpressionUtils.getField(this._dataAccessors, "endDate", agendaSettings);
    } else if (settings) {
      targetedAdapter.startDate = info ? info.sourceAppointment.startDate : adapter.startDate;
      targetedAdapter.endDate = info ? info.sourceAppointment.endDate : adapter.endDate;
    }
    const rawTargetedAppointment = targetedAdapter.source();
    if (element) {
      this.setTargetedAppointmentResources(rawTargetedAppointment, element, appointmentIndex);
    }
    if (info) {
      rawTargetedAppointment.displayStartDate = new Date(info.appointment.startDate);
      rawTargetedAppointment.displayEndDate = new Date(info.appointment.endDate);
    }
    return rawTargetedAppointment;
  }
  subscribe(subject, action) {
    this._subscribes[subject] = m_subscribes_default[subject] = action;
  }
  fire(subject) {
    const callback = this._subscribes[subject];
    const args = Array.prototype.slice.call(arguments);
    if (!isFunction(callback)) {
      throw ui_errors_default.Error("E1031", subject);
    }
    return callback.apply(this, args.slice(1));
  }
  getTargetCellData() {
    return this._workSpace.getDataByDroppableCell();
  }
  _updateAppointment(target, rawAppointment, onUpdatePrevented, dragEvent) {
    const updatingOptions = {
      newData: rawAppointment,
      oldData: extend({}, target),
      cancel: false
    };
    const performFailAction = (function(err) {
      if (onUpdatePrevented) {
        onUpdatePrevented.call(this);
      }
      if (err && "Error" === err.name) {
        throw err;
      }
    }).bind(this);
    this._actions[StoreEventNames.UPDATING](updatingOptions);
    if (dragEvent && !isDeferred(dragEvent.cancel)) {
      dragEvent.cancel = new Deferred();
    }
    return this._processActionResult(updatingOptions, function(canceled) {
      let deferred = new Deferred();
      if (!canceled) {
        this._expandAllDayPanel(rawAppointment);
        try {
          deferred = this.appointmentDataProvider.update(target, rawAppointment).done(() => {
            dragEvent && dragEvent.cancel.resolve(false);
          }).always((storeAppointment) => this._onDataPromiseCompleted(StoreEventNames.UPDATED, storeAppointment)).fail(() => performFailAction());
        } catch (err) {
          performFailAction(err);
          deferred.resolve();
        }
      } else {
        performFailAction();
        deferred.resolve();
      }
      return deferred.promise();
    });
  }
  _processActionResult(actionOptions, callback) {
    const deferred = new Deferred();
    const resolveCallback = (callbackResult) => {
      when(fromPromise(callbackResult)).always(deferred.resolve);
    };
    if (isPromise(actionOptions.cancel)) {
      when(fromPromise(actionOptions.cancel)).always((cancel2) => {
        if (!isDefined(cancel2)) {
          cancel2 = "rejected" === actionOptions.cancel.state();
        }
        resolveCallback(callback.call(this, cancel2));
      });
    } else {
      resolveCallback(callback.call(this, actionOptions.cancel));
    }
    return deferred.promise();
  }
  _expandAllDayPanel(appointment) {
    if (!this._isAllDayExpanded() && this.appointmentTakesAllDay(appointment)) {
      this._workSpace.option("allDayExpanded", true);
    }
  }
  _onDataPromiseCompleted(handlerName, storeAppointment, appointment) {
    const args = {
      appointmentData: appointment || storeAppointment
    };
    if (storeAppointment instanceof Error) {
      args.error = storeAppointment;
    } else {
      this._appointmentPopup.visible && this._appointmentPopup.hide();
    }
    this._actions[handlerName](args);
    this._fireContentReadyAction();
  }
  getAppointmentsInstance() {
    return this._appointments;
  }
  getLayoutManager() {
    return this._layoutManager;
  }
  getRenderingStrategyInstance() {
    return this.getLayoutManager().getRenderingStrategyInstance();
  }
  getActions() {
    return this._actions;
  }
  appointmentTakesAllDay(rawAppointment) {
    const appointment = createAppointmentAdapter(rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    return getAppointmentTakesAllDay(appointment, this._getCurrentViewOption("allDayPanelMode"));
  }
  dayHasAppointment(day, rawAppointment, trimTime3) {
    const getConvertedToTimeZone = (date) => this.timeZoneCalculator.createDate(date, {
      path: "toGrid"
    });
    const appointment = createAppointmentAdapter(rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    let startDate = new Date(appointment.startDate);
    let endDate = new Date(appointment.endDate);
    startDate = getConvertedToTimeZone(startDate);
    endDate = getConvertedToTimeZone(endDate);
    if (day.getTime() === endDate.getTime()) {
      return startDate.getTime() === endDate.getTime();
    }
    if (trimTime3) {
      day = date_default.trimTime(day);
      startDate = date_default.trimTime(startDate);
      endDate = date_default.trimTime(endDate);
    }
    const dayTimeStamp = day.getTime();
    const startDateTimeStamp = startDate.getTime();
    const endDateTimeStamp = endDate.getTime();
    return startDateTimeStamp <= dayTimeStamp && dayTimeStamp <= endDateTimeStamp;
  }
  setTargetedAppointmentResources(rawAppointment, element, appointmentIndex) {
    const groups = this._getCurrentViewOption("groups");
    if (null !== groups && void 0 !== groups && groups.length) {
      const resourcesSetter = this.getResourceDataAccessors().setter;
      const workSpace = this._workSpace;
      let getGroups;
      let setResourceCallback;
      if (this._isAgenda()) {
        getGroups = function() {
          const apptSettings = this.getLayoutManager()._positionMap[appointmentIndex];
          return getCellGroups(apptSettings[0].groupIndex, this.getWorkSpace().option("groups"));
        };
        setResourceCallback = function(_, group) {
          resourcesSetter[group.name](rawAppointment, group.id);
        };
      } else {
        getGroups = function() {
          const setting = utils2.dataAccessors.getAppointmentSettings(element) || {};
          return workSpace.getCellDataByCoordinates({
            left: setting.left,
            top: setting.top
          }).groups;
        };
        setResourceCallback = function(field, value2) {
          resourcesSetter[field](rawAppointment, value2);
        };
      }
      each(getGroups.call(this), setResourceCallback);
    }
  }
  getStartViewDate() {
    var _this$_workSpace4;
    return null === (_this$_workSpace4 = this._workSpace) || void 0 === _this$_workSpace4 ? void 0 : _this$_workSpace4.getStartViewDate();
  }
  getEndViewDate() {
    return this._workSpace.getEndViewDate();
  }
  showAddAppointmentPopup(cellData, cellGroups) {
    const appointmentAdapter = createAppointmentAdapter({}, this._dataAccessors, this.timeZoneCalculator);
    appointmentAdapter.allDay = cellData.allDay;
    appointmentAdapter.startDate = this.timeZoneCalculator.createDate(cellData.startDate, {
      path: "fromGrid"
    });
    appointmentAdapter.endDate = this.timeZoneCalculator.createDate(cellData.endDate, {
      path: "fromGrid"
    });
    const resultAppointment = extend(appointmentAdapter.source(), cellGroups);
    this.showAppointmentPopup(resultAppointment, true);
  }
  showAppointmentPopup(rawAppointment, createNewAppointment, rawTargetedAppointment) {
    const newRawTargetedAppointment = _extends({}, rawTargetedAppointment);
    if (newRawTargetedAppointment) {
      delete newRawTargetedAppointment.displayStartDate;
      delete newRawTargetedAppointment.displayEndDate;
    }
    const appointment = createAppointmentAdapter(newRawTargetedAppointment || rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    const newTargetedAppointment = extend({}, rawAppointment, newRawTargetedAppointment);
    const isCreateAppointment = createNewAppointment ?? isEmptyObject(rawAppointment);
    if (isEmptyObject(rawAppointment)) {
      rawAppointment = this.createPopupAppointment();
    }
    if (isCreateAppointment) {
      delete this._editAppointmentData;
      this._editing.allowAdding && this._appointmentPopup.show(rawAppointment, {
        isToolbarVisible: true,
        action: ACTION_TO_APPOINTMENT.CREATE
      });
    } else {
      this._checkRecurringAppointment(rawAppointment, newTargetedAppointment, appointment.startDate, () => {
        this._editAppointmentData = rawAppointment;
        this._appointmentPopup.show(rawAppointment, {
          isToolbarVisible: this._editing.allowUpdating,
          action: ACTION_TO_APPOINTMENT.UPDATE
        });
      }, false, true);
    }
  }
  createPopupAppointment() {
    const result2 = {};
    const toMs27 = date_default.dateToMilliseconds;
    const startDate = new Date(this.option("currentDate"));
    const endDate = new Date(startDate.getTime() + this.option("cellDuration") * toMs27("minute"));
    ExpressionUtils.setField(this._dataAccessors, "startDate", result2, startDate);
    ExpressionUtils.setField(this._dataAccessors, "endDate", result2, endDate);
    return result2;
  }
  hideAppointmentPopup(saveChanges) {
    var _this$_appointmentPop3;
    if (null !== (_this$_appointmentPop3 = this._appointmentPopup) && void 0 !== _this$_appointmentPop3 && _this$_appointmentPop3.visible) {
      saveChanges && this._appointmentPopup.saveChangesAsync();
      this._appointmentPopup.hide();
    }
  }
  showAppointmentTooltip(appointment, element, targetedAppointment) {
    if (appointment) {
      const settings = utils2.dataAccessors.getAppointmentSettings(element);
      const appointmentConfig = {
        itemData: targetedAppointment || appointment,
        groupIndex: null === settings || void 0 === settings ? void 0 : settings.groupIndex,
        groups: this.option("groups")
      };
      const getAppointmentColor2 = this.createGetAppointmentColor();
      const deferredColor = getAppointmentColor2(appointmentConfig);
      const info = new AppointmentTooltipInfo(appointment, targetedAppointment, deferredColor);
      this.showAppointmentTooltipCore(element, [info]);
    }
  }
  createGetAppointmentColor() {
    return (appointmentConfig) => {
      const resourceConfig = {
        resources: this.option("resources"),
        dataAccessors: this.getResourceDataAccessors(),
        loadedResources: this.option("loadedResources"),
        resourceLoaderMap: this.option("resourceLoaderMap")
      };
      return getAppointmentColor(resourceConfig, appointmentConfig);
    };
  }
  showAppointmentTooltipCore(target, data2, options2) {
    const arg = {
      cancel: false,
      appointments: data2.map((item) => {
        const result2 = {
          appointmentData: item.appointment,
          currentAppointmentData: _extends({}, item.targetedAppointment),
          color: item.color
        };
        if (item.settings.info) {
          const {
            startDate,
            endDate
          } = item.settings.info.appointment;
          result2.currentAppointmentData.displayStartDate = startDate;
          result2.currentAppointmentData.displayEndDate = endDate;
        }
        return result2;
      }),
      targetElement: getPublicElement(target)
    };
    this._createActionByOption("onAppointmentTooltipShowing")(arg);
    if (this._appointmentTooltip.isAlreadyShown(target)) {
      this.hideAppointmentTooltip();
    } else {
      this._processActionResult(arg, (canceled) => {
        !canceled && this._appointmentTooltip.show(target, data2, _extends({}, this._getExtraAppointmentTooltipOptions(), options2));
      });
    }
  }
  hideAppointmentTooltip() {
    this._appointmentTooltip && this._appointmentTooltip.hide();
  }
  scrollToTime(hours, minutes, date) {
    ui_errors_default.log("W0002", "dxScheduler", "scrollToTime", "21.1", 'Use the "scrollTo" method instead');
    this._workSpace.scrollToTime(hours, minutes, date);
  }
  scrollTo(date, groups, allDay) {
    this._workSpace.scrollTo(date, groups, allDay);
  }
  _isHorizontalVirtualScrolling() {
    const scrolling = this.option("scrolling");
    const {
      orientation,
      mode
    } = scrolling;
    const isVirtualScrolling = "virtual" === mode;
    return isVirtualScrolling && ("horizontal" === orientation || "both" === orientation);
  }
  addAppointment(rawAppointment) {
    const appointment = createAppointmentAdapter(rawAppointment, this._dataAccessors, this.timeZoneCalculator);
    appointment.text = appointment.text || "";
    const serializedAppointment = appointment.source(true);
    const addingOptions = {
      appointmentData: serializedAppointment,
      cancel: false
    };
    this._actions[StoreEventNames.ADDING](addingOptions);
    return this._processActionResult(addingOptions, (canceled) => {
      if (canceled) {
        return new Deferred().resolve();
      }
      this._expandAllDayPanel(serializedAppointment);
      return this.appointmentDataProvider.add(serializedAppointment).always((storeAppointment) => this._onDataPromiseCompleted(StoreEventNames.ADDED, storeAppointment));
    });
  }
  updateAppointment(target, appointment) {
    return this._updateAppointment(target, appointment);
  }
  deleteAppointment(rawAppointment) {
    const deletingOptions = this.fireOnAppointmentDeleting(rawAppointment);
    this.processDeleteAppointment(rawAppointment, deletingOptions);
  }
  fireOnAppointmentDeleting(rawAppointment, targetedAppointmentData) {
    const deletingOptions = {
      appointmentData: rawAppointment,
      targetedAppointmentData,
      cancel: false
    };
    this._actions[StoreEventNames.DELETING](deletingOptions);
    return deletingOptions;
  }
  processDeleteAppointment(rawAppointment, deletingOptions) {
    this._processActionResult(deletingOptions, function(canceled) {
      if (!canceled) {
        this.appointmentDataProvider.remove(rawAppointment).always((storeAppointment) => this._onDataPromiseCompleted(StoreEventNames.DELETED, storeAppointment, rawAppointment));
      }
    });
  }
  deleteRecurrence(appointment, date, recurrenceEditMode) {
    this._checkRecurringAppointment(appointment, {}, date, () => {
      this.processDeleteAppointment(appointment, {
        cancel: false
      });
    }, true, false, null, recurrenceEditMode);
  }
  focus() {
    if (this._editAppointmentData) {
      this._appointments.focus();
    } else {
      this._workSpace.focus();
    }
  }
  getFirstDayOfWeek() {
    return isDefined(this.option("firstDayOfWeek")) ? this.option("firstDayOfWeek") : date_default3.firstDayOfWeekIndex();
  }
  _validateKeyFieldIfAgendaExist() {
    if (!this.appointmentDataProvider.isDataSourceInit) {
      return;
    }
    const hasAgendaView = !!this._getViewByName("agenda");
    const isKeyExist = !!this.appointmentDataProvider.keyName;
    if (hasAgendaView && !isKeyExist) {
      ui_errors_default.log("W1023");
    }
  }
  _getDragBehavior() {
    return this._workSpace.dragBehavior;
  }
  getViewOffsetMs() {
    const offsetFromOptions = this._getCurrentViewOption("offset");
    return this.normalizeViewOffsetValue(offsetFromOptions);
  }
  normalizeViewOffsetValue(viewOffset) {
    if (!isDefined(viewOffset) || this.currentViewType === VIEWS.AGENDA) {
      return 0;
    }
    return viewOffset * toMs26("minute");
  }
  validateOptions() {
    const currentViewOptions = _extends({}, this.option(), {
      startDayHour: this._getCurrentViewOption("startDayHour"),
      endDayHour: this._getCurrentViewOption("endDayHour"),
      offset: this._getCurrentViewOption("offset"),
      cellDuration: this._getCurrentViewOption("cellDuration")
    });
    const validationResult = this._optionsValidator.validate(currentViewOptions);
    this._optionsValidatorErrorHandler.handleValidationResult(validationResult);
  }
};
Scheduler.include(data_helper_default);
component_registrator_default("dxScheduler", Scheduler);
var m_scheduler_default = Scheduler;

// ../../../../../../node_modules/devextreme/esm/ui/scheduler.js
var scheduler_default = m_scheduler_default;

// ../../../../../../node_modules/devextreme-vue/esm/core/strategy/vue2/index.js
var vue2_exports = {};
__export(vue2_exports, {
  createComponent: () => createComponent,
  createConfigurationComponent: () => createConfigurationComponent,
  createExtensionComponent: () => createExtensionComponent
});
function createComponent() {
  throw new Error("Since v23.2, devextreme-vue no longer supports Vue 2. See: https://supportcenter.devexpress.com/ticket/details/T1186771");
}
function createConfigurationComponent() {
}
function createExtensionComponent() {
}

// ../../../../../../node_modules/devextreme-vue/esm/core/strategy/vue3/index.js
var vue3_exports = {};
__export(vue3_exports, {
  createComponent: () => createComponent2,
  createConfigurationComponent: () => createConfigurationComponent2,
  createExtensionComponent: () => createExtensionComponent2
});

// ../../../../../../node_modules/devextreme/esm/events/index.js
var on = events_engine_default.on;
var one = events_engine_default.one;
var off = events_engine_default.off;
var trigger = events_engine_default.trigger;
var triggerHandler = events_engine_default.triggerHandler;
var Event = events_engine_default.Event;

// ../../../../../../node_modules/devextreme-vue/esm/core/helpers.js
function getTemplatePropName(props, templateName) {
  for (const propName in props) {
    if (props[propName] === templateName) {
      return propName;
    }
  }
  return templateName;
}
function uppercaseFirst(value2) {
  return value2[0].toUpperCase() + value2.substr(1);
}
function lowercaseFirst(value2) {
  return value2[0].toLowerCase() + value2.substr(1);
}
function camelize2(value2) {
  return lowercaseFirst(value2.split("-").map((v) => uppercaseFirst(v)).join(""));
}
function toComparable2(value2) {
  return value2 instanceof Date ? value2.getTime() : value2;
}
function isEqual(value1, value2) {
  if (toComparable2(value1) === toComparable2(value2)) {
    return true;
  }
  if (Array.isArray(value1) && Array.isArray(value2)) {
    return value1.length === 0 && value2.length === 0;
  }
  return false;
}
function forEachChildNode(el, callback) {
  Array.prototype.slice.call(el.childNodes).forEach(callback);
}
function allKeysAreEqual(obj1, obj2) {
  const obj1Keys = Object.keys(obj1);
  if (obj1Keys.length !== Object.keys(obj2).length) {
    return false;
  }
  for (const key of obj1Keys) {
    if (!obj2.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}
function getOptionValue(options2, optionPath) {
  let value2 = options2;
  optionPath.split(".").forEach((p2) => {
    const optionInfo = getOptionInfo(p2);
    if (value2) {
      value2 = optionInfo.isCollection ? value2[optionInfo.name] && value2[optionInfo.name][optionInfo.index] : value2[optionInfo.name];
    }
  });
  return value2;
}
function getOptionInfo(name2) {
  const parts = name2.split("[");
  if (parts.length === 1) {
    return {
      isCollection: false,
      name: name2,
      fullName: name2
    };
  }
  return {
    isCollection: true,
    name: parts[0],
    fullName: name2,
    index: Number(parts[1].slice(0, -1))
  };
}

// ../../../../../../node_modules/devextreme-vue/esm/core/children-processing.js
function pullAllChildren(directChildren, allChildren, config3) {
  if (!directChildren || directChildren.length === 0) {
    return;
  }
  pullConfigComponents(directChildren, allChildren, config3);
}
function isFragment(node) {
  const { patchFlag } = node;
  return patchFlag === 128 || patchFlag === 256 || patchFlag === 64 || patchFlag === -2;
}
function pullConfigComponents(children, nodes, ownerConfig) {
  children.forEach((node) => {
    if (isFragment(node) && Array.isArray(node.children)) {
      pullConfigComponents(node.children, nodes, ownerConfig);
    }
    if (!isFragment(node)) {
      nodes.push(node);
    }
    if (!node) {
      return;
    }
    const componentInfo = getComponentInfo(node);
    if (!componentInfo || !componentInfo.$_optionName) {
      return;
    }
    const componentChildren = configurationChildren(node);
    const initialValues = {
      ...componentInfo.$_predefinedProps,
      ...getNormalizedProps(node.props || {})
    };
    const config3 = ownerConfig.createNested(componentInfo.$_optionName, initialValues, componentInfo.$_isCollectionItem, componentInfo.$_expectedChildren);
    node.$_config = config3;
    node.$_innerChanges = {};
    if (componentChildren) {
      pullConfigComponents(componentChildren, nodes, config3);
    }
  });
}

// ../../../../../../node_modules/devextreme-vue/esm/core/vue-helper.js
var VMODEL_NAME = "modelValue";
function getChildren(component) {
  if (!hasChildren(component) || !component.$_config) {
    return [];
  }
  const children = component.$.subTree && component.$.subTree.children;
  if (!Array.isArray(children)) {
    return [];
  }
  return children.filter((child) => {
    if (!isFragment(child)) {
      return child;
    }
  });
}
function getComponentInfo(component) {
  return getConfigurationOptions(component);
}
function getNormalizedProps(props) {
  const result2 = {};
  for (const propName in props) {
    if (props.hasOwnProperty(propName)) {
      result2[camelize2(propName)] = props[propName];
    }
  }
  return result2;
}
function configurationChildren(component) {
  if (!component.children || !component.children.default) {
    return [];
  }
  return findConfigurationComponents(component.children.default());
}
function configurationDefaultTemplate(node) {
  if (!node.children || node.children === "object" || !node.children.default) {
    return;
  }
  return hasInlineTemplate(node.children.default()) ? node.children.default : void 0;
}
function configurationTemplate(node) {
  return configurationDefaultTemplate(node);
}
function declaredTemplates(component) {
  return component.$slots;
}
function defaultSlots(component) {
  const templates = declaredTemplates(component);
  if (!templates.default) {
    return [];
  }
  return templates.default();
}
function mount2(options2, parent, el) {
  const template = createApp(options2);
  template.provide("eventBus", parent.eventBus);
  setAppContext(template, parent);
  return template.mount(el);
}
function getComponentProps(component) {
  const props = component.$.vnode.props || {};
  return getNormalizedProps(props);
}
function getNodeOptions(component) {
  if (component.$) {
    return component.$.vnode;
  }
  return component;
}
function getNodeTypeOfComponent(component) {
  return component.$.vnode.type;
}
function getVModelValue(options2) {
  return options2[VMODEL_NAME];
}
function setCompatOptions(component) {
  component.compatConfig = {
    MODE: 3
  };
}
function setVModel(config3) {
  const eventName = `update:${VMODEL_NAME}`;
  config3.model.prop = VMODEL_NAME;
  config3.model.event = eventName;
  config3.props.modelValue = {};
  config3.emits = { ...config3.emits, [`${eventName}`]: null };
}
function setCustomPluginsData(appContext, parentAppContext) {
  for (const prop in parentAppContext) {
    if (!appContext.hasOwnProperty(prop) && parentAppContext.hasOwnProperty(prop)) {
      appContext[prop] = parentAppContext[prop];
    }
  }
}
function setAppContext(template, parent) {
  template._context.components = Object.assign(parent.$.appContext.components, template._context.components);
  Object.setPrototypeOf(template._context.provides, Object.getPrototypeOf(parent.$.provides));
  Object.assign(template._context.provides, parent.$.appContext.provides);
  template._context.config = parent.$.appContext.config;
  template._context.directives = parent.$.appContext.directives;
  template._context.mixins = parent.$.appContext.mixins;
  setCustomPluginsData(template._context.app, parent.$.appContext.app);
}
function findConfigurationComponents(children) {
  return children.filter((child) => {
    if (isFragment(child)) {
      return findConfigurationComponents(child.children || []);
    }
    const childType = child.type;
    if (childType && typeof childType === "object" && childType.$_optionName) {
      delete child.$_config;
      delete child.$_innerChanges;
      return child;
    }
  });
}
function hasInlineTemplate(children) {
  let hasTemplate3 = false;
  children.forEach((child) => {
    if (!isConfiguration(child) && !isFragment(child) && !isComment(child)) {
      hasTemplate3 = true;
    }
  });
  return hasTemplate3;
}
function isComment(node) {
  return node.type === Comment || node.type.toString() === "Symbol()" && !node.children;
}
function isConfiguration(child) {
  return child.type && typeof child.type === "object" && child.type.$_optionName;
}
function getConfigurationOptions(node) {
  return node.type;
}
function hasChildren(component) {
  return component.$.vnode && component.$.vnode.children && component.$.vnode.children.default;
}

// ../../../../../../node_modules/devextreme-vue/esm/core/config.js
var config2 = {
  deepWatch: false
};
function getOption(optionName) {
  return config2[optionName];
}

// ../../../../../../node_modules/devextreme-vue/esm/core/configuration.js
var Configuration = class _Configuration {
  constructor(updateFunc, name2, initialValues, expectedChildren, isCollectionItem, collectionItemIndex, ownerConfig) {
    this._updateFunc = updateFunc;
    this._name = name2;
    this._initialValues = initialValues || {};
    this._nestedConfigurations = [];
    this._isCollectionItem = !!isCollectionItem;
    this._collectionItemIndex = collectionItemIndex;
    this._expectedChildren = expectedChildren || {};
    this._ownerConfig = ownerConfig;
    this._componentChanges = [];
    this.updateValue = this.updateValue.bind(this);
  }
  get name() {
    return this._name;
  }
  get fullName() {
    return this._name && this._isCollectionItem ? `${this._name}[${this._collectionItemIndex}]` : this._name;
  }
  get componentsCountChanged() {
    return this._componentChanges;
  }
  cleanComponentsCountChanged() {
    this._componentChanges = [];
  }
  get fullPath() {
    return this._ownerConfig && this._ownerConfig.fullPath ? `${this._ownerConfig.fullPath}.${this.fullName}` : this.fullName;
  }
  get ownerConfig() {
    return this._ownerConfig;
  }
  get options() {
    return this._options;
  }
  get initialValues() {
    return this._initialValues;
  }
  get expectedChildren() {
    return this._expectedChildren;
  }
  get nested() {
    return this._nestedConfigurations;
  }
  get prevNestedOptions() {
    return this._prevNestedConfigOptions;
  }
  get collectionItemIndex() {
    return this._collectionItemIndex;
  }
  get isCollectionItem() {
    return this._isCollectionItem;
  }
  get updateFunc() {
    return this._updateFunc;
  }
  init(options2) {
    this._options = options2 || [];
  }
  set emitOptionChanged(handler) {
    this._emitOptionChanged = handler;
  }
  setPrevNestedOptions(value2) {
    this._prevNestedConfigOptions = value2;
  }
  onOptionChanged(args) {
    if (isEqual(args.value, args.previousValue)) {
      return;
    }
    this._onOptionChanged(args.fullName.split("."), args);
  }
  cleanNested() {
    this._nestedConfigurations = [];
  }
  createNested(name2, initialValues, isCollectionItem, expectedChildren) {
    const expected = this._expectedChildren[name2];
    let actualName = name2;
    let actualIsCollectionItem = isCollectionItem;
    if (expected) {
      actualIsCollectionItem = expected.isCollectionItem;
      if (expected.optionName) {
        actualName = expected.optionName;
      }
    }
    let collectionItemIndex = -1;
    if (actualIsCollectionItem && actualName) {
      collectionItemIndex = this._nestedConfigurations.filter((c) => c._name && c._name === actualName).length;
    }
    const configuration = new _Configuration(this._updateFunc, actualName, initialValues, expectedChildren, actualIsCollectionItem, collectionItemIndex, this);
    this._nestedConfigurations.push(configuration);
    return configuration;
  }
  updateValue(nestedName, value2) {
    const fullName = [this.fullPath, nestedName].filter((n) => n).join(".");
    this._updateFunc(fullName, value2);
  }
  getNestedOptionValues() {
    const values = {};
    this._nestedConfigurations.forEach((o) => {
      if (!o._name) {
        return;
      }
      const nestedValue = { ...o.initialValues, ...o.getNestedOptionValues() };
      if (!nestedValue) {
        return;
      }
      if (!o._isCollectionItem) {
        values[o._name] = nestedValue;
      } else {
        let arr = values[o._name];
        if (!arr || !Array.isArray(arr)) {
          arr = [];
          values[o._name] = arr;
        }
        arr.push(nestedValue);
      }
    });
    return values;
  }
  getOptionsToWatch() {
    const blackList = {};
    this._nestedConfigurations.forEach((c) => c._name && (blackList[c._name] = true));
    return this._options.filter((o) => !blackList[o]);
  }
  _onOptionChanged(optionRelPath, args) {
    if (optionRelPath.length === 0) {
      return;
    }
    const optionInfo = getOptionInfo(optionRelPath[0]);
    if (optionInfo.isCollection || optionRelPath.length > 1) {
      const nestedConfig = this._getNestedConfig(optionInfo.fullName);
      if (nestedConfig) {
        nestedConfig._onOptionChanged(optionRelPath.slice(1), args);
        return;
      }
      this._tryEmitOptionChanged(optionInfo.name, args.component.option(this.fullPath ? `${this.fullPath}.${optionInfo.name}` : optionInfo.name));
    } else {
      this._tryEmitOptionChanged(optionInfo.name, args.value);
    }
  }
  _getNestedConfig(fullName) {
    for (const nestedConfig of this._nestedConfigurations) {
      if (nestedConfig.fullName === fullName) {
        return nestedConfig;
      }
    }
    return void 0;
  }
  _tryEmitOptionChanged(name2, value2) {
    if (this._emitOptionChanged) {
      this._emitOptionChanged(name2, value2);
    }
  }
};
function bindOptionWatchers(config3, vueInstance, innerChanges) {
  const targets = config3 && config3.getOptionsToWatch();
  if (targets) {
    targets.forEach((optionName) => {
      vueInstance.$watch(optionName, (value2) => {
        const rawValue = toRaw(value2);
        if (!innerChanges.hasOwnProperty(optionName) || innerChanges[optionName] !== rawValue) {
          config3.updateValue(optionName, value2);
        }
        delete innerChanges[optionName];
      }, { deep: getOption("deepWatch") });
    });
  }
}
function hasProp(vueInstance, propName) {
  const { props } = vueInstance.$options;
  return props && props.hasOwnProperty(propName);
}
function hasVModelValue(options2, props, vnode) {
  var _a;
  return options2.model && props.hasOwnProperty(VMODEL_NAME) && ((_a = vnode == null ? void 0 : vnode.props) == null ? void 0 : _a.hasOwnProperty(VMODEL_NAME));
}
function setEmitOptionChangedFunc(config3, vueInstance, innerChanges) {
  config3.emitOptionChanged = (name2, value2) => {
    var _a;
    const props = vueInstance.$props;
    const vnode = (_a = vueInstance == null ? void 0 : vueInstance.$) == null ? void 0 : _a.vnode;
    if (hasProp(vueInstance, name2) && !isEqual(value2, props[name2]) && vueInstance.$emit) {
      innerChanges[name2] = toRaw(value2);
      const eventName = name2 === "value" && hasVModelValue(vueInstance.$options, props, vnode) ? `update:${VMODEL_NAME}` : `update:${name2}`;
      vueInstance.$emit(eventName, value2);
    }
  };
}
var configuration_default = Configuration;

// ../../../../../../node_modules/devextreme-vue/esm/core/configuration-component.js
function getConfig(vueInstance) {
  const componentOptions = getNodeOptions(vueInstance);
  if (!componentOptions) {
    return;
  }
  return componentOptions.$_config || vueInstance.$_config;
}
function getInnerChanges(vueInstance) {
  const componentOptions = getNodeOptions(vueInstance);
  if (!componentOptions) {
    return;
  }
  return componentOptions.$_innerChanges || vueInstance.$_innerChanges;
}
function initOptionChangedFunc(config3, props, vueInstance, innerChanges) {
  if (!config3) {
    return;
  }
  config3.init(Object.keys(props));
  if (vueInstance) {
    setEmitOptionChangedFunc(config3, vueInstance, innerChanges);
  }
}
function getComponentInfo2({ name: name2, isCollectionItem, ownerConfig }, removed) {
  const parentPath = ownerConfig && ownerConfig.fullPath;
  const optionPath = name2 && parentPath ? `${parentPath}.${name2}` : name2 || "";
  return {
    optionPath,
    isCollection: isCollectionItem,
    removed
  };
}
function initDxConfiguration() {
  return defineComponent({
    beforeMount() {
      const thisComponent = this;
      const config3 = getConfig(thisComponent);
      const innerChanges = getInnerChanges(thisComponent);
      initOptionChangedFunc(config3, getNodeTypeOfComponent(thisComponent).props, thisComponent, innerChanges);
      bindOptionWatchers(config3, this, innerChanges);
    },
    mounted() {
      if (this.$parent.$_instance) {
        this.$parent.$_config.componentsCountChanged.push(getComponentInfo2(getConfig(this)));
      }
    },
    beforeUnmount() {
      const config3 = getConfig(this);
      if (config3) {
        this.$parent.$_config.componentsCountChanged.push(getComponentInfo2(config3, true));
      }
    },
    render() {
      return null;
    }
  });
}

// ../../../../../../node_modules/devextreme-vue/esm/core/constants.js
var DX_TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var DX_REMOVE_EVENT = "dxremove";

// ../../../../../../node_modules/devextreme-vue/esm/core/templates-discovering.js
var TEMPLATE_PROP = "template";
function asConfigurable(component) {
  const componentOptions = component;
  if (!componentOptions) {
    return;
  }
  if (!componentOptions.$_config || !componentOptions.$_config.name) {
    return void 0;
  }
  return componentOptions;
}
function hasTemplate2(component) {
  return TEMPLATE_PROP in component.type.props && configurationTemplate(component);
}
function discover(component) {
  const templates = {};
  const namedTeplates = declaredTemplates(component);
  for (const slotName in namedTeplates) {
    if (slotName === "default" && component.$slots.default) {
      continue;
    }
    const slot = namedTeplates[slotName];
    if (!slot) {
      continue;
    }
    templates[slotName] = slot;
  }
  const componentChildren = getChildren(component);
  for (const childComponent of componentChildren) {
    const configurable = asConfigurable(childComponent);
    if (!configurable) {
      continue;
    }
    const defaultSlot = configurationDefaultTemplate(childComponent);
    if (!defaultSlot || !hasTemplate2(childComponent)) {
      continue;
    }
    const templateName = `${configurable.$_config.fullPath}.${TEMPLATE_PROP}`;
    templates[templateName] = defaultSlot;
  }
  return templates;
}
function clearConfiguration(content) {
  const newContent = [];
  content.forEach((item) => {
    const configurable = getConfigurationOptions(item);
    if (!configurable || !configurable.$_optionName) {
      newContent.push(item);
    }
  });
  return newContent;
}
function mountTemplate(getSlot, parent, data2, name2, placeholder) {
  return mount2({
    name: name2,
    inject: ["eventBus"],
    created() {
      this.eventBus.add(this.$_updatedHandler);
    },
    mounted() {
      data2.onRendered();
    },
    unmounted() {
      this.eventBus.remove(this.$_updatedHandler);
    },
    methods: {
      $_updatedHandler() {
        this.$forceUpdate();
      }
    },
    render: () => {
      const content = clearConfiguration(getSlot()(data2));
      if (!content) {
        return h("div");
      }
      return content.length > 1 ? content : content[0];
    }
  }, parent, placeholder);
}

// ../../../../../../node_modules/devextreme-vue/esm/core/templates-manager.js
var TemplatesManager = class {
  constructor(component) {
    this._slots = {};
    this._templates = {};
    this._isDirty = false;
    this._component = component;
    this.discover();
  }
  discover() {
    this._slots = {
      ...discover(this._component)
    };
    if (!allKeysAreEqual(this._templates, this._slots)) {
      this._prepareTemplates();
    }
  }
  get templates() {
    return this._templates;
  }
  get isDirty() {
    return this._isDirty;
  }
  resetDirtyFlag() {
    this._isDirty = false;
  }
  _prepareTemplates() {
    this._templates = {};
    for (const name2 of Object.keys(this._slots)) {
      this._templates[name2] = this.createDxTemplate(name2);
    }
    this._isDirty = true;
  }
  createDxTemplate(name2) {
    return {
      render: (data2) => {
        const rendered = ((onRendered, counter = 0) => () => {
          if (counter === 1 && onRendered) {
            onRendered();
          }
          counter++;
        })(data2.onRendered);
        const scopeData = { data: data2.model, index: data2.index, onRendered: rendered };
        const placeholder = document.createElement("div");
        const container = data2.container.get ? data2.container.get(0) : data2.container;
        container.appendChild(placeholder);
        const mountedTemplate = mountTemplate(() => this._slots[name2], this._component, scopeData, name2, placeholder);
        const element = mountedTemplate.$el;
        container.removeChild(placeholder);
        while (placeholder.firstChild) {
          container.appendChild(placeholder.firstChild);
        }
        dom_adapter_default.setClass(element, DX_TEMPLATE_WRAPPER_CLASS, true);
        if (element.nodeType === Node.TEXT_NODE) {
          const removalListener = document.createElement(container.nodeName === "TABLE" ? "tbody" : "span");
          removalListener.style.display = "none";
          container.appendChild(removalListener);
          one(removalListener, DX_REMOVE_EVENT, mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate));
        } else {
          one(element, DX_REMOVE_EVENT, mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate));
        }
        rendered();
        return element;
      }
    };
  }
};

// ../../../../../../node_modules/devextreme-vue/esm/core/component.js
var includeAttrs = ["id", "class", "style"];
config_default({
  buyNowLink: "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeVue.aspx"
});
function getAttrs(attrs, dxClasses) {
  const attributes = {};
  includeAttrs.forEach((attr) => {
    const attrValue = attrs[attr];
    if (attrValue) {
      attributes[attr] = attr === "class" && dxClasses.length ? `${attrValue} ${dxClasses.join(" ")}` : attrValue;
    }
  });
  return attributes;
}
function initBaseComponent() {
  return defineComponent({
    inheritAttrs: false,
    data() {
      return {
        eventBus: callbacks_default()
      };
    },
    provide() {
      return {
        eventBus: this.eventBus
      };
    },
    render() {
      const thisComponent = this;
      const children = [];
      const dxClasses = pickOutDxClasses(this.$el) || [];
      if (thisComponent.$_config.cleanNested) {
        thisComponent.$_config.cleanNested();
      }
      pullAllChildren(defaultSlots(this), children, thisComponent.$_config);
      this.$_processChildren(children);
      return h("div", {
        ...getAttrs(this.$attrs, dxClasses)
      }, children);
    },
    beforeUpdate() {
      const thisComponent = this;
      thisComponent.$_config.setPrevNestedOptions(thisComponent.$_config.getNestedOptionValues());
    },
    updated() {
      const thisComponent = this;
      const nodes = cleanWidgetNode(this.$el);
      getChildren(thisComponent).forEach((child) => {
        var _a;
        initOptionChangedFunc(child.$_config, child.type.props || {}, (_a = child == null ? void 0 : child.component) == null ? void 0 : _a.proxy, child.$_innerChanges);
      });
      thisComponent.$_templatesManager.discover();
      thisComponent.$_instance.beginUpdate();
      this.$_applyConfigurationChanges();
      if (thisComponent.$_templatesManager.isDirty) {
        thisComponent.$_instance.option("integrationOptions.templates", thisComponent.$_templatesManager.templates);
        const { props } = thisComponent.$.vnode;
        for (const name2 of Object.keys(thisComponent.$_templatesManager.templates)) {
          thisComponent.$_instance.option(getTemplatePropName(props, name2), name2);
        }
        thisComponent.$_templatesManager.resetDirtyFlag();
      }
      for (const name2 of Object.keys(thisComponent.$_pendingOptions)) {
        thisComponent.$_instance.option(name2, thisComponent.$_pendingOptions[name2]);
      }
      thisComponent.$_pendingOptions = {};
      thisComponent.$_instance.endUpdate();
      restoreNodes(this.$el, nodes);
      this.eventBus.fire();
    },
    beforeUnmount() {
      const thisComponent = this;
      const instance = thisComponent.$_instance;
      if (instance) {
        triggerHandler(this.$el, DX_REMOVE_EVENT);
        instance.dispose();
      }
    },
    created() {
      const thisComponent = this;
      const props = getComponentProps(this);
      thisComponent.$_config = new configuration_default((n, v) => {
        if (Array.isArray(v)) {
          thisComponent.$_instance.option(n, v);
        } else {
          thisComponent.$_pendingOptions[n === VMODEL_NAME ? "value" : n] = v;
        }
      }, null, props && { ...props }, thisComponent.$_expectedChildren);
      thisComponent.$_innerChanges = {};
      thisComponent.$_config.init(this.$props && Object.keys(this.$props));
    },
    methods: {
      $_applyConfigurationChanges() {
        const thisComponent = this;
        thisComponent.$_config.componentsCountChanged.forEach(({ optionPath, isCollection, removed }) => {
          const options2 = thisComponent.$_config.getNestedOptionValues();
          if (!isCollection && removed) {
            thisComponent.$_instance.resetOption(optionPath);
          } else {
            thisComponent.$_instance.option(optionPath, getOptionValue(options2, optionPath));
          }
        });
        thisComponent.$_config.cleanComponentsCountChanged();
      },
      $_createWidget(element) {
        const thisComponent = this;
        thisComponent.$_pendingOptions = {};
        thisComponent.$_templatesManager = new TemplatesManager(this);
        const widgetConfig = thisComponent.$_config;
        if (widgetConfig.initialValues.hasOwnProperty(VMODEL_NAME)) {
          widgetConfig.initialValues.value = getVModelValue(widgetConfig.initialValues);
        }
        const options2 = {
          templatesRenderAsynchronously: thisComponent.$_hasAsyncTemplate,
          ...getComponentProps(thisComponent),
          ...widgetConfig.initialValues,
          ...widgetConfig.getNestedOptionValues(),
          ...this.$_getIntegrationOptions()
        };
        const instance = new thisComponent.$_WidgetClass(element, options2);
        thisComponent.$_instance = instance;
        instance.on("optionChanged", (args) => widgetConfig.onOptionChanged(args));
        setEmitOptionChangedFunc(widgetConfig, thisComponent, thisComponent.$_innerChanges);
        bindOptionWatchers(widgetConfig, thisComponent, thisComponent.$_innerChanges);
        this.$_createEmitters(instance);
      },
      $_getIntegrationOptions() {
        const thisComponent = this;
        const result2 = {
          integrationOptions: {
            watchMethod: this.$_getWatchMethod()
          },
          ...this.$_getExtraIntegrationOptions()
        };
        if (thisComponent.$_templatesManager.isDirty) {
          const { templates } = thisComponent.$_templatesManager;
          result2.integrationOptions.templates = templates;
          const { props } = thisComponent.$.vnode;
          for (const name2 of Object.keys(templates)) {
            result2[getTemplatePropName(props, name2)] = name2;
          }
          thisComponent.$_templatesManager.resetDirtyFlag();
        }
        return result2;
      },
      $_getWatchMethod() {
        return (valueGetter, valueChangeCallback, options2) => {
          options2 = options2 || {};
          if (!options2.skipImmediate) {
            valueChangeCallback(valueGetter());
          }
          return this.$watch(() => valueGetter(), (newValue, oldValue) => {
            if (toComparable2(oldValue) !== toComparable2(newValue) || options2.deep) {
              valueChangeCallback(newValue);
            }
          }, {
            deep: options2.deep
          });
        };
      },
      $_getExtraIntegrationOptions() {
        return {};
      },
      $_processChildren(_children) {
      },
      $_createEmitters(instance) {
        if (this.$attrs) {
          Object.keys(this.$attrs).forEach((listenerName) => {
            const eventName = camelize2(listenerName);
            instance.on(eventName, (e) => {
              this.$emit(listenerName, e);
            });
          });
        }
      }
    }
  });
}
function cleanWidgetNode(node) {
  const removedNodes = [];
  forEachChildNode(node, (childNode) => {
    const parent = childNode.parentNode;
    const isExtension = childNode.hasAttribute && childNode.hasAttribute("isExtension");
    if ((childNode.nodeName === "#comment" || isExtension) && parent) {
      removedNodes.push(childNode);
      parent.removeChild(childNode);
    }
  });
  return removedNodes;
}
function pickOutDxClasses(el) {
  return el && Array.from(el.classList).filter((item) => item.startsWith("dx-"));
}
function restoreNodes(el, nodes) {
  nodes.forEach((node) => {
    el.appendChild(node);
  });
}
function initDxComponent() {
  return defineComponent({
    extends: initBaseComponent(),
    methods: {
      $_getExtraIntegrationOptions() {
        return {
          onInitializing() {
            this.beginUpdate();
          }
        };
      },
      $_processChildren(children) {
        children.forEach((childNode) => {
          if (!childNode || typeof childNode !== "object") {
            return;
          }
          childNode.$_hasOwner = true;
        });
      }
    },
    mounted() {
      const nodes = cleanWidgetNode(this.$el);
      const thisComponent = this;
      this.$_createWidget(this.$el);
      thisComponent.$_instance.endUpdate();
      restoreNodes(this.$el, nodes);
      if (this.$slots && this.$slots.default) {
        getChildren(thisComponent).forEach((child) => {
          const childExtenton = child;
          if (childExtenton && childExtenton.$_isExtension) {
            childExtenton.$_attachTo(this.$el);
          }
        });
      }
    }
  });
}

// ../../../../../../node_modules/devextreme-vue/esm/core/extension-component.js
function initDxExtensionComponent() {
  return defineComponent({
    extends: initBaseComponent(),
    mounted() {
      this.$el.setAttribute("isExtension", "true");
      const nodeOptions = getNodeOptions(this);
      nodeOptions.$_isExtension = true;
      nodeOptions.$_attachTo = this.attachTo.bind(this);
      if (nodeOptions && nodeOptions.$_hasOwner) {
        return;
      }
      this.attachTo(this.$el);
    },
    methods: {
      attachTo(element) {
        this.$_createWidget(element);
      }
    }
  });
}

// ../../../../../../node_modules/devextreme-vue/esm/core/strategy/vue3/index.js
function createComponent2(config3) {
  config3.extends = initDxComponent();
  setCompatOptions(config3);
  if (config3.model) {
    setVModel(config3);
  }
  return defineComponent(config3);
}
function createConfigurationComponent2(config3) {
  config3.extends = initDxConfiguration();
  setCompatOptions(config3);
  return defineComponent(config3);
}
function createExtensionComponent2(config3) {
  config3.extends = initDxExtensionComponent();
  setCompatOptions(config3);
  return defineComponent(config3);
}

// ../../../../../../node_modules/devextreme-vue/esm/core/version.js
function getVueVersion() {
  const currentVersion = version;
  return currentVersion ? Number(currentVersion.split(".")[0]) : 2;
}
function isVue3() {
  return getVueVersion() === 3;
}

// ../../../../../../node_modules/devextreme-vue/esm/core/index.js
var strategy3 = isVue3() ? vue3_exports : vue2_exports;
var { createComponent: createComponent3 } = strategy3;
var { createConfigurationComponent: createConfigurationComponent3 } = strategy3;
var { createExtensionComponent: createExtensionComponent3 } = strategy3;

// ../../../../../../node_modules/devextreme-vue/esm/scheduler.js
var DxScheduler = createComponent3({
  props: {
    accessKey: String,
    adaptivityEnabled: Boolean,
    allDayExpr: String,
    allDayPanelMode: String,
    appointmentCollectorTemplate: {},
    appointmentDragging: Object,
    appointmentTemplate: {},
    appointmentTooltipTemplate: {},
    cellDuration: Number,
    crossScrollingEnabled: Boolean,
    currentDate: [Date, Number, String],
    currentView: String,
    customizeDateNavigatorText: Function,
    dataCellTemplate: {},
    dataSource: {},
    dateCellTemplate: {},
    dateSerializationFormat: String,
    descriptionExpr: String,
    disabled: Boolean,
    dropDownAppointmentTemplate: {},
    editing: [Boolean, Object],
    elementAttr: Object,
    endDateExpr: String,
    endDateTimeZoneExpr: String,
    endDayHour: Number,
    firstDayOfWeek: {
      type: Number,
      validator: (v) => typeof v !== "number" || [
        0,
        1,
        2,
        3,
        4,
        5,
        6
      ].indexOf(v) !== -1
    },
    focusStateEnabled: Boolean,
    groupByDate: Boolean,
    groups: Array,
    height: [Function, Number, String],
    hint: String,
    indicatorUpdateInterval: Number,
    max: [Date, Number, String],
    maxAppointmentsPerCell: [Number, String],
    min: [Date, Number, String],
    noDataText: String,
    offset: Number,
    onAppointmentAdded: Function,
    onAppointmentAdding: Function,
    onAppointmentClick: Function,
    onAppointmentContextMenu: Function,
    onAppointmentDblClick: Function,
    onAppointmentDeleted: Function,
    onAppointmentDeleting: Function,
    onAppointmentFormOpening: Function,
    onAppointmentRendered: Function,
    onAppointmentTooltipShowing: Function,
    onAppointmentUpdated: Function,
    onAppointmentUpdating: Function,
    onCellClick: Function,
    onCellContextMenu: Function,
    onContentReady: Function,
    onDisposing: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    recurrenceEditMode: String,
    recurrenceExceptionExpr: String,
    recurrenceRuleExpr: String,
    remoteFiltering: Boolean,
    resourceCellTemplate: {},
    resources: Array,
    rtlEnabled: Boolean,
    scrolling: Object,
    selectedCellData: Array,
    shadeUntilCurrentTime: Boolean,
    showAllDayPanel: Boolean,
    showCurrentTimeIndicator: Boolean,
    startDateExpr: String,
    startDateTimeZoneExpr: String,
    startDayHour: Number,
    tabIndex: Number,
    textExpr: String,
    timeCellTemplate: {},
    timeZone: String,
    useDropDownViewSwitcher: Boolean,
    views: Array,
    visible: Boolean,
    width: [Function, Number, String]
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:adaptivityEnabled": null,
    "update:allDayExpr": null,
    "update:allDayPanelMode": null,
    "update:appointmentCollectorTemplate": null,
    "update:appointmentDragging": null,
    "update:appointmentTemplate": null,
    "update:appointmentTooltipTemplate": null,
    "update:cellDuration": null,
    "update:crossScrollingEnabled": null,
    "update:currentDate": null,
    "update:currentView": null,
    "update:customizeDateNavigatorText": null,
    "update:dataCellTemplate": null,
    "update:dataSource": null,
    "update:dateCellTemplate": null,
    "update:dateSerializationFormat": null,
    "update:descriptionExpr": null,
    "update:disabled": null,
    "update:dropDownAppointmentTemplate": null,
    "update:editing": null,
    "update:elementAttr": null,
    "update:endDateExpr": null,
    "update:endDateTimeZoneExpr": null,
    "update:endDayHour": null,
    "update:firstDayOfWeek": null,
    "update:focusStateEnabled": null,
    "update:groupByDate": null,
    "update:groups": null,
    "update:height": null,
    "update:hint": null,
    "update:indicatorUpdateInterval": null,
    "update:max": null,
    "update:maxAppointmentsPerCell": null,
    "update:min": null,
    "update:noDataText": null,
    "update:offset": null,
    "update:onAppointmentAdded": null,
    "update:onAppointmentAdding": null,
    "update:onAppointmentClick": null,
    "update:onAppointmentContextMenu": null,
    "update:onAppointmentDblClick": null,
    "update:onAppointmentDeleted": null,
    "update:onAppointmentDeleting": null,
    "update:onAppointmentFormOpening": null,
    "update:onAppointmentRendered": null,
    "update:onAppointmentTooltipShowing": null,
    "update:onAppointmentUpdated": null,
    "update:onAppointmentUpdating": null,
    "update:onCellClick": null,
    "update:onCellContextMenu": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:recurrenceEditMode": null,
    "update:recurrenceExceptionExpr": null,
    "update:recurrenceRuleExpr": null,
    "update:remoteFiltering": null,
    "update:resourceCellTemplate": null,
    "update:resources": null,
    "update:rtlEnabled": null,
    "update:scrolling": null,
    "update:selectedCellData": null,
    "update:shadeUntilCurrentTime": null,
    "update:showAllDayPanel": null,
    "update:showCurrentTimeIndicator": null,
    "update:startDateExpr": null,
    "update:startDateTimeZoneExpr": null,
    "update:startDayHour": null,
    "update:tabIndex": null,
    "update:textExpr": null,
    "update:timeCellTemplate": null,
    "update:timeZone": null,
    "update:useDropDownViewSwitcher": null,
    "update:views": null,
    "update:visible": null,
    "update:width": null
  },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = scheduler_default;
    this.$_hasAsyncTemplate = false;
    this.$_expectedChildren = {
      appointmentDragging: { isCollectionItem: false, optionName: "appointmentDragging" },
      editing: { isCollectionItem: false, optionName: "editing" },
      resource: { isCollectionItem: true, optionName: "resources" },
      scrolling: { isCollectionItem: false, optionName: "scrolling" },
      view: { isCollectionItem: true, optionName: "views" }
    };
  }
});
var DxAppointmentDragging = createConfigurationComponent3({
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:autoScroll": null,
    "update:data": null,
    "update:group": null,
    "update:onAdd": null,
    "update:onDragEnd": null,
    "update:onDragMove": null,
    "update:onDragStart": null,
    "update:onRemove": null,
    "update:scrollSensitivity": null,
    "update:scrollSpeed": null
  },
  props: {
    autoScroll: Boolean,
    data: {},
    group: String,
    onAdd: Function,
    onDragEnd: Function,
    onDragMove: Function,
    onDragStart: Function,
    onRemove: Function,
    scrollSensitivity: Number,
    scrollSpeed: Number
  }
});
DxAppointmentDragging.$_optionName = "appointmentDragging";
var DxEditing = createConfigurationComponent3({
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowAdding": null,
    "update:allowDeleting": null,
    "update:allowDragging": null,
    "update:allowResizing": null,
    "update:allowTimeZoneEditing": null,
    "update:allowUpdating": null
  },
  props: {
    allowAdding: Boolean,
    allowDeleting: Boolean,
    allowDragging: Boolean,
    allowResizing: Boolean,
    allowTimeZoneEditing: Boolean,
    allowUpdating: Boolean
  }
});
DxEditing.$_optionName = "editing";
var DxResource = createConfigurationComponent3({
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowMultiple": null,
    "update:colorExpr": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:fieldExpr": null,
    "update:label": null,
    "update:useColorAsDefault": null,
    "update:valueExpr": null
  },
  props: {
    allowMultiple: Boolean,
    colorExpr: String,
    dataSource: {},
    displayExpr: [Function, String],
    fieldExpr: String,
    label: String,
    useColorAsDefault: Boolean,
    valueExpr: [Function, String]
  }
});
DxResource.$_optionName = "resources";
DxResource.$_isCollectionItem = true;
var DxScrolling = createConfigurationComponent3({
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:mode": null
  },
  props: {
    mode: String
  }
});
DxScrolling.$_optionName = "scrolling";
var DxView = createConfigurationComponent3({
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:agendaDuration": null,
    "update:allDayPanelMode": null,
    "update:appointmentCollectorTemplate": null,
    "update:appointmentTemplate": null,
    "update:appointmentTooltipTemplate": null,
    "update:cellDuration": null,
    "update:dataCellTemplate": null,
    "update:dateCellTemplate": null,
    "update:dropDownAppointmentTemplate": null,
    "update:endDayHour": null,
    "update:firstDayOfWeek": null,
    "update:groupByDate": null,
    "update:groupOrientation": null,
    "update:groups": null,
    "update:intervalCount": null,
    "update:maxAppointmentsPerCell": null,
    "update:name": null,
    "update:offset": null,
    "update:resourceCellTemplate": null,
    "update:scrolling": null,
    "update:startDate": null,
    "update:startDayHour": null,
    "update:timeCellTemplate": null,
    "update:type": null
  },
  props: {
    agendaDuration: Number,
    allDayPanelMode: String,
    appointmentCollectorTemplate: {},
    appointmentTemplate: {},
    appointmentTooltipTemplate: {},
    cellDuration: Number,
    dataCellTemplate: {},
    dateCellTemplate: {},
    dropDownAppointmentTemplate: {},
    endDayHour: Number,
    firstDayOfWeek: {
      type: Number,
      validator: (v) => typeof v !== "number" || [
        0,
        1,
        2,
        3,
        4,
        5,
        6
      ].indexOf(v) !== -1
    },
    groupByDate: Boolean,
    groupOrientation: String,
    groups: Array,
    intervalCount: Number,
    maxAppointmentsPerCell: [Number, String],
    name: String,
    offset: Number,
    resourceCellTemplate: {},
    scrolling: Object,
    startDate: [Date, Number, String],
    startDayHour: Number,
    timeCellTemplate: {},
    type: String
  }
});
DxView.$_optionName = "views";
DxView.$_isCollectionItem = true;
DxView.$_expectedChildren = {
  scrolling: { isCollectionItem: false, optionName: "scrolling" }
};
var scheduler_default2 = DxScheduler;
export {
  DxAppointmentDragging,
  DxEditing,
  DxResource,
  DxScheduler,
  DxScrolling,
  DxView,
  scheduler_default2 as default
};
/*! Bundled license information:

devextreme-vue/esm/core/strategy/vue2/index.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/helpers.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/children-processing.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/vue-helper.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/config.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/configuration.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/configuration-component.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/constants.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/templates-discovering.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/templates-manager.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/component.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/extension-component.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/strategy/vue3/index.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/version.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/core/index.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/esm/scheduler.js:
  (*!
   * devextreme-vue
   * Version: 24.1.6
   * Build date: Sat Sep 14 2024
   *
   * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)
*/
//# sourceMappingURL=devextreme-vue_scheduler.js.map
